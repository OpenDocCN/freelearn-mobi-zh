- en: Chapter 4. SpriteKit Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. SpriteKit 基础
- en: After an entire chapter of theory, we have finally reached the chapter where
    we will be creating a game. I am sure that this is a moment you have been waiting
    for and your fingers are aching to write some code and make a game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一整章的理论之后，我们终于到达了将创建游戏的一章。我相信这是你一直期待的时刻，你的手指都渴望编写一些代码并制作一个游戏。
- en: In this chapter, you will create a small and basic game using SpriteKit. We
    will see how to create the main menu of the game, and you will learn how to transition
    from the main menu scene to the gameplay scene, where all of the gameplay code
    will be written.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用 SpriteKit 创建一个小型且基本的游戏。我们将看到如何创建游戏的主菜单，你将学习如何从主菜单场景切换到游戏玩法场景，所有游戏玩法代码都将在此场景中编写。
- en: In the gameplay scene, we will add sprites, such as the background and hero,
    first. We will then create a small physics engine to make the hero move around.
    Then, we will add in the enemies, and move them too. Next, we will make the hero
    and the enemies shoot at each other. We will detect collision between the hero's
    rockets and the enemies, and between the enemies' bullets and the hero. For each
    enemy the hero shoots, we will get one point, but if any of the enemies go past
    the left of the screen, it will be game over. If the current high score is greater
    than the previous score saved, then your current score will be saved as the new
    high score. Once the game is over, the player can click on the button to go back
    to the main menu to start the game. I hope you are excited! Let's finally jump
    in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏玩法场景中，我们首先添加精灵，如背景和英雄。然后，我们将创建一个小的物理引擎来让英雄移动。接着，我们将添加敌人，并移动它们。接下来，我们将让英雄和敌人互相射击。我们将检测英雄的火箭与敌人之间的碰撞，以及敌人的子弹与英雄之间的碰撞。对于英雄射出的每一个敌人，我们将得到一分，但如果任何敌人穿过屏幕的左侧，游戏将结束。如果当前最高分高于之前保存的分数，那么你的当前分数将被保存为新的最高分。一旦游戏结束，玩家可以点击按钮返回主菜单以开始游戏。我希望你很兴奋！让我们最终跳进去。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Introduction to SpriteKit and SKScene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpriteKit 和 SKScene 简介
- en: Adding a main menu scene and a gameplay scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加主菜单场景和游戏玩法场景
- en: Adding and moving the Hero sprite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加并移动英雄精灵
- en: Creating interactivity with touches
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过触摸创建交互性
- en: A simple physics engine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的物理引擎
- en: Spawning enemies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成敌人
- en: Firing hero rockets and enemy bullets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射英雄火箭和敌人子弹
- en: Collision detection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Scoring and game over conditions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分和游戏结束条件
- en: Displaying, saving, and retrieving the score
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示、保存和检索分数
- en: Introduction to SpriteKit and SKScene
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpriteKit 和 SKScene 简介
- en: We have already seen in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*, how to create a SpriteKit project. Just to jog your memory,
    I will show you once again how to create a project. Click on **Xcode**, and then
    on **Create a new Xcode Project**. Then, on the left-hand side panel, navigate
    under **iOS**, and then under **Application** and select **Game**. Then click
    on **Next**. Give a new name to the project. Select the language as **Swift**,
    the game technology as **SpriteKit**, the device as **iPad**, and then click on
    **Next**. Select the location where you want the project folder to be created
    and click on **Create**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 1 章](ch01.html "第 1 章. 入门")，*入门* 中看到，如何创建 SpriteKit 项目。为了唤醒你的记忆，我将再次向你展示如何创建项目。点击
    **Xcode**，然后点击 **创建一个新的 Xcode 项目**。然后，在左侧面板下，导航到 **iOS**，然后到 **应用程序** 并选择 **游戏**。然后点击
    **下一步**。为新项目命名。选择语言为 **Swift**，游戏技术为 **SpriteKit**，设备为 **iPad**，然后点击 **下一步**。选择你想要创建项目文件夹的位置，然后点击
    **创建**。
- en: 'You will see that the majority of the project structure remains similar to
    the SingleView project we saw in the previous chapter. We have the `GameScene.sks`,
    `GameScene.swift`, and `GameViewController.swift` files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，项目结构的大部分与我们在上一章中看到的 SingleView 项目相似。我们有 `GameScene.sks`、`GameScene.swift`
    和 `GameViewController.swift` 文件：
- en: '`GameScene.sks`: This is a serialized `SpriteKitScene` file. This is used to
    create SKScenes visually without writing code. So, for example, you can drag-and-drop
    images and design them as buttons, and by clicking on them, you can make them
    perform different functions. But since we will be writing it all in code, we won''t
    be using this file to create the interface of the game.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameScene.sks`: 这是一个序列化的 `SpriteKitScene` 文件。这个文件用于在无需编写代码的情况下可视地创建 SKScenes。例如，你可以拖放图片并将它们设计成按钮，点击它们时，你可以让它们执行不同的功能。但由于我们将全部使用代码编写，我们不会使用这个文件来创建游戏的界面。'
- en: '`GameScene.swift`: This is inherited from SKScene. SKScenes are the building
    blocks of games. This class is called once the application view is loaded. You
    can create SKScene files to create the main menu Scene, gameplay scene, options
    scene, and so on. In fact, we will later rename the `GameScene.swift` file to
    `MainMenuScene.swift` and create a new scene called `GamePlayScene`, where will
    write our gameplay code.![Introduction to SpriteKit and SKScene](img/B04014_04_01.jpg)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameScene.swift`：这个类继承自SKScene。SKScenes是游戏的构建块。这个类在应用程序视图加载后调用。你可以创建SKScene文件来创建主菜单场景、游戏玩法场景、选项场景等等。实际上，我们稍后会重命名`GameScene.swift`文件为`MainMenuScene.swift`，并创建一个新的场景`GamePlayScene`，我们将在这里编写我们的游戏玩法代码。![SpriteKit和SKScene的介绍](img/B04014_04_01.jpg)'
- en: '`GameViewController.swift`: This class is similar to the `ViewController.swift`
    file we saw in the previous chapter. In the `Main.Storyboard` file, you will see
    that there is a `GameViewControllerScene` file instead of `ViewController`, but
    the structure is very similar to it. If you click on **GameViewController**, you
    can see that it calls the `GameViewController` class on the **Utility** panel
    under the **Identity** inspector. Refer to the preceding diagram.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameViewController.swift`：这个类与我们之前章节中看到的`ViewController.swift`文件类似。在`Main.Storyboard`文件中，你会看到有一个`GameViewControllerScene`文件而不是`ViewController`，但结构非常相似。如果你点击**GameViewController**，你可以在**Identity**检查器的**Utility**面板下看到它调用了`GameViewController`类。参考前面的图示。'
- en: Now, open the `GameViewController.swift` file. You will see some new functions
    and some older functions that we saw in `ViewController.swift`. You will also
    notice that SpriteKit has been imported. We will need to import SpriteKit in all
    the classes in which we want to use its features. All classes and objects that
    are part of SpriteKit start with the prefix `SK`, so SpriteKit Scenes are `SKScene`,
    sprites are `SKSpriteNode`, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`GameViewController.swift`文件。你会看到一些新函数和一些我们在`ViewController.swift`中看到的旧函数。你还会注意到已经导入了SpriteKit。我们需要在所有想要使用其功能的类中导入SpriteKit。所有属于SpriteKit的类和对象都以前缀`SK`开头，所以SpriteKit场景是`SKScene`，精灵是`SKSpriteNode`等等。
- en: A `SpriteKitNode` or `SKNode` is the basic building block required for creating
    any content in SpriteKit, but unlike an `SKScene` or `SKSpriteNode`, it doesn't
    draw any visual content. However, both `SKScene` and `SKSpriteNode` are child
    classes of `SKNode`. So, if `SKScene` is the building block of any game, `SKNode`
    is the basic building block of SpriteKit itself. A detailed explanation is provided
    under the SpriteKit section in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpriteKitNode`或`SKNode`是创建SpriteKit中任何内容所需的基本构建块，但与`SKScene`或`SKSpriteNode`不同，它不绘制任何可视内容。然而，`SKScene`和`SKSpriteNode`都是`SKNode`的子类。因此，如果`SKScene`是任何游戏的构建块，那么`SKNode`就是SpriteKit本身的基本构建块。详细的解释可以在[第1章](ch01.html
    "第1章。入门")的SpriteKit部分找到，*入门*。'
- en: 'After importing the SpriteKit, we see that an extension of SKNode is created
    with a class function called `unarchivedFromFile`, which takes a string and returns
    an SKNode. The following function is used to load the `.sks` file we saw earlier:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 导入SpriteKit后，我们看到创建了一个名为`unarchivedFromFile`的类函数的SKNode扩展，它接受一个字符串并返回一个SKNode。以下函数用于加载我们之前看到的`.sks`文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the extension, we see the actual class of `GameViewController`. It is
    still inheriting from `UIViewController`. Similar to the `ViewController.swift`
    file, the first function called here is `viewDidLoad`, which is the function that
    is called as soon as the view gets loaded. The `super.viewDidLoad` function is
    called, which calls the `viewDidLoad` of the parent class. Then, the `GameScene.sks`
    file is loaded using the extension that was created earlier. The `if let` statement
    checks if the object scene is empty or not. If it is not empty, then the code
    in the `if` block will be executed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后，我们看到实际的`GameViewController`类。它仍然继承自`UIViewController`。类似于`ViewController.swift`文件，这里首先调用的函数是`viewDidLoad`，这是视图加载后立即调用的函数。调用了`super.viewDidLoad`函数，该函数调用父类的`viewDidLoad`。然后，使用之前创建的扩展加载了`GameScene.sks`文件。`if
    let`语句检查对象场景是否为空。如果不为空，则执行`if`块中的代码。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`extension`: In Swift, you can add functionality to an existing class. In the
    preceding case, we are adding a new function called `unarchivedFromFile` to the
    `SKNode` class, which unarchives files and returns an SKScene. This function is
    used to unarchive the `SKS` file in the `viewDidLoad` function in the following
    code.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`extension`：在 Swift 中，你可以向现有类添加功能。在前面的例子中，我们向 `SKNode` 类添加了一个名为 `unarchivedFromFile`
    的新函数，该函数解档文件并返回一个 SKScene。这个函数用于在以下代码的 `viewDidLoad` 函数中解档 `SKS` 文件。'
- en: '`if let`: This checks if the object scene is empty or not. If it is not empty,
    then the code in the `if` block will be executed.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let`：这检查对象场景是否为空。如果不为空，则执行 `if` 块中的代码。'
- en: '`as`: This operator is used to downcast SKView since it is actually a subclass
    of `UIView`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`：这个运算符用于向下转换 SKView，因为它实际上是 `UIView` 的子类。'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A new variable, `skView` is created and the current view is assigned to it by
    type casting it as an SKView since the root view of `GameViewController` is an
    SKView.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新变量 `skView`，并将当前视图通过类型转换赋值给它，因为 `GameViewController` 的根视图是一个 SKView。
- en: Then, the `showsFPS` and `showsNodeCount` properties of the scene are set to
    `true`, which will show the **FPS** and **Node Count** on the bottom-right of
    the screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，场景的 `showsFPS` 和 `showsNodeCount` 属性被设置为 `true`，这将显示屏幕右下角的 **FPS** 和 **节点计数**。
- en: The `ignoreSiblingOrder` property is set to `true`, meaning that if one or more
    objects are at the same depth, then it won't prioritize between them and all objects
    will be drawn at the same depth.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ignoreSiblingOrder` 属性设置为 `true`，意味着如果一个或多个对象处于相同的深度，则不会在它们之间进行优先级排序，所有对象将以相同的深度绘制。
- en: The value of **Z order,** or depth order, decides which object is at the front
    and which object is at the back of the screen. The object with the smallest **Z**
    value is kept at the back of the screen and the object the with highest value
    is the closest to the screen. If no Z order value is assigned to an object, SpriteKit
    will assume that this object is above the previous object added. That is why in
    all games, the background is added first so that it is at the lowest Z order and
    other objects such as the hero are added next. If you were to add the hero first
    and then the background, the hero would be at the lowest Z order and the background
    image that covers the whole screen would be above it. You might think that there
    is something wrong with the code or SpriteKit since the hero is not being displayed
    only the background. The fact is that the hero is there but he is behind the background.
    So, be careful about Z orders as this may lead to bugs or unexpected results in
    games.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z 坐标**，或深度顺序的值决定了哪个对象在屏幕的前面，哪个对象在后面。具有最小 **Z** 值的对象保持在屏幕后面，而具有最高值的对象是最接近屏幕的。如果一个对象没有分配
    Z 坐标值，SpriteKit 将假设该对象位于之前添加的对象之上。这就是为什么在所有游戏中，背景总是首先添加，以便它位于最低的 Z 顺序，然后添加其他对象，如英雄。如果你首先添加英雄然后添加背景，英雄将位于最低的
    Z 顺序，而覆盖整个屏幕的背景图像将位于其上方。你可能认为代码或 SpriteKit 出了问题，因为英雄没有显示，只有背景。事实是英雄确实在那里，但他位于背景之后。所以，要注意
    Z 顺序，因为这可能导致游戏中的错误或意外结果。'
- en: 'After setting the order, we can set the `scaleMode` property of the scene.
    Here, by default, it has been set to `AspectFill`. There are four modes: `AspectFill`,
    `Fill`, `AspectFit`, and `ResizeFill`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设置顺序后，我们可以设置场景的 `scaleMode` 属性。在这里，默认情况下它已被设置为 `AspectFill`。有四种模式：`AspectFill`、`Fill`、`AspectFit`
    和 `ResizeFill`。
- en: '`AspectFill`: This is the default mode when you create a new project. In this
    scale, both *x* and *y* scale factors are calculated and the large-scale factor
    is chosen to fill the view and maintain aspect ratio of the image. This will lead
    to cropping of the scene.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AspectFill`：这是创建新项目时的默认模式。在这个比例中，计算了 *x* 和 *y* 缩放因子，并选择较大的缩放因子来填充视图并保持图像的宽高比。这将导致场景裁剪。'
- en: Let us create a project and place characters at the top-right and bottom-left
    corners, and observe what happens when we move from the landscape mode to the
    portrait mode.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们创建一个项目，并将角色放置在右上角和左下角，观察当我们从横屏模式切换到竖屏模式时会发生什么。
- en: 'In the landscape mode, both characters are displayed as they should be. One
    at the bottom left and the other at the top-right corner of the screen, as shown
    in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在横屏模式下，两个角色都按照应有的方式显示。一个位于屏幕左下角，另一个位于右上角，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_02.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SpriteKit 和 SKScene 简介](img/B04014_04_02.jpg)'
- en: 'But in the portrait mode, they have gone out of bounds of the screen, as shown
    in the following screenshot:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在纵向模式下，它们已经超出了屏幕范围，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_03.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SpriteKit和SKScene简介](img/B04014_04_03.jpg)'
- en: '`Fill`: Both *x* and *y* axes are scaled to fill the view. The view is the
    region that is shown once you click on the view in the `Main.Storyboard` file.
    The aspect ratio of the image will change both in terms of the width and height,
    to fill the view.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fill`: 无论是*x*轴还是*y*轴，都会缩放以填充视图。视图是在你点击`Main.Storyboard`文件中的视图后显示的区域。图像的宽度和高度都会改变，以填充视图。'
- en: 'If we do the same test with `.Fill,` once again in landscape mode, the images
    appear to be normal, but in the portrait mode, the two images are in their respective
    locations, but they are squashed to fit, as shown in the following screenshot:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在横屏模式下再次使用`.Fill`进行相同的测试，图像看起来似乎是正常的，但在纵向模式下，两个图像分别位于它们的位置，但被压扁以适应，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_04.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SpriteKit和SKScene简介](img/B04014_04_04.jpg)'
- en: '`AspectFit`: Instead of the upper scale factor, the lower scale factor will
    be chosen to maintain the aspect ratio of the scene. This may lead to letterboxing
    of the scene, but all the content of the scene will be displayed and will be visible
    in view.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AspectFit`: 不是选择上缩放因子，而是选择下缩放因子以保持场景的宽高比。这可能会导致场景出现信封式显示，但场景中的所有内容都将显示，并且将在视图中可见。'
- en: 'With this mode, once again everything looks fine in the landscape mode, but
    then in the portrait mode, the image is not at all squared; the whole scene is
    scaled down to fit to the width of the screen. This will cause letterboxing on
    the top and bottom of the screen, as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种模式，在横屏模式下，一切看起来都很正常，但在纵向模式下，图像根本不是正方形的；整个场景被缩小以适应屏幕宽度。这将在屏幕的顶部和底部造成信封式显示，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_05.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SpriteKit和SKScene简介](img/B04014_04_05.jpg)'
- en: '`ResizeFill`: The scene is not scaled at all. It is just resized to fit the
    view. The images will maintain the original size and aspect ratios.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResizeFill`: 场景不会进行任何缩放。它只是调整大小以适应视图。图像将保持原始大小和宽高比。'
- en: 'Here, since the aspect ratio and scale are maintained, the bottom-left image
    is shown at the right position but the top-right image goes out of bounds of the
    screen, as shown in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，由于宽高比和缩放保持不变，左下角的图像显示在正确的位置，但右上角的图像超出了屏幕范围，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_06.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SpriteKit和SKScene简介](img/B04014_04_06.jpg)'
- en: 'Looking at the preceding screenshots of the four modes, we can see that not
    all sizes fit all. You need to tinker with the scale mode to best suit the needs
    of your game. Since our game is primarily designed to be played in the landscape
    mode, we will just disable the portrait mode. So, in the main project node, disable
    the **Portrait** mode and **Upside Down** by unchecking it in the **General**
    tab, as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面四种模式的截图，我们可以看到并非所有尺寸都适合。你需要调整缩放模式以最好地满足你游戏的需求。由于我们的游戏主要是为横屏模式设计的，所以我们只禁用纵向模式。因此，在主项目节点中，通过在**通用**选项卡中取消选中来禁用**纵向**模式和**颠倒**，如下面的截图所示：
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![SpriteKit和SKScene简介](img/B04014_04_07.jpg)'
- en: 'We will also be using `ResizeFill` as we will be providing separate images
    for Retina and NonRetina assets of the devices, so that aspect ratio is not affected,
    resulting in nice full-screen images instead of cropped or scaled images. So,
    in the `GameViewController` class, change the scale mode to `ResizeFill` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`ResizeFill`，因为我们将为设备的Retina和非Retina资产提供单独的图像，这样就不会影响宽高比，从而得到完整的全屏图像，而不是裁剪或缩放的图像。因此，在`GameViewController`类中，将缩放模式更改为以下内容：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, the scene is loaded and presented using the `presentScene` function
    of the `skView` object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`skView`对象的`presentScene`函数加载并呈现场景。
- en: Once the `GameScene.swift` file is presented, the `didMoveToView` function is
    called, which, as we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*, shows the `SKLabelNode` label showing the **Hello, World!**
    text, and each time you click on the screen, the `touchesBegan` function gets
    called, and at the location of the touch, a SKSpriteNode is created and an action
    is run on it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当`GameScene.swift`文件呈现时，会调用`didMoveToView`函数，正如我们在[第1章](ch01.html "第1章。入门")中看到的，*入门*，显示显示**Hello,
    World!**文本的`SKLabelNode`标签，并且每次点击屏幕时，都会调用`touchesBegan`函数，并在触摸位置创建一个`SKSpriteNode`并对其运行动作。
- en: 'There are three new functions: the `shouldAutoRotate` function, which is set
    to `true`, and will rotate the view if the device is rotated; the `supportedInterfaceOrientation`
    function, which checks for the orientation and aligns view accordingly; and the
    `prefersStatusBarHidden` function, which hides status bar elements, such as network
    and battery indicators on the top of the screen. You can enable or disable them
    depending upon your needs.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个新函数：`shouldAutoRotate`函数，设置为`true`，当设备旋转时将旋转视图；`supportedInterfaceOrientation`函数，检查方向并相应地对齐视图；以及`prefersStatusBarHidden`函数，隐藏状态栏元素，例如屏幕顶部的网络和电池指示器。您可以根据需要启用或禁用它们。
- en: We will now change the `GameScene` to start making our game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更改`GameScene`以开始制作我们的游戏。
- en: Adding a main menu scene
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加主菜单场景
- en: 'Let us make some changes to the `GameScene` class to make it our main menu
    scene:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`GameScene`类进行一些修改，使其成为我们的主菜单场景：
- en: Rename the file to `MainMenuScene.swift` by selecting the file in the project
    hierarchy in the project navigator.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目导航器中选择项目层次结构中的文件来将文件重命名为`MainMenuScene.swift`。
- en: Change the name of the class in the file to `MainMenuScene`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件中的类名更改为`MainMenuScene`。
- en: Delete all the lines of code inside `didMoveToView`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`didMoveToView`中的所有代码行。
- en: In the `touchesBegan` function, delete the code related to the adding of the
    sprite and the running of the action upon it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`touchesBegan`函数中，删除与添加精灵及其上运行动作相关的代码。
- en: Delete the `update` function as it is not required for the main menu scene.
    If required, we will add it later.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`update`函数，因为它对于主菜单场景不是必需的。如果需要，我们将在稍后添加它。
- en: 'The `MainMenuScene.swift` file should look like the following code snippet,
    as we deleted all the code from the `didMoveToView` function and modified the
    `touchedBegan` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainMenuScene.swift`文件应如下代码片段所示，因为我们已从`didMoveToView`函数中删除所有代码并修改了`touchedBegan`函数：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Delete the `GameScene.sks` file from the project hierarchy by moving it to **Trash**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其移动到**回收站**来从项目层次结构中删除`GameScene.sks`文件。
- en: We also need to make some changes to the `GameViewController.swift` file as
    well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对`GameViewController.swift`文件进行一些修改。
- en: Delete the extension created for SKNode
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除为SKNode创建的扩展。
- en: Remove the `if let` scene line and the opening and closing bracket since we
    will be calling the `MainMenuScene` class directly through code.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`if let`场景行以及开闭括号，因为我们将通过代码直接调用`MainMenuScene`类。
- en: 'Replace the above line with `let scene = MainMenuScene(size: view.bounds.size)`.
    The SKScene constructor takes the size of the screen, so here we get it from the
    `bounds.size` property of the view.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将上述行替换为`let scene = MainMenuScene(size: view.bounds.size)`。SKScene构造函数接受屏幕大小，因此我们在这里从视图的`bounds.size`属性中获取它。'
- en: Change `.AspectFill` to `.ResizeFill`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.AspectFill`更改为`.ResizeFill`。
- en: 'The rest of the file can remain the same. Now the `viewDidLoad` function should
    look like the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其他部分可以保持不变。现在`viewDidLoad`函数应如下所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's start adding content to the main menu scene next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始向主菜单场景添加内容。
- en: In the `MainMenuScene.swift` file in the `didMoveToView` function, we will first
    add the background image, then we will add a label that will display the name
    of the game, and then we will finally add the play button, which, if clicked,
    will launch `GamePlayScene` and start the game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainMenuScene.swift`文件中的`didMoveToView`函数中，我们首先添加背景图片，然后添加一个标签，用于显示游戏名称，最后添加播放按钮，点击后将启动`GamePlayScene`并开始游戏。
- en: 'To add the background image, add the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加背景图片，请添加以下代码：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We create a constant variable called `BG` and assign an image set named `BG`
    to it. Then, we position this image. For positioning the image, we need the size
    of the view. It is very simple to get the width and height of the view. We create
    a new constant called `viewSize` of type `CGView` and assign `view.bounds.size`
    to it. So, add the following at the start of the `didMoveToView` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`BG`的常量变量，并将其分配给一个名为`BG`的图像集。然后，我们定位这个图像。为了定位图像，我们需要视图的大小。获取视图的宽度和高度非常简单。我们创建了一个名为`viewSize`的新常量，其类型为`CGView`，并将其分配给`view.bounds.size`。因此，在`didMoveToView`函数的开始处添加以下代码：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now set the position of `BG`. To set the position, we assign `BG.position`
    equal to half of the width and half of the height of the size of the view. Whenever
    we need to assign or create a new `CGPoint` variable, we have to call CGPoint,
    and in the brackets provide the `x` and `y` values separated by a comma. The `x`
    value needs to be prefixed with `x` and then a colon and, similarly, the `y` value
    needs to be prefixed with `y` followed by a colon.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置`BG`的位置。要设置位置，我们将`BG.position`设置为视图宽度和高度的一半。每次我们需要分配或创建一个新的`CGPoint`变量时，我们必须调用CGPoint，并在括号内提供用逗号分隔的`x`和`y`值。`x`值需要以`x`开头，然后是一个冒号，同样，`y`值需要以`y`开头，然后是一个冒号。
- en: For the background to get displayed, we will have to call the `addChild` function
    on self, and pass in the background created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使背景显示出来，我们将在self上调用`addChild`函数，并传入创建的背景。
- en: If you run the game now, it will give errors as we have still not assigned an
    actual image to the project. For this, go to the `Resources` folder of this chapter
    and copy all the assets onto the desktop. This will contain all the assets that
    will be used in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行游戏，它将产生错误，因为我们还没有为项目分配实际的图像。为此，转到本章的`Resources`文件夹，并将所有资产复制到桌面。这将包含本章将使用的所有资产。
- en: Now, go to the `Images.xcassets` file in your project navigator, and right-click
    on the panel and select **New Image Set**, as shown in the following screenshot.
    A new file called `Image` will be created. Select and rename it to `BG`. When
    we call `BG` while creating the sprite for the background, we are actually referring
    to this file. So, if you name it incorrectly, the code will give errors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到项目导航器中的`Images.xcassets`文件，右键单击面板并选择**New Image Set**，如下面的截图所示。将创建一个名为`Image`的新文件。选择并重命名它为`BG`。当我们创建背景精灵时调用`BG`，我们实际上是在引用这个文件。因此，如果您命名错误，代码将产生错误。
- en: '![Adding a main menu scene](img/B04014_04_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![添加主菜单场景](img/B04014_04_08.jpg)'
- en: 'The file has placeholders for **1x**, **2x**, and **3x** images. Since we are
    making the game for the iPad, there are only two resolutions we have to worry
    about; the 1024 x 768 and 2048 x 1536 resolutions. Our BG is also of the same
    two resolutions. In the `Resources` folder, look for image files `Bg.png` and
    `Bg2.png`. Drag `Bg.png` to the **1x** box and `Bg2.png` to the **2x** box, as
    shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中有**1x**、**2x**和**3x**图像的占位符。由于我们正在为iPad制作游戏，我们只需要担心两种分辨率；1024 x 768和2048
    x 1536分辨率。我们的背景也是这两种分辨率之一。在`Resources`文件夹中，查找名为`Bg.png`和`Bg2.png`的图像文件。将`Bg.png`拖到**1x**框中，将`Bg2.png`拖到**2x**框中，如下面的截图所示：
- en: '![Adding a main menu scene](img/B04014_04_09.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![添加主菜单场景](img/B04014_04_09.jpg)'
- en: Now you can run the application and the screen will display the background image
    in all its glory. On the simulator, you can select **iPad2** or **iPadAir**, and
    you will see the image will fill the entire screen, as shown in the following
    screenshot. Make sure you are running in the landscape mode.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以运行应用程序，屏幕将显示背景图像的全貌。在模拟器中，您可以选择**iPad2**或**iPadAir**，您将看到图像将填充整个屏幕，如下面的截图所示。请确保您正在横屏模式下运行。
- en: '![Adding a main menu scene](img/B04014_04_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![添加主菜单场景](img/B04014_04_10.jpg)'
- en: 'Next we will add the label to display the name of the game. Labels are used
    to display text onto the screen. Add the following code to display the label right
    after we added the BG to the scene:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加标签以显示游戏名称。标签用于在屏幕上显示文本。在我们将背景添加到场景之后，添加以下代码以显示标签：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create a new constant called `myLabel` and call the constructor of `SKLabelNode`.
    It takes the name of the font we want to use to create the text, so we pass in
    `Chalkduster`, which is one of the default fonts in Mac. In `myLabel.text`, we
    pass in the actual text that we want to display. Next we assign the size of the
    font, its position, and add it to the current class as a child. To create text,
    we don't have to create an image set but we have to have the font in the system
    as it is automatically taken from the system's font directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的常量`myLabel`并调用`SKLabelNode`的构造函数。它需要我们想要用来创建文本的字体名称，所以我们传递`Chalkduster`，这是Mac中默认字体之一。在`myLabel.text`中，我们传递我们想要显示的实际文本。接下来我们分配字体的大小、位置，并将其作为子节点添加到当前类中。要创建文本，我们不需要创建图像集，但我们必须在系统中拥有该字体，因为它会自动从系统的字体目录中获取。
- en: Let us create the play button next. In the `Resources` folder, you will find
    `playBtn.png` and `playBtn2.png`. Similar to how we created an image set for `BG`,
    create one for the play button by naming the file `playBtn`. Drag the `playBtn.png`
    image to **1x** and `playBtn2.png` to **2x**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来创建播放按钮。在`Resources`文件夹中，你可以找到`playBtn.png`和`playBtn2.png`。类似于我们为`BG`创建图像集的方式，通过命名文件为`playBtn`来为播放按钮创建一个图像集。将`playBtn.png`图像拖到**1x**，将`playBtn2.png`图像拖到**2x**。
- en: For all the assets in the `Resources` folder, you will find two of each, one
    with the filename and the second one ending with a `2` at the end. Make sure,
    henceforth, that the regular filename asset is assigned to **1x** and one with
    the `2` at the end of the file is assigned to **2x**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Resources`文件夹中的所有资产，你将找到每个文件的两个副本，一个以文件名开头，另一个以文件名结尾的`2`。因此，确保从现在起，常规文件名的资产分配给**1x**，以`2`结尾的文件分配给**2x**。
- en: 'Now appropriate images are assigned to the `playBtn` image set. Add the following
    code right under where we added the code for the label:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，适当的图像已经分配给了`playBtn`图像集。在添加标签代码的下方添加以下代码：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `playBtn` image set is also a regular SKSpriteNode, so similar to how we
    added `BG`, we will assign the `playBtn` image set to the `playBtn` constant.
    Position it at the center of the view and then add it to the view.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`playBtn`图像集也是一个常规的`SKSpriteNode`，所以类似于我们添加`BG`的方式，我们将`playBtn`图像集分配给`playBtn`常量。将其放置在视图的中心，然后将其添加到视图中。'
- en: In addition to what we do usually, I have also assigned a name to the `playBtn`
    constant so that we can refer to it later, if needed. It is not necessary that
    you assign a string; you can even assign an integer value if you wish. It should
    be named something that you find easy to remember and associate the constant with.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们通常做的事情之外，我还为`playBtn`常量分配了一个名称，以便在需要时可以引用它。不一定非得分配一个字符串；如果你愿意，甚至可以分配一个整数值。应该给它起一个容易记住并且能够与常量相关联的名字。
- en: 'Now, if you build and run the project, it should look like the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行项目，它应该看起来像以下截图：
- en: '![Adding a main menu scene](img/B04014_04_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![添加主菜单场景](img/B04014_04_11.jpg)'
- en: 'Next, we will add code in the `touchesbegan` function to check whether the
    play button was pressed. In the `touchesbegan` function, we first check whether
    any object was touched on the screen, and then, if it was touched, we get the
    location of the touch. After getting the location, we add the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`touchesbegan`函数中添加代码以检查是否按下了播放按钮。在`touchesbegan`函数中，我们首先检查屏幕上是否被触摸了任何对象，然后，如果被触摸，我们获取触摸的位置。获取位置后，我们添加以下代码：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We create a new constant called `_node` of type `SKNode` and get the node that
    is at the touched location. We then check whether the name of the node pressed
    is `playBtn`, if it is pressed, then we create a constant named `scene` and assign
    `GameplayScene` to it, and then present the scene like we presented `MainMenuScene`
    in the `GameViewController` class. Since we have not created `GamePlayScene`,
    you will get an error. Don't worry, we will be creating it in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的常量`_node`，其类型为`SKNode`，并获取触摸位置处的节点。然后我们检查被按下的节点名称是否为`playBtn`，如果是，则创建一个名为`scene`的常量，并将其分配给`GameplayScene`，然后像在`GameViewController`类中展示`MainMenuScene`一样展示场景。由于我们尚未创建`GamePlayScene`，你将得到一个错误。别担心，我们将在下一节中创建它。
- en: The question mark after `self.view` checks if the view is empty or not. If it
    is empty, it will give an error, but since the view exists, it won't give an error.
    Let us create the gameplay scene so that we don't get errors saying that it doesn't
    exist.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.view`后面的问号检查视图是否为空。如果为空，它将给出错误，但由于视图存在，它不会给出错误。让我们创建游戏场景，这样我们就不会得到说它不存在的错误。'
- en: Adding a gameplay scene
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加游戏场景
- en: 'All this time, we have been modifying the files already included with the base
    project. Now we will create a new file in the project. Right-click on the base
    project folder and click on **New File**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们一直在修改基础项目中已包含的文件。现在我们将在项目中创建一个新文件。在基础项目文件夹上右键单击，然后单击**新建文件**：
- en: '![Adding a gameplay scene](img/B04014_04_12.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![添加游戏场景](img/B04014_04_12.jpg)'
- en: In the left panel, select **iOS** and select the Swift file, and then click
    on **Next**. It will ask for the name of the file, call it `GamePlayScene` and
    click on **Create**. This will create an empty Swift file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板中，选择**iOS**，选择Swift文件，然后单击**下一步**。它将要求输入文件名，命名为`GamePlayScene`，然后单击**创建**。这将创建一个空的Swift文件。
- en: 'Add the following code in it. This is the basic structure required whenever
    you create a new scene file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中添加以下代码。这是每次创建新的场景文件时所需的基本结构：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We first import SpriteKit, and then we create the class using the `class` keyword
    followed by the name of the class and inherit from `SKScene`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入SpriteKit，然后使用`class`关键字创建类，并使用类的名称继承自`SKScene`。
- en: Then we have the `required init` function after that. Since superclass `SKScene`
    implemented it, it has to be included in all the subclasses. This is a requirement,
    so there is no avoiding it, but we won't be using it for anything as we will be
    using the regular `init` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`required init`函数。由于超类`SKScene`实现了它，所以它必须包含在所有子类中。这是一个要求，所以无法避免，但我们不会用它做任何事情，因为我们将使用常规的`init`函数。
- en: The regular `init` function of an SKScene takes in the size of the view. Then
    we have to make sure we call the `super.init` function and pass the size of the
    view in it as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SKScene的常规`init`函数接受视图的大小。然后我们必须确保调用`super.init`函数，并在其中传递视图的大小。
- en: That's it, and we are ready to add some gameplay code in this class. You can
    check in the `MainMenuScene.swift` file that there are no errors and code is building
    properly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们就准备好在这个类中添加一些游戏代码了。你可以在`MainMenuScene.swift`文件中检查是否有错误，并且代码正在正确构建。
- en: In the `GamePlayScene.swift` file, first we have to create a global variable
    for the `viewSize`. So, between the class and the required `init` function, add
    `let viewSize:CGSize!` to make `viewSize` a global variable. Also, we use `let`
    instead of `var` as we know that the size of the view won't change in the middle
    of the game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GamePlayScene.swift`文件中，首先我们必须为`viewSize`创建一个全局变量。因此，在类和必需的`init`函数之间，添加`let
    viewSize:CGSize!`以使`viewSize`成为全局变量。此外，我们使用`let`而不是`var`，因为我们知道在游戏过程中视图的大小不会改变。
- en: Since we are not initializing the constant here, we have to use an exclamation
    mark at the end to tell Swift that we will initialize it and we know that the
    type that we will initialize will be `CGSize`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里没有初始化这个常量，我们必须在末尾使用感叹号来告诉Swift我们将初始化它，并且我们知道我们将初始化的类型将是`CGSize`。
- en: 'Initialize `viewSize` equal to the size that got passed in the `init` function.
    Add the following line after `super.init` is called:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将`viewSize`初始化为通过`init`函数传入的大小。在调用`super.init`之后添加以下行：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding a background and a hero
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加背景和英雄
- en: 'We are going add the background first, so we can copy and paste the same code
    from the `MainMenuScene` into the `init` function right after where we initialized
    `viewSize`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加背景，因此我们可以将`MainMenuScene`中的相同代码复制并粘贴到初始化`viewSize`之后的`init`函数中：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next we will add the hero sprite. Similar to how we created the `BG` image asset,
    create a new asset called `hero` and assign `hero.png` and `hero2.png` to the
    **1x** and **2x** slots.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加英雄精灵。类似于我们创建`BG`图像资源的方式，创建一个新的资源名为`hero`，并将`hero.png`和`hero2.png`分配给**1x**和**2x**槽位。
- en: 'Next we want the hero to be a global variable aswell, as we will need to refer
    to her outside of the `init` function. So, right under where we created the `viewSize`
    property, add the following line of code at the top of the class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望英雄也是一个全局变量，因为我们将在`init`函数之外引用她。所以，在创建`viewSize`属性之后，在类的顶部添加以下代码行：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, in the `init` function after where we added `BG`, add the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在添加了`BG`之后的`init`函数中，添加以下代码：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, as usual, we assign the image set `hero` to the constant, assign the position,
    and add it to the scene.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，像往常一样，我们将图像集`hero`分配给常量，分配位置，并将其添加到场景中。
- en: Similar to how we positioned the background, we position the hero, but instead
    of adding the hero in the center, we place her at a distance of one fourth the
    `viewSize` from the left of the screen.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们定位背景的方式类似，我们定位英雄，但不是将英雄添加到屏幕中心，而是将其放置在屏幕左侧距离`viewSize`的四分之一处。
- en: Updating the position of the hero
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新英雄的位置
- en: 'Next, let''s update the position of the hero. Let us add gravity to the scene
    so that she starts falling down once the game starts. For updating her position,
    we will use the `update` function. The `update` function gets called as soon as
    the class gets created and it gets called 60 times a second. So, add the `update`
    function to the class as follows. Call a `updateHero()` function in it, we will
    define this function shortly:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新英雄的位置。让我们在场景中添加重力，这样游戏开始后她就会开始下落。为了更新她的位置，我们将使用`update`函数。`update`函数在类创建时立即被调用，并且每秒被调用60次。因此，将`update`函数添加到类中，如下所示。在它里面调用一个`updateHero()`函数，我们将在稍后定义这个函数：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new global constant after the `let hero` line called `gravity` of
    type `CGPoint` and initialize it with `x` value `0` and a `y` value of `–1` as
    gravity only affects in the negative *y* direction:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`let hero`行之后创建一个新的全局常量，称为`gravity`，类型为`CGPoint`，并将其初始化为`x`值为`0`和`y`值为`-1`，因为重力只影响负`y`方向：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will also create a new function called `updateHero` in which we will write
    all the code to update the hero's position. Create this function under the `update`
    function and don't forget to call this function in the `update` function, otherwise
    the hero's position won't be updated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个新的函数，称为`updateHero`，我们将在这个函数中编写所有更新英雄位置的代码。在`update`函数下创建这个函数，并且不要忘记在`update`函数中调用这个函数，否则英雄的位置将不会更新。
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `updateHero` function, we are decrementing the `y` position of the hero
    in each update. Eventually, she will fall through the bottom of screen. To make
    her stay within the bounds, we check whether she is about to go beyond the screen
    and place her back at the bottom edge of the screen. To do this, add the following
    in the `heroUpdate` function right under where we decrement her position:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateHero`函数中，我们在每次更新中递减英雄的`y`位置。最终，她将穿过屏幕底部。为了让她保持在边界内，我们检查她是否即将超出屏幕，并将她放回屏幕底部的边缘。为此，在`heroUpdate`函数中递减她的位置下方添加以下代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the first `if` block, we check whether the bottom of the hero has crossed
    the bottom of the screen. If so, then we place the hero's origin at half her height
    from the bottom of the screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`if`块中，我们检查英雄的底部是否已经超过了屏幕的底部。如果是这样，那么我们将英雄的原点放置在屏幕底部距离她高度的一半处。
- en: In the `else if` block, we check whether the top of the hero has crossed the
    top of the screen. If so, then we place her at half her height from the top of
    the screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else if`块中，我们检查英雄的顶部是否已经超过了屏幕的顶部。如果是这样，那么我们将她放置在屏幕顶部距离她高度的一半处。
- en: Now, if you build and run the game and press play, the hero will be at one fourth
    of the distance from the left of the screen and will stop once she reaches the
    bottom of the screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行游戏并按下播放，英雄将位于屏幕左侧距离的四分之一处，并且当她到达屏幕底部时将停止。
- en: '![Updating the position of the hero](img/B04014_04_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![更新英雄的位置](img/B04014_04_13.jpg)'
- en: Adding player controls
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加玩家控制
- en: We will now add player controls by using the `touchesbegan` function. If the
    player taps the left side of the screen, the hero get pushed up and will then
    start falling again due to gravity, and if the player taps the right of the screen,
    the hero will fire rockets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过使用`touchesbegan`函数来添加玩家控制。如果玩家点击屏幕的左侧，英雄将被推向上方，然后由于重力作用将再次开始下落，如果玩家点击屏幕的右侧，英雄将发射火箭。
- en: 'For detecting touches, add the `touchesBegan` function under the `update` function
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测触摸，在`update`函数下添加`touchesBegan`函数，如下所示：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is obviously the same function that we used in `MainMenuScene` to detect
    touches on the play button. Since we are just going to be checking the location
    of the touch, we don't require the object we touched, for now at least.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是我们之前在`MainMenuScene`中用来检测播放按钮触摸的相同函数。由于我们只是将要检查触摸的位置，所以我们现在不需要我们触摸的对象。
- en: 'To detect which side of the screen was tapped, add the following code under
    where we get the location of the touches in the `for in` loop:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测屏幕被点击的哪一侧，在`for in`循环中获取触摸位置的地方添加以下代码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We check whether the `x` value of the touched location is less than half of
    the width of the screen. If so, then we print out that the left side of the screen
    was touched, otherwise we check whether the `x` value of the touched location
    was greater than half of the width of the screen, then in that case, we can confirm
    that the right of the screen was touched.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查触摸位置的`x`值是否小于屏幕宽度的一半。如果是这样，那么我们将打印出屏幕的左侧被触摸了；否则，我们检查触摸位置的`x`值是否大于屏幕宽度的一半，在这种情况下，我们可以确认屏幕的右侧被触摸了。
- en: 'Now, to push the hero up in the air, we give her a small thrust each time the
    player touches the left of the screen. Add a global variable called `thrust` of
    type `CGPoint` and initialize both `x` and `y` values to zero as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将英雄推向空中，每当玩家触摸屏幕的左侧时，我们给她一个小的推力。添加一个全局变量`thrust`，其类型为`CGPoint`，并将`x`和`y`的值初始化为零，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we are using `var` and not `let,` as the value of `thrust` will change
    over a period of time. Also, `CGPointZero` is just short for `CGPoint(x:0, y:0)`.
    They will both do the same thing, so it is just a matter of convenience and preference.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`var`而不是`let`，因为`thrust`的值将在一段时间内发生变化。此外，`CGPointZero`只是`CGPoint(x:0,
    y:0)`的简写。它们都将做同样的事情，所以这只是方便和偏好的问题。
- en: 'In the `touchesBegan` function, right after we checked if the left part of
    the screen is tapped, add the following line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`touchesBegan`函数中，在我们检查屏幕左侧被触摸后，立即添加以下行：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And in the `updateHero` function, change the line `hero.position.y += gravity.y`
    to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`updateHero`函数中，将`hero.position.y += gravity.y`这一行改为以下内容：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, whenever the left side of the screen is touched, the hero will be pushed
    up by 15 points and then she will start falling down after reaching the highest
    position. Log the value of `thrust.y` as follows to see how it works:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当触摸屏幕的左侧时，英雄将向上推15点，然后当她达到最高位置后，她将开始下落。按照以下方式记录`thrust.y`的值，以查看其工作原理：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the screen is tapped, the `y` value of `thrust` that was initially set
    to `0` is set to `14`. It is not 15 since we are subtracting 1 from it due to
    gravity. Then, at each update, the `y` position of the hero is slowly decreased
    until it becomes zero, and gravity will start acting again and start pulling the
    hero down.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦屏幕被轻触，`thrust`的`y`值，最初设置为`0`，将被设置为`14`。它不是`15`，因为我们由于重力而从中减去了`1`。然后，在每次更新时，英雄的`y`位置会逐渐降低，直到变为零，重力将再次开始作用并开始将英雄向下拉。
- en: 'One thing you will notice is that when the hero is at the bottom of the screen
    and you apply an upward thrust, the hero doesn''t immediately start moving up.
    The answer to why this is also visible in the console output of `thrust.y`. As
    the gravity is added to the `thrust.y`, its value becomes huge and the small thrust
    of 15 has to overcome this value to make the hero move up again. To solve this,
    we have to set the value of `thrust` back to zero once the hero touches the top
    or the bottom of the screen. So, in the `updateHero` function, where we check
    whether that she touched the top or bottom of the screen, add the following line
    in both the `if` and the `if else` blocks after setting the hero''s position:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当英雄在屏幕底部并且你施加向上的推力时，英雄不会立即开始向上移动。为什么这一点在`thrust.y`的控制台输出中也是可见的。由于重力被添加到`thrust.y`，其值变得非常大，15点的小推力必须克服这个值才能使英雄再次向上移动。为了解决这个问题，我们必须在英雄触摸屏幕顶部或底部时将`thrust`的值重置为零。因此，在`updateHero`函数中，在检查她是否触摸了屏幕顶部或底部之后，在设置英雄位置的`if`和`if
    else`块之后添加以下行：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We will next add the rockets that fire when the right side of the screen is
    tapped. For this, we will create a new generic class so that we can use it later
    for creating enemies and enemy bullets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加当屏幕右侧被轻触时发射的火箭。为此，我们将创建一个新的泛型类，以便我们可以在以后创建敌人和敌人子弹时使用。
- en: 'As we created the `GamePlayScene.swift` file, create a file called `MovingSprite`,
    and in this file, add the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了`GamePlayScene.swift`文件，因此创建一个名为`MovingSprite`的文件，并在该文件中添加以下代码：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this class, we import SpriteKit and then create the definition of the class.
    We create two global constants for holding the reference of the SKSpriteNode and
    CGPoint objects we will be passing into the constructor. The SKSpriteNode will
    hold the sprite that we will be passing in, and `CGPoint` will hold the speed
    with which we want the sprite to move by.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们导入 SpriteKit 并创建类的定义。我们创建了两个全局常量来保存我们将传递给构造函数的 `SKSpriteNode` 和 `CGPoint`
    对象的引用。`SKSpriteNode` 将保存我们将传递的精灵，而 `CGPoint` 将保存我们想要精灵移动的速度。
- en: In the `init` function, we assign the objects passed in to the local objects
    we have created. We have added one more function called `moveSprite`. This will
    move the sprite with the speed that was assigned to it. That is all for this class
    for now. We will revisit and modify this class when we add the enemy and bullets
    class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 函数中，我们将传递的对象分配给本地创建的对象。我们添加了一个名为 `moveSprite` 的额外函数。这个函数将使用分配给它的速度移动精灵。现在这个类就到这里为止。当我们添加敌人和子弹类时，我们将重新访问并修改这个类。
- en: 'For creating the rockets, create a new function called `addRockets` in the
    `GamePlayScene` file. In it, we add the following code to create the rockets:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建火箭，在 `GamePlayScene` 文件中创建一个名为 `addRockets` 的新函数。在其中，我们添加以下代码来创建火箭：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `addRockets` function, we first create a constant called `rocketNode`
    of type `SKSpriteNode` and assign a rocket from the `imageset`. So, create a new
    image set and name it `rocket`. In the `Resources` folder, you will find `rocket.png`
    and `rocket2.png`, which you can assign to the **1x** and **2x** slots, respectively,
    in the file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addRockets` 函数中，我们首先创建一个名为 `rocketNode` 的常量，其类型为 `SKSpriteNode`，并从 `imageset`
    中分配一个火箭。因此，创建一个新的图像集并命名为 `rocket`。在 `Resources` 文件夹中，你可以找到 `rocket.png` 和 `rocket2.png`，你可以分别将它们分配给文件的
    **1x** 和 **2x** 位置。
- en: Next we set the position of the rocket. Since we want the rockets to appear
    to be coming out of the bazooka, instead of spawning in at the position of the
    player, we place it at the front end of the bazooka. So, for the `x` position,
    we get the player's position, and then add half of the width of the player to
    it and also add half of the width of the rocket itself to it. For the `y` position,
    we get the y position of the hero and subtract half of the height of the rocket
    from it. We then add it to the scenes display list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置火箭的位置。由于我们想让火箭看起来是从火箭筒中发射出来的，而不是在玩家的位置生成，所以我们将其放置在火箭筒的前端。因此，对于 `x` 位置，我们获取玩家的位置，然后加上玩家宽度的一半，并加上火箭本身宽度的一半。对于
    `y` 位置，我们获取英雄的 `y` 位置，并从它减去火箭高度的一半。然后我们将它添加到场景的显示列表中。
- en: Next we create an object called `rocket` of the type `MovingSprite` and assign
    the speed with which we want to move the sprite and pass in the `rocketNode` we
    created earlier. For assigning the speed, we create a new constant called `speed`
    of type `CGPoint` and assign `10` and `0` to the `x` and the `y` values, respectively,
    so that whenever we call the `moveSprite` function of the class, the position
    will update in the *x* direction according to the value provided.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `rocket` 的对象，其类型为 `MovingSprite`，并分配我们想要移动精灵的速度，并将我们之前创建的 `rocketNode`
    传递进去。为了分配速度，我们创建一个新的常量 `speed`，其类型为 `CGPoint`，并将 `10` 和 `0` 分别分配给 `x` 和 `y` 的值，这样每次我们调用类的
    `moveSprite` 函数时，位置将根据提供的值在 *x* 方向上更新。
- en: 'In the `touchedBegan` function, where we checked if the right side of the screen
    was clicked, add the `addRocket` function to create the rocket every time the
    right side of the screen is tapped:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `touchedBegan` 函数中，我们检查屏幕的右侧是否被点击，添加 `addRocket` 函数以在每次点击屏幕的右侧时创建火箭：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if you build and run, and tap on the right side of the screen, the rockets
    will be created, but they are not moving. To move the rockets, we have to add
    each rocket we created, into an array, and on each rocket we have to call the
    `moveSprite` function to actually move the sprites.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行，然后点击屏幕的右侧，火箭将被创建，但它们没有移动。为了移动火箭，我们必须将我们创建的每个火箭添加到一个数组中，并且在每个火箭上调用
    `moveSprite` 函数来实际移动精灵。
- en: For updating the position of the rockets, first we have to create an array to
    hold all the rockets. This array needs to be a global variable so that we can
    easily access it. So, right under where we added `var thrust = CGPointZero` at
    the start of the class, add the following line of code right under it. We create
    an array called `rockets` to hold objects of type `MovingSprite` and we are using
    `var,` as it is a mutable array, meaning we will be adding and removing objects
    from it during the course of the game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新火箭的位置，我们首先需要创建一个数组来存储所有的火箭。这个数组需要是一个全局变量，这样我们就可以轻松地访问它。因此，在类开始处添加`var thrust
    = CGPointZero`的下面，紧接着添加以下代码行。我们创建一个名为`rockets`的数组来存储`MovingSprite`类型的对象，我们使用`var`，因为它是一个可变数组，这意味着我们将在游戏过程中向其中添加和删除对象。
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, create a new function called `updateGameObjects` right under where we
    created the function for updating the hero, and add the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在创建更新英雄函数的下面创建一个新的函数`updateGameObjects`，并添加以下代码：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You might be thinking, why are we using a `for` loop instead of a `for in` loop?
    Well this is because once the rocket goes off screen, we have to delete the object,
    and for removing objects from the array in Swift, we require the index of the
    object to be removed and the `for in` loop doesn't have that feature.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，为什么我们使用`for`循环而不是`for in`循环呢？嗯，这是因为一旦火箭飞出屏幕，我们就必须删除该对象，而在Swift中从数组中删除对象时，我们需要被删除对象的索引，而`for
    in`循环没有这个功能。
- en: So, we create a regular `for` loop starting from `0` and go through each object
    in the `rockets` array by incrementing the index by 1 every time. We call the
    `moveSprite` function on the ith object of the array. Next, for convenience, we
    get the `spritenode` from the index so that we can perform some checks on it.
    We check whether the left edge of the rocket sprite is beyond the width of the
    screen, and, if so, then we remove the sprite from its parent node, which is the
    `GamePlayScene` as this is where we will add `addChild` in the `addRockets` function.
    Then, we remove the object at the current index in the rockets array by calling
    the `removeAtIndex` function of the array and pass in the current index.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建一个从`0`开始的常规`for`循环，每次通过将索引增加1遍历`rockets`数组中的每个对象。我们调用数组中的第i个对象的`moveSprite`函数。接下来，为了方便起见，我们从索引中获取`spritenode`，这样我们就可以对其进行一些检查。我们检查火箭精灵的左侧边缘是否超出了屏幕的宽度，如果是这样，那么我们就从其父节点中删除该精灵，即`GamePlayScene`，因为这是我们将在`addRockets`函数中添加`addChild`的地方。然后，我们通过调用数组的`removeAtIndex`函数并传入当前索引来从火箭数组中删除当前索引的对象。
- en: 'Finally, we also need to add the objects to the array to delete it. So, in
    the `addRocket` function, add `rockets.append(rocket)` at the end of the function
    to add the rocket to the `rockets` array:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要将对象添加到数组中以便删除它。因此，在`addRocket`函数中，在函数末尾添加`rockets.append(rocket)`以将火箭添加到`rockets`数组中：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lastly, don't forget to call the `updateGameObjects` function in the `update`
    function right below where we call the `updateHero` function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了在调用`updateHero`函数的下面调用`updateGameObjects`函数。
- en: Now, when you build and run the game, you will be able to tap on the left-hand
    side of the screen to boost up the player and then tap on the right-hand side
    of the screen to shoot the rockets.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你构建并运行游戏时，你将能够点击屏幕的左侧来提升玩家的速度，然后点击屏幕的右侧来发射火箭。
- en: Also, take a look at the node count on the bottom right of the screen. Each
    time a new rocket is created, the node count will increase, and since the rockets
    are removed once they are off screen, the count will also decrease every time
    a rocket is removed from the scene.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请查看屏幕右下角的节点计数。每次创建一个新的火箭时，节点计数都会增加，由于火箭一旦飞出屏幕就会被删除，因此每次从场景中删除火箭时，计数也会减少。
- en: 'You can also log the `rockets.count` to check how many rockets there are in
    the rockets array by adding the following in the `update` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在`update`函数中添加以下代码来记录`rockets.count`，以检查火箭数组中有多少个火箭：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Adding player controls](img/B04014_04_14.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![添加玩家控制](img/B04014_04_14.jpg)'
- en: Adding enemies
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加敌人
- en: For the hero to be a hero, we need villains. So, we will add the enemies now.
    Similar to how we created the `addRocket` function, create a new function called
    `addEnemy`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要让英雄成为英雄，我们需要反派。因此，我们现在将添加敌人。类似于我们创建`addRocket`函数的方式，创建一个新的函数`addEnemy`。
- en: 'Also, create a new array called `enemies` just after the `rocket` array in
    the global variables of the `GamePlayScene` class. This adds a new array that
    will manage enemies, like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`GamePlayScene`类的全局变量中`rocket`数组之后创建一个新的数组名为`enemies`。这添加了一个新的数组，将管理敌人，如下所示：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should now have something similar to the following in your variables declarations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的变量声明中应该有类似以下的内容：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can now update all the enemies, update their positions and remove them when
    they leave the screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新所有敌人，更新它们的位置并在它们离开屏幕时移除它们。
- en: Create a new image set called `enemy` and add the `enemy.png` and `enemy2.png`
    to the file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的图像集名为`enemy`，并将`enemy.png`和`enemy2.png`添加到文件中。
- en: Unlike the rockets that spawn at the nozzle of the bazooka, the enemy will spawn
    from the right of the screen and move toward the left of the screen. They will
    also be spawning at different heights on the screen. It won't be challenging to
    the player if all the enemies spawned from the same position. So, we will create
    a random number, based on which we will decide at what height the enemy will be
    created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与在火箭筒喷嘴处生成的火箭不同，敌人将从屏幕右侧生成并向屏幕左侧移动。它们也会在屏幕的不同高度生成。如果所有敌人都是从同一位置生成的，这对玩家来说不会构成挑战。因此，我们将创建一个随机数，根据这个随机数我们将决定敌人将在什么高度生成。
- en: 'Create the `addEnemy` function as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式创建`addEnemy`函数：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For creating a random number, we use the inbuilt function `arc4random_uniform`.
    This function takes in a value and generates a random number from `0` to one less
    than the number. So, in this case, since we have passed in `4`, it will create
    a number from `0` to `3`. Since we want a random number from `1` to `4`, we add
    `1` to it at the end. We assign this value to a variable called `factor`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建随机数，我们使用内置函数`arc4random_uniform`。这个函数接受一个值并生成一个从`0`到小于该值的随机数。所以，在这种情况下，因为我们传递了`4`，它将创建一个从`0`到`3`的数字。由于我们想要一个从`1`到`4`的随机数，我们在最后将其加`1`。我们将这个值分配给一个名为`factor`的变量。
- en: Then, we typecast this variable to `CGFloat` so that we can get a fraction value.
    Then, multiply this value by 0.20 and store it in a new variable called `fraction`.
    To finally get the random height at which the enemy needs to be created, we multiply
    the fraction with the height of the view, and assign it to a variable called `height`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个变量转换为`CGFloat`类型，这样我们就可以得到一个分数值。然后，将这个值乘以0.20并存储在一个名为`fraction`的新变量中。为了最终得到敌人需要生成的随机高度，我们将分数乘以视图的高度，并将其分配给一个名为`height`的变量。
- en: This way the enemy will be created at 20, 40, 60, or 80 percent of the height
    of the screen. We can't spawn the enemy at 0 percent or at 100 percent of the
    height since then, either the top or the bottom part of the enemy wouldn't be
    visible, because the anchor point for sprites are at the center of the sprite.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，敌人将在屏幕高度的20%、40%、60%或80%处生成。我们不能在0%或100%的高度生成敌人，因为那样的话，敌人的顶部或底部部分将不可见，因为精灵的锚点位于精灵的中心。
- en: Now, similar to how we created the rocket, we create a new called `enemyNode`
    of type `SKSpriteNode` and assign the enemy image set to it. We have to place
    the enemy just beyond the right of the screen, so we get the width of the screen
    and add half the enemy width to it. For the height, we give the random height
    at which the enemy needs to be spawned in and add the enemy sprite to the scene.
    Finally, we will name the `enemyNode` sprite as `enemy` as we will need it later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类似于我们创建火箭的方式，我们创建一个新的名为`enemyNode`的`SKSpriteNode`类型，并将敌人图像集分配给它。我们必须将敌人放置在屏幕右侧之外，因此我们获取屏幕宽度并加上敌人宽度的一半。对于高度，我们给出敌人需要生成的随机高度，并将敌人精灵添加到场景中。最后，我们将`enemyNode`精灵命名为`enemy`，因为我们稍后会用到它。
- en: Next, since we need to create an instance of the `MovingSprite` class and provide
    the `enemySprite` node and speed, we will create a new `speed` object. Since this
    time we want the enemy to be moving in the negative *x* direction, we provide
    the value of `–5` in the `x` direction for speed, keeping the `y` value as `0`
    as we don't want the enemy to be moving in the *y* direction. Then, we create
    a new `MovingSprite` object called `enemy` and provide `enemySprite` and `speed`
    to it. At the end, we append the newly created enemy object to the `enemies` array
    so we create an array called `enemies` at the top, similar to how we created rockets
    for the hero.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们需要创建`MovingSprite`类的实例，并提供`enemySprite`节点和速度，我们将创建一个新的`speed`对象。由于这次我们希望敌人向负的*x*方向移动，我们在`x`方向上提供`-5`的值作为速度，将`y`值保持为`0`，因为我们不希望敌人向*y*方向移动。然后，我们创建一个新的`MovingSprite`对象，命名为`enemy`，并向其提供`enemySprite`和`speed`。最后，我们将新创建的敌人对象追加到`enemies`数组中，这样我们就在顶部创建了一个名为`enemies`的数组，类似于我们为英雄创建火箭的方式。
- en: 'Now we have to update through the enemy objects in the array and call `moveSprite`
    on the enemy to make it move in the negative *x* direction. We also need to make
    sure that we remove the enemy sprite from the parent class and then remove the
    enemy object from the `enemies` array. To do this, we add the following code under
    where we update the player rockets in the `updateGameObjects` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须更新数组中的敌人对象，并对敌人调用`moveSprite`使其向负的*x*方向移动。我们还需要确保从父类中移除敌人精灵，然后从`enemies`数组中移除敌人对象。为此，我们在`updateGameObjects`函数中更新玩家火箭的地方添加以下代码：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Similar to how we updated the hero rockets, we create a `for` loop and then
    call the `moveSprite` function on all the objects. Create a `sprite` node for
    convenience. Now, instead of checking if the object left from the right end of
    the screen, as the enemy is moving, the negative *x* direction, we check whether
    the right edge of the enemy is beyond the left of the screen, and if so, then
    we remove the sprite from the parent and then remove the object from the current
    index in the `enemies` array.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们更新英雄火箭的方式类似，我们创建一个`for`循环，然后对所有的对象调用`moveSprite`函数。为了方便起见，创建一个`sprite`节点。现在，我们不再检查对象是否从屏幕的右侧离开，因为敌人正在移动，向负的*x*方向，而是检查敌人的右边缘是否超出了屏幕的左侧，如果是这样，我们就从父节点中移除精灵，然后从`enemies`数组中的当前索引移除对象。
- en: Since we are already calling `updateGameObjects` in the `update` function, we
    aren't required to add it again. But we should call the `addEnemy` function after
    every couple of seconds to spawn the enemy.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在`update`函数中调用了`updateGameObjects`，因此不需要再次添加。但是，我们应该每隔几秒钟调用一次`addEnemy`函数来生成敌人。
- en: 'For actually spawning the enemy, we can use an action to call the `addEnemy`
    function after whatever duration we want. To do this, in the `init` function,
    add the following under where we added the hero to the scene:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际生成敌人，我们可以使用一个动作在想要持续的时间后调用`addEnemy`函数。为此，在`init`函数中，在将英雄添加到场景的地方添加以下内容：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First we create a few actions. All actions are of the type `SKAction`. The first
    action is `runBlock` in which we provide the function that we want to call, which
    is `addEnemy`. We assign this action to `let` called `callFunc`. Next we create
    another action called `waitDuration` and assign `3.0`, which is 3 seconds, and
    assign it to `delay`. The third action is a `sequence`. A `sequence` action lets
    you perform actions one after the other. So, here we first give `callFunc` and
    then `delay`. The square brackets indicate that the sequence is an array, so we
    can create a sequence of however many actions we want to call, by adding it to
    the array and then passing it into the sequence. In this sequence, the `callEnemy`
    function will be called first and then the action will wait for 3 seconds.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一些动作。所有动作都是`SKAction`类型。第一个动作是`runBlock`，我们提供想要调用的函数，即`addEnemy`。我们将此动作分配给名为`callFunc`的`let`。接下来，我们创建另一个名为`waitDuration`的动作，将其分配为`3.0`，即3秒，并将其分配给`delay`。第三个动作是一个`sequence`。`sequence`动作允许你依次执行动作。因此，在这里我们首先提供`callFunc`，然后是`delay`。方括号表示序列是一个数组，因此我们可以创建一个包含我们想要调用的任意多个动作的序列，通过将其添加到数组中，然后传递给序列。在这个序列中，`callEnemy`函数将首先被调用，然后动作将等待3秒。
- en: The last action is the `repeatActionForever` action and here we pass in the
    sequence action so that the sequence is called over and over.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的操作是`repeatActionForever`动作，在这里我们传入序列动作，以便序列被反复调用。
- en: Finally, we run the action on the current scene and provide `addEnemyAction`,
    which will eventually call the `addEnemy` function until we tell it to stop running
    the action.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在当前场景上运行动作，并提供`addEnemyAction`，这将最终调用`addEnemy`函数，直到我们告诉它停止运行动作。
- en: Build and run now to see enemies popping up from the right of the screen, getting
    updated, and then once they leave the scene, getting deleted from the scene.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行程序，可以看到敌人从屏幕右侧出现，更新状态，然后一旦他们离开场景，就会从场景中删除。
- en: '![Adding enemies](img/B04014_04_15.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![添加敌人](img/B04014_04_15.jpg)'
- en: Adding enemy bullets
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加敌人子弹
- en: OK. The enemy seems to be carrying a rifle of some cartoony sort but he doesn't
    seem to be doing anything with it. Let's make him use it. We will make the enemy
    shoot bullets.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。敌人似乎携带一种卡通风格的步枪，但他似乎没有用它做任何事情。让我们让他使用它。我们将让敌人射击子弹。
- en: 'Create an image set called `bullet` and assign `bullet.png` and `bullet2.png`
    to the **1x** and **2x** slots, respectively, in `Images.xcassets`. Also, create
    a new global variable called `bullets` of type `array` at the top of the `GamePlayScene`
    class as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`bullet`的图像集，并将`bullet.png`和`bullet2.png`分别分配给`Images.xcassets`中的**1x**和**2x**槽位。此外，在`GamePlayScene`类的顶部创建一个名为`bullets`的新的全局变量，类型为`array`，如下所示：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For spawning the bullets, we will be using the `movingSprite` class. But we
    have to make some changes to it so that as soon as the enemy is created, he starts
    firing away with the rifle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成子弹，我们将使用`movingSprite`类。但我们必须对其进行一些修改，以便敌人一被创建就开始用步枪射击。
- en: 'So, open the `movingSprite` class and add the following in the `init` function
    right after we initialize the global variables. Remember that we added a name
    to the enemy sprite when we create it. This will come into use in the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开`movingSprite`类，并在初始化全局变量后立即在`init`函数中添加以下内容。记住，我们在创建敌人精灵时给它添加了一个名称。这将在以下内容中使用：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we first check the name of the sprite passed in, and if it is the enemy,
    then we create an action similar to how we created the spawning of the enemies
    in the `GameplayScene` class. The difference being that, instead of creating a
    separate variable for each action here, we are just creating one single action
    called `shootAction` and calling all the actions inside it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查传入的精灵名称，如果是敌人，则创建一个类似于我们在`GameplayScene`类中创建敌人生成的动作。区别在于，我们在这里不是为每个动作创建一个单独的变量，而是创建一个名为`shootAction`的单个动作，并调用其中的所有动作。
- en: So, basically, we are calling a `shootBullet` function, which we will create
    in the same class, that will be called every 3 seconds.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们正在调用一个名为`shootBullet`的函数，我们将在同一个类中创建它，该函数将每3秒被调用一次。
- en: After we create `shootAction`, we call the action on the sprite so that it can
    start calling `shootAction`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`shootAction`之后，我们调用精灵上的动作，以便它能够开始调用`shootAction`。
- en: We will define the `shootBullet` function as follows. This can be added right
    under where we added the `moveSprite` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`shootBullet`函数如下。这可以添加在我们添加`moveSprite`函数的下方。
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This function, in turn, will call a function called `addBullets` in the `GameplayScene`.
    Since we have added the hero, rockets, and enemy in the gameplay scene, it is
    better if we also add the bullets into the same scene, as it will be easier for
    us to cycle through the objects when checking for collision.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数反过来会调用`GameplayScene`中的`addBullets`函数。由于我们在游戏场景中添加了英雄、火箭和敌人，如果我们也将子弹添加到同一个场景中会更好，因为这样在检查碰撞时更容易遍历对象。
- en: To get an instance of the `GameplayScene`, we will create a local constant called
    `_gameplayScene` and use the `.parent` property of the `SKSpriteNode` to get the
    parent class on to which the sprite was added. Since we added the enemy in `GameplayScene`,
    it will return `GameplayScene`. We still need to typecast it so that we use the
    `as` operator and typecast it to `GamePlayScene`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`GameplayScene`的实例，我们将创建一个名为`_gameplayScene`的局部常量，并使用`SKSpriteNode`的`.parent`属性来获取精灵被添加到的父类。由于我们在`GameplayScene`中添加了敌人，它将返回`GameplayScene`。我们仍然需要将其类型转换为`GamePlayScene`，所以我们使用`as`运算符并将其类型转换为`GamePlayScene`。
- en: Now, since we need to position the bullets properly, the same way we positioned
    the rockets for the hero, we will need to provide the position and size of the
    enemy object while creating bullets. Assuming that, we will create a function
    called `addBullets`, we will call this function on the `GamePlayScene` by providing
    the position and size of the enemy sprite.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们需要正确地定位子弹，就像我们为英雄定位火箭一样，我们需要在创建子弹时提供敌人对象的位置和大小。假设如此，我们将创建一个名为 `addBullets`
    的函数，我们将通过提供敌人精灵的位置和大小来在 `GamePlayScene` 中调用此函数。
- en: 'Now, let''s go to `GameplayScene` and create the `addBullets` function as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到 `GameplayScene` 并创建一个名为 `addBullets` 的函数，如下所示：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should be quite accustomed to adding objects in SpriteKit now. Like the
    rockets, we create a `SKSpriteNode` called `bulletNode` and assign the bullet
    image set it. You know the drill.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该相当熟悉在 SpriteKit 中添加对象了。就像火箭一样，我们创建一个名为 `bulletNode` 的 `SKSpriteNode`，并分配子弹图像。你知道该怎么做。
- en: We then create a new position, which will be at the left end of the enemy sprite.
    So, we take the current position of the enemy and subtract half the width of the
    enemy and half the `bulletNode` from the `x` position. For the `y` position, we
    get the `y` position of the position and subtract the full height of the bullet.
    In the next step, we assign this position to the position of `bulletNode`, and
    then we add it to the current scene.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的位置，它将在敌人精灵的左侧端点。因此，我们取敌人的当前位置，从 `x` 位置减去敌人宽度的一半和 `bulletNode` 的一半。对于
    `y` 位置，我们从位置 `y` 位置减去子弹的全高。在下一步中，我们将此位置分配给 `bulletNode` 的位置，然后将其添加到当前场景中。
- en: We create a new speed variable and assign the speed with which we want the bullet
    to move. We create a new constant called `bullet` and provide the `bulletNode`
    and speed to it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的速度变量，并分配我们想要子弹移动的速度。我们创建一个新的常量 `bullet`，并将 `bulletNode` 和速度提供给它。
- en: A bullets array needs to be created to append all the bullets created. So, create
    a new array called `bullets` that takes in `MovingSprite` and adds it to the top
    of the class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个子弹数组来追加所有创建的子弹。因此，创建一个新的名为 `bullets` 的数组，它接受 `MovingSprite` 并将其添加到类的顶部。
- en: After the bullet is created, append it to the `bullets` array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹创建后，将其追加到 `bullets` 数组中。
- en: 'We also need to update the position of the bullets and check so we can delete
    them once they have left the screen. So, similar to updating the enemy, we need
    to add the following code in the `updateGameObjects` function to update the bullets:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新子弹的位置并检查，以便在它们离开屏幕后删除它们。因此，类似于更新敌人，我们需要在 `updateGameObjects` 函数中添加以下代码来更新子弹：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, here we go through the bullets in the array, call the `moveSprite` function,
    and if the sprite has gone beyond the left of the screen, we remove it from the
    parent and remove the object in the current index.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们遍历数组中的子弹，调用 `moveSprite` 函数，如果精灵已经超出屏幕的左侧，我们就从父节点中移除它，并在当前索引中移除对象。
- en: '![Adding enemy bullets](img/B04014_04_16.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![添加敌人子弹](img/B04014_04_16.jpg)'
- en: Now we have all the elements needed to go to the next stage of development,
    that is, to check for collisions between the hero's rockets and enemies, and between
    the enemy's bullets and the hero. Based on collision, we will be doing the scoring
    and checking for the game over condition.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了进入下一阶段开发所需的所有元素，即检查英雄火箭与敌人之间的碰撞，以及敌人子弹与英雄之间的碰撞。基于碰撞，我们将进行计分和检查游戏结束条件。
- en: Collision detection
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Collision detection in 2D games is done using the `intersectsNode` function
    of the sprite class itself. We can check whether the current sprite is overlapping
    the other sprite. In the `intersectsNode` function of the current node, we pass
    in a node that we want to check for collision with the current node. If there
    is an intersection, the function will return `true`, if not, it returns `false`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维游戏中，碰撞检测是通过精灵类的 `intersectsNode` 函数来完成的。我们可以检查当前精灵是否与其他精灵重叠。在当前节点的 `intersectsNode`
    函数中，我们传入一个节点，我们想要检查它与当前节点是否发生碰撞。如果有交集，函数将返回 `true`，如果没有，则返回 `false`。
- en: For checking collision, we will first check the collision between the enemy's
    bullets and the hero. If there is collision, then the game is over. Then we will
    check collision between the hero's rockets and the enemies. If we detect a collision,
    then we have to update the score.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于碰撞检查，我们首先检查敌人子弹与英雄之间的碰撞。如果发生碰撞，则游戏结束。然后我们将检查英雄火箭与敌人之间的碰撞。如果我们检测到碰撞，则必须更新分数。
- en: Also, if the enemy goes beyond the left of the screen, the game is over, so
    we will call the `GameOver` function in this case also.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果敌人超出屏幕的左侧，游戏即结束，因此在这种情况下也会调用 `GameOver` 函数。
- en: 'For checking collision, create a new function called `checkCollision` in the
    `GameplayScene` and add the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查碰撞，在 `GameplayScene` 中创建一个新的函数 `checkCollision` 并添加以下代码：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we wont be needing to know the index numbers, we will just use the `for in`
    loop to check collision.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要知道索引号，我们将仅使用 `for in` 循环来检查碰撞。
- en: Here we go through all the bullet objects in the `bullets` array. First, we
    assign the sprite of the bullet object to a local sprite variable. Then, we will
    call the `intersectsNode` function on the sprite to check whether it intersects
    the hero sprite. If it does intersect, then the `GameOver` function is called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历 `bullets` 数组中的所有子弹对象。首先，我们将子弹对象的精灵分配给一个局部精灵变量。然后，我们将对该精灵调用 `intersectsNode`
    函数以检查它是否与英雄精灵相交。如果相交，则调用 `GameOver` 函数。
- en: The `intersectsNode` function just takes the sprite of the node and checks if
    the box surrounding this sprite intersects with the bounding box of the sprite
    provided for it. If there is some overlapping, it will return `true` if the collision
    has occurred, or `false` otherwise.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersectsNode` 函数仅接受节点的精灵，并检查围绕该精灵的矩形是否与提供的精灵的边界框相交。如果存在重叠，则如果发生碰撞，将返回 `true`，否则返回
    `false`。'
- en: 'Call the `checkCollision` function in the `update` function right after we
    update the hero and the game objects, as shown in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新英雄和游戏对象之后，立即在 `update` 函数中调用 `checkCollision` 函数，如下所示：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, let's create the `GameOver` function. Once the game is over, we want to
    stop updating the hero and game objects, and stop checking for collision.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `GameOver` 函数。一旦游戏结束，我们希望停止更新英雄和游戏对象，并停止检查碰撞。
- en: 'Also, create a global bool at the top of the class called `gameOver` and set
    it to `false`. It should be a `var` and not `let` as we will change it in the
    `GameOver` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在类的顶部创建一个全局布尔变量 `gameOver` 并将其设置为 `false`。它应该是一个 `var` 而不是 `let`，因为我们将在 `GameOver`
    函数中更改它：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the `GameOver` function to the `GamePlayScene` class right after the `update`
    function as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GameOver` 函数添加到 `GamePlayScene` 类中，紧接在 `update` 函数之后，如下所示：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once the game is over, we set the `gameOver` bool to `false`. Next we call `removeAllActions`
    on the current class so that enemies will stop spawning, and then we also call
    the function on all the enemies that are currently present on the screen, so that
    the bullets stop spawning.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦游戏结束，我们将 `gameOver` 布尔值设置为 `false`。接下来，我们调用当前类上的 `removeAllActions` 以停止敌人生成，然后我们也调用屏幕上所有当前存在的敌人的函数，这样子弹就不会生成。
- en: 'We also need to call the `GameOver` function when any of the enemies go beyond
    the left of the screen, so to update the position of the enemy, call the `GameOver`
    function in the `if` condition in the loop, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在敌人超出屏幕左侧时调用 `GameOver` 函数，因此为了更新敌人的位置，在循环中的 `if` 条件中调用 `GameOver` 函数，如下所示：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In order to stop updating the hero and game objects and stop checking for collision,
    once the game is over, enclose the three functions in an `if` condition, as shown
    in the following code, where we check whether the `gameOver` Boolean value is
    `false` or not. If it is `false`, then the functions will get called, else it
    will be bypassed and won't call the functions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏结束后停止更新英雄和游戏对象，并停止检查碰撞，一旦游戏结束，将三个函数包裹在一个 `if` 条件语句中，如下所示，其中我们检查 `gameOver`
    布尔值是否为 `false`。如果是 `false`，则函数将被调用，否则将跳过并不会调用函数。
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, if the game is over, the player shouldn''t be able to fire rockets or
    make the hero thrust up. So, basically, we have to disable the player controls
    once the game is over. So, in the `touchesBegan` function, enclose where we check
    which side the screen is tapped in the `if` condition, checking if the game over
    condition is met or not, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果游戏结束，玩家不应能够发射火箭或使英雄向上推。所以，基本上，我们必须在游戏结束后禁用玩家控制。因此，在 `touchesBegan` 函数中，将检查屏幕被点击哪一侧的部分包裹在
    `if` 条件中，检查是否满足游戏结束条件，如下所示：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Keeping score
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记分
- en: 'We are still not done with the `checkCollision` function. We still need to
    keep track of the score. For this, we have to check the collision between the
    hero''s rockets and the enemies. So, in the `checkCollision` function, add the
    following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成`checkCollision`函数。我们仍然需要跟踪分数。为此，我们必须检查英雄的火箭与敌人的碰撞。因此，在`checkCollision`函数中，添加以下代码：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We are using the `for` loop as we will need the index of the objects in the
    loops here. We loop through all the rockets in the scene and check the collision
    with all the enemies in the scene by looping through the `enemies` array. If any
    of the rockets collides with the enemy, then we remove both the rocket and the
    enemy sprite node from the scene, and also remove the rocket and enemy from the
    array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环，因为我们在这里需要循环中对象的索引。我们遍历场景中的所有火箭，并通过遍历`enemies`数组来检查场景中所有敌人的碰撞。如果任何火箭与敌人发生碰撞，则从场景中移除火箭和敌人精灵节点，并从数组中移除火箭和敌人。
- en: Finally, create a new global variable `var` called `score` of type `int` and
    initialize it equal to zero at the top of the class, as shown in the following.
    We increase the score by 1 after checking the collision, to keep track of the
    score.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在类的顶部创建一个新的全局变量`var`，命名为`score`，类型为`int`，并将其初始化为0，如下所示。在检查碰撞后，我们增加分数1，以跟踪分数。
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can log the score in the console to check whether the score variable is actually
    increasing. But how will the player know how much he/she has scored?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台中记录分数以检查分数变量是否实际上在增加。但是，玩家如何知道他们已经获得了多少分数？
- en: Displaying the score
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示分数
- en: 'For showing the score, we will use a `SKLabelNode` and assign the value of
    the score every time the score is changed. Since we will need to access this variable
    in the `checkCollision` function, it has to be a global variable. So, create a
    variable called `scoreLabel` of type `SKLabelNode` along with the other global
    variables at the top:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示分数，我们将使用`SKLabelNode`，并在分数每次更改时分配分数值。由于我们将在`checkCollision`函数中访问此变量，它必须是一个全局变量。因此，在顶部创建一个名为`scoreLabel`的变量，类型为`SKLabelNode`，与其他全局变量一起：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `init` function, right after we added the hero, we can add the following
    lines to initialize the `scoreLabel` variable:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，在我们添加英雄后，可以添加以下行来初始化`scoreLabel`变量：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We give a font name to use as the font, which is `Chalkdust`. Then we assign
    the actual text to be displayed. We will later change the value of this text,
    depending on what the score variable is later in the `checkCollision` function.
    We set the size to `45` and place the `scoreLabel` at 90 percent of the height
    of the display, so that it is at the top of the screen, and place it at the center
    of the width of the screen. Finally, we add the `scoreLabel` to the current scene.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为要使用的字体指定一个名称，即`Chalkdust`。然后我们分配要显示的实际文本。稍后，在`checkCollision`函数中，我们将根据分数变量的值更改此文本的值。我们将大小设置为`45`，并将`scoreLabel`放置在显示高度的90%，以便它在屏幕顶部，并将其放置在屏幕宽度的中心。最后，我们将`scoreLabel`添加到当前场景中。
- en: If you run the game now, the text that we assigned will be displayed, but the
    score won't update. For the score to update, we have to change the text and assign
    the actual value of the score variable we created earlier.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，我们将分配的文本将会显示，但分数不会更新。为了更新分数，我们必须更改文本并分配我们之前创建的分数变量的实际值。
- en: 'So, right after we increment the score in the `checkCollision` function, add
    the following to increment the score text of the label:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们通过`checkCollision`函数增加分数后，立即添加以下代码来增加标签的分数文本：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Similar to how we log variables to the console, we assign the score value to
    the string and then pass it to the text property of `scoreLabel`. Now, if we build
    and run the game, it should display the current score, as shown in the following
    screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将变量记录到控制台的方式类似，我们将分数值分配给字符串，然后将其传递给`scoreLabel`的文本属性。现在，如果我们构建并运行游戏，它应该显示当前分数，如下面的截图所示：
- en: '![Displaying the score](img/B04014_04_17.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![显示分数](img/B04014_04_17.jpg)'
- en: Displaying the game over screen
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示游戏结束屏幕
- en: Once the game is over, we have to display **GameOver!** to the player and add
    a button so that the player can go back to the main menu.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束后，我们必须向玩家显示**GameOver!**，并添加一个按钮，以便玩家可以返回主菜单。
- en: 'In the `GameOver` function, add a label called `myLabel` after we called the
    function to stop all the actions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOver`函数中，在调用停止所有动作的函数后添加一个名为`myLabel`的标签：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We add the **GameOver!** text of font size `65` so that it is easily visible
    to the player and place it slightly above the center of the screen to make space
    for the main menu button that we will be adding next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了字体大小为`65`的**GameOver!**文本，以便玩家可以轻松看到，并将其放置在屏幕中央稍上方，为即将添加的主菜单按钮腾出空间。
- en: Adding the main menu button
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加主菜单按钮
- en: 'Next, in the `GameOver` function, a SKSpriteNode called `menuBtn` is created,
    and we pass the `menuBtn` image set to it. For creating the image set in `images.xcassets`,
    `homeBtn.png`, and `homeBtn2.png` are included in the `Resources` folder. We place
    it at the center of the screen. We also give it a name so that we can refer to
    it later in the `touchesBegan` function so that if it is pressed, we can call
    some function on it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GameOver`函数中，创建一个名为`menuBtn`的SKSpriteNode，并将`menuBtn`的图像集传递给它。为了在`images.xcassets`中创建图像集，`homeBtn.png`和`homeBtn2.png`被包含在`Resources`文件夹中。我们将它放置在屏幕中央。我们还给它起了一个名字，以便我们可以在`touchesBegan`函数中引用它，以便如果它被按下，我们可以调用它的一些函数：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, in the `touchesBegan` function, after we checked if the game is over
    or not, add an `else` block and add the following code to replace the current
    scene with the `MainMenuScene`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`touchesBegan`函数中，在我们检查游戏是否结束之后，添加一个`else`块，并添加以下代码以替换当前场景为`MainMenuScene`：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Adding the main menu button](img/B04014_04_18.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![添加主菜单按钮](img/B04014_04_18.jpg)'
- en: Similar to how we made the play button interactive, if the game is over, we
    check whether the player touched the screen. If the location that he tapped contains
    the node name `menuBtn`, we create a local object called `scene` and assign the
    `MainMenuScene`, and then we replace the current scene with the `MainMenuScene`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们制作播放按钮交互的方式类似，如果游戏结束，我们检查玩家是否触摸了屏幕。如果他点击的位置包含节点名称`menuBtn`，我们创建一个名为`scene`的本地对象，并分配`MainMenuScene`，然后替换当前场景为`MainMenuScene`。
- en: As far as gameplay goes, we are done with it. Now let's add a feature that allows
    us to save the high score, so that we can challenge the player to beat it, to
    increase replayability of the game.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏玩法而言，我们已经完成了。现在让我们添加一个功能，允许我们保存最高分，这样我们就可以挑战玩家打破它，以增加游戏的可玩性。
- en: Saving the high score
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存最高分
- en: For saving the high scores, we can use the `NSUserDefaults` property. Here we
    can use a key and assign a particular value to it which the device will store
    in its memory, so that we can retrieve later. The best thing about this is, we
    can retrieve and rewrite the value stored in it currently, to some other file.
    So, here we will store the high score in `GamePlayScene` and later the value stored
    in the key, in the `MainMenuScene`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于保存最高分，我们可以使用`NSUserDefaults`属性。在这里，我们可以使用一个键并为其分配一个特定的值，设备将将其存储在其内存中，以便我们稍后可以检索。最好的事情是，我们可以检索并重写它当前存储的值，到另一个文件中。因此，这里我们将最高分存储在`GamePlayScene`中，稍后，在`MainMenuScene`中存储的键的值。
- en: Since it is a dictionary, you can store integer, floats, and string. In this
    case, since the high score will always be an integer, we will get and store an
    integer for the key. The key here is a string and the value that is stored is
    an integer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个字典，你可以存储整数、浮点数和字符串。在这种情况下，由于最高分始终是整数，我们将为键获取并存储一个整数。这里的键是一个字符串，存储的值是一个整数。
- en: 'For retrieving the high score value, add the following code after we added
    `menuBtn` in the `GameOver` function:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检索最高分值，在`GameOver`函数中添加`menuBtn`之后添加以下代码：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since no value is stored currently in the key, it will return zero.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前没有在键中存储值，它将返回零。
- en: 'For congratulating the players on getting a new high score, create a new `SKLabelNode`,
    right after we added the `currentHighScore`, and call it `highScoreLabel`, as
    shown in the following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了祝贺玩家获得新的最高分，创建一个新的`SKLabelNode`，在我们添加了`currentHighScore`之后，并称它为`highScoreLabel`，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We create the label with font `Chalkduster`. We set the initial text value to
    a blank so that we can change it later depending on whether the player beats the
    high score or not. We set the text height to `45`, and place it below the button
    and then add it to the scene.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个带有`Chalkduster`字体的标签。我们将初始文本值设置为空白，以便我们可以根据玩家是否打破最高分来稍后更改它。我们将文本高度设置为`45`，并将其放置在按钮下方，然后将其添加到场景中。
- en: 'Next we check the value stored in `currentHighScore` against the current `score`
    and see if the `currentHighScore` value is greater than the current `score`, as
    shown in the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查存储在`currentHighScore`中的值与当前`score`的值，看看`currentHighScore`的值是否大于当前`score`，如下所示：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If the score is higher than the current high score, then we call the `setInteger`
    function of `standardUserDefaults` and assign the new high score that is the current
    score and the key to store it against. When assigning keys, make sure it is unique.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分数高于当前最高分，那么我们调用`standardUserDefaults`的`setInteger`函数，并将新的最高分（即当前分数）和键分配给它存储。在分配键时，请确保它是唯一的。
- en: To save the data to the device, we have to call the `synchronize` function.
    If we fail to call this, once you close the application, the data will be lost,
    so make sure to call this function each time you store the value against a key.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据保存到设备，我们必须调用`synchronize`函数。如果我们未能调用此函数，一旦关闭应用程序，数据将会丢失，所以请确保每次存储值时都调用此函数。
- en: We then congratulate the player on getting a new high score by changing the
    text property to show the current score, which is the new high score.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过更改文本属性来祝贺玩家获得新的高分，显示当前分数，即新的最高分。
- en: If the player didn't beat his current high score, then in the `else` statement
    we change the text property of the `highScoreLabel` to show that he can do better
    than the current score so that it will motivate him to play the game again and
    beat his previous high score.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家没有打破他当前的最高分，那么在`else`语句中，我们更改`highScoreLabel`的文本属性，显示他可以比当前分数做得更好，这样就会激励他再次玩游戏并打破之前的最高分。
- en: In the following screenshot, I scored **7**, which is okay I think. With a little
    bit of practice, I think I will be able to do better. It is also just to demonstrate
    that the code works fine, and if the current score is greater than the high score,
    then it shows the new high score.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我得了**7**分，我认为这还不错。经过一点练习，我认为我会做得更好。这也只是为了证明代码运行正常，如果当前分数高于最高分，那么它将显示新的最高分。
- en: '![Saving the high score](img/B04014_04_19.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![保存最高分](img/B04014_04_19.jpg)'
- en: If the current score is less than the current high score, then you will see
    the following screen. Here I got a **4**, which is less than the current high
    score saved in memory that is **7**.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前分数低于当前最高分，那么你会看到以下屏幕。这里我得了**4**分，低于保存在内存中的当前最高分**7**。
- en: '![Saving the high score](img/B04014_04_20.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![保存最高分](img/B04014_04_20.jpg)'
- en: Resetting the high score count
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置最高分计数
- en: What if the player wants to reset their high score to zero? We can do this by
    adding a button in the main menu and resetting the value of the key to zero.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家想要将他们的最高分重置为零呢？我们可以通过在主菜单中添加一个按钮并重置键的值为零来实现这一点。
- en: Open the `MainMenuScene.swift` file, and in the `didMoveToView` function where
    we created the play button, create one more SKSpriteNode called `resetBtn`. Place
    this button at three-fourth of the width of the screen and name the sprite `resetBtn`.
    We will use the name to check whether the player clicked the play button or the
    reset button.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainMenuScene.swift`文件，在创建播放按钮的`didMoveToView`函数中，创建一个名为`resetBtn`的`SKSpriteNode`。将此按钮放置在屏幕宽度的四分之三处，并命名为`resetBtn`。我们将使用此名称来检查玩家是否点击了播放按钮或重置按钮。
- en: 'The assets for the reset button are in the `Resources` folder, so create a
    new image set called `resetBtn` and drag-and-drop `resetBtn.png` and `resetBtn2.png`
    to the **1x** and **2x** placeholders, respectively, as shown in the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 重置按钮的资产位于`Resources`文件夹中，因此创建一个新的图像集`resetBtn`，并将`resetBtn.png`和`resetBtn2.png`分别拖放到**1x**和**2x**占位符中，如下所示：
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, in the `touchesBegan` function where we checked for `playBtn`, add an
    `else if` block and check whether `resetBtn` is pressed, like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`touchesBegan`函数中，我们在检查`playBtn`时添加一个`else if`块，并检查是否按下了`resetBtn`，如下所示：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the reset button is pressed, we set the value of the key by which we have
    been getting the value, to zero and call the synchronize function again so that
    this value is stored in the system.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下重置按钮，我们将通过我们获取值的键的值设置为零，并再次调用`synchronize`函数，以便将此值存储在系统中。
- en: 'Now, as one last thing, let''s show the player the current high score when
    the application opens, so create a new global variable called `currentHighScoreLabel`
    of type `SKLabel` at the top of the `MainMenuScene` class, as shown in the following
    code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为最后一件事，当应用程序打开时，让我们向玩家展示当前的最高分，因此，在`MainMenuScene`类的顶部创建一个新的全局变量`currentHighScoreLabel`，类型为`SKLabel`，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we add the following in the `didMoveToView` function right after where
    we added the reset button:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`didMoveToView`函数中添加以下内容，紧接在添加重置按钮之后：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We first get the current high score stored, and then assign the value to the
    text. The rest of the code is similar to the code except that the `y` value for
    the position is multiplied by 0.2 instead of 0.3, as the play button is pretty
    big.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取存储的当前最高分，然后将这个值赋给文本。其余的代码与之前的代码类似，只是位置`y`的值乘以0.2而不是0.3，因为播放按钮相当大。
- en: 'We also need to change the text once the high score is reset, so in the `else
    if` block where we check whether the reset button is pressed, under the place
    where we added code to reset the value for the key, add the highlighted lines
    shown here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在重置最高分后更改文本，所以在我们检查是否按下重置按钮的`else if`块中，在添加代码重置键的值的地方，添加这里显示的突出显示的行：
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we get the stored value again just to check whether the value that we
    stored earlier is actually reflected. Then we set text of `currentHighScoreLabel`
    to this value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次获取存储的值，只是为了检查我们之前存储的值是否确实得到了反映。然后我们将`currentHighScoreLabel`的文本设置为这个值。
- en: 'We could have just set the text as `Current High Score: 0` and it would have
    still worked without a problem, but this way, we would not have been sure whether
    the value for the key was actually set to zero.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将文本设置为`当前最高分：0`，这样它仍然可以正常工作，但这样我们就不确定键的值是否实际上被设置为零。
- en: Now, if you run the code, you can see the current high score displayed at the
    main menu screen when the game starts. You can also verify that the value of the
    high score is actually set to zero once you reset it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行代码，你可以在游戏开始时看到主菜单屏幕上显示的当前最高分。你还可以验证一旦重置，最高分的值实际上被设置为零。
- en: 'So, in the following screenshot, the main menu scene, once again, is showing
    my current high score, even though this code was added after achieving my new
    high score:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下面的屏幕截图中，主菜单场景再次显示了当前最高分，尽管这段代码是在达到新最高分之后添加的：
- en: '![Resetting the high score count](img/B04014_04_21.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![重置最高分计数](img/B04014_04_21.jpg)'
- en: 'In the next screenshot, we can be sure that the value of the current high score
    changes once the reset button is pressed:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张屏幕截图中，我们可以确定一旦按下重置按钮，当前最高分的值就会改变：
- en: '![Resetting the high score count](img/B04014_04_22.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![重置最高分计数](img/B04014_04_22.jpg)'
- en: So this is all for this chapter. Save this file and keep it, as we will need
    it again in the next chapter.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是这一章的全部内容。保存这个文件并保留它，因为我们在下一章还需要它。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a pretty long chapter and we actually made a complete working game
    in it. We created the main menu and gameplay scenes using SKScenes and added interactive
    buttons to move between the scenes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章相当长的内容，我们实际上在其中制作了一个完整的游戏。我们使用SKScenes创建了主菜单和游戏场景，并添加了交互式按钮来在场景之间切换。
- en: You learned how to import assets into the project, add them onto the screen,
    and make them move around and interact with each other. You also saw how to remove
    objects from the screen and add and update the score.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何将资源导入项目，将它们添加到屏幕上，并使它们移动并相互交互。你还看到了如何从屏幕上移除对象以及添加和更新分数。
- en: Finally, you saw how to store and retrieve the current high score on the device.
    However, we are not done with the game. We still need to add animations, particle
    effects, and background music and sounds effects to the game to make it come alive.
    Hope you guys are looking forward to it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了如何在设备上存储和检索当前最高分。然而，我们还没有完成游戏。我们还需要添加动画、粒子效果和背景音乐及音效，让游戏变得生动起来。希望你们都在期待它。
- en: In the meantime, you can practice and try to beat my high score.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你可以练习并尝试打破我的最高分。
