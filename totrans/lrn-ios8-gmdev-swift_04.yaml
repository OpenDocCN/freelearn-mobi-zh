- en: Chapter 4. SpriteKit Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After an entire chapter of theory, we have finally reached the chapter where
    we will be creating a game. I am sure that this is a moment you have been waiting
    for and your fingers are aching to write some code and make a game.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create a small and basic game using SpriteKit. We
    will see how to create the main menu of the game, and you will learn how to transition
    from the main menu scene to the gameplay scene, where all of the gameplay code
    will be written.
  prefs: []
  type: TYPE_NORMAL
- en: In the gameplay scene, we will add sprites, such as the background and hero,
    first. We will then create a small physics engine to make the hero move around.
    Then, we will add in the enemies, and move them too. Next, we will make the hero
    and the enemies shoot at each other. We will detect collision between the hero's
    rockets and the enemies, and between the enemies' bullets and the hero. For each
    enemy the hero shoots, we will get one point, but if any of the enemies go past
    the left of the screen, it will be game over. If the current high score is greater
    than the previous score saved, then your current score will be saved as the new
    high score. Once the game is over, the player can click on the button to go back
    to the main menu to start the game. I hope you are excited! Let's finally jump
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SpriteKit and SKScene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a main menu scene and a gameplay scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and moving the Hero sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interactivity with touches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple physics engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing hero rockets and enemy bullets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoring and game over conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying, saving, and retrieving the score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to SpriteKit and SKScene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*, how to create a SpriteKit project. Just to jog your memory,
    I will show you once again how to create a project. Click on **Xcode**, and then
    on **Create a new Xcode Project**. Then, on the left-hand side panel, navigate
    under **iOS**, and then under **Application** and select **Game**. Then click
    on **Next**. Give a new name to the project. Select the language as **Swift**,
    the game technology as **SpriteKit**, the device as **iPad**, and then click on
    **Next**. Select the location where you want the project folder to be created
    and click on **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that the majority of the project structure remains similar to
    the SingleView project we saw in the previous chapter. We have the `GameScene.sks`,
    `GameScene.swift`, and `GameViewController.swift` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameScene.sks`: This is a serialized `SpriteKitScene` file. This is used to
    create SKScenes visually without writing code. So, for example, you can drag-and-drop
    images and design them as buttons, and by clicking on them, you can make them
    perform different functions. But since we will be writing it all in code, we won''t
    be using this file to create the interface of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameScene.swift`: This is inherited from SKScene. SKScenes are the building
    blocks of games. This class is called once the application view is loaded. You
    can create SKScene files to create the main menu Scene, gameplay scene, options
    scene, and so on. In fact, we will later rename the `GameScene.swift` file to
    `MainMenuScene.swift` and create a new scene called `GamePlayScene`, where will
    write our gameplay code.![Introduction to SpriteKit and SKScene](img/B04014_04_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameViewController.swift`: This class is similar to the `ViewController.swift`
    file we saw in the previous chapter. In the `Main.Storyboard` file, you will see
    that there is a `GameViewControllerScene` file instead of `ViewController`, but
    the structure is very similar to it. If you click on **GameViewController**, you
    can see that it calls the `GameViewController` class on the **Utility** panel
    under the **Identity** inspector. Refer to the preceding diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, open the `GameViewController.swift` file. You will see some new functions
    and some older functions that we saw in `ViewController.swift`. You will also
    notice that SpriteKit has been imported. We will need to import SpriteKit in all
    the classes in which we want to use its features. All classes and objects that
    are part of SpriteKit start with the prefix `SK`, so SpriteKit Scenes are `SKScene`,
    sprites are `SKSpriteNode`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A `SpriteKitNode` or `SKNode` is the basic building block required for creating
    any content in SpriteKit, but unlike an `SKScene` or `SKSpriteNode`, it doesn't
    draw any visual content. However, both `SKScene` and `SKSpriteNode` are child
    classes of `SKNode`. So, if `SKScene` is the building block of any game, `SKNode`
    is the basic building block of SpriteKit itself. A detailed explanation is provided
    under the SpriteKit section in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the SpriteKit, we see that an extension of SKNode is created
    with a class function called `unarchivedFromFile`, which takes a string and returns
    an SKNode. The following function is used to load the `.sks` file we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the extension, we see the actual class of `GameViewController`. It is
    still inheriting from `UIViewController`. Similar to the `ViewController.swift`
    file, the first function called here is `viewDidLoad`, which is the function that
    is called as soon as the view gets loaded. The `super.viewDidLoad` function is
    called, which calls the `viewDidLoad` of the parent class. Then, the `GameScene.sks`
    file is loaded using the extension that was created earlier. The `if let` statement
    checks if the object scene is empty or not. If it is not empty, then the code
    in the `if` block will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`extension`: In Swift, you can add functionality to an existing class. In the
    preceding case, we are adding a new function called `unarchivedFromFile` to the
    `SKNode` class, which unarchives files and returns an SKScene. This function is
    used to unarchive the `SKS` file in the `viewDidLoad` function in the following
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`if let`: This checks if the object scene is empty or not. If it is not empty,
    then the code in the `if` block will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`as`: This operator is used to downcast SKView since it is actually a subclass
    of `UIView`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A new variable, `skView` is created and the current view is assigned to it by
    type casting it as an SKView since the root view of `GameViewController` is an
    SKView.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `showsFPS` and `showsNodeCount` properties of the scene are set to
    `true`, which will show the **FPS** and **Node Count** on the bottom-right of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `ignoreSiblingOrder` property is set to `true`, meaning that if one or more
    objects are at the same depth, then it won't prioritize between them and all objects
    will be drawn at the same depth.
  prefs: []
  type: TYPE_NORMAL
- en: The value of **Z order,** or depth order, decides which object is at the front
    and which object is at the back of the screen. The object with the smallest **Z**
    value is kept at the back of the screen and the object the with highest value
    is the closest to the screen. If no Z order value is assigned to an object, SpriteKit
    will assume that this object is above the previous object added. That is why in
    all games, the background is added first so that it is at the lowest Z order and
    other objects such as the hero are added next. If you were to add the hero first
    and then the background, the hero would be at the lowest Z order and the background
    image that covers the whole screen would be above it. You might think that there
    is something wrong with the code or SpriteKit since the hero is not being displayed
    only the background. The fact is that the hero is there but he is behind the background.
    So, be careful about Z orders as this may lead to bugs or unexpected results in
    games.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the order, we can set the `scaleMode` property of the scene.
    Here, by default, it has been set to `AspectFill`. There are four modes: `AspectFill`,
    `Fill`, `AspectFit`, and `ResizeFill`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AspectFill`: This is the default mode when you create a new project. In this
    scale, both *x* and *y* scale factors are calculated and the large-scale factor
    is chosen to fill the view and maintain aspect ratio of the image. This will lead
    to cropping of the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us create a project and place characters at the top-right and bottom-left
    corners, and observe what happens when we move from the landscape mode to the
    portrait mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the landscape mode, both characters are displayed as they should be. One
    at the bottom left and the other at the top-right corner of the screen, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'But in the portrait mode, they have gone out of bounds of the screen, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '`Fill`: Both *x* and *y* axes are scaled to fill the view. The view is the
    region that is shown once you click on the view in the `Main.Storyboard` file.
    The aspect ratio of the image will change both in terms of the width and height,
    to fill the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we do the same test with `.Fill,` once again in landscape mode, the images
    appear to be normal, but in the portrait mode, the two images are in their respective
    locations, but they are squashed to fit, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '`AspectFit`: Instead of the upper scale factor, the lower scale factor will
    be chosen to maintain the aspect ratio of the scene. This may lead to letterboxing
    of the scene, but all the content of the scene will be displayed and will be visible
    in view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this mode, once again everything looks fine in the landscape mode, but
    then in the portrait mode, the image is not at all squared; the whole scene is
    scaled down to fit to the width of the screen. This will cause letterboxing on
    the top and bottom of the screen, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '`ResizeFill`: The scene is not scaled at all. It is just resized to fit the
    view. The images will maintain the original size and aspect ratios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, since the aspect ratio and scale are maintained, the bottom-left image
    is shown at the right position but the top-right image goes out of bounds of the
    screen, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Looking at the preceding screenshots of the four modes, we can see that not
    all sizes fit all. You need to tinker with the scale mode to best suit the needs
    of your game. Since our game is primarily designed to be played in the landscape
    mode, we will just disable the portrait mode. So, in the main project node, disable
    the **Portrait** mode and **Upside Down** by unchecking it in the **General**
    tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to SpriteKit and SKScene](img/B04014_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also be using `ResizeFill` as we will be providing separate images
    for Retina and NonRetina assets of the devices, so that aspect ratio is not affected,
    resulting in nice full-screen images instead of cropped or scaled images. So,
    in the `GameViewController` class, change the scale mode to `ResizeFill` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the scene is loaded and presented using the `presentScene` function
    of the `skView` object.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `GameScene.swift` file is presented, the `didMoveToView` function is
    called, which, as we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*, shows the `SKLabelNode` label showing the **Hello, World!**
    text, and each time you click on the screen, the `touchesBegan` function gets
    called, and at the location of the touch, a SKSpriteNode is created and an action
    is run on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three new functions: the `shouldAutoRotate` function, which is set
    to `true`, and will rotate the view if the device is rotated; the `supportedInterfaceOrientation`
    function, which checks for the orientation and aligns view accordingly; and the
    `prefersStatusBarHidden` function, which hides status bar elements, such as network
    and battery indicators on the top of the screen. You can enable or disable them
    depending upon your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now change the `GameScene` to start making our game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a main menu scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us make some changes to the `GameScene` class to make it our main menu
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file to `MainMenuScene.swift` by selecting the file in the project
    hierarchy in the project navigator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the name of the class in the file to `MainMenuScene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the lines of code inside `didMoveToView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `touchesBegan` function, delete the code related to the adding of the
    sprite and the running of the action upon it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `update` function as it is not required for the main menu scene.
    If required, we will add it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `MainMenuScene.swift` file should look like the following code snippet,
    as we deleted all the code from the `didMoveToView` function and modified the
    `touchedBegan` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Delete the `GameScene.sks` file from the project hierarchy by moving it to **Trash**.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to make some changes to the `GameViewController.swift` file as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the extension created for SKNode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `if let` scene line and the opening and closing bracket since we
    will be calling the `MainMenuScene` class directly through code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the above line with `let scene = MainMenuScene(size: view.bounds.size)`.
    The SKScene constructor takes the size of the screen, so here we get it from the
    `bounds.size` property of the view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `.AspectFill` to `.ResizeFill`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The rest of the file can remain the same. Now the `viewDidLoad` function should
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's start adding content to the main menu scene next.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainMenuScene.swift` file in the `didMoveToView` function, we will first
    add the background image, then we will add a label that will display the name
    of the game, and then we will finally add the play button, which, if clicked,
    will launch `GamePlayScene` and start the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the background image, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a constant variable called `BG` and assign an image set named `BG`
    to it. Then, we position this image. For positioning the image, we need the size
    of the view. It is very simple to get the width and height of the view. We create
    a new constant called `viewSize` of type `CGView` and assign `view.bounds.size`
    to it. So, add the following at the start of the `didMoveToView` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can now set the position of `BG`. To set the position, we assign `BG.position`
    equal to half of the width and half of the height of the size of the view. Whenever
    we need to assign or create a new `CGPoint` variable, we have to call CGPoint,
    and in the brackets provide the `x` and `y` values separated by a comma. The `x`
    value needs to be prefixed with `x` and then a colon and, similarly, the `y` value
    needs to be prefixed with `y` followed by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: For the background to get displayed, we will have to call the `addChild` function
    on self, and pass in the background created.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, it will give errors as we have still not assigned an
    actual image to the project. For this, go to the `Resources` folder of this chapter
    and copy all the assets onto the desktop. This will contain all the assets that
    will be used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to the `Images.xcassets` file in your project navigator, and right-click
    on the panel and select **New Image Set**, as shown in the following screenshot.
    A new file called `Image` will be created. Select and rename it to `BG`. When
    we call `BG` while creating the sprite for the background, we are actually referring
    to this file. So, if you name it incorrectly, the code will give errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a main menu scene](img/B04014_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The file has placeholders for **1x**, **2x**, and **3x** images. Since we are
    making the game for the iPad, there are only two resolutions we have to worry
    about; the 1024 x 768 and 2048 x 1536 resolutions. Our BG is also of the same
    two resolutions. In the `Resources` folder, look for image files `Bg.png` and
    `Bg2.png`. Drag `Bg.png` to the **1x** box and `Bg2.png` to the **2x** box, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a main menu scene](img/B04014_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can run the application and the screen will display the background image
    in all its glory. On the simulator, you can select **iPad2** or **iPadAir**, and
    you will see the image will fill the entire screen, as shown in the following
    screenshot. Make sure you are running in the landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a main menu scene](img/B04014_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we will add the label to display the name of the game. Labels are used
    to display text onto the screen. Add the following code to display the label right
    after we added the BG to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We create a new constant called `myLabel` and call the constructor of `SKLabelNode`.
    It takes the name of the font we want to use to create the text, so we pass in
    `Chalkduster`, which is one of the default fonts in Mac. In `myLabel.text`, we
    pass in the actual text that we want to display. Next we assign the size of the
    font, its position, and add it to the current class as a child. To create text,
    we don't have to create an image set but we have to have the font in the system
    as it is automatically taken from the system's font directory.
  prefs: []
  type: TYPE_NORMAL
- en: Let us create the play button next. In the `Resources` folder, you will find
    `playBtn.png` and `playBtn2.png`. Similar to how we created an image set for `BG`,
    create one for the play button by naming the file `playBtn`. Drag the `playBtn.png`
    image to **1x** and `playBtn2.png` to **2x**.
  prefs: []
  type: TYPE_NORMAL
- en: For all the assets in the `Resources` folder, you will find two of each, one
    with the filename and the second one ending with a `2` at the end. Make sure,
    henceforth, that the regular filename asset is assigned to **1x** and one with
    the `2` at the end of the file is assigned to **2x**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now appropriate images are assigned to the `playBtn` image set. Add the following
    code right under where we added the code for the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `playBtn` image set is also a regular SKSpriteNode, so similar to how we
    added `BG`, we will assign the `playBtn` image set to the `playBtn` constant.
    Position it at the center of the view and then add it to the view.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to what we do usually, I have also assigned a name to the `playBtn`
    constant so that we can refer to it later, if needed. It is not necessary that
    you assign a string; you can even assign an integer value if you wish. It should
    be named something that you find easy to remember and associate the constant with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you build and run the project, it should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a main menu scene](img/B04014_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will add code in the `touchesbegan` function to check whether the
    play button was pressed. In the `touchesbegan` function, we first check whether
    any object was touched on the screen, and then, if it was touched, we get the
    location of the touch. After getting the location, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We create a new constant called `_node` of type `SKNode` and get the node that
    is at the touched location. We then check whether the name of the node pressed
    is `playBtn`, if it is pressed, then we create a constant named `scene` and assign
    `GameplayScene` to it, and then present the scene like we presented `MainMenuScene`
    in the `GameViewController` class. Since we have not created `GamePlayScene`,
    you will get an error. Don't worry, we will be creating it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark after `self.view` checks if the view is empty or not. If it
    is empty, it will give an error, but since the view exists, it won't give an error.
    Let us create the gameplay scene so that we don't get errors saying that it doesn't
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a gameplay scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All this time, we have been modifying the files already included with the base
    project. Now we will create a new file in the project. Right-click on the base
    project folder and click on **New File**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a gameplay scene](img/B04014_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the left panel, select **iOS** and select the Swift file, and then click
    on **Next**. It will ask for the name of the file, call it `GamePlayScene` and
    click on **Create**. This will create an empty Swift file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in it. This is the basic structure required whenever
    you create a new scene file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We first import SpriteKit, and then we create the class using the `class` keyword
    followed by the name of the class and inherit from `SKScene`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the `required init` function after that. Since superclass `SKScene`
    implemented it, it has to be included in all the subclasses. This is a requirement,
    so there is no avoiding it, but we won't be using it for anything as we will be
    using the regular `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: The regular `init` function of an SKScene takes in the size of the view. Then
    we have to make sure we call the `super.init` function and pass the size of the
    view in it as well.
  prefs: []
  type: TYPE_NORMAL
- en: That's it, and we are ready to add some gameplay code in this class. You can
    check in the `MainMenuScene.swift` file that there are no errors and code is building
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GamePlayScene.swift` file, first we have to create a global variable
    for the `viewSize`. So, between the class and the required `init` function, add
    `let viewSize:CGSize!` to make `viewSize` a global variable. Also, we use `let`
    instead of `var` as we know that the size of the view won't change in the middle
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not initializing the constant here, we have to use an exclamation
    mark at the end to tell Swift that we will initialize it and we know that the
    type that we will initialize will be `CGSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize `viewSize` equal to the size that got passed in the `init` function.
    Add the following line after `super.init` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding a background and a hero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going add the background first, so we can copy and paste the same code
    from the `MainMenuScene` into the `init` function right after where we initialized
    `viewSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next we will add the hero sprite. Similar to how we created the `BG` image asset,
    create a new asset called `hero` and assign `hero.png` and `hero2.png` to the
    **1x** and **2x** slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we want the hero to be a global variable aswell, as we will need to refer
    to her outside of the `init` function. So, right under where we created the `viewSize`
    property, add the following line of code at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `init` function after where we added `BG`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, as usual, we assign the image set `hero` to the constant, assign the position,
    and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how we positioned the background, we position the hero, but instead
    of adding the hero in the center, we place her at a distance of one fourth the
    `viewSize` from the left of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the position of the hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s update the position of the hero. Let us add gravity to the scene
    so that she starts falling down once the game starts. For updating her position,
    we will use the `update` function. The `update` function gets called as soon as
    the class gets created and it gets called 60 times a second. So, add the `update`
    function to the class as follows. Call a `updateHero()` function in it, we will
    define this function shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new global constant after the `let hero` line called `gravity` of
    type `CGPoint` and initialize it with `x` value `0` and a `y` value of `–1` as
    gravity only affects in the negative *y* direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will also create a new function called `updateHero` in which we will write
    all the code to update the hero's position. Create this function under the `update`
    function and don't forget to call this function in the `update` function, otherwise
    the hero's position won't be updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `updateHero` function, we are decrementing the `y` position of the hero
    in each update. Eventually, she will fall through the bottom of screen. To make
    her stay within the bounds, we check whether she is about to go beyond the screen
    and place her back at the bottom edge of the screen. To do this, add the following
    in the `heroUpdate` function right under where we decrement her position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the first `if` block, we check whether the bottom of the hero has crossed
    the bottom of the screen. If so, then we place the hero's origin at half her height
    from the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the `else if` block, we check whether the top of the hero has crossed the
    top of the screen. If so, then we place her at half her height from the top of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you build and run the game and press play, the hero will be at one fourth
    of the distance from the left of the screen and will stop once she reaches the
    bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the position of the hero](img/B04014_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding player controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now add player controls by using the `touchesbegan` function. If the
    player taps the left side of the screen, the hero get pushed up and will then
    start falling again due to gravity, and if the player taps the right of the screen,
    the hero will fire rockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For detecting touches, add the `touchesBegan` function under the `update` function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously the same function that we used in `MainMenuScene` to detect
    touches on the play button. Since we are just going to be checking the location
    of the touch, we don't require the object we touched, for now at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect which side of the screen was tapped, add the following code under
    where we get the location of the touches in the `for in` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We check whether the `x` value of the touched location is less than half of
    the width of the screen. If so, then we print out that the left side of the screen
    was touched, otherwise we check whether the `x` value of the touched location
    was greater than half of the width of the screen, then in that case, we can confirm
    that the right of the screen was touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to push the hero up in the air, we give her a small thrust each time the
    player touches the left of the screen. Add a global variable called `thrust` of
    type `CGPoint` and initialize both `x` and `y` values to zero as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using `var` and not `let,` as the value of `thrust` will change
    over a period of time. Also, `CGPointZero` is just short for `CGPoint(x:0, y:0)`.
    They will both do the same thing, so it is just a matter of convenience and preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `touchesBegan` function, right after we checked if the left part of
    the screen is tapped, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `updateHero` function, change the line `hero.position.y += gravity.y`
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever the left side of the screen is touched, the hero will be pushed
    up by 15 points and then she will start falling down after reaching the highest
    position. Log the value of `thrust.y` as follows to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the screen is tapped, the `y` value of `thrust` that was initially set
    to `0` is set to `14`. It is not 15 since we are subtracting 1 from it due to
    gravity. Then, at each update, the `y` position of the hero is slowly decreased
    until it becomes zero, and gravity will start acting again and start pulling the
    hero down.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you will notice is that when the hero is at the bottom of the screen
    and you apply an upward thrust, the hero doesn''t immediately start moving up.
    The answer to why this is also visible in the console output of `thrust.y`. As
    the gravity is added to the `thrust.y`, its value becomes huge and the small thrust
    of 15 has to overcome this value to make the hero move up again. To solve this,
    we have to set the value of `thrust` back to zero once the hero touches the top
    or the bottom of the screen. So, in the `updateHero` function, where we check
    whether that she touched the top or bottom of the screen, add the following line
    in both the `if` and the `if else` blocks after setting the hero''s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We will next add the rockets that fire when the right side of the screen is
    tapped. For this, we will create a new generic class so that we can use it later
    for creating enemies and enemy bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we created the `GamePlayScene.swift` file, create a file called `MovingSprite`,
    and in this file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we import SpriteKit and then create the definition of the class.
    We create two global constants for holding the reference of the SKSpriteNode and
    CGPoint objects we will be passing into the constructor. The SKSpriteNode will
    hold the sprite that we will be passing in, and `CGPoint` will hold the speed
    with which we want the sprite to move by.
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` function, we assign the objects passed in to the local objects
    we have created. We have added one more function called `moveSprite`. This will
    move the sprite with the speed that was assigned to it. That is all for this class
    for now. We will revisit and modify this class when we add the enemy and bullets
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For creating the rockets, create a new function called `addRockets` in the
    `GamePlayScene` file. In it, we add the following code to create the rockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the `addRockets` function, we first create a constant called `rocketNode`
    of type `SKSpriteNode` and assign a rocket from the `imageset`. So, create a new
    image set and name it `rocket`. In the `Resources` folder, you will find `rocket.png`
    and `rocket2.png`, which you can assign to the **1x** and **2x** slots, respectively,
    in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set the position of the rocket. Since we want the rockets to appear
    to be coming out of the bazooka, instead of spawning in at the position of the
    player, we place it at the front end of the bazooka. So, for the `x` position,
    we get the player's position, and then add half of the width of the player to
    it and also add half of the width of the rocket itself to it. For the `y` position,
    we get the y position of the hero and subtract half of the height of the rocket
    from it. We then add it to the scenes display list.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create an object called `rocket` of the type `MovingSprite` and assign
    the speed with which we want to move the sprite and pass in the `rocketNode` we
    created earlier. For assigning the speed, we create a new constant called `speed`
    of type `CGPoint` and assign `10` and `0` to the `x` and the `y` values, respectively,
    so that whenever we call the `moveSprite` function of the class, the position
    will update in the *x* direction according to the value provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `touchedBegan` function, where we checked if the right side of the screen
    was clicked, add the `addRocket` function to create the rocket every time the
    right side of the screen is tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you build and run, and tap on the right side of the screen, the rockets
    will be created, but they are not moving. To move the rockets, we have to add
    each rocket we created, into an array, and on each rocket we have to call the
    `moveSprite` function to actually move the sprites.
  prefs: []
  type: TYPE_NORMAL
- en: For updating the position of the rockets, first we have to create an array to
    hold all the rockets. This array needs to be a global variable so that we can
    easily access it. So, right under where we added `var thrust = CGPointZero` at
    the start of the class, add the following line of code right under it. We create
    an array called `rockets` to hold objects of type `MovingSprite` and we are using
    `var,` as it is a mutable array, meaning we will be adding and removing objects
    from it during the course of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new function called `updateGameObjects` right under where we
    created the function for updating the hero, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking, why are we using a `for` loop instead of a `for in` loop?
    Well this is because once the rocket goes off screen, we have to delete the object,
    and for removing objects from the array in Swift, we require the index of the
    object to be removed and the `for in` loop doesn't have that feature.
  prefs: []
  type: TYPE_NORMAL
- en: So, we create a regular `for` loop starting from `0` and go through each object
    in the `rockets` array by incrementing the index by 1 every time. We call the
    `moveSprite` function on the ith object of the array. Next, for convenience, we
    get the `spritenode` from the index so that we can perform some checks on it.
    We check whether the left edge of the rocket sprite is beyond the width of the
    screen, and, if so, then we remove the sprite from its parent node, which is the
    `GamePlayScene` as this is where we will add `addChild` in the `addRockets` function.
    Then, we remove the object at the current index in the rockets array by calling
    the `removeAtIndex` function of the array and pass in the current index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to add the objects to the array to delete it. So, in
    the `addRocket` function, add `rockets.append(rocket)` at the end of the function
    to add the rocket to the `rockets` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, don't forget to call the `updateGameObjects` function in the `update`
    function right below where we call the `updateHero` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you build and run the game, you will be able to tap on the left-hand
    side of the screen to boost up the player and then tap on the right-hand side
    of the screen to shoot the rockets.
  prefs: []
  type: TYPE_NORMAL
- en: Also, take a look at the node count on the bottom right of the screen. Each
    time a new rocket is created, the node count will increase, and since the rockets
    are removed once they are off screen, the count will also decrease every time
    a rocket is removed from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also log the `rockets.count` to check how many rockets there are in
    the rockets array by adding the following in the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding player controls](img/B04014_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the hero to be a hero, we need villains. So, we will add the enemies now.
    Similar to how we created the `addRocket` function, create a new function called
    `addEnemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, create a new array called `enemies` just after the `rocket` array in
    the global variables of the `GamePlayScene` class. This adds a new array that
    will manage enemies, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have something similar to the following in your variables declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can now update all the enemies, update their positions and remove them when
    they leave the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new image set called `enemy` and add the `enemy.png` and `enemy2.png`
    to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the rockets that spawn at the nozzle of the bazooka, the enemy will spawn
    from the right of the screen and move toward the left of the screen. They will
    also be spawning at different heights on the screen. It won't be challenging to
    the player if all the enemies spawned from the same position. So, we will create
    a random number, based on which we will decide at what height the enemy will be
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `addEnemy` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For creating a random number, we use the inbuilt function `arc4random_uniform`.
    This function takes in a value and generates a random number from `0` to one less
    than the number. So, in this case, since we have passed in `4`, it will create
    a number from `0` to `3`. Since we want a random number from `1` to `4`, we add
    `1` to it at the end. We assign this value to a variable called `factor`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we typecast this variable to `CGFloat` so that we can get a fraction value.
    Then, multiply this value by 0.20 and store it in a new variable called `fraction`.
    To finally get the random height at which the enemy needs to be created, we multiply
    the fraction with the height of the view, and assign it to a variable called `height`.
  prefs: []
  type: TYPE_NORMAL
- en: This way the enemy will be created at 20, 40, 60, or 80 percent of the height
    of the screen. We can't spawn the enemy at 0 percent or at 100 percent of the
    height since then, either the top or the bottom part of the enemy wouldn't be
    visible, because the anchor point for sprites are at the center of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now, similar to how we created the rocket, we create a new called `enemyNode`
    of type `SKSpriteNode` and assign the enemy image set to it. We have to place
    the enemy just beyond the right of the screen, so we get the width of the screen
    and add half the enemy width to it. For the height, we give the random height
    at which the enemy needs to be spawned in and add the enemy sprite to the scene.
    Finally, we will name the `enemyNode` sprite as `enemy` as we will need it later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, since we need to create an instance of the `MovingSprite` class and provide
    the `enemySprite` node and speed, we will create a new `speed` object. Since this
    time we want the enemy to be moving in the negative *x* direction, we provide
    the value of `–5` in the `x` direction for speed, keeping the `y` value as `0`
    as we don't want the enemy to be moving in the *y* direction. Then, we create
    a new `MovingSprite` object called `enemy` and provide `enemySprite` and `speed`
    to it. At the end, we append the newly created enemy object to the `enemies` array
    so we create an array called `enemies` at the top, similar to how we created rockets
    for the hero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to update through the enemy objects in the array and call `moveSprite`
    on the enemy to make it move in the negative *x* direction. We also need to make
    sure that we remove the enemy sprite from the parent class and then remove the
    enemy object from the `enemies` array. To do this, we add the following code under
    where we update the player rockets in the `updateGameObjects` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how we updated the hero rockets, we create a `for` loop and then
    call the `moveSprite` function on all the objects. Create a `sprite` node for
    convenience. Now, instead of checking if the object left from the right end of
    the screen, as the enemy is moving, the negative *x* direction, we check whether
    the right edge of the enemy is beyond the left of the screen, and if so, then
    we remove the sprite from the parent and then remove the object from the current
    index in the `enemies` array.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are already calling `updateGameObjects` in the `update` function, we
    aren't required to add it again. But we should call the `addEnemy` function after
    every couple of seconds to spawn the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For actually spawning the enemy, we can use an action to call the `addEnemy`
    function after whatever duration we want. To do this, in the `init` function,
    add the following under where we added the hero to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First we create a few actions. All actions are of the type `SKAction`. The first
    action is `runBlock` in which we provide the function that we want to call, which
    is `addEnemy`. We assign this action to `let` called `callFunc`. Next we create
    another action called `waitDuration` and assign `3.0`, which is 3 seconds, and
    assign it to `delay`. The third action is a `sequence`. A `sequence` action lets
    you perform actions one after the other. So, here we first give `callFunc` and
    then `delay`. The square brackets indicate that the sequence is an array, so we
    can create a sequence of however many actions we want to call, by adding it to
    the array and then passing it into the sequence. In this sequence, the `callEnemy`
    function will be called first and then the action will wait for 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The last action is the `repeatActionForever` action and here we pass in the
    sequence action so that the sequence is called over and over.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we run the action on the current scene and provide `addEnemyAction`,
    which will eventually call the `addEnemy` function until we tell it to stop running
    the action.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run now to see enemies popping up from the right of the screen, getting
    updated, and then once they leave the scene, getting deleted from the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding enemies](img/B04014_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding enemy bullets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK. The enemy seems to be carrying a rifle of some cartoony sort but he doesn't
    seem to be doing anything with it. Let's make him use it. We will make the enemy
    shoot bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an image set called `bullet` and assign `bullet.png` and `bullet2.png`
    to the **1x** and **2x** slots, respectively, in `Images.xcassets`. Also, create
    a new global variable called `bullets` of type `array` at the top of the `GamePlayScene`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For spawning the bullets, we will be using the `movingSprite` class. But we
    have to make some changes to it so that as soon as the enemy is created, he starts
    firing away with the rifle.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open the `movingSprite` class and add the following in the `init` function
    right after we initialize the global variables. Remember that we added a name
    to the enemy sprite when we create it. This will come into use in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we first check the name of the sprite passed in, and if it is the enemy,
    then we create an action similar to how we created the spawning of the enemies
    in the `GameplayScene` class. The difference being that, instead of creating a
    separate variable for each action here, we are just creating one single action
    called `shootAction` and calling all the actions inside it.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, we are calling a `shootBullet` function, which we will create
    in the same class, that will be called every 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: After we create `shootAction`, we call the action on the sprite so that it can
    start calling `shootAction`.
  prefs: []
  type: TYPE_NORMAL
- en: We will define the `shootBullet` function as follows. This can be added right
    under where we added the `moveSprite` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function, in turn, will call a function called `addBullets` in the `GameplayScene`.
    Since we have added the hero, rockets, and enemy in the gameplay scene, it is
    better if we also add the bullets into the same scene, as it will be easier for
    us to cycle through the objects when checking for collision.
  prefs: []
  type: TYPE_NORMAL
- en: To get an instance of the `GameplayScene`, we will create a local constant called
    `_gameplayScene` and use the `.parent` property of the `SKSpriteNode` to get the
    parent class on to which the sprite was added. Since we added the enemy in `GameplayScene`,
    it will return `GameplayScene`. We still need to typecast it so that we use the
    `as` operator and typecast it to `GamePlayScene`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we need to position the bullets properly, the same way we positioned
    the rockets for the hero, we will need to provide the position and size of the
    enemy object while creating bullets. Assuming that, we will create a function
    called `addBullets`, we will call this function on the `GamePlayScene` by providing
    the position and size of the enemy sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go to `GameplayScene` and create the `addBullets` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You should be quite accustomed to adding objects in SpriteKit now. Like the
    rockets, we create a `SKSpriteNode` called `bulletNode` and assign the bullet
    image set it. You know the drill.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new position, which will be at the left end of the enemy sprite.
    So, we take the current position of the enemy and subtract half the width of the
    enemy and half the `bulletNode` from the `x` position. For the `y` position, we
    get the `y` position of the position and subtract the full height of the bullet.
    In the next step, we assign this position to the position of `bulletNode`, and
    then we add it to the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new speed variable and assign the speed with which we want the bullet
    to move. We create a new constant called `bullet` and provide the `bulletNode`
    and speed to it.
  prefs: []
  type: TYPE_NORMAL
- en: A bullets array needs to be created to append all the bullets created. So, create
    a new array called `bullets` that takes in `MovingSprite` and adds it to the top
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: After the bullet is created, append it to the `bullets` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to update the position of the bullets and check so we can delete
    them once they have left the screen. So, similar to updating the enemy, we need
    to add the following code in the `updateGameObjects` function to update the bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, here we go through the bullets in the array, call the `moveSprite` function,
    and if the sprite has gone beyond the left of the screen, we remove it from the
    parent and remove the object in the current index.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding enemy bullets](img/B04014_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have all the elements needed to go to the next stage of development,
    that is, to check for collisions between the hero's rockets and enemies, and between
    the enemy's bullets and the hero. Based on collision, we will be doing the scoring
    and checking for the game over condition.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collision detection in 2D games is done using the `intersectsNode` function
    of the sprite class itself. We can check whether the current sprite is overlapping
    the other sprite. In the `intersectsNode` function of the current node, we pass
    in a node that we want to check for collision with the current node. If there
    is an intersection, the function will return `true`, if not, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: For checking collision, we will first check the collision between the enemy's
    bullets and the hero. If there is collision, then the game is over. Then we will
    check collision between the hero's rockets and the enemies. If we detect a collision,
    then we have to update the score.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the enemy goes beyond the left of the screen, the game is over, so
    we will call the `GameOver` function in this case also.
  prefs: []
  type: TYPE_NORMAL
- en: 'For checking collision, create a new function called `checkCollision` in the
    `GameplayScene` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we wont be needing to know the index numbers, we will just use the `for in`
    loop to check collision.
  prefs: []
  type: TYPE_NORMAL
- en: Here we go through all the bullet objects in the `bullets` array. First, we
    assign the sprite of the bullet object to a local sprite variable. Then, we will
    call the `intersectsNode` function on the sprite to check whether it intersects
    the hero sprite. If it does intersect, then the `GameOver` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `intersectsNode` function just takes the sprite of the node and checks if
    the box surrounding this sprite intersects with the bounding box of the sprite
    provided for it. If there is some overlapping, it will return `true` if the collision
    has occurred, or `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `checkCollision` function in the `update` function right after we
    update the hero and the game objects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create the `GameOver` function. Once the game is over, we want to
    stop updating the hero and game objects, and stop checking for collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, create a global bool at the top of the class called `gameOver` and set
    it to `false`. It should be a `var` and not `let` as we will change it in the
    `GameOver` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `GameOver` function to the `GamePlayScene` class right after the `update`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once the game is over, we set the `gameOver` bool to `false`. Next we call `removeAllActions`
    on the current class so that enemies will stop spawning, and then we also call
    the function on all the enemies that are currently present on the screen, so that
    the bullets stop spawning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to call the `GameOver` function when any of the enemies go beyond
    the left of the screen, so to update the position of the enemy, call the `GameOver`
    function in the `if` condition in the loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In order to stop updating the hero and game objects and stop checking for collision,
    once the game is over, enclose the three functions in an `if` condition, as shown
    in the following code, where we check whether the `gameOver` Boolean value is
    `false` or not. If it is `false`, then the functions will get called, else it
    will be bypassed and won't call the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, if the game is over, the player shouldn''t be able to fire rockets or
    make the hero thrust up. So, basically, we have to disable the player controls
    once the game is over. So, in the `touchesBegan` function, enclose where we check
    which side the screen is tapped in the `if` condition, checking if the game over
    condition is met or not, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Keeping score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are still not done with the `checkCollision` function. We still need to
    keep track of the score. For this, we have to check the collision between the
    hero''s rockets and the enemies. So, in the `checkCollision` function, add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `for` loop as we will need the index of the objects in the
    loops here. We loop through all the rockets in the scene and check the collision
    with all the enemies in the scene by looping through the `enemies` array. If any
    of the rockets collides with the enemy, then we remove both the rocket and the
    enemy sprite node from the scene, and also remove the rocket and enemy from the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create a new global variable `var` called `score` of type `int` and
    initialize it equal to zero at the top of the class, as shown in the following.
    We increase the score by 1 after checking the collision, to keep track of the
    score.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can log the score in the console to check whether the score variable is actually
    increasing. But how will the player know how much he/she has scored?
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For showing the score, we will use a `SKLabelNode` and assign the value of
    the score every time the score is changed. Since we will need to access this variable
    in the `checkCollision` function, it has to be a global variable. So, create a
    variable called `scoreLabel` of type `SKLabelNode` along with the other global
    variables at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init` function, right after we added the hero, we can add the following
    lines to initialize the `scoreLabel` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We give a font name to use as the font, which is `Chalkdust`. Then we assign
    the actual text to be displayed. We will later change the value of this text,
    depending on what the score variable is later in the `checkCollision` function.
    We set the size to `45` and place the `scoreLabel` at 90 percent of the height
    of the display, so that it is at the top of the screen, and place it at the center
    of the width of the screen. Finally, we add the `scoreLabel` to the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, the text that we assigned will be displayed, but the
    score won't update. For the score to update, we have to change the text and assign
    the actual value of the score variable we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, right after we increment the score in the `checkCollision` function, add
    the following to increment the score text of the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to how we log variables to the console, we assign the score value to
    the string and then pass it to the text property of `scoreLabel`. Now, if we build
    and run the game, it should display the current score, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the score](img/B04014_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the game over screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the game is over, we have to display **GameOver!** to the player and add
    a button so that the player can go back to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `GameOver` function, add a label called `myLabel` after we called the
    function to stop all the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We add the **GameOver!** text of font size `65` so that it is easily visible
    to the player and place it slightly above the center of the screen to make space
    for the main menu button that we will be adding next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the main menu button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, in the `GameOver` function, a SKSpriteNode called `menuBtn` is created,
    and we pass the `menuBtn` image set to it. For creating the image set in `images.xcassets`,
    `homeBtn.png`, and `homeBtn2.png` are included in the `Resources` folder. We place
    it at the center of the screen. We also give it a name so that we can refer to
    it later in the `touchesBegan` function so that if it is pressed, we can call
    some function on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `touchesBegan` function, after we checked if the game is over
    or not, add an `else` block and add the following code to replace the current
    scene with the `MainMenuScene`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding the main menu button](img/B04014_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similar to how we made the play button interactive, if the game is over, we
    check whether the player touched the screen. If the location that he tapped contains
    the node name `menuBtn`, we create a local object called `scene` and assign the
    `MainMenuScene`, and then we replace the current scene with the `MainMenuScene`.
  prefs: []
  type: TYPE_NORMAL
- en: As far as gameplay goes, we are done with it. Now let's add a feature that allows
    us to save the high score, so that we can challenge the player to beat it, to
    increase replayability of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the high score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For saving the high scores, we can use the `NSUserDefaults` property. Here we
    can use a key and assign a particular value to it which the device will store
    in its memory, so that we can retrieve later. The best thing about this is, we
    can retrieve and rewrite the value stored in it currently, to some other file.
    So, here we will store the high score in `GamePlayScene` and later the value stored
    in the key, in the `MainMenuScene`.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is a dictionary, you can store integer, floats, and string. In this
    case, since the high score will always be an integer, we will get and store an
    integer for the key. The key here is a string and the value that is stored is
    an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For retrieving the high score value, add the following code after we added
    `menuBtn` in the `GameOver` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Since no value is stored currently in the key, it will return zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For congratulating the players on getting a new high score, create a new `SKLabelNode`,
    right after we added the `currentHighScore`, and call it `highScoreLabel`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We create the label with font `Chalkduster`. We set the initial text value to
    a blank so that we can change it later depending on whether the player beats the
    high score or not. We set the text height to `45`, and place it below the button
    and then add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we check the value stored in `currentHighScore` against the current `score`
    and see if the `currentHighScore` value is greater than the current `score`, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If the score is higher than the current high score, then we call the `setInteger`
    function of `standardUserDefaults` and assign the new high score that is the current
    score and the key to store it against. When assigning keys, make sure it is unique.
  prefs: []
  type: TYPE_NORMAL
- en: To save the data to the device, we have to call the `synchronize` function.
    If we fail to call this, once you close the application, the data will be lost,
    so make sure to call this function each time you store the value against a key.
  prefs: []
  type: TYPE_NORMAL
- en: We then congratulate the player on getting a new high score by changing the
    text property to show the current score, which is the new high score.
  prefs: []
  type: TYPE_NORMAL
- en: If the player didn't beat his current high score, then in the `else` statement
    we change the text property of the `highScoreLabel` to show that he can do better
    than the current score so that it will motivate him to play the game again and
    beat his previous high score.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, I scored **7**, which is okay I think. With a little
    bit of practice, I think I will be able to do better. It is also just to demonstrate
    that the code works fine, and if the current score is greater than the high score,
    then it shows the new high score.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the high score](img/B04014_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the current score is less than the current high score, then you will see
    the following screen. Here I got a **4**, which is less than the current high
    score saved in memory that is **7**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the high score](img/B04014_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resetting the high score count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if the player wants to reset their high score to zero? We can do this by
    adding a button in the main menu and resetting the value of the key to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainMenuScene.swift` file, and in the `didMoveToView` function where
    we created the play button, create one more SKSpriteNode called `resetBtn`. Place
    this button at three-fourth of the width of the screen and name the sprite `resetBtn`.
    We will use the name to check whether the player clicked the play button or the
    reset button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assets for the reset button are in the `Resources` folder, so create a
    new image set called `resetBtn` and drag-and-drop `resetBtn.png` and `resetBtn2.png`
    to the **1x** and **2x** placeholders, respectively, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `touchesBegan` function where we checked for `playBtn`, add an
    `else if` block and check whether `resetBtn` is pressed, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If the reset button is pressed, we set the value of the key by which we have
    been getting the value, to zero and call the synchronize function again so that
    this value is stored in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as one last thing, let''s show the player the current high score when
    the application opens, so create a new global variable called `currentHighScoreLabel`
    of type `SKLabel` at the top of the `MainMenuScene` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the following in the `didMoveToView` function right after where
    we added the reset button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We first get the current high score stored, and then assign the value to the
    text. The rest of the code is similar to the code except that the `y` value for
    the position is multiplied by 0.2 instead of 0.3, as the play button is pretty
    big.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change the text once the high score is reset, so in the `else
    if` block where we check whether the reset button is pressed, under the place
    where we added code to reset the value for the key, add the highlighted lines
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the stored value again just to check whether the value that we
    stored earlier is actually reflected. Then we set text of `currentHighScoreLabel`
    to this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have just set the text as `Current High Score: 0` and it would have
    still worked without a problem, but this way, we would not have been sure whether
    the value for the key was actually set to zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run the code, you can see the current high score displayed at the
    main menu screen when the game starts. You can also verify that the value of the
    high score is actually set to zero once you reset it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the following screenshot, the main menu scene, once again, is showing
    my current high score, even though this code was added after achieving my new
    high score:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resetting the high score count](img/B04014_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next screenshot, we can be sure that the value of the current high score
    changes once the reset button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resetting the high score count](img/B04014_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So this is all for this chapter. Save this file and keep it, as we will need
    it again in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a pretty long chapter and we actually made a complete working game
    in it. We created the main menu and gameplay scenes using SKScenes and added interactive
    buttons to move between the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to import assets into the project, add them onto the screen,
    and make them move around and interact with each other. You also saw how to remove
    objects from the screen and add and update the score.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you saw how to store and retrieve the current high score on the device.
    However, we are not done with the game. We still need to add animations, particle
    effects, and background music and sounds effects to the game to make it come alive.
    Hope you guys are looking forward to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, you can practice and try to beat my high score.
  prefs: []
  type: TYPE_NORMAL
