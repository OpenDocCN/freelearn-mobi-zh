- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Navigating within Your App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序内导航
- en: The apps we make need to move from one screen to the other, showing different
    content on these screens. So far, we have been making apps with only one screen.
    In this chapter, we will learn how to move from one screen to the other. We will
    learn how to use the **Jetpack Compose Navigation** library to navigate to different
    Jetpack Compose screens within our app. We will learn the tips and best practices
    for using this library. Also, we will cover how to pass arguments as we navigate
    to screens. Lastly, we will build on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055),
    by handling navigation on large screens and foldables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作的应用程序需要从一个屏幕移动到另一个屏幕，在这些屏幕上显示不同的内容。到目前为止，我们只制作了一个屏幕的应用程序。在本章中，我们将学习如何从一个屏幕移动到另一个屏幕。我们将学习如何使用
    **Jetpack Compose 导航** 库在我们的应用程序中导航到不同的 Jetpack Compose 屏幕。我们将学习使用此库的技巧和最佳实践。此外，我们还将介绍如何在大型屏幕和可折叠设备上处理导航。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Jetpack Navigation overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetpack 导航概述
- en: Navigating to Compose destinations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 Compose 目的地
- en: Passing arguments to destinations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向目的地传递参数
- en: Navigation in foldables and large screens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可折叠设备和大型屏幕上的导航
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本（[https://developer.android.com/studio](https://developer.android.com/studio)）。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterseven)找到本章的代码。
- en: Jetpack Navigation overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jetpack 导航概述
- en: The Jetpack Navigation library provides an API for handling **complex navigation**
    with ease while also following the principles of Android Jetpack. The library
    is available for both the old view system, which uses XML ([https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation)),
    and Jetpack Compose ([https://developer.android.com/jetpack/compose/navigation](https://developer.android.com/jetpack/compose/navigation)).
    We will be learning about the latter in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 导航库提供了一个易于处理 **复杂导航** 的 API，同时遵循 Android Jetpack 的原则。该库适用于旧视图系统，该系统使用
    XML（[https://developer.android.com/guide/navigation](https://developer.android.com/guide/navigation)），以及
    Jetpack Compose（[https://developer.android.com/jetpack/compose/navigation](https://developer.android.com/jetpack/compose/navigation)）。在本章中，我们将学习后者。
- en: Still building on the Pets app we used in the previous chapter, we are going
    to navigate to a details screen that has a back button to the previous screen.
    We will also be passing data to the details screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在上一章使用的宠物应用程序的基础上，导航到一个具有返回到上一屏幕按钮的详细信息屏幕。我们还将向详细信息屏幕传递数据。
- en: 'To start with, we need to add the Jetpack Navigation Compose dependency to
    our project. Let’s add the following library inside the `versions` section in
    our `libs.versions.toml` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 Jetpack 导航 Compose 依赖项添加到我们的项目中。让我们在 `libs.versions.toml` 文件的 `versions`
    部分中添加以下库：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to add the dependency to our app module’s `build.gradle.kts`
    file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将依赖项添加到我们的应用程序模块的 `build.gradle.kts` 文件中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Do a Gradle sync to add the library to our project. The next step is to create
    `NavController` and `NavHost`. `NavController` is a class that manages app navigation
    within `NavHost`. `NavHost` is a container that hosts composables and handles
    navigation between them. Let’s create a new package called `navigation` and create
    a new sealed class called `Screens.kt`. Inside the file, let us add the following
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步以将库添加到我们的项目中。下一步是创建 `NavController` 和 `NavHost`。`NavController`
    是一个管理 `NavHost` 内应用程序导航的类。`NavHost` 是一个容器，它托管可组合元素并处理它们之间的导航。让我们创建一个名为 `navigation`
    的新包，并创建一个名为 `Screens.kt` 的新密封类。在文件内部，让我们添加以下代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a sealed class that has two objects. A sealed class is used to represent
    restricted class hierarchies wherein the object or value can only have a value
    among one of the types defined in the sealed class. The first object is `PetsScreen`,
    which will be the first screen we will see when we launch the app. The second
    object is `PetDetailsScreen`, which will be the screen we will navigate to when
    we click on a pet item in `PetsScreen`. Every time we need to add a new destination
    screen, we will add a new object to the sealed class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有两个对象的密封类。密封类用于表示受限的类层次结构，其中对象或值只能具有密封类中定义的类型之一。第一个对象是`PetsScreen`，它将是我们在启动应用时看到的第一个屏幕。第二个对象是`PetDetailsScreen`，它将是我们在点击`PetsScreen`中的宠物项目时导航到的屏幕。每次我们需要添加一个新的目标屏幕时，我们都会在密封类中添加一个新的对象。
- en: 'Next, let us create a new file inside the `navigation` package called `AppNavigation.kt`.
    Inside the file, let us add the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`navigation`包内部创建一个名为`AppNavigation.kt`的新文件。在文件内部，让我们添加以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s explain the preceding code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下前面的代码：
- en: We create **NavController** using the **rememberNavController()** function.
    This function is used to create **NavController** that will be remembered across
    recompositions. This is important because we need to be able to navigate to different
    screens in our app.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`rememberNavController()`函数创建**NavController**。这个函数用于创建将在重组之间被记住的**NavController**。这很重要，因为我们需要能够在我们的应用中导航到不同的屏幕。
- en: We create a **NavHost** composable that takes in **navController** and **startDestination**.
    **startDestination** is the first screen we want to see when we launch the app.
    In our case, it is **PetsScreen**.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个**NavHost**可组合组件，它接受**navController**和**startDestination**。**startDestination**是我们启动应用时想要看到的第一个屏幕。在我们的例子中，它是**PetsScreen**。
- en: We add the **PetsScreen** composable. This composable has an error because we
    have not created it yet. We will do that shortly.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了**PetsScreen**可组合组件。这个可组合组件有一个错误，因为我们还没有创建它。我们很快就会做到这一点。
- en: '![Figure 7.1 – PetsScreen error](img/B19779_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – PetsScreen错误](img/B19779_07_01.jpg)'
- en: Figure 7.1 – PetsScreen error
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – PetsScreen错误
- en: 'As seen in the preceding screenshot, the `PetsScreen` composable is highlighted
    in red because we have not created the composable yet. We will refactor our code
    a bit. Let us create a new file called `PetsScreen.kt`. Inside the file, let’s
    add the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`PetsScreen`可组合组件被红色突出显示，因为我们还没有创建这个可组合组件。我们将对我们的代码进行一些重构。让我们创建一个名为`PetsScreen.kt`的新文件。在文件内部，让我们添加以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PetsScreen` composable displays a list of pets. We have added a `Scaffold`
    composable as the root element. Inside the `Scaffold` composable, we have added
    a `TopAppBar` composable. We have also added a `PetList` composable as the content
    of the `Scaffold` composable. We have added a new `onPetClicked` callback to the
    `PetList` composable. We will be using this callback to navigate to `PetDetailsScreen`
    when we click on a pet item in the list.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetsScreen`可组合组件显示宠物列表。我们添加了一个`Scaffold`可组合组件作为根元素。在`Scaffold`可组合组件内部，我们添加了一个`TopAppBar`可组合组件。我们还添加了一个`PetList`可组合组件作为`Scaffold`可组合组件的内容。我们还在`PetList`可组合组件中添加了一个新的`onPetClicked`回调。我们将使用这个回调在点击列表中的宠物项目时导航到`PetDetailsScreen`。'
- en: 'With this, our navigation graph is ready. We can now add the `AppNavigation`
    composable to our `MainActivity.kt` file. Let’s replace all the code inside the
    `ChapterSevenTheme` block with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的导航图就准备好了。我们现在可以将`AppNavigation`可组合组件添加到我们的`MainActivity.kt`文件中。让我们用以下代码替换`ChapterSevenTheme`块内的所有代码：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Build and run the app. The app still displays a list of cute pets as before,
    but now we are using the Jetpack Navigation library to handle our navigation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用。应用仍然显示与之前一样的可爱宠物列表，但现在我们正在使用Jetpack Navigation库来处理我们的导航。
- en: '![Figure 7.2 – Pets](img/B19779_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 宠物](img/B19779_07_02.jpg)'
- en: Figure 7.2 – Pets
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 宠物
- en: In the next section, let us learn how to navigate to a details screen when we
    click on a pet item in the list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们学习如何在我们点击列表中的宠物项目时导航到详细信息屏幕。
- en: Navigating to Compose destinations
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到Compose目标
- en: 'In this section, we will learn how to navigate to a details screen when we
    click on a pet item in the list. First, we need to create a new composable for
    `PetDetailsScreen`. Let us create a new file called `PetDetailsScreen.kt` and
    create the `PetDetailsScreenContent` composable as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在我们点击列表中的宠物项目时导航到详细信息屏幕。首先，我们需要为`PetDetailsScreen`创建一个新的可组合组件。让我们创建一个名为`PetDetailsScreen.kt`的新文件，并按照以下方式创建`PetDetailsScreenContent`可组合组件：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we created a composable that has `Column` as the root element. Inside
    the `Column` element, we added an `AsyncImage` composable that displays a cat
    image. We also added a `FlowRow` composable to flow items to the next line when
    space runs out, which cannot be achieved with rows. `FlowRow` displays two `SuggestionChip`
    composables. We will use this composable to display the details of a pet. Notice
    we are using hardcoded cat IDs and tags for now. We will pass this data from the
    `PetList` composable in the next section. Next, let us create the `PetDetailsScreen`
    composable as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个以 `Column` 作为根元素的组合器。在 `Column` 元素内部，我们添加了一个 `AsyncImage` 组合器来显示猫的图片。我们还添加了一个
    `FlowRow` 组合器，当空间不足时将项目流动到下一行，这是无法通过行实现的。`FlowRow` 显示了两个 `SuggestionChip` 组合器。我们将使用此组合器来显示宠物的详细信息。注意，我们现在正在使用硬编码的猫
    ID 和标签。我们将在下一节中从 `PetList` 组合器传递这些数据。接下来，让我们创建 `PetDetailsScreen` 组合器，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `PetDetailsScreen` composable displays the details of a pet. We have added
    a `Scaffold` composable as the root element. Inside the `Scaffold` composable,
    we have added a `TopAppBar` composable. We have also used the `PetDetailsScreenContent`
    composable we created earlier as the content of the `Scaffold` composable. We
    have added a new `onBackPressed` callback to the `PetDetailsScreen` composable.
    We will be using this callback to navigate back to the previous screen when we
    click on the back button in `TopAppBar`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetDetailsScreen` 组合器显示宠物的详细信息。我们添加了一个 `Scaffold` 组合器作为根元素。在 `Scaffold` 组合器内部，我们添加了一个
    `TopAppBar` 组合器。我们还使用了之前创建的 `PetDetailsScreenContent` 组合器作为 `Scaffold` 组合器的内容。我们还在
    `PetDetailsScreen` 组合器中添加了一个新的 `onBackPressed` 回调。我们将使用此回调在点击 `TopAppBar` 中的返回按钮时导航回上一屏幕。'
- en: 'Our next step is to add a composable for `PetDetailsScreen` to our `AppNavigation.kt`
    file. Let us add the following code to our `NavHost` below the composable for
    `PetsScreen`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是将 `PetDetailsScreen` 组合器添加到我们的 `AppNavigation.kt` 文件中。让我们在 `PetsScreen`
    组合器下方添加以下代码到我们的 `NavHost` 中：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have added a composable for `PetDetailsScreen`. We passed in the route
    for the screen and the `PetDetailsScreen` composable as the content. `PetDetailsScreen`
    has the `onBackPressed` argument. The argument handles the situation where a user
    taps the back arrow icon, which is normally at the top left. We use `navController.popBackStack()`
    inside the `onBackPressed` argument. This method attempts to pop the current destination
    off the back stack and navigates to the previous destination.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个 `PetDetailsScreen` 组合器。我们传递了屏幕的路由和 `PetDetailsScreen` 组合器作为内容。`PetDetailsScreen`
    有 `onBackPressed` 参数。该参数处理用户点击通常位于左上角的返回箭头图标的情况。我们在 `onBackPressed` 参数中使用 `navController.popBackStack()`。此方法尝试从返回堆栈中弹出当前目的地并导航到上一个目的地。
- en: 'Now we need to do the actual navigation to `PetDetailsScreen` when we click
    on a pet item in the list. Let us head over to the `PetListItem` composable. We
    will add a new `onPetClicked` callback to the `PetListItem` composable. The modified
    composable should look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在列表中点击宠物项时，我们需要实际导航到 `PetDetailsScreen`。让我们转到 `PetListItem` 组合器。我们将在 `PetListItem`
    组合器中添加一个新的 `onPetClicked` 回调。修改后的组合器应如下所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we have added a new `onPetClicked` callback to the composable.
    We have added the `clickable` modifier to `Column` and called the `onPetClicked`
    callback inside the modifier. We pass in the `cat` object to the callback. Next,
    we need to add the `onPetClicked` callback to the `PetList` composable, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在组合器中添加了一个新的 `onPetClicked` 回调。我们向 `Column` 添加了 `clickable` 修饰符，并在修饰符内部调用了
    `onPetClicked` 回调。我们将 `cat` 对象传递给回调。接下来，我们需要将 `onPetClicked` 回调添加到 `PetList` 组合器中，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to pass this callback where we use our `PetListItem` composable.
    The modified `PetListItem` composable at the call site inside the items block
    should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此回调传递到我们使用 `PetListItem` 组合器的地方。在 items 块内部调用点的修改后的 `PetListItem` 组合器应如下所示：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, we need to modify the `AppNavigation` composable to pass the `onPetClicked`
    callback to the `PetsScreen` composable. The modified `AppNavigation` composable
    should look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改 `AppNavigation` 组合器，以便将 `onPetClicked` 回调传递给 `PetsScreen` 组合器。修改后的
    `AppNavigation` 组合器应如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we pass the `onPetClicked` callback to the `PetsScreen` composable. Inside
    the callback, we call the `navigate()` function on `navController` and pass in
    the route for `PetDetailsScreen`. This will navigate to `PetDetailsScreen` when
    we click on a pet item in the list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `onPetClicked` 回调传递给 `PetsScreen` 可组合组件。在回调内部，我们在 `navController` 上调用
    `navigate()` 函数，并传入 `PetDetailsScreen` 的路由。当我们点击列表中的宠物项时，这将导航到 `PetDetailsScreen`。
- en: Build and run the app. Click on a pet item in the list. You will see that the
    app navigates to `PetDetailsScreen`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。点击列表中的宠物项。您将看到应用程序导航到 `PetDetailsScreen`。
- en: '![Figure 7.3 – Pet Details screen](img/B19779_07_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 宠物详情屏幕](img/B19779_07_03.jpg)'
- en: Figure 7.3 – Pet Details screen
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 宠物详情屏幕
- en: We can see a cute cat image and some tags. Additionally, if we press the back
    button in `TopAppBar`, we will be able to navigate back to `PetsScreen`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一只可爱的猫的图片和一些标签。此外，如果我们按下 `TopAppBar` 中的返回按钮，我们将能够导航回 `PetsScreen`。
- en: So far, we have been able to navigate from `PetsScreen` to `PetDetailsScreen`.
    However, we are not passing any data to `PetDetailsScreen`. In the next section,
    we will learn how to pass data to `PetDetailsScreen`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够从 `PetsScreen` 导航到 `PetDetailsScreen`。然而，我们没有向 `PetDetailsScreen`
    传递任何数据。在下一节中，我们将学习如何向 `PetDetailsScreen` 传递数据。
- en: Passing arguments to destinations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向目标传递参数
- en: 'In our `PetDetailsScreen`, we need to remove the hardcoded cat IDs and tags
    and pass them from the `PetList` composable. Follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PetDetailsScreen` 中，我们需要移除硬编码的猫 ID 和标签，并从 `PetList` 可组合组件中传递它们。请按照以下步骤操作：
- en: 'Let us head over to the **PetDetailsScreenContent** composable inside the **PetDetailsScreen.kt**
    file and modify it as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 **PetDetailsScreenContent** 可组合组件，位于 `PetDetailsScreen.kt` 文件中，并按以下方式修改它：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have added a new `cat` parameter to the composable. We have used the `cat`
    object to display the cat image and tags.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为可组合组件添加了一个新的 `cat` 参数。我们使用 `cat` 对象来显示猫的图片和标签。
- en: 'Next, let us head over to the **PetDetailsScreen** composable and modify it
    as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们转到 `PetDetailsScreen` 可组合组件，并按以下方式修改它：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have added a new `cat` parameter to the composable. We have passed
    the `cat` object to the `PetDetailsScreenContent` composable.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们向可组合组件添加了一个新的 `cat` 参数。我们将 `cat` 对象传递给 `PetDetailsScreenContent` 可组合组件。
- en: 'Next, let us head over to the **AppNavigation** composable and add the logic
    for passing the **cat** object to **PetDetailsScreen**. We need to first modify
    the composable for **PetDetailsScreen**, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们转到 **AppNavigation** 可组合组件，并添加将 **cat** 对象传递给 `PetDetailsScreen` 的逻辑。我们需要首先修改
    `PetDetailsScreen` 的可组合组件，如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s explain the changes:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释一下这些更改：
- en: On the route, we have added a new parameter called **cat**. This is the parameter
    we will use to pass the **cat** object to **PetDetailsScreen**.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由上，我们添加了一个新的参数，称为 **cat**。这是我们用来将 **cat** 对象传递给 `PetDetailsScreen` 的参数。
- en: We have added a new **arguments** parameter. This parameter is used to pass
    arguments to the destination screen. We have added **navArgument** for the **cat**
    parameter. We have set the type to be **String**. This is because we will be passing
    a string representation of the **cat** object.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个新的 **arguments** 参数。该参数用于将参数传递到目标屏幕。我们为 `cat` 参数添加了 **navArgument**。我们将类型设置为
    **String**。这是因为我们将传递 **cat** 对象的字符串表示形式。
- en: We pass the **cat** object to the **PetDetailsScreen** composable. We have used
    **Json.decodeFromString()** from the Kotlinx Serialization library that we learned
    about in [*Chapter 6*](B19779_06.xhtml#_idTextAnchor084) to convert the string
    value of the **cat** object into a **Cat** object. We have used the **arguments**
    property of **NavBackStackEntry** to get the string value of the **cat** object.
    We have used the Elvis operator to return an empty string if the **arguments**
    property is null.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 **cat** 对象传递给 `PetDetailsScreen` 可组合组件。我们使用了 Kotlinx Serialization 库中的 **Json.decodeFromString()**，这是我们之前在
    [*第 6 章*](B19779_06.xhtml#_idTextAnchor084) 中了解到的，将 **cat** 对象的字符串值转换为 **Cat**
    对象。我们使用了 **NavBackStackEntry** 的 **arguments** 属性来获取 **cat** 对象的字符串值。如果 **arguments**
    属性为空，我们使用了 Elvis 操作符返回一个空字符串。
- en: 'Lastly, we need to modify the **onPetClicked** callback of **PetsScreen** in
    the **AppNavigation** composable, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改 **AppNavigation** 可组合组件中的 **onPetClicked** 回调，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have modified the `navigate()` function to pass the `Cat` object as a string.
    We also used `Json.encodeToString()` from the Kotlinx Serialization library to
    convert the `Cat` object into a string. This will be passed as an argument to
    `PetDetailsScreen` when we click on a pet item in the list.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已修改了`navigate()`函数，将其作为字符串传递`Cat`对象。我们还使用了 Kotlinx Serialization 库中的`Json.encodeToString()`，将`Cat`对象转换为字符串。这将作为参数传递给`PetDetailsScreen`，当我们点击列表中的宠物项时。
- en: 'Build and run the app. Click on any cute cat picture from the list and now
    the details screen will display the cat image and tag of the cute cat that we
    selected:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。点击列表中的任何可爱猫的图片，现在详情屏幕将显示我们选择的可爱猫的图片和标签：
- en: '![Figure 7.4 – Pet Details](img/B19779_07_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 宠物详情](img/B19779_07_04.jpg)'
- en: Figure 7.4 – Pet Details
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 宠物详情
- en: We have now been able to pass data to `PetDetailsScreen`. We have learned how
    to navigate to a compose destination and pass data to the details screen. In the
    next section, we will learn how to handle navigation in foldables and large screens.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经能够将数据传递给`PetDetailsScreen`。我们学习了如何导航到组合目标并传递数据到详情屏幕。在下一节中，我们将学习如何处理可折叠设备和大型屏幕上的导航。
- en: Navigation in foldables and large screens
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可折叠设备和大型屏幕上的导航
- en: 'In the *Designing UIs for large screens and foldables* section of [*Chapter
    4*](B19779_04.xhtml#_idTextAnchor055), we learned about the `WindowSize` class
    and how we can make our apps responsive in foldable devices and large screens.
    In this section, we are going to make our Pets app responsive in foldable devices
    and large screens. We are going to make several changes, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B19779_04.xhtml#_idTextAnchor055)的“*为大型屏幕和可折叠设备设计 UI*”部分，我们学习了`WindowSize`类以及如何在可折叠设备和大型屏幕上使我们的应用具有响应性。在本节中，我们将使我们的宠物应用在可折叠设备和大型屏幕上具有响应性。我们将进行以下几项更改：
- en: Add a bottom bar to **PetsScreen**, which will have several options.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**PetsScreen**中添加一个底部栏，它将包含几个选项。
- en: Add **NavigationRail** and **NavigationDrawer**, which will be used depending
    on the screen size.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据屏幕大小添加**NavigationRail**和**NavigationDrawer**。
- en: Observe the device’s foldable state and change the layout of the app depending
    on the foldable state.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察设备的可折叠状态，并根据可折叠状态更改应用的布局。
- en: Depending on the screen size, we will also change the content type. On large
    screens, we will display the list of cats and the details of the selected cat
    side by side. On small screens, we will display the list of cats and the details
    of the selected cat on different screens.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据屏幕大小，我们还将更改内容类型。在大型屏幕上，我们将并排显示猫的列表和所选猫的详情。在小屏幕上，我们将显示猫的列表和所选猫的详情在不同的屏幕上。
- en: 'Quite a lot of changes are required. The good thing is that I have already
    made the changes and you can find the final version in the `chapterseven` folder
    in the project’s repository. Let us go through the changes one by one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的更改相当多。好消息是，我已经完成了这些更改，你可以在项目的仓库中的`chapterseven`文件夹中找到最终版本。让我们逐一查看这些更改：
- en: 'We will start by creating a **sealed interface** named **NavigationType** that
    represents the different types of navigation we will be using in our app. Let
    us create a new file inside the **navigation** package called **NavigationType.kt**
    and add the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为**NavigationType**的**密封接口**，它代表我们将在应用中使用的不同类型的导航。让我们在**navigation**包内创建一个名为**NavigationType.kt**的新文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are using a sealed interface instead of a sealed class here. This is because
    we do not need to hold any state in our `NavigationType`. We also do not need
    to pass properties to any of the `NavigationTypes`. We have three options: `BottomNavigation`,
    `NavigationDrawer`, and `NavigationRail`. We will be using these options to change
    the navigation type depending on the screen size.'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用密封接口而不是密封类，这是因为我们不需要在`NavigationType`中保留任何状态。我们也不需要将任何属性传递给`NavigationTypes`中的任何一个。我们有三个选项：`BottomNavigation`、`NavigationDrawer`和`NavigationRail`。我们将使用这些选项根据屏幕大小更改导航类型。
- en: 'Next, let us create yet another sealed interface called **ContentType**. This
    interface will be used to change the content display type depending on the screen
    size. Let us create a new file called **ContentType.kt** still inside the **navigation**
    package and add the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个名为**ContentType**的密封接口。此接口将用于根据屏幕大小更改内容显示类型。让我们在**navigation**包内创建一个名为**ContentType.kt**的新文件，并添加以下代码：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This represents the two modes in which we can display our content depending
    on the screen size. We have the `List` mode, which displays the list of cats only.
    We also have the `ListAndDetail` mode, which displays the list of cats and the
    details of the selected cat side by side.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示我们可以根据屏幕大小显示内容的两种模式。我们有 `List` 模式，只显示猫的列表。我们还有 `ListAndDetail` 模式，显示猫的列表和所选猫的详细信息并排显示。
- en: 'Next, in our **Screens.kt** file, we have to add a new destination screen called
    **FavoritesScreen**. The final code for the file should look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的 **Screens.kt** 文件中，我们必须添加一个名为 **FavoritesScreen** 的新目的地屏幕。文件的最终代码应如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have three destinations for our app.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们为我们的应用有了三个目的地。
- en: 'Next, let us add the **WindowSize** dependencies to the libraries section in
    the **libs.versions.toml** file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将 **WindowSize** 依赖项添加到 **libs.versions.toml** 文件中的库部分：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need to add the dependencies to our app module’s **build.gradle.kts**
    file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将依赖项添加到我们的应用模块的 **build.gradle.kts** 文件中：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Do a Gradle sync to be able to add the dependencies to our project.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步以便能够将依赖项添加到我们的项目中。
- en: 'Next, we need to create the composables for **NavigationRail**, **NavigationDrawer**,
    and **BottomNavigation**. Let us create a new file called **PetsNavigationRail.kt**
    inside the **view** package and add the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 **NavigationRail**、**NavigationDrawer** 和 **BottomNavigation** 的可组合组件。在
    **view** 包内创建一个名为 **PetsNavigationRail.kt** 的新文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we created the `PetsNavigationRail()` composable, which
    has three parameters: `onFavoriteClicked`, `onHomeClicked`, and `onDrawerClicked`.
    The first two are callbacks that will be used to navigate to the different screens.
    We use the `onDrawerClicked` callback to close or open the drawer when the user
    interacts with it. At the top, we have the `items` variable, which holds a list
    of all our screens, and the `selectedItem` variable, which holds the currently
    selected screen. We use the `NavigationRail` composable from the Material 3 library
    to display the navigation rail. To add items to `NavigationRail`, we use the `NavigationRailItem`
    composable. We pass in the selected state of the item, the `onClick` callback,
    and the icon to display.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `PetsNavigationRail()` 可组合组件，它有三个参数：`onFavoriteClicked`、`onHomeClicked`
    和 `onDrawerClicked`。前两个是回调函数，将用于导航到不同的屏幕。我们使用 `onDrawerClicked` 回调函数在用户与之交互时关闭或打开抽屉。在顶部，我们有
    `items` 变量，它包含所有我们的屏幕列表，以及 `selectedItem` 变量，它包含当前选中的屏幕。我们使用 Material 3 库中的 `NavigationRail`
    可组合组件来显示导航栏。要向 `NavigationRail` 添加项目，我们使用 `NavigationRailItem` 可组合组件。我们传递项目的选中状态、`onClick`
    回调函数和要显示的图标。
- en: 'Next, let us create the **PetsBottomNavigationBar** composable. Let us create
    a new file called **PetsBottomNavigationBar.kt** inside the **view** package and
    add the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 **PetsBottomNavigationBar** 的可组合组件。在 **view** 包内创建一个名为 **PetsBottomNavigationBar.kt**
    的新文件，并添加以下代码：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `PetsBottomNavigationBar` composable is similar to the `PetsNavigationRail`
    composable. The only difference is that we are using the `NavigationBar` composable
    instead of the `NavigationRail` composable. We have the home and favorite items.
    We use the `NavigationBarItem` composable to add items to `NavigationBar`. We
    pass in the selected state of the item, the `onClick` callback, and the icon to
    display.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PetsBottomNavigationBar` 可组合组件与 `PetsNavigationRail` 可组合组件类似。唯一的区别是我们使用 `NavigationBar`
    可组合组件而不是 `NavigationRail` 可组合组件。我们有主页和收藏夹项目。我们使用 `NavigationBarItem` 可组合组件向 `NavigationBar`
    添加项目。我们传递项目的选中状态、`onClick` 回调函数和要显示的图标。'
- en: 'Next, let us create the **PetsNavigationDrawer** composable. Let us create
    a new file called **PetsNavigationDrawer.kt** inside the **view** package and
    add the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 **PetsNavigationDrawer** 的可组合组件。在 **view** 包内创建一个名为 **PetsNavigationDrawer.kt**
    的新文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We used the `NavigationDrawer` composable from the Material 3 library to display
    the navigation drawer. We used the `NavigationDrawerItem` composable to add items
    to `NavigationDrawer`. We passed in the label, the selected state of the item,
    the `onClick` callback, and the icon to display.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了 Material 3 库中的 `NavigationDrawer` 可组合组件来显示导航抽屉。我们使用 `NavigationDrawerItem`
    可组合组件向 `NavigationDrawer` 添加项目。我们传递了标签、项目的选中状态、`onClick` 回调函数和要显示的图标。
- en: 'Since our **PetsNavigationDrawer**, **PetsNavigationRail**, and **PetsBottomNavigationBar**
    composables have **FavoritesScreen**, let us create a new file called **FavoritePetsScreen.kt**
    inside the view package and add the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的`PetsNavigationDrawer`、`PetsNavigationRail`和`PetsBottomNavigationBar`可组合组件都有`FavoritesScreen`，让我们在视图包中创建一个名为`FavoritePetsScreen.kt`的新文件，并添加以下代码：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a simple composable that displays the text `"Favorite Pets"`. We will
    use this composable as the content of `FavoritesScreen`. We also need to refactor
    our `AppNavigation()` composable to make it ready to handle the different navigation
    and content types. The final modified composable should look like this:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的可组合组件，显示文本`"Favorite Pets"`。我们将使用这个可组合组件作为`FavoritesScreen`的内容。我们还需要重构我们的`AppNavigation()`可组合组件，使其准备好处理不同的导航和内容类型。最终修改后的可组合组件应该看起来像这样：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s highlight the changes:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们突出显示这些更改：
- en: Our **AppNavigation()** composable now takes in a **contentType** parameter
    of type **ContentType**. This is the parameter we will use to change the content
    type depending on the screen size. We also pass in a **navHostController** parameter
    of type **NavHostController**. This is the parameter we will use to navigate to
    different screens in our app. Previously, **navHostController** was created inside
    the **AppNavigation()** composable. We have moved it to the call site so that
    we can be able to use the same **navHostController** in different composables.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在的`AppNavigation()`可组合组件接受一个类型为`ContentType`的`contentType`参数。这是我们用来根据屏幕大小更改内容类型的参数。我们还传递了一个类型为`NavHostController`的`navHostController`参数。这是我们用来在应用中导航到不同屏幕的参数。之前，`navHostController`是在`AppNavigation()`可组合组件内部创建的。我们已经将其移动到调用位置，这样我们就可以在不同的可组合组件中使用相同的`navHostController`。
- en: We have used the new **PetsScreen()** composable, which takes in the **contentType**
    parameter. Same as before, we still pass **onPetClicked**, which navigates to
    **PetDetailsScreen**. Previously, we were using the **PetList** composable.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了新的`PetsScreen()`可组合组件，它接受`contentType`参数。和之前一样，我们仍然传递`onPetClicked`，它导航到`PetDetailsScreen`。之前，我们使用的是`PetList`可组合组件。
- en: Lastly, we have added our new **FavoritePetsScreen** destination to the **NavHost**
    composable.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将新的`FavoritePetsScreen`目的地添加到`NavHost`可组合组件中。
- en: 'Let us see what the new update **PetsScreen** composable looks like. Let us
    head over to the **PetsScreen.kt** file and modify the composable as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看新的更新`PetsScreen`可组合组件的样子。让我们转到`PetsScreen.kt`文件，并按如下方式修改可组合组件：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have added a new `contentType` parameter to the composable. We have also
    added a new `petsUIState` parameter. This is the UI state of `PetsScreen`. We
    will use this state to display the list of cats.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向可组合组件中添加了一个新的`contentType`参数，还添加了一个新的`petsUIState`参数。这是`PetsScreen`的UI状态。我们将使用这个状态来显示猫的列表。
- en: 'Next, create a new file called **PetsScreenContent.kt** and add the following
    code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`PetsScreenContent.kt`的新文件，并添加以下代码：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s explain the preceding code:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释一下前面的代码：
- en: '`PetList` composable should look like this:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PetList`可组合组件应该看起来像这样：'
- en: '[PRE29]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'No major changes here: we have just added the `pets` parameter. We use this
    parameter to display the list of cats in our `LazyColumn`. With this update, it
    is time to create the `PetListAndDetails` composable.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里没有重大变化：我们只是添加了`pets`参数。我们使用这个参数来显示`LazyColumn`中的猫的列表。随着这个更新，现在是时候创建`PetListAndDetails`可组合组件了。
- en: 'Let us create a new file called **PetListAndDetails.kt** inside the view package
    and add the following code:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在视图包中创建一个名为`PetListAndDetails.kt`的新文件，并添加以下代码：
- en: '[PRE30]'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This composable has a `Row`, which has two items each with a weight of `1f`.
    We have used the updated `PetListComposable` and `PetDetailsScreenContent` that
    we created earlier. We have also added a `currentPet` variable, which holds the
    currently selected cat. We use this variable to display the details of the selected
    cat. We also use this variable to update `currentPet` when we click on a pet item
    in the list. Make sure you also update `PetDetailsScreenContent` to take in the
    new modifier parameter.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个可组合组件有一个`Row`，其中有两个项目，每个项目的权重为`1f`。我们使用了之前创建的更新后的`PetListComposable`和`PetDetailsScreenContent`。我们还添加了一个`currentPet`变量，它保存当前选中的猫。我们使用这个变量来显示所选猫的详细信息。我们还使用这个变量在点击列表中的宠物项目时更新`currentPet`。确保您还更新`PetDetailsScreenContent`以接受新的修饰符参数。
- en: With the modifications we have made, let us now create a new composable called
    `AppNavigationContent`, which has logic for displaying `NavigationRail` or `BottomNavigation`
    depending on `NavigationType`.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过我们进行的修改，现在让我们创建一个新的可组合组件，名为 `AppNavigationContent`，它根据 `NavigationType` 来显示
    `NavigationRail` 或 `BottomNavigation`。
- en: 'Let us create a new file called **AppNavigationContent.kt** inside the navigation
    package and add the following code:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们在 **navigation** 包内创建一个名为 **AppNavigationContent.kt** 的新文件，并添加以下代码：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s explain the preceding code:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们解释一下前面的代码：
- en: The **AppNavigationContent** composable takes a number of parameters. The **contentType**
    parameter is used to display the content type. The **navigationType** parameter
    is used to toggle the navigation options. **onFavoriteClicked** and **onHomeClicked**
    are callbacks that will be used to navigate to the different screens. **navHostController**
    is an object that manages navigation within the **NavHost** **onDrawerClicked**
    is used to close or open the drawer when the user interacts with it.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AppNavigationContent** 可组合组件接受多个参数。**contentType** 参数用于显示内容类型。**navigationType**
    参数用于切换导航选项。**onFavoriteClicked** 和 **onHomeClicked** 是回调函数，将用于导航到不同的屏幕。**navHostController**
    是一个对象，用于管理 **NavHost** 内部的导航。**onDrawerClicked** 用于在用户与之交互时关闭或打开抽屉。'
- en: We have **Row** as the root element. Inside **Row**, we have an **AnimatedVisibility**
    composable that displays the **PetsNavigationRail** composable when **navigationType**
    is **NavigationType**.**NavigationRail**. We have also added a **Scaffold** composable.
    We have used the **AppNavigation** composable as the content of **Scaffold**,
    passing in **contentType** and **navHostController**. We have also used the **PetsBottomNavigationBar**
    composable as the bottom bar of **Scaffold**. We have used the **AnimatedVisibility**
    composable to display the **PetsBottomNavigationBar** composable when **navigationType**
    is **NavigationType.BottomNavigation**.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以 **Row** 作为根元素。在 **Row** 内部，我们有一个 **AnimatedVisibility** 可组合组件，当 **navigationType**
    为 **NavigationType** 时，它会显示 **PetsNavigationRail** 可组合组件。我们还添加了一个 **Scaffold**
    可组合组件。我们将 **AppNavigation** 可组合组件用作 **Scaffold** 的内容，传递了 **contentType** 和 **navHostController**。我们还使用了
    **PetsBottomNavigationBar** 可组合组件作为 **Scaffold** 的底部栏。当 **navigationType** 为 **NavigationType.BottomNavigation**
    时，我们使用了 **AnimatedVisibility** 可组合组件来显示 **PetsBottomNavigationBar** 可组合组件。
- en: 'The last step is to refactor the **MainActivity.kt** file to use the new **AppNavigationContent**
    composable. We will walk through the changes step by step. There are several changes:'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是将 **MainActivity.kt** 文件重构以使用新的 **AppNavigationContent** 可组合组件。我们将一步一步地介绍这些更改。有几个更改：
- en: 'To begin with, we need to observe the device’s foldable state. This will enable
    us to change the content type and navigation type. Let us create a new file called
    **DeviceFoldPosture.kt** inside the **navigation** package and add the following
    code:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要观察设备的折叠状态。这将使我们能够更改内容类型和导航类型。让我们在 **navigation** 包内创建一个名为 **DeviceFoldPosture.kt**
    的新文件，并添加以下代码：
- en: '[PRE32]'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we have a sealed interface that represents the different
    postures a foldable device can be in. We have `BookPosture`, which represents
    the posture when the device is in portrait orientation and its fold state is half
    opened. We have `SeparatingPosture`, which represents the posture when the fold
    or hinge device creates two logical display areas. We also have `NormalPosture`,
    which represents the posture when the device is not folded. We have two utility
    functions, `isBookPosture()` and `isSeparating()`, which are used to check the
    posture of the device. We will use these functions to check the posture of the
    device and change the layout of the app depending on the posture.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个密封接口，表示可折叠设备可以处于的不同状态。我们有 `BookPosture`，表示设备处于纵向方向且折叠状态为半开时的状态。我们有
    `SeparatingPosture`，表示折叠或铰链设备创建两个逻辑显示区域的状态。我们还有 `NormalPosture`，表示设备未折叠时的状态。我们有两个实用函数，`isBookPosture()`
    和 `isSeparating()`，用于检查设备的状态。我们将使用这些函数来检查设备的状态，并根据状态改变应用布局。
- en: 'Let us head over to the **MainActivity.kt** file and add the following code
    before the **setContent** block:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 **MainActivity.kt** 文件，并在 **setContent** 块之前添加以下代码：
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we use `WindowInfoTracker` to get the window layout info. We use `flowWithLifecycle()`
    to make sure we only get the layout info when the activity is in the correct life
    cycle state. We then use the `map` operator to map the layout info to the different
    postures. We use the `stateIn()` operator, which converts a cold `Flow` into a
    hot `StateFlow` that is started in the given coroutine scope, sharing the most
    recently emitted value of device posture. We use `SharingStarted.Eagerly` to make
    sure we get the latest value of the posture when the activity is in the started
    state. We use the `initialValue` parameter to set the initial value of the posture
    to `DeviceFoldPosture.NormalPosture`. We will use this flow to observe the device’s
    posture and change the app’s layout depending on the posture.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`WindowInfoTracker`来获取窗口布局信息。我们使用`flowWithLifecycle()`来确保我们只在活动处于正确的生命周期状态时获取布局信息。然后我们使用`map`操作符将布局信息映射到不同的姿势。我们使用`stateIn()`操作符，它将冷`Flow`转换为在给定协程作用域中启动的热`StateFlow`，共享设备姿势的最新发出值。我们使用`SharingStarted.Eagerly`来确保当活动处于启动状态时，我们获取姿势的最新值。我们使用`initialValue`参数将姿势的初始值设置为`DeviceFoldPosture.NormalPosture`。我们将使用这个流来观察设备的姿势并根据姿势更改应用布局。
- en: 'Next, inside our **setcontent** block, we need to add the variables before
    the theme block:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的**setcontent**块内部，我们需要在主题块之前添加变量：
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have added the `devicePosture` variable, which holds the posture of the device.
    We have also added the `windowSizeClass` variable, which holds the window size
    class of the device; the `scope` variable, which holds `CoroutineScope`; the `drawerState`
    variable, which holds the state of the drawer; and the `navController` variable,
    which holds `NavHostController`. We will use this variable to navigate to different
    screens in our app.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了`devicePosture`变量，它包含设备的姿势。我们还添加了`windowSizeClass`变量，它包含设备的窗口大小类；`scope`变量，它包含`CoroutineScope`；`drawerState`变量，它包含抽屉的状态；以及`navController`变量，它包含`NavHostController`。我们将使用这个变量来导航到我们应用中的不同屏幕。
- en: 'Inside our **ChapterSevenTheme**, we need to add the following code:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的**ChapterSevenTheme**内部，我们需要添加以下代码：
- en: '[PRE35]'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we have two variables: `navigationType` and `contentType`. We use `windowSizeClass`
    to get the width of our device and, depending on the width size, we assign the
    values for our `navigationType` and `contentType` variables:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有两个变量：`navigationType`和`contentType`。我们使用`windowSizeClass`来获取我们设备的宽度，并根据宽度大小，为我们的`navigationType`和`contentType`变量分配值：
- en: If the width size is **Compact**, we use **BottomNavigation** for **navigationType**
    and **List** for **contentType**.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是**Compact**，我们使用**BottomNavigation**作为**navigationType**和**List**作为**contentType**。
- en: If the width size is **Medium**, we use **NavigationRail** for **navigationType**.
    For **contentType**, we check **devicePosture**. If **devicePosture** is **DeviceFoldPosture.BookPosture**
    or **DeviceFoldPosture.SeparatingPosture**, we use **ListAndDetail** for **contentType**.
    If **devicePosture** is not **DeviceFoldPosture.BookPosture** or **DeviceFoldPosture.SeparatingPosture**,
    we use **List** for **contentType**.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是**Medium**，我们使用**NavigationRail**作为**navigationType**。对于**contentType**，我们检查**devicePosture**。如果**devicePosture**是**DeviceFoldPosture.BookPosture**或**DeviceFoldPosture.SeparatingPosture**，我们使用**ListAndDetail**作为**contentType**。如果**devicePosture**不是**DeviceFoldPosture.BookPosture**或**DeviceFoldPosture.SeparatingPosture**，我们使用**List**作为**contentType**。
- en: If the width size is **Expanded**, we check **devicePosture**. If **devicePosture**
    is **DeviceFoldPosture.BookPosture**, we use **NavigationRail** for **navigationType**.
    If **devicePosture** is not **DeviceFoldPosture.BookPosture**, we use **NavigationDrawer**
    for **navigationType**. We use **ListAndDetail** for **contentType**.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宽度大小是**Expanded**，我们检查**devicePosture**。如果**devicePosture**是**DeviceFoldPosture.BookPosture**，我们使用**NavigationRail**作为**navigationType**。如果**devicePosture**不是**DeviceFoldPosture.BookPosture**，我们使用**NavigationDrawer**作为**navigationType**。我们使用**ListAndDetail**作为**contentType**。
- en: Lastly, if the width size is anything else, we use **BottomNavigation** for
    **navigationType** and **List** for **contentType**.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果宽度大小是其他任何值，我们使用**BottomNavigation**作为**navigationType**和**List**作为**contentType**。
- en: 'Below the preceding code, add this **if** statement:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码下方，添加以下**if**语句：
- en: '[PRE36]'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The condition checks whether `navigationType` is `NavigationType.NavigationDrawer`.
    If it is, we use the `PermanentNavigationDrawer` composable from the Material
    3 library. We use the `PetsNavigationDrawer` composable that we created for `drawerContent`.
    We use the `AppNavigationContent` composable as the content of `PermanentNavigationDrawer`.
    We pass in the `navigationType`, `contentType`, `onFavoriteClicked`, `onHomeClicked`,
    and `navHostController` parameters.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件检查`navigationType`是否为`NavigationType.NavigationDrawer`。如果是，我们使用Material 3库中的`PermanentNavigationDrawer`可组合组件。我们使用我们为`drawerContent`创建的`PetsNavigationDrawer`可组合组件。我们将`AppNavigationContent`可组合组件用作`PermanentNavigationDrawer`的内容。我们传递`navigationType`、`contentType`、`onFavoriteClicked`、`onHomeClicked`和`navHostController`参数。
- en: 'Next, let us add the **else** condition for our **if** statement:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的**if**语句添加**else**条件：
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, when `navigationType` is not `NavigationType.NavigationDrawer`, we use
    the `ModalNavigationDrawer` composable from the Material 3 library. We use the
    `PetsNavigationDrawer` composable for `drawerContent`. We use the `AppNavigationContent`
    composable as the content of `ModalNavigationDrawer`. We pass in the `navigationType`,
    `contentType`, `onFavoriteClicked`, `onHomeClicked`, and `navHostController` parameters.
    We also pass in the `drawerState` parameter. We use the `onDrawerClicked` callback
    to open or close the drawer when the user interacts with it.
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，当`navigationType`不是`NavigationType.NavigationDrawer`时，我们使用Material 3库中的`ModalNavigationDrawer`可组合组件。我们使用`PetsNavigationDrawer`可组合组件作为`drawerContent`。我们将`AppNavigationContent`可组合组件用作`ModalNavigationDrawer`的内容。我们传递`navigationType`、`contentType`、`onFavoriteClicked`、`onHomeClicked`和`navHostController`参数。我们还传递`drawerState`参数。我们使用`onDrawerClicked`回调在用户与之交互时打开或关闭抽屉。
- en: Those were a lot of changes; great work on adding them! We now need to run these
    changes and see them into action. Luckily, we have a **resizable emulator** to
    help test these changes. We will be creating one and testing the app in the next
    subsection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化有很多；在添加它们方面做得很好！我们现在需要运行这些更改并看到它们付诸实践。幸运的是，我们有一个**可调整大小的模拟器**来帮助我们测试这些更改。我们将在下一小节中创建一个并测试应用。
- en: Creating and using the resizable emulator
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用可调整大小的模拟器
- en: 'To create and use the resizable emulator, follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用可调整大小的模拟器，请按照以下步骤操作：
- en: Open the **Device Manager** window from the right sidebar in Android Studio.
    If you cannot find it there, use the **View** menu option at the top and select
    **Tool Windows**; then, you will see the **Device** **Manager** option.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Android Studio的右侧侧边栏打开**设备管理器**窗口。如果你在那里找不到它，请使用顶部菜单中的**视图**选项，然后选择**工具窗口**；然后，你将看到**设备管理器**选项。
- en: '![Figure 7.5 – Device Manager](img/B19779_07_05.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 设备管理器](img/B19779_07_05.jpg)'
- en: Figure 7.5 – Device Manager
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 设备管理器
- en: 'Select the **Virtual** devices tab and click on **Create Device**, which brings
    you this pop-up window:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**虚拟设备**选项卡，然后点击**创建设备**，这将弹出一个窗口：
- en: '![Figure 7.6 – New device configurations](img/B19779_07_06.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 新设备配置](img/B19779_07_06.jpg)'
- en: Figure 7.6 – New device configurations
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 新设备配置
- en: The window enables you to customize the properties of the device you want to
    create. You can change the device category and you also select the device you
    want to create.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该窗口使你能够自定义你想要创建的设备的属性。你可以更改设备类别，并且你也可以选择你想要创建的设备。
- en: 'Let us select the **Resizable (Experimental)** option under the **Phone** category.
    This will enable us to create a resizable device. Click **Next** and you will
    see the following window:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在**手机**类别下选择**可调整大小（实验性）**选项。这将使我们能够创建一个可调整大小的设备。点击**下一步**，你将看到以下窗口：
- en: '![Figure 7.7 – System Image](img/B19779_07_07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 系统镜像](img/B19779_07_07.jpg)'
- en: Figure 7.7 – System Image
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 系统镜像
- en: 'Here, you select the system image you want to use. Let us select the **API
    34** system image. Click **Next** and you will see the following window:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你选择要使用的系统镜像。让我们选择**API 34**系统镜像。点击**下一步**，你将看到以下窗口：
- en: '![Figure 7.8 – Device information](img/B19779_07_08.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 设备信息](img/B19779_07_08.jpg)'
- en: Figure 7.8 – Device information
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 设备信息
- en: This is the last step where you confirm the device name and the device orientation.
    We will maintain the name generated and use portrait as the default orientation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一步，在这里你确认设备名称和设备方向。我们将保持生成的名称，并使用纵向作为默认方向。
- en: 'Click **Finish** and you will see the device has been added to your list of
    devices:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**，你将看到设备已添加到你的设备列表中：
- en: '![Figure 7.9 – Devices list](img/B19779_07_09.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 设备列表](img/B19779_07_09.jpg)'
- en: Figure 7.9 – Devices list
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 设备列表
- en: Start the emulator and run the app.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器并运行应用。
- en: '![Figure 7.10 – Resizable emulator](img/B19779_07_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 可调整大小的模拟器](img/B19779_07_10.jpg)'
- en: Figure 7.10 – Resizable emulator
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 可调整大小的模拟器
- en: From the emulator, we can see we have two options highlighted. The first one
    allows us to change the device from a small/normal device to a foldable or tablet
    device. The second one allows us to change the options when we change to a foldable
    device. Let us change the device to a foldable device. The app now changes the
    navigation option to navigation rail and the screen has a list and details of
    the first cat opened too.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从模拟器中，我们可以看到有两个选项被突出显示。第一个选项允许我们将设备从小型/普通设备更改为可折叠或平板设备。第二个选项允许我们在更改为可折叠设备时更改选项。让我们将设备更改为可折叠设备。现在应用将导航选项更改为导航轨道，屏幕上还打开了第一只猫的列表和详细信息。
- en: '![Figure 7.11 – Foldable device navigation rail](img/B19779_07_11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 可折叠设备导航轨道](img/B19779_07_11.jpg)'
- en: Figure 7.11 – Foldable device navigation rail
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 可折叠设备导航轨道
- en: 'On tapping the **Foldable** options, we can see the following options:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**可折叠**选项时，我们可以看到以下选项：
- en: '![Figure 7.12 – Foldable options](img/B19779_07_12.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 可折叠选项](img/B19779_07_12.jpg)'
- en: Figure 7.12 – Foldable options
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 可折叠选项
- en: 'Selecting the second option in the foldables section brings us to the following
    screen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在可折叠部分选择第二个选项将带我们到以下屏幕：
- en: '![Figure 7.13 – Foldable device](img/B19779_07_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 可折叠设备](img/B19779_07_13.jpg)'
- en: Figure 7.13 – Foldable device
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 可折叠设备
- en: 'From the device size option, we can also switch to tablet view:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备尺寸选项中，我们还可以切换到平板视图：
- en: '![Figure 7.14 – Tablet view](img/B19779_07_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 平板视图](img/B19779_07_14.jpg)'
- en: Figure 7.14 – Tablet view
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 平板视图
- en: You can see the app now has a permanent navigation drawer and the screen has
    a list and details of the first cat opened too. Tap a different cat and you will
    see the details of the cat displayed on the right side of the screen. We can also
    navigate to the **Favorites** screen and back to the **Pets** screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到现在应用有一个永久的导航抽屉，屏幕上还打开了第一只猫的列表和详细信息。点击不同的猫，您将在屏幕右侧看到猫的详细信息。我们还可以导航到**收藏**屏幕，然后返回到**宠物**屏幕。
- en: '![Figure 7.15 – Favorite Pets screen](img/B19779_07_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 喜爱的宠物屏幕](img/B19779_07_15.jpg)'
- en: Figure 7.15 – Favorite Pets screen
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 喜爱的宠物屏幕
- en: 'We can also see the modal navigation drawer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到模式导航抽屉：
- en: '![Figure 7.16 – Modal navigation drawer](img/B19779_07_16.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 模式导航抽屉](img/B19779_07_16.jpg)'
- en: Figure 7.16 – Modal navigation drawer
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 模式导航抽屉
- en: 'The resizable emulator is a great way for us to test our app across different
    device sizes, but it has its own limitations. The following are the limitations
    of resizable emulators:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可调整大小的模拟器是我们测试不同设备尺寸应用的好方法，但它有其自身的局限性。以下是可以调整大小的模拟器的局限性：
- en: '**Hinge simulation**: While resizable emulators offer multi-window support
    and simulate various orientations, they might not accurately replicate the behavior
    of a physical hinge on foldable devices. The hinge’s physical characteristics
    and behavior may affect app layouts and interactions differently.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**铰链模拟**：虽然可调整大小的模拟器提供了多窗口支持和模拟各种方向，但它们可能无法准确复制可折叠设备上物理铰链的行为。铰链的物理特性和行为可能会以不同的方式影响应用布局和交互。'
- en: '**Hardware specifics**: Emulators lack physical hardware components present
    in foldable devices, such as the actual hinge mechanism, flexible displays, sensors,
    and proprietary features, impacting the true emulation of foldable device behavior.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件特定**：模拟器缺乏可折叠设备中存在的物理硬件组件，例如实际铰链机构、柔性显示屏、传感器和专有功能，这影响了可折叠设备行为的真实模拟。'
- en: '**Performance variation**: Emulators may not accurately represent the performance
    capabilities of real foldable devices, especially in terms of hardware-specific
    optimizations and performance characteristics.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能变化**：模拟器可能无法准确代表真实可折叠设备的性能能力，特别是在硬件特定优化和性能特性方面。'
- en: '**Real-world testing environment**: Foldable devices may have unique environmental
    factors that impact user experience, such as external lighting conditions affecting
    the flexible display. Emulators may not replicate these real-world scenarios accurately.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实世界测试环境**：可折叠设备可能具有影响用户体验的独特环境因素，例如外部照明条件会影响柔性显示屏。模拟器可能无法准确复制这些现实世界场景。'
- en: '**Software emulation versus hardware interaction**: Certain foldable device
    behaviors, such as drag-and-drop interactions across screens or unique gestures,
    might not be fully emulated in software due to hardware-specific interactions.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件仿真与硬件交互**：由于硬件特定的交互，某些可折叠设备的行为，例如跨屏幕的拖放交互或独特的手势，可能无法在软件中完全仿真。'
- en: 'We have learned how to handle navigation in foldable devices and large screens
    and how to provide a great user experience as the user is switching between the
    different screen sizes. This ensures that our app is responsive to different devices
    and that we satisfactorily use the available screen sizes. The team at Google
    has published stories of companies that support large screens and foldables; you
    can have a look here: [https://developer.android.com/large-screens/stories](https://developer.android.com/large-screens/stories).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何处理可折叠设备和大型屏幕中的导航，以及如何在用户在不同屏幕尺寸之间切换时提供出色的用户体验。这确保了我们的应用能够对不同设备做出响应，并且我们能够充分利用可用的屏幕尺寸。谷歌团队发布了支持大屏幕和可折叠设备的公司故事；您可以在此查看：[https://developer.android.com/large-screens/stories](https://developer.android.com/large-screens/stories)。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use the Jetpack Compose Navigation library
    to navigate to different Jetpack Compose screens within our app. We have also
    learned tips and best practices for using this library. Additionally, we have
    covered how to pass arguments as we navigate to screens. Lastly, we have built
    on what we learned in [*Chapter 4*](B19779_04.xhtml#_idTextAnchor055), by handling
    navigation in large screens and foldables in detail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Jetpack Compose导航库在应用内导航到不同的Jetpack Compose屏幕。我们还学习了使用此库的技巧和最佳实践。此外，我们还介绍了如何在导航到屏幕时传递参数。最后，我们通过详细处理大屏幕和可折叠设备中的导航，在[*第4章*](B19779_04.xhtml#_idTextAnchor055)所学内容的基础上进行了扩展。
- en: We have created `FavoritePetsScreen`, but as of now it only has a `Text` label.
    In the next chapter, we will be adding functionality to persist data locally and
    retrieve that data locally too without any internet access. We will learn how
    to save our cute cat photos to Room, another Jetpack library for offline storage,
    and also add pets to our favorites list.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`FavoritePetsScreen`，但截至目前，它只有一个`Text`标签。在下一章中，我们将添加功能以在本地持久化数据，并在没有互联网访问的情况下检索该数据。我们将学习如何将我们可爱的小猫照片保存到Room，这是另一个用于离线存储的Jetpack库，并且还将添加宠物到我们的收藏列表中。
