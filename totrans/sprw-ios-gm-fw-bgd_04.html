<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. The Basics of Our Game</h1></div></div></div><p>
<em>In the previous chapter, we learned about assets and how to implement our own asset management system which loads the assets from the application bundle and caches them. We used the asset management setup to load our first image. We covered how to group display objects into scenes and wrote a scene director that manages our scenes. In this chapter, we will begin setting up our game. We will learn about what to consider when targeting different devices, and we will take the first step in setting up our game. This includes creating the scenes we need and displaying static images on the screen.</em>
</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Taking care of cross-device compatibility</h1></div></div></div><p>When developing an iOS game, we need to know which device to target. Besides the obvious technical differences between all of the iOS devices, there are two factors we need to actively take care of: screen size and texture size limit.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>For a quick <a id="id149" class="indexterm"/>reference on the differences between iOS devices, take a look at the comparison table at <a class="ulink" href="http://www.iosres.com/">http://www.iosres.com/</a>.</p></div></div><p>Let's take a closer look at how to deal with the texture size limit and screen sizes.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Understanding the texture size limit</h2></div></div></div><p>Every <a id="id150" class="indexterm"/>graphics card has a limit for the maximum size texture it can display. If a texture is bigger than the texture size limit, it can't be loaded and will appear black on the screen. A texture size limit has <strong>power-of-two</strong> dimensions and is a square such as 1024 pixels in width and in height or 2048 x 2048 pixels.</p><p>When loading a texture, they don't need to have power-of-two dimensions. In fact, the texture does not have to be a square. However, it is a best practice for a texture to have power-of-two dimensions.</p><p>This limit holds for big images as well as a bunch of small images packed into a big image. The latter is commonly referred to as a sprite sheet. Take a look at the following sample <a id="id151" class="indexterm"/>sprite sheet to see how it's structured:</p><div><img src="img/1509OS_04_01.jpg" alt="Understanding the texture size limit"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>How to deal with different screen sizes</h2></div></div></div><p>While the<a id="id152" class="indexterm"/> screen size is always measured in pixels, the iOS coordinate system is measured in points.</p><p>The screen size of an iPhone 3GS is 320 x 480 pixels and also 320 x 480 points. On an iPhone 4, the screen size is 640 x 960 pixels, but is still 320 by 480 points. So, in this case, each point represents four pixels: two in width and two in height. A 100-point wide rectangle will be 200 pixels wide on an iPhone 4 and 100 pixels on an iPhone 3GS.</p><p>It works similarly for the devices with large display screens, such as the iPhone 5. Instead of 480 points, it's 568 points.</p><div><img src="img/1509OS_04_02.jpg" alt="How to deal with different screen sizes"/></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Scaling the viewport</h3></div></div></div><p>Let's explain the <a id="id153" class="indexterm"/>term viewport first: the viewport is the visible <a id="id154" class="indexterm"/>portion of the complete screen area.</p><p>We need to be clear about which devices we want our game to run on. We take the biggest resolution that we want to support and scale it down to a smaller resolution. This is the easiest option, but it might not lead to the best results; touch areas and the user interface scale down as well. Apple recommends for touch areas to be at least a 40-point square; so, depending on the user interface, some elements might get scaled down so much that they get harder to touch.</p><p>Take a look at the following screenshot, where we choose the iPad Retina resolution (2048 x 1536 pixels) as our biggest resolution and scale down all display objects on the screen for the iPad resolution (1024 x 768 pixels):</p><div><img src="img/1509OS_04_03.jpg" alt="Scaling the viewport"/></div><p>Scaling<a id="id155" class="indexterm"/> is a popular option for non-iOS environments, especially<a id="id156" class="indexterm"/> for PC and Mac games that support resolutions from 1024 x 600 pixels to full HD.</p><p>As we will learn later in this chapter, Sparrow and the iOS SDK provide some mechanisms that will facilitate handling Retina and non-Retina iPad devices without the need to scale the whole viewport.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Black borders</h3></div></div></div><p>Some games<a id="id157" class="indexterm"/> in the past have been designed for a 4:3 resolution<a id="id158" class="indexterm"/> display but then made to run on a widescreen device that had more screen space.</p><p>So, the option was to either scale a 4:3 resolution to widescreen, which will distort the whole screen, or put some black borders on either side of the screen to maintain the original scale factor.</p><div><img src="img/1509OS_04_04.jpg" alt="Black borders"/></div><p>Showing black<a id="id159" class="indexterm"/> borders is something that is now considered<a id="id160" class="indexterm"/> as bad practice, especially when there are so many games out there which scale quite well across different screen sizes and platforms.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Showing non-interactive screen space</h3></div></div></div><p>If our <a id="id161" class="indexterm"/>pirate game is a multiplayer, we <a id="id162" class="indexterm"/>may have a player on an iPad and another on an iPhone 5. So, the player with the iPad has a bigger screen and more screen space to maneuver their ship. The worst case will be if the player with the iPad is able to move their ship outside the visual range for the iPhone player to see, which will result in a serious advantage for the iPad player.</p><p>Luckily for us, we don't require competitive multiplayer functionality. Still, we need to keep a consistent screen space for players to move their ship in for game balance purposes. We wouldn't want to tie the difficulty level to the device someone is playing on.</p><div><img src="img/1509OS_04_05.jpg" alt="Showing non-interactive screen space"/></div><p>Let's<a id="id163" class="indexterm"/> compare the previous screenshot<a id="id164" class="indexterm"/> to the black border example. Instead of the ugly black borders, we just show more of the background.</p><p>In some cases, it's also possible to move some user interface elements to the areas which are not visible on other devices. However, we will need to consider whether we want to keep the same user experience across devices and whether moving these elements will result in a disadvantage for users who don't have this extra screen space on their devices.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Rearranging screen elements</h3></div></div></div><p>Rearranging<a id="id165" class="indexterm"/> screen elements is probably<a id="id166" class="indexterm"/> the most time-intensive and sophisticated way of solving this issue. In this example, we have a big user interface at the top of the screen in the portrait mode. Now, if we were to leave it like this in the landscape mode, the top of the screen will be just the user interface, leaving very little room for the game itself.</p><div><img src="img/1509OS_04_06.jpg" alt="Rearranging screen elements"/></div><p>In this<a id="id167" class="indexterm"/> case, we have to be deliberate about what<a id="id168" class="indexterm"/> kind of elements we need to see on the screen and which elements are using up too much screen estate. <strong>Screen real estate</strong> (or screen estate) is the amount of space available on a display for an application or a game to provide output. We will then have to reposition them, cut them up in to smaller pieces, or both.</p><p>The most prominent example of this technique is <em>Candy Crush</em> (a popular trending game) by King. While this concept applies particularly to device rotation, this does not mean that it can't be used for universal applications.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Choosing the best option</h3></div></div></div><p>None of these options are mutually exclusive. For our purposes, we are going to show non-interactive screen space, and if things get complicated, we might also resort to rearranging screen elements depending on our needs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Differences between various devices</h2></div></div></div><p>Let's take <a id="id169" class="indexterm"/>a look at the differences in the screen size and the texture size limit between the different iOS devices:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device</p>
</th><th style="text-align: left" valign="bottom">
<p>Screen size (in pixels)</p>
</th><th style="text-align: left" valign="bottom">
<p>Texture size limit (in pixels)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>iPhone 3GS</p>
</td><td style="text-align: left" valign="top">
<p>480 x 360</p>
</td><td style="text-align: left" valign="top">
<p>2048 x 2048</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 4 (including iPhone 4S) and iPod Touch 4<sup>th</sup> generation</p>
</td><td style="text-align: left" valign="top">
<p>960 x 640</p>
</td><td style="text-align: left" valign="top">
<p>2048 x 2048</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch 5<sup>th</sup> generation</p>
</td><td style="text-align: left" valign="top">
<p>1136 x 640</p>
</td><td style="text-align: left" valign="top">
<p>2048 x 2048</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad 2</p>
</td><td style="text-align: left" valign="top">
<p>1024 x 768</p>
</td><td style="text-align: left" valign="top">
<p>2048 x 2048</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad (3<sup>rd</sup> and 4<sup>th</sup> generations) and iPad Air</p>
</td><td style="text-align: left" valign="top">
<p>2048 x 1536</p>
</td><td style="text-align: left" valign="top">
<p>4096 x 4096</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad Mini</p>
</td><td style="text-align: left" valign="top">
<p>1024 x 768</p>
</td><td style="text-align: left" valign="top">
<p>4096 x 4096</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Utilizing the iOS SDK</h2></div></div></div><p>Both the iOS<a id="id170" class="indexterm"/> SDK and Sparrow can aid us in creating a universal application. Universal application is the term for apps that target more than one device, especially for an app that targets the iPhone and iPad device family.</p><p>The iOS SDK provides a handy mechanism for loading files for specific devices. Let's say we are developing an iPhone application and we have an image that's called <code class="literal">my_amazing_image.png</code>. If we load this image on our devices, it will get loaded—no questions asked. However, if it's not a universal application, we can only scale the application using the regular scale button on iPad and iPhone Retina devices. This button appears on the bottom-right of the screen.</p><p>If we want to target iPad, we have two options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first option is to load the image as is. The device will scale the image. Depending on the image quality, the scaled image may look bad. In this case, we also need to consider that the device's CPU will do all the scaling work, which might result in some slowdown depending on the app's complexity.</li><li class="listitem" style="list-style-type: disc">The second option is to add an extra image for iPad devices. This one will use the <code class="literal">~ipad</code> suffix, for example, <code class="literal">my_amazing_image~ipad.png</code>. When loading the required image, we will still use the filename <code class="literal">my_amazing_image.png</code>. The iOS SDK will automatically detect the different sizes of the image supplied and use the correct size for the device.</li></ul></div><p>Beginning with Xcode 5 and iOS 7, it is possible to use asset catalogs. Asset catalogs can contain a variety of images grouped into image sets. Image sets contain all the images for the targeted devices. These asset catalogs don't require files with suffixes any more. These can only be used for splash images and application icons. We can't use asset catalogs for textures we load with Sparrow though.</p><p>The following table shows which suffix is needed for which device:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device</p>
</th><th style="text-align: left" valign="bottom">
<p>Retina</p>
</th><th style="text-align: left" valign="bottom">
<p>File suffix</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>iPhone 3GS</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>None</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 4 (including iPhone 4S) and iPod Touch (4<sup>th</sup> generation)</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@2x</code>
</p>
<p>
<code class="literal">@2x~iphone</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch (5<sup>th</sup> generation)</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">-568h@2x</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad 2</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">~ipad</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad (3<sup>rd</sup> and 4<sup>th</sup> generations) and iPad Air</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">@2x~ipad</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad Mini</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">~ipad</code>
</p>
</td></tr></tbody></table></div><p>How <a id="id171" class="indexterm"/>does this affect the graphics we wish to display? The non-Retina image will be 128 pixels in width and 128 pixels in height. The Retina image, the one with the <code class="literal">@2x</code> suffix, will be exactly double the size of the non-Retina image, that is, 256 pixels in width and 256 pixels in height.</p><div><img src="img/1509OS_04_07.jpg" alt="Utilizing the iOS SDK"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Retina and iPad support in Sparrow</h2></div></div></div><p>Sparrow <a id="id172" class="indexterm"/>supports all the filename suffixes shown in the previous table, <a id="id173" class="indexterm"/>and there is a special case for iPad devices, which we<a id="id174" class="indexterm"/> will take a closer look at now.</p><p>When we take<a id="id175" class="indexterm"/> a look at <code class="literal">AppDelegate.m</code> in our game's source, note the following line:</p><div><pre class="programlisting">[_viewController startWithRoot:[Game class] supportHighResolutions:YES doubleOnPad:YES];</pre></div><p>The first parameter, <code class="literal">supportHighResolutions</code>, tells the application to load Retina images (with the <code class="literal">@2x</code> suffix) if they are available.</p><p>The <code class="literal">doubleOnPad</code> parameter<a id="id176" class="indexterm"/> is the interesting one. If this is set to <code class="literal">true</code>, Sparrow will use the <code class="literal">@2x</code> images for iPad devices. So, we don't need to create a separate set of images for iPad, but we can use the Retina iPhone images for the iPad application.</p><p>In this case, the width and height are 512 and 384 points respectively. If we are targeting iPad Retina devices, Sparrow introduces the <code class="literal">@4x</code> suffix, which requires larger images and leaves the coordinate system at 512 x 384 points.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>App icons and splash images</h2></div></div></div><p>If we are talking about images of different sizes for the actual game content, app icons and splash images are also required to be in different sizes.</p><p>
<strong>Splash images</strong> (also referred to as launch images) are the images that show up while the application loads. The iOS naming scheme applies for these images as well, so for Retina iPhone devices such as iPhone 4, we will name an image as <code class="literal">Default@2x.png,</code> and for iPhone 5 devices, we will name an image as <code class="literal">Default-568h@2x.png</code>.</p><p>For the correct<a id="id177" class="indexterm"/> size of app icons, take a look at the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Device</p>
</th><th style="text-align: left" valign="bottom">
<p>Retina</p>
</th><th style="text-align: left" valign="bottom">
<p>App icon size</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>iPhone 3GS</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>57 x 57 pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 4 (including iPhone 4S) and iPod Touch 4<sup>th</sup> generation</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>120 x 120 pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch 5<sup>th</sup> generation</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>120 x 120 pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad 2</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>76 x 76 pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad (3<sup>rd</sup> and 4<sup>th</sup> generation) and iPad Air</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>152 x 152 pixels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>iPad Mini</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>76 x 76 pixels</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>The bottom line</h2></div></div></div><p>The more devices we want to support, the more graphics we need, which directly increases the application file size, of course. Adding iPad support to our application is not a simple task, but Sparrow does some groundwork.</p><p>One thing we should keep in mind though: if we are only targeting iOS 7.0 and higher, we don't need to include non-Retina iPhone images any more. Using <code class="literal">@2x</code> and <code class="literal">@4x</code> will be enough in this case, as support for non-Retina devices will soon end.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Starting with the development of our game</h1></div></div></div><p>Now that we <a id="id178" class="indexterm"/>have enough theory and experience with the Sparrow framework, let's put all that knowledge to use and turn theory into practice by creating our pirate game.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>If you miss any of the development of our game, the source code of the game is also available on GitHub at <a class="ulink" href="https://github.com/freezedev/pirategame">https://github.com/freezedev/pirategame</a>.</p></div></div><p>Our game consists of two main gameplay parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Battlefield/arena</strong>: This<a id="id179" class="indexterm"/> is the scene where our pirate<a id="id180" class="indexterm"/> ship battles against other ships</li><li class="listitem" style="list-style-type: disc"><strong>Pirate cove</strong>: The<a id="id181" class="indexterm"/> pirate cove is the hub for <a id="id182" class="indexterm"/>activities after battling other ships such as hiring new crew members and upgrading the ship</li></ul></div><p>In this chapter, we will set up the required scenes and load the textures, display them as images, and arrange the entities on the screen.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The<a id="id183" class="indexterm"/> graphics for the game are on GitHub as well: <a class="ulink" href="https://github.com/freezedev/pirategame-assets">https://github.com/freezedev/pirategame-assets</a>. The graphics are made with the open-source 3D modeling software, Blender (<a class="ulink" href="http://www.blender.org">http://www.blender.org</a>); Version 2.69 is required to open and edit these files. Don't <a id="id184" class="indexterm"/>worry, we don't need to update these files for the purposes of this book, but if you want to in order to look for inspiration, you are definitely encouraged to do so.</p></div></div><p>Let's download<a id="id185" class="indexterm"/> the required images for this chapter by navigating to <a class="ulink" href="https://github.com/freezedev/pirategame-assets/releases">https://github.com/freezedev/pirategame-assets/releases</a>. This will show all the available releases for this particular repository, as shown in the following screenshot:</p><div><img src="img/1509OS_04_08.jpg" alt="Starting with the development of our game"/></div><p>Go ahead and download the <code class="literal">Graphics.zip</code> package and unzip the contents somewhere on your computer. This package contains the following images:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Filename</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">water.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the background for the battlefield scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">island.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the background for the pirate base. Technically, it's more of an island than a cove, which is why this image is called island, but it's referred to as the pirate cove everywhere else.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">house.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a shelter for our pirates.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tavern.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the building where we get to hire new pirates.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">weaponsmith.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This will be the place where we upgrade our ship with additional cannons or ammunition.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ship.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is our basic enemy.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ship_pirate.png</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the ship we are going to control.</p>
</td></tr></tbody></table></div><p>All of <a id="id186" class="indexterm"/>the assets are in a non-Retina resolution, Retina for iPad 2, iPad Mini, and iPhone/iPod Touch using the <code class="literal">@2x</code> filename suffix and <code class="literal">@4x</code> for iPad Retina devices.</p><p>Drag and drop the files into the <code class="literal">Resources</code> folder of our Xcode project. When a dialog pops up, we need to check <strong>Copy items into destination group's folder (if needed)</strong>, so we don't have to worry about references to the original files. Click on <strong>Finish</strong> to start the process.</p><p>So far, the images have been optimized for the landscape mode, so we need to deactivate the portrait mode for now. We need to select the <strong>PirateGame</strong> project and uncheck <strong>Portrait</strong> and <strong>Upside Down</strong> in the <strong>Deployment Info</strong> section, as shown in the following screenshot. Make sure to uncheck them for both iPhone and iPad.</p><div><img src="img/1509OS_04_09.jpg" alt="Starting with the development of our game"/></div><p>We can also safely delete the cardboard puppet doll code that is still in our <code class="literal">Game.m</code> file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Creating our scene manager setup</h1></div></div></div><p>In the previous chapter, we created a scene manager which we will now use for our scenes. In our first step, we will need two dummy scenes that we will later fill with gameplay mechanics. We will also need to add these scenes to our scene director and display one of the two scenes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Time for action – creating our scene manager setup</h1></div></div></div><p>To<a id="id187" class="indexterm"/> create our scene manager setup, we need to follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your Xcode game template if it's not already open.</li><li class="listitem">Right-click on the <strong>Classes</strong> folder and select <strong>New Group</strong>.</li><li class="listitem">Rename the group to <strong>GameScenes</strong>.</li><li class="listitem">Create a new Objective-C class called <code class="literal">PirateCove</code> which is sub-classed from <code class="literal">Scene</code>.</li><li class="listitem">Add an initializer with the following content:<div><pre class="programlisting">if ((self = [super init])) {
  NSLog(@"Pirate cove scene created");
}</pre></div></li><li class="listitem">Create another Objective-C class which is sub-classed from <code class="literal">Scene</code>. Call this <code class="literal">Battlefield</code>.</li><li class="listitem">Add an initializer with the following content:<div><pre class="programlisting">-(id) init
{
    if ((self = [super init])) {
        NSLog(@"Battlefield scene created");
    }
    
    return self;
}</pre></div></li><li class="listitem">Switch to the <code class="literal">Game.m</code> file.</li><li class="listitem">Add the <code class="literal">PirateCove.h</code>, <code class="literal">Battlefield.h</code>, and <code class="literal">SceneDirector.h</code> files to the <code class="literal">import</code> section, as shown in the following code:<div><pre class="programlisting">#import "SceneDirector.h"
#import "PirateCove.h"
#import "Battlefield.h"</pre></div></li><li class="listitem">In the <code class="literal">init</code> method, create an instance of the <code class="literal">PirateCove</code> and <code class="literal">Battlefield</code> classes and call the <code class="literal">initWithName</code> method using <code class="literal">@"piratecove"</code> and <code class="literal">@"battlefield"</code> respectively for its parameter:<div><pre class="programlisting">PirateCove *pirateCove = [[PirateCove alloc] initWithName:@"piratecove"];
Battlefield *battlefield = [[Battlefield alloc] initWithName:@"battlefield"];</pre></div></li><li class="listitem">Create<a id="id188" class="indexterm"/> an instance of the scene director and add it to the <code class="literal">Game</code> class, as shown in the following code:<div><pre class="programlisting">SceneDirector *director = [[SceneDirector alloc] init];
[self addChild:director];</pre></div></li><li class="listitem">Add both scenes to the scene director and show the pirate cove scene:<div><pre class="programlisting">[director addScene:pirateCove];
[director addScene:battlefield];

[director showScene:@"battlefield"];</pre></div></li><li class="listitem">Run the example and you will get the following output:<div><img src="img/1509OS_04_10.jpg" alt="Time for action – creating our scene manager setup"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>
<em>What just happened?</em>
</h2></div></div></div><p>In step 1, we opened our Xcode template from where we left off in the previous chapter. In step 2, we created a new group where everything that is related to our game scenes will be put. In step 3, we renamed the newly created group.</p><p>In step 4, we created a new Objective-C class, which is derived from the <code class="literal">Scene</code> class. In the next step, we added the initializer method where we added a log message to see whether the scene has been created.</p><p>In steps 6 and 7, we did the same for the battlefield scene.</p><p>After we switched to the <code class="literal">Game.m</code> file in step 8, we imported all the source files we need, which is the header from the scene director and both scenes we just created.</p><p>We created instances of our scenes and our scene director in step 11. The scene director is a sprite itself, so we need to add it to the <code class="literal">Game</code> class, which also derives from <code class="literal">SPSprite</code>.</p><p>In step 12, we added our scene instances to the scene director, which means that the scenes are now in the display tree. We then called the method in the <code class="literal">SceneDirector</code> instance to show the battlefield scene.</p><p>When we<a id="id189" class="indexterm"/> ran the example, we didn't see anything worthwhile on the screen as the scenes didn't have anything in them, but if we take a look at the console, we see that our two scenes have been successfully created.</p><p>Here is the full source code from this example:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pirate cove scene</p>
</th><th style="text-align: left" valign="bottom">
<p>Battlefield scene</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PirateCove.h</code>
</p>
<p>
</p><div><pre class="programlisting">#import "Scene.h"

@interface PirateCove : Scene

@end</pre></div><p>
</p>
<p>
<code class="literal">PirateCove.m</code>
</p>
<p>
</p><div><pre class="programlisting">#import "PirateCove.h"

@implementation PirateCove

-(id) init
{
  if ((self = [super init])) {
    NSLog(@"Pirate cove scene created");
  }
    
    return self;
}

@end</pre></div><p>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Battlefield.h</code>
</p>
<p>
</p><div><pre class="programlisting">#import "Scene.h"

@interface Battlefield : Scene

@end</pre></div><p>
</p>
<p>
<code class="literal">Battlefield.m</code>
</p>
<p>
</p><div><pre class="programlisting">#import "Battlefield.h"

@implementation Battlefield

-(id) init
{
    if ((self = [super init])) {
        NSLog(@"Battlefield scene created");
    }
    
    return self;
}

@end</pre></div><p>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">Game.m</code> file <a id="id190" class="indexterm"/>contains the following code:</p><div><pre class="programlisting">#import "Game.h" 
#import "SceneDirector.h"
#import "PirateCove.h"
#import "Battlefield.h"

@implementation Game

- (id)init
{
    if ((self = [super init]))
    {
        Sparrow.stage.color = 0xffffff;
    PirateCove *pirateCove = [[PirateCove alloc] initWithName:@"piratecove"];
    Battlefield *battlefield = [[Battlefield alloc] initWithName:@"battlefield"];
        
    SceneDirector *director = [[SceneDirector alloc] init];
    [self addChild:director];
        
    [director addScene:pirateCove];
    [director addScene:battlefield];

    [director showScene:@"battlefield"];
    }
    return self;
}

@end</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Adding images to the battlefield scene</h1></div></div></div><p>Now that the scenes are ready to use, let's add some ships to the battlefield scene.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec60"/>Time for action – adding images to the battlefield scene</h1></div></div></div><p>Let's take<a id="id191" class="indexterm"/> a look <a id="id192" class="indexterm"/>at the following steps in order to add images to the battlefield scene:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Battlefield.m</code> file and import the <code class="literal">Assets</code> header file:<div><pre class="programlisting">#import "Assets.h"</pre></div></li><li class="listitem">Remove the log message and add the background image, as shown in the following code:<div><pre class="programlisting">SPImage *background = [SPImage imageWithTexture:[Assets texture:@"water.png"]];
background.x = (Sparrow.stage.width - background.width) / 2;
background.y = (Sparrow.stage.height - background.height) / 2;</pre></div></li><li class="listitem">Add the pirate ship, as shown in the following code:<div><pre class="programlisting">SPImage *pirateShip = [SPImage imageWithTexture:[Assets texture:@"ship_pirate.png"]];
pirateShip.x = (Sparrow.stage.width - pirateShip.width) / 2;
pirateShip.y = (Sparrow.stage.height - pirateShip.height) / 2;</pre></div></li><li class="listitem">Add <a id="id193" class="indexterm"/>an enemy ship using the following <a id="id194" class="indexterm"/>code:<div><pre class="programlisting">SPImage *ship = [SPImage imageWithTexture:[Assets texture:@"ship.png"]];
ship.x = 100;
ship.y = 100;</pre></div></li><li class="listitem">Add all children to the display tree, as shown in the following code:<div><pre class="programlisting">[self addChild:background];
[self addChild:pirateShip];
[self addChild:ship];</pre></div></li><li class="listitem">Run the example and you will get the following output:<div><img src="img/1509OS_04_11.jpg" alt="Time for action – adding images to the battlefield scene"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>
<em>What just happened?</em>
</h2></div></div></div><p>In step 1, we opened the <code class="literal">Battlefield.m</code> file as this is the file we need if we want to change <a id="id195" class="indexterm"/>anything in the battlefield scene and we imported the <code class="literal">Assets.h</code> file in order to use our asset management system.</p><p>In step 2, we<a id="id196" class="indexterm"/> prepared the background, which should be in the center of the screen. We used our asset management system to get a texture from a specified file which returns either the cached or newly loaded texture, and the texture will then be used to draw <code class="literal">SPImage</code> on the screen.</p><p>In step 3, we added the pirate ship, which should be in the center of the screen as well. In the next step, we added an enemy ship, which should not be too far away from our ship.</p><p>In step 5, we added all our display objects to the display tree, and when we ran the example, we saw two ships on the screen.</p><p>The <code class="literal">Battlefield.m</code> file will contain the following code:</p><div><pre class="programlisting">#import "Battlefield.h"
#import "Assets.h"

@implementation Battlefield

-(id) init
{
    if ((self = [super init])) {
    SPImage *background = [SPImage imageWithTexture:[Assets texture:@"water.png"]];
    background.x = (Sparrow.stage.width - background.width) / 2;
    background.y = (Sparrow.stage.height - background.height) / 2;
        
    SPImage *pirateShip = [SPImage imageWithTexture:[Assets texture:@"ship_pirate.png"]];
    pirateShip.x = (Sparrow.stage.width - pirateShip.width) / 2;
    pirateShip.y = (Sparrow.stage.height - pirateShip.height) / 2;
        
    SPImage *ship = [SPImage imageWithTexture:[Assets texture:@"ship.png"]];
    ship.x = 100;
    ship.y = 100;
        
    [self addChild:background];
    [self addChild:pirateShip];
    [self addChild:ship];
    }
    
    return self;
}

@end</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec61"/>Arranging images in the pirate cove scene</h1></div></div></div><p>Let's move on to the pirate cove scene to give our pirates a nice little home. What we will be doing in this example is adding a house, a tavern, and a weaponsmith to the scene. These will serve as places where we can update our ship later on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec62"/>Time for action – arranging images in the pirate cove scene</h1></div></div></div><p>To add images to the pirate cove scene, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open<a id="id197" class="indexterm"/> <code class="literal">PirateCove.m</code>.</li><li class="listitem">Import<a id="id198" class="indexterm"/> the <code class="literal">Assets</code> header file using the following line of code:<div><pre class="programlisting">#import "Assets.h"</pre></div></li><li class="listitem">Remove the log message and add the background image, as shown in the following code:<div><pre class="programlisting">SPImage *background = [SPImage imageWithTexture:[Assets   texture:@"cove.png"]];
background.x = (Sparrow.stage.width - background.width) / 2;
background.y = (Sparrow.stage.height - background.height) / 2;</pre></div></li><li class="listitem">Add our pirate ship, as shown in the following code:<div><pre class="programlisting">SPImage *pirateShip = [SPImage imageWithTexture:[Assets   texture:@"ship_pirate.png"]];
pirateShip.x = Sparrow.stage.width - pirateShip.width - 120;
pirateShip.y = Sparrow.stage.height - pirateShip.height - 10;</pre></div></li><li class="listitem">Add a house, as shown in the following code:<div><pre class="programlisting">SPImage *house = [SPImage imageWithTexture:[Assets   texture:@"house.png"]];
house.x = 100;
house.y = 100;</pre></div></li><li class="listitem">Add a tavern, as shown in the following code:<div><pre class="programlisting">SPImage *tavern = [SPImage imageWithTexture:[Assets   texture:@"tavern.png"]];
tavern.x = 220;
tavern.y = 40;</pre></div></li><li class="listitem">Add a weaponsmith, as shown in the following code:<div><pre class="programlisting">SPImage *weaponsmith = [SPImage imageWithTexture:[Assets   texture:@"weaponsmith.png"]];
weaponsmith.x = 350;
weaponsmith.y = 130;</pre></div></li><li class="listitem">Register<a id="id199" class="indexterm"/> all images to the display<a id="id200" class="indexterm"/> tree:<div><pre class="programlisting">[self addChild:background];
[self addChild:pirateShip];
[self addChild:house];
[self addChild:tavern];
[self addChild:weaponsmith];</pre></div></li><li class="listitem">Go to the <code class="literal">Game.m</code> file and change the default scene to the pirate cove, as shown in the following code:<div><pre class="programlisting">[director showScene:@"piratecove"];</pre></div></li><li class="listitem">Run the example and you will get the following output:<div><img src="img/1509OS_04_12.jpg" alt="Time for action – arranging images in the pirate cove scene"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>
<em>What just happened?</em>
</h2></div></div></div><p>Most of the steps are quite similar to the battlefield scene, so we don't need to explain every step in detail.</p><p>In step 1, we<a id="id201" class="indexterm"/> opened the <code class="literal">PirateCove.m</code> file where everything with regard to the pirate cove should be. We needed the asset management<a id="id202" class="indexterm"/> system here as well, so we imported it in step 2.</p><p>In step 3, we loaded the fitting image, which should be in the center of the screen. In steps 4 to 7, we loaded different entities we wanted to display on the screen, such as the pirate ship and the house. We positioned them more or less randomly on the screen, but left enough space between them so that it won't leave a cluttered impression.</p><p>In step 8, we added all of our display objects to the screen. Remember that the order matters. If we were to add the background image last, we will only see the background and nothing else.</p><p>We set the scene director to load the pirate cove scene instead of the battlefield scene, and when we ran the example, we saw the pirate cove on the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Pop quiz</h2></div></div></div><p>Q1. What do we need to actively take care of when developing a universal application?</p><div><ol class="orderedlist arabic"><li class="listitem">Battery power</li><li class="listitem">Screen size and texture size limit</li><li class="listitem">GPU memory</li></ol></div><p>Q2. If we want to display an image with the suffix <code class="literal">~ipad</code>, on which device(s) will it load?</p><div><ol class="orderedlist arabic"><li class="listitem">Non-Retina iPad</li><li class="listitem">Retina iPhone</li><li class="listitem">Retina iPad</li></ol></div><p>Q3. What will the dimensions be of an image of 256 x 256 pixels on, Retina iPhone in the iOS point coordinate system?</p><div><ol class="orderedlist arabic"><li class="listitem">128 x 128 pt</li><li class="listitem">256 x 256 pt</li><li class="listitem">512 x 512 pt</li></ol></div><p>Q4. Which suffix is required to load images on, Retina iPad if the <code class="literal">doubleOnPad</code> parameter is set to <code class="literal">YES</code>?</p><div><ol class="orderedlist arabic"><li class="listitem">@2x</li><li class="listitem">@3x</li><li class="listitem">@4x</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, we learned about cross-platform device compatibility between iPad and iPhone devices.</p><p>Specifically, we covered which filename suffix we need to identify, which file to load for which device, how the coordinate system in points works, and texture size limits when loading images.</p><p>We also set up the bare bone, of our game where we loaded the images for different kinds of devices utilizing our asset and scene managers.</p><p>Now that the scenes of our game are available and we have put some images on the screen, we're ready to beautify our game—which is the topic of the next chapter.</p></div></body></html>