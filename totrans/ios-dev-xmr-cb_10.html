<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Location Services and Maps</h1></div></div></div><p>In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determining location</li><li class="listitem" style="list-style-type: disc">Determining heading</li><li class="listitem" style="list-style-type: disc">Using region monitoring</li><li class="listitem" style="list-style-type: disc">Using a significant-change location service</li><li class="listitem" style="list-style-type: disc">Location services in the background</li><li class="listitem" style="list-style-type: disc">Displaying maps</li><li class="listitem" style="list-style-type: disc">Geocoding</li><li class="listitem" style="list-style-type: disc">Adding map annotations</li><li class="listitem" style="list-style-type: disc">Adding map overlays</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Introduction</h1></div></div></div><p>Today's smartphones and hand-held devices are equipped with high-accuracy Global Positioning System (GPS) hardware. The GPS hardware receives location information from a constellation of satellites. Apart from the satellites, iOS devices take advantage of the cellular and Wi-Fi networks to<a id="id572" class="indexterm"/> provide location information to the user.</p><p>In this chapter, we will discuss how to use the appropriate frameworks to take advantage of the location services of the device. Furthermore, we will learn how to display maps and annotate them. Specifically, we will focus on the following subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Location services</strong>: Here, the services available on a device for providing location<a id="id573" class="indexterm"/> information will be discussed. These services are as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Standard location service</strong>: This <a id="id574" class="indexterm"/>location<a id="id575" class="indexterm"/> service depends fully on the device's GPS module and provides location <a id="id576" class="indexterm"/>data of the highest <a id="id577" class="indexterm"/>accuracy</li><li class="listitem" style="list-style-type: disc"><strong>Region monitoring service</strong>: This <a id="id578" class="indexterm"/>location<a id="id579" class="indexterm"/> service monitors boundary crossings</li><li class="listitem" style="list-style-type: disc"><strong>Significant-change location service</strong>: This service monitors significant <a id="id580" class="indexterm"/>changes <a id="id581" class="indexterm"/>in the location of the device</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">CLLocationManager</code>: This <a id="id582" class="indexterm"/>class allows us to use the location services</li><li class="listitem" style="list-style-type: disc"><code class="literal">Compass</code>: This <a id="id583" class="indexterm"/>class shows how to use the built-in compass</li><li class="listitem" style="list-style-type: disc"><code class="literal">MKMapView</code>: This <a id="id584" class="indexterm"/>view is used to display maps</li><li class="listitem" style="list-style-type: disc"><code class="literal">CLGeocoder</code>: This <a id="id585" class="indexterm"/>class provides geocoding features</li><li class="listitem" style="list-style-type: disc"><code class="literal">MKAnnotation</code>: This <a id="id586" class="indexterm"/>class allows us to add annotations on maps</li><li class="listitem" style="list-style-type: disc"><code class="literal">MKOverlay</code>: This <a id="id587" class="indexterm"/>class allows us to add overlays on maps</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Determining location</h1></div></div></div><p>We will <a id="id588" class="indexterm"/>now learn how to receive the location <a id="id589" class="indexterm"/>information from the built-in GPS hardware.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec343"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">LocationApp</code>. Add two buttons and a label on the view of the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec344"/>How to do it...</h2></div></div></div><p>Perform the following steps to receive the location of the device:</p><div><ol class="orderedlist arabic"><li class="listitem">To retrieve location information from the built-in GPS hardware, we need to use the Core Location framework. It is exposed through the <code class="literal">MonoTouch.CoreLocation</code> namespace as follows:<div><pre class="programlisting">using MonoTouch.CoreLocation;</pre></div></li><li class="listitem">Add <a id="id590" class="indexterm"/>the following code in the <a id="id591" class="indexterm"/><code class="literal">LocationAppViewController</code> class:<div><pre class="programlisting">private CLLocationManager locationManager;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.locationManager = new CLLocationManager();
  this.locationManager.LocationsUpdated += LocationManager_LocationsUpdated;
  this.locationManager.Failed += this.LocationManager_Failed;

  this.btnStart.TouchUpInside += delegate {
    this.lblOutput.Text = "Determining location...";
    this.locationManager.StartUpdatingLocation();
  } ;
  this.btnStop.TouchUpInside += delegate {
    this.locationManager.StopUpdatingLocation();
    this.lblOutput.Text = "Location update stopped.";
  } ;
}
private void LocationManager_LocationsUpdated (object sender, CLLocationsUpdatedEventArgs e)
{
  CLLocation location = e.Locations[0];
  double latitude = Math.Round(location.Coordinate.Latitude, 4);
  double longitude = Math.Round(location.Coordinate.Longitude, 4);
  double accuracy = Math.Round(location.HorizontalAccuracy, 0);
  this.lblOutput.Text = string.Format("Latitude: {0}\nLongitude: {1},\nAccuracy: {2}m", latitude, longitude, accuracy);
}
private void LocationManager_Failed (object sender, NSErrorEventArgs e)
{
  this.lblOutput.Text = string.Format("Location update failed! Error message: {0}", e.Error.LocalizedDescription);
}</pre></div></li><li class="listitem">Compile and run the app on the device. Tap the start button to view your location coordinates on the screen.</li></ol></div><div><div><h3 class="title"><a id="note53"/>Note</h3><p>Projects <a id="id592" class="indexterm"/>using the Core Location framework to determine the current position of a device can work on the<a id="id593" class="indexterm"/> simulator. By navigating to the <strong>Debug</strong> | <strong>Location</strong> menu of the simulator, we can customize the location that the device will be using.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec345"/>How it works...</h2></div></div></div><p>The location data that the GPS module provides can be accessed through the <code class="literal">CLLocationManager</code> class. After initializing an instance of the class, we need to subscribe to its <code class="literal">LocationsUpdated</code> event as follows:</p><div><pre class="programlisting">this.locationManager = new CLLocationManager();
this.locationManager.LocationsUpdated += LocationManager_LocationsUpdated;</pre></div><p>Location data will become available, as they are issued through this event. It is also a good practice to subscribe to the <code class="literal">Failed</code> event as follows:</p><div><pre class="programlisting">  this.locationManager.Failed += this.LocationManager_Failed;</pre></div><p>When the location manager first requests for location updates, the user is informed through a system-specific alert, which is similar to the one shown in the following screenshot:</p><div><img src="img/8924OT_10_01.jpg" alt="How it works..."/></div><p>This alert basically asks for user permission to allow the app to retrieve location data. If <a id="id594" class="indexterm"/>the user denies this request, the <code class="literal">Failed</code> event <a id="id595" class="indexterm"/>will be triggered with the appropriate message. Future location requests will not trigger the permission alert, and the user will have to enable location services for the app through the device's settings, so we need to handle this scenario accordingly.</p><p>After subscribing to the appropriate events, we request the delivery of location updates through the <code class="literal">StartUpdatingLocation</code> method as follows:</p><div><pre class="programlisting">this.locationManager.StartUpdatingLocation();</pre></div><p>To stop receiving location updates, we call the <code class="literal">StopUpdatingLocation</code> method as follows:</p><div><pre class="programlisting">this.locationManager.StopUpdatingLocation();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec346"/>There's more...</h2></div></div></div><p>The <code class="literal">LocationsUpdated</code> event accepts the delegates of the <code class="literal">EventHandler&lt;CLLocationsUpdatedEventArgs&gt;</code> type. The <code class="literal">CLLocationsUpdatedEventArgs</code> parameter contains one property that returns an array of <code class="literal">CLLocation</code> objects. The last item in the array contains the most recent location data that were retrieved from location services. The array will always contain at least one <code class="literal">CLLocation</code> item.</p><p>The <a id="id596" class="indexterm"/>coordinates are returned as values of the <a id="id597" class="indexterm"/>
<code class="literal">double</code> type and represent the coordinates of the position in degrees as follows:</p><div><pre class="programlisting">CLLocation location = e.Locations[0];
double latitude = Math.Round(location.Coordinate.Latitude, 4);
double longitude = Math.Round(location.Coordinate.Longitude, 4);
double accuracy = Math.Round(location.HorizontalAccuracy, 0);</pre></div><p>Negative latitude values indicate south coordinates and positive values indicate north coordinates. Negative longitude values indicate west coordinates, while positive longitude values indicate east coordinates.</p><p>The <code class="literal">HorizontalAccuracy</code> property returns the accuracy of the GPS fix in meters. For example, a value of 17 m indicates that the location is determined within a circle of a diameter 17 m. Lower values indicate better accuracy.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec83"/>GPS accuracy</h3></div></div></div><p>There is always a margin of error in location data, which is independent of GPS hardware, and<a id="id598" class="indexterm"/> there are variable factors that define it, such as the surrounding buildings and various obstacles. You will notice that the <code class="literal">HorizontalAccuracy</code> property will return lower values when the device is outdoors, while higher values will be returned when we use the GPS indoors or on a city street with tall buildings.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec84"/>Location services availability</h3></div></div></div><p>Not all <a id="id599" class="indexterm"/>devices are equipped with location services hardware. Furthermore, even if a device is equipped with the appropriate hardware, location services could be disabled by the user.</p><p>To determine if the location services are available or enabled on the device, we read the return value of the <code class="literal">CLLocationManager.LocationServicesEnabled</code> static property before <a id="id600" class="indexterm"/>initializing the location manager object as follows:</p><div><pre class="programlisting">if (CLLocationManager.LocationServicesEnabled) {
  // Initialize the location manager
  //...
}</pre></div><p>Furthermore, we can check for the authorization status of location services through the <code class="literal">CLLocationManager.Status</code> property as follows:</p><div><pre class="programlisting">if (CLLocationManager.Status == CLAuthorizationStatus.Authorized) {
  //..
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec85"/>Location services usage indicator</h3></div></div></div><p>When any<a id="id601" class="indexterm"/> type of location service is used, the location services icon appears on the right-hand side of the status bar next to the battery indicator, as shown in the following screenshot:</p><div><img src="img/8924OT_10_02.jpg" alt="Location services usage indicator"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec347"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Determining heading</em> and <em>Location services in the background</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Determining heading</h1></div></div></div><p>In this <a id="id602" class="indexterm"/>recipe, we will learn how to use the <a id="id603" class="indexterm"/>built-in compass to determine <a id="id604" class="indexterm"/>the heading of the device.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec348"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">HeadingApp</code>. Just as you did in the previous recipe, add two buttons and a label on the view of the controller.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>The<a id="id605" class="indexterm"/> project in this recipe cannot<a id="id606" class="indexterm"/> be tested on the simulator. A device with compass hardware (magnetometer) is required.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec349"/>How to do it...</h2></div></div></div><p>Perform the following steps to determine the heading of the device:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following code in the <code class="literal">HeadingAppViewController</code> class:<div><pre class="programlisting">private CLLocationManager locationManager;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  // Perform any additional setup after loading the view, typically from a nib.
  this.locationManager = new CLLocationManager();
  this.locationManager.UpdatedHeading += LocationManager_UpdatedHeading;
  this.locationManager.Failed += (sender, e) =&gt; Console.WriteLine("Failed! {0}", e.Error.LocalizedDescription);

  this.btnStart.TouchUpInside += delegate {
    this.lblOutput.Text = "Starting updating heading...";
    this.locationManager.StartUpdatingHeading();
  } ;
  this.btnStop.TouchUpInside += delegate {
    this.locationManager.StopUpdatingHeading();
    this.lblOutput.Text = "Stopped updating heading.";
  };
}
private void LocationManager_UpdatedHeading (object sender, CLHeadingUpdatedEventArgs e)
{
  this.lblOutput.Text = string.Format("Magnetic heading: {0}", Math.Round(e.NewHeading.MagneticHeading, 1));
}</pre></div></li><li class="listitem">Compile and run the app on the device. Tap the start button and rotate the device to view the different heading values.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec350"/>How it works...</h2></div></div></div><p>To retrieve the heading information, we first need to subscribe to the location manager's <code class="literal">UpdatedHeading</code> event as follows:</p><div><pre class="programlisting">this.locationManager.UpdatedHeading += this.LocationManager_UpdatedHeading;</pre></div><p>To <a id="id607" class="indexterm"/>initiate the delivery of heading information, we<a id="id608" class="indexterm"/> call the <code class="literal">StartUpdatingHeading</code> method as follows:</p><div><pre class="programlisting">this.locationManager.StartUpdatingHeading();</pre></div><p>Inside the <code class="literal">UpdatedHeading</code> event handler, we retrieve the heading information through the <code class="literal">MagneticHeading</code> property of the <code class="literal">CLHeading</code> object exposed through the event arguments' <code class="literal">NewHeading</code> property as follows:</p><div><pre class="programlisting">this.lblOutput.Text = string.Format("Magnetic heading: {0}", Math.Round(e.NewHeading.MagneticHeading, 1));</pre></div><p>To stop retrieving heading updates, we call the <code class="literal">StopUpdatingHeading</code> method with the help of the following code:</p><div><pre class="programlisting">this.locationManager.StopUpdatingHeading();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec351"/>There's more...</h2></div></div></div><p>The heading is measured in degrees. The values for the four points of the horizon that can be viewed on a<a id="id609" class="indexterm"/> simple compass are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>0 or 360 degrees</strong>: The magnetometer will return values of up to 359.99 degrees and then return 0 when the device is heading North.</li><li class="listitem" style="list-style-type: disc"><strong>90 degrees</strong>: The device is heading East</li><li class="listitem" style="list-style-type: disc"><strong>180 degrees</strong>: The device is heading South</li><li class="listitem" style="list-style-type: disc"><strong>270 degrees</strong>: The device is heading West</li></ul></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec86"/>Magnetic vs true heading</h3></div></div></div><p>Magnetic<a id="id610" class="indexterm"/> heading <a id="id611" class="indexterm"/>is the heading<a id="id612" class="indexterm"/> that<a id="id613" class="indexterm"/> is <a id="id614" class="indexterm"/>based <a id="id615" class="indexterm"/>on what a normal compass will show as North. True heading is the true direction of North based on the actual position of the earth's North Pole. There is a slight difference between the two, which varies according to the earth's magnetic-field fluctuations, and it is usually about 2 degrees.</p><p>The <code class="literal">CLHeading</code> class provides both readings through the <code class="literal">MagneticHeading</code> and <code class="literal">TrueHeading</code> properties. This provides a significant help to developers, as calculating the<a id="id616" class="indexterm"/> difference<a id="id617" class="indexterm"/> between the two <a id="id618" class="indexterm"/>readings <a id="id619" class="indexterm"/>requires either expensive equipment or very difficult calculations based on the time of year and other factors.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec87"/>Compass availability</h3></div></div></div><p>The magnetometer, a module that can determine the heading in degrees and provides compass <a id="id620" class="indexterm"/>functionality to devices, is not available on all devices. To check if a device can provide heading information, retrieve the value from the <code class="literal">CLLocationManager.HeadingAvailable</code> static property as follows:</p><div><pre class="programlisting">if (CLLocationManager.HeadingAvailable) {
  // Start updating heading
  //...
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec352"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Determining location</em> and <em>Location services in the background</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Using region monitoring</h1></div></div></div><p>In this recipe, we will learn how to use GPS to respond to region-specific position changes.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec353"/>Getting ready</h2></div></div></div><p>Create a <a id="id621" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">RegionApp</code>. Add two buttons and a label on the view of the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec354"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create two fields in the <code class="literal">RegionAppViewController</code> class as follows:<div><pre class="programlisting">private CLLocationManager locationManager;
private CLCircularRegion region;</pre></div></li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method, initialize the <code class="literal">RegionAppViewController</code> class, and subscribe to the <code class="literal">LocationsUpdated</code>, <code class="literal">RegionEntered</code>, and <code class="literal">RegionLeft</code> events as follows:<div><pre class="programlisting">this.locationManager.RegionEntered += this.LocationManager_RegionEntered;
this.locationManager.RegionLeft += this.LocationManager_RegionLeft;
this.locationManager.UpdatedLocation += this.LocationManager_UpdatedLocation;</pre></div></li><li class="listitem">Enter <a id="id622" class="indexterm"/>the following event handlers in the class:<div><pre class="programlisting">private void LocationManager_LocationsUpdated (object sender, CLLocationUpdatedEventArgs e)
{
  CLLocation location = e.Locations[0];
  if (location.HorizontalAccuracy &lt; 100)
  {
    this.region = new CLCircularRegion(location.Coordinate, 100, "Home");
    this.locationManager.StartMonitoring(this.region);
    this.locationManager.StopUpdatingLocation();
  }
}
private void LocationManager_RegionLeft (object sender, CLRegionEventArgs e)
{
  this.lblOutput.Text = string.Format("{0} region left.", e.Region.Identifier);
}
private void LocationManager_RegionEntered (object sender, CLRegionEventArgs e)
{
  this.lblOutput.Text = string.Format("{0} region entered.", e.Region.Identifier);
}</pre></div></li><li class="listitem">In the start button's <code class="literal">TouchUpInside</code> handler, call the <code class="literal">StartUpdatingLocation</code> method using the following code:<div><pre class="programlisting">this.locationManager.StartUpdatingLocation();</pre></div></li><li class="listitem">In the stop button's <code class="literal">TouchUpInside</code> handler, call the <code class="literal">StopMonitoring</code> method using the following code:<div><pre class="programlisting">this.locationManager.StopMonitoring(this.region);</pre></div></li><li class="listitem">Compile and run the app on the simulator. Navigate to <strong>Debug</strong> | <strong>Location</strong> | <strong>Freeway drive</strong> on the simulator's menu and tap the <strong>Start region monitoring</strong> button.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec355"/>How it works...</h2></div></div></div><p>Region monitoring is a feature that monitors boundary crossings. When a boundary of a specific <a id="id623" class="indexterm"/>region is crossed, the <code class="literal">CLLocationManager</code> object issues the appropriate events as follows:</p><div><pre class="programlisting">this.locationManager.RegionEntered += this.LocationManager_RegionEntered;
this.locationManager.RegionLeft += this.LocationManager_RegionLeft;</pre></div><p>In this example, we define the region based on the current location; hence, we also subscribe to the <code class="literal">LocationsUpdated</code> event.</p><p>When the app starts receiving location updates, it first checks for location accuracy using the following code:</p><div><pre class="programlisting">if (location.HorizontalAccuracy &lt; 100)</pre></div><p>If the desired accuracy is achieved (&lt;100 m, modify at your discretion), we initialize the <code class="literal">CLCircularRegion</code> object using the following line of code:</p><div><pre class="programlisting">this.region = new CLRegion(e.NewLocation.Coordinate, 100, "Home");</pre></div><p>The <code class="literal">CLCircularRegion</code> class is used to define circular regions and inherits the <code class="literal">CLRegion</code> class. Here, in the first parameter, we create the region to be monitored based on our current location. The second parameter declares the radius around the coordinate, in meters, defining the region's boundary. The third parameter is a string identifier we want to assign to the region.</p><p>To start monitoring the region, we call the <code class="literal">StartMonitoring</code> method using the following line of code:</p><div><pre class="programlisting">this.locationManager.StartMonitoring(this.region);</pre></div><p>When region monitoring has started, the appropriate events will be triggered when the device enters or leaves the region.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec356"/>There's more...</h2></div></div></div><p>Region monitoring is a very useful feature. For example, an app could provide specific information to users based on their proximity to various areas. Furthermore, it can notify of boundary crossings while the app is in the background.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec88"/>Region monitoring availability</h3></div></div></div><p>To check if a <a id="id624" class="indexterm"/>device supports region monitoring, call the <code class="literal">CLLocationManager.IsMonitoringAvailable</code> static method passing the type of the <code class="literal">CLRegion</code> object we want to use as follows:</p><div><pre class="programlisting">if (CLLocationManager.IsMonitoringAvailable(typeof(CLCircularRegion)) {
  // Start monitoring a region
  //...
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec357"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using a significant-change location service</em> and <em>Location services in the background</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Using a significant-change location service</h1></div></div></div><p>In this chapter, we will learn how to use the significant location change monitoring feature.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec358"/>Getting ready</h2></div></div></div><p>Create a <a id="id625" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">SLCApp</code>. Add a label and two buttons on the view of the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec359"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following <code class="literal">ViewDidLoad</code> method in the <code class="literal">SLCAppViewController</code> class:<div><pre class="programlisting">private CLLocationManager locationManager;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  
  // Perform any additional setup after loading the view, typically from a nib.
  this.locationManager = new CLLocationManager();
  this.locationManager.LocationsUpdated += LocationManager_LocationsUpdated;
  this.btnStart.TouchUpInside += (s, e) =&gt; {
    this.lblOutput.Text = "Starting monitoring significant location changes...";
    this.locationManager.StartMonitoringSignificantLocationChanges();
  } ;
  this.btnStop.TouchUpInside += (s, e) =&gt; {
    this.locationManager.StopMonitoringSignificantLocationChanges();
    this.lblOutput.Text = "Stopped monitoring significant location changes.";
  } ;
}</pre></div></li><li class="listitem">Add<a id="id626" class="indexterm"/> the following method:<div><pre class="programlisting">private void LocationManager_LocationsUpdated (object sender, CLLocationsUpdatedEventArgs e)
{
  CLLocation location = e.Locations[0];
  double latitude = Math.Round(location.Coordinate.Latitude, 4);
  double longitude = Math.Round(location.Coordinate.Longitude, 4);
  double accuracy = Math.Round(location.HorizontalAccuracy, 0);
  this.lblOutput.Text = string.Format("Latitude: {0}\nLongitude: {1}\nAccuracy: {2}", latitude, longitude, accuracy);
}</pre></div></li><li class="listitem">In iOS Simulator, navigate to <strong>Debug</strong> | <strong>Location</strong> | <strong>Freeway drive</strong> on the menu.</li><li class="listitem">Compile and run the app on the simulator. Tap the <strong>Start monitoring</strong> button to start monitoring for significant location changes.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec360"/>How it works...</h2></div></div></div><p>The significant-change location service monitors significant location changes and provides location information when these changes occur. In terms of power consumption, it is the less-demanding location service. It uses the device's cellular radio transceiver to determine the user's location. Only devices equipped with a cellular radio transceiver can use this service.</p><p>The code for using the significant-change location service is similar to the code of the standard location services. The only differences are the methods of starting and stopping the service. To start the service, we call the <code class="literal">StartMonitoringSignificantLocationChanges</code> method using the following line of code:</p><div><pre class="programlisting">this.locationManager.StartMonitoringSignificantLocationChanges();</pre></div><p>Location updates are issued through the <code class="literal">LocationsUpdated</code> event handler, which is the same event we use for the standard location service as follows:</p><div><pre class="programlisting">this.locationManager.LocationsUpdated += LocationManager_LocationsUpdated;
//...
private void LocationManager_LocationsUpdated (object sender, CLLocationUpdatedEventArgs e)
{
//...
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec361"/>There's more...</h2></div></div></div><p>The <a id="id627" class="indexterm"/>significant-change location service can report location changes while in the background, waking up the app. It is very useful for apps that need to make use of location services, with a lower accuracy than that of the standard location services.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec89"/>Significant-change location service availability</h3></div></div></div><p>To determine if a device is capable of using the significant-change location service, retrieve <a id="id628" class="indexterm"/>the value of the <code class="literal">SignificantLocationChangeMonitoringAvailable</code> static property as follows:</p><div><pre class="programlisting">if (CLLocationManager.SignificantLocationChangeMonitoringAvailable) {
  // Start monitoring for significant location changes.
  //...
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec362"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using region monitoring</em> and <em>Location services in the background</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Location services in the background</h1></div></div></div><p>In this <a id="id629" class="indexterm"/>recipe, we will discuss how to use location services while the app is in the background.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec363"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">BackgroundLocationApp</code>. Just like we did in the previous recipes, add a label and two buttons on the view of the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec364"/>How to do it...</h2></div></div></div><p>Perform<a id="id630" class="indexterm"/> the following steps to use the location services when the app is in the background:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Solution</strong> pane, double-click on the <code class="literal">Info.plist</code> file to open it. Under the <strong>Source</strong> tab, add a new key by clicking on the plus (<strong>+</strong>) sign or by right-clicking and selecting <strong>New Key</strong> from the context menu.</li><li class="listitem">Select <strong>Required background modes</strong> from the drop-down list or just type <code class="literal">UIBackgroundModes</code> in the field.</li><li class="listitem">Expand the key and right-click on the empty item below it. Click on <strong>New Key</strong> in the context menu. In its <strong>Value</strong> field, select <strong>App registers for location updates</strong>, or type the word <code class="literal">location</code>. Save the document. When done, you should have something similar to the following screenshot:<div><img src="img/8924OT_10_03.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">BackgroundLocationAppViewController</code> class, enter the same code as the one used in the <em>Determining location</em> recipe of this chapter.</li><li class="listitem">At the bottom of the <code class="literal">LocationManager_LocationsUpdated</code> method, add the following line:<div><pre class="programlisting">Console.WriteLine("{0}:\n\t{1} ", DateTime.Now, this.lblOutput.Text);</pre></div></li><li class="listitem">Compile <a id="id631" class="indexterm"/>and run the app on the simulator. Tap the <strong>Start</strong> button to start receiving location updates.</li><li class="listitem">With the simulator window active, press <em>Cmd</em> + <em>Shift</em> + <em>H</em>. This key combination simulates pressing the home button on a device and will move the app to the background. Watch Xamarin Studio's <strong>Application Output</strong> pad continuing the display of location updates.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec365"/>How it works...</h2></div></div></div><p>To receive location updates while the app is in the background, we need to set the <code class="literal">location</code> value to the <code class="literal">UIBackgroundModes</code> key in the <code class="literal">Info.plist</code> file. This basically makes sure that the app has the appropriate permission to receive location updates while it is in the background and that it will not get suspended.</p><p>If you open the <code class="literal">Info.plist</code> file in a text editor, this is what has been added:</p><div><pre class="programlisting">&lt;key&gt;UIBackgroundModes&lt;/key&gt;
  &lt;array&gt;
    &lt;string&gt;location&lt;/string&gt;
  &lt;/array&gt;
&lt;/key&gt;</pre></div><p>To make sure that the app is receiving location updates, check the status bar. The location services icon should be displayed even if the app is in the background.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec366"/>There's more...</h2></div></div></div><p>Setting the <code class="literal">UIBackgroundModes</code> key for location services is only needed for the standard location service. Both the region monitoring and significant-change location services support delivery of location updates while the app is in the background, by default. While one of these location services has started updating location data, the app can even be terminated. When a location update is received, the app is started or woken up from the suspended state and is given a limited amount of time to execute code.</p><p>To determine if an app has been started by one of these two location services, check the <code class="literal">options</code> parameter of the <code class="literal">FinishedLaunching</code> method in the <code class="literal">AppDelegate</code> class as follows:</p><div><pre class="programlisting">if (null != options)
{
<strong>  if (options.ContainsKey (UIApplication.LaunchOptionsLocationKey))</strong>
  {
    Console.WriteLine ("Woken from location service!");
    CLLocationManager locationManager = new CLLocationManager();
    locationManager.UpdatedLocation += this.LocationUpdatedHandler;
    locationManager.StartMonitoringSignificantLocationChanges();
  }
}</pre></div><p>The <code class="literal">options</code> parameter is of the <code class="literal">NSDictionary</code> type. If this dictionary contains <code class="literal">UIApplication.LaunchOptionsLocationKey</code>, then the app has been started or woken up from the suspended state due to a location service. When this is the case, we need to call the <code class="literal">StartMonitoringSignificantLocationChanges</code> method on a <code class="literal">CLLocationManager</code> instance again, to retrieve location data.</p><p>The<a id="id632" class="indexterm"/> same applies to region-monitoring location service. Note that if we use either of these two location services, but our app does not support the background delivery of a location's events, we have to make sure that we stop monitoring location updates when they are no longer needed. If we do not, the location services will continue to run, causing significant battery drain.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec90"/>Restricting to supported hardware</h3></div></div></div><p>If our app's features are fully dependent on location services and cannot operate correctly on devices <a id="id633" class="indexterm"/>that do not support them, we have to add the <code class="literal">UIRequiredDeviceCapabilities</code> key in the <code class="literal">Info.plist</code> file with the <code class="literal">location-services</code> value.</p><p>Furthermore, when the app requires the use of the standard location service, which uses the GPS hardware, we need to add the <code class="literal">gps</code> value to the <code class="literal">UIRequiredDeviceCapabilities</code> key. This way, we make sure that the app will not be available through the App Store to the devices that are not equipped with the appropriate hardware.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec91"/>UI updates while in the background</h3></div></div></div><p>In this recipe, we deliberately set a value to the label's <strong>Text</strong> property while the app is in the background. However, updating the UI while the app is in the background should be avoided, because <a id="id634" class="indexterm"/>the iOS might terminate our app if there are too many updates. Furthermore, UI updates that occur in the background are basically being queued for when the app returns to the foreground and take place instantaneously when this happens. This may result in unexpected behavior in our app.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec367"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Determining location</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Creating an iOS project with Xamarin Studio</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. Development Tools">Chapter 1</a>, <em>Development Tools</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Displaying maps</h1></div></div></div><p>In this recipe, we will learn how to display maps in our app.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec368"/>Getting ready</h2></div></div></div><p>Create a <a id="id635" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">MapDisplayApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec369"/>How to do it...</h2></div></div></div><p>Perform the following steps to display maps in the app:</p><div><ol class="orderedlist arabic"><li class="listitem">Add <code class="literal">MKMapView</code> on the controller. The following screenshot shows the symbol for <code class="literal">MKMapView</code> in Xcode's object library:<div><img src="img/8924OT_10_04.jpg" alt="How to do it..."/></div></li><li class="listitem">Add the following <code class="literal">using</code> directives in the <code class="literal">MapDisplayAppViewController.cs</code> file:<div><pre class="programlisting">using MonoTouch.MapKit;
using MonoTouch.CoreLocation;</pre></div></li><li class="listitem">Enter the following code in the <code class="literal">MapDisplayAppViewController</code> class:<div><pre class="programlisting">public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.mapView.ShowsUserLocation = true;
  this.mapView.RegionChanged += this.MapView_RegionChanged;
}
private void MapView_RegionChanged (object sender, MKMapViewChangeEventArgs e)
{
  if (this.mapView.UserLocation.Location != null)
  {
    CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
    Console.WriteLine("Current coordinates: LAT: {0}, LON: {1}", mapCoordinate.Latitude, mapCoordinate.Longitude);
  }
}</pre></div></li><li class="listitem">Compile<a id="id636" class="indexterm"/> and run the app either on the simulator or on the device.</li><li class="listitem">Zoom or pan the map by pinching on the screen (press <em>Option</em> and click-and-drag on the simulator) to output the current location in the <strong>Application Output</strong> pad.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec370"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.MapKit</code> namespace wraps all the objects contained in the MapKit framework. The MapKit framework uses Apple maps to display maps.</p><p>
<code class="literal">MKMapView</code> is the default iOS view that displays maps. It is especially designed for this purpose, and it should not be subclassed.</p><p>To display the user's location on the map, we set its <code class="literal">ShowsUserLocation</code> property to <code class="literal">true</code> using the following line of code:</p><div><pre class="programlisting">this.mapView.ShowsUserLocation = true;</pre></div><p>This activates the standard location service to start receiving location updates and handing them over to the <code class="literal">MKMapView</code> object internally.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>When <code class="literal">MKMapView</code> is first shown in an app, the system will prompt the user for the permission to use location services, just as if we were trying to use location services directly.</p></div></div><p>To determine when the user zooms or pans the map, we subscribe to the <code class="literal">RegionChanged</code> event using the following code:</p><div><pre class="programlisting">this.mapView.RegionChanged += this.MapView_RegionChanged;</pre></div><p>Inside the <a id="id637" class="indexterm"/>event handler, we retrieve the current location through the <code class="literal">UserLocation</code> property as follows:</p><div><pre class="programlisting">if (this.mapView.UserLocation.Location != null)
{
  CLLocationCoordinate2D mapCoordinate = this.mapView.UserLocation.Location.Coordinate;
  Console.WriteLine("Current coordinates: LAT: {0}, LON: {1}", mapCoordinate.Latitude, mapCoordinate.Longitude);
}</pre></div><p>If the <code class="literal">ShowsUserLocation</code> property is set to <code class="literal">false</code>, the location services will not be activated, and the <code class="literal">UserLocation.Location</code> property will return <code class="literal">null</code>. It will also return <code class="literal">null</code> when the app runs for the first time, as it will ask the user for permission to use location services. However, a map will be displayed as long as the device or simulator has an active Internet connection.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec371"/>There's more...</h2></div></div></div><p>We can set the center coordinate of the map to be displayed with the <code class="literal">SetCenterCoordinate</code> method as follows:</p><div><pre class="programlisting">CLLocationCoordinate2D mapCoordinates = new CLLocationCoordinate2D(0, 0);
this.mapView.SetCenterCoordinate(mapCoordinates, true);</pre></div><p>The first parameter is the map coordinates where we want the map to be centered at, represented by an object of the <code class="literal">CLLocationCoordinate2D</code> type. The second parameter declares if we want the centering of the map to be animated or not.</p><p>Apart from centering the map, we can also set its zoom level. We do this through the <code class="literal">SetRegion</code> method as follows:</p><div><pre class="programlisting">this.mapView.SetRegion(MKCoordinateRegion.FromDistance(mapCoordinates, 1000, 1000), true);</pre></div><p>The first parameter is of the <code class="literal">MKCoordinateRegion</code> type. Here, its <code class="literal">FromDistance</code> static method is used to create an instance. Its first parameter is the coordinate of the region's center, while the next two parameters represent the horizontal and vertical span of the map to display, in meters. It basically means that the region represented by this <code class="literal">MKCoordinateRegion</code> instance will have <code class="literal">mapCoordinates</code> at the center, and the horizontal and vertical part of the map will each represent 1000 meters on the map.</p><p>Note that <code class="literal">MKMapView</code> will set the actual region to an approximation of the values of <code class="literal">MKCoordinateRegion</code>. This is because the dimensions of <code class="literal">MKMapView</code> cannot always match the horizontal and vertical span values provided. For example, here, we set a square region of 1000 x 1000 meters, but our <code class="literal">MKMapView</code> layout is not an absolute square, as<a id="id638" class="indexterm"/> it basically takes over the entire screen. We can retrieve the actual region of the map that the <code class="literal">MKMapView</code> is displaying through its <code class="literal">Region</code> property.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec372"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Geocoding</em>, <em>Adding map annotations</em>, and <em>Adding map overlays</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Geocoding</h1></div></div></div><p>In this recipe, we will learn how to provide information about an address, city, or country based on location coordinates.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec373"/>Getting ready</h2></div></div></div><p>Create a <a id="id639" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">GeocodingApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec374"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add an <code class="literal">MKMapView</code> on the top half of the view of <code class="literal">MainController</code>, a label, and a button on the bottom half.</li><li class="listitem">Add the <code class="literal">MonoTouch.MapKit</code> and <code class="literal">MonoTouch.CoreLocation</code> namespaces in the <code class="literal">GeocodingAppViewController.cs</code> file.</li><li class="listitem">Enter the following <code class="literal">ViewDidLoad</code> method in the class:<div><pre class="programlisting">private CLGeocoder geocoder;
public override void ViewDidLoad () {
  base.ViewDidLoad ();
  this.mapView.ShowsUserLocation = true;
  this.btnGeocode.TouchUpInside += async (sender, e) =&gt; {
    this.lblOutput.Text = "Reverse geocoding location...";
    this.btnGeocode.Enabled = false;
    CLLocation currentLocation = 
      this.mapView.UserLocation.Location;
    this.mapView.SetRegion(MKCoordinateRegion.FromDistance(currentLocation.Coordinate, 1000, 1000), true);
    this.geocoder = new CLGeocoder();
    try	{
      CLPlacemark[] placemarks = 
        await this.geocoder.ReverseGeocodeLocationAsync(currentLocation);
      if (null != placemarks)  {
        CLPlacemark placemark = placemarks[0];
        this.lblOutput.Text = 
          string.Format("Locality: {0}, Administrative area: {1}", 
            placemark.Locality,
            placemark.AdministrativeArea);
      }
    } catch (Exception ex) {
      Console.WriteLine("Error reverse geocoding location! {0}", ex.Message);
    } finally {
      this.btnGeocode.Enabled = true;
    }
  };
}</pre></div></li><li class="listitem">Make <a id="id640" class="indexterm"/>sure that the simulator's location is set to a stationary position. Navigate to <strong>Debug</strong> | <strong>Location</strong> | <strong>Custom</strong> (or <strong>Apple</strong>).</li><li class="listitem">Compile and run the app either on the simulator or on the device. The result should be similar to the following screenshot:<div><img src="img/8924OT_10_05.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec375"/>How it works...</h2></div></div></div><p>Geocoding is the<a id="id641" class="indexterm"/> process of matching address information to geographic <a id="id642" class="indexterm"/>coordinates. Reverse geocoding is the opposite, matching geographic coordinates to address information. In this recipe, we are using reverse geocoding through the <code class="literal">CLGeocoder</code> class as follows:</p><div><pre class="programlisting">private CLGeocoder geocoder;</pre></div><p>After initializing the geocoder object, we call the <code class="literal">ReverseGeocodeAsync</code> method as follows:</p><div><pre class="programlisting">CLPlacemark[] placemarks = 
        await this.geocoder.ReverseGeocodeLocationAsync(currentLocation);</pre></div><p>The method accepts a <code class="literal">CLLocation</code> parameter, which represents the location for which we want to retrieve geocoding data. The <code class="literal">return</code> value is an array of the CLPlacemark objects. The <code class="literal">CLPlacemark</code> class contains the reverse-geocoded information, such as the country, city, and address of the coordinates as shown in the following code:</p><div><pre class="programlisting">CLPlacemark placemark = placemarks[0];
this.lblOutput.Text = 
  string.Format("Locality: {0}, Administrative area: {1}", 
            placemark.Locality,
            placemark.AdministrativeArea);</pre></div><p>When reverse-geocoding a location, the array will always contain one item. If the return value is null, then an error has occurred.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec376"/>There's more...</h2></div></div></div><p>We can also <a id="id643" class="indexterm"/>use the <code class="literal">CLGeocoder</code> class for forward geocoding. For example, to get the coordinates of Apple's central offices, we use the <code class="literal">GeocodeAddressAsync</code> method as follows:</p><div><pre class="programlisting">CLPlacemark[] forward = 
  await this.geocoder.GeocodeAddressAsync("Infinite Loop, 1-5, Cupertino, CA, USA");</pre></div><p>The method will give more accurate results when we pass as all the information that we have to it.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Forward geocoding with the <code class="literal">GeocodeAddressAsync</code> method might return more than one item in the resulting <code class="literal">CLPlacemark[]</code> object. This is because the geocoder might not be able to determine the exact location through the passed information, so a set of possible results will be returned.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec92"/>Things to have in mind for CLGeocoder</h3></div></div></div><p>Apple <a id="id644" class="indexterm"/>provides the geocoding feature with a rate limit. Although the exact limit is not documented, it is recommended that you do not make more than one geocoding request per minute. If the rate limit is exceeded, the geocoder will fail with an error.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec93"/>Obsolete API</h3></div></div></div><p>The <code class="literal">CLGeocoder</code> class basically replaces <code class="literal">MKReverseGeocoder</code>, which only offered reverse geocoding until iOS 5.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec377"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Displaying maps</em>, <em>Adding map annotations</em>, and <em>Adding map overlays</em> recipes</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Adding map annotations</h1></div></div></div><p>In this recipe, we will discuss annotating a map to provide a variety of information to the user.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec378"/>Getting ready</h2></div></div></div><p>Create a <a id="id645" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">MapAnnotateApp</code>. Add <code class="literal">MKMapView</code> and a button on the view of the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec379"/>How to do it...</h2></div></div></div><p>Perform the following steps to add annotations to a map:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">MonoTouch.MapKit</code> and <code class="literal">MonoTouch.CoreLocation</code> namespaces in the <code class="literal">MapAnnotateAppViewController.cs</code> file.</li><li class="listitem">Add the <code class="literal">IMKMapViewDelegate</code> interface to the <code class="literal">MapAnnotateAppViewController</code> class declaration using the following code:<div><pre class="programlisting">public partial class MapAnnotateAppViewController : UIViewController, IMKMapViewDelegate</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.mapView.ShowsUserLocation = true;
this.mapView.WeakDelegate = this;
this.btnAddPin.TouchUpInside += (sender, e) =&gt; {
  CLLocationCoordinate2D mapCoordinate = 
    this.mapView.UserLocation.Coordinate;
  this.mapView.SetRegion(MKCoordinateRegion.FromDistance(mapCoordinate, 1000, 1000), true);
  MKPointAnnotation myAnnotation = new MKPointAnnotation();
  myAnnotation.Coordinate = mapCoordinate;
  myAnnotation.Title = "My Annotation";
  myAnnotation.Subtitle = "Standard pin with Xamarin";
  this.mapView.AddAnnotation(myAnnotation);
};</pre></div></li><li class="listitem">Add the following method in the <code class="literal">MapAnnotateAppViewController</code> class:<div><pre class="programlisting">[Export ("mapView:viewForAnnotation:")]
public MKAnnotationView GetViewForAnnotation (MKMapView mapView, NSObject annotation)
{
  if (annotation is MKUserLocation)
  {
    return null;
  } else
  {
    string reuseID = "myAnnotation";
    MKPinAnnotationView pinView = 
      mapView.DequeueReusableAnnotation(reuseID) as MKPinAnnotationView;
    if (null == pinView)
    {
      pinView = new MKPinAnnotationView(annotation, reuseID);
      pinView.PinColor = MKPinAnnotationColor.Purple;
      pinView.AnimatesDrop = true;
      pinView.CanShowCallout = true;

    }
    return pinView;
  }
}</pre></div></li><li class="listitem">Compile <a id="id646" class="indexterm"/>and run the app either on the simulator or on the device. Tap the button to add a pin on the map. The result should be similar to the following screenshot:<div><img src="img/8924OT_10_06.jpg" alt="How to do it..."/></div></li></ol></div><p>Tapping <a id="id647" class="indexterm"/>on the pin displays the callout bubble with the annotation title and subtitle.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec380"/>How it works...</h2></div></div></div><p>Annotating maps is very useful for providing a variety of information along with the map data. We can use the <code class="literal">MKPointAnnotation</code> class to create a simple annotation as follows:</p><div><pre class="programlisting">MKPointAnnotation myAnnotation = new MKPointAnnotation();
myAnnotation.Coordinate = mapCoordinate;
myAnnotation.Title = "MyAnnotation";
myAnnotation.Subtitle = "Standard annotation";
this.mapView.AddAnnotation(myAnnotation);</pre></div><p>We assign the annotation that will appear on the map coordinates, and optionally, a title and subtitle might also appear. We then add the annotation to the map view with the <code class="literal">AddAnnotation</code> method.</p><p>Just adding an annotation object to a map view is not enough. The annotation needs a view that will display its information. To provide a view for the annotation, we need to assign a delegate object to our map view. In this recipe, we are using our controller class as a delegate object for the map view as follows:</p><div><pre class="programlisting">this.mapView.WeakDelegate = this;</pre></div><p>We can assign any object that derives from <code class="literal">NSObject</code> to the <code class="literal">WeakDelegate</code> property. All we need to make it work properly is to make sure that we provide the necessary methods. Here is where the <code class="literal">GetViewForAnnotation</code> method comes in as follows:</p><div><pre class="programlisting">[Export ("mapView:viewForAnnotation:")]
public MKAnnotationView GetViewForAnnotation (MKMapView mapView, NSObject annotation)</pre></div><p>This <a id="id648" class="indexterm"/>method is found in the <code class="literal">MKMapViewDelegate</code> class and is called by the system when it needs to get a view for an annotation. The main difference in our implementation here is that instead of subclassing <code class="literal">MKMapViewDelegate</code>, we just use our controller as a delegate for our map view.</p><p>Inside the <code class="literal">GetViewForAnnotation</code> method, we need to make sure that we create and return a view for our annotation. As the map displays the user's location, there are two annotations on the map. We first need to check if the annotation object is <code class="literal">MKUserLocation</code> using the following code:</p><div><pre class="programlisting">  if (annotation is MKUserLocation)</pre></div><p>In this case, we just return null. If the annotation parameter is of the <code class="literal">MKPointAnnotation</code> type, we first try to retrieve the view for it in a fashion similar to <code class="literal">UITableView</code> that creates the cells it contains, as follows:</p><div><pre class="programlisting">MKPinAnnotationView pinView = mapView.DequeueReusableAnnotation(reuseIdentifier) as MKPinAnnotationView;</pre></div><p>If the result of the <code class="literal">DequeueReusableAnnotation</code> method is <code class="literal">null</code>, we initialize a new instance for our annotation view using the following code:</p><div><pre class="programlisting">pinView = new MKPinAnnotationView(annotation, reuseIdentifier);
pinView.PinColor = MKPinAnnotationColor.Purple;
pinView.AnimatesDrop = true;
pinView.CanShowCallout = true;</pre></div><p>The view we create for the annotation here is of the <code class="literal">MKPinAnnotationView</code> type. This is the standard view that is represented by a pin on the map. The properties we set are pretty straightforward and define its appearance and behavior. The <code class="literal">PinColor</code> property defines the color of the pin, the <code class="literal">AnimatesDrop</code> property defines if the pin will be displayed on the map with an animation, and the <code class="literal">CanShowCallout</code> property defines if the annotation view will display the information of its underlying annotation in a callout bubble.</p><p>After we have created the view for the annotation, we just return it from the method using the following line of code:</p><div><pre class="programlisting">return pinView;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec381"/>There's more...</h2></div></div></div><p>We can<a id="id649" class="indexterm"/> also create custom annotations and annotation views. For annotations, we have to override the <code class="literal">MKAnnotation</code> class, while for annotation views, we can override the <code class="literal">MKAnnotationView</code> class.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec94"/>An annotation's performance</h3></div></div></div><p>Theoretically, we can add as many annotations as we want to a map view. Although <code class="literal">MKMapView</code> can manage a large amount of annotations efficiently, it is strongly advised to take<a id="id650" class="indexterm"/> performance degradation into account. A way to overcome this is to display only the required annotations, instead of all of them. To do this, we can call the <code class="literal">ShowAnnotations</code> method, passing the specific annotation objects as an array using the following code:</p><div><pre class="programlisting">this.mapView.ShowAnnotations(myAnnotationsArray, true);</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec382"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Displaying maps</em> and <em>Adding map overlays</em> recipes</li><li class="listitem" style="list-style-type: disc">The <em>Displaying data in a table</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Displaying Data">Chapter 5</a>, <em>Displaying Data</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Adding map overlays</h1></div></div></div><p>In this recipe, we will learn how to add a red circle overlay over a point on the map.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec383"/>Getting ready</h2></div></div></div><p>Create a<a id="id651" class="indexterm"/> new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">MapOverlayApp</code>. Add <code class="literal">MKMapView</code> and a button on the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec384"/>How to do it...</h2></div></div></div><p>Perform the following steps to add overlays on the map:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">MonoTouch.MapKit</code> and <code class="literal">MonoTouch.CoreLocation</code> namespaces in the <code class="literal">MapOverlayAppViewController.cs</code> file.</li><li class="listitem">Add the <code class="literal">IMKMapViewDelegate</code> interface to the class declaration using the following code:<div><pre class="programlisting">public partial class MapOverlayAppViewController : UIViewController, IMKMapViewDelegate</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">this.mapView.ShowsUserLocation = true;
this.mapView.WeakDelegate = this;
this.btnAddOverlay.TouchUpInside += (sender, e) =&gt; {
  CLLocationCoordinate2D mapCoordinate = 
    this.mapView.UserLocation.Coordinate;
  this.mapView.SetRegion(MKCoordinateRegion.FromDistance(mapCoordinate, 1000, 1000), true);
  MKCircle circle = 
    MKCircle.Circle(mapCoordinate, 250);
  this.mapView.AddOverlay(circle, MKOverlayLevel.AboveRoads);
};</pre></div></li><li class="listitem">Add the<a id="id652" class="indexterm"/> following method to the class:<div><pre class="programlisting">[Export ("mapView:rendererForOverlay:")]
public MKOverlayRenderer OverlayRenderer (MKMapView mapView, IMKOverlay overlay)
{
  MKCircle circle = overlay as MKCircle;
  if (null != circle)
  {
    MKCircleRenderer renderer = new MKCircleRenderer(circle);
    renderer.FillColor = UIColor.FromRGBA(1.0f, 0.5f, 0.5f, 0.5f);
    renderer.StrokeColor = UIColor.Red;
    renderer.LineWidth = 2f;
    return renderer;
  } else
  {
    return null;
  }
}</pre></div></li><li class="listitem">Compile and run the app either on the simulator or on the device. When you tap the button, the result should be similar to the following screenshot:<div><img src="img/8924OT_10_07.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec385"/>How it works...</h2></div></div></div><p>While <a id="id653" class="indexterm"/>an <code class="literal">MK</code> <code class="literal">MKAnnotation</code> represents a point on a map, an <code class="literal">MKOverlay</code> object can represent an area on a map. In this example, we use the <code class="literal">MKCircle</code> class, which inherits from <code class="literal">MKOverlay</code>, to display a circle over an area on the map.</p><p>We initialize an <code class="literal">MKCircle</code> instance with its <code class="literal">Circle</code> static method using the following code:</p><div><pre class="programlisting">MKCircle circle = MKCircle.Circle(mapCoordinate, 250);</pre></div><p>The first parameter represents the coordinates of the center of the circle, while the second parameter represents the radius of the circle, in meters. After initialization, we add the overlay to the map view with the <code class="literal">AddOverlay</code> method as follows:</p><div><pre class="programlisting">this.mapView.AddOverlay(circle, MKOverlayLevel.AboveRoads);</pre></div><p>The second parameter of the <code class="literal">AddOverlay</code> method determines how the overlay should be rendered in relation to the map's information. There are two possible values, which are explained <a id="id654" class="indexterm"/>with the following accompanying screenshots:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MKOverlayLevel.AboveRoads</code>: This overlay will be displayed above the roads of the map, but below the map labels, as shown in the following screenshot:<div><img src="img/8924OT_10_08.jpg" alt="How it works..."/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">MKOverlayLevel.AboveLabels</code>: This overlay will be displayed above both roads and labels on the map, but below annotations and 3D projections of the buildings, as shown in the following screenshot:<div><img src="img/8924OT_10_09.jpg" alt="How it works..."/></div></li></ul></div><p>Unlike annotations, overlays require <code class="literal">MKOverlayRenderer</code> to display their information.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>Prior to iOS 7, overlays were shown with a view of the <code class="literal">MKOverlayView</code> type. This class is now deprecated.</p></div></div><p>To provide a renderer for our overlay, we use the <code class="literal">OverlayRenderer</code> method as follows:</p><div><pre class="programlisting">public override MKOverlayRenderer OverlayRenderer (MKMapView mapView, IMKOverlay overlay)</pre></div><p>Inside this method, we first check if the <code class="literal">overlay</code> parameter is of the type we want (in this case, an <code class="literal">MKCircle</code>) using the following code:</p><div><pre class="programlisting">MKCircle circleOverlay = overlay as MKCircle;
if (null != circleOverlay)</pre></div><p>Then, we create an instance of the <code class="literal">MKCircleView</code> class and return it as follows:</p><div><pre class="programlisting">MKCircleRenderer renderer = new MKCircleRenderer(circle);
renderer.FillColor = UIColor.FromRGBA(1.0f, 0.5f, 0.5f, 0.5f);
renderer.StrokeColor = UIColor.Red;
renderer.LineWidth = 2f;
return renderer;</pre></div><p>We set the appropriate properties that will define the appearance of our overlay. In this case, we set the <code class="literal">FillColor</code>, <code class="literal">StrokeColor</code>, and <code class="literal">LineWidth</code> properties.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec386"/>There's more...</h2></div></div></div><p>Overlays<a id="id655" class="indexterm"/> are handled efficiently by the map view. One important thing that the map view takes care of for us is that when we scale the map, the overlay is automatically scaled to match each zoom level. This way, we do not need to scale the overlay manually in code.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec95"/>Creating custom overlays</h3></div></div></div><p>We can<a id="id656" class="indexterm"/> create our own custom overlays. To do this, we need to override the <code class="literal">MKOverlay</code> class for the overlay and the <code class="literal">MKOverlayRenderer</code> class for the renderer.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec96"/>Standard overlay objects</h3></div></div></div><p>Apart from <code class="literal">MKCircle</code>, the other standard overlay objects are <code class="literal">MKPolygon</code> for creating polygon <a id="id657" class="indexterm"/>shapes and <code class="literal">MKPolyline</code> for creating polylines, like in a track-recording application.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec387"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Displaying maps</em> and <em>Adding map annotations</em> recipes</li></ul></div></div></div></body></html>