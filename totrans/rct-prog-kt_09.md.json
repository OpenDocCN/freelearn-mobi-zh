["```kt\n    class Resource():Closeable { \n      init { \n        println(\"Resource Created\") \n      } \n\n      val data:String = \"Hello World\" \n\n      override fun close() { \n        println(\"Resource Closed\") \n      } \n    } \n```", "```kt\n    fun <T, D> using(resourceSupplier: Callable<out D>, sourceSupplier:    \n    Function<in D, out ObservableSource<out T>>, \n     disposer: Consumer<in D>): Observable<T> { \n       return using(resourceSupplier, sourceSupplier, disposer, true) \n     } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.using({//(1) \n        Resource() \n      },{//(2) \n        resource:Resource-> \n        Observable.just(resource) \n      },{//(3) \n        resource:Resource-> \n        resource.close() \n      }).subscribe { \n        println(\"Resource Data ${it.data}\") \n      } \n    } \n```", "```kt\n    interface ObservableOperator<Downstream, Upstream> { \n      /** \n      * Applies a function to the child Observer and returns a new\n       parent Observer. \n      * @param observer the child Observer instance \n      * @return the parent Observer instance \n      * @throws Exception on failure \n      */ \n      @NonNull \n      @Throws(Exception::class) \n      fun apply(@NonNull observer: Observer<in Downstream>): \n      Observer<in Upstream>; \n    } \n```", "```kt\n    class AddSerialNumber<T> : ObservableOperator<Pair<Int,T>,T> { \n      val counter:AtomicInteger = AtomicInteger() \n\n      override fun apply(observer: Observer<in Pair<Int, T>>):\n      Observer<in T> { \n        return object : Observer<T> { \n          override fun onComplete() { \n             observer.onComplete() \n          } \n\n          override fun onSubscribe(d: Disposable) { \n              observer.onSubscribe(d) \n          } \n\n          override fun onError(e: Throwable) { \n              observer.onError(e) \n          } \n\n          override fun onNext(t: T) { \n              observer.onNext(Pair(counter.incrementAndGet(),t)) \n          } \n\n         } \n      } \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(10,20) \n       .lift(AddSerialNumber<Int>()) \n        .subscribeBy ( \n           onNext = { \n             println(\"Next $it\") \n           }, \n           onError = { \n             it.printStackTrace() \n           }, \n           onComplete = { \n             println(\"Completed\") \n           } \n       ) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      listOf(\"Reactive\",\"Programming\",\"in\",\"Kotlin\",\n      \"by Rivu Chakraborty\",\"Packt\") \n         .toObservable() \n         .lift<Pair<Int,String>> { \n            observer -> \n            val counter = AtomicInteger() \n            object :Observer<String> { \n              override fun onSubscribe(d: Disposable) { \n              observer.onSubscribe(d) \n            } \n\n            override fun onNext(t: String) { \n              observer.onNext(Pair(counter.incrementAndGet(), t)) \n            } \n\n            override fun onComplete() { \n              observer.onComplete() \n            } \n\n            override fun onError(e: Throwable) { \n               observer.onError(e) \n            } \n\n          } \n      } \n      .subscribeBy ( \n         onNext = { \n           println(\"Next $it\") \n         }, \n         onError = { \n           it.printStackTrace() \n         }, \n         onComplete = { \n           println(\"Completed\") \n          } \n            ) \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n        .map { \n           println(\"map - ${Thread.currentThread().name} $it\") \n           it \n         } \n         .subscribeOn(Schedulers.computation()) \n         .observeOn(Schedulers.io()) \n         .subscribe { \n            println(\"onNext - ${Thread.currentThread().name} $it\") \n         } \n\n        runBlocking { delay(100) } \n     } \n```", "```kt\n    interface ObservableTransformer<Upstream, Downstream> { \n       /** \n       * Applies a function to the upstream Observable \n       and returns an ObservableSource with \n       * optionally different element type. \n       * @param upstream the upstream Observable instance \n       * @return the transformed ObservableSource instance \n       */ \n       @NonNull \n      fun apply(@NonNull upstream: Observable<Upstream>):   \n      ObservableSource<Downstream> \n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n        .map { \n           println(\"map - ${Thread.currentThread().name} $it\") \n           it \n         } \n         .compose(SchedulerManager(Schedulers.computation(), \n             Schedulers.io())) \n             .subscribe { \n               println(\"onNext - ${Thread.currentThread().name} $it\") \n             } \n\n            runBlocking { delay(100) } \n    } \n\n    class SchedulerManager<T>(val subscribeScheduler:Scheduler,\n    val   observeScheduler:Scheduler):ObservableTransformer<T,T> { \n      override fun apply(upstream: Observable<T>): \n      ObservableSource<T> { \n        return upstream.subscribeOn(subscribeScheduler) \n        .observeOn(observeScheduler) \n      } \n\n    } \n```", "```kt\n    fun main(args: Array<String>) { \n      Observable.range(1,10) \n        .compose<List<Int>> { \n           upstream: Observable<Int> -> \n           upstream.toList().toObservable() \n         } \n         .first(listOf()) \n         .subscribeBy { \n            println(it) \n         } \n    } \n```"]