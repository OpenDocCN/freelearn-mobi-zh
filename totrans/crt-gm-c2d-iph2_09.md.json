["```swift\n-(void) addGroundTileswithEnemies:(BOOL)haveEnemies {\n    // Randomize nearly everything about the ground\n    NSInteger platformWidth = (arc4random() % 5) + 2;\n    NSInteger platformHeight = (arc4random() % 4) + 1;\n    NSInteger platformType = (arc4random() % 3) + 1;\n\n    switch (platformHeight) {\n        case 1:\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:3]];\n            break;\n        case 2:\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:1]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:3]];\n            break;\n        case 3:\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:1]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:2]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:3]];\n            break;\n        case 4:\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:1]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:3]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:2]];\n            [platformStack addObject:[NSNumber\n                                      numberWithInt:3]];\n            break;\n    }\n```", "```swift\n    for (int w = 0; w <= platformWidth; w++) {\n        // Set the new X position for the tile\n        maxTileX = maxTileX + tileSize;\n\n        for (int i = 0; i < platformHeight; i++) {\n            NSInteger currentTile = [[platformStack\n                   objectAtIndex:i] integerValue];\n\n            NSString *tileNm = [NSString stringWithFormat:@\"w%i_%i.png\", platformType, currentTile];\n            ERTile *tile = [ERTile\n                spriteWithSpriteFrameName:tileNm];\n\n            // Determine where to position the tile\n            [tile setAnchorPoint:ccp(0.5,0)];\n            float newY = i * tileSize;\n\n            // Identify if we need a walkable surface\n            if (currentTile == 3) {\n                [tile setIsTop:YES];\n\n                // Do we want enemies to spawn here?\n                if (haveEnemies) {\n                    // Determine if we need an enemy here\n                    if ((arc4random() % 13) < 1) {\n                        // chance of an enemy walker\n                        // Add it slightly above the ground\n                        [self addWalkingEnemyAtPosition:\n                         ccp(maxTileX, newY + tileSize)];\n                    }\n                }\n            } else {\n                [tile setIsTop:NO];\n            }\n\n            // Set the position (will also create sensor)\n            [tile setPosition:ccp(maxTileX, newY)];\n\n            [grndArray addObject:tile];\n            [runnersheet addChild:tile z:currentTile];\n        }\n    }\n    [platformStack removeAllObjects];\n}\n```", "```swift\n-(void) defineSensors {\n    topSensor = CGRectMake(self.boundingBox.origin.x,\n                           self.boundingBox.origin.y +\n                           self.boundingBox.size.height - 10,\n                           self.boundingBox.size.width,\n                           5);\n}\n\n-(void) setPosition:(CGPoint)position {\n    // Override set position so we can keep the sensors\n    // together with sprite\n    [super setPosition:position];\n\n    if (isTop) {\n        [self defineSensors];\n    }\n}\n```", "```swift\n-(void) addGapTiles {\n    // Add spaces between tiles\n    // Size of gap depends on current speed\n    NSInteger gapRnd = arc4random() % 5;\n\n    // Only create a gap some of the time\n    if (gapRnd > 1) {\n        // Largest gap allowed is 5 tiles\n        NSInteger gapSize = MIN(5, scrollSpeed);\n\n        // Determine which gap/water image to use\n        NSInteger gapType = (arc4random() % 2) + 1;\n\n        for (int w = 0; w < gapSize; w++) {\n            // We make the water slightly narrower\n            maxTileX = maxTileX + tileSize - 2;\n\n            NSString *tileNm = [NSString\n                stringWithFormat:@\"gap%i.png\", gapType];\n            ERTile *tile = [ERTile\n               spriteWithSpriteFrameName:tileNm];\n\n            [tile setAnchorPoint:ccp(0.5,0)];\n\n            // Put tile at bottom of screen\n            [tile setPosition:ccp(maxTileX, 0)];\n\n            // Gap tiles are not walkable\n            [tile setIsTop:NO];\n\n            [grndArray addObject:tile];\n            [runnersheet addChild:tile z:-1];\n        }\n    }\n\n    // 10 % chance of spawning a flying enemy\n    if (arc4random() % 10 == 1) {\n        float newY = (arc4random() % 40) + 250;\n        [self addFlyingEnemyAtPosition:ccp(maxTileX, newY)];\n    }\n    // Always add more tiles after the gap\n    [self addGroundTileswithEnemies:YES];\n}\n```", "```swift\n-(void) updateTiles {\n    //Update the ground position, if scrolling\n    if (isScrolling) {\n        for (CCSprite *aTile in grndArray) {\n            [aTile setPosition:ccpAdd(aTile.position, \n                                      ccp(-scrollSpeed,0))];\n        }\n        // Update HUD\n        distanceTravelled = distanceTravelled + \n                                   (scrollSpeed / 100);\n        [hudLayer changeDistanceTo:distanceTravelled];\n\n        // Speed up the scroll slowly\n        scrollSpeed = scrollSpeed + 0.001;\n    }\n\n    // Reset the maxTileX value\n    maxTileX = 0;\n\n    // Check all tiles\n    for (ERTile *aTile in grndArray) {\n        // Check for tiles scrolled away\n        if (aTile.position.x < -100) {\n            [grndToDelete addObject:aTile];\n            [aTile removeFromParentAndCleanup:YES];\n        }\n\n        // Check for the rightmost tiles\n        if (aTile.position.x > maxTileX) {\n            maxTileX = aTile.position.x;\n        }\n    }\n\n    // Remove off-screen tiles\n    [grndArray removeObjectsInArray:grndToDelete];\n    [grndToDelete removeAllObjects];\n\n    // Check if we need to add new tiles\n    if (maxTileX < (size.width * 1.1)) {\n        // Add a gap first\n        [self addGapTiles];\n    }\n}\n```", "```swift\n#define CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL 0\n```", "```swift\n-(id) init {\n    if(self = [super init]) {\n        size = [[CCDirector sharedDirector] winSize];\n\n        bg1 = [CCSprite spriteWithFile:@\"bg_mtns.png\"];\n        [bg1 setAnchorPoint:ccp(0,0)];\n        [bg1 setPosition:ccp(0, 0)];\n        [self addChild:bg1];\n\n        bg2 = [CCSprite spriteWithFile:@\"bg_mtns.png\"];\n        [bg2 setAnchorPoint:ccp(0,0)];\n        [bg2 setPosition:ccp(1001, 0)];\n        [self addChild:bg2];\n\n        [bg2 setFlipX:YES];\n    }\n    return self;\n}\n```", "```swift\n-(void) useDarkBG {\n    // Tint for darker mountains\n    [bg1 setColor:ccc3(150,150,150)];\n    [bg2 setColor:ccc3(150,150,150)];\n}\n```", "```swift\n-(void) update:(ccTime)dt {\n    // Move the mountains by their scroll speed\n    [bg1 setPosition:ccpAdd(bg1.position,\n                            ccp(-bgScrollSpeed,0))];\n    [bg2 setPosition:ccpAdd(bg2.position,\n                            ccp(-bgScrollSpeed,0))];\n\n    // If bg1 is completely off-screen, move after bg2\n    if (bg1.position.x < (-1000 - initialOffset.x)) {\n        [bg1 setPosition:ccpAdd(bg2.position,\n                        ccp(1000 + initialOffset.x,0))];\n    }\n\n    // If bg2 is completely off-screen, move after bg1\n    if (bg2.position.x < (-1000 - initialOffset.x)) {\n        [bg2 setPosition:ccpAdd(bg1.position,\n                        ccp(1000 + initialOffset.x,0))];\n    }\n}\n```", "```swift\n        // Build the scrolling background layers\n        background1 = [[ERBackground alloc] init];\n        [background1 setAnchorPoint:ccp(0,0)];\n        [background1 setPosition:ccp(0,0)];\n        [background1 useDarkBG];\n        [background1 setBgScrollSpeed:0.025];\n        [self addChild:background1 z:-2];\n\n        background2 = [[ERBackground alloc] init];\n        [background2 setAnchorPoint:ccp(0,0)];\n        [background2 setPosition:ccp(200,0)];\n        [background2 setInitialOffset:ccp(200,0)];\n        [background2 setBgScrollSpeed:0.1];\n        [self addChild:background2 z:-3];\n```", "```swift\n-(void) update:(ccTime)dt {\n\n    // Move the background layers\n    [background1 update:dt];\n    [background2 update:dt];\n```", "```swift\n+(id)spriteWithSpriteFrameName:(NSString *)spriteFrameName {\n   return [[[self alloc] initWithSpriteFrameName:spriteFrameName] autorelease];\n}\n\n-(id) initWithSpriteFrameName:(NSString *)spriteFrameName {\n    if(self = [super initWithSpriteFrameName:spriteFrameName]) { \n        _state = kHeroFalling;\n\n        // Let the hero take 5 hits before death\n        heroHealth = 5;\n\n    }\n    return self;\n}\n```", "```swift\ntypedef enum {\n    kHeroRunning = 1,\n    kHeroJumping,\n    kHeroInAir,\n    kHeroFalling\n} HeroState;\n```", "```swift\n-(void) stateChangeTo:(HeroState)newState {\n    // Make sure we are actually changing state\n    if (newState == _state) {\n        return;\n    }\n    // Stop old actions\n    [self stopAllActions];\n    // Reset the color if we were flashing\n    if (isFlashing) {\n        CCTintTo *normal = [CCTintTo actionWithDuration:\n                            0.05 red:255 green:255 blue:255];\n        CCCallBlock *done = [CCCallBlock actionWithBlock:^{\n            isFlashing = NO;\n        }];\n        [self runAction:[CCSequence actions:normal,\n                         done, nil]];\n    }\n\n    // Determine what to do now\n    switch (newState) {\n        case kHeroRunning:\n            [self playRunAnim];\n            break;\n        case kHeroJumping:\n            [self playJumpAnim];\n            break;\n        case kHeroFalling:\n            [self playLandAnim];\n            break;\n        case kHeroInAir:\n            // Leave the last frame\n            break;\n    }\n    _state = newState;\n\n    [self defineSensors];\n}\n```", "```swift\n-(void) defineSensors {\n\n    footSensor = CGRectMake(self.boundingBox.origin.x+20,\n                              self.boundingBox.origin.y,\n                              self.boundingBox.size.width-40,\n                              1);\n    fallSensor = CGRectMake(self.boundingBox.origin.x+20,\n                              self.boundingBox.origin.y-3,\n                              self.boundingBox.size.width-40,\n                              2);\n}\n\n-(void) setPosition:(CGPoint)position {\n    // Override set position so we can keep the sensors\n    // together with sprite\n    [super setPosition:position];\n\n    [self defineSensors];\n}\n```", "```swift\n-(void)buildCacheAnimation:(NSString*) AnimName\n          forFrameNameRoot:(NSString*) root\n             withExtension:(NSString*) ext\n                frameCount:(NSInteger) count\n                 withDelay:(float)delay {\n  // This method goes through all the steps to load an\n  // animation to the CCSpriteFrameCache\n  NSMutableArray *frames = [NSMutableArray array];\n\n  // Load the frames\n  for(int i = 1; i <= count; i++) {\n      CCSpriteFrame *newFrame = [[CCSpriteFrameCache\n            sharedSpriteFrameCache] spriteFrameByName:\n            [NSString stringWithFormat:@\"%@%i%@\",\n            root, i, ext]];\n      [frames addObject:newFrame];\n  }\n  // Build the animation\n    CCAnimation *newAnim  =[CCAnimation\n                        animationWithSpriteFrames:frames\n                        delay:delay];\n  // Store it in the cache\n  [[CCAnimationCache sharedAnimationCache]\n             addAnimation:newAnim name:AnimName];\n}\n\n-(CCAnimate*) getAnim:(NSString*)animNm {\n    // Helper to avoid typing this long line repeaedly\n    return [CCAnimate actionWithAnimation:\n             [[CCAnimationCache sharedAnimationCache]\n             animationByName:animNm]];\n}\n```", "```swift\n-(void) loadAnimations {\n    [pf buildCacheAnimation:@\"HeroRun\"\n           forFrameNameRoot:@\"hero_run\"\n              withExtension:@\".png\"\n                 frameCount:4 withDelay:0.1];\n    [pf buildCacheAnimation:@\"HeroJump\"\n           forFrameNameRoot:@\"hero_jump\"\n              withExtension:@\".png\"\n                 frameCount:3 withDelay:0.1];\n    [pf buildCacheAnimation:@\"HeroLand\"\n           forFrameNameRoot:@\"hero_land\"\n              withExtension:@\".png\"\n                 frameCount:3 withDelay:0.1];\n}\n```", "```swift\n-(void) playRunAnim {\n    CCAnimate *idle = [pf getAnim:@\"HeroRun\"];\n    CCRepeatForever *repeat = [CCRepeatForever\n                         actionWithAction:idle];\n    [self runAction:repeat];\n}\n```", "```swift\n-(void) playLandAnim {\n    CCAnimate *land = [pf getAnim:@\"HeroLand\"];\n    [self runAction:land];\n}\n```", "```swift\n-(void) playJumpAnim {\n    CCAnimate *jump = [pf getAnim:@\"HeroJump\"];\n    CCCallBlock *change = [CCCallBlock actionWithBlock:^{\n        [self stateChangeTo:kHeroInAir];\n    }];\n    CCSequence *doIt = [CCSequence actions:jump, change, nil];\n\n    [self runAction:doIt];\n\n    // Play the sound effect\n    [[SimpleAudioEngine sharedEngine]\n                         playEffect:SND_HEROJUMP];\n}\n```", "```swift\n-(void) updateHero:(ccTime)dt {\n    CGPoint newPos = hero.position;\n\n    BOOL isFalling = YES;\n\n    // The hero is going up\n    if (hero.state == kHeroJumping ||\n                   hero.state == kHeroInAir) {\n        jumpTimer = jumpTimer - dt;\n\n        if (jumpTimer <= 0) {\n            // Jump ending, descend\n            [hero stateChangeTo:kHeroFalling];\n        } else {\n            // Apply a force up for the hero\n            newPos = ccpAdd(hero.position, ccp(0,3));\n        }\n    }\n\n    // If hero is falling, apply our gravity\n    if (hero.state == kHeroFalling) {\n        newPos = ccpAdd(hero.position, ccp(0,-3));\n    }\n\n    // Check if the hero is touching the ground\n    for (ERTile *aTile in grndArray) {\n        if (CGRectIntersectsRect(hero.footSensor,\n                                   aTile.topSensor)) {\n            // push hero up 1 point if his feet hit the ground\n            newPos = ccpAdd(hero.position, ccp(0,1));\n            [hero stateChangeTo:kHeroRunning];\n        }\n\n        // See if the fall sensor detects anything below\n        if (CGRectIntersectsRect(hero.fallSensor,\n                                   aTile.topSensor)) {\n            // Not falling\n            isFalling = NO;\n        }\n    }\n    // Check if hero should fall\n    if (isFalling && hero.state == kHeroRunning) {\n        [hero stateChangeTo:kHeroFalling];\n    }\n\n    // Move the hero\n    [hero setPosition:newPos];\n\n    // Check if hero has fallen off screen\n    if (hero.position.y < -40) {\n        [self gameOver];\n    }\n}\n```", "```swift\n-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {\n    if (preventTouches) {\n        return YES;\n    }\n\n    if (isGameOver) {\n        [[CCDirector sharedDirector] replaceScene:[ERMenuScene\n                                               scene]];\n        return YES;\n    }\n\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n\n    if (convLoc.x < size.width/2) {\n        // Jump if left side of screen\n        if (hero.state == kHeroRunning) {\n            // Jump from the ground\n            [hero stateChangeTo:kHeroJumping];\n            // Reset the jump timer\n            jumpTimer = maxJumpTimer;\n            // Allow hero to double-jump\n            allowDoubleJump = YES;\n        } else if (allowDoubleJump) {\n            // Allow a second jump in the air\n            [hero stateChangeTo:kHeroJumping];\n            // Reset the jump timer\n            jumpTimer = maxJumpTimer;\n            // Prevent a third jump\n            allowDoubleJump = NO;\n        } else {\n            return NO;\n        }\n    } else {\n        // Shoot if right side of screen\n        [hero shoot];\n    }\n    return YES;\n}\n```", "```swift\n-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {\n    if (isGameOver) {\n        return;\n    }\n\n    CGPoint loc = [touch locationInView:[touch view]];\n    CGPoint convLoc = [[CCDirector sharedDirector]\n                       convertToGL:loc];\n\n    // Release the jump\n    if (convLoc.x < size.width/2) {\n        // Jump if left side of screen\n        [hero stateChangeTo:kHeroFalling];\n    }\n}\n```", "```swift\n@interface ERBullet : CCSprite {\n    BOOL isShootingRight;\n    BOOL isHeroBullet;\n}\n\n@property (nonatomic, assign) BOOL isShootingRight;\n@property (nonatomic, assign) BOOL isHeroBullet;\n\n@end\nERBullet.m:\n@implementation ERBullet\n\n@synthesize isShootingRight;\n@synthesize isHeroBullet;\n\n@end\n```", "```swift\n-(void) shoot {\n    // Create a bullet at hero's position\n    ERBullet *bullet = [ERBullet\n                   spriteWithSpriteFrameName:IMG_BULLET];\n    [bullet setColor:ccBLUE];\n    [bullet setIsShootingRight:YES];\n    [bullet setIsHeroBullet:YES];\n    [bullet setPosition:self.position];\n\n    // Tell the playfield to add the bullet\n    [pf addBullet:bullet];\n\n    // Play the sound effect\n    [[SimpleAudioEngine sharedEngine]\n                   playEffect:SND_HEROSHOOT];\n}\n```", "```swift\n-(void) addBullet:(ERBullet*) thisBullet {\n    [runnersheet addChild:thisBullet z:3];\n\n    [bulletArray addObject:thisBullet];\n}\n```", "```swift\n-(void) updateBullets {\n    for (ERBullet *bullet in bulletArray) {\n        if (bullet.isShootingRight) {\n            // Move the bullet right\n            bullet.position = ccpAdd(bullet.position,\n                                      ccp(10,0));\n\n            // Remove bullets that are off the screen\n            if (bullet.position.x > size.width) {\n                [bulletsToDelete addObject:bullet];\n                [bullet removeFromParentAndCleanup:YES];\n            }\n        } else {\n            // Move the bullet left\n            bullet.position = ccpAdd(bullet.position, \n                                      ccp(-10,0));\n\n            // Remove bullets that are off the screen\n            if (bullet.position.x < 0) {\n                [bulletsToDelete addObject:bullet];\n                [bullet removeFromParentAndCleanup:YES];\n            }\n        }\n    }\n\n    // Remove deleted bullets from the array\n    [bulletArray removeObjectsInArray:bulletsToDelete];\n    [bulletsToDelete removeAllObjects];\n}\n```", "```swift\n-(void) loadEnemyAnimations {    \n    // Build all walking enemy animations\n    for (int i = 1; i <= 18; i++) {\n        // Build the names for the image and animation\n        NSString *root = [NSString stringWithFormat:\n                          @\"walk%i_\", i];\n        NSString *anim = [NSString stringWithFormat:\n                          @\"%@move\", root];\n\n        // Build the animation into the cache\n        [self buildCacheAnimation:anim\n                 forFrameNameRoot:root\n                    withExtension:@\".png\"\n                       frameCount:4 withDelay:0.1];\n    }\n\n    // Build all flying enemy animations\n    for (int i = 1; i <= 12; i++) {\n        // Build the names for the image and animation\n        NSString *root = [NSString stringWithFormat:\n                          @\"fly%i_\", i];\n        NSString *anim = [NSString stringWithFormat:\n                          @\"%@move\", root];\n\n        // Build the animation into the cache\n        [self buildCacheAnimation:anim\n                 forFrameNameRoot:root\n                    withExtension:@\".png\"\n                       frameCount:4 withDelay:0.1];\n    }\n }\n```", "```swift\n-(void) defineSensors {\n    fallSensor = CGRectMake(self.boundingBox.origin.x+20,\n                            self.boundingBox.origin.y-10,\n                            self.boundingBox.size.width-40,\n                            10);\n}\n-(void) setPosition:(CGPoint)position {\n    // Override set position so we can keep the sensors\n    // together with sprite\n    [super setPosition:position];\n\n    [self defineSensors];\n}\n```", "```swift\n-(void) shoot {\n    // Create a bullet at enemy's position\n    ERBullet *bullet = [ERBullet\n                          spriteWithSpriteFrameName:IMG_BULLET];\n    [bullet setColor:ccRED];\n    [bullet setIsShootingRight:self.isMovingRight];\n    [bullet setPosition:self.position];\n    [bullet setIsHeroBullet:NO];\n\n    // Tell the playfield to add the bullet\n    [pf addBullet:bullet];\n\n    // Play the sound effect\n    [[SimpleAudioEngine sharedEngine]\n                              playEffect:SND_ENEMYSHOOT];\n}\n```", "```swift\n    BOOL isMovingRight;\n    BOOL isFlying;\n    ccTime shootTimer;\n```", "```swift\n-(void) addWalkingEnemyAtPosition:(CGPoint)pos {\n    // Randomly select a walking enemy\n    NSInteger enemyNo = (arc4random() % 18) + 1;\n\n    // Build the name of the enemy\n    NSString *enemyNm = [NSString stringWithFormat:@\"walk%i\",\n                            enemyNo];\n\n    // Build the initial sprite frame name\n    NSString *enemyFrame = [NSString\n                      stringWithFormat:@\"%@_1.png\", enemyNm];\n    EREnemy *enemy = [EREnemy\n                      spriteWithSpriteFrameName:enemyFrame];\n    [enemy setPosition:ccpAdd(pos, \n                      ccp(0, enemy.contentSize.height/2))];\n    [enemy setIsMovingRight:NO];\n    [enemy setFlipX:NO];\n    [enemy setIsFlying:NO];\n    [enemy setPf:self];\n\n    // Add this enemy to the layer and the array\n    [runnersheet addChild:enemy z:5];\n    [enemyArray addObject:enemy];\n\n    // Set the enemy in motion\n    NSString *moveAnim = [NSString\n                    stringWithFormat:@\"%@_move\", enemyNm];\n    CCAnimate *idle = [self getAnim:moveAnim];\n    CCRepeatForever *repeat = [CCRepeatForever\n                    actionWithAction:idle];\n    [enemy runAction:repeat];\n}\n```", "```swift\n-(void) addFlyingEnemyAtPosition:(CGPoint)pos {\n    // Randomly select a walking enemy\n    NSInteger enemyNo = (arc4random() % 12) + 1;\n\n    // Build the name of the enemy\n    NSString *enemyNm = [NSString stringWithFormat:@\"fly%i\",\n                      enemyNo];\n\n    // Build the initial sprite frame name\n    NSString *enemyFrame = [NSString\n                      stringWithFormat:@\"%@_1.png\", enemyNm];\n    EREnemy *enemy = [EREnemy\n                      spriteWithSpriteFrameName:enemyFrame];\n    [enemy setPosition:pos];\n    [enemy setIsMovingRight:NO];\n    [enemy setFlipX:NO];\n    [enemy setIsFlying:YES];\n    [enemy setPf:self];\n\n    // Add this enemy to the layer and the array\n    [runnersheet addChild:enemy z:5];\n    [enemyArray addObject:enemy];\n\n    // Set the enemy in motion\n    NSString *moveAnim = [NSString\n                      stringWithFormat:@\"%@_move\", enemyNm];\n    CCAnimate *idle = [self getAnim:moveAnim];\n    CCRepeatForever *repeat = [CCRepeatForever\n                      actionWithAction:idle];\n    [enemy runAction:repeat];\n}\n```", "```swift\n-(void) updateEnemies:(ccTime)dt {\n    // Only update the enemies while scrolling\n    if (isScrolling == NO) {\n        return;\n    }\n\n    // Loop through all enemies\n    for (EREnemy *anEnemy in enemyArray) {\n        BOOL noGround = YES;\n\n        // Check movement direction\n        if (anEnemy.isMovingRight) {\n            // Moving against the scroll\n            [anEnemy setPosition:ccpAdd(anEnemy.position,\n                             ccp(-scrollSpeed + 2,0))];\n        } else {\n            // Moving with the scroll\n            [anEnemy setPosition:ccpAdd(anEnemy.position,\n                             ccp(-scrollSpeed - 2,0))];\n        }\n\n        // Updates for walking enemies only\n        if (anEnemy.isFlying == NO) {\n            // Check if the enemy is touching the ground\n            for (ERTile *aTile in grndArray) {\n                // See if the sensor detects anything below\n                if (CGRectIntersectsRect(anEnemy.fallSensor,\n                                aTile.topSensor)) {\n                    // Ground is under foot\n                    noGround = NO;\n                }\n            }\n\n            // If there is no ground underfoot, turn around\n            if (noGround) {\n                if (anEnemy.isMovingRight) {\n                    [anEnemy setIsMovingRight:NO];\n                    [anEnemy setFlipX:NO];\n                } else {\n                    [anEnemy setIsMovingRight:YES];\n                    [anEnemy setFlipX:YES];\n                }\n            }\n        }\n\n        // Enemy can shoot, with time delay\n        if (anEnemy.shootTimer <= 0) {\n            [anEnemy shoot];\n            anEnemy.shootTimer = 2.0;\n        } else {\n            anEnemy.shootTimer = anEnemy.shootTimer - dt;\n        }\n\n        // Check for enemies off screen\n        if (anEnemy.position.x < -50) {\n            // If off-screen to the left, add to delete\n            [enemiesToDelete addObject:anEnemy];\n            [anEnemy removeFromParentAndCleanup:YES];\n        }\n    }\n\n    // Remove deleted enemies from the array\n    [enemyArray removeObjectsInArray:enemiesToDelete];\n    [enemiesToDelete removeAllObjects];\n}\n```", "```swift\n-(void) checkCollisions {\n    BOOL isHeroHit = NO;\n\n    for (ERBullet *bullet in bulletArray) {\n        // Enemy bullets\n        if (bullet.isHeroBullet == NO) {\n            if (CGRectIntersectsRect(hero.boundingBox,\n                                bullet.boundingBox)) {\n                // Hero got hit\n                [bulletsToDelete addObject:bullet];\n                [bullet removeFromParentAndCleanup:YES];\n                isHeroHit = YES;\n                break;\n            }\n        } else {\n            // Hero bullets\n\n            // Check all enemies to see if they got hit\n            for (EREnemy *anEnemy in enemyArray) {\n                if (CGRectIntersectsRect(anEnemy.boundingBox,\n                                         bullet.boundingBox)) {\n                    [bulletsToDelete addObject:bullet];\n                    [bullet removeFromParentAndCleanup:YES];\n                    [enemiesToDelete addObject:anEnemy];\n                    [anEnemy gotShot];\n                    break;\n                }\n            }\n        } \n    }\n```", "```swift\n    // Check for enemy and hero collisions\n    for (EREnemy *anEnemy in enemyArray) {\n        if (CGRectIntersectsRect(anEnemy.boundingBox,\n                         hero.boundingBox)) {\n            // Trigger the enemy's hit\n            [enemiesToDelete addObject:anEnemy];\n            [anEnemy gotShot];\n            // Trigger the hero's hit\n            isHeroHit = YES;\n            break;\n        }\n    }\n\n    // We process this here because there could be\n    // multiple collisions with the hero\n    if (isHeroHit) {\n        [hero gotShot];\n    }\n\n    // Remove deleted bullets from the array\n    [bulletArray removeObjectsInArray:bulletsToDelete];\n    [bulletsToDelete removeAllObjects];\n\n    // Remove deleted enemies from the array\n    [enemyArray removeObjectsInArray:enemiesToDelete];\n    [enemiesToDelete removeAllObjects];\n}\n```", "```swift\n-(void) gotShot {\n    CCParticleSystemQuad *emitter = [CCParticleSystemQuad\n                      particleWithFile:@\"enemydie.plist\"];\n    [emitter setPosition:self.position];\n    [pf addChild:emitter z:50];\n\n    [self removeFromParentAndCleanup:YES];\n\n    // Play the sound effect\n    [[SimpleAudioEngine sharedEngine]\n                         playEffect:SND_ENEMYDEAD];\n}\n```", "```swift\n-(void) gotShot {\n    // Subtract one from hero health\n    heroHealth--;\n\n    // Determine if the hero is dead\n    if (heroHealth <= 0) {\n        // Spawn a death particle\n        CCParticleSystemQuad *emitter = [CCParticleSystemQuad\n                        particleWithFile:@\"ExplodingRing.plist\"];\n        [emitter setPosition:self.position];\n        [pf addChild:emitter z:50];\n\n        // We don't clean up to avoid block failure\n        [self removeFromParentAndCleanup:NO];\n\n        // Play the sound effect for death\n        [[SimpleAudioEngine sharedEngine]\n                      playEffect:SND_HERODEATH];\n\n        // Trigger game over\n        [pf gameOver];\n    } else if (isFlashing == NO) {\n        // Flash the hero red briefly\n        isFlashing = YES;\n        CCTintTo *red = [CCTintTo actionWithDuration:0.05\n                                   red:255 green:0 blue:0];\n        CCTintTo *normal = [CCTintTo actionWithDuration:0.05\n                                   red:255 green:255 blue:255];\n        CCCallBlock *done = [CCCallBlock actionWithBlock:^{\n            isFlashing = NO;\n        }];\n        [self runAction:[CCSequence actions: red, normal,\n                             done, nil]];\n\n        // Play the got hit sound effect\n        [[SimpleAudioEngine sharedEngine]\n                            playEffect:SND_HEROHIT];\n    }\n}\n```"]