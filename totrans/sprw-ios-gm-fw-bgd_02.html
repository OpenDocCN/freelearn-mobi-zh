<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Displaying Our First Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Displaying Our First Objects</h1></div></div></div><p>
<span class="emphasis"><em>In the previous chapter, we installed and configured Xcode developer tools and also as downloaded the Sparrow framework and linked it to a sample project. We proceeded to test it in both the iOS Simulator and a real device. We also set the scope for the game we are going to develop throughout the book. However, before we get into the game development process, let's touch on some core concepts of Sparrow and get accustomed with the way things work in Sparrow. We will draw some objects on the screen and manipulate these objects by applying rotation and scaling transforms.</em></span>
</p><div class="section" title="Understanding display objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Understanding display objects</h1></div></div></div><p>As the name suggests, a display object is something that will be displayed on the screen. We can think of display objects as separate graphical entities that contain different kinds of graphical data. While this may sound a bit abstract at first, every image (<code class="literal">SPImage</code>), quads (<code class="literal">SPQuad</code>), or other geometrical shapes are derived from the <code class="literal">SPDisplayObject</code> class, which is the representation of a display object in Sparrow.</p><div class="section" title="Explaining display object containers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Explaining display object containers</h2></div></div></div><p>A display object container (<code class="literal">SPDisplayObjectContainer</code>) inherits from <code class="literal">SPDisplayObject</code>, adding the facility to own a set of child display objects. When you add a <a id="id76" class="indexterm"/>child display object to a parent display object container, you can think of it as attaching one display object to another. If you move, scale, or rotate the parent display object, all the changes are inherited by any children it might have. This concept is more or less identical to how objects on the screen are managed in the Adobe Flash API. The full set of parent and child nodes is referred to as the display list, or sometimes as a display tree. This is because, like a tree, it contains many branches that all ultimately converge into one single trunk, often referred to as the root. Yet another name for a display tree is a scene graph.</p><p>The display list draws the display objects in the order they are added to their parent display object container. If we were to add a second child display object to the same parent as that of the previously added display object, the second display object will be drawn in front of the first.</p><p>Let's go<a id="id77" class="indexterm"/> ahead and imagine ourselves as a cardboard puppet doll. We need a head, a torso and a leg, arm, and hand on the left side and the same goes for the right side. Refer to the following diagram that displays this concept:</p><div class="mediaobject"><img src="graphics/1509OS_02_01.jpg" alt="Explaining display object containers"/></div><p>The root object for this arrangement would be the body object. The head, torso, legs, and arms would be directly bound to the body and the hands would be bound to each arm.</p></div></div></div>
<div class="section" title="Setting the background color"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Setting the background color</h1></div></div></div><p>Before we draw a couple of objects on the screen, let's change the background color of our application that will eventually become our game.</p></div>
<div class="section" title="Time for action &#x2013; changing the background color"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Time for action – changing the background color</h1></div></div></div><p>Let's take <a id="id78" class="indexterm"/>a look at the required steps to change the background color:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open our Xcode game template if it's not already open.</li><li class="listitem">Open the <code class="literal">Game.m</code> source file.</li><li class="listitem">After the initialization method and before the existing <code class="literal">SPQuad</code> object, add the following lines:<div class="informalexample"><pre class="programlisting">SPQuad *background = [SPQuad quadWithWidth:Sparrow.stage.width height:Sparrow.stage.height color:0xffffff];
[self addChild:background];</pre></div></li><li class="listitem">Run the example.</li></ol></div><p>When the example is running, we see our red rectangle on a white background as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1509OS_02_02.jpg" alt="Time for action – changing the background color"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 1, we opened our Xcode template that we created in the previous chapter, and in step 2, we navigated to the <code class="literal">Game.m</code> file, which is where our game code currently lies. The game is the red rectangle that keeps showing up.</p><p>In step 3, right <a id="id79" class="indexterm"/>before we drew our red rectangle, we defined the <code class="literal">background</code> variable that is a pointer to an instance of <code class="literal">SPQuad</code>. The <code class="literal">SPQuad</code> class is derived from <code class="literal">SPDisplayObject</code>. The function of <code class="literal">SPQuad</code> is to draw a rectangular shape with a background color.</p><p>The <code class="literal">SPQuad</code> class provides a few factory methods for operations such as creating a quad with a width and height and also adds a color value to it. In this example, we are creating a quad with a predefined width and height and a color value of <code class="literal">0xffffff</code>. A color is defined as <code class="literal">0xRRGGBB</code> in a hexadecimal notation, that is, <code class="literal">REDRED</code> <code class="literal">GREENGREEN</code> <code class="literal">BLUEBLUE</code>.</p><p>While at the surface, the call to <code class="literal">[SPQuad quadWithWidth:Sparrow.stage.width height:Sparrow.stage.height]</code> seems to be the same as the one to <code class="literal">[[SPQuad alloc] initWithWidth:Sparrow.stage.width height:Sparrow.stage.height]</code>, but there is one major difference under the hood. When the factory method is called, it returns an auto-released object, which means we don't have an ownership over the instance and it's being destroyed at some point. On the other hand, if we use the alloc-and-init combination, we do have the ownership and the need to release the instance ourselves.</p><p>As <a id="id80" class="indexterm"/>our application uses <span class="strong"><strong>Automatic Reference Counting</strong></span> (<span class="strong"><strong>ARC</strong></span>), we don't need to worry about releasing instances ourselves. On the <a id="id81" class="indexterm"/>other hand, Sparrow itself uses <span class="strong"><strong>Manual Reference Counting</strong></span> (<span class="strong"><strong>MRC</strong></span>).</p><p>To cover the whole screen, we need to get the width and height of the screen itself. Those values are available as properties in the <code class="literal">Sparrow.stage</code> object.</p><p>We need to add the background to the <code class="literal">Game</code> class, which is exactly what <code class="literal">[self addChild:background]</code> does. The <code class="literal">self</code> keyword is a reference to the <code class="literal">Game</code> class, which is derived from the <code class="literal">SPSprite</code> class.</p><p>Now, we have a white background with a red rectangle that appears on top of it.</p><p>Our <code class="literal">Game.m</code> source file should contain the following code:</p><div class="informalexample"><pre class="programlisting">#import "Game.h" 

@implementation Game

- (id)init
{
    if ((self = [super init]))
    {
        SPQuad *background = [SPQuad quadWithWidth:Sparrow.stage.width height:Sparrow.stage.height color:0xffffff];
        [self addChild:background];
        
        SPQuad *quad = [SPQuad quadWithWidth:100 height:100];
        quad.color = 0xff0000;
        quad.x = 50;
        quad.y = 50;
        [self addChild:quad];
    }
    return self;
}

@end</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>There is<a id="id82" class="indexterm"/> also an easier way to set the background color. While the performance penalty in this specific case is not that high to worry about, we could directly set the color through <code class="literal">Sparrow.stage</code> by using its color property: <code class="literal">Sparrow.stage.color = 0xffffff</code>. It consists of fewer lines, is more readable, and shows its intention better.</p></div><div class="section" title="What is a stage?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>What is a stage?</h2></div></div></div><p>We briefly<a id="id83" class="indexterm"/> touched on the topic of <code class="literal">Sparrow.stage</code>, which so far proved to have some useful properties for getting the width and height of the screen and setting the background color directly.</p><p>A stage is the top-level element of any Sparrow game and logically the root element of the display tree, which Sparrow automatically creates for us.</p></div></div>
<div class="section" title="Creating our cardboard puppet doll"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Creating our cardboard puppet doll</h1></div></div></div><p>Let's implement the cardboard puppet doll that we talked about in the beginning of the chapter. Remove the red rectangle that has been drawn on the screen.</p></div>
<div class="section" title="Time for action &#x2013; creating a cardboard puppet doll"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Time for action – creating a cardboard puppet doll</h1></div></div></div><p>To<a id="id84" class="indexterm"/> create the cardboard puppet doll, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Game.m</code> file if it's not already open.</li><li class="listitem">Add a <code class="literal">body</code> container with the following lines:<div class="informalexample"><pre class="programlisting">SPSprite *body = [[SPSprite alloc] init];
body.x = 85;
body.y = 120;
        
[self addChild:body];</pre></div></li><li class="listitem">Add <code class="literal">torso</code> as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *torso = [SPQuad quadWithWidth:150 height:150];
torso.color = 0xff0000;
        
[body addChild:torso];</pre></div></li><li class="listitem">Now add a local variable <code class="literal">head</code> as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *head = [SPQuad quadWithWidth:80 height:80 color:SP_YELLOW];
head.x = 35;
head.y = -70;

[body addChild: head];</pre></div></li><li class="listitem">Add a container for the <code class="literal">arms</code> local variable as shown in the following code:<div class="informalexample"><pre class="programlisting">SPSprite *arms = [[SPSprite alloc] init];

[body addChild:arms];</pre></div></li><li class="listitem">Add a container for the <code class="literal">legs</code> local variable as shown in the following code:<div class="informalexample"><pre class="programlisting">SPSprite *legs = [[SPSprite alloc] init];
legs.y = 140;

[body addChild:legs];</pre></div></li><li class="listitem">Add the left arm as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *leftArm = [SPQuad quadWithWidth:100 height:50 color:0x00ff00];
leftArm.x = -80;

[arms addChild:leftArm];</pre></div></li><li class="listitem">Add the right arm as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *rightArm = [SPQuad quadWithWidth:100 height:50 color:0x00ff00];
rightArm.x = 130;

[arms addChild:rightArm];</pre></div></li><li class="listitem">Every arm needs a hand. Let's add the left one first as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *leftHand = [SPQuad quadWithWidth:40 height:50 color:SP_YELLOW];
leftHand.x = -80;

[arms addChild:leftHand];</pre></div></li><li class="listitem">Now use the following code for the right hand:<div class="informalexample"><pre class="programlisting">SPQuad *rightHand = [SPQuad quadWithWidth:40 height:50 color:SP_YELLOW];
rightHand.x = 190;

[arms addChild:rightHand];</pre></div></li><li class="listitem">Let's move on to the legs. We'll create the left one first with the following code:<div class="informalexample"><pre class="programlisting">SPQuad *leftLeg = [SPQuad quadWithWidth:50 height:150 color:0x0000ff];

[legs addChild:leftLeg];</pre></div></li><li class="listitem">We'll create the right leg with the following code:<div class="informalexample"><pre class="programlisting">SPQuad *rightLeg = [SPQuad quadWithWidth:50 height:150 color:0x0000ff];
rightLeg.x = 100;

[legs addChild:rightLeg];</pre></div></li><li class="listitem">Run the example.</li></ol></div><p>When we run the example, a simple cardboard puppet doll made of rectangles is looking right at us, as <a id="id85" class="indexterm"/>shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1509OS_02_03.jpg" alt="Time for action – creating a cardboard puppet doll"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 1, we used the <code class="literal">Game.m</code> source file we are already familiar with.</p><p>At first, we needed a container object, which we called <code class="literal">body</code> for this example. A quad would not suffice in this case because <code class="literal">SPQuad</code> does not inherit from <code class="literal">SPDisplayObjectContainer</code> and so cannot have children added to it. We set the <code class="literal">x</code> and <code class="literal">y</code> properties, so the contents of the <code class="literal">body</code> element appeared somewhere in the middle of our screen. The coordinate system in Sparrow started at the top-left corner of the screen, just like how the coordinate system works in Flash or in traditional application development when adding control elements to a window. Developers from a traditional graphics development may take some time to get used to this. In OpenGL, for example, the <span class="emphasis"><em>y</em></span> axis is flipped. We then add the <code class="literal">body</code> element to our Game instance.</p><p>In step 3, we took the <code class="literal">torso,</code> which is a quad and added it to the body element. If we don't specify an <code class="literal">x</code> or <code class="literal">y</code> property, their default value is <code class="literal">0</code>.</p><p>After that, we added the <code class="literal">head</code>. The <code class="literal">x</code> and <code class="literal">y</code> properties are measured relative to the parent display object. So, if we use a negative value, it doesn't necessarily mean that the element is drawn outside the screen. It depends on the position of the parent display object container.</p><p>While <a id="id86" class="indexterm"/>we know that we can use colors with the hexadecimal notation, we are using <code class="literal">SP_YELLOW</code> in this step. This has the same effect as typing <code class="literal">0xffff00</code>.</p><p>For the arms and legs, we added a container for each in step 5 and step 6, respectively. <code class="literal">SPSprite</code> is the most basic and lightweight container class that should be used when grouping objects. The leg container is already being positioned a bit to the bottom, so its children elements only need to be positioned horizontally.</p><p>In the remaining steps, we added each limb and when we finally ran the application, we had a cardboard puppet doll made of rectangles looking at us.</p></div><div class="section" title="Have a go hero – improving the cardboard puppet doll"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Have a go hero – improving the cardboard puppet doll</h2></div></div></div><p>Our code can be improved quite a bit; the <code class="literal">legs</code>, <code class="literal">arms</code>, and <code class="literal">hands</code> code are practically the same, but<a id="id87" class="indexterm"/> we define each element separately. We could try to group and simplify the code a bit.</p><p>Also, in the current arrangement, the hands are not directly connected to the arms of the doll. Instead, they are bound to the <code class="literal">arms</code> container object. So if we were to move a single arm, the hand would not move with the arm.</p><p>The following are some ideas on how to solve these problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In order to connect the hands to the arms, we would need at least two new container objects</li><li class="listitem" style="list-style-type: disc">Make a cardboard puppet doll class in which its elements are classes inheriting from the display object containers</li></ul></div></div></div>
<div class="section" title="Explaining macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec33"/>Explaining macros</h1></div></div></div><p>While <a id="id88" class="indexterm"/>we know that we can use colors with the hexadecimal notation, Sparrow provides some shorthand constants for the most commonly used colors. In the previous example, instead of using <code class="literal">0xffff00</code> for the color yellow, we used <code class="literal">SP_YELLOW</code>.</p><p>To generalize, macros are handy little functions that allow us to simplify the workflow when working with repetitious tasks.</p><p>Macros in <a id="id89" class="indexterm"/>Objective-C are preprocessor directives and work the same way that macros work in C and C++. Before the code is compiled, the preprocessor goes through the entire code and replaces all occurrences of the macro with the result of the macro.</p><p>While we could write each color in the hexadecimal color value notation, sometimes it does make more sense to use an RGB value. The <code class="literal">SP_COLOR</code> macro does exactly that, converting a RGB color into a hexadecimal color value.</p><p>In this section, we will look at what the different kinds of macros are and how to use them.</p><div class="section" title="The Angles macro"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>The Angles macro</h2></div></div></div><p>Sparrow <a id="id90" class="indexterm"/>uses radians to describe the rotation of its display objects. If we<a id="id91" class="indexterm"/> want to use degrees for our calculations, we would need the following macros:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_R2D</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Converts radians to degrees</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_R2D(PI);</code>
</p>
<p>
<code class="literal">// 180</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_D2R</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Converts degrees to radians</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_D2R(180);</code>
</p>
<p>
<code class="literal">// PI</code>
</p>
</td></tr></tbody></table></div></div><div class="section" title="The Colors macro"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>The Colors macro</h2></div></div></div><p>If we need<a id="id92" class="indexterm"/> to create a custom color or take an existing color apart, the<a id="id93" class="indexterm"/> following macros would fit our purpose:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR_PART_ALPHA</code>
</p>
<p>
<code class="literal">SP_COLOR_PART_RED</code>
</p>
<p>
<code class="literal">SP_COLOR_PART_GREEN</code>
</p>
<p>
<code class="literal">SP_COLOR_PART_BLUE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Getting the partial value of a color</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR_PART_RED(0xff0000);</code>
</p>
<p>
<code class="literal">// 0xff</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets an RGB color</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR(255, 255, 0);</code>
</p>
<p>
<code class="literal">// 0xffff00</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR_ARGB</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets an ARGB color</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_COLOR_ARGB(128, 255, 255, 0);</code>
</p>
<p>
<code class="literal">// 0x80ffff00</code>
</p>
</td></tr></tbody></table></div></div><div class="section" title="The utility functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>The utility functions</h2></div></div></div><p>Let's<a id="id94" class="indexterm"/> take a look at the last group of macros that aren't angle- or <a id="id95" class="indexterm"/>color-related:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_IS_FLOAT_EQUAL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Does<a id="id96" class="indexterm"/> a float comparison between two values. Returns 0 if it's false, 1 if it's true.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_IS_FLOAT_EQUAL(0.11, 0.12);</code>
</p>
<p>
<code class="literal">// 0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_CLAMP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Clamps<a id="id97" class="indexterm"/> between two values. The first parameter is the initial value. The other two parameters are the minimum and maximum values respectively.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_CLAMP(0.6, 1.0, 2.0);</code>
</p>
<p>
<code class="literal">// 1.0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_SWAP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Swaps<a id="id98" class="indexterm"/> two values with each other.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">NSUInteger x = 0;</code>
</p>
<p>
<code class="literal">NSUInteger y = 1;</code>
</p>
<p>
<code class="literal">SP_SWAP(x, y, NSUInteger);</code>
</p>
<p>
<code class="literal">// x = 1; y = 0</code>
</p>
</td></tr></tbody></table></div></div><div class="section" title="Constants in Sparrow"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Constants in Sparrow</h2></div></div></div><p>We <a id="id99" class="indexterm"/>already know about <code class="literal">SP_YELLOW</code>, so let's take a look at what constants are defined in Sparrow.</p><div class="section" title="Math"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Math</h3></div></div></div><p>The <code class="literal">PI</code> constant, for<a id="id100" class="indexterm"/> example, is used in the macro to convert <a id="id101" class="indexterm"/>radians to degrees and vice versa. The following are the examples of <code class="literal">PI</code> constant:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PI</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value of Pi</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PI_HALF</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value of Pi divided by two</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TWO_PI</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The value of Pi multiplied by two</p>
</td></tr></tbody></table></div></div><div class="section" title="Color"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Color</h3></div></div></div><p>Sparrow predefines 16 colors for easier usage, so we don't have to use a macro each time. These<a id="id102" class="indexterm"/> are the most basic colors and are also defined in a number of <a id="id103" class="indexterm"/>different libraries and frameworks, for example, HTML 4.01. The following table shows 16 colors that are predefined in Sparrow:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>RGB value</p>
</th><th style="text-align: left" valign="bottom">
<p>Hex value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_WHITE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">255, 255, 255</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0xffffff</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_SILVER</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">208, 208, 208</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0xc0c0c0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_GRAY</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">128, 128, 128</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x808080</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_BLACK</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 0, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x000000</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_RED</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">255, 0, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0xff0000</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_MAROON</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">128, 0, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x800000</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_YELLOW</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">255, 255, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0xffff00</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_OLIVE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">128, 128, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x808000</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_LIME</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 255, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x00ff00</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_GREEN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 128, 0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x008000</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_AQUA</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 255, 255</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x00ffff</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_TEAL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 128, 128</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x008080</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_BLUE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 0, 255</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x0000ff</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_NAVY</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0, 0, 128</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x000080</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_FUCHSIA</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">255, 0, 255</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0xff00ff</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SP_PURPLE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">128, 0, 128</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0x800080</code>
</p>
</td></tr></tbody></table></div></div></div></div>
<div class="section" title="Manipulating display objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec34"/>Manipulating display objects</h1></div></div></div><p>Now that we have our cardboard puppet doll on the screen, let's start manipulating the objects on the screen.</p><p>In this example, we will take a look at how to rotate, scale, and skew objects, and then set the origin of these objects.</p></div>
<div class="section" title="Time for action &#x2013; manipulating display objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec35"/>Time for action – manipulating display objects</h1></div></div></div><p>Perform<a id="id104" class="indexterm"/> the following steps to manipulate the display objects we created earlier:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new method to <code class="literal">Game.m</code> below the <code class="literal">init</code> method we used to create the body parts:<div class="informalexample"><pre class="programlisting">- (void)onLegTouch:(SPTouchEvent *)event
{
  SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];
  if (touch) {
    SPQuad* target = (SPQuad *) event.target;
    
    float currentRotation = SP_R2D(target.rotation);
    currentRoration = currentRotation + 10;
    
    if (currentRotation &gt;= 360.0)
    {
      currentRotation = currentRotation - 360.0;
    }
    target.rotation = SP_D2R(currentRotation);
  }
}</pre></div></li><li class="listitem">Next, we'll need to set the anchor (pivot) of our legs in the initializer, as shown in the following code:<div class="informalexample"><pre class="programlisting">leftLeg.pivotX = 25;
leftLeg.pivotY = 10;
        
rightLeg.pivotX = 25;
rightLeg.pivotY = 10;</pre></div></li><li class="listitem">Update the leg positions using the following code:<div class="informalexample"><pre class="programlisting">SPQuad *leftLeg = [SPQuad quadWithWidth:50 height:150 color:0x0000ff];
[legs addChild:leftLeg];
<span class="strong"><strong>leftLeg.x = 25;</strong></span>
        
SPQuad *rightLeg = [SPQuad quadWithWidth:50 height:150 color:0x0000ff];
<span class="strong"><strong>rightLeg.x = 125;</strong></span>
[legs addChild:rightLeg];</pre></div></li><li class="listitem">We'll set an event listener for the legs using the following code:<div class="informalexample"><pre class="programlisting">[rightLeg addEventListener:@selector(onLegTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
[leftLeg addEventListener:@selector(onLegTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];</pre></div></li><li class="listitem">Let's add<a id="id105" class="indexterm"/> another method that should be called when we touch the head of our cardboard puppet doll. This method should be below the initializer and the <code class="literal">onLegTouch</code> method:<div class="informalexample"><pre class="programlisting">- (void)onHeadTouch:(SPTouchEvent *)event
{
    SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];
    if (touch) {
        SPQuad* target = (SPQuad *) event.target;
        target.scaleX = (target.scaleX == 1.0) ? 1.5 : 1.0;
        target.scaleY = (target.scaleY == 1.0) ? 1.5 : 1.0;
    }
}</pre></div></li><li class="listitem">We'll need to set the pivot for the head as well:<div class="informalexample"><pre class="programlisting">head.pivotX = head.width / 2;
head.pivotY = head.height / 2;</pre></div></li><li class="listitem">Let's update the position of the head as shown in the following code:<div class="informalexample"><pre class="programlisting">SPQuad *head = [SPQuad quadWithWidth:80 height:80 color:SP_YELLOW];
<span class="strong"><strong>head.x = 75;</strong></span>
<span class="strong"><strong>head.y = -30;</strong></span>
[body addChild: head];</pre></div></li><li class="listitem">Let's add an event listener for the head as shown in the following code:<div class="informalexample"><pre class="programlisting">[head addEventListener:@selector(onHeadTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];</pre></div></li><li class="listitem">Add another method that should be called if we touch the arms. This is shown in the following code:<div class="informalexample"><pre class="programlisting">- (void)onArmsTouch:(SPTouchEvent *)event
{
    SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];
    if (touch) {
        SPQuad* target = (SPQuad *) event.target;
        target.skewX = (target.skewX == SP_D2R(20)) ? SP_D2R(0) : SP_D2R(20);
        target.skewY = (target.skewY == SP_D2R(20)) ? SP_D2R(0) : SP_D2R(20);
    }
}</pre></div></li><li class="listitem">Bind the event listener to this newly added method:<div class="informalexample"><pre class="programlisting">[arms addEventListener:@selector(onArmsTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];</pre></div></li><li class="listitem">Run the <a id="id106" class="indexterm"/>example and touch some limbs of our cardboard puppet doll. We should now see our cardboard puppet doll on the screen and if we touch an arm, leg, or the head, we see these objects rotated, skewed, or scaled.<p> </p><div class="mediaobject"><img src="graphics/1509OS_02_04.jpg" alt="Time for action – manipulating display objects"/></div><p>
</p></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 1, we defined a method that should be called when we touch one of the legs. We need to get a reference to the touch event, which in Sparrow is described as <code class="literal">SPTouchEvent</code>. To get the touch instance (<code class="literal">SPTouch</code>), we looked for touches on any object in the touch began phase. Each touch moves through three phases: first <code class="literal">SPTouchPhaseBegan</code>, then <code class="literal">SPTouchPhaseMoved</code>, and finally <code class="literal">SPTouchPhaseEnded</code>. We need to check whether the touch is valid as objects have been touched by using it as a condition in the <code class="literal">if</code>-statement. The current target of the event is available in <code class="literal">event.target</code> although it needs to be casted to the appropriate display object type, in this case, <code class="literal">SPQuad</code>.</p><p>We then<a id="id107" class="indexterm"/> got the current rotation of the touched object and add 10 degrees to the rotation. The new rotation will be set to the quad. If the rotation is bigger than 360 degrees, we'll subtract 360 degrees.</p><p>The origin for display objects is, by default, the top-left corner of the display object itself. If we want a different origin, we'll need to modify it using the <code class="literal">pivotX</code> and <code class="literal">pivotY</code> properties of a display object.</p><p>Modifying the origin also has an effect on the positioning of the element; so, if we want to keep the same position, we need to add the pivot value to the position values, which is what happened in step 3.</p><p>In step 4, we added an event listener for each of the legs, so when we actually touch the legs, something happens. When using <code class="literal">addEventListener</code>, we are binding a selector that will be called once the event is triggered, in our case, <code class="literal">SP_EVENT_TYPE_TOUCH</code>. This event will be called if any touch occurs on the specified object, which was <code class="literal">self</code> (the <code class="literal">Game</code> instance) in this step. Multiple selectors can be bound to one event when using <code class="literal">addEventListener</code> each time.</p><p>For the next step, we added a method for touching the head of our cardboard puppet doll. We also needed to do the same touch check and target casting we did last time. This time when we touch the head, it should scale up to 150 percent of its original size, and if we touch the head again, it'll shrink back to its original size.</p><p>In step 6, we set the origin to the center of the element. In step 7, we needed to update the position accordingly, and in step 8, we bound the method to the <code class="literal">head</code> element.</p><p>The last method that we defined is what would happen when we touch any <code class="literal">arms</code> element. If we are binding a touch event to a <code class="literal">SPSprite</code> instance, it will fire for all its children as well. The same touch check applies to this method. We'll skew an element by 20 degrees with the first touch and reset it to its original state when the element is touched again.</p><p>We use a ternary statement here to check whether the target is already skewed. We check for the condition within the parenthesis. If the condition evaluates against <code class="literal">true</code>, the statement after the question mark will be executed; otherwise, the statement after the colon will be executed. The advantage is that the ternary statement is an expression and can be assigned to a value in a single step. It would translate to the following code if we were to use <code class="literal">if</code> statements instead:</p><div class="informalexample"><pre class="programlisting">if (target.skewX == SP_D2R(20)) {
  target.skewX = SP_D2R(0);
} else {
  target.skewX = SP_D2R(20);
}

if (target.skewY == SP_D2R(20)) {
  target.skewY = SP_D2R(0);
} else {
  target.skewY = SP_D2R(20);
}</pre></div><p>The <code class="literal">onArmsTouch</code> method was then bound to the <code class="literal">arms</code> object in step 10.</p><p>When <a id="id108" class="indexterm"/>we run the example and touch various elements, we'll see all the skewing, scaling, and rotating in action.</p></div><div class="section" title="Pop quiz"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Pop quiz</h2></div></div></div><p>Q1. What is an alternate term for display list/tree?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Display block</li><li class="listitem">Display object</li><li class="listitem">Scene graph</li></ol></div><p>Q2. What is a Sparrow stage?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A game level</li><li class="listitem">Root element of the display tree</li><li class="listitem">A display object on the <code class="literal">Game</code> class</li></ol></div><p>Q3. What are macros?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Functions that are evaluated at runtime</li><li class="listitem">Preprocessor directives that are evaluated before compiling</li><li class="listitem">Dynamic constants</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec36"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about how to display objects on the screen and how to manipulate them.</p><p>Specifically, we covered how to display objects on the screen and use macros and constants Sparrow provides. Another important aspect is that we manipulated the objects we drew on the screen.</p><p>We also touched on some topics such as the Sparrow stage and got an overview of how the Sparrow API works.</p><p>Now that we know how to draw objects on the screen, we're ready to learn about asset and scene management—which is the topic of the next chapter.</p></div></body></html>