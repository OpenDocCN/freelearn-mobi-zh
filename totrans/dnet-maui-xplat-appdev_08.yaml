- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Platform-Specific Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last six chapters, we developed a fundamental password manager app. So
    far, all platform-specific features have been managed by .NET MAUI, making the
    developed features appear platform-agnostic. However, addressing platform-specific
    features is not always avoidable. In this chapter, we will delve into the implementation
    of such features.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how to utilize device features on supported platforms. By applying
    the knowledge gained in this chapter, we will incorporate fingerprint support
    and a customized Markdown view into our app.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter does touch on platform-specific features, its primary focus
    isn’t platform-specific programming. Delving deeper into platform-specific implementations
    would require specific programming knowledge for Android, iOS, WinUI, and so on.
    Given this would require a considerable amount of knowledge, instead of teaching
    you to write your own plugins or specific UI controls for each platform, we will
    consider some of the high-level concepts involved in creating these elements.
    To help you become familiar with these concepts, our focus will be on how to extend
    these features and incorporate them into our app.
  prefs: []
  type: TYPE_NORMAL
- en: To use .NET for native application development, you would need to write a specialized
    book for each platform. You can refer to the *Further reading* section for more
    information about Android and iOS native application development using Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter07](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/269e26ce42e9d82430a8c8deeda25ffb80a501d0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the section
    *Managing the source code in this book* in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing platform-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of .NET MAUI application development, there are numerous instances
    where we might need to write platform-specific code. In this section, we will
    examine the guidelines for implementing such code. Following that, we will explore
    the two most common scenarios that necessitate writing platform-specific code
    in this chapter. The first scenario involves accessing platform features that
    are not readily available in .NET MAUI APIs. The second scenario may require creating
    custom controls or customizing existing controls.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into how to access platform APIs, it’s important to distinguish
    between the terms .NET MAUI API and platform API. In *Chapter 1*, *Getting Started
    with .NET MAUI*, we have the following architecture diagram of a .NET MAUI application
    (*Figure 7.1*).
  prefs: []
  type: TYPE_NORMAL
- en: '![A group of colorful rectangular boxes with text  Description automatically
    generated](img/B21554_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: .NET MAUI architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since most of the components in the architectural diagram are open-source,
    I’ve numbered the components for the discussion. You can reference these numbers
    in the *Further reading* section to locate the corresponding source code on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET MAUI APIs** **(6)** are the cross-platform APIs offered by the .NET
    MAUI framework. These APIs maintain consistency and unification across various
    platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform APIs** **(7)(8)(9)(10)**, on the other hand, pertain to the platform-specific
    APIs provided by the underlying target platforms (Android, iOS/macOS, and Windows).
    These APIs enable you to access native features, devices, and functionalities
    unique to each platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, to incorporate platform code in .NET MAUI, we can utilize techniques
    such as conditional compilation and interfaces, as well as partial classes and
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET MAUI, it is possible to employ conditional compilation to invoke platform-specific
    code by defining compiler directives tailored to each platform. These directives
    enable you to incorporate or omit particular code segments, depending on the target
    platform throughout the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subsequent code snippet, the Markdown encoding varies on Android. By
    utilizing conditional compilation, we can manage the Android code independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This modular approach enables the effective use of platform-specific APIs while
    preserving a shared codebase, facilitating a more seamless cross-platform development
    process. The conditional compilation method described is typically used for simple
    implementations. However, if platform-specific implementations involve more complex
    logic, it’s best to utilize interfaces and partial classes. These provide a more
    structured approach, allowing for better organization and maintainability of the
    code, especially when dealing with complex, platform-specific logic.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, partial class, and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using interfaces, partial classes, and methods to implement platform-specific
    features provides several benefits to developers when building cross-platform
    applications, ensuring clean code organization, maintainability, and flexibility.
    Here are the advantages of using these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstraction and modularity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces**: Interfaces provide a way to define contracts that must be implemented
    by the platform-specific classes, encapsulating platform-specific code while ensuring
    consistency across different platform implementations. This promotes a clear separation
    of concerns and allows for modular code that is easier to manage and maintain.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial classes**: Partial classes enable you to split the implementation
    of a single class across multiple files, which is particularly useful when working
    with platform-specific features. Each platform’s implementation can be separated
    into different files, resulting in cleaner and more organized code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code reusability and maintainability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interfaces allows you to create reusable components that can be easily
    plugged into different platform-specific implementations without modifying the
    shared code. This improves maintainability, as changes in platform-specific code
    do not affect the rest of the application, reducing the potential for errors and
    simplifying updates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Partial methods serve as optional method implementations within partial classes.
    They enable you to define a method signature in the shared code without providing
    an implementation. The platform-specific code can then provide the implementation
    if needed, which can be left empty otherwise. This approach keeps the codebase
    cleaner by avoiding unnecessary empty method implementations and helps to maintain
    a more consistent structure across platforms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flexibility and testability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces offer flexibility when implementing platform-specific features, as
    different implementations can be easily swapped for testing purposes or to support
    future platforms. It allows for dependency injection, making it easier to write
    unit tests and mock platform-specific components during development and testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to utilize platform features that are not directly supported by .NET
    MAUI, we typically create components known as plugins. In the upcoming section,
    we will use the fingerprint plugin as a case study to gain insight into the implementation
    of .NET MAUI plugins through interfaces, partial classes, or abstract classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .NET MAUI/Xamarin plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To utilize platform features in a cross-platform manner, we typically create
    components known as plugins. In .NET MAUI plugins (or Xamarin plugins), we establish
    cross-platform APIs to access native platform features or services. These plugins
    empower you to write platform-independent code in your shared project while concurrently
    harnessing native functionality on each platform (Android, iOS, macOS, and Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Plugins abstract platform-specific code, enabling you to use a standardized
    API in your shared project for accessing native features. This streamlines development
    and helps you maintain a neater and more readable codebase that adheres to the
    **Model-View-ViewModel** (**MVVM**) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Although I have used the term “.NET MAUI plugins,” it’s important to note that
    it’s not limited purely to .NET MAUI. In fact, it’s possible to develop a plugin
    that can be used by both .NET MAUI and Xamarin.Forms simultaneously. Typically,
    a plugin is a multi-target .NET project where the developer can decide the number
    of platforms to support. The content in this chapter regarding plugins is also
    applicable to .NET MAUI Blazor Hybrid apps. We will delve into .NET MAUI Blazor
    Hybrid app development in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As plugin development can be fairly flexible and potent, the compatibility of
    plugin libraries is determined by individual developers. To standardize a variety
    of plugins from the community, let’s evaluate the evolutionary path of .NET MAUI
    or Xamarin plugins in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of .NET MAUI/Xamarin plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, in order to utilize a device feature without a built-in cross-platform
    interface, we could often find Xamarin plugins developed by the community. Xamarin
    plugins, created by Xamarin developers, are packaged in a cross-platform format.
    However, these plugins lack standardization, which may result in the existence
    of multiple plugins catering to the same device features.
  prefs: []
  type: TYPE_NORMAL
- en: As the Xamarin ecosystem evolved and matured, Xamarin.Essentials was introduced
    as an all-embracing, harmonized alternative. By consolidating popular plugins
    into a single cross-platform library, it simplified the utilization of native
    APIs across Android, iOS, and Windows devices.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Essentials serves as both a library and a namespace. Within this namespace,
    we can access hardware interfaces, such as a battery, flashlight, vibration, geolocation
    sensor, etc.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of .NET MAUI, Xamarin.Essentials has undergone further development,
    resulting in a collection of individual namespaces housed under the `Microsoft.Maui`
    namespace, as depicted in *Figure 7.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a computer program  Description automatically generated](img/B21554_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Evolution of Xamarin.Essentials'
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin.Essentials, all features are consolidated under a single namespace,
    resulting in a sizable and flat library. In contrast, .NET MAUI adopts a more
    refined design by dividing the features into multiple namespaces, as illustrated
    in *Table 7.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.ApplicationModel` | Within this namespace, it encompasses
    APIs that enable access to platform-specific application-level information and
    activities. Examples of these include app actions, app information, the browser,
    the launcher, the main thread, maps, permissions, and version tracking. |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.ApplicationModel.Communication` | Within this namespace,
    we have access to various communication services, including contacts, email, networking,
    the phone dialer, sms, and web authenticator functionality. |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.ApplicationModel.DataTransfer` | Clipboard and sharing APIs
    can be found in this namespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.Devices` | In this namespace, we have the capability to access
    various hardware sensors and accelerators, including the battery, the device display,
    device information, device sensors, the flashlight, geocoding, geolocation, haptic
    feedback, and vibration. |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.Media` | We can access video and photos in this namespace,
    such as the media picker, screenshot, text-to-speech, or unit converters. |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.Maui.Storage` | To access various local storage in preferences
    or secure storage, we can use this namespace. We can find a cross-platform file
    picker and filesystem helpers here. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Device features in Microsoft.Maui'
  prefs: []
  type: TYPE_NORMAL
- en: While the cross-platform APIs listed in *Table 7.1* allow us to access various
    device features, there are still some platform features unavailable. In such instances,
    we must either implement our own solutions or utilize plugins developed by the
    community. For instance, there are no cross-platform APIs available for fingerprint
    functionality. To incorporate fingerprint features in our app, we need to rely
    on community-developed plugins.
  prefs: []
  type: TYPE_NORMAL
- en: As .NET MAUI APIs currently do not support fingerprint functionality, we will
    employ an open-source plugin called `Plugin.Fingerprint`, which was previously
    used in the Xamarin version of `PassXYZ.Vault`. In this chapter, we will utilize
    the same plugin to facilitate fingerprint support in the .NET MAUI version of
    PassXYZ.Vault. `Plugin.Fingerprint` is an example of a library that can support
    both .NET MAUI and Xamarin.Forms.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of Plugin.Fingerprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this session, we will utilize `Plugin.Fingerprint` as a case study to demonstrate
    the implementation of .NET MAUI plugins. You can find the fingerprint plugin we
    will be using at the following GitHub URL: [https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Plugin.Fingerprint` in our project, we can add the package to our project
    by using the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to implement a plugin, it is common practice to begin by defining an
    interface. This interface serves as a means to access the features provided by
    the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The concrete implementation is divided into two components, the cross-platform
    aspect and the platform-specific aspect, which are achieved using either a partial
    class or an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a fingerprint  Description automatically generated](img/B21554_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Plugin.Fingerprint'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.3* presents the class diagram of `Plugin.Fingerprint`. It is evident
    that `Plugin.Fingerprint` establishes an interface called `IFingerprint`. An abstract
    class, `FingerprintImplementationBase`, carries out the implementation of this
    interface. This abstract class is responsible for cross-platform functionality
    and outlines abstract methods designated for platform-specific implementation.
    `FingerprintImplementation`, a separate class on each platform, defines the platform-specific
    implementation. In the following block, we will examine the code of `IFingerprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IFingerprint` interface defines four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetAvailabilityAsync` checks the availability of fingerprint authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsAvailableAsync` serves as a wrapper for `GetAvailabilityAsync`, offering
    easier access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticateAsync` handles the actual authentication, using fingerprint data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetAuthenticationTypeAsync` allows users to retrieve the currently available
    authentication type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s examine `FingerprintImplementationBase`, which implements the `IFingerprint`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the `FingerprintImplementationBase` class, the `AuthenticateAsync` method
    is implemented by invoking the `NativeAuthenticateAsync` method. The latter is
    defined as an abstract method that is implemented in the platform layer.
  prefs: []
  type: TYPE_NORMAL
- en: It also defines `GetAvailabilityAsync` and `GetAuthenticationTypeAsync` as abstract
    methods, which are subsequently implemented in the platform layer.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsAvailableAsync` method simply invokes `GetAvailabilityAsync` and then
    compares the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to instantiate the `IFingerprint` interface, `Plugin.Fingerprint`
    employs a class named `CrossFingerprint`. This class utilizes a creational design
    pattern, along with lazy initialization, to generate `IFingerprint` interface
    instances during runtime, as we can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In `CrossFingerprint`, a static property called `Current` **(2)** is defined,
    which can be utilized to obtain the instance of `IFingerprint`. The property `Current`
    returns the value of a `Lazy<IFingerprint>` object, specified in the variable
    `_implementation` **(1)**, which implements lazy initialization. Within `Lazy<IFingerprint>`,
    the `IFingerprint` instance is created using the factory method `CreateFingerprint`
    **(3)**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced `Plugin.Fingerprint`, let’s explore how to incorporate
    fingerprint support in our app using this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting fingerprint functionality using Plugin.Fingerprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To incorporate fingerprint functionality using `Plugin.Fingerprint`, we must
    first configure it within our project before making any code modifications. This
    step involves adding the NuGet package `Plugin.Fingerprint` to our project file,
    as detailed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For now, please disregard the NuGet package `EJL.MauiHybridWebView`. We will
    delve into a discussion about it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As users must access device-specific features within each platform, it is essential
    to configure the required permissions for our application in their respective
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Android platform, it is necessary to request specific permissions within
    the `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the iOS platform, we need to do the same in `Info.plist`, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Incorporating fingerprint functionality is an objective we aim to achieve in
    our application. By employing the MVVM pattern, we can initially integrate this
    fingerprint feature within our view model. Subsequently, we can utilize this functionality
    in our XAML pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our users will utilize fingerprint authentication to log in, so we can incorporate
    the fingerprint plugin into the `LoginViewModel`. The users will engage with `LoginPage`
    to carry out the login process. However, before they can employ fingerprint authentication
    within `LoginPage`, they must first enable the fingerprint feature in our app’s
    settings. The implementation of these settings is found in the `SettingsPage`.
    The relationship between `IFingerprint`, `LoginViewModel`, `LoginPage`, and `SettingsPage`
    is illustrated in *Figure 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a computer program  Description automatically generated](img/B21554_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Plugin.Fingerprint integration'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are utilizing dependency injection to manage dependencies, it is necessary
    to initially include the `IFingerprint` interface in the configuration found in
    `MauiProgram.cs`, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Having completed the aforementioned setup and configuration, let us now examine
    the code of the `LoginViewModel` provided below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7.1: `LoginViewModel.cs` ([https://epa.ms/LoginViewModel7-1](https://epa.ms/LoginViewModel7-1))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LoginViewModel`, we obtain an instance of the `IFingerprint` interface
    **(1)** via constructor dependency injection and save it in the member variable
    `_fingerprint`. This `IFingerprint` instance is then utilized to implement fingerprint
    status validation and authentication functions.
  prefs: []
  type: TYPE_NORMAL
- en: The function `CheckFingerprintStatus` **(3)** has been implemented to evaluate
    the device’s capability and status, specifically determining if the device supports
    fingerprint recognition and if it is enabled for the current user. The properties
    `IsFingerprintEnabled` **(4)** and `IsFingerprintAvailable` **(5)** will be updated
    by this function.
  prefs: []
  type: TYPE_NORMAL
- en: To enable fingerprint authentication, `FingerprintLogin` **(2)** is incorporated
    to execute login via fingerprint recognition. The function `AuthenticateAsync`
    **(6)** is utilized for fingerprint verification; however, it does not carry out
    the login process.
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the view model, we can focus on developing the user interface.
    To incorporate fingerprint functionality, it is necessary for the user to activate
    it initially. We employ a settings page for this purpose. When the fingerprint
    feature is enabled, the user can access the system using their fingerprint. This
    login function is incorporated into the `LoginPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Fingerprint settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to *Figure 7.5* for the fingerprint configuration. The user interface
    design is notably minimalistic, utilizing only a switch control to activate or
    deactivate the fingerprint function.
  prefs: []
  type: TYPE_NORMAL
- en: '![A white background with black dots  Description automatically generated](img/B21554_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: SettingsPage'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface for the `SettingsPage` is relatively straightforward, which
    allows us to bypass discussing its XAML. Instead, we will focus on examining the
    code-behind file of the `SettingsPage` in *Listing 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7.2: `SettingsPage.xaml.cs` ([https://epa.ms/SettingsPage7-2](https://epa.ms/SettingsPage7-2))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SettingsPage`, we incorporate `LoginViewModel` **(1)** and `LoginService`
    through dependency injection. We override the lifecycle method `OnAppearing` **(2)**
    to evaluate fingerprint support by invoking `CheckFingerprintStatus` **(3)**.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we execute the function `SetFingerprintSwitcher` **(4)** to
    update the UI. When users toggle the switch on or off, the event handler `OnSwitcherToggleAsync`
    **(5)** is activated. Within this event handler, we authenticate the fingerprint
    by calling `AuthenticateAsync` **(6)** and subsequently save the master password
    in secure storage. If fingerprint authentication is not used, we remove the master
    password from secure storage to disable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Login using a fingerprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Upon activating the fingerprint feature in the `SettingsPage`, users can utilize
    fingerprint login, as illustrated in *Figure 7.6*. With the fingerprint function
    enabled, a fingerprint icon appears next to the password field. By clicking on
    this icon, users can access the fingerprint login user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a login screen  Description automatically generated](img/B21554_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: LoginPage'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can examine the implementation of this fingerprint icon by reviewing the
    XAML code provided below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The fingerprint icon is designed as an `ImageButton`, which will only be visible
    when `IsFingerprintEnabled` is set to true through data binding. Upon clicking
    the icon, the `FingerprintLoginCommand` will be triggered. By leveraging the MVVM
    pattern, we simply need to add this `ImageButton` to the XAML page, while the
    remaining logic is implemented within the view model.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the introduction of .NET MAUI/Xamarin plugins. Our app’s
    fingerprint support was made possible through the use of `Plugin.Fingerprint`.
    In the upcoming section, we will explore another case – creating custom controls
    or customizing existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET MAUI controls are built on the foundation of native controls. There may
    be instances where we would like these native controls to exhibit customized behavior
    to cater to our specific needs. Additionally, there might be situations when we
    need to create our own controls, particularly when the desired native controls
    are not readily available in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the .NET MAUI implementations of cross-platform
    controls and use an example to illustrate how to enhance a cross-platform control
    with new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we might want to present a password entry as a secure note,
    rather than as a standard password entry on the details page. To improve the user
    experience, we aim to support Markdown text instead of plain text. As .NET MAUI
    currently does not provide a Markdown view control, we must create our own. We
    will use this scenario as an example to demonstrate how to expand the functionality
    of existing controls to develop a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET MAUI, handlers play a crucial role in the rendering process by transforming
    cross-platform view elements (controls) into their corresponding platform-specific
    native UI components. The implementation of handlers bears a resemblance to the
    approach taken in the `Plugin.Fingerprint` implementation, where a control-specific
    interface is employed to distinguish between the cross-platform view and the native
    view. As we plan to implement our `MarkdownView` using the `WebView` control,
    we will use the `WebView` control as an example to explain handlers.
  prefs: []
  type: TYPE_NORMAL
- en: A `WebView` displays web content and HTML within a .NET MAUI application. In
    .NET MAUI, each supported platform (iOS, Android, macOS, and Windows) has corresponding
    handlers for the `WebView` control, mapping it to native controls. Such examples
    include `WKWebView` for iOS and macOS, `WebView` for Android, and `WebView2` for
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a company  Description automatically generated](img/B21554_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: .NET MAUI handlers'
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in *Figure 7.7*, the architecture consists of three layers: a virtual
    view, handlers, and native views. Cross-platform controls interact with native
    views via a control-specific interface implemented by the handlers. In the case
    of `WebView`, it communicates with `WebViewHandler` through the `IWebView` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IWebView` interface is implemented by `WebViewHandler`, which utilizes
    partial classes to segregate the platform-specific implementation, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WebViewHandler.iOS.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebViewHandler.Android.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebViewHandler.WinUI.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebViewHandler.MacCatalyst.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the handler, the `VirtualView` property is defined as a reference to
    the cross-platform control, while the `PlatformView` property refers to the native
    view. A property mapper is utilized to establish a connection between the cross-platform
    control’s API and the native view’s API.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of .NET MAUI handlers illustrates the architectural differences
    between .NET MAUI and Xamarin.Forms. For more information on .NET MAUI handlers,
    you can refer to the Microsoft article titled “*Create a custom control using
    handlers*” in the *Further reading* section. This article provides extensive insights
    into the creation and application of custom controls using handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Using HybridWebView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we introduce handlers, we will investigate the implementation of a Markdown
    view using `WebView`. A common approach to displaying Markdown text involves converting
    it into HTML and then presenting the HTML content within a `WebView`. Our challenge
    lies in transforming the Markdown text into HTML. There are .NET libraries available
    to accomplish this, such as Markdig, which can be found at [https://github.com/xoofx/markdig](https://github.com/xoofx/markdig).
  prefs: []
  type: TYPE_NORMAL
- en: Opting for this approach requires us to convert Markdown text into HTML at runtime
    and subsequently assemble an HTML page. Since `WebView` will be employed, a more
    straightforward method involves directly passing the Markdown text to `WebView`
    and allowing `WebView` to interpret the text, using a JavaScript library. However,
    the default `WebView` lacks sufficient JavaScript interoperability to facilitate
    this process. As a solution, we will implement our Markdown view using the open-source
    project `HybridWebView`, developed by Eilon Lipton, which can be found at [https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView).
  prefs: []
  type: TYPE_NORMAL
- en: '`HybridWebView` improves `WebView` by supporting more sophisticated JavaScript
    interoperability. This enhancement allows for the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: We can configure a JavaScript library and resources by utilizing .NET MAUI raw
    resources, packaging them similarly to a static website. At runtime, we can load
    it in `WebView`, which resembles a **Single Page Application** (**SPA**). There
    is a sample app that demonstrates how to convert an existing React application
    into a .NET MAUI application running in `WebView`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HybridWebView` also augments event handling and enables JavaScript functions
    to invoke .NET functions, and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the assistance of `HybridWebView`, let’s explore how to incorporate `MarkdownView`
    into our app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing MarkdownView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept behind `MarkdownView` is to directly pass the Markdown text that
    we wish to display to `HybridWebView`. This employs a JavaScript library to render
    the text. To achieve this, we require a JavaScript-based Markdown interpreter.
    Given that Markdown is widely utilized in numerous web applications, several JavaScript
    libraries are available for this purpose. We will use a compact, yet efficient
    library called Marked, which can be found at [https://github.com/markedjs/marked](https://github.com/markedjs/marked).
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing the Marked library is quite simple. You can simply invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can observe that displaying a Markdown string is achieved by passing it to
    the `marked.parse` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we proceed, we must determine the appropriate moment to pass
    this Markdown string to `WebView`. If we simply call a JavaScript function from
    the .NET side, the JavaScript function in the HTML file may not be fully prepared.
    Hence, it is essential to wait for the HTML file to load completely in `WebView`.
  prefs: []
  type: TYPE_NORMAL
- en: By employing the jQuery library, we can obtain an event that notifies .NET when
    the HTML page is ready, as illustrated in *Figure 7.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: HTML and JavaScript resources'
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in *Figure 7.8*, we create a folder named `hybrid_root` within the
    `Raw` directory under the `Resources` folder. Within the `hybrid_root` folder,
    we store JavaScript files in the `js` folder and CSS files in the `styles` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `js` folder houses local copies of both Marked and jQuery, eliminating the
    need for network requests when displaying a Markdown string. The left side of
    *Figure 7.8* displays the contents of `hybrid_app.xhtml`. Inside this file, we
    utilize the jQuery function `$(document).ready()` to send an event to the .NET
    side when the page has loaded. Once the .NET side receives this event, it can
    invoke the `MarkdownToHtml` function by passing a Markdown string to it. In this
    manner, we can display any Markdown string using `MarkdownView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having explained the necessary preparations for HTML and JavaScript, let’s
    examine what we need to implement on the .NET side. We can begin by looking at
    the implementation of `MarkdownView` in *Listing 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7.3: `MarkdownView.cs` ([https://epa.ms/MarkdownView7-3](https://epa.ms/MarkdownView7-3))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MarkdownView`, we must establish the web asset’s root as `hybrid_root`
    **(1)**, and `hybrid_app.xhtml` **(2)** is the HTML file that needs to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function called `DisplayMarkdown` is created to showcase Markdown text, and
    it will invoke the JavaScript function `MarkdownToHtml` **(4)** to display the
    text. Since the encoding of Markdown text varies between Android, Windows, and
    iOS/macOS, the string encoding function `JavaScriptStringEncode` **(3)** has to
    be called for Windows and iOS/macOS platforms. After implementing `MarkdownView`,
    we can develop the user interface to render Markdown text, as demonstrated in
    *Listing 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7.4: `NotesPage.xaml` ([https://epa.ms/NotesPage7-4](https://epa.ms/NotesPage7-4))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 7.4*, a `MarkdownView` called `markdownview` is defined. An event
    handler, `OnHybridWebViewRawMessageReceived`, is registered, and its implementation
    can be found in the code-behind file in *Listing 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7.5: `NotesPage.xaml.cs` ([https://epa.ms/NotesPage7-5](https://epa.ms/NotesPage7-5))'
  prefs: []
  type: TYPE_NORMAL
- en: In the `NotesPage.xaml.cs` file, we override the `OnAppearing` function **(1)**.
    This function ensures that `MarkdownView` is reloaded every time the page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnHybridWebViewRawMessageReceived` event handler is where we invoke `DisplayMarkdown`
    **(2)** to showcase the Markdown text. *Figure 7.9* displays the completed user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated](img/B21554_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: MarkdownView'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of `MarkdownView`, we have gained knowledge on expanding
    an existing control to accommodate the necessary new features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented guidelines on implementing platform-specific code
    within a .NET MAUI project. There are numerous instances where platform-specific
    code implementation may be required. Regardless of whether we aim to create a
    plugin or a custom control, it is crucial to begin with an interface definition.
    A pre-defined interface facilitates the seamless separation of cross-platform
    and native implementations. To implement the interface, we have the option to
    employ either an abstract class or a partial class, allowing us to distribute
    the implementation for each platform across individual files.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of `HybridWebView` opens the door to integrating or reusing
    JavaScript libraries. By crafting hybrid solutions, we can harness the advantages
    of both .NET and the JavaScript ecosystem. `HybridWebView` enables the development
    of .NET solutions that incorporate various JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the current version of the password manager app, we have now
    reached the end of *Part 1* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 2*, we will delve into the Blazor Hybrid app within .NET MAUI, which
    is a novel feature that is not present in Xamarin.Forms. By employing Blazor,
    we can introduce some cutting-edge frontend development methods to .NET MAUI development.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Biometric / fingerprint plugin for Xamarin: [https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI HybridWebView: [https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marked – Markdown parser: [https://marked.js.org](https://marked.js.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xamarin Mobile Application Development for Android: [https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/](https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beginning Xamarin Development for the Mac: Create iOS, watchOS, and Apple tvOS
    apps with Xamarin.iOS and Visual Studio for Mac: [https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/](https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI source code: [https://github.com/dotnet/maui](https://github.com/dotnet/maui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET for Android source code – both .NET for Android and Xamarin.Android are
    built from this repository with different build configurations: [https://github.com/xamarin/xamarin-android](https://github.com/xamarin/xamarin-android)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET for iOS source code – both .NET for iOS and Xamarin.iOS are built from
    this repository with different build configurations: [https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET for Mac source code – .NET for iOS and .NET for Mac share the same codebase
    with different build configurations: [https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WinUI: [https://github.com/microsoft/microsoft-ui-xaml](https://github.com/microsoft/microsoft-ui-xaml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a custom control using handlers: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introducing Shared Class Library – multi-target Xamarin.Forms and .NET MAUI
    from a single project: [https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/](https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_a_review_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
