- en: Chapter 2. What Goes into an Effective UI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the core components of every Android user interface:
    layouts and views. You''ll learn how to add these elements to your Android projects
    and all the different ways you can customize these UI building blocks to meet
    your exact design needs. We''ll also look at how to enhance our UI using strings,
    colors resources, and state lists, and we''ll begin to look at how we can create
    a user interface that looks crisp and clear regardless of the screen it''s being
    displayed on.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we'll be exploring layouts and views in greater detail throughout this
    chapter, the two are intrinsically linked. Before you can add a view to your app,
    you need a layout, and a layout without any views isn't likely to win your app
    any fans.
  prefs: []
  type: TYPE_NORMAL
- en: So, before we dive into the finer details of UI design, let's get an overview
    of how views and layouts come together to create an effective Android UI.
  prefs: []
  type: TYPE_NORMAL
- en: What is a view?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you're already aware, Android apps are made up of Activities. Typically,
    one **Activity** is displayed at a time and this Activity occupies the entire
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Activity is made up of views, which are the most basic component of a
    user interface. Views always occupy a rectangular area, although a view can display
    content of any shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a view?](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some examples of the most commonly used views are `TextView`, `EditText`, `ImageView`, `Button`,
    and `ImageButton`.
  prefs: []
  type: TYPE_NORMAL
- en: What is a layout?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **ViewGroup** is a container that groups other child views and ViewGroup objects
    together.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common examples of a ViewGroup is a layout, which is an invisible
    container that''s responsible for positioning the child elements on the screen.
    For example, **LinearLayout** is a ViewGroup (also sometimes known as a **layout
    manager**) that arranges its child elements (views or ViewGroups) into vertical
    or horizontal rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a layout?](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I'll mostly be focusing on layout managers, as these are the
    ViewGroup you'll typically use most often; but just be aware that other kinds
    of ViewGroup also exist.
  prefs: []
  type: TYPE_NORMAL
- en: Building your UI – XML or Java?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way of defining your user interface (and the views, ViewGroups,
    and layout elements that it contains) is via your project's XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring your UI with XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android provides a straightforward XML vocabulary that gives your user interface
    a human-readable structure, and creates a separation between the code that defines
    your UI and the code that controls your app's behavior. You define your layouts
    in XML in a dedicated layout resource file. This helps to keep both sets of code
    cleaner, and it gives you the ability to tweak and refine your UI without having
    to touch your app's underlying code. For example, you can update your layout to
    support an additional language *without* having to touch the previously-tested
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring your UI in XML also makes it easier to provide alternate layouts;
    for example, at some point, you may want to create an alternative version of your
    layout that's optimized for landscape mode. If you declare your original layout
    in XML, providing a landscape-optimized layout is as easy as creating a `res/layout-land`
    directory, and then filling this folder with XML files that define your app's
    landscape-optimized layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an Android project in Eclipse or Android Studio, the IDE''s
    project creation wizard automatically generates a layout resource file for your
    application''s main activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring your UI with XML](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll find this layout resource file in your project''s `res/layout` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring your UI with XML](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each layout resource file must contain exactly one root element, which can
    either be a view or a ViewGroup. For example, you can use the vertical `LinearLayout`
    element as your layout''s root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `<merge>` element as your root element. We'll cover merging
    in [Chapter 9](ch09.html "Chapter 9. Optimizing Your UI"), *Optimizing your UI*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've defined your layout resource file's root element, you're ready to
    build a view hierarchy by adding objects such as `TextViews`, `Buttons`, and `ImageViews`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a layout resource file, you need to reference it from your application''s
    `onCreate()` callback implementation. For example, open your project''s `MainActivity.java`
    file and you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, your project calls `setContentView()` and passes it the reference to your
    project's automatically-generated resource file; in this instance, it is `R.layout.main_layout`.
    When the user loads your application, `MainActivity` will read this referenced
    layout resource file and display its content to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring your UI programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second option is to create your UI programmatically at runtime. This approach
    isn't generally recommended, as it means that your app's underlying code and the
    UI code get mixed up. So, tweaking an element of your app's UI becomes much more
    difficult than it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes you will need to define certain aspects of your user interface
    programmatically, and occasionally you may even need to define the whole thing
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve already seen, when you define your layout resource in XML, you load
    it from your application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, you're telling your Activity to load the `main_activity.xml` layout resource
    file, but if you're creating your layout programmatically, you need to remove
    this bit of code so that your Activity doesn't go looking for a layout resource
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using both programmatic and XML layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the best solution maybe to use both programmatic and XML layouts.
    This approach helps you to keep some separation between your UI and application
    code by defining the bulk of your UI in XML, while also allowing you to create
    a more dynamic user interface by modifying the state of some onscreen elements
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your app may contain a slideshow that's controlled by a single
    button. When the user taps the button, a new image appears. To create this effect,
    you can define the button in XML, and then add a new image programmatically whenever
    the user taps the button.
  prefs: []
  type: TYPE_NORMAL
- en: Since XML is the easiest and most efficient way of defining your UI, this chapter
    mainly focuses on creating and customizing views, ViewGroups, and layouts in XML.
    However, occasionally you may need to define parts of your UI programmatically,
    so I'll also include some snippets of Java along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Deep dive – exploring layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have an idea of how views, ViewGroups, and Layouts come together
    to create a user interface, and how to create your user interface programmatically
    and in XML, it''s time to look at each of Android''s most common UI components
    in more detail. We''ll start with the component that pretty much lays the foundation
    of any user interface: a layout container.'
  prefs: []
  type: TYPE_NORMAL
- en: The Android platform supports a range of layouts, so your first task is deciding
    which layout best meets your design needs. If you're struggling to make this decision,
    keep in mind that you can nest layouts within one another to create your perfect
    layout container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't go overboard with the nesting as this can have a negative impact on your
    app's performance. If you find yourself nesting multiple layouts, then this could
    be a sign that you're using the wrong kind of layout!
  prefs: []
  type: TYPE_NORMAL
- en: Before you create any kind of layout, here are a few rules, regulations, and
    attributes that you need to get to grips with.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the size of your layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you create a layout, you need to tell the Android system how big this
    layout should be.
  prefs: []
  type: TYPE_NORMAL
- en: The XML attributes you use to define the size of your layouts are `android:layout_height`
    and `android:layout_width`. As their names suggest, these attributes set the height
    and width of your layouts respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both accept the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: A supported keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android screens come in lots of different sizes. One of the easiest ways of
    ensuring your user interface is flexible enough to cope with all these differently-sized
    screens is to set your layout''s width and height to one of the following supported
    keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`match_parent`: This makes the height or width expand to completely fill the
    available onscreen space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrap_content`: This sets the height or width to the minimum size required
    to fit the element''s content and no larger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use `match_parent` and `wrap_content` to set the size of other
    onscreen elements, including views and ViewGroups.
  prefs: []
  type: TYPE_NORMAL
- en: A dimension value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, you can set the size of your layout using one of the units of
    measure supported by the Android system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Density-independent pixels (dp)**: This is an abstract unit which is based
    on the screen''s physical density. The dp unit is relative to 1 physical pixel
    on a 160 dots per inch screen. At runtime, Android automatically adjusts the number
    of pixels used to draw 1 dp by a factor that''s appropriate for the current screen''s
    dp. Using density-independent measurements is a straightforward solution to creating
    a UI that can adjust automatically across a range of screen sizes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An absolute unit**: Android supports a number of absolute units of measure
    (specifically pixels, millimeters, and inches), but you should avoid defining
    your layout using absolute sizes as this makes your UI very rigid, and can prevent
    it from resizing itself to suit a range of screens. Unless you have a *very good
    reason* not to, stick to relative measurements, such as dp, `match_parent`, and
    `wrap_content`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the layout size programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also set the size of your layout programmatically by creating the `LayoutParams`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then set its width and height as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Exploring different layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know how to create layouts in XML and Java, and how to set their
    height and width, you can take a closer look at two of the most commonly used
    layouts: the straightforward and easy-to-use `LinearLayout` layout and the incredibly
    flexible `RelativeLayout` layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything you need to know about LinearLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LinearLayout` aligns all its children in a single horizontal or vertical row,
    stacking them one after the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You set the direction of your `LinearLayout` layout using either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:orientation="horizontal."`: The views are placed next to each other
    in *rows*. A horizontal `LinearLayout` layout is only ever one row high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:orientation="vertical."`: The views are placed below each other in
    *columns*. A vertical `LinearLayout` layout only ever has one child per row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple `LinearLayout` layout with a horizontal orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how this horizontal `LinearLayout` layout appears on an Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Everything you need to know about LinearLayout](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the same `LinearLayout` based UI with the orientation set to `android:orientation="vertical"`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Everything you need to know about LinearLayout](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Everything you need to know about RelativeLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RelativeLayout` is one of the most flexible layouts at your disposal, giving
    you the freedom to position every child element based on its relationship with
    any other child element, with its parent container.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, you have the flexibility to position `TextView` so that it aligns
    with the edge of the `RelativeLayout` container, and then you can position a `Button`
    100 density-independent pixels above `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using RelativeLayout to optimize your UI**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to giving you control over where each element appears on the screen,
    `RelativeLayout` can improve your app's overall performance by reducing nesting.
    If you find yourself using several nested `LinearLayouts`, you maybe able to flatten
    your layout hierarchy by replacing them with a single `RelativeLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `RelativeLayout` is all about giving you the flexibility to position your
    UI elements wherever you want, it's no surprise that this layout supports a long
    list of attributes that let you position your UI elements relative to their parent
    container and relative to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Relative to the parent container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the following attributes accept the `true` value; for example, `android:layout_alignParentTop="true"`
    and `android:layout_alignParentStart="true."`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:layout_alignParentTop`: This aligns the top edge of a view with the
    top edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignParentBottom`: This aligns the bottom edge of a view with
    the bottom edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_centerInParent`: This centers a view horizontally and vertically
    within its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignParentRight`: This aligns the right edge of a view with
    the right edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignParentLeft`: This aligns the left edge of a view with
    the left edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_centerHorizontal`: This centers a view horizontally within
    its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_centerVertical`: This centers a view vertically within its
    parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignParentStart`: This aligns the start edge of a view with
    the start edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignParentEnd`: This aligns the end edge of a view with the
    end edge of its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignWithParentIfMissing`: If the view references an element
    that''s missing, this attribute will align the view with the parent instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Relative to the parent container](img/image_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Relative to other elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also position UI elements relative to other onscreen elements; for example,
    you may want to position the `back_button` view to the left of `forward_button`
    and position `titleTextBox` above `subheadingTextBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the following attributes should reference the ID of the element you''re
    using as your reference point (we''ll look at IDs in more detail shortly, but
    essentially a view''s ID is the value of its `android:id` element in your layout
    resource file, for example, the ID of `android:id ="@+id/viewName"` is `viewName`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:layout_above`: This places a view above the specified element; for
    example, `android:layout_above="@+id/subheadingTextBox"` will place the UI element
    above `subheadingTextBox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_below`: This places a view below the specified element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_toLeftOf`: This places a view to the left of the specified
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_toRightOf`: This places a view to the right of the specified
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_toStartOf`: This aligns the end edge of a view with the start
    of the specified element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_toEndOf`: This aligns the start edge of a view with the end
    edge of the specified element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Relative to other elements](img/image_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aligning with other elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also position a UI element by specifying how it aligns with other on-screen
    elements. Again, the value for all the following attributes is the ID of the element
    you''re using as your reference point:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:layout_alignBottom`: This aligns the bottom of a view element with
    the bottom of the specified onscreen element. For example, `android:layout_alignBottom="@+id/back_button"`
    aligns the bottom of a UI element with the bottom of `back_button`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignLeft`: This aligns the left edge of a view with the left
    edge of the specified element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignRight`: This aligns the right edge of a view with the
    right edge of the specified element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignTop`: This aligns the top edge of a view with the top
    edge of the specified element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignStart`: This aligns the start edge of a view with the
    start edge of the specified element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_alignBaseline`: This attribute is a bit different. **Baseline**
    is a typography term for the invisible line that text sits on. So, this attribute
    aligns a view''s baseline with the baseline of the specified element. For example,
    if you have two `TextViews`, you may want to use `alignBaseline` to create the
    impression that the text in both views is written on the same invisible line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views are the basic building blocks of a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time you''ll create view objects by adding them to your Activity''s
    corresponding layout resource file. You can either edit the XML code directly,
    or you may want to drag UI elements from your IDE''s palette and drop them onto
    the UI preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views](img/image_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You also have the option of creating views programmatically. For example, if
    you wanted to instantiate a `TextView` programmatically, you would add `TextView`
    to your Activity''s `onCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the ID attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ID gives you a way of identifying individual views within your layout. For
    example, if you create two buttons, you can distinguish between them by assigning
    them the IDs `yesButton` and `noButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You assign an ID to a view using the `android:id` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the ID to reference this particular view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the ID to locate a view programmatically using `findViewById(id)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once this method returns the desired view, you can interact with the view programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a view's size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way you need to set the size of your layout container, you need
    to set the size of all the views you add to your layout resource file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that you can use exactly the same attributes and values, which
    means you can add `android:layout_width` and `android:layout_height` to your layout
    resource file, and then choose from the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wrap_content**: This sets the view''s height or width to the minimum size
    required to accommodate the view''s content. For example, if you apply `wrap_content`
    to a button that contains a text label, the system will size the button so it''s
    *just* big enough to contain the button''s text label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**match_parent**: This expands the view''s height or width to fill all the
    available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density-independent pixels (dp):** When you assign a dp measurement, the
    Android system scales the view up or down based on the specific density of the
    user''s screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An absolute unit**: Although this is not recommended, you can also use absolute
    units of measurements: pixels, millimeters, or inches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android gravity and layout gravity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gravity attribute specifies how an object should be positioned along the
    *X* and *Y* axis inside its enclosing object. This may sound straightforward,
    but there''s a catch: you''ll encounter two different gravity attributes in Android.
    Although they look similar, they can actually yield very different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:gravity`: This positions the content that''s inside a view, for example,
    the text inside a `TextView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:layout_gravity`: This positions a child view inside its parent container,
    for example, a `TextView` inside a `LinearLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both accept a wide range of values, including several values that *won''t*
    change the size of the object you''re applying the gravity attribute to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top`: This positions the object at the top of its parent container. For example,
    `android:gravity="top"` will position the text at the top of `TextView`, while
    `android:layout_gravity="top"` will position `TextView` at the top of `LinearLayout`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Left`: This positions the object to the left-hand side of its parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center_vertical`: This positions the object in the vertical center of its
    parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start`: This positions the object at the beginning of its parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both `gravity` attributes also support several values that *do* alter the object''s
    size, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fill_vertical`: This expands the object vertically, so it completely fills
    its parent container. For example, `android:gravity="fill_vertical"` will expand
    an image vertically to fill its `ImageView` container, while `android:layout_gravity="fill_vertical"`
    will expand `ImageView` vertically to fill its `RelativeLayout` container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill_horizontal`: This expands the object horizontally and vertically so that
    it completely fills its parent container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full list of supported values, see [http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity](http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity).
  prefs: []
  type: TYPE_NORMAL
- en: You assign gravity programmatically using the `setGravity` attribute, for example,
    `Gravity.CENTER_HORIZONTAL`. You could also use `setHorizontalGravity` and `setVerticalGravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the background – working with color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to background, some views have a completely transparent background,
    such as `TextViews`, while others have a standard background color, for example
    buttons, which are grey by default.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not a fan of a view's default background, you can always change it.
    Android gives you several options for adding a splash of color to your UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the Android system does support a number of colors out of the box,
    so if you want to use any of the following hues, then you''re in luck, because
    the Android system has already done all the hard work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`black`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`white`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_blue_bright`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_blue_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_blue_light`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_green_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_green_light`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_orange_light`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_orange_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_purple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_red_dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`holo_red_light`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`darker_gray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply any of these ready-made color resources to a view, add the `android:background`
    attribute, but set its value to `"@android:/color"` followed by the color of your
    choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android also supports values such as `primary_text_dark` and `widget_edittext_dark`
    for specific UI elements. You'll find the complete list of predefined colors in
    the official Android docs at [http://developer.android.com/reference/android/R.color.html](http://developer.android.com/reference/android/R.color.html).
  prefs: []
  type: TYPE_NORMAL
- en: However, this list is pretty limited! Sooner or later Android's predefined colors
    just aren't going to cut it, and you'll want to create your own color resources,
    which means using hex codes.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a particular shade in mind, you can usually find its hex code by
    performing a quick Google search, for example, by searching for `cyan hex code`
    or `light pink hex code`. Alternatively, you can go window shopping by browsing
    the Android style guide, which contains a wide range of colors and their corresponding
    hex codes. This is available at [https://www.google.com/design/spec/style/color.html#color-color-palette](https://www.google.com/design/spec/style/color.html#color-color-palette).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your hex code, you can take the quick and easy route of entering
    the code directly into your layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This may *seem* quick, but it might just end up costing you more time in the
    long run. Since consistency is a big part of providing a great user experience,
    chances are that you'll use the same colors multiple times throughout your application,
    and typing out the entire hex code every single time you want to use that color
    can really add up.
  prefs: []
  type: TYPE_NORMAL
- en: Although it may require a bit of initial effort, most of the time it makes sense
    to define your colors as color resources in your project's `res/values/colors.xml`
    file. You can then reference these color resources as many times as you want without
    having to type out entire hex codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your project doesn''t contain the `colors.xml` file, you can create one
    by right-clicking on your project''s `values` folder and selecting **New**, followed
    by **Values resource file**. Give your file the name of `colors.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the background – working with color](img/image_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `colors.xml` file and define all the colors you want to use in your
    app using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this color resource anywhere in your app, including in the
    background of your views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also change the background of your entire UI by adding the `android:background`
    attribute to your layout container such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use images as the backdrop to your views, whether it''s
    a simple textured background image or a high definition photo. We''ll cover images
    in greater detail when we take a look at `ImageViews`, but as a quick overview,
    you just need to add the image to your project''s `res/drawable` folder and then
    reference the image in your layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you want to set your app's background programmatically, use the `setBackgroundResource`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a weight value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you're positioning views inside `LinearLayout`, you can control how much
    space each view occupies onscreen by assigning it a weight value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign weight values to your views, any remaining space in the layout
    is assigned to your views in the proportion of their declared weight. For example,
    imagine your layout contains three buttons with different weight values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Button3` is declaring that it''s more important than `Button1` and `Button2`,
    so it''ll be assigned half of any remaining space, while `Button1` and `Button2`
    have to share the rest of the available space equally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assigning a weight value](img/image_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just be aware that other attributes may interact with your `layout_weight` values.
    For example, imagine your layout contains three `TextViews` and all of them are
    set to `android:layout_width="wrap content"`. In this scenario, the Android system
    calculates how wide each `TextView` needs to be in order to accommodate their
    text and *only* then does it divide up the remaining space. So, if one `TextView`
    needs to accommodate much more text than the other two `TextView`, this will have
    an impact on your weight results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All views have a default weight of 0, unless you specify otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing view objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to add view objects to your layout is via the layout resource
    file in your project's `res/layout` folder, although you can also add views programmatically
    as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few sections, I'll show you how to create some of Android's most
    commonly used views, specifically `TextViews`, `EditText`, `ImageViews`, `Buttons`,
    and `ImageButtons`. Once you've created each view, I'll show you how to configure
    that view so it looks and functions *exactly* as you want it to.
  prefs: []
  type: TYPE_NORMAL
- en: TextView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not be the most exciting part of your user interface, but the vast majority
    of Android apps feature some kind of text. You display text to your users via
    `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `TextView`, add the `<TextView>` tag to your project''s layout resource
    file, and then tell the `TextView` what text it should display either by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding the text directly to the layout**: This is pretty straightforward.
    Just add the `android:text` attribute and your text to the `TextView` XML code,
    for example, `android:text="Hello world!"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referencing a string resource**: Most of the time, if your app needs to display
    text, then this text belongs in your project''s resources and *not* in your actual
    application code. This separation helps to keep your app''s code clean and readable,
    and it also means that you can tweak and change your app''s text at any point
    without ever having to touch your app''s underlying code. To create a string resource,
    open your project''s `res/values/strings.xml` file and add your text in the following
    format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then reference this string resource from your layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is all you need to know in order to display basic text, and sometimes this
    may be enough. However, text does have the potential to be a bit dry and boring!
    If you want to create more visually appealing text, you have several options.
  prefs: []
  type: TYPE_NORMAL
- en: Brightening up your text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `android:textColor` attribute to change the color of the text
    inside a `TextView`. To reference one of the default colors supported by the Android
    system, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re referencing a color that you defined yourself in your project''s
    `res/values/colors.xml` file, the value is laid out slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you want to set the color of your `TextView` programmatically, use the `setTextColor()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the size of your text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can make your text larger or smaller using `android:textSize`.
  prefs: []
  type: TYPE_NORMAL
- en: Once again you need to remember that Android screens come in all sorts of different
    sizes, and your text needs to be easily readable regardless of the screen it's
    being displayed on.
  prefs: []
  type: TYPE_NORMAL
- en: To further complicate things, Android users can actually change the size of
    the font that's displayed on their device by opening their device's **Settings**,
    tapping **Display,** and selecting **Font Size**. This is a really useful feature
    for people who have vision problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of ensuring that your text is flexible enough to adapt to the
    user''s font preferences and screen size is to use scale-independent pixels (`sp`)
    units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Android also supports three relative font size styles that you may want to
    use in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextAppearance.Small`, such as `style="@android:style/TextAppearance.Small."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextAppearance.Medium`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextAppearance.Large`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasizing your text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add bold or italic emphasis to your text using the `android:textStyle`
    attribute. The possible values are normal, bold, and italic, or you can combine
    bold and italic by separating the two values with a pipe character (`android:textStyle="bold|italic"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Emphasizing your text](img/image_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the typeface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Android applies the normal typeface to your text, but the system
    also supports `sans`, `monospace`, and `serif` typefaces, which you set using
    `android:typeface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting the typeface](img/image_02_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To set the typeface programmatically, you need to use the `setTypeFace` method.
  prefs: []
  type: TYPE_NORMAL
- en: How many lines?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the content of your `TextView` will run across multiple lines depending
    on how much text it has to display. If you want more control over the span of
    your `TextView`, you have a few options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:lines`: This makes `TextView` exactly *X* number of lines tall, for
    example, `android:lines="2"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:minLines.` At a minimum, `TextView` will be this many lines tall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:maxLines`: This limits the `TextView` to this many lines tall'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EditText
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `TextViews` are great for displaying text, if you want the user to be
    able to input text, you should use `EditText` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common examples of `EditTexts` in action is a form that requests
    user data. In this example, each input field is a separate `EditText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how this simple form looks on the user''s device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EditText](img/image_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the `EditText` class is derived from the `TextView` class, many of the
    `TextView` attributes are also applicable to `EditText`, including `textColor`,
    `textSize`, `textStyle`, and `typeface`. However, `EditText` also supports a range
    of XML attributes that are specific to the `EditText` class.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling keyboard behavior - setting the inputType
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, when the user taps the `EditText` field, the standard keyboard appears
    and they can enter whatever characters they like. However, you may want to restrict
    the kind of data users can enter into your `EditText` fields using the `android:inputType
    attribute`.
  prefs: []
  type: TYPE_NORMAL
- en: This restriction prevents the user from entering invalid data, but some `inputType`
    values also prompt the Android system to optimize the virtual keyboard for a particular
    kind of content. For example, if you specify that the `EditText` `inputType` value
    is a phone number (`android:inputType="phone"`) the Android system will display
    the numerical keyboard, which makes it easier for the user to input the required
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Some `inputType` values also prompt the keyboard into other useful behavior;
    for example, if you set `inputType` to `textCapWords`, the keyboard will capitalize
    every new word automatically. This is handy when you're asking the user to enter
    data that should always be capitalized, such as their name or address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the different `inputType` values you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text`: This displays the standard text keyboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textEmailAddress`: This displays the standard text keyboard with the addition
    of the `@` character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textUri`: This displays the standard text keyboard with the addition of the
    `/` character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: This displays the basic numerical keyboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phone`: This displays the phone-style keyboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the following values display the standard text keyboard, but modify other
    keyboard behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`textCapSentences`: This automatically capitalizes the first letter of every
    new sentence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textCapWords`: This automatically capitalizes every word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textAutoCorrect`: This automatically corrects commonly misspelled words.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textPassword`: This masks the user''s password by transforming every inputted
    character into a dot. This is the behavior you typically encounter when entering
    passwords on your Android device. Another way of creating this masking effect
    is via the XML attribute `android:password="true."`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textMultiLine`: By default, the `EditText` field is constrained to a single
    line. This attribute allows the user to enter multiple lines of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also combine multiple values using the pipe character. For example,
    if you''re asking the user to create a password, you could automatically capitalize
    every new word while also masking their input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To specify keyboard behavior programmatically, use the `setRawInputType` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we're on the subject of controlling user input, you can restrict what
    numbers the user can enter into an `EditText` using `android:digits` (`android:digits="12345."`).
  prefs: []
  type: TYPE_NORMAL
- en: android:imeOptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user has entered information into the `EditText` field, they'll usually
    confirm their input by tapping the action key that appears in place of the keyboard's
    usual carriage return key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you *don''t* specify what action key the system should display, the Android
    system defaults to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionNext`: If there''s at least one focusable field to move on to, the system
    displays the **Next** action key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionDone`: If there''s no subsequent focusable fields, the system displays
    the **Done** key. In our `form` example, the **Done** key would appear once the
    user has completed the final `EditText` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to override this default behavior and specify which
    action key the keyboard should display. You can do this using the `android:imeOptions`
    attribute and one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actionGo`: This displays the **Go** key (`android:imeOptions="actionGo")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionNext`: This displays the **Nex**t key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionDone`: This displays the **Done** key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionSearch`: This displays the **Search** key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionSend`: This displays the **Send** key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving the user a hint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though `EditTexts` are designed to collect user input, you may want to
    prompt the user for a specific input by displaying temporary, greyed-out text
    in your `EditText` fields. These hints are useful when it isn't immediately obvious
    what information the user is supposed to enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You display hints using the `android:hint` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the hint into your layout resource file directly (`android:hint="Please
    enter your password"`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and reference a string resource (`android:hint="@string/messageHint."`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are a handy way of conveying information to your users without forcing
    them to read lots of on-screen text. Although you can add images to lots of different
    areas within your app, (such as your layout's background and the background of
    onscreen elements, such as buttons), the Android SDK provides a dedicated view
    for displaying images, called `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed how you can use density-independent and other relative
    units of measure to create a user interface that displays correctly across a range
    of different screens. However, ensuring your images look crisp and clear across
    a range of different screen sizes isn't quite so straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: This makes `ImageView` one of the more complicated views, but since images are
    such an integral part of most Android UIs, it's well worth taking the time to
    properly master Android's `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll show you how to add **drawables** to your UI and the steps
    you should take to ensure these images display properly across the full range
    of possible screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A drawable just means "something that can be drawn on the screen," and is often
    used to describe your app's graphical content.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple screens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get the tricky stuff out of the way first: how to create images that
    display correctly across a wide range of different screens.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the Android system scales your content automatically to fit the current
    screen configuration, you shouldn't rely on the system to do all the hard work
    for you, *especially* when it comes to `ImageViews` as this can result in blurry
    or pixelated images.
  prefs: []
  type: TYPE_NORMAL
- en: To provide the best possible user experience, you'll need to provide alternate
    versions of all the images you use in your app. These versions should be optimized
    for different screen densities.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you don't have to provide images for *every* screen density
    imaginable, as the Android system groups all possible screen densities into generalized
    density spans. As long as you provide a version for each density span, the Android
    system will choose the version that's the best match for the current screen configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android supports five main generalized screen densities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low**: `ldpi 120dpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medium**: `mdpi 60dpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High**: `hdpi 240dpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra-high**: `xhdpi 320dpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra-extra-high**: `xxhdpi 480dpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android actually supports a sixth screen density: extra-extra-extra-high, also
    known as `xxxhdpi`. This `640dpi` density span is a bit different from the others
    as it *only* applies to your application''s launcher icon. Some devices, such
    as tablets, may display extra-large app icons in their launcher. To make sure
    your app''s icon doesn''t end up looking fuzzy on a large screen with an `xxxhdpi`
    display, you should supply an extra-extra-extra high density version of your app''s
    icon. You don''t need to provide `xxxhdi` versions of any other UI elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different screen densities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, how do you let Android know which image is optimized for `hdpi` displays,
    and which image is optimized for `xhdpi` displays? The answer is to create directories
    that are tagged with the `ldpi`, `mdpi`,  `hdpi`,  `xhdpi`,  `xxhdpi`, and  `xxxhdpi`
    qualifiers. Android will recognize that these directories contain resources that
    target a specific screen density, and then select an image from the appropriate
    directory based on the current screen configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an Android project in Eclipse or Android Studio, the project
    typically contains the default `res/drawable` directory only, so you''ll need
    to create the following directories manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drawable-ldpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-mdpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-hdpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-xhdpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable- xxhdp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-xxxhdpi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, this directory should contain the extra-extra-extra-high density version
    of your app's launcher icon only.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these density-specific directories, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on your project's `res` folder and select **New**, followed by **Android
    resource directory**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that appears, open the **Resource type** dropdown and select **Drawable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Available qualifiers** section, add **Density** as **Chosen qualifier**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Density** dropdown and select the desired density from the list,
    for example, **Low Density** if you're creating the `drawable-ldpi` directory,
    or **XXX-High density** if you're creating a `drawable-xxxhdpi` directory. You'll
    notice that when you select the density, **Directory name** gets updated automatically:![Supporting
    different screen densities](img/image_02_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you're happy with the information you've entered, click **OK**. Your IDE
    will then create the new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat! You'll typically want to create a directory for each of the generalized
    screen densities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''re working with a project in Android Studio, sometimes you may create
    all your density-specific directories and then realize that none of them are appearing
    in Android Studio''s **Project** view. If this happens, the problem may be that
    you have the **Android** view selected instead of **Project** view. To switch
    views, click on the **Android** label in Android Studio''s **Project** view, and
    then select **Project** from the drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting different screen densities](img/image_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice your project structure has changed. Open the `app/src/main/res`
    folder, and you will see all the density-specific directories you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating density-specific images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you've updated your project structure, it's time to actually create
    those optimized images and add them to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android supports several different image types, but you''ll typically use one
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitmaps**: Android supports bitmap files in three formats: `.png` (preferred),
    `.jpg` (acceptable), or if you really *must*, `.gif` (discouraged).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nine-patch file**: This is a `.png` file with a difference! Nine-patch files
    allow you to define stretchable regions that help your image resize more smoothly.
    We''ll explore nine-patch images in more detail in the later chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key to creating alternate bitmaps and nine-patch files is to adhere to
    a 3:4:6:8:12:16 scaling ratio. For example, if you have an image that''s 68 x
    68 pixels and targets medium-density screens, you''d need to create the following
    alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LDPI**: 51 x 51 pixels (0.75% of the original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MDPI**: 68 x 68 pixels (original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HDPI**: 102 x 102 pixels (150% of the original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XHDPI**: 136 x 136 (200% of the original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XXHDPI**: 204 x 204 (300% of the original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XXXHDPI**: 272 x 272 (400% of the original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're creating your alternate images, you *must* use the same filename
    for each version of the image. This is essential if the Android system is going
    to recognize these files as alternate versions of the same image.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is placing each file inside the appropriate directory.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ImageView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the correct `drawable` directory structure and providing multiple versions
    of the same image may feel like a lot of work, but once you've done all this groundwork,
    displaying `drawable` content in `ImageView` is a fairly straightforward task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, you''ll create your `ImageView` by adding an `<ImageView>`
    element to your Activity''s layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note the `android:src` attribute. This is how you tell your `ImageView` what
    `drawable` to display. Assuming you've provided several versions of the `myImage`
    file, the Android system checks each `drawable` directory for the most suitable
    version, and then it displays this image.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd prefer to set your `ImageView` content programmatically, you can use
    the `setImageResource()` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons and ImageButtons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Buttons` (and by extension, `ImageButtons)` are UI components that react to
    the user tapping the screen. Whenever you add a button to your UI, it should be
    immediately clear to the user what this button will do when they touch it.'
  prefs: []
  type: TYPE_NORMAL
- en: While you *could* inform the user about a button's purpose with an accompanying
    `TextView` (something along the lines of *tap the button below to move onto the
    next screen*) this is wordy and inefficient. Most of the time, you'll want to
    communicate a button's purpose by adding a label to this button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android provides you with several labeling options:'
  prefs: []
  type: TYPE_NORMAL
- en: A text label, for example **Next**, **Submit**, or **Cancel**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An image icon, such as a checkmark or a cross icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both! If the button represents an unusual, unexpected, or complicated action,
    you may want to clear up any potential confusion by labeling the button with both
    text and an image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Buttons and ImageButtons](img/image_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Depending on whether you want your button to display text, an icon, or both,
    you can add a button to your layout resource file in one of three ways.
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons with text labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a basic button with a text label, insert a `<Button>` element into
    your layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You set the button's text label using the `android:text` attribute. As with
    `TextViews`, you can either insert the text into your layout directly (`android:text="Submit"`)
    or you can create a string resource in your project's `res/values/strings.xml`
    file, and then reference the string resource (`android:text="@string/submitText"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the button''s text programmatically, use `setText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Creating buttons with image labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, `ImageButton` is a button with an image label.
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert `ImageButton` into your UI, you need to add the `<ImageButton>` tag
    to your layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Recognize the `android:src` attribute? It's referencing a `drawable` resource,
    in exactly the same way an `ImageView` references a `drawable` reasource.
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons with text and image labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to leave the user in no doubt about what''ll happen when they touch
    a button, you can label that button with both text and an image. This involves
    utilizing the `Button` class with the addition of `android:drawableLeft`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Change your button''s background**'
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like these three options aren't enough, you can also change a button's
    background using `android:background` and then referencing a color value or an
    image.
  prefs: []
  type: TYPE_NORMAL
- en: State list resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your typical button has three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Default`: This button is neither pressed nor focused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pressed`: This button is in a pressed state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Focused`: This button is currently in focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the button attributes we've discussed so far (text labels, image labels,
    and backgrounds) apply to a button element regardless of its current state. But
    sometimes you'll want your button to give the user visual clues about its current
    state. For example, when the user taps a button, you may want it to briefly display
    a darker color while it's in its pressed state, so users know that their devices
    have successfully registered the touch event.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your button to react to its current state, you need to create a
    state list resource, which is an XML file that defines three different images
    or colors to use for each of the button's states.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this state list resource, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create three drawables to use as your button's background. These drawables represent
    each of the button's states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give each `drawable` a name that reflects the state it represents, for example,
    `button_pressed`, or `button_default`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add these drawables to the appropriate `res/drawable` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new XML file in your project's `res/drawable` directory, by right-clicking
    on the `drawable` directory and selecting **New**, followed by **Drawable resource
    file**. Give the XML file a descriptive name, such as `button_states`, and then
    click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your new `drawable` resource file and define all the drawables you want
    to use for each state by adding them as separate `<list>` elements inside a single
    `<selector>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''re defining which `drawable` the button should use
    when it''s in each state:'
  prefs: []
  type: TYPE_NORMAL
- en: When `pressed = true`, the button should use the `button_pressed` drawable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When `focused = true`, the button should use the `button_focused` drawable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the button isn't pressed or focused, it should use the `button_default` drawable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the `<item>` elements in your state list resource is important,
    as when you reference this state list, the system moves through the `<item>` elements
    in order and uses the first `<item>` element that's applicable to the button's
    current state. Since the default state is *always* applicable, you must always
    place the default `drawable` at the end of the list, to ensure it's only used
    if the system has checked and discarded `android:state_pressed` and `android:state_focused`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a state list resource to a button, you need to reference it as a single
    `drawable` in your Activity''s layout resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create state list resources that use colors instead of images.
    These kinds of state lists are known as **color state list resources**. You use
    the same `<selector>` and `<item>` elements; the only difference is that each
    `<item>` element references a color rather than a `drawable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the most commonly used views and layouts,
    and we looked at all the different ways to customize them to suit our specific
    design needs.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there are views and layouts we haven't covered yet, many of the
    attributes we've explored in this chapter are applicable to the views and layouts
    that we'll encounter in later chapters, for example, `layout_width`, `android:src`,
    `android:id` and the relative units of measure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll expand on using resources such as strings, nine-patch
    images, colors, and state lists, and also take a look at some new resources, including
    arrays and dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you''ll learn all about an important aspect of UI design that we haven''t
    touched on yet: *fragments*.'
  prefs: []
  type: TYPE_NORMAL
