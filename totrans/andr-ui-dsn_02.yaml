- en: Chapter 2. What Goes into an Effective UI?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：有效的UI包含哪些内容？
- en: 'In this chapter, we''ll look at the core components of every Android user interface:
    layouts and views. You''ll learn how to add these elements to your Android projects
    and all the different ways you can customize these UI building blocks to meet
    your exact design needs. We''ll also look at how to enhance our UI using strings,
    colors resources, and state lists, and we''ll begin to look at how we can create
    a user interface that looks crisp and clear regardless of the screen it''s being
    displayed on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看每个Android用户界面的核心组件：布局和视图。您将学习如何将这些元素添加到您的Android项目中，以及您可以根据自己的设计需求自定义这些UI构建块的所有不同方式。我们还将探讨如何使用字符串、颜色资源和状态列表来增强我们的UI，并开始探讨如何创建一个无论在哪个屏幕上显示都清晰明亮的用户界面。
- en: Although we'll be exploring layouts and views in greater detail throughout this
    chapter, the two are intrinsically linked. Before you can add a view to your app,
    you need a layout, and a layout without any views isn't likely to win your app
    any fans.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章中更详细地探讨布局和视图，但这两者是内在联系的。在您向您的应用添加视图之前，您需要一个布局，而没有视图的布局不太可能赢得您的应用粉丝。
- en: So, before we dive into the finer details of UI design, let's get an overview
    of how views and layouts come together to create an effective Android UI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们深入UI设计的细节之前，让我们先概述一下视图和布局是如何结合在一起创建有效的Android UI的。
- en: What is a view?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是视图？
- en: As you're already aware, Android apps are made up of Activities. Typically,
    one **Activity** is displayed at a time and this Activity occupies the entire
    screen.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，Android应用由Activity组成。通常，一次只显示一个**Activity**，并且这个Activity占据整个屏幕。
- en: 'Each Activity is made up of views, which are the most basic component of a
    user interface. Views always occupy a rectangular area, although a view can display
    content of any shape:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Activity都由视图组成，视图是用户界面的最基本组件。视图总是占据一个矩形区域，尽管视图可以显示任何形状的内容：
- en: '![What is a view?](img/image_02_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![什么是视图？](img/image_02_001.jpg)'
- en: Some examples of the most commonly used views are `TextView`, `EditText`, `ImageView`, `Button`,
    and `ImageButton`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的视图示例包括`TextView`、`EditText`、`ImageView`、`Button`和`ImageButton`。
- en: What is a layout?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是布局？
- en: A **ViewGroup** is a container that groups other child views and ViewGroup objects
    together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewGroup**是一个容器，它将其他子视图和ViewGroup对象组合在一起。'
- en: 'One of the most common examples of a ViewGroup is a layout, which is an invisible
    container that''s responsible for positioning the child elements on the screen.
    For example, **LinearLayout** is a ViewGroup (also sometimes known as a **layout
    manager**) that arranges its child elements (views or ViewGroups) into vertical
    or horizontal rows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ViewGroup最常见的一个例子是布局，这是一个负责在屏幕上定位子元素的不可见容器。例如，**LinearLayout**是一个ViewGroup（有时也称为**布局管理器**），它将子元素（视图或ViewGroup）排列成垂直或水平行：
- en: '![What is a layout?](img/image_02_002.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![什么是布局？](img/image_02_002.jpg)'
- en: In this chapter, I'll mostly be focusing on layout managers, as these are the
    ViewGroup you'll typically use most often; but just be aware that other kinds
    of ViewGroup also exist.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将主要关注布局管理器，因为这些是您通常最常使用的ViewGroup；但请注意，也存在其他类型的ViewGroup。
- en: Building your UI – XML or Java?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的UI——XML还是Java？
- en: The easiest way of defining your user interface (and the views, ViewGroups,
    and layout elements that it contains) is via your project's XML file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定义用户界面（以及它包含的视图、ViewGroup和布局元素）的最简单方法是通过您项目的XML文件。
- en: Declaring your UI with XML
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XML声明你的UI
- en: Android provides a straightforward XML vocabulary that gives your user interface
    a human-readable structure, and creates a separation between the code that defines
    your UI and the code that controls your app's behavior. You define your layouts
    in XML in a dedicated layout resource file. This helps to keep both sets of code
    cleaner, and it gives you the ability to tweak and refine your UI without having
    to touch your app's underlying code. For example, you can update your layout to
    support an additional language *without* having to touch the previously-tested
    code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一种直接的XML词汇表，为您的用户界面提供了一个可读的结构，并在定义UI的代码和控制应用行为的代码之间创建了一个分离。您在专门的布局资源文件中定义布局。这有助于保持两组代码的整洁，并让您能够在不触及应用底层代码的情况下调整和优化您的UI。例如，您可以在不触及先前测试的代码的情况下更新布局以支持额外的语言。
- en: Declaring your UI in XML also makes it easier to provide alternate layouts;
    for example, at some point, you may want to create an alternative version of your
    layout that's optimized for landscape mode. If you declare your original layout
    in XML, providing a landscape-optimized layout is as easy as creating a `res/layout-land`
    directory, and then filling this folder with XML files that define your app's
    landscape-optimized layouts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中声明UI也使得提供备用布局变得更容易；例如，在某个时候，您可能希望创建一个针对横屏模式优化的布局的替代版本。如果您在XML中声明原始布局，提供横屏优化的布局就像创建一个`res/layout-land`目录，然后在这个文件夹中填充定义您的应用横屏优化布局的XML文件一样简单。
- en: 'When you create an Android project in Eclipse or Android Studio, the IDE''s
    project creation wizard automatically generates a layout resource file for your
    application''s main activity:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Eclipse或Android Studio中创建Android项目时，IDE的项目创建向导会自动为应用程序的主活动生成一个布局资源文件：
- en: '![Declaring your UI with XML](img/image_02_003.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![使用XML声明UI](img/image_02_003.jpg)'
- en: 'You''ll find this layout resource file in your project''s `res/layout` folder:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目的`res/layout`文件夹中找到此布局资源文件：
- en: '![Declaring your UI with XML](img/image_02_004.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用XML声明UI](img/image_02_004.jpg)'
- en: 'Each layout resource file must contain exactly one root element, which can
    either be a view or a ViewGroup. For example, you can use the vertical `LinearLayout`
    element as your layout''s root element:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布局资源文件必须恰好包含一个根元素，它可以是视图或`ViewGroup`。例如，您可以使用垂直的`LinearLayout`元素作为布局的根元素：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the `<merge>` element as your root element. We'll cover merging
    in [Chapter 9](ch09.html "Chapter 9. Optimizing Your UI"), *Optimizing your UI*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`<merge>`元素作为根元素。我们将在第9章[优化您的UI](ch09.html "第9章。优化您的UI")中介绍合并。
- en: Once you've defined your layout resource file's root element, you're ready to
    build a view hierarchy by adding objects such as `TextViews`, `Buttons`, and `ImageViews`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了布局资源文件的根元素，您就可以通过添加`TextViews`、`Buttons`和`ImageViews`等对象来构建视图层次结构。
- en: 'To load a layout resource file, you need to reference it from your application''s
    `onCreate()` callback implementation. For example, open your project''s `MainActivity.java`
    file and you will see something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载布局资源文件，您需要从应用程序的`onCreate()`回调实现中引用它。例如，打开您的项目`MainActivity.java`文件，您将看到如下内容：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, your project calls `setContentView()` and passes it the reference to your
    project's automatically-generated resource file; in this instance, it is `R.layout.main_layout`.
    When the user loads your application, `MainActivity` will read this referenced
    layout resource file and display its content to the user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您的项目调用`setContentView()`并将项目自动生成的资源文件的引用传递给它；在这个例子中，它是`R.layout.main_layout`。当用户加载您的应用程序时，`MainActivity`将读取这个引用的布局资源文件并向用户显示其内容。
- en: Declaring your UI programmatically
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式声明UI
- en: The second option is to create your UI programmatically at runtime. This approach
    isn't generally recommended, as it means that your app's underlying code and the
    UI code get mixed up. So, tweaking an element of your app's UI becomes much more
    difficult than it needs to be.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是在运行时以编程方式创建UI。这种方法通常不推荐，因为它意味着您的应用程序的底层代码和UI代码被混合在一起。因此，调整应用程序UI的元素变得比必要的要困难得多。
- en: However, sometimes you will need to define certain aspects of your user interface
    programmatically, and occasionally you may even need to define the whole thing
    in Java.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能需要以编程方式定义用户界面的某些方面，有时甚至可能需要用Java定义整个界面。
- en: 'As we''ve already seen, when you define your layout resource in XML, you load
    it from your application code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，当您在XML中定义布局时，您从应用程序代码中加载它：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you're telling your Activity to load the `main_activity.xml` layout resource
    file, but if you're creating your layout programmatically, you need to remove
    this bit of code so that your Activity doesn't go looking for a layout resource
    file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，您正在告诉您的Activity加载`main_activity.xml`布局资源文件，但如果您以编程方式创建布局，则需要删除此段代码，这样您的Activity就不会寻找布局资源文件。
- en: 'For example, take a look at the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下内容：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using both programmatic and XML layouts
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编程和XML布局
- en: Sometimes the best solution maybe to use both programmatic and XML layouts.
    This approach helps you to keep some separation between your UI and application
    code by defining the bulk of your UI in XML, while also allowing you to create
    a more dynamic user interface by modifying the state of some onscreen elements
    at runtime.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，最好的解决方案可能是同时使用编程和XML布局。这种方法通过在XML中定义大部分UI来帮助你保持UI和应用程序代码之间的分离，同时允许你在运行时通过修改一些屏幕元素的状态来创建一个更动态的用户界面。
- en: For example, your app may contain a slideshow that's controlled by a single
    button. When the user taps the button, a new image appears. To create this effect,
    you can define the button in XML, and then add a new image programmatically whenever
    the user taps the button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你的应用可能包含一个由单个按钮控制的幻灯片。当用户点击按钮时，会出现一张新图片。为了创建这种效果，你可以在XML中定义按钮，然后每当用户点击按钮时，以编程方式添加一张新图片。
- en: Since XML is the easiest and most efficient way of defining your UI, this chapter
    mainly focuses on creating and customizing views, ViewGroups, and layouts in XML.
    However, occasionally you may need to define parts of your UI programmatically,
    so I'll also include some snippets of Java along the way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML是定义UI最简单和最有效的方式，因此本章主要关注在XML中创建和自定义视图、ViewGroups和布局。然而，偶尔你可能需要以编程方式定义UI的一部分，所以在这个过程中我也会包括一些Java代码片段。
- en: Deep dive – exploring layouts
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 - 探索布局
- en: 'Now that you have an idea of how views, ViewGroups, and Layouts come together
    to create a user interface, and how to create your user interface programmatically
    and in XML, it''s time to look at each of Android''s most common UI components
    in more detail. We''ll start with the component that pretty much lays the foundation
    of any user interface: a layout container.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了视图、ViewGroups和布局如何结合在一起创建用户界面，以及如何以编程方式和在XML中创建用户界面，是时候更详细地查看Android最常用的UI组件了。我们将从基本上为任何用户界面奠定基础的那个组件开始：布局容器。
- en: The Android platform supports a range of layouts, so your first task is deciding
    which layout best meets your design needs. If you're struggling to make this decision,
    keep in mind that you can nest layouts within one another to create your perfect
    layout container.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台支持一系列布局，因此你的第一个任务是决定哪种布局最能满足你的设计需求。如果你在做出这个决定时遇到困难，请记住，你可以在布局之间嵌套以创建你完美的布局容器。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't go overboard with the nesting as this can have a negative impact on your
    app's performance. If you find yourself nesting multiple layouts, then this could
    be a sign that you're using the wrong kind of layout!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度嵌套，因为这可能会对你的应用程序性能产生负面影响。如果你发现自己嵌套了多个布局，那么这可能是一个迹象，表明你正在使用错误的布局类型！
- en: Before you create any kind of layout, here are a few rules, regulations, and
    attributes that you need to get to grips with.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建任何类型的布局之前，这里有一些规则、规定和属性，你需要掌握。
- en: Defining the size of your layouts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义布局的大小
- en: Whenever you create a layout, you need to tell the Android system how big this
    layout should be.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个布局时，你需要告诉Android系统这个布局应该有多大。
- en: The XML attributes you use to define the size of your layouts are `android:layout_height`
    and `android:layout_width`. As their names suggest, these attributes set the height
    and width of your layouts respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你用来定义布局大小的XML属性是`android:layout_height`和`android:layout_width`。正如它们的名称所暗示的，这些属性分别设置布局的高度和宽度。
- en: 'Both accept the following values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都接受以下值：
- en: A supported keyword
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个支持的关键字
- en: 'Android screens come in lots of different sizes. One of the easiest ways of
    ensuring your user interface is flexible enough to cope with all these differently-sized
    screens is to set your layout''s width and height to one of the following supported
    keywords:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Android屏幕有各种不同的尺寸。确保你的用户界面足够灵活，能够应对所有这些不同尺寸的屏幕的最简单方法之一是将布局的宽度和高度设置为以下支持的其中一个关键字：
- en: '`match_parent`: This makes the height or width expand to completely fill the
    available onscreen space'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match_parent`：这使得高度或宽度扩展以完全填充可用的屏幕空间'
- en: '`wrap_content`: This sets the height or width to the minimum size required
    to fit the element''s content and no larger'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrap_content`：这设置高度或宽度为适应元素内容所需的最小尺寸，且不更大'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use `match_parent` and `wrap_content` to set the size of other
    onscreen elements, including views and ViewGroups.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`match_parent`和`wrap_content`来设置其他屏幕元素的大小，包括视图和ViewGroups。
- en: A dimension value
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尺寸值
- en: 'Alternatively, you can set the size of your layout using one of the units of
    measure supported by the Android system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 Android 系统支持的测量单位之一来设置你的布局大小：
- en: '**Density-independent pixels (dp)**: This is an abstract unit which is based
    on the screen''s physical density. The dp unit is relative to 1 physical pixel
    on a 160 dots per inch screen. At runtime, Android automatically adjusts the number
    of pixels used to draw 1 dp by a factor that''s appropriate for the current screen''s
    dp. Using density-independent measurements is a straightforward solution to creating
    a UI that can adjust automatically across a range of screen sizes.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度无关像素 (dp)**：这是一个基于屏幕物理密度的抽象单位。dp 单位相对于 160 点每英寸屏幕上的 1 个物理像素。在运行时，Android
    会根据当前屏幕的 dp 自动调整绘制 1 dp 所使用的像素数。使用密度无关的测量是创建能够自动适应不同屏幕大小的 UI 的简单解决方案。'
- en: '**An absolute unit**: Android supports a number of absolute units of measure
    (specifically pixels, millimeters, and inches), but you should avoid defining
    your layout using absolute sizes as this makes your UI very rigid, and can prevent
    it from resizing itself to suit a range of screens. Unless you have a *very good
    reason* not to, stick to relative measurements, such as dp, `match_parent`, and
    `wrap_content`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对单位**：Android 支持多种绝对测量单位（特别是像素、毫米和英寸），但你应避免使用绝对大小来定义你的布局，因为这会使你的 UI 非常僵硬，并可能阻止它根据不同屏幕大小进行缩放。除非你有
    *非常好的理由* 不这样做，否则请坚持使用相对测量，如 dp、`match_parent` 和 `wrap_content`。'
- en: Setting the layout size programmatically
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序化设置布局大小
- en: 'You can also set the size of your layout programmatically by creating the `LayoutParams`
    object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过创建 `LayoutParams` 对象来程序化地设置布局的大小：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then set its width and height as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式设置其宽度和高度：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exploring different layouts
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索不同的布局
- en: 'Now that you know how to create layouts in XML and Java, and how to set their
    height and width, you can take a closer look at two of the most commonly used
    layouts: the straightforward and easy-to-use `LinearLayout` layout and the incredibly
    flexible `RelativeLayout` layout.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在 XML 和 Java 中创建布局，以及如何设置它们的高度和宽度，你可以更深入地了解两种最常用的布局：简单易用的 `LinearLayout`
    布局和极其灵活的 `RelativeLayout` 布局。
- en: Everything you need to know about LinearLayout
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 LinearLayout 你需要知道的一切
- en: '`LinearLayout` aligns all its children in a single horizontal or vertical row,
    stacking them one after the other.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout` 将其所有子元素对齐在单个水平或垂直行中，一个接一个地堆叠。'
- en: 'You set the direction of your `LinearLayout` layout using either of the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下任一方式设置你的 `LinearLayout` 布局的朝向：
- en: '`android:orientation="horizontal."`: The views are placed next to each other
    in *rows*. A horizontal `LinearLayout` layout is only ever one row high.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:orientation="horizontal."`: 视图被放置在彼此旁边的 *行* 中。水平 `LinearLayout` 布局始终只有一行高。'
- en: '`android:orientation="vertical."`: The views are placed below each other in
    *columns*. A vertical `LinearLayout` layout only ever has one child per row.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:orientation="vertical."`: 视图被放置在彼此下面的 *列* 中。垂直 `LinearLayout` 布局始终每行只有一个子元素。'
- en: 'Here''s a simple `LinearLayout` layout with a horizontal orientation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具有水平方向的简单 `LinearLayout` 布局：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s how this horizontal `LinearLayout` layout appears on an Android device:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这种水平 `LinearLayout` 布局在 Android 设备上的显示方式：
- en: '![Everything you need to know about LinearLayout](img/image_02_005.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![关于 LinearLayout 你需要知道的一切](img/image_02_005.jpg)'
- en: 'Here''s the same `LinearLayout` based UI with the orientation set to `android:orientation="vertical"`
    instead:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是具有 `android:orientation="vertical"` 朝向的相同 `LinearLayout` 基础 UI：
- en: '![Everything you need to know about LinearLayout](img/image_02_006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![关于 LinearLayout 你需要知道的一切](img/image_02_006.jpg)'
- en: Everything you need to know about RelativeLayout
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 RelativeLayout 你需要知道的一切
- en: '`RelativeLayout` is one of the most flexible layouts at your disposal, giving
    you the freedom to position every child element based on its relationship with
    any other child element, with its parent container.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout` 是你可用布局中最灵活的一种，它让你可以根据每个子元素与其任何其他子元素的关系，以及与其父容器的关系来定位每个子元素。'
- en: For example, you have the flexibility to position `TextView` so that it aligns
    with the edge of the `RelativeLayout` container, and then you can position a `Button`
    100 density-independent pixels above `TextView`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以灵活地定位 `TextView` 以使其与 `RelativeLayout` 容器的边缘对齐，然后你可以将一个 `Button` 放置在 `TextView`
    上方 100 密度无关像素的位置。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Using RelativeLayout to optimize your UI**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 RelativeLayout 优化你的 UI**'
- en: In addition to giving you control over where each element appears on the screen,
    `RelativeLayout` can improve your app's overall performance by reducing nesting.
    If you find yourself using several nested `LinearLayouts`, you maybe able to flatten
    your layout hierarchy by replacing them with a single `RelativeLayout`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让您控制每个元素在屏幕上的位置外，`RelativeLayout`还可以通过减少嵌套来提高您应用程序的整体性能。如果您发现自己正在使用多个嵌套的`LinearLayout`，您可能可以通过用单个`RelativeLayout`替换它们来简化布局层次结构。
- en: Since `RelativeLayout` is all about giving you the flexibility to position your
    UI elements wherever you want, it's no surprise that this layout supports a long
    list of attributes that let you position your UI elements relative to their parent
    container and relative to one another.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '由于`RelativeLayout`主要是关于给您提供灵活性，以便将UI元素定位到您想要的位置，因此它支持一系列属性，这些属性允许您将UI元素相对于其父容器和彼此进行定位，这并不令人惊讶。 '
- en: Relative to the parent container
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对于父容器
- en: 'All the following attributes accept the `true` value; for example, `android:layout_alignParentTop="true"`
    and `android:layout_alignParentStart="true."`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '所有以下属性都接受`true`值；例如，`android:layout_alignParentTop="true"`和`android:layout_alignParentStart="true."`:'
- en: '`android:layout_alignParentTop`: This aligns the top edge of a view with the
    top edge of its parent'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentTop`: 这会将视图的顶部与其父视图的顶部对齐'
- en: '`android:layout_alignParentBottom`: This aligns the bottom edge of a view with
    the bottom edge of its parent'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentBottom`: 这会将视图的底部与其父视图的底部对齐'
- en: '`android:layout_centerInParent`: This centers a view horizontally and vertically
    within its parent'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_centerInParent`: 这将在父视图内水平和垂直居中视图'
- en: '`android:layout_alignParentRight`: This aligns the right edge of a view with
    the right edge of its parent'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentRight`: 这会将视图的右侧与其父视图的右侧对齐'
- en: '`android:layout_alignParentLeft`: This aligns the left edge of a view with
    the left edge of its parent'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentLeft`: 这会将视图的左侧与其父视图的左侧对齐'
- en: '`android:layout_centerHorizontal`: This centers a view horizontally within
    its parent'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_centerHorizontal`: 这将在父视图内水平居中视图'
- en: '`android:layout_centerVertical`: This centers a view vertically within its
    parent'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_centerVertical`: 这将在父视图内垂直居中视图'
- en: '`android:layout_alignParentStart`: This aligns the start edge of a view with
    the start edge of its parent'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentStart`: 这会将视图的起始边缘与其父视图的起始边缘对齐'
- en: '`android:layout_alignParentEnd`: This aligns the end edge of a view with the
    end edge of its parent'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignParentEnd`: 这会将视图的末端与其父视图的末端对齐'
- en: '`android:layout_alignWithParentIfMissing`: If the view references an element
    that''s missing, this attribute will align the view with the parent instead'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignWithParentIfMissing`: 如果视图引用了一个缺失的元素，则此属性将使视图与父视图对齐'
- en: '![Relative to the parent container](img/image_02_007.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![相对于父容器](img/image_02_007.jpg)'
- en: Relative to other elements
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对于其他元素
- en: You can also position UI elements relative to other onscreen elements; for example,
    you may want to position the `back_button` view to the left of `forward_button`
    and position `titleTextBox` above `subheadingTextBox`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将UI元素相对于屏幕上的其他元素进行定位；例如，您可能希望将`back_button`视图放置在`forward_button`的左侧，并将`titleTextBox`放置在`subheadingTextBox`上方。
- en: 'All the following attributes should reference the ID of the element you''re
    using as your reference point (we''ll look at IDs in more detail shortly, but
    essentially a view''s ID is the value of its `android:id` element in your layout
    resource file, for example, the ID of `android:id ="@+id/viewName"` is `viewName`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '所有以下属性都应该引用您用作参考点的元素的ID（我们将在稍后更详细地介绍ID，但基本上，视图的ID是您布局资源文件中`android:id`元素的值，例如，`android:id="@+id/viewName"`的ID是`viewName`）:'
- en: '`android:layout_above`: This places a view above the specified element; for
    example, `android:layout_above="@+id/subheadingTextBox"` will place the UI element
    above `subheadingTextBox`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_above`: 这会将视图放置在指定的元素上方；例如，`android:layout_above="@+id/subheadingTextBox"`将UI元素放置在`subheadingTextBox`上方'
- en: '`android:layout_below`: This places a view below the specified element'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_below`: 这会将视图放置在指定的元素下方'
- en: '`android:layout_toLeftOf`: This places a view to the left of the specified
    element'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_toLeftOf`: 这会将视图放置在指定元素的左侧'
- en: '`android:layout_toRightOf`: This places a view to the right of the specified
    element'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_toRightOf`: 这会将视图放置在指定的元素右侧'
- en: '`android:layout_toStartOf`: This aligns the end edge of a view with the start
    of the specified element'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_toStartOf`: 这会将视图的末端与指定元素的起始边缘对齐'
- en: '`android:layout_toEndOf`: This aligns the start edge of a view with the end
    edge of the specified element'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_toEndOf`: 这会将视图的起始边缘与指定元素的结束边缘对齐'
- en: '![Relative to other elements](img/image_02_008.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![相对于其他元素](img/image_02_008.jpg)'
- en: Aligning with other elements
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他元素对齐
- en: 'You can also position a UI element by specifying how it aligns with other on-screen
    elements. Again, the value for all the following attributes is the ID of the element
    you''re using as your reference point:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过指定UI元素如何与其他屏幕元素对齐来定位UI元素。同样，以下所有属性的值都是您用作参考点的元素的ID：
- en: '`android:layout_alignBottom`: This aligns the bottom of a view element with
    the bottom of the specified onscreen element. For example, `android:layout_alignBottom="@+id/back_button"`
    aligns the bottom of a UI element with the bottom of `back_button`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignBottom`: 这会将视图元素的底部与指定屏幕元素的底部对齐。例如，`android:layout_alignBottom="@+id/back_button"`会将UI元素的底部与`back_button`的底部对齐。'
- en: '`android:layout_alignLeft`: This aligns the left edge of a view with the left
    edge of the specified element.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignLeft`: 这会将视图的左侧边缘与指定元素的左侧边缘对齐。'
- en: '`android:layout_alignRight`: This aligns the right edge of a view with the
    right edge of the specified element.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignRight`: 这会将视图的右侧边缘与指定元素的右侧边缘对齐。'
- en: '`android:layout_alignTop`: This aligns the top edge of a view with the top
    edge of the specified element.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignTop`: 这会将视图的顶部边缘与指定元素的顶部边缘对齐。'
- en: '`android:layout_alignStart`: This aligns the start edge of a view with the
    start edge of the specified element.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignStart`: 这会将视图的起始边缘与指定元素的起始边缘对齐。'
- en: '`android:layout_alignBaseline`: This attribute is a bit different. **Baseline**
    is a typography term for the invisible line that text sits on. So, this attribute
    aligns a view''s baseline with the baseline of the specified element. For example,
    if you have two `TextViews`, you may want to use `alignBaseline` to create the
    impression that the text in both views is written on the same invisible line.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_alignBaseline`: 此属性略有不同。**基线**是排版术语，指的是文本所在的无形线。因此，此属性将视图的基线与指定元素的基线对齐。例如，如果您有两个`TextView`，您可能想使用`alignBaseline`来产生这样的印象，即两个视图中的文本都写在同一无形线上。'
- en: Creating views
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: Views are the basic building blocks of a user interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是用户界面的基本构建块。
- en: 'Most of the time you''ll create view objects by adding them to your Activity''s
    corresponding layout resource file. You can either edit the XML code directly,
    or you may want to drag UI elements from your IDE''s palette and drop them onto
    the UI preview:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您将通过将它们添加到您的Activity对应的布局资源文件中来创建视图对象。您可以直接编辑XML代码，或者您可能想从您的IDE调色板中拖动UI元素并将它们拖放到UI预览中：
- en: '![Creating views](img/image_02_009.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![创建视图](img/image_02_009.jpg)'
- en: 'You also have the option of creating views programmatically. For example, if
    you wanted to instantiate a `TextView` programmatically, you would add `TextView`
    to your Activity''s `onCreate()` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过编程方式创建视图。例如，如果您想通过编程方式实例化一个`TextView`，您可以将`TextView`添加到您的Activity的`onCreate()`方法中：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assigning the ID attribute
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配ID属性
- en: An ID gives you a way of identifying individual views within your layout. For
    example, if you create two buttons, you can distinguish between them by assigning
    them the IDs `yesButton` and `noButton`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ID为您在布局中识别单个视图提供了一种方式。例如，如果您创建了两个按钮，您可以通过分配它们ID `yesButton`和`noButton`来区分它们。
- en: 'You assign an ID to a view using the `android:id` attribute:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`android:id`属性为视图分配一个ID：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can then use the ID to reference this particular view:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用ID来引用这个特定的视图：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use the ID to locate a view programmatically using `findViewById(id)`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用ID通过`findViewById(id)`编程方式定位视图：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this method returns the desired view, you can interact with the view programmatically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此方法返回所需的视图，您就可以通过编程方式与视图交互。
- en: Setting a view's size
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置视图的大小
- en: In the same way you need to set the size of your layout container, you need
    to set the size of all the views you add to your layout resource file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与您需要设置布局容器的大小一样，您还需要设置添加到布局资源文件中的所有视图的大小。
- en: 'The good news is that you can use exactly the same attributes and values, which
    means you can add `android:layout_width` and `android:layout_height` to your layout
    resource file, and then choose from the following values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您可以使用完全相同的属性和值，这意味着您可以将`android:layout_width`和`android:layout_height`添加到您的布局资源文件中，然后从以下值中选择：
- en: '**wrap_content**: This sets the view''s height or width to the minimum size
    required to accommodate the view''s content. For example, if you apply `wrap_content`
    to a button that contains a text label, the system will size the button so it''s
    *just* big enough to contain the button''s text label.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wrap_content**: 这将视图的高度或宽度设置为容纳视图内容所需的最小尺寸。例如，如果您将 `wrap_content` 应用到包含文本标签的按钮上，系统将调整按钮的大小，使其**刚好**足够容纳按钮的文本标签。'
- en: '**match_parent**: This expands the view''s height or width to fill all the
    available space.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**match_parent**: 这将视图的高度或宽度扩展以填充所有可用空间。'
- en: '**Density-independent pixels (dp):** When you assign a dp measurement, the
    Android system scales the view up or down based on the specific density of the
    user''s screen.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度无关像素（dp）:** 当您分配一个dp测量值时，Android系统会根据用户屏幕的具体密度来放大或缩小视图。'
- en: '**An absolute unit**: Although this is not recommended, you can also use absolute
    units of measurements: pixels, millimeters, or inches.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对单位**：尽管不推荐这样做，但您也可以使用绝对单位进行测量：像素、毫米或英寸。'
- en: Android gravity and layout gravity
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android重力布局和布局重力
- en: 'The gravity attribute specifies how an object should be positioned along the
    *X* and *Y* axis inside its enclosing object. This may sound straightforward,
    but there''s a catch: you''ll encounter two different gravity attributes in Android.
    Although they look similar, they can actually yield very different results:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重力属性指定对象在其封装对象内沿 *X* 和 *Y* 轴应该如何定位。这听起来可能很简单，但有一个问题：您将在Android中遇到两个不同的重力属性。尽管它们看起来很相似，但它们实际上可以产生非常不同的结果：
- en: '`android:gravity`: This positions the content that''s inside a view, for example,
    the text inside a `TextView`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:gravity`: 这将定位视图内的内容，例如，`TextView` 内的文本。'
- en: '`android:layout_gravity`: This positions a child view inside its parent container,
    for example, a `TextView` inside a `LinearLayout`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_gravity`: 这将子视图定位在其父容器内，例如，一个 `TextView` 在 `LinearLayout` 内。'
- en: 'Both accept a wide range of values, including several values that *won''t*
    change the size of the object you''re applying the gravity attribute to:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都接受广泛的值，包括几个不会改变应用重力属性的物体大小的值：
- en: '`top`: This positions the object at the top of its parent container. For example,
    `android:gravity="top"` will position the text at the top of `TextView`, while
    `android:layout_gravity="top"` will position `TextView` at the top of `LinearLayout`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`: 这会将对象定位在其父容器的顶部。例如，`android:gravity="top"` 将将文本定位在 `TextView` 的顶部，而
    `android:layout_gravity="top"` 将将 `TextView` 定位在 `LinearLayout` 的顶部。'
- en: '`Left`: This positions the object to the left-hand side of its parent container.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Left`: 这将对象定位在其父容器的左侧。'
- en: '`center_vertical`: This positions the object in the vertical center of its
    parent container.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`center_vertical`: 这会将对象定位在其父容器垂直中心。'
- en: '`Start`: This positions the object at the beginning of its parent container.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start`: 这将对象定位在其父容器的开始处。'
- en: 'Both `gravity` attributes also support several values that *do* alter the object''s
    size, including the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `gravity` 属性也支持几个会改变对象大小的值，包括以下内容：
- en: '`fill_vertical`: This expands the object vertically, so it completely fills
    its parent container. For example, `android:gravity="fill_vertical"` will expand
    an image vertically to fill its `ImageView` container, while `android:layout_gravity="fill_vertical"`
    will expand `ImageView` vertically to fill its `RelativeLayout` container.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill_vertical`: 这将对象垂直扩展，使其完全填充其父容器。例如，`android:gravity="fill_vertical"` 将将图像垂直扩展以填充其
    `ImageView` 容器，而 `android:layout_gravity="fill_vertical"` 将将 `ImageView` 垂直扩展以填充其
    `RelativeLayout` 容器。'
- en: '`fill_horizontal`: This expands the object horizontally and vertically so that
    it completely fills its parent container.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill_horizontal`: 这将对象水平和垂直扩展，使其完全填充其父容器。'
- en: For the full list of supported values, see [http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity](http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持的完整值列表，请参阅 [http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity](http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:gravity)。
- en: You assign gravity programmatically using the `setGravity` attribute, for example,
    `Gravity.CENTER_HORIZONTAL`. You could also use `setHorizontalGravity` and `setVerticalGravity`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `setGravity` 属性编程式地分配重力，例如，`Gravity.CENTER_HORIZONTAL`。您还可以使用 `setHorizontalGravity`
    和 `setVerticalGravity`。
- en: Setting the background – working with color
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置背景 – 与颜色一起工作
- en: When it comes to background, some views have a completely transparent background,
    such as `TextViews`, while others have a standard background color, for example
    buttons, which are grey by default.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到背景时，一些视图具有完全透明的背景，例如`TextViews`，而其他视图则具有标准的背景颜色，例如按钮，默认为灰色。
- en: If you're not a fan of a view's default background, you can always change it.
    Android gives you several options for adding a splash of color to your UI.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢视图的默认背景，您总是可以更改它。Android 为您提供了多种选项，以在您的 UI 中添加一抹色彩。
- en: 'Firstly, the Android system does support a number of colors out of the box,
    so if you want to use any of the following hues, then you''re in luck, because
    the Android system has already done all the hard work for you:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Android 系统确实支持一些开箱即用的颜色，所以如果您想使用以下任何一种色调，那么您很幸运，因为 Android 系统已经为您做了所有艰苦的工作：
- en: '`black`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`black`'
- en: '`white`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`white`'
- en: '`holo_blue_bright`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_blue_bright`'
- en: '`holo_blue_dark`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_blue_dark`'
- en: '`holo_blue_light`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_blue_light`'
- en: '`holo_green_dark`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_green_dark`'
- en: '`holo_green_light`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_green_light`'
- en: '`holo_orange_light`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_orange_light`'
- en: '`holo_orange_dark`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_orange_dark`'
- en: '`holo_purple`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_purple`'
- en: '`holo_red_dark`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_red_dark`'
- en: '`holo_red_light`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holo_red_light`'
- en: '`darker_gray`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`darker_gray`'
- en: 'To apply any of these ready-made color resources to a view, add the `android:background`
    attribute, but set its value to `"@android:/color"` followed by the color of your
    choice:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何这些现成的颜色资源应用到视图中，请添加`android:background`属性，但将其值设置为`"@android:/color"`后跟您选择的颜色：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android also supports values such as `primary_text_dark` and `widget_edittext_dark`
    for specific UI elements. You'll find the complete list of predefined colors in
    the official Android docs at [http://developer.android.com/reference/android/R.color.html](http://developer.android.com/reference/android/R.color.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Android 还支持`primary_text_dark`和`widget_edittext_dark`等特定 UI 元素的值。您可以在官方 Android
    文档中找到预定义颜色的完整列表，网址为[http://developer.android.com/reference/android/R.color.html](http://developer.android.com/reference/android/R.color.html)。
- en: However, this list is pretty limited! Sooner or later Android's predefined colors
    just aren't going to cut it, and you'll want to create your own color resources,
    which means using hex codes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个列表相当有限！迟早 Android 的预定义颜色将不再适用，您将需要创建自己的颜色资源，这意味着使用十六进制代码。
- en: If you have a particular shade in mind, you can usually find its hex code by
    performing a quick Google search, for example, by searching for `cyan hex code`
    or `light pink hex code`. Alternatively, you can go window shopping by browsing
    the Android style guide, which contains a wide range of colors and their corresponding
    hex codes. This is available at [https://www.google.com/design/spec/style/color.html#color-color-palette](https://www.google.com/design/spec/style/color.html#color-color-palette).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个特定的色调在心中，您通常可以通过快速谷歌搜索找到它的十六进制代码，例如，通过搜索`青色十六进制代码`或`浅粉色十六进制代码`。或者，您可以通过浏览
    Android 风格指南来进行“橱窗购物”，该指南包含广泛的颜色及其相应的十六进制代码。这可在[https://www.google.com/design/spec/style/color.html#color-color-palette](https://www.google.com/design/spec/style/color.html#color-color-palette)找到。
- en: 'Once you have your hex code, you can take the quick and easy route of entering
    the code directly into your layout resource file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了十六进制代码，您可以直接将代码输入到您的布局资源文件中：
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This may *seem* quick, but it might just end up costing you more time in the
    long run. Since consistency is a big part of providing a great user experience,
    chances are that you'll use the same colors multiple times throughout your application,
    and typing out the entire hex code every single time you want to use that color
    can really add up.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能*看起来*很快，但长期来看，这可能会让您花费更多的时间。由于一致性是提供良好用户体验的重要组成部分，您可能会在应用程序的多个地方多次使用相同的颜色，每次使用该颜色时都输入整个十六进制代码可能会真正增加工作量。
- en: Although it may require a bit of initial effort, most of the time it makes sense
    to define your colors as color resources in your project's `res/values/colors.xml`
    file. You can then reference these color resources as many times as you want without
    having to type out entire hex codes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能需要一些初始的努力，但大多数时候，在项目的`res/values/colors.xml`文件中定义颜色资源是有意义的。然后您可以多次引用这些颜色资源，而无需输入整个十六进制代码。
- en: 'If your project doesn''t contain the `colors.xml` file, you can create one
    by right-clicking on your project''s `values` folder and selecting **New**, followed
    by **Values resource file**. Give your file the name of `colors.xml`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目不包含`colors.xml`文件，您可以通过在项目的`values`文件夹上右键单击，选择**新建**，然后选择**值资源文件**来创建一个。将您的文件命名为`colors.xml`：
- en: '![Setting the background – working with color](img/image_02_010.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![设置背景 – 使用颜色](img/image_02_010.jpg)'
- en: 'Open the `colors.xml` file and define all the colors you want to use in your
    app using the following format:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`colors.xml`文件，并使用以下格式定义你想要在应用中使用的所有颜色：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can then use this color resource anywhere in your app, including in the
    background of your views:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在你的应用中的任何地方使用这个颜色资源，包括在你的视图的背景中：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also change the background of your entire UI by adding the `android:background`
    attribute to your layout container such as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在你的布局容器中添加`android:background`属性来更改你整个UI的背景，如下所示：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can use images as the backdrop to your views, whether it''s
    a simple textured background image or a high definition photo. We''ll cover images
    in greater detail when we take a look at `ImageViews`, but as a quick overview,
    you just need to add the image to your project''s `res/drawable` folder and then
    reference the image in your layout file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用图像作为视图的背景，无论是简单的纹理背景图像还是高清晰度的照片。当我们在查看`ImageViews`时，我们将更详细地介绍图像，但作为一个快速概述，你只需要将图像添加到你的项目`res/drawable`文件夹中，然后在你的布局文件中引用该图像：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to set your app's background programmatically, use the `setBackgroundResource`
    method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以编程方式设置你应用的背景，请使用`setBackgroundResource`方法。
- en: Assigning a weight value
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配权重值
- en: When you're positioning views inside `LinearLayout`, you can control how much
    space each view occupies onscreen by assigning it a weight value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`LinearLayout`内部定位视图时，你可以通过为其分配一个权重值来控制每个视图在屏幕上占据的空间大小。
- en: 'When you assign weight values to your views, any remaining space in the layout
    is assigned to your views in the proportion of their declared weight. For example,
    imagine your layout contains three buttons with different weight values:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为你的视图分配权重值时，布局中剩余的空间将按其声明的权重比例分配给你的视图。例如，假设你的布局包含三个具有不同权重值的按钮：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Button3` is declaring that it''s more important than `Button1` and `Button2`,
    so it''ll be assigned half of any remaining space, while `Button1` and `Button2`
    have to share the rest of the available space equally:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button3`声明它比`Button1`和`Button2`更重要，因此它将被分配剩余空间的一半，而`Button1`和`Button2`必须平均分配剩余的可供空间：'
- en: '![Assigning a weight value](img/image_02_011.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![分配权重值](img/image_02_011.jpg)'
- en: Just be aware that other attributes may interact with your `layout_weight` values.
    For example, imagine your layout contains three `TextViews` and all of them are
    set to `android:layout_width="wrap content"`. In this scenario, the Android system
    calculates how wide each `TextView` needs to be in order to accommodate their
    text and *only* then does it divide up the remaining space. So, if one `TextView`
    needs to accommodate much more text than the other two `TextView`, this will have
    an impact on your weight results.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注意，其他属性可能与你的`layout_weight`值交互。例如，假设你的布局包含三个`TextViews`，并且它们都被设置为`android:layout_width="wrap
    content"`。在这种情况下，Android系统会计算每个`TextView`需要多宽才能容纳它们的文本，然后才会分配剩余的空间。所以，如果一个`TextView`需要容纳比其他两个`TextView`更多的文本，这将影响你的权重结果。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All views have a default weight of 0, unless you specify otherwise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视图都有一个默认的权重值为0，除非你指定了其他值。
- en: Adding and customizing view objects
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和自定义视图对象
- en: The easiest way to add view objects to your layout is via the layout resource
    file in your project's `res/layout` folder, although you can also add views programmatically
    as and when required.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 向你的布局添加视图对象的最简单方法是使用项目`res/layout`文件夹中的布局资源文件，尽管你也可以根据需要以编程方式添加视图。
- en: Over the next few sections, I'll show you how to create some of Android's most
    commonly used views, specifically `TextViews`, `EditText`, `ImageViews`, `Buttons`,
    and `ImageButtons`. Once you've created each view, I'll show you how to configure
    that view so it looks and functions *exactly* as you want it to.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将向你展示如何创建Android中最常用的视图之一，特别是`TextViews`、`EditText`、`ImageViews`、`Buttons`和`ImageButtons`。一旦创建了每个视图，我将向你展示如何配置该视图，使其看起来和功能与你期望的完全一致。
- en: TextView
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextView
- en: It may not be the most exciting part of your user interface, but the vast majority
    of Android apps feature some kind of text. You display text to your users via
    `TextView`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你用户界面中最令人兴奋的部分，但绝大多数Android应用都包含某种文本。你通过`TextView`向用户显示文本。
- en: 'To create `TextView`, add the `<TextView>` tag to your project''s layout resource
    file, and then tell the `TextView` what text it should display either by:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`TextView`，将`<TextView>`标签添加到您项目的布局资源文件中，然后告诉`TextView`它应该显示什么文本，可以通过以下方式：
- en: '**Adding the text directly to the layout**: This is pretty straightforward.
    Just add the `android:text` attribute and your text to the `TextView` XML code,
    for example, `android:text="Hello world!"`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接将文本添加到布局中**：这很简单。只需将`android:text`属性和您的文本添加到`TextView` XML代码中，例如，`android:text="Hello
    world!"`。'
- en: '**Referencing a string resource**: Most of the time, if your app needs to display
    text, then this text belongs in your project''s resources and *not* in your actual
    application code. This separation helps to keep your app''s code clean and readable,
    and it also means that you can tweak and change your app''s text at any point
    without ever having to touch your app''s underlying code. To create a string resource,
    open your project''s `res/values/strings.xml` file and add your text in the following
    format:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用字符串资源**：大多数情况下，如果您的应用程序需要显示文本，那么这些文本属于您的项目资源，而不是您的实际应用程序代码。这种分离有助于保持您的应用程序代码干净和可读，并且这也意味着您可以在任何时间点调整和更改应用程序的文本，而无需触及应用程序的底层代码。要创建字符串资源，打开您的项目`res/values/strings.xml`文件，并按以下格式添加您的文本：'
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can then reference this string resource from your layout file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从您的布局文件中引用这个字符串资源：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is all you need to know in order to display basic text, and sometimes this
    may be enough. However, text does have the potential to be a bit dry and boring!
    If you want to create more visually appealing text, you have several options.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要知道的所有内容，以便显示基本文本，有时这也许就足够了。然而，文本确实有可能显得有点枯燥和无聊！如果您想创建更具视觉吸引力的文本，您有几种选择。
- en: Brightening up your text
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使文本更加明亮
- en: 'You can use the `android:textColor` attribute to change the color of the text
    inside a `TextView`. To reference one of the default colors supported by the Android
    system, use the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`android:textColor`属性来更改`TextView`内文本的颜色。要引用Android系统支持的默认颜色之一，请使用以下格式：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you''re referencing a color that you defined yourself in your project''s
    `res/values/colors.xml` file, the value is laid out slightly differently:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在引用您在项目`res/values/colors.xml`文件中定义的颜色，其值布局略有不同：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you want to set the color of your `TextView` programmatically, use the `setTextColor()`
    method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以编程方式设置`TextView`的颜色，请使用`setTextColor()`方法。
- en: Setting the size of your text
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置文本大小
- en: You can make your text larger or smaller using `android:textSize`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`android:textSize`来增大或减小文本。
- en: Once again you need to remember that Android screens come in all sorts of different
    sizes, and your text needs to be easily readable regardless of the screen it's
    being displayed on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒您，Android屏幕有各种不同的尺寸，并且无论在哪个屏幕上显示，您的文本都需要易于阅读。
- en: To further complicate things, Android users can actually change the size of
    the font that's displayed on their device by opening their device's **Settings**,
    tapping **Display,** and selecting **Font Size**. This is a really useful feature
    for people who have vision problems.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步复杂化问题，Android用户实际上可以通过打开他们的设备**设置**，点击**显示**，并选择**字体大小**来更改显示在他们的设备上的字体大小。这对于有视力问题的人来说是一个非常实用的功能。
- en: 'The easiest way of ensuring that your text is flexible enough to adapt to the
    user''s font preferences and screen size is to use scale-independent pixels (`sp`)
    units:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的文本足够灵活，能够适应用户的字体偏好和屏幕大小，最简单的方法是使用无缩放像素（`sp`）单位：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Android also supports three relative font size styles that you may want to
    use in your application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Android还支持三种相对字体大小样式，您可能想在您的应用程序中使用：
- en: '`TextAppearance.Small`, such as `style="@android:style/TextAppearance.Small."`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextAppearance.Small`，例如`style="@android:style/TextAppearance.Small."`'
- en: '`TextAppearance.Medium`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextAppearance.Medium`'
- en: '`TextAppearance.Large`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextAppearance.Large`'
- en: Emphasizing your text
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强调您的文本
- en: 'You can add bold or italic emphasis to your text using the `android:textStyle`
    attribute. The possible values are normal, bold, and italic, or you can combine
    bold and italic by separating the two values with a pipe character (`android:textStyle="bold|italic"`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`android:textStyle`属性为您的文本添加粗体或斜体强调。可能的值是正常、粗体、斜体，或者您可以通过管道字符（`android:textStyle="bold|italic"`）将两个值分开来组合粗体和斜体：
- en: '![Emphasizing your text](img/image_02_012.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![强调您的文本](img/image_02_012.jpg)'
- en: Setting the typeface
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置字体样式
- en: 'By default, Android applies the normal typeface to your text, but the system
    also supports `sans`, `monospace`, and `serif` typefaces, which you set using
    `android:typeface`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android 应用正常字体到您的文本，但系统也支持 `sans`、`monospace` 和 `serif` 字体，您可以使用 `android:typeface`
    设置这些字体：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Setting the typeface](img/image_02_013.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![设置字体](img/image_02_013.jpg)'
- en: To set the typeface programmatically, you need to use the `setTypeFace` method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要程序化设置字体，您需要使用 `setTypeFace` 方法。
- en: How many lines?
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有多少行？
- en: 'By default, the content of your `TextView` will run across multiple lines depending
    on how much text it has to display. If you want more control over the span of
    your `TextView`, you have a few options, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的 `TextView` 的内容将根据需要显示的文本量自动换行。如果您想对 `TextView` 的显示范围有更多控制，您有以下几种选择：
- en: '`android:lines`: This makes `TextView` exactly *X* number of lines tall, for
    example, `android:lines="2"`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:lines`：这使得 `TextView` 精确为 *X* 行高，例如，`android:lines="2"`'
- en: '`android:minLines.` At a minimum, `TextView` will be this many lines tall'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:minLines`：至少，`TextView` 将有这么多行高'
- en: '`android:maxLines`: This limits the `TextView` to this many lines tall'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:maxLines`：这限制 `TextView` 的高度为这么多行'
- en: EditText
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditText
- en: While `TextViews` are great for displaying text, if you want the user to be
    able to input text, you should use `EditText` instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `TextViews` 在显示文本方面很出色，但如果您希望用户能够输入文本，您应该使用 `EditText`。
- en: 'One of the most common examples of `EditTexts` in action is a form that requests
    user data. In this example, each input field is a separate `EditText`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText` 在实际应用中最常见的例子之一是请求用户数据的表单。在这个例子中，每个输入字段都是一个单独的 `EditText`：'
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s how this simple form looks on the user''s device:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这种简单表单在用户设备上的样子：
- en: '![EditText](img/image_02_014.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![EditText](img/image_02_014.jpg)'
- en: Since the `EditText` class is derived from the `TextView` class, many of the
    `TextView` attributes are also applicable to `EditText`, including `textColor`,
    `textSize`, `textStyle`, and `typeface`. However, `EditText` also supports a range
    of XML attributes that are specific to the `EditText` class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `EditText` 类是从 `TextView` 类派生出来的，因此许多 `TextView` 属性也适用于 `EditText`，包括 `textColor`、`textSize`、`textStyle`
    和 `typeface`。但是，`EditText` 也支持一系列特定于 `EditText` 类的 XML 属性。
- en: Controlling keyboard behavior - setting the inputType
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制键盘行为 - 设置输入类型
- en: By default, when the user taps the `EditText` field, the standard keyboard appears
    and they can enter whatever characters they like. However, you may want to restrict
    the kind of data users can enter into your `EditText` fields using the `android:inputType
    attribute`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当用户点击 `EditText` 字段时，将出现标准键盘，他们可以输入他们喜欢的任何字符。但是，您可能希望使用 `android:inputType`
    属性限制用户可以输入到您的 `EditText` 字段中的数据类型。
- en: This restriction prevents the user from entering invalid data, but some `inputType`
    values also prompt the Android system to optimize the virtual keyboard for a particular
    kind of content. For example, if you specify that the `EditText` `inputType` value
    is a phone number (`android:inputType="phone"`) the Android system will display
    the numerical keyboard, which makes it easier for the user to input the required
    data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制可以防止用户输入无效数据，但某些 `inputType` 值也会提示 Android 系统针对特定类型的内容优化虚拟键盘。例如，如果您指定 `EditText`
    的 `inputType` 值为电话号码 (`android:inputType="phone"`)，Android 系统将显示数字键盘，这使得用户输入所需数据变得更容易。
- en: Some `inputType` values also prompt the keyboard into other useful behavior;
    for example, if you set `inputType` to `textCapWords`, the keyboard will capitalize
    every new word automatically. This is handy when you're asking the user to enter
    data that should always be capitalized, such as their name or address.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `inputType` 值也会触发键盘的其他有用行为；例如，如果您将 `inputType` 设置为 `textCapWords`，键盘将自动将每个新单词的首字母大写。当您要求用户输入应始终大写的数据时，这很有用，例如他们的名字或地址。
- en: 'Here are the different `inputType` values you can use:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是您可以使用的不同 `inputType` 值：
- en: '`text`: This displays the standard text keyboard'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这显示标准文本键盘'
- en: '`textEmailAddress`: This displays the standard text keyboard with the addition
    of the `@` character'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textEmailAddress`：这显示带有 `@` 字符的标准文本键盘'
- en: '`textUri`: This displays the standard text keyboard with the addition of the
    `/` character'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textUri`：这显示带有 `/` 字符的标准文本键盘'
- en: '`number`: This displays the basic numerical keyboard'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`：这显示基本的数字键盘'
- en: '`phone`: This displays the phone-style keyboard'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phone`：这显示电话风格的键盘'
- en: 'All the following values display the standard text keyboard, but modify other
    keyboard behavior:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下值都显示标准文本键盘，但修改其他键盘行为：
- en: '`textCapSentences`: This automatically capitalizes the first letter of every
    new sentence.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textCapSentences`: 这会自动将每个新句子的第一个字母大写。'
- en: '`textCapWords`: This automatically capitalizes every word.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textCapWords`: 这会自动将每个单词的首字母大写。'
- en: '`textAutoCorrect`: This automatically corrects commonly misspelled words.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textAutoCorrect`: 这会自动纠正常见的拼写错误。'
- en: '`textPassword`: This masks the user''s password by transforming every inputted
    character into a dot. This is the behavior you typically encounter when entering
    passwords on your Android device. Another way of creating this masking effect
    is via the XML attribute `android:password="true."`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textPassword`: 这通过将每个输入的字符转换为点来隐藏用户的密码。这是你在Android设备上输入密码时通常遇到的行为。创建此隐藏效果的另一种方法是使用XML属性`android:password="true."`。'
- en: '`textMultiLine`: By default, the `EditText` field is constrained to a single
    line. This attribute allows the user to enter multiple lines of text.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textMultiLine`: 默认情况下，`EditText`字段被限制为单行。此属性允许用户输入多行文本。'
- en: 'You can also combine multiple values using the pipe character. For example,
    if you''re asking the user to create a password, you could automatically capitalize
    every new word while also masking their input:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用管道字符组合多个值。例如，如果你要求用户创建一个密码，你可以自动将每个新单词的首字母大写，同时隐藏他们的输入：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To specify keyboard behavior programmatically, use the `setRawInputType` method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式指定键盘行为，请使用`setRawInputType`方法。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While we're on the subject of controlling user input, you can restrict what
    numbers the user can enter into an `EditText` using `android:digits` (`android:digits="12345."`).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论控制用户输入时，你可以使用`android:digits` (`android:digits="12345."`)来限制用户可以输入到`EditText`中的数字。
- en: android:imeOptions
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: android:imeOptions
- en: Once the user has entered information into the `EditText` field, they'll usually
    confirm their input by tapping the action key that appears in place of the keyboard's
    usual carriage return key.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户在`EditText`字段中输入了信息，他们通常会通过点击键盘上通常的回车键替代的操作键来确认他们的输入。
- en: 'If you *don''t* specify what action key the system should display, the Android
    system defaults to the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定系统应显示哪个操作键，Android系统默认为以下：
- en: '`actionNext`: If there''s at least one focusable field to move on to, the system
    displays the **Next** action key.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionNext`: 如果至少有一个可聚焦字段可以移动到，系统将显示**下一步**操作键。'
- en: '`actionDone`: If there''s no subsequent focusable fields, the system displays
    the **Done** key. In our `form` example, the **Done** key would appear once the
    user has completed the final `EditText` field.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionDone`: 如果没有后续的可聚焦字段，系统将显示**完成**键。在我们的`form`示例中，**完成**键会在用户完成最后的`EditText`字段后出现。'
- en: 'Sometimes, you may want to override this default behavior and specify which
    action key the keyboard should display. You can do this using the `android:imeOptions`
    attribute and one of the following values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想覆盖此默认行为并指定键盘应显示哪个操作键。你可以使用`android:imeOptions`属性和以下值之一来完成此操作：
- en: '`actionGo`: This displays the **Go** key (`android:imeOptions="actionGo")`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionGo`: 这将显示**前往**键(`android:imeOptions="actionGo")`)'
- en: '`actionNext`: This displays the **Nex**t key'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionNext`: 这将显示**下一个**键'
- en: '`actionDone`: This displays the **Done** key'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionDone`: 这将显示**完成**键'
- en: '`actionSearch`: This displays the **Search** key'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionSearch`: 这将显示**搜索**键'
- en: '`actionSend`: This displays the **Send** key'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actionSend`: 这将显示**发送**键'
- en: Giving the user a hint
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供用户提示
- en: Even though `EditTexts` are designed to collect user input, you may want to
    prompt the user for a specific input by displaying temporary, greyed-out text
    in your `EditText` fields. These hints are useful when it isn't immediately obvious
    what information the user is supposed to enter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`EditTexts`旨在收集用户输入，但你可能希望通过在`EditText`字段中显示临时、灰色文本来提示用户进行特定输入。这些提示在用户不清楚应输入什么信息时非常有用。
- en: 'You display hints using the `android:hint` attribute:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`android:hint`属性来显示提示信息：
- en: Enter the hint into your layout resource file directly (`android:hint="Please
    enter your password"`)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将提示信息输入到你的布局资源文件中(`android:hint="请输入您的密码"`)
- en: Create and reference a string resource (`android:hint="@string/messageHint."`)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并引用一个字符串资源(`android:hint="@string/messageHint."`)
- en: ImageView
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImageView
- en: Images are a handy way of conveying information to your users without forcing
    them to read lots of on-screen text. Although you can add images to lots of different
    areas within your app, (such as your layout's background and the background of
    onscreen elements, such as buttons), the Android SDK provides a dedicated view
    for displaying images, called `ImageView`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图片是向用户传达信息的一种便捷方式，无需强迫他们阅读大量屏幕上的文本。尽管您可以在应用中的许多不同区域添加图片（例如布局的背景和屏幕元素如按钮的背景），但Android
    SDK提供了一个专门的视图来显示图片，称为`ImageView`。
- en: We've already discussed how you can use density-independent and other relative
    units of measure to create a user interface that displays correctly across a range
    of different screens. However, ensuring your images look crisp and clear across
    a range of different screen sizes isn't quite so straightforward.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用密度无关和其他相对单位来创建可以在不同屏幕上正确显示的用户界面。然而，确保您的图片在不同屏幕尺寸上看起来清晰并不那么简单。
- en: This makes `ImageView` one of the more complicated views, but since images are
    such an integral part of most Android UIs, it's well worth taking the time to
    properly master Android's `ImageView`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`ImageView`成为更复杂的视图之一，但由于图片是大多数Android UI的核心部分，因此花时间正确掌握Android的`ImageView`是非常值得的。
- en: In this section, I'll show you how to add **drawables** to your UI and the steps
    you should take to ensure these images display properly across the full range
    of possible screen sizes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何将**可绘制物**添加到您的UI中，以及您应采取的步骤以确保这些图片在所有可能的屏幕尺寸范围内正确显示。
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A drawable just means "something that can be drawn on the screen," and is often
    used to describe your app's graphical content.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可绘制物仅意味着“可以在屏幕上绘制的东西”，通常用来描述您应用的图形内容。
- en: Supporting multiple screens
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多屏幕
- en: 'Let''s get the tricky stuff out of the way first: how to create images that
    display correctly across a wide range of different screens.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决一些棘手的问题：如何创建可以在广泛不同屏幕上正确显示的图片。
- en: Although the Android system scales your content automatically to fit the current
    screen configuration, you shouldn't rely on the system to do all the hard work
    for you, *especially* when it comes to `ImageViews` as this can result in blurry
    or pixelated images.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android系统会自动缩放您的内文以适应当前的屏幕配置，但您不应依赖系统为您完成所有繁重的工作，*尤其是*当涉及到`ImageView`时，因为这可能导致模糊或像素化的图片。
- en: To provide the best possible user experience, you'll need to provide alternate
    versions of all the images you use in your app. These versions should be optimized
    for different screen densities.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供最佳的用户体验，您需要为应用中使用的所有图片提供备用版本。这些版本应针对不同的屏幕密度进行优化。
- en: The good news is that you don't have to provide images for *every* screen density
    imaginable, as the Android system groups all possible screen densities into generalized
    density spans. As long as you provide a version for each density span, the Android
    system will choose the version that's the best match for the current screen configuration.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您不必为所有可想象的屏幕密度提供图片，因为Android系统将所有可能的屏幕密度分组到通用的密度范围内。只要您为每个密度范围提供版本，Android系统就会选择最适合当前屏幕配置的版本。
- en: 'Android supports five main generalized screen densities:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持五种主要的通用屏幕密度：
- en: '**Low**: `ldpi 120dpi`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低分辨率**: `ldpi 120dpi`'
- en: '**Medium**: `mdpi 60dpi`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中等分辨率**: `mdpi 60dpi`'
- en: '**High**: `hdpi 240dpi`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高分辨率**: `hdpi 240dpi`'
- en: '**Extra-high**: `xhdpi 320dpi`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超高分辨率**: `xhdpi 320dpi`'
- en: '**Extra-extra-high**: `xxhdpi 480dpi`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超超高分辨率**: `xxhdpi 480dpi`'
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Android actually supports a sixth screen density: extra-extra-extra-high, also
    known as `xxxhdpi`. This `640dpi` density span is a bit different from the others
    as it *only* applies to your application''s launcher icon. Some devices, such
    as tablets, may display extra-large app icons in their launcher. To make sure
    your app''s icon doesn''t end up looking fuzzy on a large screen with an `xxxhdpi`
    display, you should supply an extra-extra-extra high density version of your app''s
    icon. You don''t need to provide `xxxhdi` versions of any other UI elements.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Android实际上支持第六种屏幕密度：超超超高分辨率，也称为`xxxhdpi`。这个`640dpi`的密度范围与其他的不同，因为它*仅*适用于您应用程序的启动器图标。一些设备，如平板电脑，可能在启动器中显示超大型应用图标。为了确保您的应用图标在具有`xxxhdpi`显示的大屏幕上不会看起来模糊，您应该提供您应用图标的超超超高密度版本。您不需要为任何其他UI元素提供`xxxhdi`版本。
- en: Supporting different screen densities
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持不同的屏幕密度
- en: So, how do you let Android know which image is optimized for `hdpi` displays,
    and which image is optimized for `xhdpi` displays? The answer is to create directories
    that are tagged with the `ldpi`, `mdpi`,  `hdpi`,  `xhdpi`,  `xxhdpi`, and  `xxxhdpi`
    qualifiers. Android will recognize that these directories contain resources that
    target a specific screen density, and then select an image from the appropriate
    directory based on the current screen configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你是如何让Android知道哪个图像是针对`hdpi`显示屏优化的，哪个图像是针对`xhdpi`显示屏优化的呢？答案是创建带有`ldpi`、`mdpi`、`hdpi`、`xhdpi`、`xxhdpi`和`xxxhdpi`限定符的目录。Android会识别这些目录包含针对特定屏幕密度的资源，然后根据当前的屏幕配置从适当的目录中选择图像。
- en: 'When you create an Android project in Eclipse or Android Studio, the project
    typically contains the default `res/drawable` directory only, so you''ll need
    to create the following directories manually:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Eclipse或Android Studio中创建Android项目时，项目通常只包含默认的`res/drawable`目录，因此你需要手动创建以下目录：
- en: '`drawable-ldpi`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-ldpi`'
- en: '`drawable-mdpi`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-mdpi`'
- en: '`drawable-hdpi`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-hdpi`'
- en: '`drawable-xhdpi`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-xhdpi`'
- en: '`drawable- xxhdp`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable- xxhdp`'
- en: '`drawable-xxxhdpi`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-xxxhdpi`'
- en: Remember, this directory should contain the extra-extra-extra-high density version
    of your app's launcher icon only.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个目录应该只包含应用启动器的额外额外额外高密度版本。
- en: 'To create these density-specific directories, perform the following steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些密度特定的目录，执行以下步骤：
- en: Right-click on your project's `res` folder and select **New**, followed by **Android
    resource directory**.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你的项目`res`文件夹，选择**新建**，然后选择**Android资源目录**。
- en: In the window that appears, open the **Resource type** dropdown and select **Drawable**.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中，打开**资源类型**下拉菜单，选择**Drawable**。
- en: In the **Available qualifiers** section, add **Density** as **Chosen qualifier**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**可用限定符**部分，将**密度**添加为**选择的限定符**。
- en: Open the **Density** dropdown and select the desired density from the list,
    for example, **Low Density** if you're creating the `drawable-ldpi` directory,
    or **XXX-High density** if you're creating a `drawable-xxxhdpi` directory. You'll
    notice that when you select the density, **Directory name** gets updated automatically:![Supporting
    different screen densities](img/image_02_015.jpg)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**密度**下拉菜单，从列表中选择所需的密度，例如，如果你正在创建`drawable-ldpi`目录，则选择**低密度**；如果你正在创建`drawable-xxxhdpi`目录，则选择**XXX-高密度**。你会注意到，当你选择密度时，**目录名称**会自动更新：![支持不同的屏幕密度](img/image_02_015.jpg)
- en: When you're happy with the information you've entered, click **OK**. Your IDE
    will then create the new directory.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你对输入的信息满意时，点击**确定**。然后你的IDE将创建新的目录。
- en: Repeat! You'll typically want to create a directory for each of the generalized
    screen densities.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复！你通常希望为每个通用的屏幕密度创建一个目录。
- en: 'If you''re working with a project in Android Studio, sometimes you may create
    all your density-specific directories and then realize that none of them are appearing
    in Android Studio''s **Project** view. If this happens, the problem may be that
    you have the **Android** view selected instead of **Project** view. To switch
    views, click on the **Android** label in Android Studio''s **Project** view, and
    then select **Project** from the drop-down menu:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Android Studio中的项目，有时你可能创建了所有密度特定的目录，然后意识到它们在Android Studio的**项目**视图中都没有出现。如果发生这种情况，问题可能在于你选择了**Android**视图而不是**项目**视图。要切换视图，请点击Android
    Studio的**项目**视图中的**Android**标签，然后从下拉菜单中选择**项目**：
- en: '![Supporting different screen densities](img/image_02_016.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![支持不同的屏幕密度](img/image_02_016.jpg)'
- en: You'll notice your project structure has changed. Open the `app/src/main/res`
    folder, and you will see all the density-specific directories you created earlier.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你的项目结构已经改变。打开`app/src/main/res`文件夹，你会看到你之前创建的所有密度特定的目录。
- en: Creating density-specific images
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建密度特定图像
- en: Now that you've updated your project structure, it's time to actually create
    those optimized images and add them to your project.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更新了项目结构，是时候实际创建那些优化图像并将它们添加到你的项目中。
- en: 'Android supports several different image types, but you''ll typically use one
    of the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持多种不同的图像类型，但通常你会使用以下之一：
- en: '**Bitmaps**: Android supports bitmap files in three formats: `.png` (preferred),
    `.jpg` (acceptable), or if you really *must*, `.gif` (discouraged).'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位图**：Android支持三种格式的位图文件：`.png`（首选），`.jpg`（可接受），或者如果你真的**必须**，`.gif`（不推荐）。'
- en: '**Nine-patch file**: This is a `.png` file with a difference! Nine-patch files
    allow you to define stretchable regions that help your image resize more smoothly.
    We''ll explore nine-patch images in more detail in the later chapters.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nine-patch文件**：这是一个`.png`文件，但有所不同！Nine-patch文件允许你定义可拉伸的区域，这有助于你的图像更平滑地调整大小。我们将在后面的章节中更详细地探讨nine-patch图像。'
- en: 'The key to creating alternate bitmaps and nine-patch files is to adhere to
    a 3:4:6:8:12:16 scaling ratio. For example, if you have an image that''s 68 x
    68 pixels and targets medium-density screens, you''d need to create the following
    alternatives:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 创建替代位图和nine-patch文件的关键是遵守3:4:6:8:12:16的缩放比例。例如，如果你有一个68 x 68像素的图像，目标是中等密度的屏幕，你需要创建以下替代版本：
- en: '**LDPI**: 51 x 51 pixels (0.75% of the original size)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDPI**: 51 x 51像素（原始大小的0.75%）'
- en: '**MDPI**: 68 x 68 pixels (original size)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MDPI**: 68 x 68像素（原始大小）'
- en: '**HDPI**: 102 x 102 pixels (150% of the original size)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDPI**: 102 x 102像素（原始大小的150%）'
- en: '**XHDPI**: 136 x 136 (200% of the original size)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XHDPI**: 136 x 136 (原始大小的200%)'
- en: '**XXHDPI**: 204 x 204 (300% of the original size)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XXHDPI**: 204 x 204 (原始大小的300%)'
- en: '**XXXHDPI**: 272 x 272 (400% of the original size)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XXXHDPI**: 272 x 272 (原始大小的400%)'
- en: When you're creating your alternate images, you *must* use the same filename
    for each version of the image. This is essential if the Android system is going
    to recognize these files as alternate versions of the same image.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建替代图像时，*必须*为每个图像版本使用相同的文件名。如果Android系统要识别这些文件为同一图像的替代版本，这是必不可少的。
- en: The final step is placing each file inside the appropriate directory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将每个文件放入适当的目录中。
- en: Adding ImageView
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ImageView
- en: Creating the correct `drawable` directory structure and providing multiple versions
    of the same image may feel like a lot of work, but once you've done all this groundwork,
    displaying `drawable` content in `ImageView` is a fairly straightforward task.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 创建正确的`drawable`目录结构和提供相同图像的多个版本可能感觉像是一项大量工作，但一旦你完成了所有这些基础工作，在`ImageView`中显示`drawable`内容就相对简单直接。
- en: 'Most of the time, you''ll create your `ImageView` by adding an `<ImageView>`
    element to your Activity''s layout resource file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你将通过向Activity的布局资源文件添加`<ImageView>`元素来创建你的`ImageView`：
- en: '[PRE26]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the `android:src` attribute. This is how you tell your `ImageView` what
    `drawable` to display. Assuming you've provided several versions of the `myImage`
    file, the Android system checks each `drawable` directory for the most suitable
    version, and then it displays this image.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`android:src`属性。这是你告诉`ImageView`显示哪个`drawable`的方式。假设你已经提供了几个版本的`myImage`文件，Android系统会检查每个`drawable`目录以找到最合适的版本，然后显示此图像。
- en: If you'd prefer to set your `ImageView` content programmatically, you can use
    the `setImageResource()` method instead.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢以编程方式设置`ImageView`内容，可以使用`setImageResource()`方法代替。
- en: Buttons and ImageButtons
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮和ImageButtons
- en: '`Buttons` (and by extension, `ImageButtons)` are UI components that react to
    the user tapping the screen. Whenever you add a button to your UI, it should be
    immediately clear to the user what this button will do when they touch it.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buttons`（以及由此扩展的`ImageButtons`）是响应用户触摸屏幕的UI组件。每次你在UI中添加按钮时，用户应该立即清楚这个按钮在被触摸时将执行什么操作。'
- en: While you *could* inform the user about a button's purpose with an accompanying
    `TextView` (something along the lines of *tap the button below to move onto the
    next screen*) this is wordy and inefficient. Most of the time, you'll want to
    communicate a button's purpose by adding a label to this button.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你*可以*通过伴随的`TextView`（例如*点击下面的按钮进入下一屏幕*）来告知用户按钮的目的，但这很啰嗦且效率低下。大多数情况下，你将通过向此按钮添加标签来传达按钮的目的。
- en: 'Android provides you with several labeling options:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Android为你提供了几个标签选项：
- en: A text label, for example **Next**, **Submit**, or **Cancel**.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本标签，例如**下一步**、**提交**或**取消**。
- en: An image icon, such as a checkmark or a cross icon.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像图标，例如勾选标记或交叉图标。
- en: 'Both! If the button represents an unusual, unexpected, or complicated action,
    you may want to clear up any potential confusion by labeling the button with both
    text and an image:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都要！如果按钮代表不寻常、意外或复杂的操作，你可能希望通过在按钮上添加文本和图像来消除任何潜在的混淆：
- en: '![Buttons and ImageButtons](img/image_02_017.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![按钮和ImageButtons](img/image_02_017.jpg)'
- en: Depending on whether you want your button to display text, an icon, or both,
    you can add a button to your layout resource file in one of three ways.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你希望按钮显示文本、图标还是两者，你可以通过以下三种方式之一将按钮添加到布局资源文件中。
- en: Creating buttons with text labels
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有文本标签的按钮
- en: 'To create a basic button with a text label, insert a `<Button>` element into
    your layout resource file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个带有文本标签的基本按钮，请将`<Button>`元素插入到您的布局资源文件中：
- en: '[PRE27]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You set the button's text label using the `android:text` attribute. As with
    `TextViews`, you can either insert the text into your layout directly (`android:text="Submit"`)
    or you can create a string resource in your project's `res/values/strings.xml`
    file, and then reference the string resource (`android:text="@string/submitText"`).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`android:text`属性设置按钮的文本标签。与`TextViews`一样，您可以直接将文本插入到布局中（`android:text="Submit"`）或您可以在项目的`res/values/strings.xml`文件中创建一个字符串资源，然后引用该字符串资源（`android:text="@string/submitText"`）。
- en: 'To set the button''s text programmatically, use `setText`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式设置按钮的文本，请使用`setText`：
- en: '[PRE28]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Creating buttons with image labels
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有图像标签的按钮
- en: As the name suggests, `ImageButton` is a button with an image label.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`ImageButton`是一个带有图像标签的按钮。
- en: 'To insert `ImageButton` into your UI, you need to add the `<ImageButton>` tag
    to your layout resource file:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`ImageButton`插入到您的UI中，您需要在布局资源文件中添加`<ImageButton>`标签：
- en: '[PRE29]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Recognize the `android:src` attribute? It's referencing a `drawable` resource,
    in exactly the same way an `ImageView` references a `drawable` reasource.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到`android:src`属性吗？它引用了一个`drawable`资源，与`ImageView`引用`drawable`资源的方式完全相同。
- en: Creating buttons with text and image labels
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有文本和图像标签的按钮
- en: 'If you want to leave the user in no doubt about what''ll happen when they touch
    a button, you can label that button with both text and an image. This involves
    utilizing the `Button` class with the addition of `android:drawableLeft`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确保用户在触摸按钮时完全清楚会发生什么，您可以使用文本和图像标签该按钮。这涉及到使用带有`android:drawableLeft`的`Button`类：
- en: '[PRE30]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Change your button''s background**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改按钮的背景**'
- en: If you feel like these three options aren't enough, you can also change a button's
    background using `android:background` and then referencing a color value or an
    image.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得这三个选项还不够，您还可以使用`android:background`更改按钮的背景，然后引用一个颜色值或一个图像。
- en: State list resources
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态列表资源
- en: 'Your typical button has three states:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您典型的按钮有三个状态：
- en: '`Default`: This button is neither pressed nor focused'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`：此按钮既未被按下也未被聚焦'
- en: '`Pressed`: This button is in a pressed state'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pressed`：此按钮处于按下状态'
- en: '`Focused`: This button is currently in focus'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Focused`：此按钮当前处于焦点状态'
- en: All the button attributes we've discussed so far (text labels, image labels,
    and backgrounds) apply to a button element regardless of its current state. But
    sometimes you'll want your button to give the user visual clues about its current
    state. For example, when the user taps a button, you may want it to briefly display
    a darker color while it's in its pressed state, so users know that their devices
    have successfully registered the touch event.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的所有按钮属性（文本标签、图像标签和背景）都适用于按钮元素，无论其当前状态如何。但有时您可能希望按钮向用户提供关于其当前状态的视觉提示。例如，当用户轻触按钮时，您可能希望它在按下状态下短暂显示较深的颜色，这样用户就知道他们的设备已成功注册了触摸事件。
- en: If you want your button to react to its current state, you need to create a
    state list resource, which is an XML file that defines three different images
    or colors to use for each of the button's states.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望按钮对其当前状态做出反应，您需要创建一个状态列表资源，这是一个定义每个按钮状态使用不同图像或颜色的XML文件。
- en: 'To create this state list resource, do the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此状态列表资源，请执行以下操作：
- en: Create three drawables to use as your button's background. These drawables represent
    each of the button's states.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个可绘制对象作为按钮的背景。这些可绘制对象代表按钮的每个状态。
- en: Give each `drawable` a name that reflects the state it represents, for example,
    `button_pressed`, or `button_default`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给每个`drawable`一个反映其状态的名称，例如`button_pressed`或`button_default`。
- en: Add these drawables to the appropriate `res/drawable` directory.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些可绘制对象添加到适当的`res/drawable`目录中。
- en: Create a new XML file in your project's `res/drawable` directory, by right-clicking
    on the `drawable` directory and selecting **New**, followed by **Drawable resource
    file**. Give the XML file a descriptive name, such as `button_states`, and then
    click on **OK**.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目`res/drawable`目录中创建一个新的XML文件，通过在`drawable`目录上右键单击并选择**新建**，然后选择**可绘制资源文件**。给XML文件一个描述性的名称，例如`button_states`，然后点击**确定**。
- en: 'Open your new `drawable` resource file and define all the drawables you want
    to use for each state by adding them as separate `<list>` elements inside a single
    `<selector>` element:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的新 `drawable` 资源文件，通过在单个 `<selector>` 元素内添加单独的 `<list>` 元素来定义你想要为每个状态使用的所有
    `drawable`：
- en: '[PRE31]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we''re defining which `drawable` the button should use
    when it''s in each state:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了按钮在每种状态下应该使用哪个 `drawable`：
- en: When `pressed = true`, the button should use the `button_pressed` drawable.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `pressed = true` 时，按钮应该使用 `button_pressed` `drawable`。
- en: When `focused = true`, the button should use the `button_focused` drawable.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `focused = true` 时，按钮应该使用 `button_focused` `drawable`。
- en: If the button isn't pressed or focused, it should use the `button_default` drawable.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按钮没有被按下或聚焦，它应该使用 `button_default` `drawable`。
- en: The order of the `<item>` elements in your state list resource is important,
    as when you reference this state list, the system moves through the `<item>` elements
    in order and uses the first `<item>` element that's applicable to the button's
    current state. Since the default state is *always* applicable, you must always
    place the default `drawable` at the end of the list, to ensure it's only used
    if the system has checked and discarded `android:state_pressed` and `android:state_focused`
    first.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的状态列表资源中 `<item>` 元素的顺序很重要，因为当你引用这个状态列表时，系统会按顺序遍历 `<item>` 元素，并使用第一个适用于按钮当前状态的
    `<item>` 元素。由于默认状态总是适用的，你必须始终将默认 `drawable` 放在列表的末尾，以确保它只有在系统首先检查并丢弃 `android:state_pressed`
    和 `android:state_focused` 后才会被使用。
- en: 'To apply a state list resource to a button, you need to reference it as a single
    `drawable` in your Activity''s layout resource file:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要将状态列表资源应用到按钮上，你需要在 Activity 的布局资源文件中将其引用为一个单独的 `drawable`：
- en: '[PRE32]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also create state list resources that use colors instead of images.
    These kinds of state lists are known as **color state list resources**. You use
    the same `<selector>` and `<item>` elements; the only difference is that each
    `<item>` element references a color rather than a `drawable`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建使用颜色而不是图像的状态列表资源。这类状态列表被称为 **颜色状态列表资源**。你使用相同的 `<selector>` 和 `<item>`
    元素；唯一的不同是每个 `<item>` 元素引用的是颜色而不是 `drawable`：
- en: '[PRE33]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Or
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE34]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the most commonly used views and layouts,
    and we looked at all the different ways to customize them to suit our specific
    design needs.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了最常用的视图和布局，并探讨了所有不同的自定义方式，以满足我们的特定设计需求。
- en: Even though there are views and layouts we haven't covered yet, many of the
    attributes we've explored in this chapter are applicable to the views and layouts
    that we'll encounter in later chapters, for example, `layout_width`, `android:src`,
    `android:id` and the relative units of measure.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有介绍过一些视图和布局，但本章中我们探讨的许多属性都适用于我们在后续章节中遇到的视图和布局，例如 `layout_width`、`android:src`、`android:id`
    以及相对度量单位。
- en: In the next chapter, we'll expand on using resources such as strings, nine-patch
    images, colors, and state lists, and also take a look at some new resources, including
    arrays and dimensions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展使用资源，如字符串、九宫格图像、颜色和状态列表，并查看一些新的资源，包括数组和维度。
- en: 'Finally, you''ll learn all about an important aspect of UI design that we haven''t
    touched on yet: *fragments*.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习到 UI 设计的一个重要方面，这是我们之前还没有涉及到的：*片段*。
