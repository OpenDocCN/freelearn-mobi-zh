- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Continuous Integration and Continuous Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和持续部署
- en: After we complete the development and first deployment of our app, we must think
    of how to make the process smoother for consecutive deployments, and that’s where
    **Continuous integration/Continuous delivery** (**CI/CD**) comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成应用的开发和首次部署后，我们必须考虑如何使后续部署的过程更加顺畅，这就是 **持续集成/持续交付**（**CI/CD**）发挥作用的地方。
- en: In this chapter, we will learn how to use GitHub Actions to automate some of
    the manual tasks, such as deploying new builds to the Google Play Store. We will
    learn how to run tests on CI/CD pipelines and push builds to the Play Store using
    GitHub Actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 GitHub Actions 自动化一些手动任务，例如将新构建部署到 Google Play 商店。我们将学习如何在 CI/CD
    管道上运行测试，并使用 GitHub Actions 将构建推送到 Play 商店。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up GitHub Actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 GitHub Actions
- en: Running lint checks and tests on GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 上运行代码检查和测试
- en: Deploying to Play Store using GitHub Actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 部署到 Play 商店
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本 ([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在 [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen)
    找到本章的代码。
- en: Setting up GitHub Actions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 GitHub Actions
- en: Before we can understand GitHub Actions, we need to understand what CI/CD is.
    This is a process that allows us to automate the building, testing, and deployment
    of our code to production. CI/CD not only automates these processes but also integrates
    them into a single coherent pipeline. This ensures that code changes are more
    reliable and stable when deployed. The definition should emphasize the role of
    CI/CD in facilitating frequent and reliable updates. This is an especially important
    process as it aims to improve the speed, efficiency, and reliability of how we
    deliver our software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解 GitHub Actions 之前，我们需要了解什么是 CI/CD。这是一个允许我们自动化构建、测试和将代码部署到生产环境的过程。CI/CD
    不仅自动化了这些流程，还将它们整合成一个单一的连贯管道。这确保了代码更改在部署时更加可靠和稳定。定义应该强调 CI/CD 在促进频繁和可靠更新方面的作用。这是一个特别重要的过程，因为它旨在提高我们交付软件的速度、效率和可靠性。
- en: Benefits of CI/CD
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 的好处
- en: 'Let’s go through some of the benefits of CI/CD:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 CI/CD 的一些好处：
- en: '**Fast release cycles**: CI/CD allows us to release our software faster and
    more frequently. This is because we are automating the process of building, testing,
    and deploying our code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速发布周期**：CI/CD 允许我们更快、更频繁地发布我们的软件。这是因为我们正在自动化构建、测试和部署代码的过程。'
- en: '**Increased collaboration**: Since a lot of the processes are automated, we
    can focus on the code and the features we are building. This allows us to collaborate
    more effectively with our team.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高协作**：由于许多流程都是自动化的，我们可以专注于代码和正在构建的功能。这使得我们能够更有效地与团队协作。'
- en: '**Less manual work**: We are reducing the amount of manual work we do due to
    automation. This means we can focus on the code and the features we are building.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少手动工作**：由于自动化，我们正在减少所做的手动工作。这意味着我们可以专注于代码和正在构建的功能。'
- en: '**Improved quality**: Automating the process allows us to test our code more
    frequently and more effectively. This means we can catch bugs and errors earlier
    in the process.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高质量**：自动化流程使我们能够更频繁、更有效地测试我们的代码。这意味着我们可以在流程的早期阶段捕捉到错误和漏洞。'
- en: Now we have learned about the benefits of CI/CD, let us look at how CI/CD works
    in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 CI/CD 的好处，让我们详细看看 CI/CD 是如何工作的。
- en: How CI/CD works
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 的工作原理
- en: 'Let us go through how CI/CD works:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 CI/CD 的工作原理：
- en: '**CI**: This is the process of automating the building and testing of our code.
    This is done every time we push our code to our repository. This allows us to
    catch bugs and errors earlier in the process. In this step, once we push or commit
    code to our remote repository, which can be hosted in GitHub, Gitlab, Bitbucket,
    and so on, we run checks and tests against these changes to ensure they are functional
    and meet the code quality standards. If the tests pass, we can merge the code
    into the main branch. If the tests fail, we can fix the code and run the tests
    again.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI**：这是自动化构建和测试我们代码的过程。每次我们将代码推送到我们的存储库时，都会执行此操作。这使我们能够更早地捕捉到错误和缺陷。在此步骤中，一旦我们将代码推送到远程存储库（可以是
    GitHub、Gitlab、Bitbucket 等），我们就会对这些更改运行检查和测试，以确保它们是功能性的并且符合代码质量标准。如果测试通过，我们可以将代码合并到主分支。如果测试失败，我们可以修复代码并再次运行测试。'
- en: '**CD**: This is the process of automating the deployment of our code to production.
    This is done every time we push our code to our repository. This allows us to
    release our software faster and more frequently. This happens after the CI step.
    Once the changes are merged to the main or development branch, we can deploy the
    code to production or whichever environment it needs to be deployed to. This step
    aims at pushing minor changes to production more frequently. This allows us to
    release our software faster and more frequently.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CD**：这是自动化将我们的代码部署到生产环境的过程。每次我们将代码推送到我们的存储库时，都会执行此操作。这使我们能够更快、更频繁地发布我们的软件。这发生在
    CI 步骤之后。一旦更改合并到主分支或开发分支，我们就可以将代码部署到生产环境或需要部署到的任何环境。此步骤旨在更频繁地将小更改推送到生产环境。这使我们能够更快、更频繁地发布我们的软件。'
- en: With this background, we can now look at GitHub Actions ([https://docs.github.com/en/actions](https://docs.github.com/en/actions)).
    GitHub Actions is a CI/CD tool that allows us to automate the building, testing,
    and deployment of our code. It is built into GitHub and is free to use up to certain
    limits. It is also extremely easy to use and set up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们现在可以查看 GitHub Actions ([https://docs.github.com/en/actions](https://docs.github.com/en/actions))。GitHub
    Actions 是一个 CI/CD 工具，允许我们自动化构建、测试和部署我们的代码。它是内置在 GitHub 中的，并且在使用一定限制内是免费的。它也非常易于使用和设置。
- en: 'In the next section, we are going to set up GitHub Actions for our project
    that is in this repository: [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为存储在本存储库中的项目设置 GitHub Actions：[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android)
- en: Setting up GitHub Actions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 GitHub Actions
- en: 'To enable GitHub Actions in our project, follow these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中启用 GitHub Actions，请按照以下步骤操作：
- en: 'Go to the **Actions** tab of our repository, as shown in the following screenshot:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们的存储库的 **操作** 选项卡，如图下截图所示：
- en: '![Figure 14.1 – GitHub Actions tab](img/B19779_14_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – GitHub Actions 选项卡](img/B19779_14_01.jpg)'
- en: Figure 14.1 – GitHub Actions tab
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – GitHub Actions 选项卡
- en: 'This step will bring us to the GitHub Actions landing page:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤将带我们进入 GitHub Actions 的主页：
- en: '![Figure 14.2 – GitHub Actions landing page](img/B19779_14_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – GitHub Actions 主页](img/B19779_14_02.jpg)'
- en: Figure 14.2 – GitHub Actions landing page
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – GitHub Actions 主页
- en: 'As seen in the preceding image, we have some suggested actions that we can
    use in our repository. For now, we will set the actions by ourselves, so let us
    click on the **set up a workflow yourself** option. This brings us to the following
    page:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一些建议的操作，我们可以在我们的存储库中使用。目前，我们将自己设置操作，所以让我们点击 **自行设置工作流程** 选项。这会带我们到以下页面：
- en: '![Figure 14.3 – New GitHub Action](img/B19779_14_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 新的 GitHub Action](img/B19779_14_03.jpg)'
- en: Figure 14.3 – New GitHub Action
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 新的 GitHub Action
- en: As you can see in the preceding image, we have an editor for writing our workflow.
    Notice at the top we now have a new folder called `.github`. This is where we
    will store our workflow files. The editor saves the workflow file in the `.github/workflows`
    folder. By default, our workflow is named `main.yml`. On the right, we have templates
    that we can use to easily create our workflow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一个编辑器用于编写我们的工作流程。注意，在顶部我们现在有一个名为 `.github` 的新文件夹。这是我们存储工作流程文件的地方。编辑器将工作流程文件保存在
    `.github/workflows` 文件夹中。默认情况下，我们的工作流程命名为 `main.yml`。在右侧，我们有模板，我们可以使用这些模板轻松创建我们的工作流程。
- en: 'For now, we are going to create our own workflow, so let us add the following
    code to our workflow:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们将创建自己的工作流程，所以请将以下代码添加到我们的工作流程中：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s understand the different fields in the preceding workflow file:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们理解前面工作流程文件中的不同字段：
- en: '`name`: This is the name of our workflow. This will be displayed on the GitHub
    Actions page.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是我们的工作流程名称。这将在 GitHub Actions 页面上显示。'
- en: '`on`: This is the event that will trigger our workflow. In our case, we are
    triggering our workflow when we push code to the main branch.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`: 这是将触发我们的工作流程的事件。在我们的例子中，我们在向主分支推送代码时触发我们的工作流程。'
- en: '`workflow_dispatch`: This is a manual trigger that we can use to trigger our
    workflow from the GitHub Actions page. This is useful when we want to trigger
    our workflow manually.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workflow_dispatch`: 这是一个手动触发器，我们可以使用它从 GitHub Actions 页面触发我们的工作流程。这在我们需要手动触发工作流程时很有用。'
- en: '`jobs`: This is the job that will be run when our workflow is triggered. In
    our case, we have a job called `build`. This job will run on the latest version
    of Ubuntu as specified by the `runs-on` field.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`: 这是在我们的工作流程被触发时运行的作业。在我们的例子中，我们有一个名为 `build` 的作业。这个作业将在由 `runs-on` 字段指定的最新版本的
    Ubuntu 上运行。'
- en: '`steps`: This field contains the steps that will be run in our job. In our
    case, we have a single step that will run a command. This command will print out
    the event that triggered our workflow. A step can contain a shell command or an
    action from GitHub Marketplace.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steps`: 这个字段包含将在我们的作业中运行的步骤。在我们的例子中，我们有一个将运行命令的单个步骤。这个命令将打印出触发我们的工作流程的事件。一个步骤可以包含一个
    shell 命令或来自 GitHub Marketplace 的动作。'
- en: 'Click on the **Commit changes...** button. This will commit our workflow file
    to our repository and trigger our workflow. We can see the workflow running in
    the **Actions** tab, as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **提交更改...** 按钮。这将把我们的工作流程文件提交到我们的仓库并触发我们的工作流程。我们可以在 **操作** 选项卡中看到工作流程正在运行，如下面的截图所示：
- en: '![Figure 14.4 – First GitHub Action](img/B19779_14_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 第一个 GitHub Action](img/B19779_14_04.jpg)'
- en: Figure 14.4 – First GitHub Action
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 第一个 GitHub Action
- en: 'In the preceding image, we can see the commit that triggered the workflow and
    the workflow itself. We can also see the job that was run and the step that was
    run. We can also see the output of the step. Additionally, we can see the time
    it took to run the workflow. If we tap the action, we can see more details:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到触发工作流程的提交和工作流程本身。我们还可以看到运行的作业和步骤。我们还可以看到步骤的输出。此外，我们还可以看到运行工作流程所需的时间。如果我们点击动作，我们可以看到更多详细信息：
- en: '![Figure 14.5 – Github Action details](img/B19779_14_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – Github Action 详细信息](img/B19779_14_05.jpg)'
- en: Figure 14.5 – Github Action details
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – Github Action 详细信息
- en: This shows the steps that were run and the time the job took to run. It also
    shows the total duration of the workflow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了运行的步骤和作业运行的时间。它还显示了工作流程的总持续时间。
- en: This was a simple workflow that just printed out the event that triggered the
    workflow. We can also do more complex things in our workflow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的只打印出触发工作流程的事件的工作流程。我们也可以在我们的工作流程中做更复杂的事情。
- en: 'Let us see how we can set up Android-related actions in our workflow:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在我们的工作流程中设置与 Android 相关的操作：
- en: Head to the newly created `.github/workflows` folder and edit the `main.yml`
    file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往新创建的 `.github/workflows` 文件夹并编辑 `main.yml` 文件。
- en: 'Let us add the following code to our workflow below the previous command we
    ran in *step 3* of the previous section:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在上一节中 *步骤 3* 运行的命令下方添加以下代码：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us understand the preceding code:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码：
- en: We have created another step called `Checkout`. This step will `checkout` our
    code from our repository. This is done using the `checkout` action, which we specify
    using the `uses` field. This action is fetched from GitHub Marketplace.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `Checkout` 的另一个步骤。这个步骤将从我们的仓库中 `checkout` 我们的代码。这是通过使用 `checkout`
    动作完成的，我们使用 `uses` 字段指定了这个动作。这个动作是从 GitHub Marketplace 获取的。
- en: We have created another step called `Set up JDK 17`. This step will set up JDK
    17\. `setup-java` action, which we specify using the `uses` field. We specify
    the version of Java we want to use using the `java-version` field. We specify
    the distribution of Java we want to use using the `distribution` field. We also
    specify that we want to cache Gradle using the `cache` field.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `Set up JDK 17` 的另一个步骤。这个步骤将设置 JDK 17。我们使用 `uses` 字段指定了 `setup-java`
    动作。我们使用 `java-version` 字段指定了我们想要使用的 Java 版本。我们使用 `distribution` 字段指定了我们想要使用的 Java
    发行版。我们还使用 `cache` 字段指定了我们要缓存 Gradle。
- en: We have created another step called `Grant execute permission for gradlew`.
    This step will grant execute permission for gradlew. This is done using the `run`
    command. We specify the command we want to run using the `run` field. We also
    specify the working directory we want to run the command in using the `working-directory`
    field. In this case, we want to run the command in the `chapterfourteen` folder
    since we have a number of folders in our repository. Note that this step is platform-dependent
    since it is only necessary for Unix-based systems but might be redundant for Windows-based
    systems. Therefore, it may not be required in all CI/CD setups.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Grant execute permission for gradlew`的另一个步骤。此步骤将为gradlew授予执行权限。这是通过`run`命令完成的。我们使用`run`字段指定我们想要运行的命令。我们还使用`working-directory`字段指定我们想要运行命令的工作目录。在这种情况下，我们希望在`chapterfourteen`文件夹中运行命令，因为我们仓库中有许多文件夹。请注意，此步骤是平台相关的，因为它对于基于Unix的系统是必要的，但对于基于Windows的系统可能是多余的。因此，它可能不是所有CI/CD设置中必需的。
- en: Lastly, we have created another step called `Build with Gradle`. This step will
    build our project using Gradle. Here, we run the `./gradlew assembleDebug` command.
    This command generates a debug Android APK for our project. We also specify the
    working directory in which we want to run the command.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个名为`Build with Gradle`的另一个步骤。此步骤将使用Gradle构建我们的项目。在这里，我们运行`./gradlew
    assembleDebug`命令。此命令为我们项目生成一个调试Android APK。我们还指定了要运行命令的工作目录。
- en: One thing to note is that `.yml` files are overly sensitive to indentation.
    So, we need to ensure that we indent our code correctly.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是`.yml`文件对缩进非常敏感。因此，我们需要确保我们的代码缩进正确。
- en: 'Commit to the changes and the action will automatically run. We can see the
    workflow results and, looking at the job build, we can see all the steps that
    were run, as shown in the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交更改后，操作将自动运行。我们可以查看工作流程结果，并查看作业构建，我们可以看到所有运行的步骤，如下面的截图所示：
- en: '![Figure 14.6 – GitHub Action steps](img/B19779_14_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – GitHub操作步骤](img/B19779_14_06.jpg)'
- en: Figure 14.6 – GitHub Action steps
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – GitHub操作步骤
- en: We now know what GitHub Actions are, have created our first action, and have
    seen how we can run Android-specific workflows on GitHub Actions. In the next
    section, we will run lint checks and tests in our workflow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GitHub操作是什么，创建了我们的第一个操作，并看到了如何在GitHub操作上运行Android特定的工作流程。在下一节中，我们将在工作流程中运行lint检查和测试。
- en: Running lint checks and tests on GitHub Actions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitHub操作上运行lint检查和测试
- en: 'In [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135), we learned how to run
    lint checks on our project using shell commands on the terminal. We have also
    learned how to write tests for our code base. In this section, we are going to
    run the format, lint checks, and tests on our newly created actions and we will
    do all of this step by step:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B19779_11.xhtml#_idTextAnchor135)中，我们学习了如何使用终端上的shell命令在我们的项目中运行lint检查。我们还学习了如何为我们的代码库编写测试。在本节中，我们将逐步在我们的新创建的操作上运行格式、lint检查和测试：
- en: 'First, we will add the `ktlintCheck` step:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加`ktlintCheck`步骤：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we have added a step called `Run ktlintCheck`. This step will
    run the `ktlintCheck` command, which will check whether our code is formatted
    correctly. This step fails if our code is not formatted correctly.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们添加了一个名为`Run ktlintCheck`的步骤。此步骤将运行`ktlintCheck`命令，该命令将检查我们的代码是否格式正确。如果我们的代码格式不正确，此步骤将失败。
- en: 'Next, we add the `detekt` step:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加`detekt`步骤：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this step, we run the `detekt` command, which will run the detekt checks
    on the code that we set up earlier in [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135).
    This step fails if our code does not pass the detekt checks.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，我们运行`detekt`命令，该命令将在[*第11章*](B19779_11.xhtml#_idTextAnchor135)中较早设置的代码上运行detekt检查。如果我们的代码未通过detekt检查，此步骤将失败。
- en: 'Next, we add the test step:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加测试步骤：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This step will run all the unit tests in our project. This step fails if any
    of the tests fail.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此步骤将在我们的项目中运行所有单元测试。如果任何测试失败，此步骤将失败。
- en: 'Lastly, we add the step to run our instrumented tests:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加运行仪器化测试的步骤：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This step uses the `android-emulator-runner` action to run our instrumented
    tests on an emulator. This action sets up an emulator to run our instrumented
    tests in the CI environment. In the action configuration, we set up the following:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此步骤使用`android-emulator-runner`操作来在模拟器上运行我们的仪器化测试。此操作在CI环境中设置模拟器以运行我们的仪器化测试。在操作配置中，我们设置了以下内容：
- en: '`working-directory`: This is where our project is located.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工作目录`：这是我们的项目所在的位置。'
- en: '`api-level`: This is the API level of the platform system image for our emulator.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api-level`：这是我们模拟器平台系统镜像的API级别。'
- en: '`target`: This is the target for the system image of the emulator.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是模拟器系统镜像的目标。'
- en: '`architecture`: We specify the architecture of the emulator we want to run
    our tests on.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`架构`：我们指定要在其上运行测试的模拟器的架构。'
- en: '`disable-animations`: We disable animations in the emulator.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable-animations`：我们在模拟器中禁用动画。'
- en: Lastly, we specify the command we want to run using the script field. In this
    case, we run the `connectedCheck` task, which will run our instrumented tests.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用脚本字段指定我们想要运行的命令。在这种情况下，我们运行`connectedCheck`任务，这将运行我们的仪器化测试。
- en: 'After making the preceding changes, commit the changes and the action will
    run. We can see the results of the action in the **Actions** tab, as shown in
    the following screenshot:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行上述更改后，提交更改，操作将运行。我们可以在**操作**标签中查看操作的结果，如下面的截图所示：
- en: '![Figure 14.7 – More Github Actions steps](img/B19779_14_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 更多Github Actions步骤](img/B19779_14_07.jpg)'
- en: Figure 14.7 – More Github Actions steps
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 更多Github Actions步骤
- en: We’ve expanded our workflow by incorporating additional steps to perform lint
    checks and tests. We can see the results of each step. We can also see the time
    it took to run each step. The `Run connected test` step takes the longest time
    to run. This is because it must set up the emulator and run the tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过增加额外的步骤来扩展我们的工作流程，以执行lint检查和测试。我们可以看到每个步骤的结果。我们还可以看到运行每个步骤所需的时间。`运行连接测试`步骤运行时间最长。这是因为它必须设置模拟器并运行测试。
- en: 'We need to modify when the `main.yml` file runs. Currently, our workflow runs
    when we push code to the main branch. We are going to change this to also run
    when we create a pull request to the main branch. This is because we want to run
    our checks before we move our code to the main branch. To do this, we are going
    to add the `pull_request` event just above the `workflow_dispatch` event:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`main.yml`文件运行的时间。目前，我们的工作流程在我们向主分支推送代码时运行。我们将将其更改为在向主分支创建拉取请求时也运行。这是因为我们希望在将代码移动到主分支之前运行我们的检查。为此，我们将在`workflow_dispatch`事件之上添加`pull_request`事件：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After making this change, we can commit the changes and the action will run.
    Let us now create a pull request to test the changes. Ensure that you pull all
    the changes that we made in our browser locally before proceeding with the following
    steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此更改后，我们可以提交更改，操作将运行。现在，让我们创建一个拉取请求来测试这些更改。确保在执行以下步骤之前，您在我们的浏览器本地拉取了我们所做的所有更改：
- en: First, let us create a new branch called `test`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`test`的新分支。
- en: 'Open the terminal in Android Studio and run the following command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开终端并运行以下命令：
- en: '[PRE7]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let us modify the app’s `versionName` and `versionCode` in our app-level
    `build.gradle.kts` file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们修改应用级别的`build.gradle.kts`文件中的`versionName`和`versionCode`：
- en: '[PRE8]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tap **Sync Now** to sync these changes to our project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**立即同步**以将这些更改同步到我们的项目中。
- en: 'After making the `versionName` and `versionCode` changes, we can commit the
    changes and push them to our remote repository. We can do this by running the
    following command in the terminal:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对`versionName`和`versionCode`进行更改后，我们可以提交更改并将它们推送到我们的远程仓库。我们可以在终端中运行以下命令来完成此操作：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command stages all the changes we have made.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将我们已做的所有更改暂存。
- en: 'Next, we run the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command commits the changes we have made.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令提交我们已做的更改。
- en: 'Next, we run the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command pushes the changes to our remote repository.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将更改推送到我们的远程仓库。
- en: 'Next, head to our repository in a browser, open the **Pull requests** tab,
    and click on the **New pull request** button. This will open the following page:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在浏览器中转到我们的仓库，打开**拉取请求**标签，然后点击**新建拉取请求**按钮。这将打开以下页面：
- en: '![Figure 14.8 – Create a new pull request](img/B19779_14_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 创建新的拉取请求](img/B19779_14_08.jpg)'
- en: Figure 14.8 – Create a new pull request
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 创建新的拉取请求
- en: On this page, we set the `base` branch and the `compare` branch. The `base`
    branch is the branch we want to merge our changes to. In our case, we want to
    merge our changes to the `main` branch. The `compare` branch is the branch that
    has recent changes. In our case, we want to merge changes from the `test` branch
    to the `main` branch. We can see the changes we have made as soon as we set the
    `compare` branch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，我们设置了`base`分支和`compare`分支。`base`分支是我们想要合并更改的分支。在我们的例子中，我们想要将更改合并到`main`分支。`compare`分支是包含最近更改的分支。在我们的例子中，我们想要将`test`分支的更改合并到`main`分支。我们可以在设置`compare`分支后立即看到我们所做的更改。
- en: 'Finalize the pull request by clicking on the **Create pull request** button.
    After creating the pull request, we can review the pull request details:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**创建拉取请求**按钮来最终确定拉取请求。创建拉取请求后，我们可以查看拉取请求的详细信息：
- en: '![Figure 14.9 – Pull request checks](img/B19779_14_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – 拉取请求检查](img/B19779_14_09.jpg)'
- en: Figure 14.9 – Pull request checks
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 拉取请求检查
- en: As seen in the preceding image, the workflow checks have started running since
    we created a pull request and we specified that our workflow should run when we
    create a pull request. The **Merge pull request** button is disabled since the
    workflow is still running.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，工作流程检查已经开始运行，因为我们创建了一个拉取请求，并指定了当创建拉取请求时应该运行我们的工作流程。由于工作流程仍在运行，**合并拉取请求**按钮被禁用。
- en: 'Once the workflow is done running, we can merge the pull request. We can enforce
    even further rules per the checks but for now, we are good to go with the default
    behavior. Once the workflow completes and all checks pass, we should see the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作流程运行完成，我们可以合并拉取请求。我们可以根据检查强制执行更进一步的规则，但现在，我们默认行为就足够了。一旦工作流程完成并且所有检查都通过，我们应该看到以下内容：
- en: '![Figure 14.10 – Pull request checks complete](img/B19779_14_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – 拉取请求检查完成](img/B19779_14_10.jpg)'
- en: Figure 14.10 – Pull request checks complete
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 拉取请求检查完成
- en: We have now learned how to run lint checks and tests on GitHub Actions. In the
    next section, we are going to learn how to deploy our app to Google Play Store
    using GitHub Actions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何在GitHub Actions上运行lint检查和测试。在下一节中，我们将学习如何使用GitHub Actions将我们的应用程序部署到Google
    Play Store。
- en: Deploying to Play Store using GitHub Actions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions部署到Play Store
- en: In [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175), we learned how to deploy
    our app to Google Play Store using Google Play Console. However, in that chapter,
    we did it manually. In this chapter, we are going to learn how to deploy our app
    to Google Play Store using GitHub Actions. We are going to use the Google Play
    Publisher action to deploy our app to Google Play Store. This action is available
    in GitHub Marketplace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B19779_13.xhtml#_idTextAnchor175)中，我们学习了如何使用Google Play Console将我们的应用程序部署到Google
    Play Store。然而，在第13章中，我们是手动完成的。在本章中，我们将学习如何使用GitHub Actions将我们的应用程序部署到Google Play
    Store。我们将使用Google Play Publisher action将我们的应用程序部署到Google Play Store。这个操作可在GitHub
    Marketplace中找到。
- en: 'Before we can write our workflow, we need to do some setup. We need to create
    a service account on our Google Play Store account. We can do this by following
    these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够编写我们的工作流程之前，我们需要做一些设置。我们需要在我们的Google Play Store账户上创建一个服务账户。我们可以通过以下步骤来完成：
- en: 'Configure the service account in Google Cloud Platform by following these steps:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在Google Cloud Platform中配置服务账户：
- en: Navigate to [https://cloud.google.com/gcp](https://cloud.google.com/gcp).
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[https://cloud.google.com/gcp](https://cloud.google.com/gcp)。
- en: Navigate to `GOOGLE_SERVICES_JSON`. This is the name we will use in our workflow
    to access the JSON file.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`GOOGLE_SERVICES_JSON`。这是我们将在工作流程中使用以访问JSON文件的名字。
- en: 'Add a user to Google Play Console by following these steps:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤将用户添加到Google Play Console：
- en: Open [https://play.google.com/console](https://play.google.com/console) and
    pick your developer account.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[https://play.google.com/console](https://play.google.com/console)并选择您的开发者账户。
- en: Open **Users** **and permissions**.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**用户** **和权限**。
- en: Click on **Invite new user** and add the email of the service account created
    in step 1.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**邀请新用户**并添加步骤1中创建的服务账户的电子邮件。
- en: Grant permissions to the app to which you want the service account to deploy
    in-app permissions.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予服务账户部署的应用程序内权限。
- en: 'If you need more details on how to do this, you can check out the following
    link: [https://developers.google.com/android/management/service-account](https://developers.google.com/android/management/service-account)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要更多关于如何操作的详细信息，您可以查看以下链接：[https://developers.google.com/android/management/service-account](https://developers.google.com/android/management/service-account)
- en: 'Like how we created the `GOOGLE_SERVICES_JSON` variable in our repository secrets,
    we need to add the details of our signing certificate to our variables so that
    we can use them on our CI/CD pipeline. The first step is to generate a `base64`-encoded
    version of our signing certificate. We can do this by running the following command
    in the terminal:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在仓库秘密中创建`GOOGLE_SERVICES_JSON`变量一样，我们需要将我们的签名证书的详细信息添加到我们的变量中，这样我们就可以在CI/CD管道中使用它们。第一步是生成签名证书的`base64`编码版本。我们可以在终端中运行以下命令来完成此操作：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should run this command in the directory where you saved your keystore
    file. You could change the name to match the filename of the keystore file if
    you named yours differently. This command will generate a `base64`-encoded version
    of our keystore file. We can then copy the contents of the file and add it to
    our repository secrets. We need to also add the following secrets to our repository:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在保存您的密钥库文件的目录中运行此命令。如果您将其命名为不同的名称，可以将其更改为与密钥库文件名匹配。此命令将生成密钥库文件的`base64`编码版本。然后我们可以复制文件内容并将其添加到我们的仓库秘密中。我们还需要将以下秘密添加到我们的仓库中：
- en: '![Figure 14.11 – Repository secrets](img/B19779_14_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 仓库秘密](img/B19779_14_11.jpg)'
- en: Figure 14.11 – Repository secrets
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 仓库秘密
- en: 'The newly created secrets are explained as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的秘密解释如下：
- en: '`KEYSTORE_PASSWORD`: This is the password of our keystore file'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEYSTORE_PASSWORD`: 这是我们的密钥库文件的密码'
- en: '`KEY_ALIAS`: This is the alias of our keystore file'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_ALIAS`: 这是我们的密钥库文件的别名'
- en: '`KEY_PASSWORD`: This is the password of our keystore file alias'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_PASSWORD`: 这是我们的密钥库文件别名的密码'
- en: 'All these details should be like the ones we used when we created our keystore
    file. Now, let us write our workflow. Before writing the workflow, ensure that
    you have completed the publishing of our app steps in [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175),
    since this is needed for this action to work. Let us head to the `.github/workflows`
    folder, create a new file called `deploy-to-playstore.yml`, and add the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些细节都应该像我们创建密钥库文件时使用的那样。现在，让我们编写我们的工作流程。在编写工作流程之前，请确保您已经完成了[*第13章*](B19779_13.xhtml#_idTextAnchor175)中我们的应用程序发布步骤，因为这是此操作所需。让我们前往`.github/workflows`文件夹，创建一个名为`deploy-to-playstore.yml`的新文件，并添加以下代码：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The workflow is remarkably similar to the one we created earlier on in the *Setting
    up GitHub Actions* and *Running lint checks and tests in GitHub Actions* sections
    with only slight differences. We have a step that bumps the `versionName` and
    `versionCode` for us instead of us having to do this manually every time. Versioning
    serves as a structured identifier for different software iterations. Employing
    semantic versioning aids in communicating the impact of changes, distinguishing
    major backward-incompatible updates, minor backward-compatible feature additions,
    and patch-level bug fixes. It plays a crucial role in dependency management, facilitating
    compatibility between different components. Additionally, versioning supports
    rollbacks, hotfixes, and efficient testing, ensuring the stability of the application.
    Release notes and communication are streamlined, providing users and stakeholders
    with clear insights into each release. Ultimately, versioning contributes to a
    reliable and predictable user experience, fostering trust and transparency throughout
    the software development life cycle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程与我们之前在*设置GitHub Actions*和*在GitHub Actions中运行lint检查和测试*部分创建的工作流程非常相似，只有细微的差别。我们有一个步骤可以自动增加`versionName`和`versionCode`，而不是每次都手动进行。版本号作为不同软件版本的有序标识符。采用语义版本控制有助于传达更改的影响，区分主要不兼容更新、次要兼容性功能添加和补丁级别的错误修复。它在依赖关系管理中发挥着关键作用，促进不同组件之间的兼容性。此外，版本控制支持回滚、热修复和高效测试，确保应用程序的稳定性。发布说明和沟通流程简化，为用户和利益相关者提供对每个发布的清晰洞察。最终，版本控制有助于提供可靠和可预测的用户体验，在整个软件开发生命周期中促进信任和透明度。
- en: 'We have another step that builds a signed `upload-google-play` action, which
    automates and makes the process easier. We do the configurations on this action,
    such as specifying our service account, the package name of our app on Play Store,
    the directory where our signed AAB will be found, and lastly, the track that we
    want to deploy to. Pushing the changes to the main branch will trigger the actions
    again and once the `deploy-to-playstore` workflow is complete, we should see a
    new internal testing release on our Play Store page, as shown in the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个步骤，它构建了一个名为 `upload-google-play` 的签名操作，这自动化了过程并使其变得更简单。我们在该操作上执行配置，例如指定我们的服务账户、我们在
    Play Store 上的应用包名、我们的签名 AAB 将被找到的目录，以及最后，我们想要部署的轨道。将更改推送到主分支将再次触发操作，一旦 `deploy-to-playstore`
    工作流程完成，我们应该在我们的 Play Store 页面上看到一个新的内部测试版本，如下所示：
- en: '![Figure 14.12 – New internal testing release](img/B19779_14_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 新的内部测试版本](img/B19779_14_12.jpg)'
- en: Figure 14.12 – New internal testing release
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 新的内部测试版本
- en: We have completed putting in place our CI/CD process. We only do this setup
    once and we can always use it to make deployments and automated testing easier,
    faster, and more reliable for us.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 CI/CD 流程的建立。我们只设置一次这个环境，并且我们可以始终使用它来简化我们的部署和自动化测试，使其更快、更可靠。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use GitHub Actions to automate some manual
    tasks, such as deploying new builds to the Play Store. Additionally, we learned
    how to run lint checks and tests on CI/CD pipelines and push builds to Google
    Play Store using GitHub Actions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 GitHub Actions 自动化一些手动任务，例如将新构建部署到 Play Store。此外，我们还学习了如何在 CI/CD
    管道上运行 lint 检查和测试，并使用 GitHub Actions 将构建推送到 Google Play Store。
- en: In the next chapter, we will learn about techniques to improve our apps by adding
    analytics, using Firebase Crashlytics, and using cloud messaging to increase user
    engagement in our apps. Additionally, we will learn some tips and tricks for securing
    our apps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习通过添加分析、使用 Firebase Crashlytics 以及使用云消息来增加我们应用的用户参与度的技术。此外，我们还将学习一些确保我们应用安全性的技巧和窍门。
