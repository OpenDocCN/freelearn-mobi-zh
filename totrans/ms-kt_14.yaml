- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous Integration and Continuous Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we complete the development and first deployment of our app, we must think
    of how to make the process smoother for consecutive deployments, and that’s where
    **Continuous integration/Continuous delivery** (**CI/CD**) comes in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use GitHub Actions to automate some of
    the manual tasks, such as deploying new builds to the Google Play Store. We will
    learn how to run tests on CI/CD pipelines and push builds to the Play Store using
    GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running lint checks and tests on GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Play Store using GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can understand GitHub Actions, we need to understand what CI/CD is.
    This is a process that allows us to automate the building, testing, and deployment
    of our code to production. CI/CD not only automates these processes but also integrates
    them into a single coherent pipeline. This ensures that code changes are more
    reliable and stable when deployed. The definition should emphasize the role of
    CI/CD in facilitating frequent and reliable updates. This is an especially important
    process as it aims to improve the speed, efficiency, and reliability of how we
    deliver our software.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go through some of the benefits of CI/CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast release cycles**: CI/CD allows us to release our software faster and
    more frequently. This is because we are automating the process of building, testing,
    and deploying our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased collaboration**: Since a lot of the processes are automated, we
    can focus on the code and the features we are building. This allows us to collaborate
    more effectively with our team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less manual work**: We are reducing the amount of manual work we do due to
    automation. This means we can focus on the code and the features we are building.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved quality**: Automating the process allows us to test our code more
    frequently and more effectively. This means we can catch bugs and errors earlier
    in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have learned about the benefits of CI/CD, let us look at how CI/CD works
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How CI/CD works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us go through how CI/CD works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CI**: This is the process of automating the building and testing of our code.
    This is done every time we push our code to our repository. This allows us to
    catch bugs and errors earlier in the process. In this step, once we push or commit
    code to our remote repository, which can be hosted in GitHub, Gitlab, Bitbucket,
    and so on, we run checks and tests against these changes to ensure they are functional
    and meet the code quality standards. If the tests pass, we can merge the code
    into the main branch. If the tests fail, we can fix the code and run the tests
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CD**: This is the process of automating the deployment of our code to production.
    This is done every time we push our code to our repository. This allows us to
    release our software faster and more frequently. This happens after the CI step.
    Once the changes are merged to the main or development branch, we can deploy the
    code to production or whichever environment it needs to be deployed to. This step
    aims at pushing minor changes to production more frequently. This allows us to
    release our software faster and more frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this background, we can now look at GitHub Actions ([https://docs.github.com/en/actions](https://docs.github.com/en/actions)).
    GitHub Actions is a CI/CD tool that allows us to automate the building, testing,
    and deployment of our code. It is built into GitHub and is free to use up to certain
    limits. It is also extremely easy to use and set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we are going to set up GitHub Actions for our project
    that is in this repository: [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable GitHub Actions in our project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the **Actions** tab of our repository, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – GitHub Actions tab](img/B19779_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – GitHub Actions tab
  prefs: []
  type: TYPE_NORMAL
- en: 'This step will bring us to the GitHub Actions landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – GitHub Actions landing page](img/B19779_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – GitHub Actions landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding image, we have some suggested actions that we can
    use in our repository. For now, we will set the actions by ourselves, so let us
    click on the **set up a workflow yourself** option. This brings us to the following
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – New GitHub Action](img/B19779_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – New GitHub Action
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding image, we have an editor for writing our workflow.
    Notice at the top we now have a new folder called `.github`. This is where we
    will store our workflow files. The editor saves the workflow file in the `.github/workflows`
    folder. By default, our workflow is named `main.yml`. On the right, we have templates
    that we can use to easily create our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we are going to create our own workflow, so let us add the following
    code to our workflow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s understand the different fields in the preceding workflow file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name`: This is the name of our workflow. This will be displayed on the GitHub
    Actions page.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on`: This is the event that will trigger our workflow. In our case, we are
    triggering our workflow when we push code to the main branch.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workflow_dispatch`: This is a manual trigger that we can use to trigger our
    workflow from the GitHub Actions page. This is useful when we want to trigger
    our workflow manually.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jobs`: This is the job that will be run when our workflow is triggered. In
    our case, we have a job called `build`. This job will run on the latest version
    of Ubuntu as specified by the `runs-on` field.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`steps`: This field contains the steps that will be run in our job. In our
    case, we have a single step that will run a command. This command will print out
    the event that triggered our workflow. A step can contain a shell command or an
    action from GitHub Marketplace.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on the **Commit changes...** button. This will commit our workflow file
    to our repository and trigger our workflow. We can see the workflow running in
    the **Actions** tab, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – First GitHub Action](img/B19779_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – First GitHub Action
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding image, we can see the commit that triggered the workflow and
    the workflow itself. We can also see the job that was run and the step that was
    run. We can also see the output of the step. Additionally, we can see the time
    it took to run the workflow. If we tap the action, we can see more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Github Action details](img/B19779_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Github Action details
  prefs: []
  type: TYPE_NORMAL
- en: This shows the steps that were run and the time the job took to run. It also
    shows the total duration of the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple workflow that just printed out the event that triggered the
    workflow. We can also do more complex things in our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how we can set up Android-related actions in our workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the newly created `.github/workflows` folder and edit the `main.yml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us add the following code to our workflow below the previous command we
    ran in *step 3* of the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us understand the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have created another step called `Checkout`. This step will `checkout` our
    code from our repository. This is done using the `checkout` action, which we specify
    using the `uses` field. This action is fetched from GitHub Marketplace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created another step called `Set up JDK 17`. This step will set up JDK
    17\. `setup-java` action, which we specify using the `uses` field. We specify
    the version of Java we want to use using the `java-version` field. We specify
    the distribution of Java we want to use using the `distribution` field. We also
    specify that we want to cache Gradle using the `cache` field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created another step called `Grant execute permission for gradlew`.
    This step will grant execute permission for gradlew. This is done using the `run`
    command. We specify the command we want to run using the `run` field. We also
    specify the working directory we want to run the command in using the `working-directory`
    field. In this case, we want to run the command in the `chapterfourteen` folder
    since we have a number of folders in our repository. Note that this step is platform-dependent
    since it is only necessary for Unix-based systems but might be redundant for Windows-based
    systems. Therefore, it may not be required in all CI/CD setups.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have created another step called `Build with Gradle`. This step will
    build our project using Gradle. Here, we run the `./gradlew assembleDebug` command.
    This command generates a debug Android APK for our project. We also specify the
    working directory in which we want to run the command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to note is that `.yml` files are overly sensitive to indentation.
    So, we need to ensure that we indent our code correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Commit to the changes and the action will automatically run. We can see the
    workflow results and, looking at the job build, we can see all the steps that
    were run, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – GitHub Action steps](img/B19779_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – GitHub Action steps
  prefs: []
  type: TYPE_NORMAL
- en: We now know what GitHub Actions are, have created our first action, and have
    seen how we can run Android-specific workflows on GitHub Actions. In the next
    section, we will run lint checks and tests in our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Running lint checks and tests on GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135), we learned how to run
    lint checks on our project using shell commands on the terminal. We have also
    learned how to write tests for our code base. In this section, we are going to
    run the format, lint checks, and tests on our newly created actions and we will
    do all of this step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the `ktlintCheck` step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we have added a step called `Run ktlintCheck`. This step will
    run the `ktlintCheck` command, which will check whether our code is formatted
    correctly. This step fails if our code is not formatted correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add the `detekt` step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this step, we run the `detekt` command, which will run the detekt checks
    on the code that we set up earlier in [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135).
    This step fails if our code does not pass the detekt checks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add the test step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step will run all the unit tests in our project. This step fails if any
    of the tests fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, we add the step to run our instrumented tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step uses the `android-emulator-runner` action to run our instrumented
    tests on an emulator. This action sets up an emulator to run our instrumented
    tests in the CI environment. In the action configuration, we set up the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`working-directory`: This is where our project is located.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api-level`: This is the API level of the platform system image for our emulator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`: This is the target for the system image of the emulator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`architecture`: We specify the architecture of the emulator we want to run
    our tests on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disable-animations`: We disable animations in the emulator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we specify the command we want to run using the script field. In this
    case, we run the `connectedCheck` task, which will run our instrumented tests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making the preceding changes, commit the changes and the action will
    run. We can see the results of the action in the **Actions** tab, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – More Github Actions steps](img/B19779_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – More Github Actions steps
  prefs: []
  type: TYPE_NORMAL
- en: We’ve expanded our workflow by incorporating additional steps to perform lint
    checks and tests. We can see the results of each step. We can also see the time
    it took to run each step. The `Run connected test` step takes the longest time
    to run. This is because it must set up the emulator and run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify when the `main.yml` file runs. Currently, our workflow runs
    when we push code to the main branch. We are going to change this to also run
    when we create a pull request to the main branch. This is because we want to run
    our checks before we move our code to the main branch. To do this, we are going
    to add the `pull_request` event just above the `workflow_dispatch` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After making this change, we can commit the changes and the action will run.
    Let us now create a pull request to test the changes. Ensure that you pull all
    the changes that we made in our browser locally before proceeding with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let us create a new branch called `test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal in Android Studio and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let us modify the app’s `versionName` and `versionCode` in our app-level
    `build.gradle.kts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tap **Sync Now** to sync these changes to our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After making the `versionName` and `versionCode` changes, we can commit the
    changes and push them to our remote repository. We can do this by running the
    following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command stages all the changes we have made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command commits the changes we have made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command pushes the changes to our remote repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, head to our repository in a browser, open the **Pull requests** tab,
    and click on the **New pull request** button. This will open the following page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Create a new pull request](img/B19779_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Create a new pull request
  prefs: []
  type: TYPE_NORMAL
- en: On this page, we set the `base` branch and the `compare` branch. The `base`
    branch is the branch we want to merge our changes to. In our case, we want to
    merge our changes to the `main` branch. The `compare` branch is the branch that
    has recent changes. In our case, we want to merge changes from the `test` branch
    to the `main` branch. We can see the changes we have made as soon as we set the
    `compare` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finalize the pull request by clicking on the **Create pull request** button.
    After creating the pull request, we can review the pull request details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Pull request checks](img/B19779_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Pull request checks
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding image, the workflow checks have started running since
    we created a pull request and we specified that our workflow should run when we
    create a pull request. The **Merge pull request** button is disabled since the
    workflow is still running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the workflow is done running, we can merge the pull request. We can enforce
    even further rules per the checks but for now, we are good to go with the default
    behavior. Once the workflow completes and all checks pass, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Pull request checks complete](img/B19779_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Pull request checks complete
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to run lint checks and tests on GitHub Actions. In the
    next section, we are going to learn how to deploy our app to Google Play Store
    using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Play Store using GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175), we learned how to deploy
    our app to Google Play Store using Google Play Console. However, in that chapter,
    we did it manually. In this chapter, we are going to learn how to deploy our app
    to Google Play Store using GitHub Actions. We are going to use the Google Play
    Publisher action to deploy our app to Google Play Store. This action is available
    in GitHub Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can write our workflow, we need to do some setup. We need to create
    a service account on our Google Play Store account. We can do this by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the service account in Google Cloud Platform by following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to [https://cloud.google.com/gcp](https://cloud.google.com/gcp).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `GOOGLE_SERVICES_JSON`. This is the name we will use in our workflow
    to access the JSON file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a user to Google Play Console by following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open [https://play.google.com/console](https://play.google.com/console) and
    pick your developer account.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **Users** **and permissions**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Invite new user** and add the email of the service account created
    in step 1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Grant permissions to the app to which you want the service account to deploy
    in-app permissions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you need more details on how to do this, you can check out the following
    link: [https://developers.google.com/android/management/service-account](https://developers.google.com/android/management/service-account)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Like how we created the `GOOGLE_SERVICES_JSON` variable in our repository secrets,
    we need to add the details of our signing certificate to our variables so that
    we can use them on our CI/CD pipeline. The first step is to generate a `base64`-encoded
    version of our signing certificate. We can do this by running the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should run this command in the directory where you saved your keystore
    file. You could change the name to match the filename of the keystore file if
    you named yours differently. This command will generate a `base64`-encoded version
    of our keystore file. We can then copy the contents of the file and add it to
    our repository secrets. We need to also add the following secrets to our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Repository secrets](img/B19779_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – Repository secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly created secrets are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KEYSTORE_PASSWORD`: This is the password of our keystore file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_ALIAS`: This is the alias of our keystore file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_PASSWORD`: This is the password of our keystore file alias'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these details should be like the ones we used when we created our keystore
    file. Now, let us write our workflow. Before writing the workflow, ensure that
    you have completed the publishing of our app steps in [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175),
    since this is needed for this action to work. Let us head to the `.github/workflows`
    folder, create a new file called `deploy-to-playstore.yml`, and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The workflow is remarkably similar to the one we created earlier on in the *Setting
    up GitHub Actions* and *Running lint checks and tests in GitHub Actions* sections
    with only slight differences. We have a step that bumps the `versionName` and
    `versionCode` for us instead of us having to do this manually every time. Versioning
    serves as a structured identifier for different software iterations. Employing
    semantic versioning aids in communicating the impact of changes, distinguishing
    major backward-incompatible updates, minor backward-compatible feature additions,
    and patch-level bug fixes. It plays a crucial role in dependency management, facilitating
    compatibility between different components. Additionally, versioning supports
    rollbacks, hotfixes, and efficient testing, ensuring the stability of the application.
    Release notes and communication are streamlined, providing users and stakeholders
    with clear insights into each release. Ultimately, versioning contributes to a
    reliable and predictable user experience, fostering trust and transparency throughout
    the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another step that builds a signed `upload-google-play` action, which
    automates and makes the process easier. We do the configurations on this action,
    such as specifying our service account, the package name of our app on Play Store,
    the directory where our signed AAB will be found, and lastly, the track that we
    want to deploy to. Pushing the changes to the main branch will trigger the actions
    again and once the `deploy-to-playstore` workflow is complete, we should see a
    new internal testing release on our Play Store page, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – New internal testing release](img/B19779_14_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – New internal testing release
  prefs: []
  type: TYPE_NORMAL
- en: We have completed putting in place our CI/CD process. We only do this setup
    once and we can always use it to make deployments and automated testing easier,
    faster, and more reliable for us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use GitHub Actions to automate some manual
    tasks, such as deploying new builds to the Play Store. Additionally, we learned
    how to run lint checks and tests on CI/CD pipelines and push builds to Google
    Play Store using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about techniques to improve our apps by adding
    analytics, using Firebase Crashlytics, and using cloud messaging to increase user
    engagement in our apps. Additionally, we will learn some tips and tricks for securing
    our apps.
  prefs: []
  type: TYPE_NORMAL
