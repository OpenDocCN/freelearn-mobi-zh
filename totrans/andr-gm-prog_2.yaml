- en: Part 2. Module 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Android Game Programming by Example***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Harness the power of the Android SDK by building three immersive and captivating
    games*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chapter 1. Player 1 UP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terminology used by old arcade and pinball machines "1 UP" was a kind of
    notice to the players that they were playing (up) now. It was also used to indicate
    earning an extra life. Are you ready to build three great games?
  prefs: []
  type: TYPE_NORMAL
- en: We will build three cool games together. Every line of code for these three
    games is shown in this book; you will never have to refer to the code files to
    see what is going on. Also, the entire file set required to build all three games
    is included in the download bundle that can be obtained from the books page on
    the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: All the code, Android manifest files, and the graphical and audio assets are
    included in the download as well. The three cool games are progressively more
    challenging to implement.
  prefs: []
  type: TYPE_NORMAL
- en: The first project uses a simple but functional game engine that clearly demonstrates
    the essentials of a main game loop. The game will be fully working with the home
    screen, high scores, sound, and animation. But by the end of the project, as we
    add features and try to balance the game play, we will soon see that we need more
    flexibility in order to add features.
  prefs: []
  type: TYPE_NORMAL
- en: In the second project, a hard retro platformer, we will see how we can use a
    simple and flexible design to build a relatively fast and very flexible game engine,
    which is extendable and reusable. This flexibility will allow us to make quite
    a complex and well-featured game. This game will have multiple levels, different
    environments, and more. This in turn will highlight the need for being able to
    draw graphics more quickly. That leads us on to the third project.
  prefs: []
  type: TYPE_NORMAL
- en: In the third project, we will build an Asteroids-like game called **Asteroids
    simulator**. Although the game won't have as many features as the previous project,
    it will feature the super-smooth drawing of hundreds of animated game objects
    running at over 60 frames per second. We will achieve this by learning about and
    using the **Open Graphics Library for Embedded Systems** (**OpenGL ES 2**).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this book, you will have a whole repertoire of design ideas, techniques,
    and code templates that you can use in your future games. By seeing the strengths
    and weaknesses of the different ways of making games on Android, you will be able
    to successfully design and build games in the most appropriate way for your next
    big game.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a quick glimpse at the three projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tappy Defender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fly Flappy Bird-style with one finger to reach your home planet, while avoiding
    multiple enemies. Features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home screen![Tappy Defender](img/B04322_01_01.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple HUD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-finger touch screen controls![Tappy Defender](img/B04322_01_01b.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tough retro platformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a genuinely tough-to-beat retro style platform game. We have to guide
    Bob from the underground fire caves through the city, forest, and finally to the
    mountains. It has four challenging levels. Features include:'
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced, flexible game engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced "sprite sheet" character animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A level builder engine to design your levels in text format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple scrolling parallax backgrounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transition between levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more advanced HUD![Tough retro platformer](img/B04322_01_02.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add loads of extra diverse levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound manager to easily manage sound FX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pickups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An upgradeable gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seek-and-destroy enemy drones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple AI scripting for patrolling enemy guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hazards such as fire pits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenery objects to create atmosphere![Tough retro platformer](img/B04322_01_02b.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asteroids simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a classic shooter with retro vector-graphics style visuals. It involves
    clearing waves of smoothly animated spinning asteroids with a rapid fire gun.
    Features include:'
  prefs: []
  type: TYPE_NORMAL
- en: 60 frames per second or better, even on old hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to OpenGL ES 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooter with waves of progressive difficulty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced multiphase collision detection![Asteroids simulator](img/B04322_01_03.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code in this book and the download bundle will work in your favorite
    Android IDE. However, I found the latest version of Android Studio exceptionally
    friendly to use and the code was written and tested in it as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't currently use Android Studio, I encourage you to give it a try.
    Here is a quick overview of how to get up and running quickly. This guide includes
    steps to install the Java JDK in case you are completely new to Android development.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have your preferred development environment ready to go then
    jump straight to [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"),
    *Tappy Defender – First Step*.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is prepare your PC to develop for Android using
    Java. Fortunately, this is made quite simple for us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are learning on Mac or Linux everything in this book will still work.
    The next two tutorials have Windows-specific instructions and screenshots. However,
    it shouldn't be too difficult to vary the steps slightly to suit Mac or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the **Java Development Kit** (**JDK**), which allows us to develop in
    Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then install Android Studio to make Android development fast and easy. Android
    Studio uses the JDK and some other Android-specific tools that get automatically
    installed when we install Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get the latest version of the JDK. To complete
    this guide, perform the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be on the Java website, so visit: [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the three buttons shown here and click on the one that says **JDK** that
    is highlighted in the following image. They are on the right-hand side of the
    web page. Then, click on the **Download** button under the **JDK** option:![Installing
    the JDK](img/B04322_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be taken to a page that has multiple options to download the JDK. In
    the **Product/File Description** column, you need to click the option that matches
    your operating system. Windows, Mac, Linux, and some other less common options
    are all listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common question asked here is, do I have 32- or 64-bit windows? To find out,
    right-click on your **My Computer** icon (**This PC** on Windows 8), click on
    the **Properties** option, and look under the **System** heading at the **System
    type** entry:![Installing the JDK](img/B04322_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the somewhat hidden **Accept License Agreement** checkbox:![Installing
    the JDK](img/B04322_01_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on **download for your OS** and type as previously determined. Wait
    for the download to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your `downloads` folder, double-click on the file you just downloaded. The
    latest version at the time of writing for a 64-bit Windows PC was `jdk-8u5-windows-x64`.
    If you are using Mac/Linux or have a 32-bit OS, your filename will vary accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first of several install dialogs, click on the **Next** button and you
    will see the following dialog box:![Installing the JDK](img/B04322_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the defaults shown in the previous image by clicking on **Next**. In
    the next dialog box, you can accept the default install location by clicking on
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is the last dialog of the Java installer; for this click on **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The JDK is now installed. Next, we will make sure that Android Studio is able
    to use the JDK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on your **My Computer** icon (**This PC** on windows 8) and click
    on **Properties** | **Advanced system settings** | **Environment Variables...**
    | **New...** (under **System variables**, not under **User variables**). Now,
    you can see the **New System Variable** dialog box:![Installing the JDK](img/B04322_01_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `JAVA_HOME` for **Variable name:** and enter `C:\Program Files\Java\jdk1.8.0_05`
    for the **Variable value:** field. If you installed the JDK somewhere else, then
    the file path you enter in the **Variable value:** field will need to point to
    wherever you put it. Your exact file path will likely have a different ending
    to match the latest version of Java at the time you downloaded it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to save your new settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now under **System variables**, click on **Path** and then click on the **Edit...**
    button. At the very end of the text in the **Variable value:** field, enter the
    following text to add our new variable to the file paths that Windows will use,
    `;JAVA_HOME`. Be sure not to miss the semicolon from the beginning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to save the updated **Path** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click on **OK** again to clear the **Advanced system settings** dialog
    box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JDK is now installed on our PC.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without delay, let''s get Android Studio installed, and then we can begin our
    first game project. Visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the button labeled **DOWNLOAD ANDROID STUDIO FOR WINDOWS** to start
    the Android Studio download. This will take you to another web page with a very
    similar looking button to the one you just clicked on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license by checking the checkbox and commence the download by clicking
    the button labeled **DOWNLOAD ANDROID STUDIO FOR WINDOWS** and wait for the download
    to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder you just downloaded Android Studio to, right-click on the `android-studio-bundle-135.12465-windows.exe`
    file and click on **Run as administrator**. The end of your filename will vary
    depending on the version of Android Studio and your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When asked if you want to allow the following program from an unknown publisher
    to make changes to your computer, click on **Yes**. On the next screen, click
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the screen pictured here, you can choose which users of your PC can use Android
    Studio. Choose which is right for you as all options will work, and then click
    on **Next**:![Installing Android Studio](img/B04322_01_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next dialog, leave the default settings and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Choose start menu folder** dialog box leave the defaults and click
    on **Install**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Installation complete dialog, click on **Finish** to run Android Studio
    for the first time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next dialog is for users who have already used Android Studio, so assuming
    you are first-time user, select the **I do not have a previous version of Android
    Studio or I do not want to import my settings** checkbox. Then click on **OK**:![Installing
    Android Studio](img/B04322_01_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That was the last piece of software we needed. We will begin to use Android
    Studio straight away in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was deliberately kept as short as possible, so we can get on with
    building some games. We will do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2. Tappy Defender – First Step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first game, which we will learn about in three chapters. In this
    chapter, we will closely examine the goals for the finished product. It helps
    a lot when building a game, if we know exactly what we are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: We can then look at the structure of our code, including an approximate design
    pattern that we will be adhering to. Then, we will put together the code skeleton
    of our first game engine. Finally, to finish the chapter, we will draw our first
    real object from the game and animate it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will then be ready for [Chapter 3](ch12.html "Chapter 3. Tappy Defender –
    Taking Flight"), *Tappy Defender – Taking Flight*, where we can make really fast
    progress before completing our first game in [Chapter 4](ch13.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the first game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will flesh out exactly what our game will be. The backstory;
    who is our hero and what are they trying to achieve? The game mechanics; what
    will the player actually do? What buttons will he press and in what way is that
    a challenge or fun thing to do? Then, we will look at the rules. What constitutes
    victory, death, and progress? Finally, we will get technical and start to examine
    how we will actually build the game.
  prefs: []
  type: TYPE_NORMAL
- en: Backstory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Valerie has been defending the far outposts of humanity since the early '80s.
    Her brave exploits were originally immortalized in the 1981 arcade classic, Defender.
    However, after over 30 years on the front line, she is retiring and it is time
    to begin the journey home. Unfortunately, in a recent skirmish, her ship's engines
    and navigation systems were severely damaged. Therefore, now she must fly all
    the way home using only her boost thruster.
  prefs: []
  type: TYPE_NORMAL
- en: This means that she must fly her ship by simultaneously thrusting up and forward,
    kind of bouncing really, while avoiding enemies who try to crash into her. In
    a recent communication with Earth, Valerie was heard to claim that it was, "Like
    trying to fly a lame bird." This is some concept art of Valerie in her damaged
    ship because it helps to visualize our game as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Backstory](img/B04322_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have learned a little bit about our hero and her predicament, we
    take a closer look at the mechanics of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mechanics are the key actions that a player must make and become good at, to
    be able to beat the game. When designing a game, you can rely on tried and tested
    ideas for mechanics or you can invent your own. In Tappy Defender, we will be
    using a mechanic where the player taps and holds the screen to boost the ship.
  prefs: []
  type: TYPE_NORMAL
- en: This boosting will raise the ship up the screen, but will also make the ship
    speed up and therefore be more vulnerable. When the player removes their finger,
    the boost engine will cut out and the ship will fall downward and decelerate,
    thus making the ship slightly less vulnerable. Therefore, a very fine and masterful
    balance of boosting and not boosting is required to survive.
  prefs: []
  type: TYPE_NORMAL
- en: Tappy Defender is of course heavily inspired by Flappy Bird and a multitude
    of similar games that followed its success.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a how-far-can-I-get scoring system like Flappy Bird, Tappy Defender
    will have a goal of reaching "home". Then, the player can replay the game multiple
    times in order to try and beat their fastest time. Of course to go faster, the
    player must boost more frequently and put Valerie in greater peril.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the unlikely event you have never played or seen Flappy Bird, it is well
    worth spending 5 minutes having a play with this type of game now. You can download
    one of the many Flappy Bird inspired apps from the Google Play store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.google.com/store/search?q=flappy%20bird&c=apps](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will define things which balance the game and make it fair and consistent
    for the player:'
  prefs: []
  type: TYPE_NORMAL
- en: The player's ship is much tougher than the enemy ships. This is because the
    player's ship has shields. Each time the player collides with an enemy, the enemy
    is instantly destroyed, but the player loses a shield. The player has three shields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will need to fly a set number of kilometers to reach home.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player reaches home, they win the game. If their time was the
    fastest, they also get a new fastest time, like a high score.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies will spawn at a random height on the far right of the screen and fly
    toward the player at a random speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player is always positioned on the far left of the screen, but boosting
    will mean the enemies approach more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a loose design pattern, where we will separate our code based on
    a control part, model part, and view. This is how we will separate our code into
    three areas.
  prefs: []
  type: TYPE_NORMAL
- en: Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the part of our code that will control all other parts. It will decide
    when to show the view, it will initialize all our game objects from the model,
    and it will prompt decisions based on the states of data to take place within
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model is our game data and logic. What do the ships look like? Where on
    the screen are our ships? How fast are they going, and so on. Furthermore, the
    model part of our code is the intelligence system for each of our game objects.
    Although our enemies in this game don't have sophisticated AI, they will know
    and decide for themselves how fast they are going, when to respawn and more.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The view is exactly what it sounds like. It is the part of our code that will
    do the actual drawing based on the state of the models. It will draw when the
    control part of our code tells it. It will not have any influence over the game
    objects. For example, the view will not decide where an object is or even what
    it looks like. It just draws and then hands control back to the control code.
  prefs: []
  type: TYPE_NORMAL
- en: Design pattern reality check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, the separation is not as clear as the discussion suggests. In fact,
    the code for drawing and control is within the same class. However, you will see
    that the logic of drawing and controlling is separate within that class.
  prefs: []
  type: TYPE_NORMAL
- en: By separating our game into these three parts, we will see how we simplify the
    development and avoid getting tied up in messy code that constantly expands as
    we add new features to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look more closely at where this pattern fits in with our code.
  prefs: []
  type: TYPE_NORMAL
- en: The game code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we must take account of the system we are working within. In this
    case, it is the Android system. If you have been making Android apps for a while,
    you may be wondering where this pattern stuff fits in with the Android Activity
    lifecycle. If you are new to Android, you might ask what the Activity lifecycle
    is.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Activity lifecycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android Activity lifecycle is the framework we must work within to make
    any type of Android app. There is a class called `Activity` that we must derive
    from and is an entry point to our app. In addition, we need to be aware that this
    class, that our game is an object of, also has some methods we can override. These
    methods control the lifecycle of our app.
  prefs: []
  type: TYPE_NORMAL
- en: When an app is started by the user, our `Activity` object is created and a number
    of the methods that we can override are called in sequence. This is what happens.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Activity` object is created, three methods are called in sequence;
    `onCreate()`, `onStart()`, and `onResume()`. At this point, the app is now running.
    In addition, when the user quits an app or the app is interrupted, perhaps by
    a phone call, the `onPause` method is called. The user may decide, perhaps after
    completing their phone call, to return to the app. If this happens, the `onResume`
    method is called, following which the app is running again.
  prefs: []
  type: TYPE_NORMAL
- en: Should the user not return to the app or the Android system decides that it
    wants the system resources for something else, two further methods are called
    to clean up. First `onStop()`, and then `onDestroy()`. The app is now destroyed
    and any attempt to return to the game again will result in the Activity lifecycle
    starting from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do as game programmers is be aware of this lifecycle and observe
    a few rules of good housekeeping. We will implement and explain the rules of good
    housekeeping as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Android Activity lifecycle is much more complex and far more nuanced than
    I have just explained it. However, we know everything we need to get programming
    our first game. If you want to know more please have a look at this article on
    the Android developer''s web site at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have catered for the Android Activity lifecycle, the core methods of
    our class representing the control part of the pattern will be as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the state of our game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the game objects based on their state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pause to lock the frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get player input. Actually because parts 1, 2, and 3 happen in a thread, this
    part can happen at any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last bit of preparation, before we start to build our game for real.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Studio file structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android system is quite particular about where we put our class files, including
    `Activity` and where in the file hierarchy we place our assets like sound files
    and graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a really quick overview of where we will be putting everything. You
    don't need to memorize this, as we will remind ourselves of the correct folder
    while adding assets. We will step through the activity/class creation process
    the first few times we need to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a heads up, here is an annotated diagram of what your Android Studio project
    explorer will look like by the end of the Tappy Defender project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Android Studio file structure](img/B04322_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can actually start building Tappy Defender.
  prefs: []
  type: TYPE_NORMAL
- en: Building the home screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have done all the planning and preparation, we can get started with
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use the code files, you will still need to create an Android Studio project.
    In addition, you will need to change the package name in the very first line of
    code of each of the JAVA files. Change the package name to match the package name
    of the project you created. Finally, you will need to make sure that any assets
    such as images or sound files are placed into the appropriate folder in the project.
    All the required assets for each project are supplied in the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fire up Android Studio and create a new project by following these steps. All
    the files to get the project to where we will be, by the end of this chapter,
    are in the download bundle in the `Chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: On the **Welcome to Android Studio** dialog, click on **Start a new Android
    Studio project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create New Project** window shown next, we need to enter some basic
    information about our app. These bits of information will be used by Android Studio
    to determine the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following image, you can see the **Edit** link where you can customize
    the package name if required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you will be copy/pasting the supplied code into your project, then use `C1
    Tappy Defender` for the **Application name** field and `gamecodeschool.com` in
    the **Company Domain** field as shown in the following screenshot:![Creating the
    project](img/B04322_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button when you're ready. When asked to select the form
    factors, your app will run on, we can accept the default settings (**Phone and
    Tablet**). So click on **Next** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Add an activity to mobile** dialog, just click on **Blank Activity**
    followed by the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Customize the Activity** dialog, again we can accept the default settings
    because `MainActivity` seems like a good name for our main Activity. So click
    on the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio has built the project and created a number of files, most of
    which we will see and edit during the course of building this game. As mentioned
    earlier, even if you are just copying and pasting the code, you need to go through
    this step because Android Studio is doing things behind the scenes to make our
    project work.
  prefs: []
  type: TYPE_NORMAL
- en: Building the home screen UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and simplest part of our Tappy Defender game is the home screen.
    All we need is a neat picture with a scene about the game, a high score, and a
    button to start the game. The finished home screen will look a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the home screen UI](img/B04322_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we built the project, Android Studio opens up two files ready for us to
    edit. You can see them as tabs in the following Android Studio UI designer. The
    files (and tabs) are `MainActivity.java` and `activity_main.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the home screen UI](img/B04322_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `MainActivity.java` file is the entry point to our game, and we will see
    this in more detail soon. The `activity_main.xml` file is the UI layout that our
    home screen will use. Now, we can go ahead and edit the `activity_main.xml` file,
    so it actually looks like our home screen should.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, your game will be played with the Android device in landscape
    mode. If we change our UI preview window to landscape, we will see your progress
    more accurately. Look for the button shown in the next image. It is just preceding
    the UI preview:![Building the home screen UI](img/B04322_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the button shown in the preceding screenshot, and your UI preview will
    switch to landscape like this:![Building the home screen UI](img/B04322_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure `activity_main.xml` is open by clicking on its tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will set in a background image. You can use your own or mine from `Chapter2/drawable/background.jpg`
    in the download bundle. Add your chosen image to the `drawable` folder of the
    project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Properties** window of the UI designer, find and click on the **background**
    property as shown in the next image:![Building the home screen UI](img/B04322_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, in the previous image the button labelled **...** is outlined. It is just
    to the right of the **background** property. Click on that **...** button and
    browse to and select the background image file that you will be using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need a **TextView** widget that we will use to display the high score.
    Note that there is already a **TextView** widget on the layout. It says **Hello
    World**. You will modify this and use it for our high score. Left click on it
    and drag the **TextView** to where you want it. You can copy me if you intend
    using the supplied background or put it where it looks best with your background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Properties** window, find and click on the **id** property. Enter
    `textHighScore`. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it, to show
    the player's fastest time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also edit the **text** property to say `High Score: 99999` or similar
    so that the **TextView** looks the part. However, this isn''t necessary because
    your Java code will take care of this later.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will drag a button from the widget palette as shown in the following
    screenshot:![Building the home screen UI](img/B04322_02_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it to where it looks good on your background. You can copy me if using
    the supplied background or put it where it looks best with your background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the Properties window, find and click on the id property of the button.
    Enter buttonPlay. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it. Also
    edit the text property to say Play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a cool background with neatly arranged widgets (a **TextView** and
    a **Button**) for your home screen. We can add functionality via Java code to
    the **Button** widget next. Revisit the **TextView** for the player's high score
    in [Chapter 4](ch13.html "Chapter 4. Tappy Defender – Going Home"), *Tappy Defender
    – Going Home*. The important point is that both the widgets have been assigned
    a unique ID that we can use to reference and manipulate in your Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have a simple layout for our game home screen. Now, we need to add the
    functionality that will allow the player to click on the **Play** button to start
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the tab for the `MainActivity.java` file. The code that was automatically
    generated for us is not exactly what we need. Therefore, we will start again as
    it is simpler and quicker than tinkering with what is already there.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the entire contents of the `MainActivity.java` file except the package
    name and enter the following code in it. Of course, your package name may be different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mentioned code is the current contents of our main `MainActivity` class
    and the entry point of our game, the `onCreate` method. The line of code that
    begins with `setContentView...` is the line that loads our UI layout from `activity_main.xml`
    to the players screen. We can run the game now and see our home screen, but let's
    make some more progress, following which we will look at how we run the game on
    a real device at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's handle the **Play** button on our home screen. Add the two highlighted
    lines of the following code into the `onCreate` method just after the call to
    `setContentView()`. The first new line creates a new `Button` object and gets
    a reference to `Button` in our UI layout. The second line is the code that listens
    for clicks on the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have a few errors in our code. We can resolve these errors by holding
    down the *Alt* keyboard key and then pressing *Enter*. This will add an import
    directive for the `Button` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have one error. We need to implement an interface so that our code
    listens to the button clicks. Modify the `MainActivity` class declaration as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we implement the `onClickListener` interface, we must also implement the
    `onClick` method. This is where we will handle what happens when a button is clicked.
    We can automatically generate the `onClick` method by right-clicking somewhere
    after the `onCreate` method, but within the `MainActivity` class, and navigating
    to **Generate** | **Implement methods** | **onClick(v:View):void. Or just add
    the given code.**
  prefs: []
  type: TYPE_NORMAL
- en: We also need to have Android Studio add another import directive for `Android.view.View`.
    Use the *Alt* | *Enter* keyboard combination again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now scroll to near the bottom of the `MainActivity` class and see that
    Android Studio has implemented an empty `onClick` method for us. We should have
    no errors in your code at this point. Here is the `onClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we only have one `Button` object and one listener, we can safely assume that
    any clicks on our home screen are the player pressing our **Play** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android uses the `Intent` class to switch between activities. As we need to
    go to a new activity when the **Play** button is clicked, we will create a new
    `Intent` object and pass in the name of our future `Activity` class, `GameActivity`
    to its constructor. We can then use the `Intent` object to switch activities.
    Add the following code to the body of the `onClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have errors in our code because we need to generate a new import
    directive, this time for the `Intent` class so use the *Alt* | *Enter* keyboard
    combination again. We still have one error in our code. This is because our `GameActivity`
    class does not exist yet. We will now solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GameActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that when the player clicks on the **Play** button, main activity
    will close and game activity will begin. Therefore, we need to create a new activity
    called `GameActivity` that will be were your game actually executes.
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, navigate to **File** | **New** | **Activity** | **Blank
    Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Customize the Activity** dialog, change the **Activity Name** field
    to `GameActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can accept all the other default settings from this dialog, so click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did with your `MainActivity` class, we will code this class from scratch.
    Therefore, delete the entire code content from `GameActivity.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio has generated two more files for us and done some work behind
    the scenes that we will investigate soon. The new files are `GameActivity.java`
    and `activity_game.xml`. They are both automatically opened for us in two new
    tabs, in the same place as the other tabs above the UI designer.
  prefs: []
  type: TYPE_NORMAL
- en: We will never need `activity_game.xml` because we will build a dynamically generated
    game view, not a static UI. Feel free to close that now or just ignore it. We
    will come back to the `GameActivity.java` file, when we start to code our game
    for real, later in the chapter in the *Coding the game loop* section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AndroidManifest.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly mentioned that when we create a new project or a new activity, Android
    Studio does more than just creating two files for us. This is why we create new
    projects/activities the way we do.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things going on behind the scenes is the creation and modification
    of the `AndroidManifest.xml` file in the `manifests` directory.
  prefs: []
  type: TYPE_NORMAL
- en: This file is required for our app to work. Also, it needs to be edited to make
    our app work the way we want it to. Android Studio has automatically configured
    the basics for us, but we will now do two more things to this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'By editing the `AndroidManifest.xml` file, we will force both of our activities
    to run with a full screen, and we will also lock them to a landscape layout. Let''s
    make these changes here:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now, and double click on the `AndroidManifest.xml`
    file to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately following it, type or copy and paste these two lines to make `MainActivity`
    run full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately following it, type or copy and paste these two lines to make `GameActivity`
    run full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have now configured both activities from our game to be full screen. This
    presents a much more pleasing appearance to our player. In addition, we have disabled
    the player's ability to affect our game by rotating their Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We said that we will not be using a UI layout for our game screen, but instead
    a dynamically drawn view. This is where the view of our pattern comes in. Let's
    create a new class to represent our view, then we will put in the fundamental
    building blocks of our Tappy Defender game.
  prefs: []
  type: TYPE_NORMAL
- en: Building the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will leave our two activity classes alone for a while so that we can take
    a look at our class that will represent the view of our game. As we discussed
    at the start of this chapter, the view and the controller aspects will be part
    of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: The Android API provides us with an ideal class for our requirements. The `android.view.SurfaceView`
    class not only provides us a view that is designed for drawing pixels, text, lines,
    and sprites onto, but also enables us to quickly handle player input as well.
  prefs: []
  type: TYPE_NORMAL
- en: As if this wasn't useful enough, we can also spawn a thread by implementing
    the runnable interface allowing our main game loop to get player input and other
    system essentials at the same time. We will deal with the general structure of
    your new `SurfaceView` implementation now, so we can fill in the details as we
    progress with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new class for the view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without further delay, we can create a new class which extends `SurfaceView`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the folder containing our `.java` files and select **New** | **Java
    Class** then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create New Class** dialog, name the new class `TDView,` (Tappy Defender
    view). Now, click on **OK** to have Android Studio autogenerate the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new class will open in the code editor. Amend the code to have it extend
    `SurfaceView` and implement `Runnable` as discussed in the previous section. Edit
    the highlighted parts of the code that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the *Alt* | *Enter* combination to import the missing classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we still have an error in our code. This is because we must provide
    a constructor for our `SurfaceView` implementation. Right-click just below the
    `TDView` class declaration and navigate to **Generate** | **Constructor** | **SurfaceView(Context:context)**.
    Or you can just type this in as shown in the next block of code. Now click on
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we did
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a new class called `TDView`, which extends `SurfaceView` for our
    drawing requirements and implements `Runnable` for our threading needs. We have
    also generated a constructor, which we will use soon to initialize our new class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` parameter that is passed into our constructor is a reference to
    the current state of our application within the Android system that is held by
    our `GameActivity` class. This `Context` parameter is useful/essential for a number
    of things that we will be implementing throughout this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our `TDView` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Structuring the class code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have our `TDView` class extended from the `SurfaceView` class, we
    can start coding it. To control the game, we need to be able to update all the
    game data/objects. This implies an `update` method. In addition, we are obviously
    going to want to draw all our game data once every frame after they have been
    updated. Let's keep all of our drawing code together in a method called `draw`.
    Furthermore, we need to control the frequency with which this happens. Therefore,
    a `control` method seems like it should be part of the class as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also know that everything needs to happen in your thread; so to achieve this,
    we should wrap the code in the `run` method. Lastly, we need a way to control
    when the thread should and shouldn't do its work so we need an infinite loop controlled
    by a Boolean, perhaps, `playing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following code into the body of our `TDView` class to implement what
    we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the bare-bones of our game. The `run` method will execute in a thread,
    but it will only execute the game loop while the Boolean `playing` instance is
    true. Then, it will update all the game data, draw the screen based on that game
    data, and control how long it is until the `run` method is called again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can quickly build on this code. First of all, we can implement the
    three methods that we call from the `run` method. Type the following code in the
    body of our `TDView` class after closing the curly brace of the `run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to declare our playing member variable. We can do this using the
    `volatile` keyword as it will be accessed from outside the thread and from within.
    Type this code just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we know that we can control the execution of code within the run method
    with the infinite loop and the `playing` variable. We also need to start and stop
    the actual thread itself. Not just when we decide, but when the player unexpectedly
    quits the game. What if he gets a phone call or just taps the home button on his
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle these events, we need the `TDView` class and `GameActivity` to work
    together. Now, in the `TDView` class, we can implement a `pause` method and a
    `resume` method. Within them, we put the code to stop and start our thread. Implement
    these two methods within the body of the `TDView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need an instance of a `Thread` class called `gameThread`. We can declare
    it as a member variable of `TDView` just after the class declaration, right after
    our Boolean `playing` parameter. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `onPause` and `onResume` methods are public. We can now add code
    to our `GameActivity` class to call these methods at the appropriate time. Remember
    that `GameActivity` extends `Activity`. Therefore, use the overridden `Activity`
    lifecycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: By overriding the `onPause` method, whenever the activity is paused, we can
    shut down the thread. This avoids potentially embarrassing the player and having
    to explain to his caller, why they can hear sound FX in the background.
  prefs: []
  type: TYPE_NORMAL
- en: By overriding `onResume()`, we can have our thread start up in the last phase
    of the Android lifecycle before the app is actually running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the distinction between the `pause` and `resume` methods of the `TDView`
    class and the overridden `onPause` and `onResume` methods of the `GameActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The game activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you implement/override this method, note that all they will do is call
    the parent version of their respective methods followed by the public methods
    in the `TDView` class to which they correspond.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember back to the section when we created our new `GameActivity`
    class, we deleted the entire code contents? With that in mind, here is the outline
    of the code we will need in `GameActivity.java` including the implementation of
    the overridden methods within the body of the `GameActivity` class that we discussed
    in the previous section. Type this code in `GameActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s go ahead and declare an object of the `TDView` class. Do this
    just after the `GameActivity` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the `onCreate` method, we need to instantiate your object, keeping
    in mind that your constructor in `TDView.java` takes a `Context` object as an
    argument. Then, we use the newly instantiated object in a call to `setContentView()`.
    Remember when we built our home screen, we called `setContentView()` and passed
    in our UI design. This time, we are setting the player''s view to be the object
    of our `TDView` class. Copy the following code into the `onCreate` method of the
    `GameActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can actually run our game and click on the **Play** button
    to proceed to the `GameView` activity, which will use `TDView` as its view and
    start our thread. Obviously, there is nothing to see yet, so let's work on the
    model of our design pattern and build the basic outline of our first game object.
    At the end of the chapter, we will see how to run the game on an Android device.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayerShip object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to keep the model part of our code as separate as possible from the
    rest. We can do this by creating a class for our player's spaceship. Let's call
    our new class `PlayerShip`.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add a new class to the project, and call it `PlayerShip`. Here
    are a few quick steps on how to do that. Now, right-click the folder with our
    `.java` files in it and navigate to **New** | **Java Class**, then enter `PlayerShip`
    as the name and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need our `PlayerShip` class to be able to know about itself? As
    a bare minimum it needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Know where it is on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast it is flying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These requirements suggest a few member variables we can declare. Enter the
    code just after the class declaration that we generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As usual, use the *Alt* | *Enter* keyboard combination to import any missing
    classes. In the previous block of code, we see that we have declared an object
    of type `Bitmap` that we will use to hold the graphic which represents our ship.
  prefs: []
  type: TYPE_NORMAL
- en: We have also declared three `int` type variables; `x` and `y` to hold the spaceship's
    screen coordinates and another `int` type variable, `speed` to hold a value for
    how fast our spaceship is traveling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider what our `PlayerShip` class needs to do. Again as a bare
    minimum it needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share it's state with our view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor seems to be the ideal place to prepare itself. We can initialize
    its `x` and `y` coordinate variables and set a starting speed with the `speed`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing the constructor will need to do is to load the bitmap graphic,
    which represents its appearance. To load bitmaps, we require an Android `Context`
    object. This implies that the constructor that we write will need to receive a
    `Context` object from our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, here is our `PlayerShip` constructor to implement point
    one from our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we need to import some new classes using the *Alt* | *Enter* combination.
    After importing all the new classes required by the line which initializes our
    bitmap object, we can see we still have an error; `Cannot resolve symbol ship`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect the line that loads the ship bitmap as we will be seeing this
    quite a lot throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The `BitmapFactory` class is using its static method `decodeResource()` to attempt
    to load our graphic of the player ship. It requires two parameters. The first
    is the `getResources` method supplied by the `Context` object that was passed
    from the view.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter `R.drawable.ship` is requesting a graphic called `ship`
    from the (R)esource folder named `drawable`. All we have to do to resolve this
    error is to copy our graphic, named `ship.png`, into the `drawable` folder of
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply drag and drop/copy and paste the `ship.png` graphic contained in the
    `Chapter2/drawable` folder from the download bundle into the `res/drawable` folder
    in the Android Studio project explorer window. The following is a `ship.png` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PlayerShip object](img/B04322_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Number two on our list of things that `PlayerShip` needs to do is, to update
    itself. Let''s implement a public `update` method that can be called from our
    `TDView` class. The method will simply increment the ship''s *x* value by 1 each
    time it is called. Clearly, we need to get more advanced than this. For now implement
    the method in the `PlayerShip` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Number three on the to-do list is to share its state with the view. We can
    do this by providing a bunch of getter methods like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now your `TDView` class can be instantiated, and find out what it likes about
    any `PlayerShip` objects. However, only the `PlayerShip` class itself can decide
    how it should look, what properties it has, and how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how we will draw our player's ship to the screen and animate it as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will see, drawing a bitmap is really trivial. But the coordinate system
    that we use to draw our graphics onto needs a brief explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting and drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we draw a `Bitmap` object to the screen, we pass in the coordinates we
    want to draw the object at. The available coordinates of a given Android device
    depend on the resolution of its screen.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Samsung Galaxy S4 phone has a screen resolution of 1920 pixels
    (across) by 1080 pixels (down) when held in a landscape view.
  prefs: []
  type: TYPE_NORMAL
- en: The numbering system of these coordinates starts in the top-left hand corner
    at 0,0 and proceeds down and to the right until the bottom right corner is pixel
    1919, 1079\. The apparent 1 pixel disparity between 1920/ 1919 and 1080/ 1079
    is because the numbering starts at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when we draw a bitmap or any other drawable to the screen, we must
    specify *x*, *y* coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, a bitmap is, of course, comprised of many pixels. So which pixel
    of a given bitmap is drawn at the *x*, *y* screen coordinate that we will be specifying?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the top-left pixel of the `Bitmap` object. Take a look at the
    next image, which should clarify the screen coordinates using the Samsung Galaxy
    S4 as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting and drawing](img/B04322_02_10b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For now, when drawing just a single ship at an arbitrary location, this information
    is of little consequence. It will become more important in the next chapter, when
    we start constraining our graphics to the visible screen and respawning them when
    they disappear.
  prefs: []
  type: TYPE_NORMAL
- en: So let's just bare this in mind and get on with drawing our ship to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing PlayerShip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know all this, we can add some code to our `TDView` class, so we
    can see our `PlayerShip` class in action. First, we need a new `PlayerShip` object
    with class scope. The following code is the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also need a bunch of objects that we haven't seen yet to help us actually
    do some drawing. We need a canvas and some paint.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas and Paint objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aptly named `Canvas` class provides just what you will expect—a virtual
    canvas to draw our graphics upon.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a virtual canvas using the `Canvas` class and project it onto our
    `SurfaceView` object which is the view of your `GameActivity` class. We can actually
    add `Bitmap` objects and even manipulate individual pixels on our `Canvas` object
    using methods from our `Paint` object. In addition, we also need an object of
    the `SurfaceHolder` class. This allows us to lock your `Canvas` object while we
    are manipulating it and unlock it when we are ready to draw the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see in more detail how these classes work as we proceed. Type this
    code immediately following the previous line of code we typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we need to use the *Alt | Enter* keyboard combination to import some
    new classes for the two lines of code that follow. From this point on, we will
    save digital link and just assume that you know to do this each time you add a
    new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up to prepare for drawing. The best place to do this is
    in the `TDView()`, constructor. Type the following code to prepare our `Paint`
    and `SurfaceHolder` objects for action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after the previous line of code, we can at last call `new()` to
    initialize our `PlayerShip` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can jump to our `TDView` class''s `update` method and do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The `PlayerShip` class (part of the model) knows what to do, and
    we can add all kinds of artificial intelligence into our `PlayerShip` class. The
    `TDView` class (the controller) just says when it is time to update. You can easily
    imagine that all we need to do is create lots of different game objects with different
    properties and behaviors and call their `update` methods once per frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, jump to the `TDView` class''s `draw` method. Let''s draw our `player`
    object by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check that our `SurfaceHolder` class is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock the `Canvas` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the screen with a call to `drawColor()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Splash some virtual paint on it by calling `drawBitmap()` and passing in the
    `PlayerShip` bitmap and an *x*, *y* coordinate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, unlock the `Canvas` object and draw the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To achieve these things, type this code in the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can actually run the game. If our eyesight is fast enough
    or our Android device slow enough, we will just about see our player spaceship
    fly across the screen with immense speed.
  prefs: []
  type: TYPE_NORMAL
- en: There is just one more thing to do before we deploy our game so far.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the frame rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we can barely see anything is that even though we only move our ship
    at one pixel per frame along the *x* axis (in the `PlayerShip` class's `update`
    method), our thread is calling the `run` method in an unrestricted manner. This
    is probably happening hundreds of times per second. What we need to do is control
    this rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sixty frames per second (FPS) is a reasonable goal. This goal implies the need
    for timing. The Android system measures time in milliseconds (thousandths of a
    second). Therefore, we can add the following code to the `control` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we paused the thread for 17 milliseconds (*1000(milliseconds)/60(FPS)*)
    by calling `gameThread.sleep` with `17` as the argument to the method. We wrap
    the code within a `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can run our game to see our spaceship floating through space (starting
    at 50 pixels on the *x* axis and 50 pixels on the *y* axis).
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio enables us to fairly quickly create emulators, on which we can
    test our games on a development PC. However, even the most simple of games will
    not run well on an emulator. When we start testing things like player input, the
    experience is so awful that it is best to avoid using emulators completely.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to carry out debugging on a real Android device. It is very
    easy to prepare for this.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging on an Android device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do is to visit your device manufacturer's website and obtain
    and install any drivers that are required for your device and operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The next few steps will setup the Android device for debugging. Note that different
    manufacturers structure the menu options slightly differently than others. The
    following sequence is probably very close, if not exact to enable debugging on
    most devices.
  prefs: []
  type: TYPE_NORMAL
- en: Tap the **Settings** menu option or the **Settings** app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap **Developer** options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the checkbox for **USB Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your Android device to the USB port of your development system. The
    next image shows on the Android tab. At the bottom of the Android Studio UI, you
    can see that **Samsung GT-I9100 Android 4.1.2 (API 16)** has been detected:![Debugging
    on an Android device](img/B04322_02_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Play** icon from the Android Studio toolbar:![Debugging on an
    Android device](img/B04322_02_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, click on **OK** to run the game on your chosen device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The game will now run on the device. Any output or errors can be seen in the
    **logcat** window, also on the **Android** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging on an Android device](img/B04322_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Watch with awe as our player's spaceship moves slowly from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent a lot of time setting up the structure, game loop,
    and thread. We also spent time handling the Android Activity lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have all this in place, and we can easily start adding more game objects
    to make Tappy Defender quickly feel more like a real game in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3. Tappy Defender – Taking Flight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to quickly add a lot of new objects and some features as well.
    By the end of this chapter, we will be really close to a playable game. We will
    detect the player touching the screen, so he can control the spaceship. We will
    add virtual boosters to our `SpaceShip` class to move the ship up and down and
    increase the speed.
  prefs: []
  type: TYPE_NORMAL
- en: We will then detect the resolution of the Android device and use it to do things
    like prevent the player boosting off the screen, and to detect when our enemies
    need to respawn.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `EnemyShip` class, which will represent the suicidal enemies.
    We will also see how we can easily spawn and then control them without changing
    any of the logic from the control part of our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a scrolling effect by adding a `SpaceDust` class and spawning dozens
    of them to make it look like the player is whizzing through space.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will learn about, and implement, collision detection so we know
    when our player has been hit by an enemy, as well as look at a graphical trick
    to help us with debugging our collision detection code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our player's spaceship floating aimlessly on the screen starting 50
    pixels from the left and 50 pixels from the top and drifting slowly to the right.
    Now, we can give the player the power to control the spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the design for the controls is a one finger tap and hold to boost,
    release to quit boosting and decelerate.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting touches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SurfaceView` class that we extended for our view is perfect for handling
    screen touches.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is override the `onTouchEvent` method within our `TDView`
    class. Let''s see the code in full, and then we can examine it more closely to
    make sure we understand what is going on. Enter this method in the `TDView` class
    and import the necessary classes in the usual way. I have highlighted the parts
    of the code that we will be customizing later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is how the `onTouchEvent` method works so far. The player touches the screen;
    this can be any kind of contact at all. It could be a swipe, a pinch, multiple
    fingers, and so on. A detailed message is sent to the `onTouchEvent` method.
  prefs: []
  type: TYPE_NORMAL
- en: The details of the event are contained in the `MotionEvent` class parameter,
    as we can see in our code. The `MotionEvent` class holds lots of data. It knows
    how many fingers were placed on the screen, the coordinates of each, and if any
    gestures were made as well.
  prefs: []
  type: TYPE_NORMAL
- en: As we are implementing a simple tap and hold to boost, release to stop boosting
    control scheme; we can simply switch using the `motionEvent.getAction() & MotionEvent.ACTION_MASK`
    condition and cater for just two of many possible different cases.
  prefs: []
  type: TYPE_NORMAL
- en: The case `MotionEvent.ACTION_UP:` will, as the name suggests, tell us when the
    player removes a finger from the screen. Then, perhaps unsurprisingly, case `MotionEvent.ACTION_DOWN:`
    tells us if the player places a finger on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we can find out through the `MotionEvent` class is quite vast. Why not
    take a look at the full scope of its potential here: [http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html).
    We will also explore this class further in the next project that we start to build
    in [Chapter 5](ch14.html "Chapter 5. Platformer – Upgrading the Game Engine"),
    *Platformer – Upgrading the Game Engine*.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding boosters to the spaceship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, all we need to do is think about how we will use these events to control
    the spaceship. First of all, the spaceship needs to know if it is boosting or
    not boosting. This suggests a Boolean member variable. Add this code just after
    the class declaration in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to initialize it when a `PlayerShip` object is created. So add
    this to the `PlayerShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to let the `onTouchEvent` method toggle `boosting` between true
    and false, boosting and not boosting. Add these methods to the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call these public methods from our `onTouchEvent` method to control
    the state of whether the spaceship is boosting or not. Add this new code in the
    `onTouchEvent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, our view is talking to our model; all we need to do is make the boosting
    variable do something depending on which state it is in. The logical place for
    this code will be the `PlayerShip` class's `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change the `speed` variable of our spaceship based on whether the ship
    is currently boosting. At first this seems simple, but there are a few minor issues
    with just increasing the speed based on whether the ship is boosting:'
  prefs: []
  type: TYPE_NORMAL
- en: One problem is that the `update` method is called 60 times every second. So,
    it wouldn't take much boosting to have the ship flying at ridiculous speeds. We
    need to constrain the ship's speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another problem is that our spaceship will rise up the screen when boosting,
    and there is nothing to stop it whizzing straight off the top of the screen, never
    to be seen again. We need to constrain the ship's *x* and *y* coordinates within
    the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ship is not boosting and the speed steadily returns to zero, what will
    bring the ship back down again? We will need a simple gravity physics simulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve these three problems, we can add code to our `PlayerShip` class. However,
    before we do this, a quick word about gameplay balance. The code which we will
    see very soon uses different integer values, for example, we initialize `GRAVITY`
    to `-12` and `MAX_SPEED` to `20`. These numbers have no bearing in reality!
  prefs: []
  type: TYPE_NORMAL
- en: They are simply the arbitrary numbers that make the gameplay balanced. Feel
    free to play with all these arbitrary figures to make the game harder, easier,
    or even impossible. At the end of [Chapter 4](ch13.html "Chapter 4. Tappy Defender
    – Going Home"), *Tappy Defender – Going Home*, we will look more closely at game
    iteration and look again at difficulty and balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With three of our previously stated problems in mind, add the following member
    variables just after the class declaration in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we made a start to solve our three problems, we can add code to our `PlayerShip`
    class''s `update` method. We will delete the one line of code, we put in there
    in the previous chapter. That was just there to take a quick look at our ship
    in action. Enter the new code of our `PlayerShip` class''s `update` method. We
    will take a closer look afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In order from the top of the previous block of code, we are increasing and decreasing
    the speed variable by apparently arbitrary amounts, each frame of the game, based
    on if the ship is boosting or not.
  prefs: []
  type: TYPE_NORMAL
- en: We then constrain the speed of the ship to a maximum of 20 and a minimum of
    1, as specified by the variables we added earlier. With the line `y -= speed +
    GRAVITY`, we move the graphic on screen either up or down based on speed and gravity.
    The apparently arbitrary values for `GRAVITY` and `MAX_SPEED` work nicely to allow
    the player to awkwardly and precariously bounce along through space.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we stop the ship from ever disappearing off the screen by making sure
    the ship graphic is never drawn beyond `maxY` and `minY`. You have probably noticed
    that, as of yet, we haven't initialized `maxY` and `minY`. Furthermore, what will
    we initialize them to anyway as many Android devices have vastly different screen
    resolutions?
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is discover the resolution of the Android device at run time
    and use the information to initialize `MaxY` and `minY`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the screen resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that we need the maximum *y* coordinate of the player's screen. Later
    in the project when we start adding backgrounds and enemy ships, we will realize
    that we also need the maximum *x* coordinate as well. With this in mind, let's
    see how we can get this information and make it available to the `PlayerShip`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most expedient time to detect the screen resolution is as the app is starting,
    and before our view and the model have been instantiated. This implies that our
    `GameActivity` class is a good place to do it. We will now add code to the `onCreate`
    method of the `GameActivity` class. Add this new code to the `onCreate` class,
    before the call to `new...` that creates our `TDView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares and initializes an object of the `Display` type using
    `getWindowManager().getDefaultDisplay();`. Then we create a new object of type
    `Point`. The `Point` object can hold two coordinates and we then pass it as an
    argument into the `getSize` method of our new `Display` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the resolution of the Android device our game is running on, neatly
    stored in `size`. Now pass this on to the parts of our code which require it.
    First, we will change the arguments we pass in the call to `new`, which initializes
    our `TDView` object. Change the call to `new` as shown next to pass in the screen
    resolution to the `TDView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, of course, we need to update the `TDView` constructor itself. In the
    `TDView.java` file, amend the `TDView` constructor''s signature so that the declaration
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, still in the constructor, change the way we initialize the player of our
    `PlayerShip` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we must now amend the constructor declaration within the `PlayerShip`
    class itself, to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we can now initialize our `maxY` and `minY` variables within the
    `PlayerShip` constructor. Before we see the code, we need to consider exactly
    how this will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of the bitmap that holds our spaceship graphic is drawn with
    the top-left corner at the *x = 0* and *y = 0* coordinates passed in to `drawBitmap()`
    in the `TDView` class''s `draw` method. This means that there are pixels off to
    the right and after the coordinates at which we begin to draw the ship. Take a
    look at this next image to visualize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the screen resolution](img/B043422_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, we must set our `minY` and `maxY` values with this in mind. As the
    image illustrates, the top pixel of the bitmap is indeed drawn exactly at the
    ships *y*. We can then be confident that `minY` should be zero.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the ship, however, is drawn at *y + the height of the bitmap*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add two lines of code to our constructor to initialize these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can now run the game and test out your boosters!
  prefs: []
  type: TYPE_NORMAL
- en: Building the enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the tap controls implemented, it is time to add some enemies
    that the player can boost to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: This is going to be much easier than when we added our player's spaceship because
    most of what we need is in place already. All we have to do is code a class to
    represent our enemy, instantiate as many enemy objects as we need, call their
    `update` methods, and then draw them.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, the `update` method for our enemy will be quite different to
    that of `PlayerShip`. It will need to handle things like simple AI to fly toward
    the player. It will also need to handle respawning when it leaves the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin with, create a new Java class and call it `EnemyShip`. Add these member
    variables inside the class so your new class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add some getter and setter methods so that the `draw` method can access
    what it needs to draw, and where it needs to draw it. There is nothing new or
    unusual here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Spawning the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s implement the `EnemyShip` constructor in full. Enter the code now, and
    we will then take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The constructors' signature is exactly that of the `PlayerShip` class. A `Context`
    class for manipulating your `Bitmap` object and `screenX` and `screenY` that hold
    the resolution of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with the `PlayerShip` class, we load up an image into `Bitmap`.
    Of course, we once again need to add an image file named `enemy.png` to the `drawable`
    folder of our project. There is a neat enemy graphic in the `Chapter3/drawable`
    folder of the download bundle or you can design your own. Any size between roughly
    32 x 32 and 256 x 256 will suffice for the purposes of this game. Also, like those
    supplied, your graphics do not need to be square. We will see that our game engine
    is imperfect when it comes to how it looks on different screen sizes, and we will
    address this in the next project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning the enemy](img/B043422_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we initialize `maxX`, `maxY`, `minX`, and `minY`. Although the enemies
    only move horizontally, we need the `maxY` and `minY` coordinates to make sure
    that we spawn them at a sensible height. The `maxX` coordinate will enable us
    to spawn them just off-screen horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new object of type `Random` and generate a random number between
    the values of 10 and 15\. These are the maximum and minimum speeds our enemies
    can travel at. These values are fairly arbitrary, and we might adjust them when
    we do some play-testing in [Chapter 4](ch13.html "Chapter 4. Tappy Defender –
    Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering how `generator.nextInt(6)+10;` comes up with a number between
    10 and 15, it is because the `6` argument causes `nextInt()` to return a number
    between 0 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the enemy ship's *x* coordinate to screen, which spawns it on the
    far right of the screen. Actually, this spawns it off screen. However, that is
    fine because it will then emerge in to the player's view rather than just appearing
    all at once.
  prefs: []
  type: TYPE_NORMAL
- en: We now generate another random number based on `maxY`—the height of the enemy
    ship bitmap `(bitmap.getHeight())`—to create a random but sensible *y* coordinate
    for our enemy ship to spawn at.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do now is to give our enemies life by coding their update method.
  prefs: []
  type: TYPE_NORMAL
- en: Making the enemy think
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can handle the `EnemyShip` class's `update` method. For now, we just
    need to handle two things. First, fly the enemy toward the player's end of the
    screen. We need to take account of the enemy's speed and the player's speed to
    simulate this accurately. The reason we need to do this is because when the player
    boosts, he expects his speed to increase, and objects to rush toward him more
    quickly. However, the spaceship graphic is horizontally static.
  prefs: []
  type: TYPE_NORMAL
- en: We can increase the rate of travel of an enemy in proportion to both the enemy's
    static and randomly generated speed at the same time as the player's dynamically
    set speed (through boosting). This will give the player a sense of speeding up
    even though the ship graphic never moves forward.
  prefs: []
  type: TYPE_NORMAL
- en: The other issue is that the enemy ship will eventually fly off the screen, on
    the left-hand side. We need to detect when this happens and respawn it on the
    right-hand side with a new random *y* coordinate and a new random speed. This
    is just like we did in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally before we get to the actual code, let's consider something. If the enemy
    is going to take note of and use the player's speed, it will need to be able to
    get it. Note that in the next block of code, the `EnemyShip` class's `update`
    method declaration has a parameter to receive the player's speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how this is passed in when we add code to the `TDView` class''s
    `update` method soon. Enter the following code for the `EnemyShip` class''s `update`
    method to implement what we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first decreased the enemy's *x* coordinate by the player's
    speed then by the enemy's speed. As the player boosts, the enemy will fly at the
    player faster. However, if the player is not boosting then the enemy will attack
    at the speed that was previously and randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After this, we simply detected if the right-hand edge of the enemy bitmap has
    disappeared from the left-hand side of the screen. This is done by detecting if
    the `EnemyShip` class's *x* coordinate is the width of the bitmap off screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Then we respawn the very same object to come at the player again. This appears
    to the player as if it is an entirely new enemy.
  prefs: []
  type: TYPE_NORMAL
- en: The last three things we must do are create a new object from `EnemyShip` by
    declaring and then initializing an object. Actually, let's make three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, were we declared our player''s ship in our `TDView.java` file, declare
    three enemy ships like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the constructor of our `TDView` class, initialize our three new enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` method of our `TDView` class, we call each of the new object's
    `update` methods in turn. Here, we also see how we pass in the player's speed
    to each of our enemies so they can use it in their `update` methods to adjust
    speed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the `TDView` class's `draw` method, we draw our new enemies to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game and give this a try now.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most obvious problem is that the player and the enemies fly right
    through each other. We will solve this problem later in this chapter, in the *Things
    that go bump – collision detection* section. But right now, we can make our player's
    sense of immersion better by drawing a star/space dust field as a background.
  prefs: []
  type: TYPE_NORMAL
- en: The thrill of flight – scrolling the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing our space dust is going to be really quick and easy. All we will
    do is create a `SpaceDust` class with very similar properties to our other game
    objects. Spawn them into the game at a random location, move them toward the player
    at a random speed, and respawn them on the far right of the screen, again with
    a random speed and *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Then in our `TDView` class, we can declare a whole array of these objects, update,
    and draw them each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `SpaceDust`. Now enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here is what is happening in the `SpaceDust` class. At the top of the previous
    block of code, we declare our usual speed and maximum and minimum variables. They
    will allow us to detect when the `SpaceDust` object leaves the left of the screen
    and needs respawning on the right, and provide sensible bounds for the height
    at which we respawn the object.
  prefs: []
  type: TYPE_NORMAL
- en: Then inside the `SpaceDust` constructor, we initialize the `speed`, `x`, and
    `y` variables with random values, but within the bounds set by the maximum and
    minimum variables we just initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Then we implement the `SpaceDust` class's `update` method, which moves the object
    to the left based on the speed of the object and the player, then checks if the
    object has flown of the left-hand edge of the screen and respawns it with random
    but appropriate values if it has.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, we provide two getter methods so that our `draw` method knows
    where to draw each speck of dust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create an `ArrayList` object to hold all our `SpaceDust` objects.
    Declare it just under the declaration of the other game objects near the top of
    the `TDView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TDView` constructor, we can initialize a whole bunch of the `SpaceDust`
    objects using a `for` loop and then stash them into the `ArrayList` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We create forty specks of dust in total. Each time through the loop, we create
    a new speck of dust and the `SpaceDust` constructor assigns it a random location
    and a random speed. We then put the `SpaceDust` object into our `ArrayList` object
    with `dustList.add(spec);`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we jump to our `TDView` class''s `update` method and use an enhanced
    `for` loop to call `update()` on each of our `SpaceDust` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we passed in the player speed so that the dust increases and decreases
    its speed relative to the player's speed.
  prefs: []
  type: TYPE_NORMAL
- en: Now to draw all our space dust, we loop through our `ArrayList` object and draw
    a speck at a time. Of course, we add the code to our `TDView` class's `draw` method,
    but we must make sure to draw the space dust first so it appears behind the other
    game objects. In addition, we have an extra line to switch pixel color to white
    before using the `drawPoint` method of our `Canvas` object to plot a single pixel
    for each `SpaceDust` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `draw` method of the `TDView` class, add this code to draw our dust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The only new thing here is the `canvas.drawpoint...` line of code. Apart from
    drawing bitmaps to the screen, the `Canvas` class allows us to draw primitives,
    like points and lines, as well as things like text and shapes. We will use these
    features when drawing a HUD for our game in [Chapter 4](ch13.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not run the app and check out how much neat stuff we have implemented?
    In this screenshot, I have temporarily increased the number of the `SpaceDust`
    objects to `200`, just for fun. You can also see that we have enemies drawn, attacking
    at a random *y* coordinate with random speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The thrill of flight – scrolling the background](img/B043422_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Things that go bump – collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collision detection is quite a broad subject. Throughout the three projects
    in this book, we will use a whole range of different ways to detect when things
    collide.
  prefs: []
  type: TYPE_NORMAL
- en: So, here is a quick look at our options for collision detection, and in which
    circumstances different methods may be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we just need to know when certain objects from our game touch other
    objects. We can then respond to that event by exploding, reducing shields, playing
    a sound, or whatever is appropriate. We need a broad understanding of our different
    options so we can make the right decisions in any particular game.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, here are a few of the different mathematical calculations we can
    utilize and when they may be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This type of collision detection is really straightforward. We draw an imaginary
    rectangle; we can call it a hitbox or bounding rectangle, around the objects we
    want to test for collision. Then, test to see if they intersect. If they do, we
    have a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rectangle intersection](img/B043422_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where the hitboxes intersect, we have a collision. As we can see from the previous
    image, this is far from perfect. However, in some situations, it is sufficient.
    To implement this method, all we need to do is test for the intersection using
    the *x* and *y* coordinates of both objects.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the following code. It is for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes we have a `getHitbox` method that returns the left
    and right *x* coordinates as well as the top and bottom *y* coordinates of the
    given object. In the aforementioned code, we first check to see if the *x* axes
    overlap. If they don't, then there is no point going any further. If they do,
    then check the *y* axes. If they don't, it could have been an enemy whizzing by
    above or below. If they overlap on the *y* axis as well, then we have a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can check the *x* and *y* axis in either order as long as we check
    them both.
  prefs: []
  type: TYPE_NORMAL
- en: Radius overlapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is also checking to see if two hitboxes intersect with each other,
    but as the title suggests, it does so using circles instead. There are obvious
    advantages and disadvantages. Mainly that this works well with shapes more circular
    in nature and less well with elongated shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Radius overlapping](img/B043422_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous image, it is easy to see how the radius overlapping method
    is inaccurate for these particular objects and not hard to imagine how for a circular
    object like a ball it would be perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we can implement this method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code is for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The code again makes some assumptions. Like we have a `getHitBox` method that
    can return the radius as well as the center *x* and *y* coordinates. Furthermore,
    because the static `Math.sqrt` method takes and returns a variable of type `double`,
    we will need to start working with different types in our `SpaceShip` and `EnemyShip`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the way we initialize distance: `Math.sqrt(distanceX * distanceX + distanceY
    * distanceY);` looks a little confusing, it is simply using Pythagoras'' theorem
    to get the length of the hypotenuse of a triangle which is equal in length to
    a straight line drawn between the centers of the two circles. In the last line
    of our solution, we test if `distance < ship.getHitBox.radius + enemy.getHitBox.radius`,
    then we can be certain that we must have a collision. That is because if the center
    points of two circles are closer than the combined length of their radii, they
    must be overlapping.'
  prefs: []
  type: TYPE_NORMAL
- en: The crossing number algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is mathematically more complicated. However, as we will see in
    our third and final project, it is perfect for detecting when a point intersects
    a convex polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The crossing number algorithm](img/B043422_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is perfect for an Asteroids clone, and we will explore this method more
    as well as see it in action in our final project.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, the different collision detection methods can have at least
    two problems depending on which method you use in which situation. The problems
    are lack of accuracy and drain on CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple hitboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first problem, a lack of accuracy, can be solved by having multiple hitboxes
    per object.
  prefs: []
  type: TYPE_NORMAL
- en: We simply add the required number of hitboxes to our game object to most effectively
    *wrap* it, and then perform the same rectangle intersection code on each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Neighbor checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method allows us to only check objects that are in the approximate same
    area as each other. It can be achieved by checking which neighborhood of our game
    a given two objects are in, and then only performing the more CPU intensive collision
    detection if there is a realistic chance that a collision could occur.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have 10 objects that each need to be checked against each other,
    then we need to perform 10 squared (100) collision checks. If we do neighbor checking
    first, we can significantly reduce this number. In the very hypothetical situation
    in the diagram, we would only need to do an absolute maximum of 11 collision checks,
    instead of 100, for our 10 objects, if we first check to see if objects share
    the same sector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Neighbor checking](img/B043422_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing this in code can be as simple as having a sector member variable
    for each game object, then looping through the list of objects and just checking
    if they are in the same sector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use all these options and optimizations over the course of our three
    game projects.
  prefs: []
  type: TYPE_NORMAL
- en: Best options for Tappy Defender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know our collision detection options, we can decide the best course
    of action in our current game. All our ships are approximately rectangular (or
    square), there are few or no extremities on any of them, and we only have one
    object were we really care about a collision (with all the others).
  prefs: []
  type: TYPE_NORMAL
- en: This tends to suggest that we can use a single rectangular hitbox for the player
    and the enemy and perform purely corner aligned, global collision detection. If
    you're disappointed that we are going for the easy option, then you will be pleased
    to hear we will be getting into all the fancier techniques over the next two projects.
  prefs: []
  type: TYPE_NORMAL
- en: To make life even easier, the Android API has a handy the `Rect` class that
    can not only represent our hitboxes, but also has a neat `intersects` method that
    basically does the same thing as rectangle intersection collision detection. Let's
    think about how to add collision detection to our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, all of our enemies and our player ship are going to need a hitbox. Add
    this code to declare a new `Rect` member called `hitbox`. Do this in both the
    `PlayerShip` and `EnemyShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Important!**'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to do the previous step and the next three blocks of code for both the
    `EnemyShip` class as well as the `PlayerShip` class. I will remind you each time
    but just thought it worth mentioning beforehand as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a getter method to the `PlayerShip` class and the `EnemyShip`
    class. Add this code to both classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And next, we need to make sure we initialize our hitboxes in both constructors.
    Make sure to enter the code right at the end of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make sure the hitboxes are kept up-to-date with the coordinates
    of our enemies and our player. The best place to do this is the `update` method
    of the enemy/player ships. The next block of code will update the hitboxes with
    the ship''s current coordinates. Be sure to add this block of code at the very
    end of the `update`() methods so that the hitbox is updated with the coordinates
    after the `update` methods have done their adjustments. Again, add it to both
    `PlayerShip` and `EnemyShip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Our hitboxes have the coordinates that represent the outline of our bitmaps.
    This situation is nearly perfect, apart from the transparent bits around the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use our hitboxes from the `TDView` class's `update` method to detect
    collisions. But first, we need to decide what we are going to do when a collision
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: We need to refer to the rules of our game. We discussed them back at the beginning
    of [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We know that the player has three shields but an enemy blows up
    after one hit. It makes sense to leave things like shields to a later part of
    the chapter, but we need some way to see our collision detection in action and
    make sure it is working.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the simplest way to acknowledge a collision at this stage, will be
    to make the enemy ship disappear and respawn as normal, as if it is a totally
    new enemy. We already have a mechanism in place for this. We know that when an
    enemy moves off the left of the screen it respawns as if it is a new enemy on
    the right. All we need to do is instantly transport the enemy to a location off
    of the left of the screen and the `EnemyShip` class will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to change the `EnemyShip` object''s *x* coordinate. Let''s
    add a setter method to the `EnemyShip` class so we can manipulate the *x* coordinate
    of all our enemy spaceships. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can carry out collision detection and respond when we get a hit. The
    next block of code uses the static method `Rect.intersects()` to detect a hit
    by comparing the player ship''s hitbox with each of the enemy hitboxes in turn.
    If a hit is detected, the appropriate enemy is moved off screen, ready to be respawned
    by its own `update` method in the next frame. Enter this code at the very top
    of the `TDView` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, our collisions will now work. It may be nice to be able to really
    see what is going on. For the purposes of debugging, let''s draw a rectangle around
    all our spaceships, so we can see the hitboxes. We will use the `drawRect` method
    of the `Paint` class and pass the properties of our hitboxes in as arguments to
    define the area to draw. As you will expect, this code goes in the `draw` method.
    Note that it should go before the code that draws our ships so that the rectangles
    are drawn behind them, but after we clear the screen, as shown by the highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run Tappy Defender and see the game in action complete with debugging
    mode hitboxes enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Best options for Tappy Defender](img/B043422_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can comment out this debugging code when we are done with it and then uncomment
    it should we need it again later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have all the game objects that we need for a complete game. They all
    think and represent themselves internally in the model part of our design pattern.
    Furthermore, our player can at last control his spaceship, and we can detect when
    he crashes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put the finishing touches to our game including
    adding a HUD (Heads Up Display), implementing the game rules, adding some extra
    features, and play-testing our game to get everything in balance.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4. Tappy Defender – Going Home
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are on the home straight of our first game. In this chapter, we will draw
    a HUD to show the player in-game information, and implement the rules of the game
    so that the player can win, lose, and get fastest times.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will make a pause screen so the player can admire their achievements
    (or not) after they win or lose.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also generate our own sound FX and then add them to
    the game. Following that, we will enable the player to save their fastest time,
    and finally we will add a whole bunch of minor improvements, including a bit of
    difficulty balancing based on the screen resolution of the player's Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to start making our game a bit more rounded. Games have a score or,
    in our case, a time, and other rules as well. For the player to keep check on
    their progress we need to display the stats of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will quickly set up a HUD that will show the player everything they
    need to know on screen while he is dodging enemies. We will also declare and initialize
    the variables required to supply data to the HUD. In the next section, *Implementing
    the rules*, we can begin to manipulate variables such as, shields, time, fastest
    time, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by adding some member variables to the `TDView` class. We use
    a float value for the `distanceRemaining` variable because we will be using pseudo-kilometers
    and fractions of kilometers to represent the distance remaining until our hero
    makes it to her home planet. For the `timeTaken`, `timeStarted`, and `fastestTime`
    variables, we will use the **long** type because time is represented in milliseconds
    and the values get really big. Add this code after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For now, we will just leave these variables with their default values and concentrate
    on displaying them in our HUD. We will make them useful and meaningful in the
    next section, *Implementing the rules*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can go ahead and draw our HUD to display all the data the player may
    want to know while playing. As so often, we will be using our versatile `Paint`
    class object `paint` to do the bulk of the work. This time, we use the `drawText`
    method to add text to the screen, the `setTextAlign` method to justify our text,
    and `setTextSize` to scale the size of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add this code to our `TDView` class''s `draw` method. Add it as
    the last thing to draw, just before the call to `unlockCanvasAndPost()`, as shown
    by the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After entering this code, we have some errors and probably some questions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will deal with the questions. We will look more closely at what we
    are doing to `fastestTime`, `timeTaken`, `distanceRemaining`, and the value returned
    by `getSpeed` in the next section, *Implementing the rules*. Simply put, they
    are representations of distance and time that serve to give the player a sense
    of how they are doing. They are not real simulations of distance, although the
    time is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first error we will deal with is caused by a call to a nonexistent method
    `player.getShieldStrength`. Add a member variable `shieldStrength` to the `PlayerShip`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it to `2` in the `PlayerShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement your missing getter method in the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The final errors are caused by the undeclared variables `screenX` and `screenY`.
    It is now apparent that we need the screen resolution in this part of our code.
    The fastest way to deal with this is to make some new class variables called `screenX`
    and `screenY`. Declare these now just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, knowing the screen coordinates is useful in a number of places,
    so it makes sense to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `TDView` constructor, initialize `screenX` and `screenY` with the
    resolution passed in by the `GameActivity` class. Do this at the start of the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the game and see our HUD. The only parts of our HUD with meaningful
    data are the **Shield** and **Speed** labels. The speed is a pseudo-measurement
    of MPS (meters per second). Of course it has no bearing on reality, but it is
    relative to the speed of the whizzing stars, approaching enemies and soon, to
    the decreasing distance from the player''s goal, home:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a HUD](img/B04322_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we should pause and think about what we need to do later in the project
    because it will affect what we do while implementing our rules. When the player's
    ship is destroyed or when player reaches their goal, the game will end. This implies
    that the game will need to be restarted. We don't want to quit back to the home
    screen each time, so we need a way to restart the game from within the `TDView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, we are going to implement a `startGame` method in our `TDView`
    class. The constructor will be able to call it and our game loop will also be
    able to call it when necessary as well.
  prefs: []
  type: TYPE_NORMAL
- en: It will also be necessary to pass some of the tasks that the constructor currently
    performs onto the new `startGame` method so that it can properly do its job. Also,
    we will use `startGame` to initialize some of the variables that our game rules
    and HUD require.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish what we discussed, `startGame()` will need a copy of
    the application''s `Context` object. So, like we did with `startX` and `startY`,
    we will now make `context` a member of `TDView`. Declare it after the `TDView`
    class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the constructor right after the call to `super()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can now implement the new `startGame` method. Most of the code is just moved
    from the constructor. Note that the subtle but important differences, like using
    the class version of the screen coordinates `screenX` and `screenY` instead of
    the constructor parameters *x* and *y*. Also, we initialize `distanceRemaining`,
    `timeTaken`, and `timeStarted`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are you are wondering what is going on with the `timeStarted` initialization?
    We initialized `startTime` using a method of the `System` class, `currentTimeMillis`.
    Now, `startTime` holds the number of milliseconds since January 1, 1970\. We will
    see how this is used in the upcoming section, *Ending the game*. The `System`
    class has many uses. Here, we use it to get the number of milliseconds since January
    1, 1970\. This is a common system for measuring time in a computer. It is called
    Unix time and the moment before the 1st millisecond of January 1, 1970 is known
    as the Unix Epoch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, comment out or delete the now unnecessary code from the `TDView` constructor
    but add the call to `startGame()` in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to create a method to decrement the `PlayerShip` shield strength.
    This is so that when we detect a collision, we can reduce it by one each time.
    Add this simple method to the `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can jump to the `TDView` class's `update` method and add code to implement
    our game rules a bit further. We will add a Boolean variable `hitDetected` just
    before we do all our collision detection. Inside each of the `if` blocks which
    detects a hit, we can set `hitDetected` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after all the collision detection code, we can see if a hit has been
    detected and reduce the player''s shield strength accordingly. Here is the top
    part of the `TDView` class''s `update` method with the new lines of code highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note the nested if statement after the call to `player.reduceShieldStrength`.
    This detects when the player has lost all their shields and failed. We will deal
    with what happens here soon.
  prefs: []
  type: TYPE_NORMAL
- en: We are really close to finishing off our game rules. We just need to decrease
    the `distanceRemaining` relative to the player's speed. This is so that we know
    when the player has succeeded. We also need to update the `timeTaken` variable
    so that the HUD is updated each time our draw method is called. This may not seem
    important, but thinking ahead a little, we can foresee a time when the game has
    ended, either because the player has failed or because the player has won. Let's
    talk about the end of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the game is not ended, the game is playing, and if the player has just died
    or won, the game is ended. We need to know when the game is ended and when it
    is playing. Let''s make a new member variable `gameEnded` and declare it after
    the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can initialize `gameEnded` in the `startGame` method. Enter this code
    as the very last line in the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finish the last few lines of our game rules logic, but wrap them
    in a test to see if the game has ended or not. Add the following code to conditionally
    update our game rules logic, right at the end of the `TDView` class''s `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Our HUD will now have accurate data to keep the player informed of exactly
    how they are doing. We can also detect when the player arrives home and wins because
    `distanceRemaining` will pass zero. In addition, when distance remaining is less
    than zero, we can test to see if `timeTaken` is less than `fastestTime` and update
    `fastestTime` if it is. We can also set `gameEnded` to `true`. Add this code directly
    after the last block of code in the `TDView` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We ended the game when the player won; now, add this next line of code to end
    the game when the player loses all their shields. Update this code in the `TDView`
    class''s `update` method. The new line of code is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now, we just need to make something actually happen when `gameEnded` is set
    to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to alternate how we draw the HUD based on whether the
    `gameEnded` Boolean is true or false. Identify the HUD drawing code in the `draw`
    method, shown again here for easy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to wrap that code in an `if`-`else` block. If the game is not ended,
    draw the normal HUD else draw an alternative. Wrap the HUD drawing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s deal with the `else` block, which we will execute when the game
    is ended. What we will do is draw a big **Game Over**, and show the end game stats
    from the HUD. The thread continues on but the HUD stops updating. Enter this code
    in the `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we switch text sizes using `setTextSize()`, and we align all the
    text in the center of the screen using `setTextAlign()`. This is what it looks
    like when you run the game. We just need a way to restart the game after it has
    ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ending the game](img/B04322_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Restarting the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow the player to restart after the game has ended, we just need to listen
    for a touch and call `startGame()`. Lets edit our `onTouchListener()` code to
    achieve this. The case `MotionEvent.ACTION_DOWN:` is the case we are interested
    in amending. We can simply add conditions here that if the screen is touched while
    the game is ended, restart. The new code to add to case `MotionEvent.ACTION_DOWN:`
    is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Try it out. You can now restart the game from the pause menu by tapping the
    screen. Is it just me or is it a bit quiet round here?
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding sound effects in Android is really straightforward. First, let's look
    at where we can get our sound FX from. If you just want to get on with the coding,
    you can use my sound FX in the `Chapter4/assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the FX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We require four sound FX for our Tappy Defender game:'
  prefs: []
  type: TYPE_NORMAL
- en: The sound for when our player crashes into an alien, which we will call `bump.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sound for when the player is destroyed, which we will call `destroyed.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fun sound for when the game first begins, which we will call `start.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a victory whoop-type sound, which we will call `win.ogg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is a very quick guide to make these sound FX using BFXR. Grab a free copy
    of BFXR from [www.bfxr.net](http://www.bfxr.net).
  prefs: []
  type: TYPE_NORMAL
- en: Follow the simple instructions on the website to set it up. Try out a few of
    these things to make our cool sound FX.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a very condensed tutorial. You can do so much with BFXR. To learn more
    read the tips on the website at the previous URL.
  prefs: []
  type: TYPE_NORMAL
- en: Run `bfxr.exe`.![Generating the FX](img/B04322_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out all the preset types, which generate a random sound of the type you
    are working on. When you have a sound that is close to what you want, move to
    the next step:![Generating the FX](img/B04322_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Generating the FX](img/B04322_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see we can save in formats other than `.wav` too.![Generating
    the FX](img/B04322_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file use the `.ogg` extension at the end of the filename. Remember we need to
    create `bump.ogg`, `destroyed.ogg`, `start.ogg`, and `win.ogg`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5 and create the four sound FX that we discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `app` folder in Android Studio. From the pop-up menu, navigate
    to **New** | **Android resource directory**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Directory name** field, type `assets`. Click on **OK** to create the
    `assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your operating system's file manager to add a folder called `assets` to
    the main folder of the project, then add the four sound files to the new assets
    folder in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SoundPool class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To play our sounds, we will use the `SoundPool` class. We are using the deprecated
    version of the `SoundPool` constructor because the new version needs API 21 or
    newer and it is likely that lots of readers will be using an earlier version of
    Android. We can dynamically get the Android version and provide a different version
    of the code for pre- and post-API level 21, but the older constructor meets our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the sound FX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declare a `SoundPool` object and some integers to represent the individual
    sounds. Add this code just after the `TDView` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can initialize our `SoundPool` object and our integer sound IDs. We
    wrap the code in a `try`-`catch` block as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the call to `load()` starts a process of converting our `.ogg` files
    to raw sound data. If the process is not finished when a call to `playSound()`
    is made, the sound won''t play. The calls to `load()` are in the likely order
    of them being used to minimize this possibility. Enter this code in the constructor
    of our `TDView` class as shown. The new code is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Add a call to `playSound()` using the appropriate reference at the points in
    our code which represent the appropriate event in our game. We have four sounds,
    so four calls to `playSound()` will be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first goes at the very end of the `startGame()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two are highlighted in the `if(hitDetected)` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is in the `if(distanceRemaining < 0)` block, as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: It's time to run Tappy Defender now and hear the sound in action.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to save our player's high score by saving it to a file when
    they achieve it and loading it back up again when Tappy Defender starts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the current fastest time is zero and can therefore
    never be beaten. The other problem is that every time the player quits the game
    the high score is lost. Now, we will load a default high score from a file. When
    a new high score is achieved, save it to the file. It doesn't matter if the player
    quits the game or even switches off their phone; their high score will remain.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need two new objects. Declare them as members of the `TDView` class
    after the `TDView` class declaration. The first is a `SharedPreferences` object
    and the second is an `Editor` object, which actually writes to the file for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `prefs` first as we just want to attempt to load a high score if one
    exists. We will also initialize `editor` ready for when we save our high score.
    We do this in the `TDView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use our `Editor` object to write any new fastest times to the `HiScores`
    file when appropriate. Add the extra highlighted lines shown to add the proposed
    changes to our file, first into a buffer and then commit the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is get the home screen to load up the fastest time
    and display it to the player. We will load the fastest time in exactly the same
    way as we did in our `TDView` constructor. We will also get a reference to our
    `TextView` through its ID `textHighScore`, which we assigned way back at the beginning
    of [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We then use the `setText` method to display it to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `MainActivity.java` and add the highlighted code to the `onCreate`
    method to achieve what we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a complete working game. However, it is not really finished yet.
    To make a game that is genuinely playable and fun, we have to improve, refine,
    test, and iterate.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make our game better and more playable? Let's look at a number of
    possibilities and then go ahead and implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple different enemy graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the enemies a bit more interesting by adding a few more graphics
    to the game. First, we need to add the extra graphics to the project. Copy and
    paste `enemy2.png` and `enemy3.png` from the `Chapter4/drawables` folder of the
    download bundle into the `drawables` folder in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple different enemy graphics](img/B04322_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: enemy2 and enemy3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to amend the `EnemyShip` constructor. This code generates
    a random number between 0 and 2, and then switches to load a different enemy bitmap
    accordingly. Our completed constructor now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Note that we just need to move the `Random generator = new Random();` line of
    code to the top of the constructor, so we can use it to choose a bitmap as well
    as generate a random height later in the constructor, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: An exercise in balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the biggest playability issue in the game is the difference in difficulty
    when playing on a medium/high resolution screen as opposed to a low resolution
    screen. For example, one of my testing devices is a Samsung Galaxy S2\. It is
    a few years old now, and the screen resolution is 800 x 480 pixels when held in
    the landscape position. For comparison, I tested the game on a Samsung Galaxy
    S4 that has 1920 x 1080 pixels in landscape mode. This is more than double the
    resolution of the S2.
  prefs: []
  type: TYPE_NORMAL
- en: On the S4, the player seems to effortlessly glide in between the almost insignificant
    enemies, while on the S2, the player is faced with an almost impenetrable wall
    of alien steel.
  prefs: []
  type: TYPE_NORMAL
- en: The real solution to this problem is to draw game objects at pseudo-real-world
    coordinates, and then map these coordinates back to the device at the same scale,
    regardless of resolution. This way, the game will look and play the same on both
    an S2 and an S4\. In the next project, we will build a more advanced game engine
    that does this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will still have the consideration of the actual physical screen
    size, making the player's experience varied, but this is a much more accepted
    situation by gamers.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick and dirty solution, we will vary the size of the ships and the number
    of enemies. So on lower resolutions, we will have three enemies, but we will shrink
    their size. On higher resolutions, we will increase the number of enemies gradually.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `EnemyShip` class, just after the `switch` block that loads our enemy
    graphics into our `Bitmap` object, add the line shown highlighted to call a new
    method that we will write soon, `scaleBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write our new `scaleBitmap` method. This simple helper method
    takes a single argument, which as we have seen is the horizontal resolution of
    the screen. We then use the resolution and the static `createScaledBitmap` method
    to reduce our `Bitmap` objects on a scale of 2 or 3 depending on the resolution
    of the screen. Add the new `scaleBitmap` method to the `EnemyShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The enemies will be scaled down in size on lower resolution screens. Now, let's
    increase the number of enemies for the higher resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we will add code to the `TDView` class to add extra enemies to higher
    resolution screens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning! This code sucks, but it works and it shows us where we can make improvements
    in our next project. When planning a game, there is always a trade-off between
    good design and simplicity. By keeping things organized from the start, we can
    get away with a bit of hacking near the end. Yes, we can redesign the way we spawn
    and store our game objects, and if Tappy Defender was an ongoing project then
    this would be worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more enemy ship objects after the first three, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add code to conditionally initialize these two new objects in the `startGame`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code in the `update` method to update our fourth and fifth enemies and
    check for collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `draw` method, draw our extra enemies when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we now realize that we may like to scale the player as well. This
    makes it plain that perhaps we need a `Ship` class, from which we can derive `PlayerShip`
    and `EnemyShip`.
  prefs: []
  type: TYPE_NORMAL
- en: Add to this the cumbersome manner in which we added the extra enemies for higher
    resolution screens and a much more polymorphic solution is probably worthwhile.
    We will see how we can seriously improve this and virtually every other aspect
    of our game engine in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Format time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at how time is formatted in the player''s HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Format time](img/B04322_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yuck! Let's write a simple helper method to make this look a whole lot nicer.
    We will add a new method to the `TDView` class called `formatTime()`. The method
    uses the number of elapsed milliseconds in this game (`timeTaken`) and reorganizes
    them into seconds and fractions of a second. It pads the fractions with zeros
    where appropriate and returns the result as a `String` ready to be drawn in the
    `TDView` class's `draw` method. The reason the method takes an argument rather
    than just using the member variable `timeTaken` is so we can reuse this code in
    a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We amend the line that draws the time in the player''s HUD. For context, in
    the next piece of code, I have commented out the entirety of the original line
    and provided the new line, which includes our call to `formatTime()`, and highlighted
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, with one minor change, we can use this formatting on the **Fastest:**
    label in the HUD as well. Again, the old line is commented out and the new one
    is highlighted. Find and amend the code in the `TDView` class''s `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also update the time formatting on the pause screen. The lines to
    change are commented out and the new lines to add are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '**Fastest:** is now formatted in the same way as **Time:** on both the in-game
    HUD and the pause screen HUD. Take a look at our neatly formatted time now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Format time](img/B04322_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handle the back button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will quickly add a small block of code to handle what happens when the player
    presses the back button on their Android device. Add this new method to both the
    `GameActivity` and `MainActivity` classes. We simply check if the back button
    was pressed, and if it was, call `finish()` to let the operating system know we
    are done with this activity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The finished game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, in case you are following along for the theory and not the practical,
    here is the finished `GameActivity` on a high resolution screen with a few hundred
    extra stars and shields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The finished game](img/B04322_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented the component parts of a basic game engine. We can do so
    much more. Of course, a modern mobile game will have a lot more going on than
    in ours. How will we handle collisions when there are lots more game objects?
    Couldn't we tighten up our class hierarchy a bit, as there were lots of similarities
    between our `PlayerShip` and `EnemyShip` classes? How can we add complex internal
    character animations without confusing the structure of our code, and what if
    we want smart enemies, enemies who can actually think?
  prefs: []
  type: TYPE_NORMAL
- en: We need realistic backgrounds, side objectives, power-ups, and pick-ups. We
    want a game world with real-world coordinates that map back accurately regardless
    of the resolution of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We need a smarter game loop that runs the game at the same speed regardless
    of the CPU it is being processed on. Most of all, what we really need, more than
    any of these things, is a dirty big machine gun. Let's build a classic platform
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5. Platformer – Upgrading the Game Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the second project of this book. Here, we will build a really tough
    retro platform game. It is not tough to build, but tough to beat when you play
    it. At the end of the project, we will also discuss ways to make the game play
    a little less punishing should you wish.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus entirely on our game engine and essentially lead to
    an upgraded version of the Tappy Defender code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will discuss what we want to achieve with this game: the backstory,
    game mechanics, and rules.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will quickly create an activity that instantiates a view that will
    do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will flesh out the basic structure of our `PlatformView` class,
    which will have some subtle, but important differences to our `TDView` class.
    Most notably, `PlatformView` will have a simple but effective way of managing
    the timing of all the events of our game.
  prefs: []
  type: TYPE_NORMAL
- en: We will then start the iterative process of building our `GameObject` class,
    from which almost every entity of the game world will be derived.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the concept of a viewport through which the game world
    is viewed by the player. We will no longer be designing our game objects to operate
    at the level of the screen resolution, but they will now exist in a world with
    their own *x* and *y* coordinates that we can think of as virtual meters. There
    is also a simple system of depth on the *z* axis as well. This will be handled
    by our new `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we will look at how we design and layout the content of our game.
    This is done via a class that is used as a level designer and can be used in a
    nonprogrammatic way to map out the jumps, enemies, rewards, and goals that constitute
    the layout of a level.
  prefs: []
  type: TYPE_NORMAL
- en: To manage the level designs and load them into our game engine, we will need
    another class. We will call it `LevelManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally in this chapter, we will look at our enhanced `update` and `draw` methods
    within the `PlatformView` class so that we can actually run our new game and see
    the first output on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: With so much to do, we better get started.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game we will build is based on the game play of some of the brutally hard
    platform games of the '80s, such as Bounty Bob Strikes Back and Impossible Mission.
    These games featured difficult jumps and required insanely precise timing at the
    same time as giving the player an unforgiving number of lives/chances. This style
    of game works well for us because we can actually build a multilevel playable
    game in just four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the classes will make it really easy for you to add your own extra
    features, and game objects or make it slightly less challenging to play should
    you want to.
  prefs: []
  type: TYPE_NORMAL
- en: The backstory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our hero Bob, having just returned from a secret mission to destroy an evil
    scientist at the center of the Earth, finds he is deep underground. Worse, it
    seems that although he has defeated the evil scientist, it was not in time to
    save the planet from the powerful guards and deadly flying robot drones that he
    unleashed.
  prefs: []
  type: TYPE_NORMAL
- en: Bob must make his way from the deep underground fiery cave, through the heavily
    guarded city, and forest, high in the mountains, where he hopes to live, free
    from the terrifying new order that has taken over the planet.
  prefs: []
  type: TYPE_NORMAL
- en: On his journey through these four levels, he must avoid guards, destroy drones,
    collect lots of money, and upgrade his initially puny machine gun.
  prefs: []
  type: TYPE_NORMAL
- en: The game mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game will be about executing precise jumps, planning the best route through
    a level to collect the loot and escape. Bob will be able to stand precariously
    on ledges with whole pixels of his feet overhanging, to be able to make seemingly
    impossible jumps. Bob will be able to control the distance he travels while jumping,
    meaning that sometimes he will often need to make sure he doesn't over jump.
  prefs: []
  type: TYPE_NORMAL
- en: Bob will need to collect machine gun upgrades before attempting to escape via
    heavily guarded areas.
  prefs: []
  type: TYPE_NORMAL
- en: Bob will only have three lives, but may be able to find some more on his journey.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Bob loses a life by being caught by a drone/guard, touching fire, or falling
    out of the game world, he will respawn at the start of the current level. Drones
    can fly, and will home in on Bob as soon as he comes into view. Bob will need
    to make sure he has enough firepower to handle the drones. Guards will patrol
    predetermined parts of the level, but they are tough and can only be knocked back
    by Bob's machine gun. Usually, Bob will need to execute a precisely timed jump
    to progress past a guard.
  prefs: []
  type: TYPE_NORMAL
- en: The environment will also be tough. Bob will need to completely master each
    level, as one wrong jump will send him plummeting back to the start, straight
    into the clutches of an enemy or even to his fiery death.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the talk of guards, drones, fire, collectibles, guns, and the implied much
    larger game world suggests a much more complex system to manage. One of the goals
    of our game engine will be to make this complexity easily manageable. The other
    goal will be to separate the level design from the coding. When our game is done,
    you will be able to sit back and design the most evil, yet rewarding levels, in
    multiple different environments without touching the code.
  prefs: []
  type: TYPE_NORMAL
- en: The platform activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First we start off with our `Activity` class, which is the entry point into
    our game. There is not much new here, so let's go ahead and get it built quickly.
    Create a new project, and in the **Application Name** field, enter `C5 Platform
    Game`. Choose **Phones and tablets**, then **Blank Activity** when prompted. In
    the **Activity Name** field, type `PlatformActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously you don't have to follow my exact naming choices, but just remember
    to make minor alterations in the code to reflect your own naming choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can delete `activity_platform.xml` from the `layout` folder. You can also
    delete all the code within the `PlatformActivity.java` file. Just leave the package
    declaration. Now, we have an entirely blank canvas ready for us to start coding.
    Here is the entirety of our project so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Let's start building our engine. Just like in our Tappy Defender project, we
    will build a class to handle the view aspect of our game. Perhaps unsurprisingly,
    we will call the class `PlatformView`. Therefore, our `PlatformActivity` class
    needs to instantiate a `PlatformView` object and set it as the main view of the
    app, just like in the previous project.
  prefs: []
  type: TYPE_NORMAL
- en: We will be making some significant upgrades to our engine, but this will mainly
    happen in the view. In the code for the `PlatformActivity` class that we will
    look at next, we do much the same as in the previous project. First, declare the
    `PlatformView` object and set it as the main view in the overridden `onCreate`
    method; however, before we do this, we also capture and pass in the resolution
    of the device's screen.
  prefs: []
  type: TYPE_NORMAL
- en: We do this using the `Display` class and chaining the `getWindowManager()` and
    `getDefaultDisplay()` methods to get the properties of the physical display hardware
    that our game will be running on. Then, we create an object of type `Point` called
    resolution and store the resolution of the display into our `Point` object by
    calling `display.getSize(size)`.
  prefs: []
  type: TYPE_NORMAL
- en: This stores the horizontal and vertical number of pixels of the screen into
    `size.x` and `size.y`, respectively. We can then go ahead and instantiate a new
    `PlatformView` object by calling its constructor and passing in the values stored
    in `size.x` and `size.y`. As before, we also pass in the application, `Context`
    object (`this`) that like in the previous project, we will find many uses for.
  prefs: []
  type: TYPE_NORMAL
- en: We can then set `platformView` as the view by calling `setContentView()` in
    the usual way. As earlier, we override the `Activity` class's lifecycle methods
    `onPause()` and `onResume()` to have them call their respective methods in our
    soon-to-be-written `PlatformView` class. These two methods can then start and
    stop our `Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the entirety of the code for the `PlatformActivity` class that we have
    just discussed, with no significant new aspects. Type or copy and paste the code
    into your project. The code for this chapter can be found within the download
    bundle from the book's page on the Packt Publishing website. All the code and
    assets from this chapter can be found in the `Chapter5` folder. This file is called
    `PlatformActivity.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to import all the new classes when prompted to do so, or by pressing
    the *Alt* | *Enter* keyboard combination while hovering the cursor over the error
    when a missing class causes this error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, until we create our `PlatformView` class, there will be errors in
    our `PlatformActivity` class's code.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the layout to landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we did for the last project, we will make sure the game runs in the
    landscape mode only. We will make our `AndroidManifest.xml` file force our `PlatformActivity`
    class to run with a full screen, and we will also lock it to a landscape layout.
    Let''s make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Immediately after it, type or copy and paste these two lines to make `PlatformActivity`
    run full screen and lock it in the landscape orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can move on to the real guts of our game and see how we can implement
    all these improvements we talked about.
  prefs: []
  type: TYPE_NORMAL
- en: The PlatformView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class, by the time it is completed, will be dependent on many other classes.
    I don't want to just present each class in turn, as this would be quite hard to
    follow and exactly what code implements which feature will become confusing. Instead,
    we will look at, and code, each feature in turn, as we require them, and then
    revisit many of the classes multiple times to add more features. This will keep
    the focus on the specific purpose of each part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Having said this, great care has been taken so that although we will revisit
    many of these classes multiple times, we won't be constantly deleting code, just
    adding to it. When we add to it, the code will be presented in its proper context
    with the new parts highlighted among the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to the structure of the classes, they are designed to be as minimal
    as possible, while at the same time, not restricting your potential to easily
    add features and extend the code.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a lesson in game engine design, but more a lesson in seeing how
    many different features we can learn to implement and cram into four chapters,
    without the code becoming unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to build very large-scale games, especially when working as a team,
    then a more robust design will be necessary. This more robust design will also
    mean a whole lot of extra classes, interfaces, packages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this type of discussion interests you, I highly recommend the book, *Beginning
    Android Games* by Mario Zechner, published by APRESS. Mario is the founder/creator
    of the LibGDX cross-platform game library, and his book goes into great detail
    about the design patterns required to build a highly extensible and reusable code
    base for games. The only downside to the great design detail that this book has,
    is that it would take around 600 pages to build a simple retro Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create the class. Right-click on the package name in the Android
    Studio project explorer and navigate to **New** | **Java Class**. Call the new
    class `PlatformView`. Delete the autogenerated contents of the class, as we will
    add our own code soon.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to add code to this class over the entirety of the project.
    The full extent of the code that we add to the class in this chapter can be found
    in the download bundle at `Chapter5/PlatformView.java`.
  prefs: []
  type: TYPE_NORMAL
- en: We need a class that can manage our level. Let's call it `LevelManager`.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a class that can hold the data for our level, as we can then extend
    it each time we create a new/different level design. Let's call the parent class
    `LevelData`, and our first real level for Bob to escape from, `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as this game is going to have many enemies, props, and terrain
    types, we are going to need a cleaner system of managing them all. We need a fairly
    generic `GameObject` class, which all the different game objects can extend. We
    can then manage them really easily in our `update` and `draw` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We will also, as a matter of necessity, build a slightly more complicated method
    of detecting the players input. We will create an `InputController` class to delegate
    all of the code from `PlatformView`. However, the details of this class we will
    not see, until we have fully fleshed out our `Player` object to represent the
    player in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can quickly code our basic `PlatformView` class with very similar code to
    the first project, but with a few notable exceptions that we will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: The basic structure of PlatformView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are the necessary imports and our member variables to get us started. We
    will add to these a fair bit as the project continues.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also declare three new object types, `lm` that will be our `LevelManager`
    class, `vp` that will be our `Viewport` class, and `ic` that is our `InputController`
    class. We will begin working on some of these in this chapter. These declarations
    will of course show an error until we implement their respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have our `PlatformView` constructor. At this stage, it does nothing
    new, in fact, it has less code than our `TDView` constructor but it will soon
    be enhanced. For now, enter the code as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our thread''s `run` method. Note that before the call to `update()`,
    we get the current time in milliseconds and put it in the `startFrameTime` long
    variable. Then after `draw()` has completed, we make another call to get the system
    time and measure how many milliseconds have elapsed since the frame started. We
    then carry out the calculation `fps = 1000 / thisFrameTime`, which gives us the
    number of frames per second our game ran at, in that last frame. This value is
    stored in the `fps` variable. We will be using this all over the place as we proceed
    with the game. Code the `run` method that we have just discussed, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in the chapter, we will see how we manage the extra complexity of multiple
    object types and update them when necessary. For now, just add an empty `update`
    method to the `PlatformView` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the familiar parts of our `draw` method. Later in this chapter,
    we will see some of the new code. For now, add the basics of the `draw` method
    as shown next as this will remain unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The last parts of the first phase of putting together our view is the `pause`
    and `resume` methods, which are called by `PlatformActivity` when the corresponding
    Activity lifecycle methods are called by the operating system. They are unchanged
    from the previous project, but here they are again for the sake of completeness
    and being able to follow along easily. Add these methods to the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the basic outline of our view coded and ready. Let's take our first
    look at the `GameObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that we need a parent class to hold the vast majority of our game objects
    as we want to improve on the inflexibility and code duplication of the last project.
    From the previous project, we also know many of the properties and methods it
    will require.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a simple class to represent the world location of all our future
    `GameObject` classes. This class will hold a detailed location on both the *x*
    and *y* axis. Note that these are totally independent to the coordinates of the
    pixels of the device on which our game will run. We can think of the *z* coordinate
    as a layer number. The lower numbers get drawn first. Therefore, create a new
    Java class, call it `Vector2Point5D`, and enter this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's have a look at, and code the basic working outline of, the `GameObject`
    class, and then throughout the project, we can come back and add extra features.
    Create a new Java class and call it `GameObject`. Let's look at the code we need
    to start to make this class useful. First, we import the classes we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: When we code `GameObject` itself, note that the class does not provide a constructor
    as this will be handled differently, depending on the specific `GameObject` that
    we are implementing.
  prefs: []
  type: TYPE_NORMAL
- en: The first variable you will notice in the code is `worldLocation`, which, as
    you may expect, is of type `Vector2Point5D`. We then have two float members, which
    will hold the width and height of the `GameObject` class. Next up, we have the
    Boolean variables `active` and `visible` which will be used, perhaps to label
    an object when it is active, visible, or otherwise. We will begin to see later
    in the chapter how this is of benefit.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need to know how many frames of internal animation any given object
    has. The default will be `1`, so `animFrameCount` is initialized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have a `char` class called `type`. This `type` variable will determine
    exactly what any particular `GameObject` might be. It will be used extensively.
    The last member variable for now is `bitmapName`. We will see that it will become
    useful to know the name of the graphic, which represents the appearance of each
    of our individual objects. Add the member variables we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can look at the first part of the functionality of `GameObject`. We
    have the abstract method `update()`. The plan was that all objects will need to
    update themselves. Turns out that this was over ambitious in just four chapters,
    and some of our objects (mainly the platforms and scenery) will just provide an
    empty `update()` implementation. However, there is nothing to stop you making
    the scenery more interactive than we have time for now, or make the platforms
    more dynamic and adventurous once we see how things work. Add the abstract `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We handle our methods that manage our graphics. We have a getter to retrieve
    `bitmapName`. Then, we have `prepareBitmap()`, which uses the string `bitmapName`
    to make an Android resource ID from a `.png` image file. This file must be present
    in the `drawable` folder of the project. A bitmap is created as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Now our `prepareBitmap` method does something new. It uses the `createScaledBitmap`
    method to change the size of the bitmap we just created. It not only uses the
    `animFrameCount`, which we already discussed, but also the `pixelsPerMetre` variable,
    which is a parameter of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea being, that each device has a `pixelsPerMetre` value that is appropriate
    for the device, which will help us create an identical view of the game across
    devices with different resolutions. We will see exactly where we get this `pixelsPerMetre`
    value from, when we discuss the `Viewport` class. Enter the following methods
    in the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We also want to be able to know where in the world each `GameObject` is and,
    of course, to set where in the world it is. Here are a getter and a setter, which
    do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We also want to be able to both, get and set many of the member variables we
    have already discussed. These getters and setters will do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we will want to check and change the status of our active and visible
    variables as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Set and get `type` of each `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create our first of many child classes from `GameObject`. Right-click
    on the package name in the Android Studio explorer and create a class called `Grass`.
    This will be our first basic tile type that the player can walk about on.
  prefs: []
  type: TYPE_NORMAL
- en: This straightforward code uses the constructor to initialize height, width,
    type, and its location in the game world. Note that all this information is passed
    in as parameters to the constructor. The only thing the `Grass` class "knows",
    and one of the few things that will differentiate it from some of the other simple
    `GameObject` child classes, is the value used for `bitmapName`, which in this
    case is `turf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously, we also provide an empty implementation of the `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Now, add the `turf.png` graphic from the `Chapter5/drawable` folder in the download
    bundle to the `drawable` folder in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will do an absolute barebones implementation of our `Player` class
    that will also extend `GameObject`. We will not be putting any functionality into
    this class just an *x* and *y* world location. This is so that the `Viewport`
    class, which we will implement next, knows where to focus.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the `Player` class, which will represent Bob our hero. The class at
    this stage is as simple and straightforward as, and nearly identical to the `Grass`
    class. This will change and evolve substantially as we progress. Note that we
    set the type to `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Add the `player.png` graphic from the `drawable` folder in the download bundle
    to the `drawable` folder in Android Studio. The graphic is a multiframe sprite
    sheet, so it won't display nicely until we animate it in [Chapter 6](ch15.html
    "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob, Beeps, and
    Bumps* , but it will serve its purpose as a placeholder for now.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see next, the view of the game world that the player sees, will focus
    on Bob, as you will probably expect.
  prefs: []
  type: TYPE_NORMAL
- en: The view through a viewport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A viewport can be thought of as the movie camera that follows the action of
    our game. It defines the area of the game world that is to be shown to the player.
    Typically, it will center on Bob.
  prefs: []
  type: TYPE_NORMAL
- en: It also serves the combined function of making our draw method more efficient
    by determining which objects are inside and outside the player's field of vision.
    There is no point drawing or processing a bunch of enemies, if they are not relevant
    at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: This will significantly speed up tasks like collision detection by implementing
    a first phase of detection by removing objects off screen from the list of objects
    to check for collisions, and it is surprisingly simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our `Viewport` class will have the task of translating game world
    coordinates into appropriate pixel coordinates for drawing on the screen. We will
    also see how this class calculates the `pixelsPerMetre` value that our `GameObject`
    class used in the `prepareBitmap` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Viewport` class really is an all singing and dancing thing. So let's get
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will declare a whole bunch of useful variables. We have another `Vector2Point5D`,
    which will just be used to represent whatever point in the world is currently
    the central focus in the viewport. Then, we have separate integer values for `pixelsPerMetreX`
    and `pixelsPerMetreY`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, in this implementation, there is no distinction between `pixelsPerMetrX`
    and `pixelsPerMetreY`. However, the `Viewport` class can be upgraded to take into
    account different ratios of width to height of the device, based on screen size,
    rather than just resolution. We don't do so in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we simply have the resolution of the screen in both axes: `screenXResolution`
    and `screenYResolution`. We then have `screenCentreX` and `screenCentreY`, which
    are basically the two previous variables divided by two to find the middle.'
  prefs: []
  type: TYPE_NORMAL
- en: In our list of declared variables, we have `metresToShowX` and `metresToShowY`
    that will be the number of meters we will squash into our viewport. Changing these
    values will show more or less of the game world on screen.
  prefs: []
  type: TYPE_NORMAL
- en: The last member, we will declare at this point, is the `int numClipped`. This
    we will use to output debugging text to see what effect our `Viewport` class is
    having with regard to making drawing, updates, and multiphase collision detection,
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Viewport` and declare the variables we have just
    discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the constructor. The constructor just needs to know the resolution
    of the screen. This is obtained in parameters *x* and *y*, which, of course, we
    assign to `screenXResolution` and `screenYResolution`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Then, as previously suggested, we divide those two previous variables by two
    and assign the results to `screenCentreX` and `screenCentreY`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `pixelsPerMetreX` and `pixelsPerMetreY` are calculated by dividing by 32
    and 18 (again, respectively), so a device with a resolution of 840 x 400 pixels
    will have pixels per meter *x/y* of 32/22\. Now, we have variables that refer
    to the number of pixels of screen real estate on the current device that represents
    a meter of our game world. We will see a number of times in our code, where this
    will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: We will actually draw a slightly wider area than this, to make sure we don't
    have any unsightly gaps/lines around the edge of the screen and assign 34 to `metresToShowX`
    and 20 to `metresToShowY`. Now, we have variables that refer to the amount of
    our game world that we will draw each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have some screen output, you can experiment with these values to create
    a more or less zoomed-in or zoomed-out experience for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Nearing the end of the constructor, we create a new `Rect` object called `convertedRect`
    that we will see in action soon. We call `new()` on `currentViewportWorldCentre`,
    so it is ready for action shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If some of the screenshots throughout this project look slightly different to
    the results you get, it is because some images have been taken using different
    viewport settings to highlight different aspects of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: The first method we write for the `Viewport` class is `setWorldCentre()`. It
    receives an *x* and a *y* parameter, which is promptly assigned as the `currentWorldCentre`.
    We need this method because of course the player will be moving around in the
    world, and we need to let the `Viewport` class know where Bob is. Also, as we
    will see in [Chapter 8](ch17.html "Chapter 8. Platformer – Putting It All Together"),
    *Putting It All together*, we will also have a situation where we don't want Bob
    as the center of attention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Now, a few simple getters and setters that will be useful to us as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: We fulfil one of the primary roles of the `Viewport` class with the `worldToScreen()`
    method. As the name suggests, this is the method that converts the locations of
    all the objects currently in the visible viewport from world coordinates to pixel
    coordinates that can actually be drawn to the screen. It returns our previously
    prepared `rectToDraw` object as the result.
  prefs: []
  type: TYPE_NORMAL
- en: This is how `worldToScreen()` works. It receives the *x* and *y* world locations
    of an object along with that object's width and height. With these values, each
    in turn, subtracts the objects world coordinate multiplied by the pixels per meter
    for the current screen, from the appropriate current world viewport center (*x*
    or *y*). Then, for the left and top coordinates of the object, the result is subtracted
    from the pixel screen center value and for the bottom and right coordinates, it
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values are then packed into the left, top, right, and bottom values of
    `convertedRect` and returned to the `draw` method of `PlatformView`. Add the `worldToScreen`
    method to the `Viewport` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Now, we implement the second primary function of the `Viewport` class, removing
    objects that are currently of no interest to us. We call this clipping, and the
    method we will call; `clipObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we receive as parameters the `x`, `y`, `width`, and `height` of
    an object. The test starts by assuming that we want to clip the current object
    and we assign `true` to clipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the four nested `if` statements test whether each and every point of
    the object is within the bounds of the related side of the viewport. If it is,
    we set `clipped` to `false`. Some of the levels we will design have in excess
    of a thousand objects, but we will see that we rarely need to process (update,
    collision detection, and draw) more than a quarter of them in any given frame.
    Enter the code for the `clipObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Now, we provide access to the `numClipped` variable so that it can be read and
    reset to zero each frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare and initialize our `Viewport` object. Add this code right after
    we initialize our `Paint` object in the `PlatformView` constructor. The new code
    is shown highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We can now describe and position objects in our game world and focus on the
    precise parts of the world we are interested in. Let's see how we will actually
    get our objects into that world, so we can then update and draw them as we have
    done before. We will also look at the concept of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will see how to build our `LevelManager`, `LevelData`, and our first
    real level, `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LevelManager` class will eventually need a copy of our `InputController`
    class. Therefore, in order to try and keep to our intentions of not having to
    delete any code, we will include a parameter for `InputController` in our `LevelManager`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly create a blank template for our `InputController` class. Create
    a new class in the usual way and call it `InputController`. Add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at our, initially, very simple `LevelData` class. Create a new
    class, call it `LevelData`, and add this code. At this stage, it holds just an
    `ArrayList` object for `Strings`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can start on what will eventually become our first playable level.
    Create a new class, call it `LevelCave`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The position of `p` for player in the `LevelCave` file is arbitrary. As long
    as it is on there, the `Player` object will be initialized. The actual spawn location
    of the player character is determined by the call to a `loadLevel` method, as
    we will soon see. I usually put the `p` for player as the first element on the
    first line of the map, then it is less likely to be forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's talk about how this level design is going to work. We will enter
    alpha-numeric characters in the `LevelCave` class within the `tiles.add("..."`
    parts of the code. We will enter a different alpha-numeric character depending
    on which `GameObject` we want to place into the level. At the moment, we just
    have `p` to represent the `Player` object, a `1` to represent a `Grass` object,
    and a period (`.`) to represent an empty space of one game world meter square.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This implies that the positioning of the `Grass` objects with the `1` character
    in the previous block of code can be arranged exactly how you like. This is the
    case, and whenever we look at the code for our `LevelCave` class please feel free
    to improvise and experiment as you like.
  prefs: []
  type: TYPE_NORMAL
- en: As the project continues, we will add more than twenty different `GameObject`
    child classes. Some will be inanimate like `Grass`, others will be thinking, aggressive
    enemies. All will be placeable within our level design.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can implement the class to manage our levels. Create a new Java class
    and call it `LevelManager`. Enter the code for the `LevelManager` class as we
    go through, and discuss it a block at a time.
  prefs: []
  type: TYPE_NORMAL
- en: First, a few import directives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Now, the constructor is where we have a `String` `level` to hold the name of
    the level, `mapWidth` and `mapHeight` to store the width and height in game world
    meters of the current level, a `Player` object because we know we will always
    have one of them, and an `int` type called `playerIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will have an `ArrayList` object of many `GameObject` classes, and it
    will be handy to always have the index of the `Player` object.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we have the Boolean `playing` because we will need to know when the
    game is being played or being paused and a float called `gravity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of this project, gravity will not be used to its full potential,
    but it can easily be manipulated so that different levels have a different gravity.
    This is why it is in the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we declare an object of type `LevelData`, an `ArrayList` object to
    hold all our `GameObject` objects, an `ArrayList` object to hold representations
    of the players control buttons and a regular array to hold the majority of all
    the `Bitmap` objects we will need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the constructor, we examine the signature and see that it receives
    a `Context` object, `pixelsPerMetre` that will have been determined when the `Viewport`
    class was constructed, `screenWidth` again direct from the `Viewport` class, a
    copy of our `InputController` class, and then the name of the level to load. The
    `int` parameters, `px` and `py`, are the starting coordinates for the player.
  prefs: []
  type: TYPE_NORMAL
- en: We assign the level parameter to our member level, then we switch to determine
    which class will be our current level. Of course, at the moment, we only have
    `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we initialize our `gameObject ArrayList` and our `bitmapsArray`. We then
    call `loadMapData()`, which is a method we will write shortly. After this, we
    set `playing` to `true`, and finally we have a getter method to find out what
    the state of `playing` is. Enter the code we have just discussed in the `LevelManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a really simple method which will enable us to get any `Bitmap`
    object based on the type of `GameObject` we are currently dealing with. This way,
    each `GameObject` does not have to hold its own `Bitmap` object. For example,
    we can design a level with hundreds of `Grass` objects. This can easily use up
    the memory of even a modern tablet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getBitmap` method takes an `int` value as an index and returns a `Bitmap`
    object. We will see how we access the appropriate value for `index` in the next
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This next method will enable us to get the `index` with which to call the `getBitmap`
    method. As long as the `char` cases correspond with the `type` values held by
    the various `GameObject` child classes we create, and the index returned by this
    method matches the index of the appropriate `Bitmap` held in the `bitmapsArray`,
    we will only ever need one copy of each `Bitmap` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Now, we do the real work with the `LevelManager` class, and load our level from
    our design. The method needs the `pixelsPerMetre` and the `Player` objects coordinates
    in order to do its work. As this is a large method, the explanations and the code
    have been split into a few sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this first part, we simply declare an `int` type called `index` and set it
    to `-1`. As we loop through our level design, it will help us keep track of where
    we are up to.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we calculate the height and width of the map using the size of `ArrayList`
    and the length of the first element of `ArrayList`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We enter a nested `for` loop starting with the first element of the first string
    in our `ArrayList` object. We work from left to right across the first string
    before moving on to the second string.
  prefs: []
  type: TYPE_NORMAL
- en: We check to see if an object other than an empty space (.) is present at the
    current location, and if it is, we enter a switch block to create the appropriate
    object at the designated location.
  prefs: []
  type: TYPE_NORMAL
- en: If we encounter a `1`, then we add a new `Grass` object to `ArrayList`, and
    if we encounter a `p`, we initialize the `Player` object at the location passed
    in to the constructor of this `LevelManager` class. When a new `Player` object
    is created, we also initialize our `playerIndex` and `player` object ready for
    future use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'If a new object has been added to `gameObjects ArrayList`, we need to check
    if the corresponding bitmap has been added to the `bitmapsArray`. If it hasn''t,
    we add one using the `prepareBitmap` method of the current `GameObject` class
    under consideration. Here is the code to perform this check and prepare the bitmap,
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `PlatformView` class, to put all our level objects to use, we call
    `loadLevel()` just after where we initialized our `Viewport` class in the `PlatformView`
    constructor. The new code has been highlighted, and the existing code is provided
    for context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Of course, now we need to implement the `loadLevel` method within the `PlatformView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadLevel` method needs to know which level to load, so the `switch` statement
    in the `LevelManager` constructor can do its work, and it also needs the coordinates
    to spawn our hero Bob.
  prefs: []
  type: TYPE_NORMAL
- en: We initialize our `LevelManager` object by calling its constructor with the
    viewport data retrieved from `vp` and the level/player data we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `InputController` class, again passing in some data from
    `vp`. We will see exactly what we do with this data when we build our `InputController`
    class in [Chapter 6](ch15.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"),
    *Bob, Beeps, and Bumps*. Finally, we call `vp.setWorldCentre()` and pass it in
    the player's location as the coordinates. This centers the screen on Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: We can add some code to our `update` method that will be first to utilize a
    primary function of our new `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: The enhanced update method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At last, we can use our handy `ArrayList` of game objects and our `Viewport`
    functionality to flesh out our enhanced `update` method. In the code that follows,
    we simply use an enhanced `for` loop to go through each `GameObject`. We check
    if it `isActive()`, and then send the object''s location and dimensions to `clipObjects()`
    wrapped in an `if` statement. If `clipObjects()` returns `false`, then the object
    is not clipped and the object is flagged as visible by calling `go.setVisible(true)`.
    Otherwise, it is flagged as not visible calling `go.setVisible(false)`. This is
    the only aspect of any object that is updated at the moment. We will see when
    we run the game, at the end of the chapter, that it is already useful. Enter the
    new code in the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The enhanced draw method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we can be more precise about which objects we need to draw. First, we declare
    and initialize a new `Rect` object called `toScreen2d`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we loop through our `gameObjects ArrayList` once for each layer starting
    with the lowest layer. This isn't strictly necessary at this stage because all
    our objects are, by default, currently on layer zero. We will add objects on layer
    -1 and 1 before the end of the project, and we don't want to have to rewrite code
    if we can help it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check if the object is visible and on the current layer. If it is,
    we pass the current object''s location and dimensions to the `worldToScreen` method,
    which returns the result to our previously prepared `toScreen2d Rect` object.
    Then, we call `drawBitmap()` using our `bitmapArray` to provide the appropriate
    bitmap, and pass in the coordinates of `toScreen2d`. Update the `draw` method
    as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Now, still in the `draw` method, we print debugging info to the screen, including
    the size of our `gameObjects ArrayList` compared to the number of objects that
    were clipped this frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we finish the `draw` method by the usual call to `unlockCanvasAndPost()`.
    Note that at the end of the `if(debugging)` block, we call `vp.resetNumClipped`
    to set the `numClipped` variable back to zero ready for the next frame. Add this
    code straight after the previous block of code in the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first time in this project, we can actually run our game and see some
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The enhanced draw method](img/B04322_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note in the image the precise layout of the grass from our `LevelCave` design.
    You can also see our squashed Bob sprite sheet and the fact that there are 28
    objects, but 10 of them have been clipped. As our levels get bigger, the ratio
    of clipped to unclipped will dramatically increase in favor of the vast majority
    being clipped.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of ground in this chapter, and now have a well fleshed-out
    game engine.
  prefs: []
  type: TYPE_NORMAL
- en: As we have done much of the setup work, from now on, most of the code we add
    will also have a visible (or audible) result and be much more satisfying, as we
    will be able to regularly run our game to see the improvements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add sound effects and input detection, thus bringing
    Bob to life. Then, we will see how dangerous his world can be, and will promptly
    add collision detection so that he can stand on a platform.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6. Platformer – Bob, Beeps, and Bumps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our basic game engine is set up, we can start making some fast progress.
    In this chapter, we will quickly add a `SoundManager` class that we will use to
    make a noise wherever and whenever we please. After that, we will put some meat
    on the bones of Bob and implement the core functionality we require in the `Player`
    class. Then, we can handle the second phase (after clipping) of our multiphase
    collision detection and give Bob the useful skill of being able to stand on a
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: After we have achieved this significant feat, we will hand over control of Bob
    to the player by implementing the `InputController` class. Bob will at last be
    able to run around and jump. At the end of this chapter, we will animate Bob's
    sprite sheet so he actually appears to run, rather than slide everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The SoundManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the next few chapters, we will be adding sound effects for various
    events. Sometimes these sounds will be triggered directly in the main `PlatformView`
    class, but other times, they will need to be triggered in more remote corners
    of your code like the `InputController` class and even within the `GameObject`
    class themselves. We will quickly make a simple `SoundManager` class that can
    be passed around and used as needed when a beep is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class and call it `SoundManager`. This class has three main
    parts. In the first part, we simply declare a `SoundPool` object and a bunch of
    `int` variables to hold a reference to each sound effect. Enter the first part
    of the code, the declaration, and members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the class is the `loadSound` method, which unsurprisingly
    loads all the sounds into memory ready for playing. We will call this once we
    have initialized a `SoundManager` object in the `PlatformView` constructor. Enter
    this code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally for our `SoundManager` class, we need to be able to play any sound
    we like. This `playSound` method simply switches on a string passed in as a parameter.
    When we have a `SoundManager` object, we can just call `playSound()` with an appropriate
    string argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Declare a new object of type `SoundManager` after the `PlatformView` class declaration
    after your new game engine classes from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize the `SoundManager` object and call `loadSound()` in the `PlatformView`
    constructor as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: You can create all your own sounds using BFXR or just copy mine from the `Chapter6/assets`
    folder. Copy all the sounds to the `assets` folder in your Android Studio project.
    Create an `assets` folder in the `src/main` folder of your project in order to
    achieve this if the folder doesn't exist already.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can play sound effects wherever we like. It's time to bring our hero
    Bob to life.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we can add the meat to the bones of your `Player` class. However, this
    section won't be the last time we revisit the `Player` class. Now, we will add
    the necessary functionality to allow Bob to move. Immediately after we have done
    this, we will add the code to allow the player to use the forthcoming collision
    detection code and the `Animation` class.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to add some members to the `Player` class. The `Player`
    class will need to know how fast it can move, when the player is pressing the
    left or right controls, and if it is falling or jumping. In addition, the `Player`
    class needs to know how long it has been jumping and how long it should jump for.
  prefs: []
  type: TYPE_NORMAL
- en: The next block of code provides variables for us to monitor all these things.
    We will very soon see, how we use them to make Bob do what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know what the variables are for. We can add this code right after the
    class declaration as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, there are some other movement-related conditions we will need
    to track, but they will be useful in other classes as well. Therefore, we will
    add them as members to the `GameObject` class. We will track the current horizontal
    and vertical speed, the direction the object is facing, and whether the object
    can move at all with the following variables. Add these to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `GameObject` class, we will add a `move` method. This method simply
    checks that the velocity on either of the axes is not zero and if it is, it moves
    the object by changing its `worldLocation` object. This method uses the velocity
    (either `xVelocity` or `yVelocity`) divided by the current frames per second to
    calculate the distance to move each frame. This ensures that the movement will
    be exactly correct, regardless of the current frames per second. It doesn't matter
    if our game executes smoothly or fluctuates a bit, or how powerful or puny the
    CPU in the Android device is. We will very soon call this `move` method from within
    the `update` method of the `Player` class. Later in the project, we will call
    it from other classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the `GameObject` class, we have a bunch of getters and setters for
    the new variables we added previously. The only part to note is that the setters
    for the two velocity variables (`setxVelocity` and `setyVelocity`) check `if(moves)`
    before actually assigning a value. Add these new getters and setters to the `GameObject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in the `Player` class constructor, we can use some of these new methods
    to set up the object at creation time. Add the highlighted code to the `Player`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can make practical use of all this new code in the `Player` class's
    `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we handle what happens when `isPressingRight` or `isPressingLeft` is
    true. Of course, we still need to be able to set these variables via touches on
    the screen. Very simply, this next code block sets the horizontal velocity to
    `MAX_X_VELOCITY` if `isPressingRight` is true or to `-MAX_X_VELOCITY` if `isPressingLeft`
    is true. If neither is true, it sets the horizontal velocity to zero, which is
    standing still.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Next, we check which way the player is moving and call `setFacing()` with either
    `RIGHT` or `LEFT` as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can handle jumping. When the player presses the jump button, if successful,
    `isJumping` will be set to true and `jumpTime` will be set to whatever the current
    system time is. So we can then enter the `if(isJumping)` block on each frame,
    test how long Bob has been jumping for, and if he has not exceeded `maxJumpTime`
    take one of two possible actions.
  prefs: []
  type: TYPE_NORMAL
- en: Action one is; if we are less than half way through the jump, the *y* velocity
    is set to `-gravity` (going up). Action two is; if Bob is more than half way through
    the jump, his *y* velocity is set to `gravity` (going down).
  prefs: []
  type: TYPE_NORMAL
- en: When `maxJumpTime` is exceeded, `isJumping` is set back to false until the next
    time the player taps the jump button. The final `else` clause in the following
    code executes whenever `isJumping` is false and sets the player's `y` velocity
    to `gravity`. Note that the additional line of code that sets `isFalling` to `true`.
    As we will see, this variable is used to control what happens when the player
    initially tries to jump and also in parts of our collision detection code. It
    basically stops the player from being able to jump in mid air.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Immediately after we handle jumping, we call `move()` to update the *x* and
    *y* coordinates, if they have changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: That was a bit of a mouthful, but apart from the actual controls, it is just
    about everything we need to allow the player to move. We just need to call the
    `update`() method from our `PlatformView` class's `update` method once each frame,
    and our player character will spring into action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method of the `PlatformView` class, add the following code
    as shown highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can see what is going on. Let''s add some more text output to the
    `if(debugging)` block in the `draw` method of `PlatformView`. Add the new highlighted
    code as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Why not run the game now? You have probably noticed the next issue is that the
    player is gone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Bob](img/B04322_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because we now have gravity, and also the thread that calls `update()`
    runs immediately as the application starts, even before our level and the player
    character is finished being set up.
  prefs: []
  type: TYPE_NORMAL
- en: We need to do two things. First, we only want `update()` to run when the `LevelManager`
    class has finished its work. Secondly, we need to update the focus of the `Viewport`
    class in every frame so that even if the player is falling to his death (as he
    will frequently) the screen will be centered on him, so we can watch his demise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the game on paused mode so that the player isn''t missing. First,
    we will add a method to our `LevelManager` class that will switch the playing
    status between playing and not playing. A good name may be `switchPlayingStatus()`.
    Add the new method to `LevelManager` as shown follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just delete or comment out the line of code in the `LevelManager` constructor
    that sets `playing` to `true`. Soon, this will be handled by screen touches and
    the method we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: We will write a tiny bit of temporary code, just a tiny bit. We already know
    that we will eventually be delegating responsibility to monitor player input to
    our new `InputController` class. This little bit of code in the overridden `onTouchEvent`
    method is well worth the effort because we will be able to use a pause feature
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: This code will toggle the playing status using the method we just wrote each
    time we touch the screen. Add the overridden method to the `PlatformView` class.
    We will eventually replace some of this code later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set `isPressingRight` in the `Player` class to true, following which
    you can run the game and tap the screen. We will then see the player fall like
    a ghost off the bottom, while moving to the right of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Bob](img/B04322_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s update the viewport per frame to remain centered on the player.
    Add this highlighted code to the very end of the `update` method in the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: If you run the game now, although the player still falls to his doom and to
    the right, at least the screen stays focused on him to watch it happen.
  prefs: []
  type: TYPE_NORMAL
- en: We will deal with the perpetual falling problem.
  prefs: []
  type: TYPE_NORMAL
- en: Multiphase collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that our player character simply falls though the world and into
    oblivion. Of course we need the player to be able to stand on the platforms. Here
    is what we will do.
  prefs: []
  type: TYPE_NORMAL
- en: We will provide every object that matters with a hitbox as we can then provide
    methods in the `Player` class to test if a hitbox has made contact with the player.
    Once per frame, we will send all hitboxes that have not been clipped by the viewport
    to this new method where a collision can be tested for.
  prefs: []
  type: TYPE_NORMAL
- en: We do it like this for two main reasons. Firstly, by sending only unclipped
    hitboxes for collision testing, we drastically reduce the number of checks, as
    described in [Chapter 3](ch12.html "Chapter 3. Tappy Defender – Taking Flight"),
    *Tappy Defender – Taking Flight*, in the section *Things that go bump – collision
    detection*. Secondly, by handling the checks within the `Player` class, we can
    give the player multiple different hitboxes and respond slightly differently according
    to which one is hit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our own class for a hitbox, so we can make it just how we want
    it. It needs to use float coordinates, it needs an `intersects` method and a bunch
    of getters and setters as well. Create a new class and call it `RectHitbox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see that `RectHitbox` simply has a bunch of self explanatory getters
    and setters. It also has the `intersects` method, which returns `true` if the
    `RectHitbox` passed into it intersects with itself. For an explanation of how
    the `intersects()` code works, see [Chapter 3](ch12.html "Chapter 3. Tappy Defender
    – Taking Flight"), *Tappy Defender – Taking Flight*. Enter the following code
    into the new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add a `RectHitbox` class as a member of `GameObject`. Add it right
    after the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a method to initialize the hitbox and a method so that we can
    grab a copy of it when needed. Add these two methods to `GameObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Now for our `Grass` object, we add a call to `setRectHitbox()` and then we can
    start bumping into it. Add this one line of highlighted code at the very end of
    the `Grass` class's constructor. It is important that the call to `setRectHitbox()`
    comes after the call to `setWorldLocation()` otherwise the hitbox won't be wrapped
    around the block of grass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can begin to comprehend the code that will do the collision checking,
    we need the `Player` class to have its own set of hitboxes. We need to know the
    following things about the player character:'
  prefs: []
  type: TYPE_NORMAL
- en: When the head bumps something above it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the feet land on a platform below
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player walks into something either side of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this, we will create four hitboxes; one for the head, one for the
    feet, and one for each of the left and right-hand sides. As they are unique to
    the player, we will create the hitboxes within the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the four hitboxes as members just after the `Player` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the constructor, we call new `RectHitbox()` to prepare them. Note that
    we haven''t bothered assigning any values to the hitboxes. We will see how we
    do that soon. Add the four calls to `new()` at the end of the `Player` constructor
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: We will see were we will initialize them properly. The hitbox values in the
    code that follows, have been manually estimated based on the space taken up by
    the actual shape of the character within the rectangle that represents each frame
    of the character. If you use a different character graphic, you will likely need
    to adjust the precise values you use.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows an approximate graphical representation of the locations that
    each hitbox will be positioned at. The apparent lack of closeness for the left
    and right hitboxes is because different frames of the animation are slightly wider
    than this one. This is a compromise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiphase collision detection](img/B04322_06_03_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code must be placed after the call to `move()` within the `update` method
    in the `Player` class. This way, the hitboxes are updated each and every time
    the player position has changed. Add the highlighted code in exactly the position
    shown, and then we are one step closer to being able to start bumping in to stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: In the next stage, we can detect some collisions and react to them. Collisions
    which only concern the player, such as falling, bumping his head, or trying to
    walk through a wall are handled directly in this next method, within the `Player`
    class. Note that the method also returns an `int` value to represent if there
    was a collision and where on the player that collision occurred so that other
    collisions with things like pickups or pits of fire can be handled outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The new `checkCollisions` method receives a `RectHitbox` as a parameter. This
    will be the `RectHitbox` of whichever object we are currently checking against
    for collisions. Add the `checkCollisions` method to the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'As the previous code implies, we need to add some setter methods to the `GameObject`
    class so that the *x* and *y* world coordinates can be changed when a collision
    is detected. Add the following two methods to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to select all relevant objects and test for collisions. We
    do this in the `update` method of the `PlatformView` class, following which we
    switch to take further actions based on which body part collides with what object
    type. Our switch block will only have a default case to begin with, since we have
    only one possible object type to collide with a grass platform. Note that when
    a collision with the feet is detected, we set our `isFalling` variable to `false`,
    enabling the player to jump. Enter the highlighted code where shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will make more use of the value that gets stored in `hit` for further collision-based
    decision making, as we progress with this project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take control of the player for real.
  prefs: []
  type: TYPE_NORMAL
- en: Player input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's add some methods in the `Player` class that our input controller
    will be able to call, then manipulate the variables that the `Player` class's
    `update` method uses to move around.
  prefs: []
  type: TYPE_NORMAL
- en: We already played with the `isPressingRight` variable, and also have an `isPressingLeft`
    variable. Furthermore, we want to be able to jump. If you take a look at the `Player`
    class's `update` method, we already have the code to handle these situations.
    We just need the player to be able to initiate the movements via touches to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous button layout design and the code we have written so far, suggests
    a method for going left, a method for going right, and a method for jumping.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also note that we pass a copy of `SoundManager` into the `startJump`
    method, which allows us to play a neat retro jumping sound, if the jump attempt
    is successful. Add these three new methods to the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can focus on the `InputController` class. Let''s pass control from
    the `onTouchEvent` method to our `InputController` class. Change the code in the
    `onTouchEvent` method to the following in the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: We have an error in our new method. This is simply because we have called the
    `handleInput` method but not implemented it yet. We will do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering about the check for whether `lm != null`, that is because
    the `onTouchEvent` method is triggered from the Android UI thread and is not within
    our control. If we pass in `lm` and start trying to do things with it, when it
    is not initialized, the game will crash.
  prefs: []
  type: TYPE_NORMAL
- en: We can now get everything that we need done within the `InputController` class.
    Open that class now, and we will plan what we are going to do.
  prefs: []
  type: TYPE_NORMAL
- en: We need a button to go left, a button to go right, a button to jump, a button
    to toggle pause, and later we will also need a button to fire a machine gun. Therefore,
    we really need to highlight different areas of the screen to represent each of
    these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will declare four `Rect` objects, one for each task. Then in
    the constructor, we will define the points of these four `Rect` objects by carrying
    out some simple calculations based on the players screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define some handy variables, `buttonWidth`, `buttonHeight`, and `buttonPadding`,
    based on the device''s screen resolution to help us arrange our `Rect` coordinates
    neatly. Enter the following members and the `InputController` constructor as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the four `Rect` objects to draw buttons on the screen. The `draw`
    method is going to need a copy of them. Enter the code for the `getButtons` method
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: We can now handle the actual player input. This project is different to the
    previous one because there are lots of different possible player actions that
    need to be monitored and responded to, sometimes simultaneously. As you expect,
    the Android API has the functionality to make this as easy as possible for us.
  prefs: []
  type: TYPE_NORMAL
- en: The `MotionEvent` class has a lot more data tucked away in it than we have seen
    so far. Previously, we simply checked for the `ACTION_DOWN` and `ACTION_UP` events.
    Now, we need to dig a little deeper to grab more of the event data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to record and pass on the details of multiple fingers, touching, leaving,
    and moving on the screen, the `MotionEvent` class stores them all in an array.
    When the first finger of the player touches the screen, the details, coordinates,
    and so on, are stored at position zero. Subsequent actions are then stored later
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: The position in the array related to any such finger's activity is not consistent.
    In some situations, such as detecting specific gestures, this can be a problem
    and the programmer needs to capture, remember, and respond to the ID of a finger,
    also held in the `MotionEvent` class.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately in this situation, we have our clearly defined areas of the screen
    that represent our buttons, and the most we will ever need to know is if the finger
    has pressed or released the screen within one of these predefined areas.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to find out how many fingers have caused events and are therefore
    stored in the array by calling `motionEvent.getPointerCount()`. We then loop through
    each of these events while providing a `switch` block to handle them, whatever
    area of the screen, where `ACTION_DOWN` or `ACTION_UP` has occurred. It won't
    matter which position in the array our event is stored at, as long as we detect
    it and respond to it.
  prefs: []
  type: TYPE_NORMAL
- en: The only other thing we need to know, before we can code our solution, is that
    the subsequent actions in the array are stored as `ACTION_POINTER_DOWN` and `ACTION_POINTER_UP`;
    therefore, with each pass through the loop, that we will shortly code, we need
    to check and handle both `ACTION_DOWN` and `ACTION_POINTER_DOWN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all this talk, here is our `handleInput` method that gets called every
    time the screen is touched or released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering why we bothered to set up two sets of control code, one
    for playing and one for not playing, it is because in [Chapter 8](ch17.html "Chapter 8. Platformer
    – Putting It All Together"), *Putting It All Together*, we will add a cool new
    feature for the game while it is paused. Of course, the `togglePlayingStatus`
    method did not need to be done like this, and it would have worked fine without
    the test for the status of playing. It just saves us making minor intricate amendments
    to our code later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is open up the `PlatformView` class, grab a copy of the
    array with all the control buttons in, and draw them to the screen. We use the
    `drawRoundRect` method to draw neat curved-corner rectangles to represent the
    areas of the screen that will respond to the player''s touches. Enter this code
    in the `draw` method right before the call to `unlockCanvasAndPost()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Also, right before we call `unlockCanvasAndPost()`, let's draw a simple pause
    screen so that we know when the game is paused or playing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now jump and walk all over the place and a nice retro jumping sound
    plays as well. Why not add some more grass to the scene by editing `LevelCave`
    and replacing a few period characters (`.`) with a few more `1` characters. The
    next screenshot shows that the player has been jumping around a bit as well as
    the buttons used for controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player input](img/B04322_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will design some real-playable levels, as well as link them together in [Chapter
    8](ch17.html "Chapter 8. Platformer – Putting It All Together"), *Putting It All
    Together*. For now, just do whatever seems like fun with `LevelCave`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can get rid of that ugly squashed player graphic and make a neat little
    animation out of it.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Bob
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite sheet animations work by quickly changing the image drawn to the screen.
    Exactly like a child may draw the phases of a stick-man moving on the corner of
    a book, and then quickly flicking through it to make it appear to move.
  prefs: []
  type: TYPE_NORMAL
- en: The frames of Bob's animation are already contained within the `player.png`
    file we have been using to represent him.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating Bob](img/B04322_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All we need to do is loop through them one at a time when the player is moving.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite straightforward to implement. We will make a simple animation
    class that handles the function of keeping time and returning the appropriate
    part of the sprite sheet when requested. We can then initialize a new animation
    object for any `GameObject` that needs to be animated. In addition, when they
    are being drawn in the `draw` method of `PlatformView`, if the object is animated,
    we will handle it slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will also see how to use the facing variable that tracks
    which way the player is facing. It will enable us to reverse the sprite sheet
    depending on the way the player (or any future animated objects) is headed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by making the animation class. Create a new Java class and call
    it `Animation`. The code that follows soon will declare variables that hold the
    bitmap to be manipulated, the name of the bitmap, and a `rect` parameter to define
    the area of the sprite sheet that is the coordinates of the currently relevant
    frame of animation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we have `frameCount`, `currentFrame`, `frameTicker`, and `framePeriod`
    that hold and control the number of available frames, the current frame number,
    and the timing of the change of the frames. As you would expect, we also need
    to know the width and height of a frame of animation, these are held by `frameWidth`
    and `frameHeight`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `Animation` class will regularly refer to the number of pixels
    per meter; therefore, it makes sense to hold this value in a member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter these member variables that we discussed in the `Animation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the constructor that prepares our animation object for use. We
    will see exactly how we prepare for the actual animation soon. Note that there
    are a fair few parameters in the signature indicating that the animation is quite
    configurable. Just note that FPS in this context is not referring to the frame
    rate of the game but the frame rate of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: We can deal with the real functionality of the class. The `getCurrentFrame`
    method first checks to see if the object is moving or if it is capable of moving.
    At this stage, this may seem a little odd as this method will only ever be called
    by a `GameObject` class that is animated. The odd looking check, therefore, is
    determining if a new frame is required at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: If an object moves, (such as Bob), but is standing still, then we don't need
    to change the frame of animation. However, if the animated object has no velocity
    ever, like a roaring fire, then we need to animate it all the time. It will never
    have any velocity so the `moves` variable will be `false`, but the method will
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The method then uses `time`, `frameTicker` and `framePeriod`, to determine if
    it is time to show the next frame of animation and if it increments the frame
    number to display. Then, if the animation is on the last frame, it goes back to
    the first frame.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the precise left and right-hand positions that represent the portion
    of the sprite sheet that contains the needed frame, are calculated and returned
    to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can add some members to the `GameObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Some methods to interact with our `Animation` class, which set and get variables,
    make the animation work and inform the `draw` method if the object is animated
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Lastly in `GameObject`, there is a method which the objects that require animating
    can use to set up their whole animation object. Note it is this `setAnimated`
    method that calls `new()` on a new animation object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The next method acts as a go between for the `draw` method of the `PlatformView`
    class and the `getRectToDraw` method of the `Animation` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update the `Player` class in order to initialize its animation
    object according to its own specific required number of frames and frames per
    second. The new code in the `Player` class is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: We can use all this new code from the `draw` method to implement our animations.
    The next block of code checks if the current `GameObject` being drawn `isAnimated()`.
    If it is, it gets the appropriate rectangle from the sprite sheet using the `getNextRect()`
    method via the `GameObject` class's `getRectToDraw` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, the next code listing from the `draw` method that made the original
    call to `drawBitmap()`, is now wrapped in an `else` clause at the end of the new
    code. Basically, the logic is this. If animated, execute the new code, otherwise
    just do it the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the animation code we know about, we also check `if(go.getFacing()
    == 1)` and use the `Matrix` class to flip the bitmap when required by scaling
    it by -1 on the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all the new code, including the original `drawBitmap()` call wrapped
    in an `else` clause at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the game and see Bob in all his animated glory. The screenshot
    can''t show his movements, but you can see he is now perfectly formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating Bob](img/B04322_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game is steadily coming together. At this stage, we can build a huge level
    design in `LevelCave` and go running and jumping all over the place. However,
    we will save to postpone trying to make the game playable until we have added
    a load more neat features.
  prefs: []
  type: TYPE_NORMAL
- en: These neat features will include a machine gun, which can be upgraded through
    collectible pickups and some enemies that Bob can shoot at. We will get going
    with that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7. Platformer – Guns, Life, Money, and the Enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will do many things. First, we will build a machine gun
    with a variable rate of fire and have it shoot bullets. Then, we will introduce
    pickups or collectibles. These give the player something to scavenge for while
    trying to escape into the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Then, just as Bob was beginning to think that his life was a blissful one of
    grass and collectibles, we will build two adversaries for him to outsmart or kill.
    A homing drone and a patrolling guard. We will easily be able to add all these
    things into our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: Ready aim fire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can give our hero a gun, and later, we can give him enemies to shoot
    at. We will create a `MachineGun` class to do all the work and a `Bullet` class
    to represent the projectiles that it fires. The `Player` class will control the
    `MachineGun` class, and the `MachineGun` class will control and keep track of
    all the `Bullet` objects that it fires.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `Bullet`. Bullets are not complicated. Ours
    will need a *x* and *y* location, a horizontal velocity, and a direction to help
    calculate the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implies the following simple class, constructor, and a bunch of getters
    and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Now let's implement the `MachineGun` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Java class and call it `MachineGun`. First, we add some members.
    The `maxBullets` variable is not the amount of shots a player has, that is unlimited,
    it is the number of bullet objects the `MachineGun` class can have. Ten is sufficient
    for a very fast firing gun, as we will see. The members `numBullets` and `nextBullet`
    help the class to keep track of its 10 bullets. The `rateOfFire` variable controls
    how fast the player will be able to tap the fire button, and `lastShotTime` will
    help enforce the `rateOfFire` by keeping track of the system time that the last
    bullet was fired. It is the rate of fire that will be the upgradeable aspect of
    the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code that we discussed as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For functional purposes, we can think of the `CopyOnWriteArrayList` `bullets`,
    which stores our bullets, as a plain old `ArrayList` object. We use this more
    complex and slightly slower class because it is thread safe and bullets can be
    accessed potentially simultaneously from the UI thread, when the player taps the
    fire button as well as from our own thread. This article explains `CopyOnWriteArrayList`,
    if you want to know more, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the constructor that just initializes bullets, `lastShotTime`, and
    `nextBullet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Here, we update all the `Bullet` objects controlled by the gun by calling the
    `bullet.update` method for each bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have some getters that will let us find out things about our gun and
    its bullets, to do things like collision detection, and drawing bullets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: We also have a quick helper method for when we want to stop drawing a bullet.
    We hide it away until it is ready to be reassigned in our `shoot` method shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'A getter that returns the direction of travel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Now, we add a more comprehensive method that actually shoots a bullet. The method
    compares the time of the last fired shot against the current `rateOfFire`. It
    then proceeds to increment `nextBullet` and create a new `Bullet` object if permitted.
    The bullet is sent speeding off in the same direction as Bob is facing. Note that
    the method returns `true` if a bullet was successfully fired. This is so that
    the `InputController` class can play a sound effect to correspond with the player's
    button press.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have a method to call when the player finds a machine gun upgrade
    pickup. We will see more of them later in the chapter. Here, we simply increase
    `rateOfFire`, which enables the player to tap the fire button more furiously and
    still get results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will modify the `Player` class to carry a `MachineGun`. Give `Player`
    a member variable that is a `MachineGun`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in the `Player` constructor, add a line of code to initialize our new
    `MachineGun` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Player` class''s `update` method, add a call to the `MachineGun` class''s
    `update` method just before we call `move()` for the player. As highlighted next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Add a method to the `Player` class, so our `InputController` can access the
    virtual trigger. As we saw, the method returns `true` if a shot was successful
    so that the `InputController` class knows whether to play a shot sound or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make some minor additions to our `InputController` class so that
    the player can fire a shot. The code to add is shown highlighted amongst the existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Not forgetting the way that our new control system works, we also need to add
    the same piece of extra code further down the `InputController` class in the `MotionEvent.ACTION_POINTER_DOWN`
    case as well. As usual, here is the code highlighted and with plenty of context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a gun, it's loaded, and we know how to pull the trigger. We just
    need to draw the bullets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new code in the `draw` method, just before we draw the debugging text,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: We will now fire some bullets. Note that the rate of fire is unsatisfying and
    slow. We will add some pickups, which the player can get to increase the rate
    of fire of his gun.
  prefs: []
  type: TYPE_NORMAL
- en: Pickups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pickups are game objects that can be collected by the player. They include things
    like upgrades, extra lives, money, and so on. We will now implement one of each
    of those collectibles. As our game engine is setup the way it is, this will be
    surprisingly easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is create a class to hold the state of the current
    player. We want to monitor the money collected, power of machine gun, and lives
    remaining. Let's call it `PlayerState`. Create a new Java class and name it `PlayerState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the variables, we have just talked about, we also want the `PlayerState`
    class to remember an *x* and *y* location to respawn at, when the player loses
    a life. Enter these member variables and the simple constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a method that we can call to initialize the respawn location.
    We will use this later when we call this method. Also, we need a method to reload
    the location. These are our next two methods for the `PlayerState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need a whole bunch of getters and setters to give us access to the
    members of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare an object of the `PlayerState` type as a member of the `PlatformView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the `PlatformView` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Now in the `loadLevel` method, create a `RectF` object, store the players starting
    location, and pass it in to the `PlayerState` object, `ps`, for safe keeping.
    Each time the player dies, he can be respawned using this location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will create three classes, one for each of our pickups. These classes
    are very simple. They extend `GameObject`, set a bitmap, have a hitbox, and a
    location in the world. Also note that they all receive a type in the constructor
    and use `setType()` to store this value. We will soon see how to use their type
    to handle what happens when the player "picks them up". Create three new Java
    classes: `Coin`, `ExtraLife`, and `MachineGunUpgrade`. Note that the pickups are
    a little smaller than a platform, perhaps as we may expect. Enter the code for
    each of them in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `Coin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for `ExtraLife`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `MachineGunUpgrade` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `LevelManager` class to expect these three new objects in our
    level designs and add them to `ArrayList` of `GameObjects`. To do this, we need
    to update the `LevelManager` class in three places: `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. Here are each of these minor updates, with the new code highlighted
    amongst the existing code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following additions to `getBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Make identical additions, but this time to `getBitmapIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the final changes within `LevelManager` with the following additions to
    `loadMapData()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add the three appropriately named graphics to the drawable folder
    and start adding them to our `LevelCave` design. Go ahead and copy `clip.png`,
    `coin.png`, and `life.png` from the `Chapter7/drawables` folder in the download
    bundle to the `drawable` folder of your Android Studio project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a handy list of comments that identify all the types of game object. We
    will add these over the course of this project and the alpha-numeric code that
    will represent them on our level designs. Add the following comments to the `LevelData`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we enhance our `LevelCave` class to use our new objects, we want to
    detect when the player collects them or collides with them and take appropriate
    action. We will first add a quick helper method to the `Player` class. The reason
    for this is because when the player collides with another object, the default
    action in the `Player` class''s `checkCollisions` method is to stop the character
    moving. We don''t want this to happen for pickups because it will be irritating
    for the player. Therefore, we will quickly add a `restorePreviousVelocity` method
    to the `Player` class that we can call whenever we don''t want this default action
    to occur. Add this method to the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can handle the collisions for each of our pickups in turn. Add these
    cases to handle our three pickups within the switch block that handles our collisions
    in the `update` method of the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add the new objects to our `LevelCave` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following code snippet, I suggest, is for a simple new layout that demonstrates
    our new objects, but your layout can be as big or elaborate as you like. We will
    do something more elaborate in the next chapter when we design and link some levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into `LevelCave` or elaborate with your own design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the simple layout will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pickups](img/B04322_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try collecting the pickups, and you will hear the pleasing sound effects. In
    addition, each time we collect a pickup, the `PlayerState` class stores an update.
    This will be useful when we build a HUD in the next chapter. Most fun of all;
    if you collect the machine gun upgrades, then try shooting your gun, you will
    find it much more satisfying to wield.
  prefs: []
  type: TYPE_NORMAL
- en: We better make those bullets do something. However, before we do that, let's
    give the player a bit more cannon fodder in the form of a couple of enemies.
  prefs: []
  type: TYPE_NORMAL
- en: The drone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The drone is a simple but evil enemy. It will detect the player when it is within
    the viewport and fly straight at him. If the drone touches the player, death is
    immediate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a `Drone` class. Create a new Java class and call it `Drone`. We
    need member variables to remember when we set the last waypoint. This will restrict
    the frequency with which the drone will get a navigation update of Bob's coordinates.
    This stops the drone from being too deadly accurate. It needs a waypoint/target
    coordinate and also needs to know the speed limit via `MAX_X_VELOCITY` and `MAX_Y_VELOCITY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Now in the `Drone` constructor, initialize the usual `GameObject` members and
    specifically, the `Drone` class ones such as `currentWaypoint`. Not forgetting,
    that if we are going to shoot the drone, it will need a hitbox and we call `setRectHitBox()`
    after we have called `setWorldLocation()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Here is the implementation of the `update` method, which compares the drone's
    coordinates with its `currentWaypoint` variable and changes its velocity accordingly.
    Then, we end `update()` by calling `move()` then `setRectHitbox()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: In our last method for the `Drone` class, update the `currentWaypoint` variable
    by passing in Bob's coordinates as a parameter. Note that we check if enough time
    has elapsed for an update to make sure our drone is not too accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Add the drone graphic `drone.png` from `Chapter7/drawable` into the `drawable`
    folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add drones to our `LevelManager` class in the usual three places,
    just as we did for each of our pickups. Now, add code to `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. These are the three minor code additions in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code in the `getBitmap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the highlighted code in the `getBitmapIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the highlighted code in the `loadMapData` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: The burning question is; how does the drone know where to go? In each frame,
    if there is a drone within the viewport, we can send the coordinates of the player.
    Do what is shown in this next code block within the `update` method of the `PlatformView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the new code is shown highlighted and in the context of the existing
    code. If you remember the `setWaypoint()` code from the `Drone` class, it only
    accepts updates every 2 seconds. This stops the drone from being too accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, these evil drones can be strategically placed around the level, and they
    will home in on the player. The last thing we need to do to make the drones fully
    operational is to detect when they actually collide with the player. This is nice
    and easy. Just add a case for drones in our collision detection `switch` block
    in the `update` method of the `PlatformView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and add a whole bunch of drones to `LevelCave` and watch them fly at
    the player. Note that if a drone catches the player, he dies and respawns.
  prefs: []
  type: TYPE_NORMAL
- en: '![The drone](img/B04322_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as if the world wasn't a dangerous enough place with all those enemy drones,
    let's add another type of enemy.
  prefs: []
  type: TYPE_NORMAL
- en: The guard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The guard enemy will be an exercise in scripting. We will have our `LevelManager`
    class automatically generate a simple script, which generates a route for our
    guard to patrol.
  prefs: []
  type: TYPE_NORMAL
- en: The route will be the simplest one possible; it will be just two waypoints that
    the guard will walk between continuously. It will be much quicker and simpler
    to preprogram our guards with two predetermined waypoints. However, by taking
    the time to have it automatically generated, we can place guards wherever we like
    (within certain parameters) on any level we design, and the behavior will be taken
    care of for us.
  prefs: []
  type: TYPE_NORMAL
- en: Our guard will be animated, so we will be using a sprite sheet and configuring
    the animation details in the constructor; just as we did for the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `Guard`. First, handle the member variables.
    Our `Guard` class will not only need two waypoints, but also a variable to indicate
    which one the current waypoint is. Like other moving objects, it will need velocity.
    Here is the class declaration and member variables to start coding your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: We need to set up our guards via the constructor. First, setup our animation
    variables, bitmap, and sizes. Then as usual, set the guard's position in the level,
    its hitbox, and the way that it is facing. However, in the last line of the constructor
    we set `currentWaypoint` to `1`; this is new. We will see how this informs our
    guard's behavior in this class's `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a method that our `LevelManager` class will use to let the `Guard`
    class know what its two waypoints are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will code the "brains" of our `Guard` class, that is, its `update` method.
    You can basically break this method into two main parts. First, `if(currentWaypoint
    == 1)` and secondly, `if(currentWaypoint == 2)`. Inside each of these `if` blocks,
    simply check if the guard has reached or passed the appropriate waypoint. If it
    has, switch waypoints, reverse the velocity, and make the guard face the other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call `move()` then `setRectHitbox()` to update the hitbox to the new
    location of the guard. Add the code for the `update` method and then we will see
    how to put it to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add `guard.png` from the `Chapter7/drawables` folder of the download
    bundle to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can make the usual three additions to the `LevelManager` class to load
    any guards that may be found in our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `getBitmap()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'In `getBitmapIndex()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'In `loadMapData()`, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: We will soon add something totally new to `LevelManager`. That is a method that
    will create the script (set two waypoints to patrol). For this new method to work,
    it needs to know if the tile is suitable for walking on. We will add a new property,
    a getter, and a setter to `GameObject` so that this is easily discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this new member to the `GameObject` class right after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these two methods to the `GameObject` class to get and set this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `Grass` class constructor, add a call to `setTraversable()`. We
    must remember to do this for all future `GameObject` derived classes that we design,
    if we want our guards to be able to patrol on them. In `Grass`, add this line
    at the top of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at the new `setWaypoints` method for our `LevelManager` class.
    It needs to examine the level design and calculate two waypoints for any `Guard`
    objects present in that level.
  prefs: []
  type: TYPE_NORMAL
- en: We will break this method into a few parts, so we can see what's happening at
    each stage.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to loop through all the `gameObjects` classes looking for the
    `Guard` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: If we reach this point in the code, it means we have found a guard who will
    need two waypoints to be set. First, we need to find the tile which the guard
    is "standing on". Then, we calculate the coordinate of the last traversable tile
    on either side, but with a maximum range of five tiles each way. These will be
    the two waypoints. Here, is the code to add to the `setWaypoints` method. It is
    heavily commented to make clear what is going on without interrupting the flow
    by stopping to talk about it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call our new `setWaypoints` method as the last thing to do in the
    `LevelManager` constructor. We need to call this method after the `GameObject`
    class''s `ArrayList` has been populated or there will be no guards in it. Add
    the call to `setWaypoints()` as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Next, add this code to the collision detection switch block in the `update`
    method of the `PlatformView` class, so we can bump into the guards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add some `g` letters to the `LevelCave` class. Make sure to place
    them with one space above the platform, because they are 2 meters high as in this
    pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '![The guard](img/B04322_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implemented guns, pickups, drones, and guards. This means we now have plenty
    of dangers, but have a machine gun that can't do any damage. We will change that
    first thing in the next chapter, by implementing collision detection for our bullets.
    However, we will go slightly further than merely having them hit our enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8. Platformer – Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we will make the bullets do some damage. The ricochet sound is very
    satisfying when the bullets energy is absorbed by a clump of grass. We will add
    an abundance of new platform types and inanimate scenery objects to make our levels
    more interesting. We will provide a real sense of motion and immersion by implementing
    multiple scrolling parallax backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add an animated fire tile for the player to avoid, and in addition,
    a special `Teleport` class to link levels together into one playable game. Then,
    we will use all of our game objects and backgrounds to create four, linked, and
    fully playable levels.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will add a HUD to keep track of pickups and lives. Finally, we will
    discuss some of the neat things that couldn't be fitted into this project in just
    four chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Bullet collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting bullet collisions is fairly straightforward. We loop through all the
    existing `Bullet` objects held by our `MachineGun` object. Next, we convert the
    points of each bullet into a `RectHitBox` object and test it using `intersects()`
    against each object in our viewport.
  prefs: []
  type: TYPE_NORMAL
- en: If we get a hit, we check to see what type of object it has hit. We then switch
    to handle each type of object that we care about. If it is a `Guard` object, we
    knock it back a bit, if it is a `Drone` object, we destroy it, and if it is anything
    else, we just make the bullet disappear and play a kind of thudding/ricochet sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply place this logic we discussed after our `switch` block that handles
    collisions with the player, but before, we call `update()` on all our unclipped
    objects as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Try it out, it is really satisfying, especially with a high rate of fire.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some fire tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These new `GameObject` derived objects will mean instant death to Bob. They
    won't move, but they will be animated. We will see we can achieve this just by
    setting the already existing properties of `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding this feature into our game is simple because we have already implemented
    all the features we need. We already have a way to locate and add new tiles, a
    way to detect and respond to a collision, sprite sheet animation, and so on. Let's
    do it step-by-step, then we can add these dangerous and life-threatening elements
    into our world.
  prefs: []
  type: TYPE_NORMAL
- en: We can put the entire functionality of the class into its constructor. All we
    do is configure the object much like we did our `Grass` object, but in addition,
    we configure it with all the animation settings, like we did to the `Player` and
    `Guard` objects. The `fire.png` sprite sheet has three frames of animation that
    we want to play over the course of one second.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some fire tiles](img/B04322_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new class, call it `Fire`, and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Now, of course, we need to add the `fire.png` sprite sheet from `Chapter8/drawable`
    in the download bundle to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add to our `LevelManager` class, in the usual three ways that we have
    done for all our new `GameObject` derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `getBitmap` method, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getBitmapIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loadMapData()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add to our collision detection `switch` block to handle the consequences
    of touching this terrible tile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Why not add a few `f` tiles to `LevelCave` and experiment with what the player
    is able to jump over. It will help us design some challenging levels later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding some fire tiles](img/B04322_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We don't want our player to be walking on the grass the whole time, so let's
    add some more variety.
  prefs: []
  type: TYPE_NORMAL
- en: Eye candy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next three sections in this chapter will be purely aesthetic. We will add
    a whole bunch of different tile graphics with matching classes so that we can
    use a whole lot more artistic license to make our levels more interesting. The
    difference between the tiles will be purely visual, but it will be fairly simple
    to make them more functional than that.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can easily detect collision with a snow tile and have the player
    keep moving briefly after stopping to simulate skidding, or perhaps; the concrete
    tile can allow the player to move faster and therefore change the way we design
    big jumps and so on. The point is that you don't have to just copy paste the classes
    as they will be presented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add some completely aesthetic props: mine carts, boulders, stalactites,
    and more. There will be no collision detection for these objects. They will allow
    the level designer to make the levels more visually interesting.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be simple to make these aesthetics more functional. Just add a hitbox
    and a case in the collision detection switch block to handle the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Probably, the most visually significant improvement we add, will be scrolling
    backgrounds. We will add some classes to allow the level designer to add multiple
    different scrolling backgrounds to a level design.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why not add all the graphics from the `Chapter8/drawable` folder of the download
    bundle to the `drawable` folder of your project. Then, you will have all the graphics
    ready and in place, for this and the next two sections as well.
  prefs: []
  type: TYPE_NORMAL
- en: The new platform tiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, add all these classes with the filenames as shown. I have removed all
    comments from the code because they are all functionally the same as the `Grass`
    class. Create each of the following classes with the name shown and enter the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Brick` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Coal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the `Concrete` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the `Scorched` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Snow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the `Stone` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Now, as we are getting used to, we need to add them all into our `LevelManager`
    in the usual three places.
  prefs: []
  type: TYPE_NORMAL
- en: In `getBitmap()`, we simply add them in as normal. Note that although the values
    are arbitrary, we will use numbers for the type 2,3,4, and so on. This makes it
    easy to remember, while designing levels, that all our actual platforms are numbers.
    The actual index numbers are unimportant to us, as long as they are the same as
    in the `getBitmapIndex` method. Also, remember that we have a list of types in
    our `LevelData` class's comments, for easy reference when designing levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'In `getBitmapIndex()`, we do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: In `loadMapData()`, we just call `new()` on our new `GameObjects` to add them
    to our `gameObjects` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go wild adding different terrains to the `LevelCave` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new platform tiles](img/B04322_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to add some scenery objects.
  prefs: []
  type: TYPE_NORMAL
- en: The new scenery objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will add some objects that don't do anything but look pretty. We will
    let the game engine know by simply not adding a hitbox and setting them randomly
    to either z layer -1, or 1\. Then the player can appear either in front or behind
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first add all the classes, and then update `LevelManager` in the usual
    three places. Create each of the new classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Boulders` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: From now on, I removed all the comments to save digital ink. The class functionality
    is the same as it is in `Boulders`, just the attributes vary a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Cart` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the `Lampost` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Stalagmite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `Stalactite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the `Tree2` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: That's all the new classes for the scenery objects. Now, we can update the `getBitmap`
    method with the seven new types in the `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `getBitmapIndex` method in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make sure our new scenery items are added to our `gameObjects` array
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can design levels with scenery. Note the slight difference in appearance
    when an object is drawn on layer zero compared to layer one and how the player
    character passes either in front or behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new scenery objects](img/B04322_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, if you want to bump into lamposts, get skewered by stalagmites, or
    jump on top of mine carts, then just give them a hitbox.
  prefs: []
  type: TYPE_NORMAL
- en: We have one more way to beautify our game world.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling parallax backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parallax backgrounds are scrolling backgrounds, where we scroll them slower
    the farther away they are. So, if we have a grass verge at the player's feet,
    we will scroll it quickly. However, if we have a mountain range in the distance,
    we will scroll it slowly. This effect can give the sense of motion to the player.
  prefs: []
  type: TYPE_NORMAL
- en: To implement them, we will first add a data structure to represent the parameters
    of a background. We will call this class `BackgroundData`, we will then implement
    a `Background` class, which has the functionality necessary to control the scrolling
    and then we will see how to position and define backgrounds in our level design.
    Finally, we will write a `drawBackground` method that we will call from our regular
    `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you added all the graphics from the `Chapter8/drawable` folder of
    the download bundle to the `drawable` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's build a simple class to hold the data structure which will define
    our backgrounds. As we can see in the next block of code, we have quite a large
    number of parameters and member variables. We will need to know which bitmap will
    represent a background, which layer on the *z* axis to draw it (in front on 1
    or behind on -1), where in the world on the *y* axis it starts and finishes, how
    fast the background will scroll, and how high the background will be.
  prefs: []
  type: TYPE_NORMAL
- en: The `isParallax` Boolean is intended to give the option to have a background
    which is static, but we will not be implementing this feature. When you see the
    code for the background class, you will see it is simple to add this functionality
    if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and call it `BackgroundData`, then implement it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add an `ArrayList` of our new type to the `LevelData` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create the `Background` class itself. Create a new class and name
    it `Background`. First, we set up a bunch of variables to hold a copy of the background
    image along with a reversed copy. We will make the backgrounds seem *endless*
    by putting the images back to back alternating between the regular image and a
    reversed image. We will see how to achieve this further on in the code.
  prefs: []
  type: TYPE_NORMAL
- en: We also have variables for the width and height of the image in pixels. The
    `reversedFirst` Boolean will determine which copy of the image is currently drawn
    on the left-hand side of the screen (first) and will change as the player moves
    and the image scrolls. The `xClip` variable will hold the precise pixel of the
    *x* axis (of the image), where we will cut the image and start to draw it from
    the left hand edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `y`, `endY`, `z`, and `speed` member variables are to hold the related
    values passed in as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the constructor, we create an Android resource ID from the name of the
    graphic file passed in as a parameter. Then, create the actual bitmap by calling
    `BitmapFactory.decodeResource()`. We set `reversedFirst` to `false`, so we will
    start with the regular (non-reversed) copy of the image on the left-hand side
    of the screen. We initialize our member variables and then scale the bitmap we
    just created by calling `Bitmap.createScaledBitmap()` and passing in bitmap, the
    width of the screen and the height (in the game world) of our background multiplied
    by the `pixelsPerMetre`, making the bitmap exactly the right size for the current
    devices screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we must choose appropriate heights for our background designs or they
    will appear stretched.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in the constructor is create a `Matrix` object and send
    it to the `createScaledBitmap` method along with the bitmap, so we now have a
    reversed copy of our background image stored in the `bitmapReversed Bitmap` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add two backgrounds to our level design. We fill out the required parameters
    that we have already discussed. Note that the "grass" background on layer 1 scrolls
    much faster than the "skyline" background on layer -1\. This will create the desired
    parallax effect. Add this code right at the end of the `LevelCave` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is certainly true that most caves do not have grass and a skyline. This is
    just a demonstration and to get the code working. We will redesign `LevelCave`
    and design some more appropriate levels a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load them with our `LevelManager` class by declaring a new `Arraylist`
    object as a member of our `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a new method in `LevelManager` to load the background data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the new method in the `LevelManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: And, not for the last time, we will upgrade our `Viewport` class to enable our
    `PlatformView` methods to get the information they need, to draw the parallax
    backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will add a method which actually does the drawing in the `PlatformView`
    class. We will call this method from `onDraw()`, in just the right places, next.
    Note that we are using the new methods that we just added to the `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define four `Rect` objects that we will use to hold the start and
    end points of `bitmap` and `reversedBitmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the first part of the `drawBackground` method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Now, we simply loop through all our backgrounds using the `start` and `stop`
    parameters to decide which backgrounds have a *z* layer that we are currently
    interested in drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Next, we send the world coordinates of the background to the `Viewport` class
    for clipping. If it isn't clipped (and should be drawn), we get the starting pixel
    coordinates, and ending pixel coordinates on the *y* axis with the help of the
    new methods we added to our `Viewport` class previously. Note that we cast the
    results to `int` variables ready to be drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'This next block of code is where the real action takes place. We initialize
    the four `Rect` objects with the starting and ending coordinates of the first
    and second of our two `Bitmap` objects. Note that the point (or pixel) that is
    calculated, is determined by `xClip`, which is initially zero. So, to start with,
    we will simply see `background` (if it is not clipped) stretched across the width
    of the screen. Soon, we will see that we modify `xClip` based on Bob''s velocity
    and cause different regions from each bitmap to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Now, we determine which background (regular or reversed) is currently being
    drawn first, and then draw that one first followed by the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: We can scroll along based on the speed and direction of Bob, `lv.player.getxVelocity()`
    and if `xClip` has reached the end of the current first background, `if (bg.xClip
    >= bg.width)`, simply set `xClip` to zero and change which bitmap we show first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Then, we add a call to `drawBackground()` just before our game objects for backgrounds
    with a *z* layer less than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Just after the bullets are drawn, but before the debugging text for those backgrounds
    with a *z* order more than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can really start to get creative with our level designs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scrolling parallax backgrounds](img/B04322_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Very soon, we will make some real playable levels that use all the features
    we have implemented over the last four chapters. Before we do that, let's have
    a bit of fun with the `Viewport` class.
  prefs: []
  type: TYPE_NORMAL
- en: It will be really useful for the player to scan around a level and plan a route.
    Equally, it will be helpful when designing levels, to zoom around the level to
    see how a particular part of the level looks without having to get the player
    character to that part in order to see it on the screen. So, let's make the pause
    screen into a moveable viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Pause menu with moveable viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is nice and quick. We will just add a bunch of new methods to our `Viewport`
    class to change the center of focus. Then, we will call them from `InputController`.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember when we implemented the `InputController` class back in [Chapter
    6](ch15.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob,
    Beeps and Bumps*, we wrapped all the control logic in an `if(playing)` test. We
    also implemented the pause button already in the `else` clause. All we will do
    is use the left, right, jump, and shoot buttons as left, right, up, and down,
    respectively, for moving the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add these methods to the `Viewport` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Now, add these calls to the methods from the `else` clause of the `if` condition
    in the `InputController` class that we were just discussing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: On the pause screen, the player can look around and plan their route when they
    are on more complicated levels. They are probably going to need to.
  prefs: []
  type: TYPE_NORMAL
- en: Levels and game rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented so many features, but we still don't have a way to put them
    altogether into a playable game. We need to be able to travel between levels,
    and have the player state persist when we do.
  prefs: []
  type: TYPE_NORMAL
- en: Traveling between levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are going to design four levels, we want the player to be able to travel
    between them. First, let''s add code to the `switch` statement at the start of
    the `LevelManager` constructor to include all four levels that we are about to
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, we start the game by calling `loadLevel()` from the `PlatformView`
    constructor. The arguments include the name of the level and the coordinates to
    spawn the player. If you are designing your own levels, then you need to decide
    which level and coordinates to start with. If you will be following along with
    the levels I have provided, set the call to `loadLevel()` in the constructor of
    `PlatformView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `if(lm.isPlaying())` block, in the `update` method, where we set the
    viewport to center on the player each frame; add the following code to detect
    (and brutally kill) the player if he falls out of the map as well as cause the
    game to restart with three lives, zero money, and no upgrades should he run out
    of lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create a special `GameObject` class that when touched sends the
    player to a predetermined level and location. We can then strategically add these
    objects to our level designs, and they will act as the link between our levels.
    Create a new class and call it `Teleport`. If you haven't already done so, add
    the `door.png` file from `Chapter8/drawable` to the `drawable` folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our `Teleport` object will appear in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traveling between levels](img/B04322_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make a simple class to hold the data that each `Teleport` object will
    need. Create a new class called `Location` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: The actual `Teleport` class looks just like any other `GameObject` class, but
    note that it also has a member `Location` variable. We will see how the level
    design will hold the destination of the `Teleport`, the `LevelManager` class will
    initialize it, and then when the player collides with it, we can load the new
    location, sending the player off to his destination.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `Teleport` class work in a way that lets the level designer decide
    what it will do exactly, we need to add to our `LevelData` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need to add a `t` to the level design wherever we want our teleport/door,
    and an entry like the next line of code, within the constructor of the class of
    the level we are designing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can have as many `Teleport` objects as you like in a map, as
    long as the order they are defined in code matches the order they appear in the
    design. We will see exactly how this works when we look at our actual level designs
    in a minute, but the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we need to update the `LevelManager` class to load and locate our
    teleport(s). Here is the new code for `getBitmap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'New code for `getBitmapIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to keep track of our `Teleport` objects during the loading phase
    in case there is more than one. So, add a new local variable as shown in the `loadMapData`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: Finally for the `LevelManager` class, we initialize all the teleport data from
    the level design, tuck it away in the object and add it to our `gameObject ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'We are really close to being able to teleport all over the place. We need to
    detect a collision with a teleport, and then load a new level with the player
    at the desired location. This code will go in our collision detection switch block
    in the `PlatformView` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new level is loaded, the `Player`, `MachineGun`, and `Bullet` objects
    are all created from scratch. Therefore, we need to add a line to our `loadLevel`
    method to reload the current machine gun fire rate from the `PlayerState` class
    into the `MachineGun` class. Add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can work on the level designs for real.
  prefs: []
  type: TYPE_NORMAL
- en: The level designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can just copy and paste four classes from the `Chapter8/java` folder into
    your project and start playing, or you can start from the beginning and design
    your own. The levels are quite large, intricate, and tough to beat. It is not
    physically possible to print the level designs in a book or e-book in any meaningful
    way, so you will need to open up the `LevelCave`, `LevelCity`, `LevelForest`,
    and `LevelMountain` design files in order to see the detail of the four levels.
  prefs: []
  type: TYPE_NORMAL
- en: However, a brief discussion of the levels, pictures, and some screenshots, but
    not actual code from the four designs follows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the following screenshots feature the new HUD that is the last thing
    we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The cave
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cave level is where the whole thing starts. It not only features modestly
    frustrating jumps, but also plenty of fire making a fall potentially deadly.
  prefs: []
  type: TYPE_NORMAL
- en: '![The cave](img/B04322_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the player starts with a puny machine gun, only a few drones are present
    in the level. But there are two awkward guards that will require vaulting.
  prefs: []
  type: TYPE_NORMAL
- en: '![The cave](img/B04322_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The city
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The city holds vast rewards, especially in the bottom left-hand corner for coins
    and the top-left for machine gun upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: '![The city](img/B04322_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, there is a very awkward-to-jump guard on the bottom level should the
    player want to get all those stray coins and not opt for leaving them behind.
    The near vertical ascent that must be traversed up the left-hand side is likely
    to frustrate and if the player opts not to go for the machine gun upgrades, he
    will probably struggle with the double-guard just outside the door to the next
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '![The city](img/B04322_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The forest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The forest may be the overall toughest level of them all with a brutally long
    run of jumps, which are very easy to over or under jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![The forest](img/B04322_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And with in excess of a dozen drones waiting to swoop on Bob, as his pixels
    hang precariously off a platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![The forest](img/B04322_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mountains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fresh mountain air means Bob has almost made it. Not a guard or a drone
    in sight.
  prefs: []
  type: TYPE_NORMAL
- en: '![The mountains](img/B04322_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, look at that winding path of jumps, most of which will see Bob thrown
    right back to the bottom if he puts a pixel out of place.
  prefs: []
  type: TYPE_NORMAL
- en: '![The mountains](img/B04322_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to try out each of the levels without completing the grueling level(s)
    that precede it, you can of course, just start at the level and location of your
    choice. To do this, just change the call to `loadLevel()` in the `PlatformView`
    constructor to one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: The HUD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The finishing touch is to add a HUD. This code in the `draw` method of `PlatformView`
    uses the graphics from some of the existing game objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code after the last call to `drawBackground()` and before the debugging
    text is drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: I think we are done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We finished the platform game because that is all there is space for. Why not
    try to implement some or all of the following improvements and features?
  prefs: []
  type: TYPE_NORMAL
- en: Change the code in the `Player` class to make Bob gradually accelerate and decelerate
    instead of always running at full speed. Simply increment the velocity for each
    frame that the player is holding down left or right, and decrement it for each
    frame they are not.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have achieved this, add the preceding code to the collision detection
    `switch` block in the `update` method to make the player skid on snow, speed up
    on concrete, and have a different walking/landing sound effect for each tile type.
  prefs: []
  type: TYPE_NORMAL
- en: Draw a gun on Bob, and adjust the height that the `Bullet` object is spawned
    at to appear as if it is coming from the barrel of his machine gun.
  prefs: []
  type: TYPE_NORMAL
- en: Make some objects pushable. Add an `isPushable` member to `GameObject` and make
    the collision detection simply knock the object back a little. Perhaps, Bob could
    push mine carts into fire to jump over extra wide fire pits. Note that pushing
    objects that fall down to another level will be more complicated than pushing
    objects that remain at the same *y* coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Destructible tiles sound like fun. Give them a strength variable that decrements
    when hit by a bullet and is removed from `gameObjects` when it reaches zero.
  prefs: []
  type: TYPE_NORMAL
- en: Moving platforms are a staple of great platformers. Simply add waypoints to
    a tile object and add the move code to the `update` method. The challenge will
    be assigning the waypoints. You can either have them all move a set number of
    spaces left and right or up and down, or do some kind of `setTileWaypoint` method
    similar to how we scripted the `Guard` object.
  prefs: []
  type: TYPE_NORMAL
- en: Make the game more persistent by saving the total number of coins collected
    ever, remembering which levels are unlocked, and offering access to replay any
    unlocked levels from the menu screen.
  prefs: []
  type: TYPE_NORMAL
- en: Make the game easier with teleports used as waypoints. Adjust the viewport zoom
    for different screen sizes. The current zoom can be a little too low for some
    small phones.
  prefs: []
  type: TYPE_NORMAL
- en: Add timed runs for high scores, leaderboards, and achievements, and add more
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at a much smaller project, but still an interesting
    one, as we will be using OpenGL ES for super-fast, smooth drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9. Asteroids at 60 FPS with OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the final project. Over the course of the next three chapters, we
    will build an Asteroids-like game using the OpenGL ES 2 graphics API. If you are
    wondering exactly what OpenGL ES 2 is, then we will discuss the details later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will build a very simple but fun and challenging game, where we can draw
    and animate hundreds of objects at a time, even on quite old Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: With OpenGL, we will take our drawing efficiency to a much higher level, and
    with some not-too-tricky math, our movement and collision detection will be greatly
    enhanced compared to our previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a basic working OpenGL ES 2 engine
    drawing our simple but temporarily static spaceship to the screen; at 60 FPS or
    higher.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have never seen or played the '80s arcade hit (released in November 1979)
    Asteroids, why not go and check out a clone of it or a video now?
  prefs: []
  type: TYPE_NORMAL
- en: Free web game at [http://www.freeasteroids.org/](http://www.freeasteroids.org/).
  prefs: []
  type: TYPE_NORMAL
- en: On YouTube at [https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo).
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss exactly what we intend to build.
  prefs: []
  type: TYPE_NORMAL
- en: Asteroids simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game will be set in a four directional scrolling world that the player will
    be able to traverse while hunting for asteroids. The world will be enclosed in
    a rectangular border to keep the asteroids from drifting off too far, and the
    border will also serve as another hazard for the player to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: The game controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will reuse our `InputController` class with a few simple modifications and
    can even keep the same button layout. As we will see, however, we will draw the
    buttons on screen in a very different manner to our retro platformer. Also, instead
    of walking left and right, the player will rotate the ship left and right through
    360 degrees. The jump button will become a thrust toggle switch to turn on and
    off forward motion, and the shoot button will remain just that. We will also have
    the pause button in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an asteroid hits the border, it will bounce back into the game world. If
    the player hits the border, a life will be lost and the ship will respawn in the
    center of the screen. If an asteroid hits the ship this will be fatal too.
  prefs: []
  type: TYPE_NORMAL
- en: The player will start with three lives and must clear the asteroids simulator
    of all asteroids. The HUD will show a tally of the remaining asteroids and lives.
    If the player clears all the asteroids, then the next wave will start with more
    than the last. They will also move a little faster. Each wave cleared will be
    rewarded with an extra life.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement these rules as we proceed through the project.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL ES 2 is the second major version of the **Open Graphics Library** (**OpenGL**)
    for embedded systems. It is the mobile incarnation of OpenGL for desktop systems.
  prefs: []
  type: TYPE_NORMAL
- en: Why use it and how does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL runs as a native process, not on the Dalvik virtual machine like the
    rest of our Java. This is one of the reasons it is super fast. The OpenGL ES API
    takes away all of the complexity of interacting with native code, and OpenGL itself
    also provides very efficient and fast algorithms within its native code base.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of OpenGL was completed in 1992\. The point is that even back
    then OpenGL used arguably the most efficient code and algorithms to draw graphics.
    Now, more than 20 years on, it has been continually refined and improved as well
    as adapted to work with the latest graphics hardware, both mobile and desktop.
    All the mobile GPU manufacturers specifically design their hardware to be compatible
    with the latest version of OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to improve on OpenGL ES is, therefore, probably a fool's errand.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is another viable Graphics API option when developing exclusively for
    Windows devices called DirectX.
  prefs: []
  type: TYPE_NORMAL
- en: What is neat about Version 2?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first version of OpenGL ES certainly impressed at the time. I remember almost
    falling off my chair when I first played a 3D shooter on a phone! Now this is
    of course commonplace. However, compared to the desktop version of OpenGL, OpenGL
    ES 1 had a major drawback.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 1 had, what is known as, a fixed function pipeline. The geometry to
    draw went into the GPU and it was drawn, but any further manipulation of individual
    pixels needed to take place before OpenGL ES took over the drawing of a frame
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with OpenGL ES 2, we have access to what is called a programmable pipeline.
    That is, we can send our graphics off to be drawn, but we can also write code
    that runs on the GPU that is capable of manipulating each and every pixel independently.
    This is a very powerful feature, although we will not get to explore it in much
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: This extra code that runs on the GPU is called a **shader** program. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually called a **fragment shader**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Actually, we can do better than even pixel manipulation. A fragment is not
    necessarily a pixel. It depends on the hardware and the specific nature of the
    graphics being processed. It can be more than one pixel or a sub-pixel: one light
    of several that makes up a pixel in the screen hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of OpenGL ES 2 for simple games like this is that you must
    provide at least one vertex and one fragment shader, even if you are not going
    to do a whole lot with them. As we will see, however, this is not very difficult.
    Although we will not be exploring shaders in any depth, we will write some shader
    code using **GL Shader Language** (**GLSL**) and get a glimpse at the possibilities
    they offer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the power of programmable graphics pipelines and shaders is just too exciting
    to leave for another day, then I can highly recommend *GLSL Essentials* by Jacobo
    Rodríguez.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
  prefs: []
  type: TYPE_NORMAL
- en: The book explores OpenGL shaders on the desktop and is highly accessible to
    any reader with basic programming knowledge and a willingness to learn a different
    language (GLSL), yet one with some syntax similarities to Java.
  prefs: []
  type: TYPE_NORMAL
- en: How will we be using OpenGL ES 2?
  prefs: []
  type: TYPE_NORMAL
- en: How we will use OpenGL ES 2?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and also combine these elements
    to make the complex graphics that we see in today's modern mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some of each type of element (points, lines, and triangles) that
    are collectively referred to as primitives.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be using textures on this project. Fortunately, the appearance of
    untextured primitives is appropriate for building our Asteroids-like game.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to primitives, Open GL uses matrices. **Matrices** are a method
    and structure for performing arithmetic. This arithmetic can range from extremely
    simple high-school level calculations to move (translate) a coordinate or it can
    be quite complex to perform more advanced mathematics to convert our game world
    coordinates into OpenGL screen coordinates that the GPU can use.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that both the matrices and methods to use them are entirely provided
    by the OpenGL API. This means that we just have to learn what methods do which
    graphical manipulation and do not have to concern ourselves with the potentially
    complex math that goes on behind the scenes (on the GPU).
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn about shaders, primitives, and matrices in OpenGL is to
    go ahead and start using them.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we start off with our `Activity` class, which as before is the entry point
    into our game. Create a new project and in the **Application Name** field enter
    `C9 Asteroids`. Choose **Phones and tablets**, then **Blank Activity** when prompted.
    In the **Activity Name** field type `AsteroidsActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously you don't have to follow my exact naming choices but just remember
    to make the minor alterations in code to reflect your own naming choices.
  prefs: []
  type: TYPE_NORMAL
- en: You can delete `activity_asteroids.xml` from the `layout` folder. You can also
    delete all the code within the `AsteroidsActivity.java` file. Just leave the package
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Locking the layout to landscape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we did for the previous two projects, we will make sure the game runs
    in landscape mode only. We will make our `AndroidManifest.xml` file, force our
    `AsteroidsActivity` class to run with a full screen, and lock it to a landscape
    orientation. Let''s make these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately, type or copy and paste these two lines to make `PlatformActivity`
    run in full screen and lock it in the landscape orientation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can move on to implementing our Asteroids simulator game with OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we have our familiar `Activity` class. The only thing that is
    new here is the type of our view class. We declare a member called `asteroidsView`
    of type `GLSurfaceView`. This is the class that will provide us with easy access
    to OpenGL. We will see exactly how very soon. Note that all we do is initialize
    `GLSurfaceView` by passing in the `Activity` context and the screen resolution
    that we obtain in the usual manner. Implement the `AsteroidsActivity` class as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will get to see some OpenGL code.
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will implement the `GLSurfaceView` class. Actually, this isn't where
    the real action will take place but it does allow us to attach an OpenGL renderer.
    This is a class that implements the `Renderer` interface. As well as in this critical
    `Renderer`, the `GLSurfaceView` class enables us to override the `onTouchListener`
    method that will allow us to detect player input in the same way that `SurfaceView`
    did in the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android Studio does not auto-import or even suggest all of the OpenGL imports
    required. Therefore, I included all of the imports for some classes in the code
    listings. In addition, you will note that sometimes we use static imports. This
    will make the code more readable too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code that follows, we declare and initialize a new object of type `GameManager`
    that we will implement soon. We set the OpenGL version to two by calling `setEGLContextClientVersion(2)`,
    and we set our vital renderer object by calling `setRenderer()` and passing in
    our `GameManager` object. Create a new class called `AsteroidsView` and implement
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can take a look at what is involved in our `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: A class to manage our game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class will control things like the level the player is on, the number of
    lives, as well as things like the overall size of the game world. It will evolve
    a little as the project progresses, but it will remain quite simple in comparison
    to the combined depth of the LevelManager and PlayerState classes from the previous
    project, although it effectively replaces both.
  prefs: []
  type: TYPE_NORMAL
- en: In the code that follows, we declare `int` members to hold the width and height
    of the game world; we can make this much bigger or smaller as we see fit. We keep
    track of the games status with the Boolean `playing`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GameManager` class also needs to know the height and width of the screen
    in pixels, and this information is passed in to the constructor when the object
    is initialized back in the `AsteroidsView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the `metresToShowX` and `metresToShowY` member variables. These probably
    sound familiar from our `Viewport` class from the last project. These variables
    will be used for exactly the same thing: defining the current viewable area of
    the game world. This time, however, OpenGL will take care of what objects to clip
    before drawing (using a matrix). We will soon see where this happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that although OpenGL takes care of clipping and scaling the area of the
    game world that we want to show, it doesn't have any effect on which objects are
    updated each frame. As we will see, however, this is just what we want for this
    game because we want all our objects to update themselves each frame, even when
    they are offscreen. Therefore, no `Viewport` class is necessary for this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we want a convenient way to pause and unpause the game, and we provide
    this functionality with the `switchPlayingStatus` method. Create a new class called
    `GameManager` and implement it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: We can now take our first look at these all powerful shaders and how we will
    manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing simple shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An application can have many shaders. We can then attach different shaders to
    different game objects to create the desired effects.
  prefs: []
  type: TYPE_NORMAL
- en: We will only have one vertex and one fragment shader in this game. However,
    when you see how to attach a shader to primitives, it will be plain that it is
    simple to have more shaders.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need the code for the shader that will be executed in the GPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we need to compile that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to link together the two compiled shaders into a GL program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we implement this next simple class, we will see how we can bundle up this
    functionality into a single method call, which can be made by an object from our
    game and have the ready-to-run GL program returned to the game object. When we
    build our `GameObject` class later in the chapter, we will see how we use this
    GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement the necessary three steps in a new class. Create
    a new class and call it `GLManager`. Add the static imports as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add some public static final member variables that we can use
    in our `GameObject` class later in the chapter. Although we will see exactly how
    they work when we get around to using them, here is a quick preliminary explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '`COPONENTS_PER_VERTEX` is the number of values that will be used to represent
    a single vertex (point) in our primitives that will make up our game objects.
    As you can see, we initialize this to three coordinates: *x*, *y*, and *z*.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have `FLOAT_SIZE`, which is initialized to `4`. This is the number of
    bytes in a Java float. As we will see soon, OpenGL likes all its primitives passed
    into it in the form of a `ByteBuffer`. We need to make sure we are precise about
    where in the `ByteBuffer` each piece of information is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare `STRIDE` and initialize it to `COMPONENTS_PER_VERTEX * FLOAT_SIZE`.
    As OpenGL uses the float type to hold virtually all of the data it works with,
    `STRIDE` now equals the size in bytes of the data that represents a single vertex
    of an object. Go ahead and add these members at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be utilized. Here, we declare and initialize some strings that
    we can use to refer to these variables more cleanly in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion of these types is beyond the scope of this book, but simply explained
    they will represent a matrix (`u_matrix`), a location (`a_position`), and a color
    (`u_Color`). We will see examples of the actual GLSL types these variables are
    in our shader code very soon.
  prefs: []
  type: TYPE_NORMAL
- en: After the strings, we declare three `int` types. These three public static (but
    not final) members will be used to store the location of there namesake types
    within our shaders. This allows us to manipulate the values within the shader
    program before we give OpenGL the final instruction to draw our primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: At last, we come to our GLSL code that is a vertex shader packed up in a string.
    Note that we declare a variable called `u_Matrix` of type uniform `mat4` and `a_Position`
    of type attribute `vec4`. We will see in our `GameObject` class later how to get
    the locations of these variables to enable us to pass in values for them from
    our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line in the code that starts with `void main()` is were the actual shader
    code executes from. Note that `gl_position` is assigned the value of the product
    of the two variables we just declared. Also `gl_PointSize` is assigned the value
    of `3.0`. This will be the size we draw all our point primitives. Enter the code
    for the vertex shader right after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will implement the fragment shader. A few things are happening here.
    First, the line precision `mediump` float tells OpenGL to draw with medium precision
    and therefore medium speed. Then we can see our variable `u_Color` being declared
    to type uniform `vec4`. We will see how we can pass a `color` value to this variable
    in the `GameObject` class soon.
  prefs: []
  type: TYPE_NORMAL
- en: When execution begins at `void main()`, we simply assign `u_Color` to `gl_FragColor`.
    So, whatever color is assigned to `u_Colour`, all the fragments will be that color.
    Just after the fragment shader, we declare an `int` called `program` that will
    act as a handle to our GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the fragment shader right after the previous block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a getter method that returns a handle to the GL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: This next method may look complex, but all it does is return a compiled and
    linked program to the caller. It does so by calling the OpenGL's `linkProgram`
    method with `compileVertexShader()` and `compileFragmentShader()` as arguments.
    Next, we see these two new methods and that all they need to do is call our method
    `compileShader()` with the OpenGL constant representing the type of shader and
    the appropriate string that holds the matching shader GLSL code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the three methods that we have just discussed into the `GLManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see what happens when our methods called `compileShader()`. First, we
    create a handle to a shader based on the `type` parameter. Then, we pass in that
    handle and the code to `glShaderSource()`. Finally, we compile the shader with
    `glCompileShader()` and return a handle to the calling method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can see the final step in the process. We create an empty program with
    `glCreateProgram()`. Then we attach each of the compiled shaders in turn with
    `glAttachShader()`, and finally link them into a program we can actually use with
    `glLinkProgram()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Note that we created a program and we have access to it via its handle and the
    `getProgram` method. We also have access to all those public static members we
    created, so we will be able to tinker with the variables in the shader programs
    from our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: The game's main loop – the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will see where the real meat of our code will go. Create a new class
    and call it `AsteroidsRenderer`. This is the class that we attached as our renderer
    to the `GLSurfaceView`. Add the import statements as follows, noting that some
    of them are static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Now we will build the class. The first thing to note that we have mentioned
    before is that the class implements `Renderer`, so we need to override three methods.
    They are `onSurfaceCreated()`, `onSurfaceChanged()`, and `onDrawFrame()`. Also,
    into this class, we will initially add a constructor to get everything set up,
    a `createObjects` method where we will eventually initialize all our game objects,
    an `update` method were we will update all our objects each frame, and a `draw`
    method were we will draw all our objects each frame.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore and explain each method as we implement it, and we will also
    see how our methods fit in to the OpenGL renderer system, which dictates the flow
    of this class.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we have some member variables that are worth looking at quite
    closely.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean debugging will be used to toggle output to the console on and off.
    The `frameCounter`, `averageFPS`, and `fps` variables will not only be used for
    checking what frame rates we are reaching but also for passing to our game objects
    that will update themselves based on the elapsed time each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Our first really interesting variable is the float array `viewportMatrix`. As
    the name suggests, it will hold a matrix that OpenGL can use to calculate the
    viewport into our game world.
  prefs: []
  type: TYPE_NORMAL
- en: We have a `GameManager` to hold a reference to the `GameManager` object, that
    `AsteroidsView` passed into this class's constructor. Finally, we have two `PointF`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will initialize the `PointF` objects in the constructor and use them for
    a few different things to avoid dereferencing any objects in the main game loop.
    When the garbage collector starts cleaning up discarded objects, even OpenGL will
    slow down. Avoiding summoning the garbage collector will be a goal for the entire
    game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the member variables at the top of the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our constructor, where we initialize our `GameManager` reference from
    the parameter and create our two handy `PointF` objects ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: This is the first overridden method. It is called every time a `GLSurfaceView`
    class with attached renderer is created. We call `glClearColor()` to set which
    color OpenGL will use each time it clears the screen. We then build our shader
    program using our `GLManager.buildProgram()` method and call our `createObjects`
    method that we will code soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: This next overridden method is called once after `onSurfaceCreated()` and any
    time the screen orientation changes. Here, we call the `glViewport()` method to
    tell OpenGL the pixel coordinates to map the OpenGL coordinate system onto.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL coordinate system is very different from the pixel coordinates we
    are used to deal with in the previous two projects. The center of the screen is
    0,0, the left and bottom are -1, and the top and right are 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![The game''s main loop – the renderer](img/B04322_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding situation is further complicated by the fact that most screens
    are not square, yet the range -1 to 1 must represent both *x* and *y* axes. Fortunately,
    our `glViewport()` has dealt with this for us.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we see in this method is calling the `orthoM` method with our
    `viewportMatrix` as the first parameter. OpenGL will now prepare `viewportMatrix`
    for use within OpenGL itself. The method `orthoM()` creates a matrix to convert
    coordinates into an orthographic view. If our coordinates are three-dimensional,
    it will have the effect of making all the objects appear the same distance away.
    As we are making a two-dimensional game, this is also suitable for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the `onSurfaceChanged` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `createObjects` method and, as you can see, we create an object
    of type `SpaceShip` and pass in the map height and width to the constructor. We
    will build the `SpaceShip` class and its parent class `GameObject` later in this
    chapter. Enter the `createObjects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: This is the overridden `onDrawFrame` method. It is called continuously by the
    system. We can control when this is called by setting a render mode when we attach
    the `AsteroidsRenderer` to the view but the default OpenGL controlled continuous
    calling is exactly what we need.
  prefs: []
  type: TYPE_NORMAL
- en: We set `startFrameTime` to whatever the current system time is. Then, if `isPlaying()`
    returns `true`, we call our soon-to-be-implemented `update` method. Then, we call
    `draw()`, which will tell all of our objects to draw themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We then update `timeThisFrame` and `fps` optionally outputting the average frames
    per second, every 100 frames, if we are debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know that OpenGL will call `onDrawFrame()` up to hundreds of times per
    second. We will conditionally call our `update` method each time as well as call
    our `draw` method. We have effectively implemented our game loop apart from the
    actual `draw` and update methods themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `onDrawFrame` method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `update` method, leave an empty body for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Now, we come to our `draw` method, which is called once per frame from the `onDrawFrame`
    method. Here, we load up the ships current location into one of our handy `PointF`
    objects. Clearly, as we haven't implemented our `SpaceShip` class yet, this method
    call will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do in `draw()` is quite interesting. We modify our `viewportMatrix`
    based on the current location in the game world and the values assigned to `metresToShowX`
    and `metresToShowY`. Simply, we are centering on wherever the ship is and extending
    out by half the distance we wish to show in all four directions. Remember that,
    this happens in every frame, so our viewport will constantly follow the player
    ship.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `glClear()` to clear the screen with the color we set in `onSurfaceCreated()`.
    The last thing we do in `draw()` is call a `draw` method on our `SpaceShip` object.
    This implies quite a fundamental design change from both of our previous games.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned this already, but here we can see it in action: each object will
    draw itself. Also, notice that we pass in our newly configured `viewportMatrix`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code for the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can build our `GameObject` super class, closely followed by its first
    child, `SpaceShip`. We will see how these objects will manage to use OpenGL to
    draw themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Building an OpenGL-friendly, GameObject super class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive straight into the code. As we will see, this `GameObject` will have
    a lot in common with the `GameObject` class from the previous project. The most
    significant difference will be that this latest `GameObject` will of course draw
    itself using a handle to the GL program, primitive (vertex) data from a child
    class, and the viewport matrix contained in `viewportMatrix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `GameObject`, and enter these import statements,
    noting again that that some of them are static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of member variables, many are self-explanatory and commented
    just to refresh our memories, but there are some totally new ones as well.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have an `enum` to represent each type of `GameObject` we will
    create. The reason for this is we will draw some objects as points, some as lines,
    and one as a triangle. The way that we use OpenGL is consistent between different
    types of primitive; hence, it is why we have bundled the code into this parent
    class. However, the final call to draw the primitive varies dependent on the type
    of primitive. We can use the `type` variable in a `switch` statement to execute
    the correct type of a `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an `int numElements` and `numVertices` that holds the number of
    points that make up any given `GameObject`. These will be set from the child class
    as we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: We have another float array called `modelVertices`, which will hold all the
    vertices that make up a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the first batch of member variables in the `GameObject` class and take
    a look at the comments to refresh your memory or make clear what the various members
    will eventually be used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add another batch of member variables. First, and most notably,
    we have a `FloatBuffer` called `vertices`. As we know, OpenGL executes in native
    code and `FloatBuffers` are how it likes to consume its data. We will see how
    we pack all our vertices into this `FloatBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use all the public static members from our `GLManager` class to
    help us get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the second most interesting new member where OpenGL is concerned is
    we have another three float arrays called `modelMatrix`, `viewportModelMatrix`,
    and `rotateViewportModelMatrix`. These will be instrumental in helping OpenGL
    to draw the `GameObject` class exactly as required. We will examine exactly how
    they are initialized and used when we get to the `draw` method of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a bunch of members that hold different angles and rotation rates.
    How we use and update these in order to inform OpenGL of the orientation of our
    objects, we will see soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: We now implement the constructor. First, we check if we have previously compiled
    the shaders, because we only need to do it once. If we haven't, this is what happens
    inside the `if(glProgarm == -1)` block.
  prefs: []
  type: TYPE_NORMAL
- en: We call `setGLProgram()` followed by `glUseProgram()` with `glProgram` as the
    argument. That is all we have to do, `GLManager` does the rest and our OpenGL
    program is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on, however, we save the locations of our key shader variables
    by calling the respective methods (`glGetUniformLocation()` and `glGetAttrtibuteLocation`)
    to get their locations within our GL program. We will see in the `draw` method
    of this class how we use those locations to manipulate values within the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we set `isActive` to `true`. Enter this method into the `GameObject`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a few getters and setters including `getWorldLocation()`, which
    we called from the `draw` method in `AsteroidsRenderer` and `setGLProgram()`.
    This uses the `GLManager` class's static method `getGLProgram()` to get the handle
    to our GL program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter all these methods into the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: The next method, `setVertices()` is a vital step in preparing an object to be
    drawn by OpenGL. In each of our child classes, we will build an array of float
    types to represent the vertices that make up the shape of the game object. Each
    game object will obviously be different in shape, but the `setVertices` method
    does not need to appreciate the difference, it just needs the data.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the next block of code, the method receives a float array as
    a parameter. It then stores the number of elements that is equal to the length
    of the array in `numElements`. Note that the number of elements is different from
    the number of vertices the elements represent. It takes three elements (*x*, *y*,
    and *z*) to make one vertex. Therefore, we can store into `numVertices` the correct
    value by dividing `numElements` by `ELEMENTS_PER_VERTEX`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can actually initialize up our `ByteBuffer` by calling `allocateDirect()`
    and passing in our newly initialized variables along with `FLOAT_SIZE`. The `ByteOrder.nativeOrder`
    method simply detects if the particular system's endianness, and `asFloatBuffer()`
    tells `ByteBuffer` the type of data that will stored. We can now store our array
    of vertices into our vertices `ByteBuffer` by calling `vertices.put(modelVertices)`.
    This data is now ready to be passed to OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to learn more about endianness, take a look at this Wikipedia article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Endianness](http://en.wikipedia.org/wiki/Endianness)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `setVertices` method into the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Now we get to see how we actually draw the contents of our `ByteBuffer`. At
    a glance, the following code may look complex, but when we discuss the nature
    of the data in our `ByteBuffer` and the steps that OpenGL goes through to draw
    this data, we will see that it is actually quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: As we have not written the code for our first `GameObject` child class, there
    is one key thing to point out. The vertices that represent the shape of a game
    object are zero based on its own center.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenGL coordinate system has **0,0** as its center but, to make it clear,
    this is not related. This is called model space. The next image is a representation
    of our spaceship, in model space, that we will soon create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an OpenGL-friendly, GameObject super class](img/B04322_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is this data that is contained within our `ByteBuffer`. This data takes no
    account of orientation (is the ship or asteroid rotated), it takes no account
    of its position in the game world and, as a reminder, it is totally unrelated
    to the OpenGL coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, before we draw our `ByteBuffer`, we need to convert this data, or,
    more accurately, we need to prepare an appropriate matrix, which we will pass
    into OpenGL with the data so that OpenGL will know how to use or convert the data.
  prefs: []
  type: TYPE_NORMAL
- en: I have split the `draw` method up into six chunks to talk about how we do this.
    Note that our `viewPort` matrix is prepared in our `AsteroidsRenderer` class's
    `draw` method, which is centered upon the location of the ship and based around
    the proportion of game world we want to show and is passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we call `glUseProgram()` and pass in the handle to our program. Then
    we set the internal pointer of our `ByteBuffer` to the start with `vertices.position(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `glVertexAttributePointer` method uses our `aPositionLocation` variable
    along with our `GLManager` static constants and of course the `vertices` `ByteBuffer`
    to associate our vertices with the `aPosition` variable in the vertex shader.
    Finally, for this chunk of code, we tell OpenGL to enable the attribute array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Now, we put our matrices to work. We create an identity matrix out of our `modelMatrix`
    array by calling `setIndentityM()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will see, we are going to be using and combining quite a lot of matrices.
    An identity matrix acts as a starting point or container on which we can build
    a matrix, which combines all the transformations that we need to occur. A very
    simple but not entirely accurate way of thinking about an identity matrix is that
    it is like the number 1\. When you multiply by an identity matrix, it doesn't
    cause any alteration to the other part of the sum. However, the answer is correct
    for moving on to the next part of the equation. If this is annoying you and you
    want to know more, take a look at these really quick tutorials on matrices and
    the identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pass our new `modelMatrix` into the `translateM` method. Translate
    is math speak for move. Look closely at the arguments passed into `translateM()`.
    We are passing in the *x* any *y* world locations of the object. This is how OpenGL
    knows where the object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: We know that OpenGL has a matrix to translate our object to its world location.
    It also has a `ByteBuffer` class with the model space coordinates, but how does
    it convert translated model space coordinates to our viewport drawn using OpenGL
    coordinate system?
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the viewport matrix, which is modified by each frame and passed into
    this method. All we need to do is multiply `viewportMatrix` and the recently translated
    `modelMatrix` together using `multiplyMM()`. This method creates the combined
    or multiplied matrix and stores the result in `viewportModelMatrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done creating our matrix. The only other possible distortion that
    OpenGL will need to make to the vertices in the `ByteBuffer` is to rotate them
    to the `facingAngle` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a rotation matrix appropriate to the current object's facing
    angle and storing the result back in `modelMatrix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we combine or multiply the newly rotated `modelMatrix` with our `viewportModelMatrix`
    and store the result in `rotateViewportModelMatrix`. This is our final matrix
    that we will pass into the OpenGL system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Now we pass in the matrix using the `glUniformMatrix4fv()` method and use the
    `uMatrixLocation` variable (which is the location of the matrix-related variable
    in the vertex shader) and our final matrix in the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We also choose the color by calling `glUniform4f()` with the `uColorLocation`
    and an RGBT (Red, Green, Blue, Transparency) value. All values are set to 1.0,
    so the fragment shader will draw white.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we switch based on the object type and draw either points, lines,
    or triangle primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the fundamentals of our `GameObject` class, we can make a class
    to represent our spaceship and draw it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class is nice and simple, although it will evolve with the project. The
    constructor receives the starting location within the game world. We set the ship's
    type and world location using the methods from the `GameObject` class, and we
    set a width and height.
  prefs: []
  type: TYPE_NORMAL
- en: We declare and initialize some variables to simplify the initialization of the
    model space coordinates, and then we go ahead and initialize a float array with
    three vertices that represent the triangle that is our ship. Note that the values
    are based around a center of *x = 0* and *y = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we do next is, call `setVertices()`, and `GameObject` will prepare the
    `ByteBuffer` ready for OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can see the fruits of our labor.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing at 60 + FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In three simple steps, we will be able to glimpse our spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `SpaceShip` object to the `GameManager` member variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a call to the new `SpaceShip()` to the `createObjects` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the call to draw the spaceship in each frame in the `draw` method of `AsteroidsRenderer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the game and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing at 60 + FPS](img/B04322_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not exactly impressive visuals, but it is running between 67 and 212 frames
    per second in debug mode while outputting to the console on an ageing Samsung
    Galaxy S2 phone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing at 60 + FPS](img/B04322_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will be our aim throughout the project to add hundreds of objects and keep
    the frames per second over 60.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the book's reviewers reported frame rates in excess of 1000 per second
    on a Nexus 5! It will therefore be worth considering a maximum frame rate locking
    strategy to save battery life if you were planning to release this to the Google
    Play store.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a drawing system was a little bit long-winded. However, now that
    it is done, we can churn out new objects much more easily. All we have to do is
    define the type and the vertices, then we can draw them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: It is because of this ground work that the next chapter will be much more visually
    rewarding. Next, we will create blinking stars, a game world border, spinning
    and moving asteroids, whizzing bullets, and a HUD, as well as add full controls
    and motion to the spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10. Move and Draw with OpenGL ES 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement all the graphics, game play, and movement.
    In just over 30 pages, we will complete everything except collision detection.
    We can achieve this much because of the groundwork we laid in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will draw a static border around our game world, then some blinking
    stars, followed by adding movement to our spaceship as well as some bullets. After
    that, we will quickly add controls for the player and we will be whizzing around
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will also make some noise by implementing our `SoundManager` class with some
    new sound FX.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we will add randomly shaped asteroids that move across the
    world while spinning around at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can add a HUD to highlight the touchable areas of the screen and provide
    a tally of the remaining player lives and asteroids that need destroying before
    the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a static game border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this simple class, we define four sets of points that will represent four
    lines. Unsurprisingly, the `GameObject` class will draw the border using these
    points as the end points of lines.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, which is the entirety of the class, we set the type by calling
    `setType()`, the world location as the center of the map, and `height` and `width`
    as the height and width of the entire map.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define the four lines in a float array and call `setVertices()` to
    prepare a `FloatBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Border` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then declare a `Border` object as a member of `GameManager` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in the `createObjects` method of `AsteroidsRenderer` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can draw our border by adding a line of code into the `draw` method
    of the `AsteroidsRendrer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the game. If you want to actually see the border, you can change
    the location to which we initialize the ship to somewhere near the border. Remember
    that in the `draw` method, we center the viewport around the ship. To see the
    border, change this one line in the `SpaceShip` class to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Run the game to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a static game border](img/B043422_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Change it back to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will fill up the area within the border with stars.
  prefs: []
  type: TYPE_NORMAL
- en: Twinkling stars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will get a bit more mobile than a static border. Here, we will add an `update`
    method to a simple `Star` class, which can be used to randomly switch the star
    on and off.
  prefs: []
  type: TYPE_NORMAL
- en: We set the type as `normal` and create a random location for the star within
    the confines of the border and call `setWorldLocation()` as always.
  prefs: []
  type: TYPE_NORMAL
- en: Stars will be drawn as points, so our vertex array will simply contain one vertex
    at model space 0,0,0\. Then, we call `setVertices()` as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `Star`, and enter the discussed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Here is our `Star` class's `update` method. As we can see, there is a one in
    a 1000 chance in each frame that the star will switch its status. For more blinking,
    use a lower seed, and for less blinking, use a higher seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare a `Star` array, as a member of `GameManager`, and an extra
    `int` variable to control how many stars we want to draw, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the array of `Star` objects in the `createObjects` method of `AsteroidsRenderer`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can draw our stars by adding these lines of code into the `draw` method
    of the `AsteroidsRenderer` class. Note that we draw the stars first as they are
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, to make them blink, we call their `update` method from the `AsteroidsRenderer`
    class''s `update` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twinkling stars](img/B043422_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bringing the spaceship to life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to add a bit more functionality to our `GameObject` class. We
    do so in `GameObject` because bullets and asteroids share a surprising amount
    of similarities with a spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a bunch of getters and setters to get and set the rotation rate, traveling
    angle, and facing angle. Add the following methods to the `GameObject` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add a `move` method, which adjusts the *x* and *y* coordinates as well
    as the `facingAngle` of the object based on the current frames per second. Add
    the `move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our additions to the `GameObject` class, add these getters and
    setters for velocity, speed, and maximum speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make some additions to the `SpaceShip` class. Add these three members
    to the `SpaceShip` class to control if the player''s ship is turning or moving
    forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `SpaceShip` constructor, let''s set the maximum speed of the
    ship. I have highlighted the new line of code among the existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Next, in the `SpaceShip` class, we add an `update` method that, first of all,
    increases and decreases the speed based on whether `isThrusting` is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Then, we set the *x* and *y* velocity based on the angle, which way the ship
    is facing, and the speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use speed multiplied by the cosine of the angle the ship is facing to set
    the velocity on the *x* axis. This works because the cosine function is a perfect
    variant that will return a value of -1 or 1, when the ship is facing exactly left
    or right, respectively; the variant returns a precise value of 0 when the ship
    is pointing exactly up or down. It also returns fine values in between as well.
    The sine of the angle works in exactly the same way on the *y* axis. The slightly
    convoluted looking code is because we need to convert our angle to radians and
    we must add 90 degrees to our `facingAngle` because 0 degrees is pointing to three
    o''clock. This fact is not conducive to using it on an *x*, *y* plane the way
    we have it, so we modify it by 90 degrees and the ship moves as expected. For
    more information about how this works check out this tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Now, we set the rotation rate based on whether the player is turning left or
    right. Finally, we call `move()` to put all the updates into effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to add a `pullTrigger` method, which for now, we just return `true`.
    We also provide three methods for our future `InputController` to call and trigger
    the `update` method to make its various changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'We are already drawing the ship in each frame, but we need to add one line
    of code in the `AsteroidsRenderer` class''s `update` method. Add this line of
    code to call the `SpaceShip` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we can't actually move until we add the player controls. Let's quickly
    add some bullets to the game. Then, we will add sound and controls so that we
    can see and hear the cool new features we added.
  prefs: []
  type: TYPE_NORMAL
- en: Rapid fire bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I've been addicted to games since Pong in the '70s, and remember my delight
    when a friend actually had a Space Invaders machine in his home for about a week.
    Although what really made asteroids so much better than Space Invaders, was how
    quickly you could shoot. In that tradition, we will make a satisfying, rapid fire
    stream of bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Bullet`, which has one vertex and will be drawn with
    a point. Note that we also declare and initialize an `inFlight` Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the `shoot` method that sets the `facingAngle` of the bullet to
    that of the ship. This will cause the bullet to move in the direction the ship
    was facing at the time the fire button was pressed. We also set `inFlight` to
    true and see how this is used in the `update` method. Finally, we set the speed
    to `300`.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a `resetBullet` method, which sets the bullet inside the ship and
    cancels its velocity and speed. This gives us a clue as to how we will implement
    our bullets. The bullets will sit invisibly inside the ship until they are fired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Now, we move the bullet based on its `facingAngle` and speed, only if `inFlight`
    is true. Otherwise, we keep the bullet inside the ship. Then, we call `move()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a `Bullet` class, we can declare an array, to hold a bunch of objects
    of this type in our `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Initialize them in `createObjects()` right after our stars from the last section
    in `AsteroidsRenderer`. Note how we initialize their location in the game world
    as the center of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: Update them in the `update` method, again right after our blinking stars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Draw them in the `draw` method, once more, after the stars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: The bullets are now ready to be fired!
  prefs: []
  type: TYPE_NORMAL
- en: We will add a `SoundManager` and `InputController` class, then we can see our
    ship and its rapid fire gun in action.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing existing classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's quickly add our `SoundManager` and `InputController` classes to this project
    because they only need a little tweak to accommodate our needs here too.
  prefs: []
  type: TYPE_NORMAL
- en: Add a member for a `SoundManager` and an `InputController` object in both the
    `AsteroidsView` and `AsteroidsRenderer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the new objects in the `onCreate` method of the `AsteroidsView`
    class and call the `loadSound` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Also in `AsteroidsView`, add an extra two arguments to the call to the `AsteroidsRenderer`
    constructor to pass in references to the `SoundManager` and `InputController`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `AsteroidsRenderer` constructor add the two extra parameters and
    initialize the two new members like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: You will have errors in your IDE until we add the two classes. We will do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SoundManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SoundManager` class works exactly the same way as it did with the previous
    project, so there is nothing new to explain here.
  prefs: []
  type: TYPE_NORMAL
- en: Add all the sound files from the download bundle `Chapter10/assets` folder to
    the assets folder of your project. As in the last two projects, you may need to
    create the assets folder in the `.../app/src/main` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, you can use the sound effects provided or create your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new class to the project called `SoundManager`. Note that the functionality
    of the class is identical to the last project, but the code is different simply
    because of the names of the sound files and their related variables. Add this
    code to the `SoundManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to call `playSound()` from anywhere we have a reference to
    our new class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the InputController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This works the same way as it did in the last project, except that we call the
    appropriate `PlayerShip` methods instead of Bob's. Furthermore, we will not be
    moving the viewport while paused, so it is not necessary to handle the screen
    touches differently when the game is paused; making this `InputController` a little
    simpler and shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `onTouchEvent` method to the `AsteroidsView` class to pass responsibility
    for handling touches to `InputController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Add a new class called `InputController`, and add the following code which is
    straightforward, except for the way that we handle the player firing a shot.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a member `int currentBullet` that keeps track of which bullet from
    our soon-to-be-declared array we are going to shoot next. Then, we can count the
    bullets out when the fire button is pressed and go back to the first bullet, right
    after the last one in the array is fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `InputController` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: Let's bundle all our buttons together in a list and make them available with
    a public method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Next, we handle the input as we have before, except we call our `Ship` class's
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can fly around and loose off a few space rounds! Of course, you will
    have to estimate the screen positions until we get our HUD drawn later in this
    chapter. Don't forget that the player needs to tap the pause button (top-right)
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that at the moment, we don't use the `resetBullet` method, and that once
    you have shot your twenty bullets, you will not be able to shoot any more. We
    can do a quick check to see if the bullet was at a location outside the border
    and then call `resetBullet`, but we will handle this fully, in conjunction with
    all the collision detection, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can't have an asteroids game without any asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing and moving the asteroids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At last, we will add our cool, spinning asteroids. First, we will look at the
    constructor that is fairly similar to the other game object constructors, except
    that we set the world location randomly. However, take a little extra care not
    to spawn them in the center of the map, where the spaceship starts the game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Asteroid` and add this constructor. Note that we
    have not defined any vertices. We delegate this to the `generatePoints` method
    that we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Our update method simply calculates the velocity based on speed and traveling
    angle as we did for the `SpaceShip` class. It then calls `move()` in the usual
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the `generatePoints` method, which will create a randomly shaped
    asteroid. Simply explained, each asteroid will have six vertices. Each vertex
    has a randomly generated position but within fairly strict limits, so we don't
    get any overlapping lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have our six points that we use to build our array of floats that represent
    the vertices. Finally, we call `setVertices()` to create our `ByteBuffer`. Note
    that the asteroids will be drawn as a series of lines, which is why the last vertex
    in the array is the same as the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Now as you have probably come to expect, we add an array to `GameManager` to
    hold all our asteroids. At the same time, we will declare some variables which
    will hold the level the player is currently on, as well as the starting (base)
    number of asteroids. Then soon, when we initialize all our asteroids, we will
    see how we will determine the number of asteroids that will need to be destroyed
    to clear a level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the array in the `GameManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the objects themselves in the `createObjects` method using our previously
    declared variables to determine the number of asteroids based on the current level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Update them in the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can draw all our asteroids in the `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the game and check out those smooth, 60+ FPS, spinning asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing and moving the asteroids](img/B043422_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to make it easy to control the ship by adding button graphics,
    as well as some other overlay information, with a HUD.
  prefs: []
  type: TYPE_NORMAL
- en: Scores and the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HUD objects will never be rotated. In addition, they are defined in the
    `InputController` class based on screen coordinates, not the game world or even
    Open GL coordinates. Therefore, our `GameObject` class is not a suitable parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, each of the three HUD classes will have their own
    `draw` method. We will see how we draw them at a consistent size and screen position
    using a new viewport matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created all three of our HUD classes, we will add all of the object
    declarations, initializations, and drawing code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding control buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first HUD object we will make a class for, is a simple button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am showing all the imports explicitly, as they do not get imported automatically.
    Note that the next two classes will need these as well. The code is all in the
    download bundle as usual, if you wish to just copy and paste it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class and call it `GameButton`, then add the following import statements.
    Be sure to state the correct package name based on which chapter's code you are
    using or the name you gave your project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare some members; `viewportMatrix` into which we will put our
    new matrix for the viewport transformation from the `InputController` class's
    screen based coordinates—An int `glprogram` value, an `int numVertices` value,
    and a `FloatBuffer` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in the constructor is make our viewport matrix by calling
    `orthoM()` with the screen height and width as `0,0`. This makes OpenGL map a
    coordinate range that is identical to the device resolution over the top of the
    OpenGL coordinate range.
  prefs: []
  type: TYPE_NORMAL
- en: We then get the coordinates of the passed in button and shrink it down to make
    it smaller. Then, we initialize a vertex array as four lines to represent a button.
    Clearly, we will need to create a new button object to represent each and every
    button from our `InputController` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Now, we duplicate a little of the code from `GameObject` to prepare `ByteBuffer`,
    but still we use our static `GLManager.getGLProgram()` to get a handle to a GL
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement the `draw` method, which is a simplified version of the
    `draw` method from `GameObject`. Note that we don't need to mess around with model,
    translation, and rotation matrices, and also that we pass a different color to
    the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Tally icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class is the same as `GameButton`, except that a tally icon will be a single
    straight vertical line; therefore, we only need two vertices.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that we have a parameter in the constructor called `nthIcon`.
    It will be the responsibility of the calling code to let `TallyIcon` know the
    total quantity of already created `TallyIcon` objects, plus one. Then, the current
    `TallyIcon` object can use the padding variable to position itself appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `TallyIcon` and enter the following code. As we have,
    previously, include the static imports as required. Here is the code for all the
    declarations and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: This is the draw method which is probably looking quite familiar by now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Now for the final HUD element.
  prefs: []
  type: TYPE_NORMAL
- en: Life icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last icon will be a kind of mini-ship to indicate how many lives the player
    has remaining.
  prefs: []
  type: TYPE_NORMAL
- en: We will construct a triangle shape out of lines to create a nice hollow effect.
    Note that the `LifeIcon` constructor also uses an `nthIcon` element to control
    the padding and on screen position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `LifeIcon` and enter the following code, remembering
    all the imports that will not auto-import. Here are the declarations and the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `draw` method of the `LifeIcon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: We have our three HUD classes, and we can draw them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring, initializing, and drawing the HUD objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will declare, initialize, and draw our HUD objects just like all the `GameObject`
    classes. However, note that, as expected, we don't pass a viewport matrix to the
    `draw` method because the HUD classes provide their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these members to `GameManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with the `asteroids` array, initialize `tallyIcons` and `lifeIcons`
    in the `GameManager` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new member array to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code to create objects of all our new HUD classes. Add it to the `createObjects`
    method just before the closing curly brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can draw our HUD based on the number of lives remaining and the number
    of asteroids left before the next level. Add this code to the end of the `draw`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: You can now fly around and admire your new HUD.
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring, initializing, and drawing the HUD objects](img/B043422_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, if we are going to make any use of our lives and asteroid tally indicators,
    then we first need to be able to shoot asteroids as well as detect them when the
    ship gets hit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We achieved lots in this chapter, and indeed it would be simple to quickly add
    more game objects. Perhaps, an occasional UFO like in the original arcade classic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will use what we learned in previous projects to set
    up collision detection and finish off the game. However, a game with precise,
    clean, smooth moving lines deserves much more accurate collision detection than
    we used so far.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will concentrate solely on implementing precise, efficient collision
    detection that will make our Asteroids simulator complete.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11. Things That Go Bump – Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The collision detection in this game is much more complex than the previous
    two. For this reason, the code will be quite heavily commented. Sometimes the
    comments will explain things in a bit more detail or in a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: However, that doesn't mean it needs to be hard work. What we need to do is take
    a moment to consider a strategy that will work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this approach will mean that by the end of the chapter, our collision
    detection solutions will appear straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we are trying to achieve can be put into the following two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want for the border:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asteroids, bullets, and the ship need to know when they have collided with the
    border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asteroids should reverse and head back into the game area when they touch the
    border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A bullet should reset itself at the border
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ship should subtract a life and then respawn in the centre
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we want for the asteroids. We need to know and respond when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ship touches an asteroid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a bullet touches an asteroid
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the original Asteroids game, we will not respond to asteroids bumping
    into each other
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we will not be detecting an asteroid on asteroid collisions, you will
    see that when our collision detection nears completion, achieving asteroid on
    asteroid collision detection will not present much of an extra challenge. However,
    it will put extra strain on the device's CPU.
  prefs: []
  type: TYPE_NORMAL
- en: We know that we have object on border collisions to detect and object on asteroid
    collisions to detect.
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with the border
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may sound obvious, but the border is simply four static straight lines. This
    makes a border collision a different problem to an asteroid collision.
  prefs: []
  type: TYPE_NORMAL
- en: All of the objects that we are interested in have vertices (or one vertex in
    the case of a bullet). This may at first suggest that we can simply compute the
    world location of each vertex from the model space and the centre of the object
    stored in `worldLocation`. We can, but this overlooks the fact that the asteroids
    and the ship rotate, which constantly causes a variation in the actual world locations
    of all the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to translate and rotate the model space vertices, and then test
    if any of them have touched the border. We can do this in the object's `update`
    method for each frame, but we only need the rotated coordinates occasionally,
    when the object is very close to the border.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase of border collision detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This suggests that a preliminary check, a first phase of collision detection,
    is more efficient. It implies that the translation and rotation of the vertices
    will need to take place outside of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do is use a simple rectangle intersect check based on the centre
    of the object and its width and height. If this cheap method returns a hit, we
    will then rotate and translate each vertex and check their real-world coordinates
    individually against the location of the border.
  prefs: []
  type: TYPE_NORMAL
- en: Once the rotated game world locations of the vertices are calculated, the collision
    detection is simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: As we will see, a two-stage solution is appropriate for the asteroid detection
    as well. Also, rotation and translation is involved but it is far less important.
  prefs: []
  type: TYPE_NORMAL
- en: Colliding with an asteroid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing for collision with an asteroid is similar in some respects. We need
    to find out if any single vertex from the ship or a bullet crosses into the space
    contained by the vertices of the asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that the asteroid is not only a moving target, but also
    a rotating one. We will not only have to rotate and translate all the vertices
    of the objects, but the asteroids as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to calculate the line made between each pair of vertices on the
    asteroid. Fortunately, at this point, we can fall back on a clever algorithm devised
    and refined by mathematicians far greater than myself. We will use the crossing
    number algorithm. This is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The crossing number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We compute the line made by a pair of vertices and use the crossing number algorithm
    to see if a particular vertex from the object being tested crossed that line.
    If it did, we increment a variable from 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: We test the same point against each and every line made by each vertex pair
    from an asteroid, incrementing our variable each time it does. If our variable
    is odd after testing the vertex against every line with the crossing number algorithm,
    we have a hit. If it is even, no collision has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Of course if no collision has occurred, we must proceed to test each and every
    vertex from the object being tested against each and every line formed out of
    the vertex pairs on the asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a visual representation of the crossing number algorithm in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![The crossing number](img/B043422_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course with all these complex calculations going on, we will definitely want
    to do a simple first phase test to see if it is likely there has been a collision
    before doing the complex tests.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase and overview of asteroid collision detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The radius overlap test is quite appropriate when testing a single vertex, such
    as a bullet, a spinning triangle like a ship, or a rotating asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an overview of the whole process we will use for testing the collisions
    against asteroids:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the radius of the object being tested overlapped with the radius of an asteroid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, has the first vertex of the object crossed the first line of the asteroid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, `crossingNumber ++`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 2 with each line on the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `crossingNumber` is odd, return true to calling code because a collision
    has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `crossingNumber` is even, no collision has occurred (yet) repeat steps 2,
    3, and 4 with the next vertex of the object being tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all vertices tested and we reached here then no collision has occurred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will set up a collision detection class called `CD` with two static methods.
    The `detect` method will test for collisions with asteroids and be called for
    each bullet and ship against each and every asteroid in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `contain` method will check for collisions with every asteroid, bullet,
    and ship against the border.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the calculations outside the objects themselves means that we will need
    a whole bunch of data for the objects we will be testing, and the ones made accessible
    to the new `CD` class's methods.
  prefs: []
  type: TYPE_NORMAL
- en: The CollisionPackage class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that we need a certain set of data to carry out detections properly.
    This next class will hold all the data that our collision detection class's methods
    will need in order to do its job, and every object that we need to detect collisions
    for will have one.
  prefs: []
  type: TYPE_NORMAL
- en: When the time comes to rotate all the points to their real-world location, our
    collision package will need to know which way the object is facing. We have a
    float called `facingAngle`.
  prefs: []
  type: TYPE_NORMAL
- en: We will obviously need a copy of the model space vertices. As with the rotated
    location, we will not go through the trouble of updating every frame and will
    do so only after the first phase of collision detection shows that a collision
    is likely.
  prefs: []
  type: TYPE_NORMAL
- en: We will also hold the precomputed value for the length of the array that holds
    these vertices. It can potentially save time in the collision detection process.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will also need the world coordinates of the object. This, we will
    update every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Each object will have a precomputed `radius` variable, which is the size of
    the object from its centre to its furthest vertex. This will be used in our `detect`
    method for radius overlapping, phase one detection.
  prefs: []
  type: TYPE_NORMAL
- en: We will also have a couple of `PointF` objects, `currentPoint`, and `currentPoint2,`
    which are just handy objects that will avoid us potentially summoning the garbage
    collector during an intensive part of the two collision detection methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class, call it `CollisionPackage`, and implement the members we
    have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a simple constructor that will receive all the necessary data
    from each object at the end of each object''s constructor. Implement the `CollisionPackage`
    constructor as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: That's all the data we need for advanced collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding collision packages to the objects and making them accessible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we have our `CollisionPackage` class. We will see how to add one to each
    object we need to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the Bullet class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open up the `Bullet` class, and we will see how to make use of our `CollisionPackage`
    constructor on the simplest case (just a point). Add a new member for the collision
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new member of type `CollisionPackage` to the `Bullet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a structure to pass in to our `CollisionPackage` constructor
    and initialize the collision package. Note that we send in a single element array
    with the model space coordinates that will be 0,0,0\. Then, we send in the world
    location, 1, for the radius and the angle the bullet is facing. Enter the following
    code at the end of the `Bullet` class''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally for the `Bullet` class, we update the collision package in each frame
    by adding this code to the very end of the `Bullet` class''s `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Now, our bullets are all set for detection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the SpaceShip class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open up the `SpaceShip` class and add these members. We will then see how to
    use them in the `SpaceShip` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we do something extra compared to the `Bullet` class. We add three more
    model space coordinates. OpenGL will not know about these and doesn''t need them.
    They are positioned in the middle of each of the three lines, which make the ship.
    We do this to make it harder for a vertex of an asteroid to drift inside the ship
    without a vertex of the ship being inside the asteroid. This is a visual representation
    of the problem that we are solving. The ships vertices are heavily emphasized
    to highlight the problem. Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can completely solve this problem by testing all the asteroids vertices
    against all of the ship''s lines as well as what we are planning to do; test all
    the ship''s vertices against all the asteroids lines. However, just adding a few
    extra points to the ship does produce near-perfect detection as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, right after the call to `setVertices()` in the `SpaceShip` constructor
    implement the code we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Next as we did for the `Bullet` class, we synchronize the collision package
    each frame in the `SpaceShip` class's `update` method. We do this at the very
    end of the method after the call to `move()` has updated the ship's coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will add a collision package to the asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a collision package to the Asteroid class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Open up the `Asteroid` class and add a `CollisionPackage` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `Asteroid` constructor, just after the call to `generatePoints()`,
    we initialize the `CollisionPackage` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a helper method that reverses the direction of travel and *bounces*
    the asteroid back by a few pixels when a collision has been detected. We will
    call this method when we detect a collision with the border. Add the `bounce`
    method to the `Asteroid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `SpaceShip` and `Bullet` classes, we will update the collision
    package in the `update` method just after the call to `move` at the very end of
    the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to do something that we didn't need to do for the other classes.
    Our crossing number algorithm uses lines not vertices, so we need to make a line
    out of the last vertex by joining it with the first. We didn't need to do this
    with the `SpaceShip` class because of the way our collision data code worked.
    The collision data code will test the points of the bullets and ship against the
    lines of the asteroids. Not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the extra code to add to the seventh point in the `generatePoints`
    method. In the following code, I have included the existing code on either side
    of the new highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can talk about building the collision detection class itself.
  prefs: []
  type: TYPE_NORMAL
- en: The CD class outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now implement the first phase of collision detection. As discussed,
    the algorithms we will use are computationally expensive, and we only want to
    use them when there is a realistic chance of a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will check each bullet and the ship against every asteroid using
    the radius overlapping method discussed in [Chapter 3](ch12.html "Chapter 3. Tappy
    Defender – Taking Flight"), *Tappy Defender – Taking Flight*. We will check the
    asteroids, ship, and bullets against the border using a simplified rectangle intersection
    method.
  prefs: []
  type: TYPE_NORMAL
- en: After the next two sections, you will actually be able to play the game, but
    you will see that the basic collision detection that we have used so far is not
    satisfying enough for this type of game.
  prefs: []
  type: TYPE_NORMAL
- en: These first checks will decide whether we then move on to do the more accurate
    and computationally expensive checks.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement these second phase checks in the sections *Precise collision
    detection with the border* and *Precise collision detection with an asteroid*,
    which will use the more advanced algorithms and put the data in our collision
    packages to full use.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new class and call it `CD`. Add a member `PointF` object
    and initialize it. We will use it to avoid creating new objects during the critical
    parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing radius overlapping for asteroids and ships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's add our first method to the `CD` class, to detect collisions between bullets
    and asteroids as well as the ship and asteroids. As we discussed, we are only
    implementing the first part of this method for now. Here is the implementation
    of the radius overlapping code.
  prefs: []
  type: TYPE_NORMAL
- en: The code works by making a hypothetical triangle with a missing side, and then
    using Pythagoras' theorem to calculate the missing side that is the distance between
    the centre points of the two objects. If the combined radii of the two objects
    is greater than the distance between the two object centers, we have an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `detect` method with the radius overlapping code. Note that we return
    `true` if the radii overlap. This one line of code will be replaced with the more
    accurate detection later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss the border.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rectangle intersection for the border
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will see if any asteroids, bullets, or the ship need containing within the
    border. As discussed, we will carry out a simple rectangle intersect test and
    return `true` if detected. Later, we will delete the return `true` and add the
    more sophisticated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `contain` method as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two methods that we just need to call them on all the appropriate
    object combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are really close to being able to play our game, albeit with simplified collision
    detection. First add some methods that handle what happens when certain collisions
    are detected and then see how we actually use our `CD` class.
  prefs: []
  type: TYPE_NORMAL
- en: Helper methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need a couple of helper methods to respond, when we detect
    various types of collisions.
  prefs: []
  type: TYPE_NORMAL
- en: We need a method for when the ship is destroyed and a method for when an asteroid
    is destroyed. The next two subsections cover this.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a ship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The death of a ship can be detected in two places, so it makes sense to add
    a method to handle the events that follow. In this next method, we reset the ship's
    location to the center of the map, play a sound, and decrement `numLives`.
  prefs: []
  type: TYPE_NORMAL
- en: If `numLives` is equal to zero, set `levelNumber` back to one, `numLives` to
    three, call `createObjects()` to redraw a level, pause the game, and then play
    a sound suitable to let the player know that he is starting again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `lifeLost` method to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: We will handle what happens when an asteroid dies.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying an asteroid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method will be called when the ship or a bullet hits an asteroid. First,
    we set the asteroid that triggered the collision to `setActive(false)`. It will
    not be drawn or updated any more.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we play a sound and decrement `numAsteroidsRemaining`. Finally if `numAsteroidsRemaining`
    is equal to zero, the player has cleared an entire level. In that case, we increment
    `levelNumber` and `numLives`, play a victorious sound, and start a harder level
    by calling `createObjects()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `destroyAsteroid()` method to the `AsteroidsRenderer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: We can now call our new `CD` class's static methods and respond when we get
    a collision.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for collisions in update()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will check to see if the ship needs containing. We simply call `CD.contain()`
    with the `mapWidth`, `mapHeight`, and the ship's collision package. If there is
    a collision, the code calls `lifeLost()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the collision detection code after all the code that updates the objects
    in the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: This is the code that detects if any of the asteroids are attempting to leave
    the asteroid simulator. It works exactly the same way as the previous block of
    code except that we loop through each asteroid, check if it is active, and call
    bounce on the asteroid if we detect a collision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: The code for the bullets looks a little more complicated, but it isn't really.
    The call to `CD.contain()` is identical, and we do so for each bullet. However,
    some last minute balancing of the game play is necessary for the bullet to be
    reset as it left the viewport (if that was before the border), because otherwise
    the ship can just spin round and destroy the asteroids from a great distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the code to detect bullet collisions with the border and the edge of
    the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game now and see how the `CD.contain()` method does a fairly
    good job of keeping everything within the asteroid simulator.
  prefs: []
  type: TYPE_NORMAL
- en: We will call our `detect` method to see if anything is bumping into an asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: First, check the bullets. Note that we do a preliminary check to make sure the
    bullet is in flight, and the asteroid is active before we trouble our `CD.detect`
    method. Then, we just pass in the two collision packages and `CD.detect` does
    the rest. If a bullet collides with the border, we call `resetBullet()` on the
    appropriate bullet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Now, we test for the ship. If a collision is detected, we call `destroyAsteroid()`
    followed by `lifeLost()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can play the game and our rudimentary collision detection
    will work. However, fly too close to an asteroid, and you will lose a life without
    touching it or merely shoot a bullet close and the asteroid is gone. We need to
    be able to skim the surface of the border or asteroid and only get a hit when
    a point actually crosses into the exact space of another object.
  prefs: []
  type: TYPE_NORMAL
- en: Precise collision detection with the border
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To upgrade our `detect` method, we need to replace the return statement in the
    `if(possibleCollision)` block with the more precise detection code.
  prefs: []
  type: TYPE_NORMAL
- en: First, initialize `radianAngle` to be the radian equivalent of whichever direction
    (in degrees) our object is facing. The `Math` class uses radians as they are more
    mathematically useful in calculations than the easier to visualize degree measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The variables `cosAngle` and `sinAngle` are just what the name suggests, and
    are used in the block of code which follows this one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth mentioning that the `Math.cos()` and `Math.sin()` methods are relatively
    time consuming. We can speed up our collision detection class by precomputing
    360 values for both `sin` and `cos` and then using a simple lookup method instead
    of this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: However, we maintain our goal of over 60 frames per second, so don't do so here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the return statement and add this code in the `if(possibleCollision)`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: In the next block of code, enter a `for` loop that loops through each of the
    object's vertices, translates them from model-space to world-space coordinates,
    then uses our previously computed values for cosine and sine of the `facingAngle`
    object to rotate them to their precise locations in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Now all we do is see if the rotated and translated vertex falls outside of either
    the left, right, top, or bottom of the border/map. If it does, we return `true`;
    if not, the loop continues to check each and every vertex the same way (translate,
    rotate, check, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game now and watch the bullets disappear with a satisfying thud
    into the border or fly your ship deadly close to the border.
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve our asteroid collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Precise collision detection with an asteroid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did this last because there is a more complicated final step. As in the border
    detection, we will need to translate and rotate our object's vertices. However
    this time, we will need to do it for two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, once we rotated and translated the asteroid's vertices, we will
    need to handle them in pairs of vertices that form a line. These are lines that
    we will test against each and every vertex from the other object. This test is
    of course our crossing number method that we discussed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to do all of this within the body of the `if (distance < cp1.radius
    + cp2.radius) { ...}`, where we previously just set the `collided` Boolean to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a lot of code, so we will split it into chunks and see what is
    going on at each stage. Also, the code indentation will not always be consistent
    from block to block in order to format it in the most readable way possible.
  prefs: []
  type: TYPE_NORMAL
- en: The next few blocks of code are the entire contents of the aforementioned, `if`
    block that needs replacing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, we can use a sine and cosine lookup table here too.
  prefs: []
  type: TYPE_NORMAL
- en: We could make a method to rotate angles as we do this so often. But this is
    not as straightforward as it may seem. If we put the rotation code in a method,
    we will either have to put the following sine and cosine calculations in it, which
    will make it slow or precompute it before the method call and the `for` loops
    which is kind of untidy itself.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you consider that we need more than one value for both the sine and
    cosine of an angle, the method needs to *know* which value to use, and this isn't
    rocket science, but it starts to get even less compact than we might have initially
    imagined. So, I opted to avoid the method call altogether, even if the code is
    a little sprawling. Actually, if you place the whole lot in a method call, you
    still get nearly 60 FPS on an old Galaxy S2 phone. So if you want to tidy things
    up, go ahead; I just thought it was worth discussing why I did things this way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the `for` loops, as we did with the border detection, we
    will compute a few things that won't change for the duration of this method. The
    sine and cosine of the facing angle from each of the two collision packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Now, we loop through all the vertices from `cp2`, then test each in turn with
    all the sides (vertex pairs) from `cp1`. Remember an asteroid has an extra vertex
    of padding that is the same as the first. Therefore, we can test the last side
    of the asteroid. We must always pass in the asteroid collision package as the
    *second* argument when calling `CD.detect()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next block of code, translate and then rotate the object being tested
    against an asteroid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: Now using a pair of vertices at a time, from the asteroid, translate and rotate
    both to their final world-space coordinates ready for the next block of code,
    where we will use the vertex locations calculated in the previous block and this
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Here, we detect if the current vertex from either the ship or a bullet crosses
    the line formed by the current vertex pair of the asteroid. If it does, we increment
    `numCrosses`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the modulus operator to determine if `numCrosses` is odd or
    even. As discussed, we return `true` (collision) for odd and `false` (no collision)
    for even.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now fly your ship right up to the asteroids and only get hit when it
    really looks like you should. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Precise collision detection with an asteroid](img/B043422_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, all of our collision detection and our Asteroids simulator game is done!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can continue to improve our game. For example, it wouldn't be too hard to
    spawn two or three smaller asteroids when the current asteroid is destroyed. We
    just need an array to hold the smaller asteroids. When we deactivate the regular
    asteroid, the array activates some previously instantiated smaller ones at the
    same location as the regular one. We can then make some minor modifications to
    the way we count asteroids, and we will have a neat new feature.
  prefs: []
  type: TYPE_NORMAL
- en: The arcade classic, Asteroids, had a mean UFO that would turn up occasionally.
    It would be simple to design a UFO shape from lines, and have it randomly proceed
    from left to right, or right to left, moving up and down a bit as well.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can add a hyperspace button. This is a kind of last resort for the
    player when they are sure that death is imminent. Tap the hyperspace button and
    the ship will respawn in a random location. We will just need to add a button
    to the array in the `InputController` class and a call to a new, simple `randomHyperspaceJUmp`
    method in the `Ship` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add Google Play achievements and leaderboards and then publish
    the game. If you publish a game that uses OpenGL, you need to add this declaration
    to the `AndroidManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: Try and add some of the improvements we talked about and perhaps some more of
    your own. If you publish your game or even if you don't, I would love to hear
    your ideas or see a link to your projects on [gamecodeschool.com](http://gamecodeschool.com).
  prefs: []
  type: TYPE_NORMAL
- en: I think we are done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you have enjoyed our whirl-wind tour, making games for Android, and I
    hope you keep making lots of new games!
  prefs: []
  type: TYPE_NORMAL
