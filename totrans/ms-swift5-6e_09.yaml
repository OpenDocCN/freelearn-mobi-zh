- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocols and Protocol Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While watching the presentations from WWDC 2015 about protocol extensions and
    **protocol-oriented programming** (**POP**), I will admit that I was very skeptical.
    I have worked with **object-oriented programming** (**OOP**) for so long that
    I was unsure whether this new programming paradigm would solve all of the problems
    that Apple was claiming it would. Since I am not one who lets my skepticism get
    in the way of trying something new, I set up a new project that mirrored the one
    I was currently working on, but wrote the code using Apple's recommendations for
    POP. I also used protocol extensions extensively in the code. I can honestly say
    that I was amazed by how much cleaner the new project was compared to the original
    one. I believe that protocol extensions are going to be one of those defining
    features that set one programming language apart from the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How are protocols used as a type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we implement polymorphism in Swift using protocols?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we use protocol extensions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why we would want to use protocol extensions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While protocol extensions are basically syntactic sugar, they are, in my opinion,
    one of the most important additions to the Swift programming language. With protocol
    extensions, we are able to provide method and property implementations to any
    type that conforms to a protocol. To really understand how useful protocols and
    protocol extensions are, let's get a better understanding of protocols.
  prefs: []
  type: TYPE_NORMAL
- en: While classes, structures, and enumerations can all conform to protocols in
    Swift, for this chapter, we will be focusing on classes and structures. Enumerations
    are used when we need to represent a finite number of cases, and while there are
    valid use cases where we would have an enumeration conform to a protocol, they
    are rare in my experience. Just remember that anywhere we refer to a class or
    structure, we can also use an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin exploring protocols by seeing how they are full-fledged types in
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols as types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though no functionality is implemented in a protocol, they are still considered
    a full-fledged type in the Swift programming language and can be used like any
    other type. This means that we can use protocols as a parameter type or as a return
    type in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use them as the type for variables, constants, and collections.
    Let''s take a look at some examples. For these few examples, we will use the following
    `PersonProtocol` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this first example, a protocol is used as a parameter type and a return
    type for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `updatePerson()` function accepts one parameter of the
    `PersonProtocol` protocol type and returns a value of the `PersonProtocol` protocol
    type. This next example shows how to use a protocol as a type for constants, variables,
    or properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a variable of the `PersonProtocol` protocol type
    that is named `myPerson`. Protocols can also be used as the item type for storing
    a collection, such as arrays, dictionaries, or sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this final example, we created an array of the `PersonProtocol` protocol
    type. Even though the `PersonProtocol` protocol does not implement any functionality,
    we can still use protocols when we need to specify a type. However, a protocol
    cannot be instantiated in the same way as a class or a structure. This is because
    no functionality is implemented in a protocol. As an example, when trying to create
    an instance of the `PersonProtocol` protocol, as shown in the following example,
    we would receive a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the instance of any type that conforms to our protocol wherever
    the protocol type is required. As an example, if we''ve defined a variable to
    be of the `PersonProtocol` protocol type, we can then populate that variable with
    any class or structure that conforms to this protocol. For this example, let''s
    assume that we have two types, named `SwiftProgrammer` and `FootballPlayer`, that
    conform to the `PersonProtocol` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start off by creating the `myPerson` variable of the `PersonProtocol`
    protocol type. We then set the variable with an instance of the `SwiftProgrammer`
    type and print out the first and last names. Next, we set the `myPerson` variable
    to an instance of the `FootballPlayer` type and print out the first and last names
    again. One thing to note is that Swift does not care whether the instance is a
    class or structure. The only thing that matters is that the type conforms to the
    `PersonProtocol` protocol type.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `PersonProtocol` protocol as the type for an array, which means
    that we can populate the array with instances of any type that conforms to the
    protocol. Once again, it does not matter whether the type is a class or a structure,
    as long as it conforms to the `PersonProtocol` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism with protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we saw in the previous examples is a form of polymorphism. The word **polymorphism**
    comes from the Greek roots **poly**, meaning many, and **morphe**, meaning form.
    In programming languages, polymorphism is a single interface to multiple types
    (many forms). In the previous example, the single interface was the `PersonProtocol`
    protocol and the multiple types were any type that conforms to that protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism gives us the ability to interact with multiple types in a uniform
    manner. To illustrate this, we can extend the previous example where we created
    an array of the `PersonProtocol` types and looped through the array. We can then
    access each item in the array using the properties and methods defined in the
    `PersonProtocol` protocol, regardless of the actual type. Let''s see an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we define the type of a variable, constant, collection type, and so on
    to be a protocol type, we can use the instance of any type that conforms to that
    protocol. This is a very important concept to understand and is one of the many
    things that make protocols and protocol extensions so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a protocol to access instances, as shown in the previous example,
    we are limited to using only properties and methods that are defined in the protocol
    itself. If we want to use properties or methods that are specific to the individual
    types, we need to cast the instance to that type.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting with protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typecasting is a way to check the type of the instance and/or to treat the instance
    as a specified type. In Swift, we use the `is` keyword to check whether an instance
    is a specific type, and the `as` keyword to treat the instance as a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s see how we would check the instance type using the `is` keyword.
    The following example shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use the `if` conditional statement to check whether each
    element in the `people` array is an instance of the `SwiftProgrammer` type and,
    if so, we print that the person is a Swift programmer to the console. While this
    is a good method to check whether we have an instance of a specific class or structure,
    it is not very efficient if we want to check for multiple types. It would be more
    efficient to use a `switch` statement, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we showed how to use the `switch` statement to check
    the instance type for each element of the array. To do this check, we use the
    `is` keyword in each of the `case` statements in an attempt to match the instance
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 6*, *Control Flow*, we saw how to filter conditional statements
    with the `where` statement. We can also use the `where` statement with the `is`
    keyword to filter the array, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at how we can cast an instance of a class or structure to a
    specific type. To do this, we would use the `as` keyword. Since the cast can fail
    if the instance is not of the specified type, the `as` keyword comes in two forms:
    `as?` and `as!`. With the `as?` form, if the casting fails, it returns `nil`,
    and with the `as!` form, if the casting fails, we get a runtime error. Therefore,
    it is recommended to use the `as?` form unless we are absolutely sure of the instance
    type or we perform a check of the instance type prior to doing the cast.'
  prefs: []
  type: TYPE_NORMAL
- en: While we do show examples of typecasting with `as!` in this book, so you are
    aware that it is there, we highly recommend that you do not use it in your projects
    because it can cause a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use the `as?` keyword to cast an instance of a
    class or structure to a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the `as?` keyword returns an optional, we use optional binding to perform
    the cast, as shown in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered the basics of protocols, let''s dive into one of the
    most exciting features of Swift: protocol extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol extensions allow us to extend a protocol to provide method and property
    implementations to conforming types. They also allow us to provide common implementations
    to all the conforming types, eliminating the need to provide an implementation
    in each individual type or the need to create a class hierarchy. While protocol
    extensions may not seem too exciting, once you see how powerful they really are,
    they will transform the way you think about and write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by looking at how we would use protocol extensions within a very
    simplistic example. We will start by defining a protocol named `Dog`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this protocol, we state that any type that conforms to the `Dog` protocol
    must have the two properties of the `String` type, named `name` and `color`. Next,
    let''s define the three types that conform to this `Dog` protocol. We will name
    these types `JackRussel`, `WhiteLab`, and `Mutt`. The following code shows how
    we would define these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We purposely created the `JackRussel` and `Mutt` types as structures and the
    `WhiteLab` type as a class to show the differences between how the two types are
    set up, and to illustrate how they are treated the same when it comes to protocols
    and protocol extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference we can see in this example is that structure types provide
    a default initiator, but in the class we must provide the initiator to populate
    the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s say that we want to provide a method named `speak` to each type
    that conforms to the protocol. Prior to protocol extensions, we would have started
    off by adding the method definition to the protocol, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the method is defined in the protocol, we would then need to provide an
    implementation of the method in every type that conforms to the protocol. Depending
    on the number of types that conformed to this protocol, this could take a bit
    of time to implement and it could affect a lot of code. The following code sample
    shows how we might implement this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: While this method works, it is not very efficient because any time we update
    the protocol, we need to update all the types that conform to it, and therefore
    duplicate a lot of code, as shown in this example. If we need to change the default
    behavior of the `speak()` method, we would have to go into each implementation
    and change the method. This is where protocol extensions come in.
  prefs: []
  type: TYPE_NORMAL
- en: With protocol extensions, we could take the `speak()` method definition out
    of the protocol itself and define it with the default behavior in the protocol
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: If we are implementing a method in a protocol extension, we are not required
    to define it in the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we would define the protocol and the protocol
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining the `Dog` protocol with the original two properties. We
    then create a protocol extension that extends it and contains the default implementation
    of the `speak()` method. With this code, there is no need to provide an implementation
    of the `speak()` method in all of the types that conform to the `Dog` protocol
    because they automatically receive the implementation as part of the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works by setting the three types that conform to the `Dog`
    protocol back to their original implementations; then they should receive the
    `speak()` method from the protocol extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use each of the types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this example, by adding the `speak()` method to the `Dog`
    protocol extension, we are automatically adding that method to all the types that
    conform to the protocol. The `speak()` method in the protocol extension can be
    considered a default implementation of the method because we are able to override
    it in the type implementations. As an example, we could override the `speak()`
    method in the `Mutt` structure, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When we call the `speak()` method for an instance of the `Mutt` type, it will
    return the `I am hungry` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we named our protocols with the protocol suffix. This was
    done to make it very clear that this was a protocol. This is not how we would
    normally name our types. The following example gives a better example of how we
    would properly name protocols. You can read additional information about Swift''s
    naming conventions in the Swift API design guidelines: [https://swift.org/documentation/api-design-guidelines/#general-conventions](https://swift.org/documentation/api-design-guidelines/#general-conventions).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to use protocols and protocol extensions, let's look
    at a more real-world example.
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In numerous apps across multiple platforms (iOS, Android, and Windows), I have
    needed to validate user input as it is entered. This validation can be done very
    easily with regular expressions; however, we do not want various regular expressions
    littered throughout our code. It is very easy to solve this problem by creating
    different classes or structures that contain the validation code. However, we
    would have to organize these types to make them easy to use and maintain. Prior
    to protocol extensions in Swift, I would use a protocol to define the validation
    requirements and then create structures that would conform to the protocol for
    each validation that I needed. Let's look at this pre-protocol extension method.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is a sequence of characters that defines a particular pattern.
    This pattern can then be used to search a string to see whether the string matches
    the pattern or contains a match of the pattern. Most major programming languages
    contain a regular expression parser, and if you are not familiar with regular
    expressions, it may be worthwhile to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `TextValidating` protocol that defines the requirements
    for any type that we want to use for text validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Swift API design guidelines ([https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/)
    ) state that protocols that describe what something is should be named as a noun,
    while protocols that describe a capability should be named with a suffix of -able,
    - ible, or -ing. With this in mind, we named the text validation protocol `TextValidating`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this protocol, we define three properties and two methods that any type
    that conforms to a protocol must implement. The three properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regExMatchingString`: This is a regular expression string used to verify that
    the input string contains only valid characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regExFindMatchString`: This is a regular expression string used to retrieve
    a new string from the input string that contains only valid characters. This regular
    expression is generally used when we need to validate the input in real time as
    the user enters information, because it will find the longest matching prefix
    of the input string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validationMessage`: This is the error message that''s displayed if the input
    string contains non-valid characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two methods for this protocol are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validateString`: This method will return `true` if the input string contains
    only valid characters. The `regExMatchingString` property will be used in this
    method to perform the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMatchingString`: This method will return a new string that contains only
    valid characters. This method is generally used when we need to validate the input
    in real time as the user enters information because it will find the longest matching
    prefix of the input string. We will use the `regExFindMatchString` property in
    this method to retrieve the new string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s see how we can create a structure that conforms to this protocol.
    The following structure would be used to verify that the input string contains
    only alpha characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, the `regExFindMatchString` and `validationMessage` properties
    are stored properties, and the `regExMatchingString` property is a computed property.
  prefs: []
  type: TYPE_NORMAL
- en: We also implement the `validateString()` and `getMatchingString()` methods within
    the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we would have several different types that conform to the protocol,
    where each one would validate a different type of input. As we can see from the
    `AlphaValidation1` structure, there is a bit of code involved with each validation
    type. A lot of the code would also be duplicated in each type. The code for both
    methods and the `regExMatchingString` property would probably be duplicated in
    every validation class. This is not ideal, but if we want to avoid creating a
    class hierarchy with a superclass that contains the duplicate code (it is recommended
    that we prefer value types over reference types), prior to protocol extensions,
    we had no other choice. Now let's see how we would implement this using protocol
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: With protocol extensions, we need to think about the code a little differently.
    The big difference is that we neither need nor want to define everything in the
    protocol. With standard protocols, all the methods and properties that you would
    want to access using a protocol interface would have to be defined within the
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'With protocol extensions, it is preferable for us not to define a property
    or method in the protocol if we are going to be defining it within the protocol
    extension. Therefore, when we rewrite our text validation types with protocol
    extensions, `TextValidating` would be greatly simplified to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the original `TextValidating` protocol, we defined three properties and
    two methods. As we can see in this new protocol, we are only defining two properties.
    Now that we have our `TextValidating` protocol defined, let''s create the protocol
    extension for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `TextValidating` protocol extension, we define the two methods and the
    property that were defined in the original `TextValidating` protocol but were
    not defined in the new one. Now that we have created the protocol and protocol
    extension, we are able to define our new text validation types. In the following
    code, we define three structures that we will use to validate text as a user types
    it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In each of the text-validation structures, we create a static constant and a
    private initializer so that we can use the structure as a singleton. For more
    information on the singleton pattern, please see *The singleton design pattern*
    section of *Chapter 20*, *Adopting Design Patterns in Swift*.
  prefs: []
  type: TYPE_NORMAL
- en: After we define the singleton pattern, all we do in each type is set the values
    for the `regExFindMatchString` and `validationMessage` properties. Now we have
    virtually no duplicate code. The only code that is duplicated is the code for
    the singleton pattern, and that is not something we would want to put in the protocol
    extension because we would not want to force the singleton pattern on all the
    conforming types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the text validation types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now the question is, do we really need to use protocols?
  prefs: []
  type: TYPE_NORMAL
- en: Do I need to use protocols?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you need to use protocols and protocol extensions when you already know OOP?
    The short answer is no; however, it is highly recommended. In *Chapter 10*, *Protocol-Oriented
    Design*, we look at what makes protocol-oriented design so powerful to show you
    why you should prefer protocols with POP over OOP. By understanding protocols
    and protocol-oriented design, you will understand the Swift standard library better.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting protocols using a synthesized implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift can automatically provide protocol conformance for the `Equatable`, `Hashable`,
    and `Comparable` protocols in specific cases. What this means is we do not need
    to write the boilerplate code to implement these protocols, and instead we can
    use the synthesized implementations. This only works if the structures or enumerations
    (not classes) contain only stored properties (for structures) or associated values
    (for enumerations) that conform to the `Equatable`, `Hashable`, and `Comparable`
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The `Equatable`, `Hashable`, and `Comparable` protocols are provided by the
    Swift standard library. Any type that conforms to the `Equatable` protocols can
    use the equals operator (==) to compare two instances of the type. Any type that
    uses the `Comparable` protocol can use comparative operators to compare two instances
    of the type. Finally, any type that conforms to the `Hashable` protocol can be
    hashed into a `Hasher` instance to produce an integer hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one example of this. We will start off by creating a simple
    structure that will store names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create three instances of the `Name` structure, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we tried to compare the instances of the `Name` structure, as shown in the
    following code, we could receive a compile-time error because the `Name` structure
    does not conform to the `Equatable` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to have the ability to compare instances of the `Name` structure,
    all that is needed is to state that the structure conforms to the `Equatable`
    protocol, and the boilerplate code to do the comparison will be automatically
    added at compile time. The following code shows us how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the only thing we changed was to add the `Equatable` protocol to
    the structure definition. We are now able to successfully compare instances of
    the `Name` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Swift's standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Swift standard library defines a base layer of functionality for writing
    Swift applications. Everything we have used so far in this book is from the Swift
    standard library. The library defines the fundamental data types, such as the
    `String`, `Int`, and `Double` types. It also defines collections, optionals, global
    functions, and all the protocols that these types conform to.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best sites to see everything that makes up the standard library is
    [http://swiftdoc.org](http://swiftdoc.org). This site lists all the types, protocols,
    operators, and globals that make up the standard library and contains documentation
    for all of it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how protocols are used in the standard library by looking at the
    documentation. When you first visit the home page, you will be greeted with a
    searchable list of everything that makes up the standard library. There is also
    a complete list of all Swift types that you can select from. Let's look at the
    Swift `Array` type by clicking on the **Array** link. This will take you to the
    documentation page for the `Array` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'These documentation pages are extremely useful and contain a lot of information
    about the various types that make up the standard library, including samples of
    how to use them. For our discussion, we are interested in the section labeled
    **Inheritance**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16683_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Documentation on Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: From the inheritance section, we can see that the Array conforms to 7 protocols.
    If you click on some of the protocols, such as the `MutableCollection` protocol,
    you will notice that they conform to other protocols. This may not make a lot
    of sense at this point but in the next chapter, *Chapter 10*, *Protocol-Oriented
    Design*, we will look at how to design our applications and frameworks using a
    protocol-oriented approach, and then we will have a better understanding of how
    the Swift standard library is written.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that protocols are treated as full-fledged types by
    Swift. We also saw how polymorphism can be implemented in Swift with protocols.
    We concluded this chapter with an in-depth look at protocol extensions and saw
    how we would use them in Swift. Protocols and protocol extensions are the backbone
    of Apple's new POP paradigm. This new model for programming has the potential
    to change the way we write and think about code. While we did not specifically
    cover POP in this chapter, getting to grips with the topics in this chapter gives
    us the solid understanding of protocols and protocol extensions needed to learn
    about this new programming model. In the next chapter, we will look at how to
    use protocols and protocol extensions when we are designing our application.
  prefs: []
  type: TYPE_NORMAL
