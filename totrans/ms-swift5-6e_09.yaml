- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Protocols and Protocol Extensions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议和协议扩展
- en: While watching the presentations from WWDC 2015 about protocol extensions and
    **protocol-oriented programming** (**POP**), I will admit that I was very skeptical.
    I have worked with **object-oriented programming** (**OOP**) for so long that
    I was unsure whether this new programming paradigm would solve all of the problems
    that Apple was claiming it would. Since I am not one who lets my skepticism get
    in the way of trying something new, I set up a new project that mirrored the one
    I was currently working on, but wrote the code using Apple's recommendations for
    POP. I also used protocol extensions extensively in the code. I can honestly say
    that I was amazed by how much cleaner the new project was compared to the original
    one. I believe that protocol extensions are going to be one of those defining
    features that set one programming language apart from the rest.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我观看 2015 年 WWDC 关于协议扩展和**面向协议编程**（**POP**）的演示时，我必须承认我非常怀疑。我长期从事**面向对象编程**（**OOP**），因此我不确定这种新的编程范式是否能够解决苹果所声称的所有问题。既然我不是一个让怀疑阻碍尝试新事物的人，我就设置了一个新的项目，该项目与我现在正在工作的项目相似，但使用苹果对
    POP 的建议编写代码。我还广泛使用了协议扩展。我可以真诚地说，与原始项目相比，新项目要干净得多。我相信，协议扩展将是那些定义性特征之一，将一种编程语言与其他编程语言区分开来。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How are protocols used as a type?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议如何用作类型？
- en: How do we implement polymorphism in Swift using protocols?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用协议在 Swift 中实现多态？
- en: How do we use protocol extensions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用协议扩展？
- en: Why we would want to use protocol extensions?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们想要使用协议扩展？
- en: While protocol extensions are basically syntactic sugar, they are, in my opinion,
    one of the most important additions to the Swift programming language. With protocol
    extensions, we are able to provide method and property implementations to any
    type that conforms to a protocol. To really understand how useful protocols and
    protocol extensions are, let's get a better understanding of protocols.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然协议扩展基本上是语法糖，但在我看来，它们是Swift编程语言中最重要的一些新增功能之一。通过协议扩展，我们能够为符合协议的任何类型提供方法和属性实现。为了真正理解协议和协议扩展的有用性，让我们更好地了解协议。
- en: While classes, structures, and enumerations can all conform to protocols in
    Swift, for this chapter, we will be focusing on classes and structures. Enumerations
    are used when we need to represent a finite number of cases, and while there are
    valid use cases where we would have an enumeration conform to a protocol, they
    are rare in my experience. Just remember that anywhere we refer to a class or
    structure, we can also use an enumeration.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 中的类、结构和枚举都可以遵守协议，但在这个章节中，我们将专注于类和结构。枚举用于表示有限数量的案例，虽然在我的经验中，枚举遵守协议的有效用例是存在的，但它们很少见。只需记住，在任何我们提到类或结构的地方，我们也可以使用枚举。
- en: Let's begin exploring protocols by seeing how they are full-fledged types in
    Swift.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解它们在Swift中是如何作为完整类型开始的，来探索协议。
- en: Protocols as types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议作为类型
- en: Even though no functionality is implemented in a protocol, they are still considered
    a full-fledged type in the Swift programming language and can be used like any
    other type. This means that we can use protocols as a parameter type or as a return
    type in a function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在协议中没有实现任何功能，但它们在 Swift 编程语言中仍然被视为完整类型，可以像任何其他类型一样使用。这意味着我们可以将协议用作函数的参数类型或返回类型。
- en: 'We can also use them as the type for variables, constants, and collections.
    Let''s take a look at some examples. For these few examples, we will use the following
    `PersonProtocol` protocol:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将它们用作变量、常量和集合的类型。让我们看看一些例子。对于这些例子，我们将使用以下`PersonProtocol`协议：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this first example, a protocol is used as a parameter type and a return
    type for a function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个第一个例子中，协议被用作函数的参数类型和返回类型： '
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, the `updatePerson()` function accepts one parameter of the
    `PersonProtocol` protocol type and returns a value of the `PersonProtocol` protocol
    type. This next example shows how to use a protocol as a type for constants, variables,
    or properties:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`updatePerson()`函数接受一个`PersonProtocol`协议类型的参数，并返回一个`PersonProtocol`协议类型的值。接下来的例子展示了如何将协议用作常量、变量或属性的类型：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we create a variable of the `PersonProtocol` protocol type
    that is named `myPerson`. Protocols can also be used as the item type for storing
    a collection, such as arrays, dictionaries, or sets:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `myPerson` 的 `PersonProtocol` 协议类型的变量。协议也可以用作存储集合的项目类型，例如数组、字典或集合：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this final example, we created an array of the `PersonProtocol` protocol
    type. Even though the `PersonProtocol` protocol does not implement any functionality,
    we can still use protocols when we need to specify a type. However, a protocol
    cannot be instantiated in the same way as a class or a structure. This is because
    no functionality is implemented in a protocol. As an example, when trying to create
    an instance of the `PersonProtocol` protocol, as shown in the following example,
    we would receive a compile-time error:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们创建了一个 `PersonProtocol` 协议类型的数组。尽管 `PersonProtocol` 协议没有实现任何功能，但我们仍然可以在需要指定类型时使用协议。然而，协议不能像类或结构体那样被实例化。这是因为协议中没有实现任何功能。例如，当尝试创建
    `PersonProtocol` 协议的实例时，如下面的例子所示，我们会收到编译时错误：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the instance of any type that conforms to our protocol wherever
    the protocol type is required. As an example, if we''ve defined a variable to
    be of the `PersonProtocol` protocol type, we can then populate that variable with
    any class or structure that conforms to this protocol. For this example, let''s
    assume that we have two types, named `SwiftProgrammer` and `FootballPlayer`, that
    conform to the `PersonProtocol` protocol:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在需要协议类型的地方使用任何符合我们协议的类型实例。例如，如果我们定义了一个变量为 `PersonProtocol` 协议类型，那么我们可以用任何符合此协议的类或结构体来填充这个变量。为了这个例子，让我们假设有两个类型，分别命名为
    `SwiftProgrammer` 和 `FootballPlayer`，它们符合 `PersonProtocol` 协议：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we start off by creating the `myPerson` variable of the `PersonProtocol`
    protocol type. We then set the variable with an instance of the `SwiftProgrammer`
    type and print out the first and last names. Next, we set the `myPerson` variable
    to an instance of the `FootballPlayer` type and print out the first and last names
    again. One thing to note is that Swift does not care whether the instance is a
    class or structure. The only thing that matters is that the type conforms to the
    `PersonProtocol` protocol type.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了一个 `PersonProtocol` 协议类型的 `myPerson` 变量。然后，我们将变量设置为 `SwiftProgrammer`
    类型的实例，并打印出姓名和姓氏。接下来，我们将 `myPerson` 变量设置为 `FootballPlayer` 类型的实例，并再次打印出姓名和姓氏。需要注意的是，Swift
    不关心实例是类还是结构体。唯一重要的是类型必须符合 `PersonProtocol` 协议类型。
- en: We can use the `PersonProtocol` protocol as the type for an array, which means
    that we can populate the array with instances of any type that conforms to the
    protocol. Once again, it does not matter whether the type is a class or a structure,
    as long as it conforms to the `PersonProtocol` protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `PersonProtocol` 协议用作数组的类型，这意味着我们可以用符合协议的任何类型的实例来填充数组。再次强调，类型是类还是结构体并不重要，只要它符合
    `PersonProtocol` 协议。
- en: Polymorphism with protocols
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议的多态性
- en: What we saw in the previous examples is a form of polymorphism. The word **polymorphism**
    comes from the Greek roots **poly**, meaning many, and **morphe**, meaning form.
    In programming languages, polymorphism is a single interface to multiple types
    (many forms). In the previous example, the single interface was the `PersonProtocol`
    protocol and the multiple types were any type that conforms to that protocol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们看到的是一种多态形式。多态这个词来自希腊语词根 **poly**，意为许多，和 **morphe**，意为形式。在编程语言中，多态是单一接口对多种类型（许多形式）。在之前的例子中，单一接口是
    `PersonProtocol` 协议，而多种类型是任何符合该协议的类型。
- en: 'Polymorphism gives us the ability to interact with multiple types in a uniform
    manner. To illustrate this, we can extend the previous example where we created
    an array of the `PersonProtocol` types and looped through the array. We can then
    access each item in the array using the properties and methods defined in the
    `PersonProtocol` protocol, regardless of the actual type. Let''s see an example
    of this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性赋予我们以统一的方式与多种类型交互的能力。为了说明这一点，我们可以扩展之前的例子，其中我们创建了一个 `PersonProtocol` 类型的数组，并遍历了这个数组。然后，我们可以使用在
    `PersonProtocol` 协议中定义的属性和方法来访问数组中的每个项目，无论实际类型如何。让我们看看这个例子：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we define the type of a variable, constant, collection type, and so on
    to be a protocol type, we can use the instance of any type that conforms to that
    protocol. This is a very important concept to understand and is one of the many
    things that make protocols and protocol extensions so powerful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义变量、常量、集合类型等类型为协议类型时，我们可以使用符合该协议的任何类型的实例。这是一个非常重要的概念，也是使协议和协议扩展如此强大的许多事情之一。
- en: When we use a protocol to access instances, as shown in the previous example,
    we are limited to using only properties and methods that are defined in the protocol
    itself. If we want to use properties or methods that are specific to the individual
    types, we need to cast the instance to that type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用协议来访问实例时，如前一个示例所示，我们仅限于使用协议本身定义的属性和方法。如果我们想使用特定于单个类型的属性或方法，我们需要将实例转换为该类型。
- en: Typecasting with protocols
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议进行类型转换
- en: Typecasting is a way to check the type of the instance and/or to treat the instance
    as a specified type. In Swift, we use the `is` keyword to check whether an instance
    is a specific type, and the `as` keyword to treat the instance as a specific type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是一种检查实例类型和/或将实例视为指定类型的方法。在Swift中，我们使用`is`关键字来检查实例是否是特定类型，并使用`as`关键字将实例视为特定类型。
- en: 'To start, let''s see how we would check the instance type using the `is` keyword.
    The following example shows how this is done:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何使用`is`关键字检查实例类型。以下示例显示了如何进行此操作：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, we use the `if` conditional statement to check whether each
    element in the `people` array is an instance of the `SwiftProgrammer` type and,
    if so, we print that the person is a Swift programmer to the console. While this
    is a good method to check whether we have an instance of a specific class or structure,
    it is not very efficient if we want to check for multiple types. It would be more
    efficient to use a `switch` statement, as shown in the next example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`if`条件语句来检查`people`数组中的每个元素是否是`SwiftProgrammer`类型的实例，如果是，我们将打印出该人是Swift程序员到控制台。虽然这是一个检查我们是否有特定类或结构体实例的好方法，但如果我们要检查多个类型，则效率不高。使用`switch`语句会更高效，如下一个示例所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, we showed how to use the `switch` statement to check
    the instance type for each element of the array. To do this check, we use the
    `is` keyword in each of the `case` statements in an attempt to match the instance
    type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们展示了如何使用`switch`语句检查数组中每个元素的实例类型。为此检查，我们在每个`case`语句中使用`is`关键字尝试匹配实例类型。
- en: 'In *Chapter 6*, *Control Flow*, we saw how to filter conditional statements
    with the `where` statement. We can also use the `where` statement with the `is`
    keyword to filter the array, as shown in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*控制流*中，我们看到了如何使用`where`语句来过滤条件语句。我们还可以使用`where`语句与`is`关键字一起过滤数组，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s look at how we can cast an instance of a class or structure to a
    specific type. To do this, we would use the `as` keyword. Since the cast can fail
    if the instance is not of the specified type, the `as` keyword comes in two forms:
    `as?` and `as!`. With the `as?` form, if the casting fails, it returns `nil`,
    and with the `as!` form, if the casting fails, we get a runtime error. Therefore,
    it is recommended to use the `as?` form unless we are absolutely sure of the instance
    type or we perform a check of the instance type prior to doing the cast.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何将类或结构的实例转换为特定类型。为此，我们将使用`as`关键字。由于类型转换可能会失败，如果实例不是指定类型，则`as`关键字有两种形式：`as?`和`as!`。使用`as?`形式，如果转换失败，它返回`nil`，而使用`as!`形式，如果转换失败，我们得到运行时错误。因此，除非我们绝对确定实例类型或在我们进行转换之前检查实例类型，否则建议使用`as?`形式。
- en: While we do show examples of typecasting with `as!` in this book, so you are
    aware that it is there, we highly recommend that you do not use it in your projects
    because it can cause a runtime error.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书中展示了使用`as!`进行类型转换的示例，以便您了解它的存在，但我们强烈建议您不要在项目中使用它，因为它可能导致运行时错误。
- en: 'Let''s look at how we would use the `as?` keyword to cast an instance of a
    class or structure to a specified type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用`as?`关键字将类或结构的实例转换为指定类型：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the `as?` keyword returns an optional, we use optional binding to perform
    the cast, as shown in this example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`as?`关键字返回一个可选值，我们使用可选绑定来执行类型转换，如下面的示例所示。
- en: 'Now that we have covered the basics of protocols, let''s dive into one of the
    most exciting features of Swift: protocol extensions.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了协议的基础知识，让我们深入探讨Swift中最激动人心的特性之一：协议扩展。
- en: Protocol extensions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议扩展
- en: Protocol extensions allow us to extend a protocol to provide method and property
    implementations to conforming types. They also allow us to provide common implementations
    to all the conforming types, eliminating the need to provide an implementation
    in each individual type or the need to create a class hierarchy. While protocol
    extensions may not seem too exciting, once you see how powerful they really are,
    they will transform the way you think about and write code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 协议扩展使我们能够将协议扩展以提供符合类型的方法和属性实现。它们还允许我们为所有符合类型的提供通用实现，从而消除了在每个单独的类型中提供实现或创建类层次结构的需要。虽然协议扩展可能看起来并不太令人兴奋，但一旦你看到它们真正的强大之处，它们将改变你对代码思考和编写的看法。
- en: 'Let''s begin by looking at how we would use protocol extensions within a very
    simplistic example. We will start by defining a protocol named `Dog`, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何在一个非常简单的例子中使用协议扩展开始。我们将首先定义一个名为`Dog`的协议，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this protocol, we state that any type that conforms to the `Dog` protocol
    must have the two properties of the `String` type, named `name` and `color`. Next,
    let''s define the three types that conform to this `Dog` protocol. We will name
    these types `JackRussel`, `WhiteLab`, and `Mutt`. The following code shows how
    we would define these types:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此协议，我们声明任何符合`Dog`协议的类型都必须具有名为`name`和`color`的`String`类型的两个属性。接下来，让我们定义符合此`Dog`协议的三个类型。我们将这些类型命名为`JackRussel`、`WhiteLab`和`Mutt`。以下代码展示了我们如何定义这些类型：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We purposely created the `JackRussel` and `Mutt` types as structures and the
    `WhiteLab` type as a class to show the differences between how the two types are
    set up, and to illustrate how they are treated the same when it comes to protocols
    and protocol extensions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将`JackRussel`和`Mutt`类型创建为结构体，将`WhiteLab`类型创建为类，以展示两种类型设置的不同之处，并说明在协议和协议扩展方面它们是如何被同等对待的。
- en: The biggest difference we can see in this example is that structure types provide
    a default initiator, but in the class we must provide the initiator to populate
    the properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到最大的区别是结构体类型提供了一个默认的初始化器，但在类中我们必须提供初始化器来填充属性。
- en: 'Now let''s say that we want to provide a method named `speak` to each type
    that conforms to the protocol. Prior to protocol extensions, we would have started
    off by adding the method definition to the protocol, as shown in the following
    code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要为符合协议的每个类型提供一个名为`speak`的方法。在协议扩展之前，我们会在协议中添加方法定义，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the method is defined in the protocol, we would then need to provide an
    implementation of the method in every type that conforms to the protocol. Depending
    on the number of types that conformed to this protocol, this could take a bit
    of time to implement and it could affect a lot of code. The following code sample
    shows how we might implement this method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在协议中定义了方法，我们就需要在每个符合协议的类型中提供方法的实现。根据符合此协议的类型数量，这可能需要一些时间来实现，并且可能会影响大量的代码。以下代码示例展示了我们可能如何实现此方法：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While this method works, it is not very efficient because any time we update
    the protocol, we need to update all the types that conform to it, and therefore
    duplicate a lot of code, as shown in this example. If we need to change the default
    behavior of the `speak()` method, we would have to go into each implementation
    and change the method. This is where protocol extensions come in.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法有效，但效率并不高，因为每次我们更新协议时，都需要更新所有符合该协议的类型，因此会重复大量的代码，如本例所示。如果我们需要更改` speak()`方法的默认行为，我们就必须进入每个实现并更改该方法。这就是协议扩展发挥作用的地方。
- en: With protocol extensions, we could take the `speak()` method definition out
    of the protocol itself and define it with the default behavior in the protocol
    extension.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议扩展，我们可以将`speak()`方法定义从协议本身中提取出来，并在协议扩展中定义其默认行为。
- en: If we are implementing a method in a protocol extension, we are not required
    to define it in the protocol.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在协议扩展中实现一个方法，我们不需要在协议中定义它。
- en: 'The following code shows how we would define the protocol and the protocol
    extension:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何定义协议和协议扩展：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We begin by defining the `Dog` protocol with the original two properties. We
    then create a protocol extension that extends it and contains the default implementation
    of the `speak()` method. With this code, there is no need to provide an implementation
    of the `speak()` method in all of the types that conform to the `Dog` protocol
    because they automatically receive the implementation as part of the protocol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了具有原始两个属性的`Dog`协议。然后我们创建了一个扩展该协议的协议扩展，其中包含`speak()`方法的默认实现。使用这段代码，我们不需要在所有符合`Dog`协议的类型中提供`speak()`方法的实现，因为它们会自动作为协议的一部分接收该实现。
- en: 'Let''s see how this works by setting the three types that conform to the `Dog`
    protocol back to their original implementations; then they should receive the
    `speak()` method from the protocol extension:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将符合`Dog`协议的三个类型恢复到它们的原始实现来查看这是如何工作的；然后它们应该会从协议扩展中接收`speak()`方法：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now use each of the types, as shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用每种类型，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see in this example, by adding the `speak()` method to the `Dog`
    protocol extension, we are automatically adding that method to all the types that
    conform to the protocol. The `speak()` method in the protocol extension can be
    considered a default implementation of the method because we are able to override
    it in the type implementations. As an example, we could override the `speak()`
    method in the `Mutt` structure, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，通过将`speak()`方法添加到`Dog`协议扩展中，我们自动将该方法添加到所有符合该协议的类型中。协议扩展中的`speak()`方法可以被视为方法的默认实现，因为我们能够在类型实现中覆盖它。例如，我们可以在`Mutt`结构中覆盖`speak()`方法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we call the `speak()` method for an instance of the `Mutt` type, it will
    return the `I am hungry` string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`Mutt`类型的实例调用`speak()`方法时，它将返回`I am hungry`字符串。
- en: 'In this chapter, we named our protocols with the protocol suffix. This was
    done to make it very clear that this was a protocol. This is not how we would
    normally name our types. The following example gives a better example of how we
    would properly name protocols. You can read additional information about Swift''s
    naming conventions in the Swift API design guidelines: [https://swift.org/documentation/api-design-guidelines/#general-conventions](https://swift.org/documentation/api-design-guidelines/#general-conventions).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用协议后缀命名我们的协议。这样做是为了使这一点非常明确，这是一个协议。这通常不是我们命名类型的方式。以下示例给出了我们如何正确命名协议的更好示例。您可以在Swift
    API设计指南中阅读有关Swift命名约定的更多信息：[https://swift.org/documentation/api-design-guidelines/#general-conventions](https://swift.org/documentation/api-design-guidelines/#general-conventions)。
- en: Now that we have seen how to use protocols and protocol extensions, let's look
    at a more real-world example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用协议和协议扩展，让我们看看一个更贴近现实世界的例子。
- en: A real-world example
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: In numerous apps across multiple platforms (iOS, Android, and Windows), I have
    needed to validate user input as it is entered. This validation can be done very
    easily with regular expressions; however, we do not want various regular expressions
    littered throughout our code. It is very easy to solve this problem by creating
    different classes or structures that contain the validation code. However, we
    would have to organize these types to make them easy to use and maintain. Prior
    to protocol extensions in Swift, I would use a protocol to define the validation
    requirements and then create structures that would conform to the protocol for
    each validation that I needed. Let's look at this pre-protocol extension method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个平台（iOS、Android和Windows）的众多应用程序中，我需要在用户输入时验证用户输入。这种验证可以使用正则表达式非常容易地完成；然而，我们不希望在代码中散布各种正则表达式。通过创建包含验证代码的不同类或结构，可以很容易地解决这个问题。然而，我们必须组织这些类型，以便它们易于使用和维护。在Swift的协议扩展之前，我会使用一个协议来定义验证要求，然后为每个需要的验证创建符合该协议的结构。让我们看看这种方法在协议扩展之前是如何工作的。
- en: A regular expression is a sequence of characters that defines a particular pattern.
    This pattern can then be used to search a string to see whether the string matches
    the pattern or contains a match of the pattern. Most major programming languages
    contain a regular expression parser, and if you are not familiar with regular
    expressions, it may be worthwhile to learn more about them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一系列字符，它定义了一个特定的模式。然后可以使用该模式来搜索字符串，以查看字符串是否与模式匹配或包含模式匹配。大多数主要编程语言都包含正则表达式解析器，如果您不熟悉正则表达式，了解它们可能是有益的。
- en: 'The following code shows the `TextValidating` protocol that defines the requirements
    for any type that we want to use for text validation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `TextValidating` 协议，它定义了我们想要用于文本验证的任何类型的必要要求：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Swift API design guidelines ([https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/)
    ) state that protocols that describe what something is should be named as a noun,
    while protocols that describe a capability should be named with a suffix of -able,
    - ible, or -ing. With this in mind, we named the text validation protocol `TextValidating`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Swift API 设计指南（[https://swift.org/documentation/api-design-guidelines/](https://swift.org/documentation/api-design-guidelines/)）指出，描述“是什么”的协议应命名为名词，而描述“能做什么”的协议应使用后缀
    -able、-ible 或 -ing。考虑到这一点，我们命名文本验证协议为 `TextValidating`。
- en: 'In this protocol, we define three properties and two methods that any type
    that conforms to a protocol must implement. The three properties are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此协议中，我们定义了三个属性和两个方法，任何符合协议的类型都必须实现。这三个属性如下：
- en: '`regExMatchingString`: This is a regular expression string used to verify that
    the input string contains only valid characters.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regExMatchingString`：这是一个正则表达式字符串，用于验证输入字符串是否只包含有效字符。'
- en: '`regExFindMatchString`: This is a regular expression string used to retrieve
    a new string from the input string that contains only valid characters. This regular
    expression is generally used when we need to validate the input in real time as
    the user enters information, because it will find the longest matching prefix
    of the input string.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regExFindMatchString`：这是一个正则表达式字符串，用于从输入字符串中检索只包含有效字符的新字符串。此正则表达式通常在我们需要实时验证用户输入信息时使用，因为它将找到输入字符串的最长匹配前缀。'
- en: '`validationMessage`: This is the error message that''s displayed if the input
    string contains non-valid characters.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validationMessage`：这是如果输入字符串包含非有效字符时显示的错误信息。'
- en: 'The two methods for this protocol are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议的两个方法如下：
- en: '`validateString`: This method will return `true` if the input string contains
    only valid characters. The `regExMatchingString` property will be used in this
    method to perform the match.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validateString`：如果输入字符串只包含有效字符，则此方法将返回 `true`。在此方法中，将使用 `regExMatchingString`
    属性来执行匹配。'
- en: '`getMatchingString`: This method will return a new string that contains only
    valid characters. This method is generally used when we need to validate the input
    in real time as the user enters information because it will find the longest matching
    prefix of the input string. We will use the `regExFindMatchString` property in
    this method to retrieve the new string.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMatchingString`：此方法将返回一个只包含有效字符的新字符串。此方法通常在我们需要实时验证用户输入信息时使用，因为它将找到输入字符串的最长匹配前缀。我们将在此方法中使用
    `regExFindMatchString` 属性来检索新字符串。'
- en: 'Now let''s see how we can create a structure that conforms to this protocol.
    The following structure would be used to verify that the input string contains
    only alpha characters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何创建一个符合此协议的结构。以下结构将用于验证输入字符串是否只包含字母字符：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this implementation, the `regExFindMatchString` and `validationMessage` properties
    are stored properties, and the `regExMatchingString` property is a computed property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，`regExFindMatchString` 和 `validationMessage` 属性是存储属性，而 `regExMatchingString`
    属性是一个计算属性。
- en: We also implement the `validateString()` and `getMatchingString()` methods within
    the structure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在结构内部实现了 `validateString()` 和 `getMatchingString()` 方法。
- en: Normally, we would have several different types that conform to the protocol,
    where each one would validate a different type of input. As we can see from the
    `AlphaValidation1` structure, there is a bit of code involved with each validation
    type. A lot of the code would also be duplicated in each type. The code for both
    methods and the `regExMatchingString` property would probably be duplicated in
    every validation class. This is not ideal, but if we want to avoid creating a
    class hierarchy with a superclass that contains the duplicate code (it is recommended
    that we prefer value types over reference types), prior to protocol extensions,
    we had no other choice. Now let's see how we would implement this using protocol
    extensions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会有几个不同的类型符合协议，其中每个类型都会验证不同类型的输入。正如我们可以从 `AlphaValidation1` 结构中看到的那样，每个验证类型都涉及一些代码。大量的代码在每个类型中也会重复。方法和
    `regExMatchingString` 属性的代码可能会在每个验证类中重复。这并不理想，但如果我们想避免创建一个包含重复代码的超类类层次结构（建议我们优先使用值类型而不是引用类型），在协议扩展之前，我们别无选择。现在让我们看看我们如何使用协议扩展来实现这一点。
- en: With protocol extensions, we need to think about the code a little differently.
    The big difference is that we neither need nor want to define everything in the
    protocol. With standard protocols, all the methods and properties that you would
    want to access using a protocol interface would have to be defined within the
    protocol.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议扩展时，我们需要稍微改变一下对代码的思考方式。最大的不同是，我们既不需要也不希望定义协议中的所有内容。在标准协议中，所有你希望通过协议接口访问的方法和属性都必须在协议内部定义。
- en: 'With protocol extensions, it is preferable for us not to define a property
    or method in the protocol if we are going to be defining it within the protocol
    extension. Therefore, when we rewrite our text validation types with protocol
    extensions, `TextValidating` would be greatly simplified to look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议扩展时，如果我们打算在协议扩展中定义它，我们更倾向于不在协议中定义属性或方法。因此，当我们用协议扩展重写我们的文本验证类型时，`TextValidating`
    将大大简化，如下所示：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the original `TextValidating` protocol, we defined three properties and
    two methods. As we can see in this new protocol, we are only defining two properties.
    Now that we have our `TextValidating` protocol defined, let''s create the protocol
    extension for it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的 `TextValidating` 协议中，我们定义了三个属性和两个方法。正如我们可以从新的协议中看到的那样，我们现在只定义了两个属性。现在我们已经定义了
    `TextValidating` 协议，让我们为它创建协议扩展：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `TextValidating` protocol extension, we define the two methods and the
    property that were defined in the original `TextValidating` protocol but were
    not defined in the new one. Now that we have created the protocol and protocol
    extension, we are able to define our new text validation types. In the following
    code, we define three structures that we will use to validate text as a user types
    it in:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextValidating` 协议扩展中，我们定义了两个方法和一个属性，这些在原始的 `TextValidating` 协议中已经定义，但在新的协议中没有定义。现在我们已经创建了协议和协议扩展，我们能够定义我们新的文本验证类型。在下面的代码中，我们定义了三个结构，我们将使用这些结构来验证用户输入的文本：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In each of the text-validation structures, we create a static constant and a
    private initializer so that we can use the structure as a singleton. For more
    information on the singleton pattern, please see *The singleton design pattern*
    section of *Chapter 20*, *Adopting Design Patterns in Swift*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文本验证结构中，我们创建一个静态常量和私有初始化器，这样我们就可以将结构作为单例使用。有关单例模式的更多信息，请参阅 *《Swift中的设计模式采用》*
    第20章的 *“单例设计模式”* 部分。
- en: After we define the singleton pattern, all we do in each type is set the values
    for the `regExFindMatchString` and `validationMessage` properties. Now we have
    virtually no duplicate code. The only code that is duplicated is the code for
    the singleton pattern, and that is not something we would want to put in the protocol
    extension because we would not want to force the singleton pattern on all the
    conforming types.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了单例模式之后，在每个类型中我们只需设置 `regExFindMatchString` 和 `validationMessage` 属性的值。现在我们几乎没有任何重复的代码。唯一重复的代码是单例模式的代码，我们不会想在协议扩展中放入这些代码，因为我们不希望将单例模式强加给所有符合的类型。
- en: 'We can now use the text validation types, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用文本验证类型，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now the question is, do we really need to use protocols?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们真的需要使用协议吗？
- en: Do I need to use protocols?
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我需要使用协议吗？
- en: Do you need to use protocols and protocol extensions when you already know OOP?
    The short answer is no; however, it is highly recommended. In *Chapter 10*, *Protocol-Oriented
    Design*, we look at what makes protocol-oriented design so powerful to show you
    why you should prefer protocols with POP over OOP. By understanding protocols
    and protocol-oriented design, you will understand the Swift standard library better.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经知道面向对象编程（OOP）时，还需要使用协议和协议扩展吗？简短的答案是：不需要；然而，强烈推荐。在*第10章*，*协议导向设计*中，我们探讨了协议导向设计为何如此强大，以展示为什么你应该在协议导向编程（POP）中优先选择协议而不是面向对象编程（OOP）。通过理解协议和协议导向设计，你会更好地理解Swift标准库。
- en: Adopting protocols using a synthesized implementation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用合成实现采用协议
- en: Swift can automatically provide protocol conformance for the `Equatable`, `Hashable`,
    and `Comparable` protocols in specific cases. What this means is we do not need
    to write the boilerplate code to implement these protocols, and instead we can
    use the synthesized implementations. This only works if the structures or enumerations
    (not classes) contain only stored properties (for structures) or associated values
    (for enumerations) that conform to the `Equatable`, `Hashable`, and `Comparable`
    protocols.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Swift可以在特定情况下自动为`Equatable`、`Hashable`和`Comparable`协议提供协议遵循。这意味着我们不需要编写实现这些协议的样板代码，而是可以使用合成实现。这仅适用于结构体或枚举（不是类）只包含遵循`Equatable`、`Hashable`和`Comparable`协议的存储属性（对于结构体）或关联值（对于枚举）。
- en: The `Equatable`, `Hashable`, and `Comparable` protocols are provided by the
    Swift standard library. Any type that conforms to the `Equatable` protocols can
    use the equals operator (==) to compare two instances of the type. Any type that
    uses the `Comparable` protocol can use comparative operators to compare two instances
    of the type. Finally, any type that conforms to the `Hashable` protocol can be
    hashed into a `Hasher` instance to produce an integer hash.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Swift标准库提供了`Equatable`、`Hashable`和`Comparable`协议。任何遵循`Equatable`协议的类型都可以使用等号运算符（==）来比较该类型的两个实例。任何使用`Comparable`协议的类型都可以使用比较运算符来比较该类型的两个实例。最后，任何遵循`Hashable`协议的类型都可以被哈希到`Hasher`实例中，以生成一个整数哈希值。
- en: 'Let''s look at one example of this. We will start off by creating a simple
    structure that will store names:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们将从一个简单的结构体开始，该结构体将存储名称：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now create three instances of the `Name` structure, as shown in the
    following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建三个`Name`结构体的实例，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we tried to compare the instances of the `Name` structure, as shown in the
    following code, we could receive a compile-time error because the `Name` structure
    does not conform to the `Equatable` protocol:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试比较`Name`结构体的实例，如下面的代码所示，我们可能会收到编译时错误，因为`Name`结构体没有遵循`Equatable`协议：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In order to have the ability to compare instances of the `Name` structure,
    all that is needed is to state that the structure conforms to the `Equatable`
    protocol, and the boilerplate code to do the comparison will be automatically
    added at compile time. The following code shows us how this is done:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够比较`Name`结构体的实例，所需的所有操作就是声明该结构体遵循`Equatable`协议，编译时将自动添加执行比较的样板代码。下面的代码展示了如何实现这一点：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the only thing we changed was to add the `Equatable` protocol to
    the structure definition. We are now able to successfully compare instances of
    the `Name` structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们唯一改变的是将`Equatable`协议添加到结构体定义中。现在，我们能够成功比较`Name`结构体的实例。
- en: Swift's standard library
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift标准库
- en: The Swift standard library defines a base layer of functionality for writing
    Swift applications. Everything we have used so far in this book is from the Swift
    standard library. The library defines the fundamental data types, such as the
    `String`, `Int`, and `Double` types. It also defines collections, optionals, global
    functions, and all the protocols that these types conform to.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Swift标准库为编写Swift应用程序定义了一个基础功能层。在这本书中我们迄今为止使用的一切都来自Swift标准库。该库定义了基本数据类型，如`String`、`Int`和`Double`类型。它还定义了集合、可选类型、全局函数以及这些类型遵循的所有协议。
- en: One of the best sites to see everything that makes up the standard library is
    [http://swiftdoc.org](http://swiftdoc.org). This site lists all the types, protocols,
    operators, and globals that make up the standard library and contains documentation
    for all of it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看构成标准库的所有内容的最佳网站之一是[http://swiftdoc.org](http://swiftdoc.org)。该网站列出了构成标准库的所有类型、协议、运算符和全局变量，并包含了所有内容的文档。
- en: Let's look at how protocols are used in the standard library by looking at the
    documentation. When you first visit the home page, you will be greeted with a
    searchable list of everything that makes up the standard library. There is also
    a complete list of all Swift types that you can select from. Let's look at the
    Swift `Array` type by clicking on the **Array** link. This will take you to the
    documentation page for the `Array` type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看文档来了解标准库中协议的使用情况。当你第一次访问主页时，你会看到一个可搜索的列表，列出了构成标准库的所有内容。还有一个你可以从中选择的 Swift
    类型完整列表。让我们通过点击 **Array** 链接来查看 Swift 的 `Array` 类型。这将带你到 `Array` 类型的文档页面。
- en: 'These documentation pages are extremely useful and contain a lot of information
    about the various types that make up the standard library, including samples of
    how to use them. For our discussion, we are interested in the section labeled
    **Inheritance**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文档页面非常有用，包含大量关于构成标准库的各种类型的信息，包括如何使用它们的示例。对于我们讨论的目的，我们感兴趣的章节是标记为 **继承** 的部分：
- en: '![](img/B16683_09_01.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16683_09_01.png)'
- en: 'Figure 9.1: Documentation on Inheritance'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：继承文档
- en: From the inheritance section, we can see that the Array conforms to 7 protocols.
    If you click on some of the protocols, such as the `MutableCollection` protocol,
    you will notice that they conform to other protocols. This may not make a lot
    of sense at this point but in the next chapter, *Chapter 10*, *Protocol-Oriented
    Design*, we will look at how to design our applications and frameworks using a
    protocol-oriented approach, and then we will have a better understanding of how
    the Swift standard library is written.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从继承部分，我们可以看到 Array 符合 7 个协议。如果你点击一些协议，例如 `MutableCollection` 协议，你会注意到它们符合其他协议。这一点现在可能不太容易理解，但在下一章，即第
    10 章“面向协议设计”中，我们将探讨如何使用面向协议的方法来设计我们的应用程序和框架，然后我们将更好地理解 Swift 标准库是如何编写的。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that protocols are treated as full-fledged types by
    Swift. We also saw how polymorphism can be implemented in Swift with protocols.
    We concluded this chapter with an in-depth look at protocol extensions and saw
    how we would use them in Swift. Protocols and protocol extensions are the backbone
    of Apple's new POP paradigm. This new model for programming has the potential
    to change the way we write and think about code. While we did not specifically
    cover POP in this chapter, getting to grips with the topics in this chapter gives
    us the solid understanding of protocols and protocol extensions needed to learn
    about this new programming model. In the next chapter, we will look at how to
    use protocols and protocol extensions when we are designing our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 Swift 将协议视为完整的类型。我们还看到了如何在 Swift 中使用协议实现多态。我们通过深入探讨协议扩展以及如何在 Swift
    中使用它们来结束本章。协议和协议扩展是苹果新 POP（面向协议）范式的骨架。这种新的编程模型有可能改变我们编写和思考代码的方式。虽然我们本章没有专门介绍 POP，但掌握本章的主题为我们提供了学习这种新编程模型所需的关于协议和协议扩展的坚实基础。在下一章中，我们将探讨在设计我们的应用程序时如何使用协议和协议扩展。
