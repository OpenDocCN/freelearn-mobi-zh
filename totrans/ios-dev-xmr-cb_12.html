<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Multitasking</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting application states</li><li class="listitem" style="list-style-type: disc">Receiving notifications for the application states</li><li class="listitem" style="list-style-type: disc">Running code in the background</li><li class="listitem" style="list-style-type: disc">Playing audio in the background</li><li class="listitem" style="list-style-type: disc">Updating data in the background</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec106"/>Introduction</h1></div></div></div><p>When the iOS platform was introduced in 2007, it brought lots of exciting new features for users and drastically changed the concept of mobile devices.</p><p>Despite its huge success, it lacked some features at the time, which were considered <em>basic</em>. One of these features was multitasking, that is, support for running multiple processes at the same time. The platform actually did support multitasking to system processes internally, but it was not available to developers. Starting with iOS 4, Apple provided support for multitasking, although it is still quite different from what most developers <a id="id702" class="indexterm"/>are accustomed to.</p><p>In this chapter, we will discuss how to make use of the platform's multitasking features. We will see under what circumstances we can use these features and what functionality we can provide to the users of our apps through multitasking. Specifically, we will learn about an application's states and its runtime lifecycle. Through a series of detailed example projects, we will be able to execute code while an app is in the background, support audio playback, and receive data updates.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec107"/>Detecting application states</h1></div></div></div><p>In this recipe, we will discuss how to detect the state of the application and respond accordingly <a id="id703" class="indexterm"/>when an application is transited from the active to the inactive state and vice versa.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec432"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">AppStateApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec433"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following method override to the <code class="literal">AppDelegate</code> class:<div><pre class="programlisting">public override void OnActivated (UIApplication application)
{
  Console.WriteLine("Activated, application state: {0}", application.ApplicationState);	
}
public override void OnResignActivation (UIApplication application)
{
  Console.WriteLine("Resign activation, application state: {0}", application.ApplicationState);
}
public override void DidEnterBackground (UIApplication application)
{
  Console.WriteLine("Entered background, application state: {0}", application.ApplicationState);
}
public override void WillEnterForeground (UIApplication application)
{
  Console.WriteLine("Will enter foreground, application state: {0}", application.ApplicationState);
}</pre></div></li><li class="listitem">Compile and run the app either on the simulator or on the device. Press the home button (or press <em>Shift</em> + <em>Command</em> + <em>H</em> on the keyboard for the simulator) to suspend the app and watch the <strong>Application Output</strong> pad in Xamarin Studio.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec434"/>How it works...</h2></div></div></div><p>The <code class="literal">UIApplicationDelegate</code> class contains methods that are triggered at specific notifications issued by the runtime. These methods are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">OnActivated</code>: This <a id="id704" class="indexterm"/>method is called when the app is made active, for example, when unlocking the screen.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnResignActivation</code>: This method is called when the app is about to become<a id="id705" class="indexterm"/> inactive, for example, when the screen is locked or when an incoming call takes place.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DidEnterBackground</code>: This method is called when the app has entered the background, for example, when pressing the home button. At this time, the app<a id="id706" class="indexterm"/> is suspended.</li><li class="listitem" style="list-style-type: disc"><code class="literal">WillEnterForeground</code>: This method is called when the app is about to return<a id="id707" class="indexterm"/> to the foreground.</li></ul></div><p>Note that<a id="id708" class="indexterm"/> when the app is moved to the background, both the <code class="literal">OnResignActivation</code> and <code class="literal">DidEnterBackground</code> methods are called. Similarly, when the app is moved to the foreground, both the <code class="literal">WillEnterForeground</code> and <code class="literal">OnActivated</code> methods are called.</p><p>All these methods contain one parameter, which contains the <code class="literal">UIApplication</code> instance of the app. The <code class="literal">UIApplication</code> class contains the <code class="literal">ApplicationState</code> property, which returns the state of the app as values of the <code class="literal">UIApplicationState</code> property. These values are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Active</strong>: This indicates that the app is active</li><li class="listitem" style="list-style-type: disc"><strong>Inactive</strong>: This indicates that the app is inactive, for example, when a notification alert is displayed</li><li class="listitem" style="list-style-type: disc"><strong>Background</strong>: This indicates that the app is in the background</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec435"/>There's more...</h2></div></div></div><p>There are cases where iOS will kill your app, for example, when a memory warning is issued and your app does not free up resources. The <code class="literal">WillTerminate</code> method will be called in these cases.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec107"/>Proper usage</h3></div></div></div><p>The preceding methods are very useful because they allow us to save the current data that is presented to the user when the app changes its state. When the app is transited to an inactive or <a id="id709" class="indexterm"/>background state, each method is given a limited amount of time to execute, so we should make sure that it does not perform long-running operations, or else, iOS will kill the app.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec108"/>Receiving notifications for app states</h1></div></div></div><p>In this recipe, we will discuss how to get notified when the application's state changes outside<a id="id710" class="indexterm"/> the scope of the <code class="literal">UIApplicationDelegate</code> implementation.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec436"/>Getting ready</h2></div></div></div><p>Create a<a id="id711" class="indexterm"/> new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">NotifyStatesApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec437"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Enter the following fields in the <code class="literal">NotifyStatesAppViewController</code> class:<div><pre class="programlisting">private NSObject appDidEnterBackgroundObserver, appWillEnterForegroundObserver;</pre></div></li><li class="listitem">Create the following methods:<div><pre class="programlisting">private void AddNotificationObservers()
{
  this.appDidEnterBackgroundObserver = UIApplication.Notifications.ObserveDidEnterBackground((s, e) =&gt; Console.WriteLine("App did enter background! App state: {0}", UIApplication.SharedApplication.ApplicationState));
  this.appWillEnterForegroundObserver = UIApplication.Notifications.ObserveWillEnterForeground((s, e) =&gt; Console.WriteLine("App will enter foreground! App state: {0}", UIApplication.SharedApplication.ApplicationState));
}
private void RemoveNotificationObservers()
{
  NSNotificationCenter.DefaultCenter.RemoveObservers(new [] {
    this.appDidEnterBackgroundObserver,
    this.appWillEnterForegroundObserver
  });
}</pre></div></li><li class="listitem">In the <code class="literal">ViewWillAppear</code> override, call the <code class="literal">AddNotificationObservers</code> method as follows:<div><pre class="programlisting">public override void ViewWillAppear(bool animated) {
  base.ViewWillAppear(animated);
  this.AddNotificationObservers();
}</pre></div></li><li class="listitem">In the <code class="literal">ViewWillDisappear</code> override, call the <code class="literal">RemoveNotificationObservers</code> method as follows:<div><pre class="programlisting">public override void ViewWillDisappear(bool animated) {
  base.ViewWillDisappear(animated);
  this.RemoveNotificationObservers();
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Press the home button (or press <em>Shift</em> + <em>Command</em> + <em>H</em>), and watch the output in the <strong>Application Output</strong> pad.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec438"/>How it works...</h2></div></div></div><p>Apart <a id="id712" class="indexterm"/>from calling the methods of the <code class="literal">UIApplicationDelegate</code> object for app states, iOS issues notifications that we can receive. This <a id="id713" class="indexterm"/>is very useful, because in most cases, we need to be notified when the app's state changes outside the scope of the <code class="literal">AppDelegate</code> class.</p><p>To accomplish this, we use the <code class="literal">NSNotificationCenter</code> method through the <code class="literal">UIApplication.Notifications</code> class as follows:</p><div><pre class="programlisting">this.appDidEnterBackgroundObserver = UIApplication.Notifications.ObserveDidEnterBackground((s, e) =&gt; Console.WriteLine("App did enter background! App state: {0}", UIApplication.SharedApplication.ApplicationState));</pre></div><p>This example only adds notification observers for the transition between the background and foreground. We can add more notification observers through the other available <code class="literal">Observe*</code> methods.</p><p>The result is similar to the example used in the previous recipe, but in this case, we get notified inside the scope of our view controller.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec439"/>There's more...</h2></div></div></div><p>To add notification observers when the app is activated or when it resigns activation, we use the <code class="literal">UIApplication.Notifications.ObserveDidBecomeActive</code> and <code class="literal">UIApplication.Notifications.ObserveWillResignActive</code> methods, respectively.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec108"/>Removing notification observers</h3></div></div></div><p>In this<a id="id714" class="indexterm"/> example, we call <code class="literal">RemoveNotificaitonObservers</code> inside the <code class="literal">ViewWillAppear</code> method. However, the method is not being called when the app is transited to the background but only when we display another view controller.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec440"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Detecting application states</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec109"/>Running code in the background</h1></div></div></div><p>In this <a id="id715" class="indexterm"/>recipe, we will learn how to execute code in the background, taking full advantage of iOS's multitasking feature.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec441"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">BackgroundCodeApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec442"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Enter the following code in the <code class="literal">AppDelegate</code> class:<div><pre class="programlisting">private int taskID;
public override void DidEnterBackground (UIApplication application)
{
  if (this.taskID == 0)
  {
    this.taskID = application.BeginBackgroundTask(() =&gt; {
      application.EndBackgroundTask(this.taskID);
      this.taskID = 0;
    });
    ThreadPool.QueueUserWorkItem(delegate {
      for (int i = 0; i &lt; 60; i++)
      {
        Console.WriteLine("Task {0} - Current time {1}", this.taskID, DateTime.Now);
        Thread.Sleep(1000);
      }
      application.EndBackgroundTask(this.taskID);
      this.taskID = 0;
    });
  }
}
public override void WillEnterForeground (UIApplication application)
{
  if (this.taskID != 0)
  {
    Console.WriteLine("Background task is running!");
  } else
  {
    Console.WriteLine("Background task completed!");
  }
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Press the home button (<em>Command</em> + <em>Shift</em> + <em>H</em>) to make the app enter the background and watch the <strong>Application Output</strong> pad. Before the background task is completed (1 minute), bring the app to the foreground by either tapping on its icon in the multitasking bar or on its icon on the home screen.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec443"/>How it works...</h2></div></div></div><p>In the <a id="id716" class="indexterm"/>previous tasks, we learned how to get informed when an app gets transited from the foreground to the background and vice versa.</p><p>Multitasking on iOS is not quite what we are used to on other platforms. The iOS platform helps us makes sure that the foreground app will have all the available resources at its disposal (and the user's). To accomplish this, when the app enters the background, it is being suspended by the operating system. When it is suspended, it does not execute any code whatsoever.</p><p>If we want to prevent the app from being suspended when the user presses the home button, we can ask for background time. The time we ask for is limited to 600 seconds (10 minutes), which is more than enough for the majority of tasks we are likely to perform in the background (for example, saving the UI state, completing a file download/upload, closing any open connections, and so on).</p><p>To ask for the background time, we call the <code class="literal">BeginBackgroundTask</code> method of our <code class="literal">UIApplication</code> instance as follows:</p><div><pre class="programlisting">this.taskID = application.BeginBackgroundTask(() =&gt; {
  application.EndBackgroundTask(taskID);
  this.taskID = 0;
} );</pre></div><p>The method accepts one parameter of the <code class="literal">NSAction</code> type and returns an integer, which corresponds to the task ID. The <code class="literal">NSAction</code> parameter represents the block of code that will be executed just before the background time elapses. Inside that block of code, we have to call the <code class="literal">EndBackgroundTask</code> method, passing the ID of the task that was started, which will inform the runtime that we no longer need the background time. Each call of <code class="literal">BeginBackgroundTask</code> should be followed by a call to <code class="literal">EndBackgroundTask</code>. If we do not call this method and the background time elapses, the app will be terminated.</p><p>After calling the <code class="literal">BeginBackgroundTask</code> method, we can execute the code we want. To allow the <code class="literal">DidEnterBackground</code> method to complete and to avoid blocking the main thread, we just enclose our code to either an asynchronous call or in a separate thread. In this example, we use a thread from <code class="literal">ThreadPool</code>. As this specific task will be completed before the time in which we have the elapses, we call the <code class="literal">EndBackgroundTask</code> method to let the system know that the job is done. The block of code that we passed to the <code class="literal">BeginBackgroundTask</code> method will not be executed as we ended the task.</p><p>There are <a id="id717" class="indexterm"/>cases however, where the user might bring the app to the foreground while a background task is still running. To cover this scenario, we need to override the <code class="literal">WillEnterForeground</code> method and handle it in an appropriate manner. We can either stop the background task (by calling <code class="literal">EndBackgroundTask</code>), or provide some sort of feedback to the user that a task is still running. This scenario also makes the use of an asynchronous call to our code, which is the best practice. If the code of our background task is synchronous, then when the user brings the app to the foreground and the task is still running, the app will be frozen until the task is completed.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec444"/>There's more...</h2></div></div></div><p>To know how much time is left to perform the background tasks, we can check the value of the <code class="literal">BackgroundTimeRemaining</code> property as follows:</p><div><pre class="programlisting">Console.WriteLine("Remaining time: {0}", application.BackgroundTimeRemaining);</pre></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec109"/>Important considerations for the background code</h3></div></div></div><p>The<a id="id718" class="indexterm"/> following are the important points to be considered when you are working with the background code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Do not update the UI while the app is in the background. Doing so may cause your app to terminate or crash. Any updates to UI elements that take place while the app is in the background are queued to be performed when it returns to the foreground. This will surely make the app unresponsive.</li><li class="listitem" style="list-style-type: disc">Do not inform the user to bring your app to the foreground just to give more time to the task. Doing so will surely get your app rejected from the app store's approval process. If a background task is in progress and the user brings the app to the foreground, moving the app back to the background again basically continues the remaining background time.</li><li class="listitem" style="list-style-type: disc">Perform lightweight operations in the background to avoid the runtime from killing your app.</li><li class="listitem" style="list-style-type: disc">Avoid <a id="id719" class="indexterm"/>using external resources (for example, resources from the assets library).</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec445"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Detecting application states</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Playing audio in the background</h1></div></div></div><p>In this recipe, we will learn how to prevent the app from being suspended in order to allow audio playback.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec446"/>Getting ready</h2></div></div></div><p>Create a<a id="id720" class="indexterm"/> new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">BackgroundAudioApp</code>. Add a button on the view of the controller. You will also need an audio file. In this example, an M4A file with a duration of 21 seconds is used.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec447"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Double-click on the <code class="literal">Info.plist</code> file to open it. Select the <strong>Source</strong> tab at the bottom and add the <code class="literal">UIBackgroundModes</code> key (<strong>Required background modes</strong>) with the string value audio. The following screenshot shows you how the key and value are shown in the editor after they have been set:<div><img src="img/8924OT_12_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Add the <code class="literal">MonoTouch.AVFoundation</code> namespace in the <code class="literal">BackgroundAudioAppViewController.cs</code> file.</li><li class="listitem">Enter the following <code class="literal">ViewDidLoad</code> method in the class:<div><pre class="programlisting">private AVAudioPlayer audioPlayer;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  NSError error = null;
  AVAudioSession.SharedInstance().SetCategory(AVAudioSession.CategoryPlayback, out error);
  if (error != null)
  {
    Console.WriteLine("Error setting audio session category: {0}", error.LocalizedDescription);
  }
  this.audioPlayer = AVAudioPlayer.FromUrl(NSUrl.FromFilename("sound.m4a"));
  this.btnPlay.TouchUpInside += (sender, e) =&gt; this.audioPlayer.Play();
}</pre></div></li><li class="listitem">Add a sound file to the project and set its <strong>Build Action</strong> to <strong>Content</strong>.</li><li class="listitem">Compile and run the app on the device. Tap the <strong>Play sound</strong> button and press the home button to make the app enter the background. Notice that the sound continues playing.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec448"/>How it works...</h2></div></div></div><p>To make <a id="id721" class="indexterm"/>sure that our app will be able to play the audio while it is in the background, we have to set the audio item in the <code class="literal">UIBackgroundModes </code>key in the <code class="literal">Info.plist</code> file.</p><p>In this example, we used the <code class="literal">AVAudioPlayer</code> class to play a sound file. Just creating an instance of the class and calling its <code class="literal">Play</code> method is not enough, though. We have to set a specific type for the audio session category. We will do this with the help of the following code:</p><div><pre class="programlisting">NSError error = null;
AVAudioSession.SharedInstance ().SetCategory (AVAudioSession.CategoryPlayback, out error);</pre></div><p>The static <code class="literal">AVAudioSession.SharedInstance</code> method returns the current audio session object. The audio session category is set to <code class="literal">AVAudioSession.CategoryPlayback</code>, which allows the <code class="literal">AVAudioPlayer</code> class to play sounds while the app is in the background. This requirement is specific to objects in the <code class="literal">MonoTouch.AVFoundation</code> namespace.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec449"/>There's more...</h2></div></div></div><p>The following are the available audio session categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryAmbient</code>: In this category, sounds are silenced when the device screen is locked or when the device's silence switch is on. Sounds from external resources (such as the iPod app) are mixed with this category.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CategorySoloAmbient</code>: This is the default category. Sounds from external resources are silenced with this category. Sounds are silenced when the screen is locked or when the device's silent switch is on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryPlayback</code>: In this category, sounds are not silenced when the screen is locked or when the silent switch is on. Sounds from external resources <a id="id722" class="indexterm"/>are silenced but can be mixed if the <code class="literal">MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers</code> property is set to <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryRecord</code>: This category is for recording audio. All the audio playback is silenced. The recording continues even when the screen is locked.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryPlayAndRecord</code>: This category is for apps that need to record and play audio. Sounds from external resources are silenced but can be mixed if the <code class="literal">MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers</code> property is set to <code class="literal">tru</code>e. Sounds continue to play when the screen is locked or when the silent switch is on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CategoryAudioProcessing</code>: This category is specific to processing audio. Sound playback and recording is disabled in this category.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec110"/>The background state for audio</h3></div></div></div><p>Even <a id="id723" class="indexterm"/>when the app is configured through the <code class="literal">Info.plist</code> file to support the background audio playback, the app will be suspended when the playback is completed.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec450"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Location services in the background</em> recipe in <a class="link" href="ch10.html" title="Chapter 10. Location Services and Maps">Chapter 10</a>, <em>Location Services and Maps</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Updating data in the background</h1></div></div></div><p>In this recipe, we will learn how to make use of iOS 7's <strong>background fetch</strong> feature. This feature <a id="id724" class="indexterm"/>automatically wakes up the app at system-managed intervals, giving it a specific amount of time to retrieve data and update the UI.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec451"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">BackgroundFetchApp</code>. Add a label to the controller.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec452"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">We<a id="id725" class="indexterm"/> need access to the label from outside of the scope of the <code class="literal">BackgroundFetchAppViewController</code> class, so create a public property for it as follows:<div><pre class="programlisting">public UILabel LabelStatus {
  get { return this.lblStatus; }
}</pre></div></li><li class="listitem">Open the <code class="literal">Info.plist</code> file and under the <strong>Source</strong> tab, add the <code class="literal">UIBackgroundModes</code> key (<strong>Required background modes</strong>) with the string value, <code class="literal">fetch</code>. The following screenshot shows you the editor after it has been set:<div><img src="img/8924OT_12_02.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">FinishedLaunching</code> method of the <code class="literal">AppDelegate</code> class, enter the following line:<div><pre class="programlisting">UIApplication.SharedApplication.SetMinimumBackgroundFetchInterval(UIApplication.BackgroundFetchIntervalMinimum);</pre></div></li><li class="listitem">Enter the following code, again, in the <code class="literal">AppDelegate</code> class:<div><pre class="programlisting">private int updateCount;
public override void PerformFetch (UIApplication application, Action&lt;UIBackgroundFetchResult&gt; completionHandler)
{
  try {
    HttpWebRequest request = WebRequest.Create("http://software.tavlikos.com") as HttpWebRequest;
    using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream())) {
      Console.WriteLine("Received response: {0}", sr.ReadToEnd());
    }
    this.viewController.LabelStatus.Text = string.Format("Update count: {0}/n{1}", ++updateCount, DateTime.Now);
    completionHandler(UIBackgroundFetchResult.NewData);

  } catch {
    this.viewController.LabelStatus.Text = string.Format("Update {0} failed at {1}!", ++updateCount, DateTime.Now);
    completionHandler(UIBackgroundFetchResult.Failed);
  }
}</pre></div></li><li class="listitem">Compile and run the app on the simulator or on the device. Press the home button (or <em>Command</em> + <em>Shift</em> + <em>H</em>) to move the app to the background and wait for an output. This might take a while, though.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec453"/>How it works...</h2></div></div></div><p>The <code class="literal">UIBackgroundModes</code> key with the <code class="literal">fetch</code> value enables the background fetch functionality <a id="id726" class="indexterm"/>for our app. Without setting it, the app will not wake up in the background.</p><p>After setting the key in <code class="literal">Info.plist</code>, we override the <code class="literal">PerformFetch</code> method in the <code class="literal">AppDelegate</code> class, as follows:</p><div><pre class="programlisting">public override void PerformFetch (UIApplication application, Action&lt;UIBackgroundFetchResult&gt; completionHandler)</pre></div><p>This method is called whenever the system wakes up the app. Inside this method, we can connect to a server and retrieve the data we need. An important thing to note here is that we do not have to use iOS-specific APIs to connect to a server. In this example, a simple <code class="literal">HttpWebRequest</code> method is used to fetch the contents of this blog: <a class="ulink" href="http://software.tavlikos.com">http://software.tavlikos.com</a>.</p><p>After we have received the data we need, we must call the callback that is passed to the method, as follows:</p><div><pre class="programlisting">completionHandler(UIBackgroundFetchResult.NewData);</pre></div><p>We also need to pass the result of the fetch. In this example, we pass <code class="literal">UIBackgroundFetchResult.NewData</code> if the update is successful and <code class="literal">UIBackgroundFetchResult.Failed</code> if an exception occurs.</p><p>If we do not call the callback in the specified amount of time, the app will be terminated. Furthermore, it might get fewer opportunities to fetch the data in the future.</p><p>Lastly, to make sure that everything works correctly, we have to set the interval at which the app will be woken up, as follows:</p><div><pre class="programlisting">UIApplication.SharedApplication.SetMinimumBackgroundFetchInterval(UIApplication.BackgroundFetchIntervalMinimum);</pre></div><p>The default interval is <code class="literal">UIApplication.BackgroundFetchIntervalNever</code>, so if we do not set an interval, the background fetch will never be triggered.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec454"/>There's more</h2></div></div></div><p>Except for the functionality we added in this project, the background fetch is completely managed by the system. The interval we set is merely an indication and the only guarantee <a id="id727" class="indexterm"/>we have is that it will not be triggered sooner than the interval. In general, the system monitors the usage of all apps and will make sure to trigger the background fetch according to how often the apps are used.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>Apart from the predefined values, we can pass whatever value we want in seconds.</p></div></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec111"/>UI updates</h3></div></div></div><p>We can <a id="id728" class="indexterm"/>update the UI in the <code class="literal">PerformFetch</code> method. iOS allows this so that the app's screenshot is updated while the app is in the background. However, note that we need to keep UI updates to the absolute minimum.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec455"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Running code in the background</em> recipe</li></ul></div></div></div></body></html>