<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Reaching a Wider Audience &#x2013; Supporting Multiple Devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Reaching a Wider Audience – Supporting Multiple Devices</h1></div></div></div><p>Android is a mobile operating system that places very few restrictions on hardware. Manufacturers are free to create Android devices that are packed with high-end hardware such as DSLR-worthy cameras, huge internal memories, and lightning-fast CPUs; or they can create more budget-friendly devices that take a no-frills approach to hardware. Android screens can also come in all sorts of sizes, shapes, and screen densities.</p><p>The only thing these devices have in common is that they all run the Android operating system—and even in this, Android smartphones and tablets are inconsistent. The current Android smartphone and tablet market is made up of lots of different versions of the Android operating system—from legacy versions, right through to the very latest release of Android. And even if two devices are running exactly the same version of Android, there's no guarantee that they'll be exactly the same, as manufacturers have a nasty habit of tweaking the Android operating system to come up with their own <span class="strong"><strong>original equipment manufacturer</strong></span> (<span class="strong"><strong>OEM</strong></span>) versions. A Samsung smartphone running Android 7.0 may not necessarily be the same as a Sony smartphone running Android 7.0.</p><p>This flexibility is great for manufacturers who can make their devices stand out from the competition by coming up with new and innovative hardware, software, and screen configurations. It's also good news for consumers who can shop around and find exactly the Android device that's right for them.</p><p>But is this good for developers? <span class="emphasis"><em>Sort of</em></span>.</p><p>All these variations on hardware, software, and screen configuration mean lots of opportunities to innovate and come up with a truly original app. However, it also poses a massive challenge, as you'll need to create an app that provides a consistent experience across all the different hardware, software, and screen configurations that your app might encounter.</p><p>Unfortunately, there's no quick fix. Essentially, the key to creating a flexible UI is to provide a wide range of alternate resources that are optimized for all the different hardware, software, screen configurations, languages, and region settings that your app may encounter, which is arguably the most time-consuming part of Android app development.</p><p>In this chapter, I'm going to cover all the major aspects you need to bear in mind, if you're going to create a flexible app that's compatible with as many different Android devices as possible.</p><div class="section" title="Supporting different versions of Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Supporting different versions of Android</h1></div></div></div><p>While most new versions of the Android platform introduce exciting new features that you'll be desperate to use in your app, if you're going to reach the widest possible audience then you'll also need to support as many older versions of the Android platform as possible.</p><p>This is a delicate balancing act. Supporting older versions of the Android platform takes time and effort, and the further you go, the harder you'll have to work to get your app playing nicely with older versions of Android.</p><p>If you continue striving to support older and older versions of Android, at some point you'll inevitably find yourself compromising your app's UI, functionality, and general user experience as you encounter versions of Android that simply aren't powerful enough to support the kind of app you originally wanted to create. In our recipe app example, we're relying on the device being powerful enough to load multiple high-res images whenever the user performs a search. If the user is running an older version of the Android operating system, processing these images may cause the search results to load more slowly. Although the problem lies with the user's device, your typical Android user is far more likely to blame your app than their outdated smartphone or tablet.</p><p>We could shrink the images or even remove them completely, but would you want to try a recipe when you hadn't even seen a photo of the finished product? At this point, you should take a step back and ask yourself whether all this time, effort, and compromise is really <span class="emphasis"><em>worth it</em></span>.</p><p>To identify the point at which supporting older versions of Android becomes more trouble than it's worth, you'll need to look at the current Android market—especially how many devices are running each version of the Android operating system. Once you have this information in front of you, you can make an informed decision about the point at which it no longer makes sense to keep supporting the older versions of Android.</p><p>One source of this information is Google's Dashboard (<a class="ulink" href="http://developer.android.com/about/dashboards/index.html">http://developer.android.com/about/dashboards/index.html</a>), which gives you a percentage of the relative number of devices running each version of Android. Just be aware that this information is gathered in a very specific way. It's essentially a snapshot of all the devices that visited the Google Play store in the previous 7 days. This data is collected from the Google Play app, and is not necessarily representative of the current state of the entire Android market. It's also worth noting that the Google Play app is only compatible with Android 2.2 and higher, so any device running versions of Android lower than 2.2 aren't included in this data; although according to Google way back in August 2013, devices running versions lower than Android 2.2 only accounted for about 1% of devices, so we're talking about a very small percentage here.</p><p>Spend some time exploring the Dashboard data, and come to a decision about which versions of Android you're going to support and which versions you aren't.</p><div class="section" title="Specifying minimum and target API levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec99"/>Specifying minimum and target API levels</h2></div></div></div><p>Once you've decided what versions of Android you're going to support, you need to include this information in your project. How you add this information will vary depending on the IDE you're using, so you'll need to open one of the following files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manifest file (Eclipse)</li><li class="listitem" style="list-style-type: disc">Module-level <code class="literal">build.gradle</code> file (Android Studio)</li></ul></div><p>We will discuss the components of this file in the next section.</p><div class="section" title="minSdkVersion"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec58"/>minSdkVersion</h3></div></div></div><p>This attribute identifies the lowest API level that your app is compatible with, for example, <code class="literal">minSdkVersion 16</code>. Google Play will use your app's <code class="literal">minSdkVersion</code> attribute to determine whether a user can install it on device.</p><p>When debating your app's <code class="literal">minSdkVersion</code> value, make sure you consult the Dashboard stats as this provides a snapshot of your potential audience. Ultimately, you'll need to decide whether supporting each additional slice of this audience is worth additional time and effort.</p></div><div class="section" title="targetSdkVersion"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec59"/>targetSdkVersion</h3></div></div></div><p>This attribute identifies the highest API level that you've tested your app against.</p><p>The <code class="literal">targetSdkVersion</code> value is particularly important for forward compatibility, as the system won't apply any behavior changes introduced in new Android releases until you update your app's <code class="literal">targetSdkVersion</code> value. To ensure your app benefits from the latest Android features, you should aim to set your app's <code class="literal">targetSdkVersion</code> value to the very latest version of Android. Updating your app to target a new SDK should always be a high priority whenever Google release a new version of Android, but you should only do this after thoroughly testing your app against the latest SDK release. <span class="emphasis"><em>Never</em></span> blindly update your <code class="literal">targetSdkVersion</code> value without testing it first.</p><p>Ideally your <code class="literal">targetSdkVersion</code> and <code class="literal">compileSdkVersion</code> value should always correspond to the very latest version of the Android SDK.</p></div><div class="section" title="compileSdkVersion"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec60"/>compileSdkVersion</h3></div></div></div><p>This attribute tells Gradle what version of Android SDK it should compile your app with.</p><p>Your <code class="literal">compileSdkVersion</code> value is not included in your published APK; it's purely used at compile time. Changing your <code class="literal">compileSdkVersion</code> value does <span class="emphasis"><em>not</em></span> change the runtime behavior, so it's recommended you always compile with the latest SDK.</p></div></div><div class="section" title="Check version at runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Check version at runtime</h2></div></div></div><p>Sometimes, you'll have a clear cut-off point where it makes sense for your app to stop supporting earlier versions of Android, but this line may not always be so clear cut.</p><p>Imagine your app includes a non-essential feature that isn't supported on Android 5.0 and earlier versions, but apart from this feature, your app is compatible with earlier versions of Android. Since this Marshmallow-and-higher feature isn't essential, it doesn't make sense to prevent everyone running Android 5.0 or earlier versions from installing your app. In this scenario, you can disable this feature by ensuring any code that depends on higher API levels is only executed when these APIs are available. Basically, this feature won't be available to users who are running Android 5.0 or a lower version, but these users will still be able to install and use your app.</p><p>You achieve this using the <code class="literal">Build</code> constants class to specify when the related code should run; for example, the following code verifies whether your app is running on Lollipop or a higher version:</p><pre class="programlisting">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#13;
</pre><p>Android provides a unique code for each platform version, which you should use alongside the <code class="literal">Build</code> constants class (in this example, the code is <code class="literal">LOLLIPOP</code>). You'll find a complete list of these codes at the official Android docs (<a class="ulink" href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html">http://developer.android.com/reference/android/os/Build.VERSION_CODES.html</a>).</p></div></div></div>
<div class="section" title="Supporting different screens"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Supporting different screens</h1></div></div></div><p>Android devices come in many different shapes and sizes. Your task, as a developer, is to create a UI that looks just as good on the small space available to a budget-friendly smartphone, as it does on the large space available to a top-of-the-line Android tablet and everything in between.</p><p>So let's break it down. Android categorizes screens in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Screen sizes</strong></span>: Traditionally, Android supported four generalized screen sizes: <code class="literal">small</code>, <code class="literal">normal</code>, <code class="literal">large</code>, and <code class="literal">xlarge</code>. However, Android 3.2 (API level 13) introduced some new configuration qualifiers that allow you to be more specific about screen sizes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Screen densities</strong></span>: A device's screen density is a combination of its resolution and display size, and is measured in <span class="strong"><strong>dots per inch</strong></span> (<span class="strong"><strong>dpi</strong></span>). The higher a device's dpi, the smaller each individual pixel, which means greater clarity and more detail per inch. Android supports six generalized densities: low (<code class="literal">ldpi</code>), medium (<code class="literal">mdpi</code>), high (<code class="literal">hdpi</code>), extra high (<code class="literal">xhdpi</code>), extra-extra-high (<code class="literal">xxhdpi</code>), and extra-extra-extra-high (<code class="literal">xxxhdpi</code>).</li></ul></div><p>You can anticipate that your app will be installed on devices spanning a wide range of screen sizes and densities. And you should aim high; it's not good enough for your app to be compatible with these different screen configurations, you should give users the impression that your app was designed specifically for their particular screen, whatever size and density that screen happens to be.</p><p>In this section, I'll show you how to create an app that can handle a wide range of different sizes and densities. The underlying theme you'll encounter time and time again is that your app's layout and drawables must render at a size that's appropriate for the current screen. The Android system is clever enough to handle most of this rendering work automatically, and it will scale your layouts and resources to fit the current size and density, but you shouldn't rely on the Android system to do all the hard work for you.</p><p>Android's automatic rendering alone won't provide the best possible user experience. You'll need to give it a hand by providing multiple versions of your app's resources that are optimized for different screen sizes and densities. These resources could be strings, layouts, graphics, or any other static resources that your app requires.</p><p>To add these resources to your project, you'll need to create alternate versions of your project's directories, and then tag them with the correct configuration qualifiers; for example, if you have a layout that's optimized for landscape orientation, you'll need to create a <code class="literal">res/layout-land</code> directory, and then place your landscape layout file inside this directory. Then, when a user runs your app, the Android system will automatically load the resource that best matches the current screen configuration, whether that's the default layout or your landscape-optimized <code class="literal">res/layout-land</code> layout.</p><div class="section" title="Configuration qualifiers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Configuration qualifiers</h2></div></div></div><p>Android supports a wide range of configuration qualifiers that you can append to your project's resource directories. These configuration qualifiers are the key to controlling which version of a resource the system displays.</p><p>Configuration qualifiers specify the characteristics that a resource was designed for, such as an image that was designed for a particular screen size or screen density. You'll find a complete list of valid configuration qualifiers in the official Android docs, specifically <span class="strong"><strong>Table 2</strong></span> of the <span class="strong"><strong>Providing Resources</strong></span> page (<a class="ulink" href="http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources">http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources</a>).</p><p>The configuration qualifiers you'll need to use will vary depending on your app and the kind of devices you're targeting, but as a minimum, you'll typically use size, density, and screen orientation qualifiers to provide drawable resources and layouts that are optimized for different screen configurations.</p><p>To use a configuration qualifier, create a new directory in your project's <code class="literal">res/</code> directory and name it using the following format:</p><pre class="programlisting">&lt;resources_name&gt;-&lt;config_qualifier&gt; &#13;
</pre><p>So, if you were creating a directory to hold layouts that were optimized for devices held in landscape mode, you'd use the <code class="literal">land</code> qualifier and create a <code class="literal">res/layout-land</code> directory, then place your layout-optimized layouts inside this directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>Never place any resources directly inside your project's <code class="literal">res/</code> directory as this will cause a compiler error. You also cannot nest alternative resources, so you cannot create a <code class="literal">res/drawable/drawable-xxhdpi/</code> directory.</p></div></div><p>You can use more than one qualifier at a time by separating each qualifier with a dash; for example, a <code class="literal">res/drawable-en-hdpi</code> directory would contain drawable resources that are designed for devices set to the English language (<code class="literal">en</code>) with a screen density that falls into the high-density bucket. If you do use multiple qualifiers, the order they appear in your directory name is crucial. They must appear in the same order as in the <span class="strong"><strong>Providing Resources</strong></span> page (<a class="ulink" href="http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources">http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources</a>). If you use qualifiers in the wrong order, the Android system won't recognize the directory, and will subsequently ignore all the resources that it contains.</p><p>Don't worry about the case you use for your directory names, as the resource compiler converts directory names into lowercase before processing anyway. If your project includes directories with long-winded names consisting of multiple configuration qualifiers, then you may want to take advantage of this automatic conversion, and use capitalization to make your directory names easier to read.</p><p>Naming is also important for the resources that you place inside your directories. When you create multiple versions of the same resource, they must all have exactly the same name as the default resource. Any variation and the Android system won't recognize them as alternate versions of the same resource.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>If your project contains resources that the system should <span class="emphasis"><em>never</em></span> scale to suit the current screen configuration, place these resources in a directory with the <code class="literal">nodpi</code> configuration qualifier, for example, <code class="literal">res/drawable-nodpi</code>.</p></div></div><div class="section" title="How Android selects the perfect resource"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec61"/>How Android selects the perfect resource</h3></div></div></div><p>When your app features multiple versions of the same resource, the Android system follows a strict set of rules when deciding which version it should display at runtime.</p><p>When the Android system is looking for a resource based on the screen size or density, it starts by searching for an exact match that it can display without scaling. If it can't find a suitable size or the density-specific version, then Android switches to plan <span class="emphasis"><em>B</em></span> and searches for a version that's designed for screens smaller than the current screen.</p><p>If the only available resources are larger than the current screen, the system will use the default version of the resource instead. The Android system assumes that your project's default resources are designed for the baseline screen size and density, which is a <code class="literal">normal</code> size and medium-density. Therefore, the system scales default resources up for high-density or larger screens, and down for low-density screens.</p><p>If the system can't find a suitable density-specific resource, or even a default version of the required resource, then your app will crash—which is why it's essential that you provide a default version of <span class="emphasis"><em>every</em></span> resource.</p><p>Even if you're confident that you've provided all the alternative resources your project could ever need, it's possible that your app may wind up on a device that has hardware, software, screen size, screen density, or language settings that you hadn't anticipated and therefore didn't provide specific resources for. In this scenario, the system may fall back on your project's default resources, and if your app doesn't include these default resources, then your app will crash.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>Default resources are all the resources that are stored in a directory without a configuration qualifier, such as <code class="literal">res/drawable</code>.</p></div></div></div><div class="section" title="Creating alias resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec62"/>Creating alias resources</h3></div></div></div><p>Sometimes, you'll have a resource that's suitable for more than one configuration qualifier; for example, you might have a drawable that you want to add to both your project's <code class="literal">res/drawable-hdpi</code> and <code class="literal">res/drawable-xhdpi</code> directories.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>You can't create a directory that uses multiple configuration qualifiers of the same type, so it's not possible to create a <code class="literal">res/drawable-hdpi-xhdpi</code> directory.</p></div></div><p>You could copy/paste the resource so that it appears in both directories; but this isn't very efficient, plus duplicating resources increases the size of your project, which is bad news for your end users. The best solution is to use an <span class="strong"><strong>alias</strong></span>.</p><p>Imagine you have a <code class="literal">scene.png</code> drawable that you want to use for both <code class="literal">hdpi</code> and <code class="literal">xhdpi</code> screens; this is the perfect opportunity to use an alias. In this scenario, you need to place the default version inside your project's <code class="literal">res/drawable</code> folder as normal. Then, save the version of the image you want to use for <code class="literal">hdpi</code> and <code class="literal">xhdpi </code>screens inside the <code class="literal">res/drawable</code> folder, but give it a different name to the default resource, for example, <code class="literal">scenery_alias.png</code>.</p><p>At this point, you have two drawables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable/scenery.png</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable/scenery_alias.png</code></li></ul></div><p>Next, create an XML file inside both of the density-specific directories. Inside these XML files, add some code that points toward your project's <code class="literal">res/drawable/scenery_alias.png</code> resource:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;bitmap    android:src="@drawable/scenery_alias" /&gt; &#13;
</pre><p>When the Android system tries to load the scenery resource from <code class="literal">res/drawable-hdpi</code> or <code class="literal">res/drawable-xhdpi</code>, it'll recognize the alias and display <code class="literal">res/drawable/scenery_alias.png</code> instead. In this way, you can replace memory-hogging and inefficient duplicate resources with small XML files.</p><p>You can also use the alias function to reuse the same layout resource files in multiple directories, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a default layout (<code class="literal">main.xml</code>), and place it in your project's <code class="literal">res/layout</code> directory.</li><li class="listitem">Create the layout you want to use across multiple directories. Give this layout a different name to the default layout (I'm going to use <code class="literal">main_alias.xml</code>), and place it inside your project's <code class="literal">res/layout</code> directory.</li><li class="listitem">Create XML files in all the directories where you want to use the <code class="literal">layout_alias.xml</code> file.</li><li class="listitem">Add some XML code that references <code class="literal">layout_alias.xml</code>:<pre class="programlisting">        &lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
        &lt;merge&gt; &#13;
           &lt;include layout="@layout/main_alias"/&gt; &#13;
        &lt;/merge&gt; &#13;
</pre></li></ol></div><p>Although less commonly used, you can also create aliases for strings and other simple values, as follows:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
   &lt;color name="yellow"&gt; #ffff00 &#13;
&lt;/color&gt; &#13;
   &lt;color name="highlightColor"&gt;@color/yellow&lt;/color&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>In this example, <code class="literal">highlightColor</code> is now an alias for <code class="literal">yellow</code>. You can also create aliases for strings:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
   &lt;string name="title"&gt;Student Recipe&lt;/string&gt; &#13;
   &lt;string name="appTitle"&gt;@string/title&lt;/string&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>In this example, <code class="literal">appTitle</code> is now an alias for <code class="literal">title</code>.</p></div></div><div class="section" title="Screen density"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Screen density</h2></div></div></div><p>When designing your UI, you should aim to achieve <span class="strong"><strong>density independence</strong></span>. This is where the Android system preserves the physical size of your UI elements across screens with different densities.</p><p>Density independence is <span class="emphasis"><em>crucial</em></span> to providing a good user experience. A high-density screen has more pixels per inch, which means the same amount of pixels fits into a smaller area. Low-density screens have less pixels, so the same amount of pixels fits into a much larger area. If you use absolute units of measure, such as specifying UI elements in pixels, then your UI elements are going to appear larger on low-density screens and smaller on high-density screens.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>It's a common misconception that devices with the same screen resolution automatically have the same screen density. Even if two devices have the same screen resolution, these screens may be different sizes. This means the screens are displaying their content in a different amount of space, which equates to a different number of dpi.</p></div></div><p>If your UI elements change sizes on different devices, then this is going to lead to problems in your layout and usability issues, and this will make for a generally poor user experience.</p><p>In most cases, you can ensure density independence by specifying your layout dimensions in density-independent pixels, and by replacing static, hardcoded sizes with more flexible elements such as <code class="literal">"wrap_content"</code> and <code class="literal">"match_parent"</code>.</p><p>When it comes to drawables, Android automatically scales each drawable based on the current screen's density, so your drawables render at the appropriate physical size for the current device. However, this automatic scaling can result in blurry or pixelated images. To make sure your drawables look their very best, you need to create alternate versions of each drawable, which are optimized for different screen densities.</p><p>The problem is that the Android marketplace includes more screen densities than you could <span class="emphasis"><em>ever</em></span> hope to support; and even if you could, providing so many alternate drawables would cause the size of your project to balloon out of control, to the point where it's unlikely it'd even fit onto your average Android smartphone or tablet.</p><p>This is why Android groups screen densities into the following generalized <span class="strong"><strong>density buckets</strong></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ldpi</code> (low-density): 120dpi</li><li class="listitem" style="list-style-type: disc"><code class="literal">mdpi</code> (medium-density): 160dpi</li><li class="listitem" style="list-style-type: disc"><code class="literal">hdpi</code> (high-density): 240dpi</li><li class="listitem" style="list-style-type: disc"><code class="literal">xhdpi</code> (extra-high-density): 320dpi</li><li class="listitem" style="list-style-type: disc"><code class="literal">xxhdpi</code> (extra-extra-high-density): 480dpi</li><li class="listitem" style="list-style-type: disc"><code class="literal">xxxhdpi</code> (extra-extra-extra-high-density): 640dpi</li></ul></div><p>The first step to a flexible layout is to create a directory for each of these density buckets, for example, <code class="literal">res/drawable-ldpi</code>, <code class="literal">res/drawable-mdpi</code>, and so on. Then, just create a version of each resource that targets these different density buckets, and the Android system will handle the rest.</p><p>To create optimized drawables for each density bucket, you need to apply the 3:4:6:8:12:16 scaling ratio across the six generalized densities. For the best results, start by creating a version of the image at the largest supported density, and then scale this graphic down proportionally for each subsequent density bucket.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>Most of the time, creating a graphic at the largest supported density means creating an image for the <code class="literal">xxhdpi</code> density bucket and <span class="emphasis"><em>not</em></span> the <code class="literal">xxxhdpi</code> bucket. This is because the <code class="literal">xxxhdpi</code> directory is reserved for launcher icons.</p></div></div><div class="section" title="Converting dpi into pixels and vice versa"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec63"/>Converting dpi into pixels and vice versa</h3></div></div></div><p>Since different screens have different pixel densities, the same number of pixels will translate into different physical sizes on different devices. Pixels aren't a density-independent unit of measurement, so 40 pixels isn't the same size on every device.</p><p>For this reason, you should never use absolute pixels to define distances or sizes. Occasionally, you may need to convert dpi values into pixel values and vice versa. You do this using the following formula: <span class="emphasis"><em>dpi = (width in pixels * 160) / screen density</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>Android uses <code class="literal">mdpi</code> (160dpi) as its baseline density where one pixel neatly equates to one density-independent pixel. This is where the 160 value in the formula comes from.</p></div></div><p>Let's try this with some numbers:</p><pre class="programlisting">(180 px x 160) / 120 = 240 dpi &#13;
</pre><p>You may also want to use an online converter (<a class="ulink" href="http://jennift.com/dpical.html">http://jennift.com/dpical.html</a>) to play around with dpi values.</p><p>If you want to convert a dpi value into pixels, then use the following formula:</p><pre class="programlisting">dp * (dpi / 160) = px &#13;
</pre><p>For example, take a look at the following:</p><pre class="programlisting">120 x (240 / 160) = 180 &#13;
</pre></div></div><div class="section" title="Providing different layouts for different screen sizes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Providing different layouts for different screen sizes</h2></div></div></div><p>Android supports a wide range of screen sizes, and it automatically resizes your UI to fit the current screen. As I've already mentioned, you shouldn't rely on the Android system to do all the hard work for you, as this autoscaling often doesn't make the best use of the space available on larger screens, particularly tablet-sized devices.</p><p>If you thoroughly test your app across a range of different screen sizes using the emulator and multiple <span class="strong"><strong>Android Virtual Devices</strong></span> (<span class="strong"><strong>AVDs</strong></span>), you may encounter your app struggling to display or function correctly on certain screens. For example, you may discover that Android's automatic scaling makes your UI look cramped once the device's screen dips below a certain dpi value; or at the other end of the scale, you may find that your UI has large areas of empty space on larger, tablet-sized screens.</p><p>If your UI is having problems with certain screen sizes, you should create layouts that are optimized for these screens.</p><p>The process for providing alternate layouts is the same as providing any alternate resource: create directories that have the appropriate configuration qualifiers. Then, create layout resource files that are optimized for specific screen sizes, and make sure these layouts have the same name as the corresponding default layout. The Android system will then select the appropriate layout based on the current screen configuration.</p><p>However, the screen size configuration qualifiers aren't as straightforward as the density configuration qualifiers, as Android 3.2 introduced some new configuration qualifiers that allow you to define the specific width and/or height required by each of your layouts, in dpi units. These new configuration qualifiers give you greater control over your resources, but they are a bit more difficult to get your head around.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note82"/>Note</h3><p>Prior to version 3.2, Android supported screen-size groups: <code class="literal">small</code>, <code class="literal">normal</code>, <code class="literal">large</code>, and <code class="literal">xlarge</code>. In order to accommodate a greater variety of screen sizes, the Android team replaced these groups with new configuration qualifiers. This chapter focuses on the new configuration qualifiers, but if you want to find out more about the now-deprecated screen size groups, you can find more information at the official Android docs at (<a class="ulink" href="http://developer.android.com/guide/practices/screens_support.html">http://developer.android.com/guide/practices/screens_support.html</a>).</p></div></div><p>These powerful new qualifiers are discussed in the next sections.</p><div class="section" title="smallestWidth – sw&lt;N&gt;dp"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec64"/>smallestWidth – sw&lt;N&gt;dp</h3></div></div></div><p>As the name suggests, you use the <code class="literal">smallestWidth</code> qualifier to define the minimum width in dpi that must be available before the Android system can use a particular layout. For example, if your layout requires a minimum of 700dpi, the <code class="literal">smallestWidth</code> configuration qualifier would be <code class="literal">sw700dp</code>. In this scenario, you'd create a <code class="literal">res/layout-sw700dp</code> directory and place your layout inside. The system will only use this layout when the current device has at least 700dpi of available width.</p><p>This qualifier is particularly useful as width is often a major factor when designing your layouts. Many apps scroll vertically, but it's pretty rare to encounter a UI that scrolls horizontally. Most apps have strict constraints about the minimum space they need horizontally, and this configuration qualifier gives you a way of specifying that minimum as a dpi value.</p><p>A device's width is a fixed characteristic that doesn't change when the user switches between portrait and landscape mode. The user's perception of their screen's width and height may change, but the system's perception of a device's <code class="literal">smallestWidth</code> never does, even when users switch their device from portrait to landscape mode and vice versa.</p></div><div class="section" title="Available screen width – w&lt;N&gt;dp"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec65"/>Available screen width – w&lt;N&gt;dp</h3></div></div></div><p>Sometimes, your app may need to react to how much width or height is currently available, which means taking the device's current orientation into consideration. For example, imagine your UI has the option to display two fragments side by side in a multi-pane layout. If the user is viewing your app in landscape mode, it makes sense to display the multi-pane layout, but as soon as the user switches the device into portrait mode, there may no longer be enough width available to display these fragments side by side.</p><p>This is where the <code class="literal">sw&lt;N&gt;dp</code> configuration qualifier comes in. You can use this qualifier to set the minimum width a resource requires, for example, <code class="literal">res/layout-w700dp</code>. However, unlike the <code class="literal">smallestWidth</code> qualifier, <code class="literal">w&lt;N&gt;dp</code> represents the width that's currently available to your UI, taking into account the current screen orientation. This allows your app to react to the width currently available to it and not just the device's fixed <code class="literal">smallestWidth</code> value.</p></div><div class="section" title="Available screen height – h&lt;number&gt;dp"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec66"/>Available screen height – h&lt;number&gt;dp</h3></div></div></div><p>As already mentioned, your typical Android app is pretty flexible about the minimum height it needs. However, if you do need to specify the minimum screen height a layout or resource needs, you can use the <code class="literal">h&lt;number&gt;dp</code> qualifier, for example, <code class="literal">res/layout-h720dp</code>.</p><p>The value the system assigns to the screen height changes when the screen's orientation changes, so similar to <code class="literal">w&lt;N&gt;dp</code>, you can use this qualifier to detect whether your app is currently being viewed in portrait or landscape mode.</p><p>While using these new configuration qualifiers may appear more complicated than using the traditional screen size groups, they do give you more control over how your UI translates across different screens, and they allow you to specify the exact point at which your app switches from a layout that's optimized for Android smartphones, to a layout that's optimized for tablets.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note83"/>Note</h3><p>Not all versions of Android support all qualifiers, for example <code class="literal">sw&lt;N&gt;dp</code> was introduced in API level 13. However, when you use a qualifier in your project, the system automatically and implicitly adds the platform version qualifier, so older versions of Android can at least recognize unsupported qualifiers and subsequently ignore them.</p></div></div></div></div><div class="section" title="Designing for different screen orientations"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Designing for different screen orientations</h2></div></div></div><p>You may also want to create versions of your layouts that are optimized for landscape and portrait orientations. You can provide layouts that are optimized for alternate orientations in the same way you provide layouts for different screen sizes and densities: you create an extra directory with the correct orientation qualifier and place your orientation-specific layouts inside that directory.</p><p>Even though Android supports two orientations—portrait and landscape—you only ever need to create one additional directory, since you'll use your project's default <code class="literal">res/layout</code> directory for one of these orientations.</p><p>Choose which orientation you want to use as your app's default, and then create a directory for the other orientation, so your project may consist of a <code class="literal">res/layout</code> directory that contains your default/portrait layouts and a <code class="literal">res/layout-land</code> directory which contains your project's landscape layouts.</p><p>Alternatively, if you want to use landscape orientation as your project's default, create a <code class="literal">res/layout-port</code> directory and use <code class="literal">res/layout</code> for your project's landscape layouts:</p><p>
</p><div class="mediaobject"><img src="graphics/B05061_8_1.jpg" alt="Designing for different screen orientations"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note84"/>Note</h3><p>When it's time to test your app, make sure you test it in both landscape and portrait mode across a range of screen configurations.</p></div></div><div class="section" title="Reacting to orientation changes"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec67"/>Reacting to orientation changes</h3></div></div></div><p>Sometimes, your app will need to register configuration changes and then modify its behavior accordingly.</p><p>One of the most common scenarios is reacting to whether the screen is in landscape or portrait mode. For example, imagine your app consists of two fragments: one fragment displays a list and the other fragment displays information about the currently-selected item. The app displays each fragment separately on smaller screens in a single-pane layout and side by side on larger screens in a multi-pane layout. When the user selects an item in the multi-pane layout, the information is displayed in the same activity. However, when the user selects an item in the single-pane layout, your app will need to display this information in a new activity. In this scenario, your app needs to know what layout the user is currently viewing (single or multi-pane), so it can react accordingly.</p><p>One method is to identify a view that's only visible in the multi-pane layout, and then query whether this view is currently visible:</p><pre class="programlisting">public class MyActivity extends FragmentActivity {  &#13;
   boolean mIsDualPane; &#13;
 &#13;
   @Override &#13;
   public void onCreate(Bundle savedInstanceState) { &#13;
       super.onCreate(savedInstanceState); &#13;
       setContentView(R.layout.main_layout); &#13;
 &#13;
//Check whether detailsView is currently visible// &#13;
 &#13;
       View detailsView = findViewById(R.id.article); &#13;
       mIsDualPane = detailsView != null &amp;&amp; &#13;
                      detailsView.getVisibility() ==&#13;
                      View.VISIBLE; &#13;
 &#13;
//If this view is visible, and we're in multi-pane mode....// &#13;
 &#13;
if (mDualPane) { &#13;
 &#13;
... &#13;
... &#13;
 &#13;
//This is where you'd define your app's multi-pane behavior// &#13;
 &#13;
} else { &#13;
 &#13;
//If this view isn't visible, then we're in single-pane mode//  &#13;
 &#13;
... &#13;
... &#13;
 &#13;
//This is where you'd define your app's single-pane behavior// &#13;
</pre><p>You can retrieve the device's current configuration using <code class="literal">getConfiguration()</code>:</p><pre class="programlisting">Configuration config = getResources().getConfiguration(); &#13;
</pre><p>To retrieve the device's current screen orientation and act on the results, run the following code:</p><pre class="programlisting">if (getResources().getConfiguration().orientation &#13;
 &#13;
//If the screen is currently in landscape mode...// &#13;
 &#13;
               == Configuration.ORIENTATION_LANDSCAPE) { &#13;
 &#13;
... &#13;
... &#13;
 &#13;
//This is where you'd define your app's landscape behavior// &#13;
 &#13;
} else  &#13;
 &#13;
//If not, then the device is in portrait orientation// &#13;
 &#13;
... &#13;
... &#13;
 &#13;
//This is where you'd define your app's portrait behavior// &#13;
</pre></div></div><div class="section" title="Testing across multiple screens"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Testing across multiple screens</h2></div></div></div><p>Before publishing your app, you should thoroughly test it across all supported screen sizes and screen densities, in both landscape and portrait mode. Unless you happen to have access to a bunch of different Android smartphones and tablets, the most practical way is to use the emulator that comes as part of the Android SDK.</p><p>When you launch the <span class="strong"><strong>AVD Manager</strong></span> and select <span class="strong"><strong>Create Virtual Device...</strong></span>, you can choose from a wide range of ready-made <span class="strong"><strong>Android Virtual Devices</strong></span> (<span class="strong"><strong>AVDs</strong></span>) that are based on real-life devices, or you can create your own by selecting <span class="strong"><strong>New Hardware Profile</strong></span>. When creating a new AVD, you can then choose whether your AVD supports landscape and/or portrait mode, but you should typically test your app in both landscape and portrait orientation on <span class="emphasis"><em>every</em></span> AVD you create.</p><p>You can also enter the screen size and resolution of your choice. As you enter these settings, you'll see the <span class="strong"><strong>Density</strong></span> of this particular device displayed in the window's right-hand pane:</p><p>
</p><div class="mediaobject"><img src="graphics/B05061_8_2.jpg" alt="Testing across multiple screens"/></div><p>
</p><p>To test your app's screen support, you'll need to create multiple AVDs that represent all the most common Android screen configurations. There's no shortcut here, and generally speaking, the more time you spend testing your app, the better the user experience will be, regardless of the device it winds up on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note85"/>Note</h3><p>I'll be using the emulator that comes as a part of the Android SDK throughout this book, but if you're not a fan of this default emulator, there are alternatives available. One popular alternative is Genymotion (<a class="ulink" href="https://www.genymotion.com">https://www.genymotion.com</a>).</p></div></div><div class="section" title="Showing off your screen support"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec68"/>Showing off your screen support</h3></div></div></div><p>When it's finally time to prepare your app's Google Play listing, you should use screenshots that show your app in the best possible light. Ideally, you should take all your screenshots on a large, high-density screen that's running the very latest version of Android, so potential users can see the most impressive version of your UI.</p><p>If you need to create promotional images for your website, blog, social media accounts, or anywhere else, then you should place your screenshots in context by wrapping them in device artwork. The easiest way to do this is using Android's drag-and-drop <span class="strong"><strong>Device Art Generator</strong></span> (<a class="ulink" href="http://developer.android.com/distribute/tools/promote/device-art.html">http://developer.android.com/distribute/tools/promote/device-art.html</a>).</p></div></div></div>
<div class="section" title="Attracting an international audience"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Attracting an international audience</h1></div></div></div><p>Your Android app has the potential to reach a worldwide audience, but <span class="emphasis"><em>only</em></span> if you invest time and effort into localizing your app.</p><p>Your biggest task when localizing a project is translating its text into your target language, but you'll also need to translate any drawables that contain text, any video that features text or dialogue, and audio that contains dialogue. You'll also need to ensure that any numbers, currency, times, or dates are formatted correctly for your target audience, as formatting can vary between languages and countries.</p><p>You provide these alternate resources in the same way you provide any other resources: create new directories and use an appropriate configuration qualifier.</p><p>When it comes to localization, you'll need to use <span class="emphasis"><em>locale</em></span> configuration qualifiers, which consist of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A language code</strong></span>: These are two-letter lowercase ISO codes, as defined by ISO 639-1 (<a class="ulink" href="https://en.wikipedia.org/wiki/ISO_639-1">https://en.wikipedia.org/wiki/ISO_639-1</a>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Country or regional code (optional)</strong></span>: Two-letter uppercase ISO codes as defined by ISO 3166-1 (<a class="ulink" href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3</a>) and proceeded by a lowercase <code class="literal">r</code>. You can use country/region codes in combination with the language code to provide resources that target devices set to a particular language and located in a specific country or region. For example, you could provide resources for French speakers located in Canada by combining the language code (<code class="literal">fr</code>) with the regional code (<code class="literal">CA</code>) plus a lowercase <code class="literal">r</code>, so your directory would be <code class="literal">res/values/fr-rCA</code>. You can't use a country or regional code on its own; it must always be preceded by a language code.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note86"/>Note</h3><p>Although it's tempting to think of a locale as being synonymous with a country, this isn't always the case. While you may create a directory that uses the French language and country code, you can also create a directory that combines the French language code with the Canadian country code.</p></div></div><div class="section" title="Identifying the target languages and regions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec106"/>Identifying the target languages and regions</h2></div></div></div><p>The first step to localizing your app is to identify the languages, regions, and countries you want to support.</p><p>Put your business head on and look for locales where there's a potential market for your app. In particular, you should look for languages, regions, or countries where:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There's a large or growing number of Android users</li><li class="listitem" style="list-style-type: disc">International languages, such as English, aren't widely used</li><li class="listitem" style="list-style-type: disc">There's a gap in the market for an app of your genre or subject</li></ul></div><p>All the preceding factors mean that localizing your app for this locale could be particularly lucrative.</p><p>Decide what countries or regions you want to target first, and then determine what language(s) your app needs to support in order to appeal to people in this part of the world.</p><p>Once you have a list of all the locales you're going to support, grab their language codes from ISO 639-1 (<a class="ulink" href="https://en.wikipedia.org/wiki/ISO_639-1">https://en.wikipedia.org/wiki/ISO_639-1</a>), plus any necessary region or country codes (<a class="ulink" href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3</a>).</p><div class="section" title="Providing alternate text"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec69"/>Providing alternate text</h3></div></div></div><p>Since translating your app's text is usually the biggest localization task, we're going to tackle this first.</p><p>Open your project's <code class="literal">res</code> folder and create all the alternate <code class="literal">values</code> directories your app needs to support your target locales. So, if you wanted your app to support the Spanish language, you'd create a directory called <code class="literal">res/values-es</code>. If you wanted to provide Spanish text that targets Spanish-speakers in Mexico, you'd create a <code class="literal">res/values-es-Rmex</code> directory.</p><p>Create the <code class="literal">strings.xml</code> files inside each of these directories:</p><p>
</p><div class="mediaobject"><img src="graphics/B05061_8_3.jpg" alt="Providing alternate text"/></div><p>
</p><p>Place all your translated string resources inside the corresponding <code class="literal">strings.xml</code> file (we'll look at some options for getting your text translated in a moment).</p><p>Continuing with our Spanish theme, our <code class="literal">res/values-es/strings.xml</code> file may look something like this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; &#13;
&lt;resources&gt; &#13;
     &lt;string name="hello_world"&gt;Hola Mundo&lt;/string&gt; &#13;
&lt;/resources&gt; &#13;
</pre><p>At runtime, the Android system logs the device's locale settings, checks your project for any suitable locale-specific resources, and then loads either the resources from the corresponding locale-specific directory or falls back on your project's default resources.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip87"/>Tip</h3><p>
<span class="strong"><strong>Keep your text separate from your application code</strong></span></p><p>It's good practice to keep the localized aspects of your app separate from your application code and to <span class="emphasis"><em>never</em></span> hardcode any text into your app, as this will make your text far more difficult to localize. Instead, declare all your text as string resources, as it's easy to extract strings from your project, send them to a translator, and then integrate them back into your app without making any changes to your compiled code.</p></div></div></div></div><div class="section" title="What other resources might you need localizing?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec107"/>What other resources might you need localizing?</h2></div></div></div><p>A large part of the localization process is translating your project's text, specifically its sting resources, but you may also want to provide locale-specific versions of other resources. For example, you may want to provide translated versions of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drawables that feature text</li><li class="listitem" style="list-style-type: disc">Video that contains text or dialogue</li><li class="listitem" style="list-style-type: disc">Audio that features dialogue</li></ul></div><p>You may also want to provide alternate versions of resources that aren't appropriate for the locale you're targeting. For example, you may want to provide alternatives to scenes that feature a particular city or scenery if this image isn't representative of the locale you're targeting. Sun-drenched beaches and crystal-clear seas aren't your typical scenery in every country (unfortunately).</p><p>You should also be aware that some images maybe considered inappropriate or offensive in certain cultures.</p><p>You provide locale-specific versions of any resource in exactly the same way you provide alternate string resources; create a new directory and use the same combination of the language and country/region code. For example, if you wanted to provide multiple versions of a <code class="literal">typical_highshcool.jpg</code> drawable, you'd create multiple drawable folders, such as <code class="literal">res/drawable-ja-rJPN</code>, <code class="literal">res/drawable-en-rUSA</code>, and <code class="literal">res/drawable-sv</code>.</p></div><div class="section" title="Why default resources are important"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Why default resources are important</h2></div></div></div><p>The key to ensuring that your app runs correctly on devices with any language, country, or region settings is to provide a complete set of default resources.</p><p>One of the most important default resources you need to provide is <code class="literal">res/values/strings.xml</code>. This is where you'll define every string resource used throughout your project in your app's <span class="emphasis"><em>default language</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note88"/>Note</h3><p>The default language is the language that's spoken by the majority of your target audience. This may not necessarily be your audience's first language.</p></div></div><p>If you don't provide a default version of every string resource, then your app will crash whenever it winds up on a device with locale settings that you haven't provided a specific string resource for. Even if the user doesn't understand your app's default language, this is still preferable to your app crashing or refusing to open.</p><p>You'll also need to provide a default version of every other locale-specific resources you use in your app, because if your project is missing one default resource, then it may not run on devices with unsupported locale settings.</p><p>Default string resources are also crucial when there's some text you want to keep consistent across your app, regardless of the device's locale settings. One common example is your app's title, which you may want to keep consistent across all versions of your app.</p><p>To use text consistently across locales, you just need to define the string once in your project's default <code class="literal">strings.xml</code> file, and then omit it from all your locale-specific <code class="literal">strings.xml</code> files. Then, when the system tries to load your app's title from a locale-specific strings file, it'll realize that this string is missing and fall back on the default version. The end result is that the same string resource will be used in every version of your app.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip89"/>Tip</h3><p>
<span class="strong"><strong>Should I translate my app's title?</strong></span></p><p>There's no straightforward answer to this tricky question. Having multiple titles makes an app more difficult to maintain, and it can make usually straightforward decisions more complex; if your app goes by multiple names, then what should your app's Twitter handle be? Do you need to create multiple versions of your app's logo and app icon? Do you need to create multiple support e-mail addresses?</p><p>You'll also have to work much harder to promote a product that goes by several different names, particularly when it comes to things such as <span class="strong"><strong>Search Engine Optimisation </strong></span>(<span class="strong"><strong>SEO</strong></span>).</p><p>Despite all these drawbacks, there are a few good reasons why you might want to publish your app under multiple names. The most common reason is that your app's title may not make much sense to people who aren't fluent in your app's default language. If we decided to call our recipe app Best Student Recipes, English-speaking users would instantly know what to expect, but for users who speak different languages, <span class="emphasis"><em>best student recipes </em></span>could be completely meaningless. A nonsensical title isn't particularly appealing to potential users who stumble across your app in the Google Play store, so you may want to consider releasing your app under multiple names.</p><p>There's no real right or wrong answer here. All that matters is that you make the best decision based on the app you're developing and your target locales.</p><p>Whatever decision you do make, make sure you stick to it! Changing your app's name after you've launched it is only going to confuse your users.</p></div></div><div class="section" title="Which configuration qualifiers are the most important?"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec70"/>Which configuration qualifiers are the most important?</h3></div></div></div><p>At this point, we've covered quite a few different configuration qualifiers: locale-specific qualifiers, screen orientation, screen density, and screen size qualifiers.</p><p>If you use a mixture of these in your projects, there's a strong possibility that more than one version of a resource is going to be suitable for the current device. Imagine your app winds up on a device with a high-density screen and Spanish language settings, and that's currently being held in landscape mode. The system needs to display a drawable, but multiple versions of this drawable are suitable for the current device:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable-es</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable-land</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">res/drawable-hdpi</code></li></ul></div><p>Which drawable will the system use? When Android is spoilt for choice, it follows a strict set of rules. Of all the qualifiers you can use, locale almost always gets preferential treatment. In this example, the device is configured to use Spanish, so Android would load the graphic from the <code class="literal">res/drawable-es</code> directory <span class="emphasis"><em>even though</em></span> the device in question also has a high-density screen and is currently in landscape mode.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note90"/>Note</h3><p>The only qualifiers that take precedence over locale qualifiers are <span class="strong"><strong>mobile country codes</strong></span> (<span class="strong"><strong>MCC</strong></span>) and <span class="strong"><strong>mobile network codes</strong></span> (<span class="strong"><strong>MNC</strong></span>). If you use any of these codes in your project's directories, they'll always take precedence over your locale qualifiers.</p></div></div></div></div><div class="section" title="Getting your app translated"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Getting your app translated</h2></div></div></div><p>Translating your app's resources is a crucial part of the localization process, and unless you're fluent in the language that you're targeting, at some point you'll need to enlist the help of a translator, whether that's a paid professional or a kind volunteer.</p><p>Although you may be tempted to go down the quick and easy route of a machine translator, services such as Google Translate can never compare to a human translator, and relying on machine translators will almost always result in a bad experience for your international users.</p><p>If you do decide to hire a professional translator, you should start contacting translators as early as possible, so you can get an idea of turnaround time and incorporate this information into your development plan. It also gives you time to shop around and find the best possible translator for your budget.</p><p>You can find translators online, or you may want to explore the Google Play app Translation service, which is offered through Developer Console.</p><p>To access these services, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log in to the Developer Console (<a class="ulink" href="https://play.google.com/apps/publish">https://play.google.com/apps/publish</a>).</li><li class="listitem">If you haven't already done so, upload your APK by selecting <span class="strong"><strong>Add new application</strong></span>.</li><li class="listitem">Once you've uploaded your app, it'll appear in your <span class="strong"><strong>All Applications</strong></span> dashboard. Select the app you want to purchase translation services for.</li><li class="listitem">Make sure <span class="strong"><strong>APK</strong></span> is selected in the left-hand menu.</li><li class="listitem">Under <span class="strong"><strong>APK Translation Service</strong></span>, select <span class="strong"><strong>Start</strong></span>.</li><li class="listitem">Select the source language used in your original text.</li><li class="listitem">Under <span class="strong"><strong>Translate API</strong></span>, add the XML source file that contains the strings that you want to translate.</li><li class="listitem">Select your target languages.</li><li class="listitem">Choose a translation vendor.</li></ol></div><p>Just be aware that even though you're making a purchase through the Developer Console, this is a direct business agreement between you and your chosen vendor, so you'll need to work with the translator directly. After purchasing a translation through the Developer Console, you will receive an e-mail from your vendor, and it's your responsibility to manage the project from there.</p><div class="section" title="Getting the most out of your translations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec71"/>Getting the most out of your translations</h3></div></div></div><p>The quality of your translations depends on the skill of the translator, but it also depends on the quality of your input. If you provide your chosen translator with a higher quality input, then it stands to reason that you're going to get a higher quality output.</p><p>In this section, I'll show you how to increase your chances of receiving a high quality, accurate translation.</p><div class="section" title="Putting your strings in context"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec16"/>Putting your strings in context</h4></div></div></div><p>When you're declaring your string resources, you should provide as much information about each string as possible, as this will help your translator to better understand your string resources.</p><p>At the very least, you should give each string a descriptive name, but ideally you should also supply a comment that explains what this string is for, along with the information about when and where the string will appear in your app, plus any restrictions such as the maximum amount of characters this part of your UI can display. For example, take a look at the following:</p><pre class="programlisting">&lt;string name="search_submit_button"&gt;Search&lt;/string&gt; &#13;
 &#13;
//Text that appears on a button that can fit 9 characters. Must be one word. The user taps this button to submit a search query// &#13;
</pre><p>If your app features any specialist language or technical terms, then you should thoroughly explain what each term means. If this turns out to be too much text to fit into a comment, or you find yourself explaining multiple strings, then you may want to create a separate glossary document that explains the meaning and use of all the specialist terms used throughout your <code class="literal">strings.xml</code> file. You can then send this additional document to the translator along with your strings.</p></div><div class="section" title="Using terms consistently"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec17"/>Using terms consistently</h4></div></div></div><p>You can greatly increase your chances of a successful and accurate translation by using terms consistently throughout your app. For example, if the main method of navigating your app is via a series of buttons that allow the user to progress to the next screen, you should label these buttons consistently, instead of using a mix of terms that all mean the same thing, such as <span class="strong"><strong>Forward</strong></span>, <span class="strong"><strong>Next</strong></span>, <span class="strong"><strong>OK</strong></span>, and <span class="strong"><strong>Submit</strong></span>. This will make the translator's job much easier.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note91"/>Note</h3><p>Using terms consistently will improve your app's general user experience too.</p></div></div></div><div class="section" title="Getting your strings in order"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec18"/>Getting your strings in order</h4></div></div></div><p>To help the translator make sense of your project's string resources, you should take a few moments to perform some admin on your <code class="literal">strings.xml</code> file. Remove any unused strings that you might have added early on and then never actually used in your project, and remove the strings that have disappeared from your project over time. You should also remove any duplicate strings, and be on the lookout for any spelling mistakes or typos. Finally, make sure your strings are formatted correctly and consistently. This housekeeping may seem simple, but it can make your translator's job much easier, particularly if they're not an Android developer themselves.</p></div><div class="section" title="Not creating unnecessary strings"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec19"/>Not creating unnecessary strings</h4></div></div></div><p>More strings mean more work! Even if you're supporting several languages, you probably won't need to create a locale-specific version of every string in every language your app supports.</p><p>There may be pieces of text that you want to use consistently across all locales, such as your app's title, which means there's no need to add this string to every locale-specific <code class="literal">strings.xml</code> file. Remember, if you don't include a particular string in a locale-specific directory, your app will use the default string instead.</p><p>Your app may also support languages that are variations of the same parent language. For example, imagine your app's default language is British English, but it also supports American English. Chances are that most of the resources you define in your project's <code class="literal">res/values/strings.xml</code> file will be suitable for your American English audience. You should still create a <code class="literal">res/values-en-rUSA/strings.xml</code> file, but this file should only contain the strings where American English spelling differs from British English spelling.</p></div><div class="section" title="Always marking non-translatable text"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec20"/>Always marking non-translatable text</h4></div></div></div><p>Your project may include some string resources that you don't want translating, such as your app's title, URLs, promotional codes, social media links, and e-mail addresses. You should clearly mark all the text you don't want translating before handing your project over to the translator.</p><p>Wrap the <code class="literal">&lt;xliff:g&gt;</code> tags around the text that you don't want translating, and use an <code class="literal">id</code> attribute to explain why this text shouldn't be translated:</p><pre class="programlisting">&lt;string name="name"&gt; This text will be translated&lt;xliff:g id="This is my explanation"&gt;this text won't be translated&lt;/xliff:g&gt; this text will be translated.&lt;/string&gt; &#13;
</pre><p>Imagine you want to display a welcome message that includes your app's title. You want the actual welcome text to be translated, but you want the app's title to remain consistent across all locales. In this scenario, you'd use the following XML:</p><pre class="programlisting">&lt;string name="welcomeMessage"&gt; Welcome to the&lt;xliff:g id="appTitle"&gt;Student Recipes&lt;/xliff:g&gt;app.&lt;/string&gt;  &#13;
</pre><p>Finally, to prevent your project from throwing an error, you need to update the resources tag in your <code class="literal">strings.xml</code> file:</p><pre class="programlisting">&lt;resources &gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip92"/>Tip</h3><p>
<span class="strong"><strong>Marking dynamic values as non-translatable</strong></span></p><p>Sometimes, you'll want to combine some predetermined and dynamic text in a single string. For example, your app could ask the student for their name, take their input, combine it with some of the predetermined text, and then display the <span class="strong"><strong>Welcome to the Student Recipe app, Nicole!</strong></span> message.</p><p>So, what does this have to do with translation? When you create strings that feature dynamic text, you represent the dynamic text with a placeholder, such as follows:
<code class="literal">&lt;string name="name"&gt;Welcome to the app %1$s&lt;/string&gt;</code></p><p>You should make it clear to your translator that this placeholder isn't an error or typo, and therefore, they shouldn't try to translate it. This becomes particularly important when you're working with a translator who isn't familiar with Android development.</p><p>To make it clear that a placeholder shouldn't be translated, you can use the regular <code class="literal">&lt;xliff:g&gt;</code> tags and the <code class="literal">id</code> attribute. However, for the sake of clarity, you should also provide an example of the kind of content this placeholder text might eventually display. In our welcome message example, this looks something like the following:
<code class="literal">&lt;string name="welcomeMessage"&gt;Welcome to the Recipe App&lt;xliff:g id="userName" example="Nicole"&gt;%1$s&lt;/xliff:g&gt;!&lt;/string&gt;</code>
</p></div></div></div></div><div class="section" title="Other things to consider"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec72"/>Other things to consider</h3></div></div></div><p>Although language may be the most obvious factor, there are several less obvious things you need to take into consideration if your app is really going to make a splash on the international market.</p><div class="section" title="Right to left support"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec21"/>Right to left support</h4></div></div></div><p>Don't automatically assume that your audience will read left to right (LTR). In some countries, reading right to left (RTL) is the norm. Depending on the locales you're targeting, you may want to consider implementing support for RTL and LTR.</p><p>The good news is that in Android 4.2 and higher, the system automatically mirrors your app's UI when the user switches the system language to a right-to-left script.</p><p>To take advantage of this automatic mirroring, open your project's <code class="literal">Manifest</code> file and add the following line:</p><pre class="programlisting">android:supportsRtl="true" &#13;
</pre><p>Then, change all your app's <code class="literal">left/right</code> layout properties to the <code class="literal">start/end</code> equivalents:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you're targeting Android 4.2 and higher, use <code class="literal">start</code> and <code class="literal">end</code> instead of <code class="literal">left </code>and <code class="literal">right</code>, for example, <code class="literal">android:paddingRight</code> becomes <code class="literal">android:paddingEnd</code></li><li class="listitem" style="list-style-type: disc">If you're targeting versions of Android lower than 4.2, you should use <code class="literal">start</code> and <code class="literal">end</code> in addition to <code class="literal">left</code> and <code class="literal">right</code>; for example, you should use both <code class="literal">android:paddingRight</code> and <code class="literal">android:paddingEnd</code></li></ul></div></div><div class="section" title="Formatting values"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec22"/>Formatting values</h4></div></div></div><p>Keep in mind that not every locale formats values, such as dates and numbers, in the same way. You should <span class="emphasis"><em>never</em></span> hardcode formats based on assumptions about the user's locale as this can cause problems when the user switches to another locale.</p><p>Instead, always use the system-provided formats and utilities such as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DateUtils (<a class="ulink" href="http://developer.android.com/reference/android/text/format/DateUtils.html">http://developer.android.com/reference/android/text/format/DateUtils.html</a>) and DateFormat (<a class="ulink" href="http://developer.android.com/reference/java/text/DateFormat.html">http://developer.android.com/reference/java/text/DateFormat.html</a>) for dates</li><li class="listitem" style="list-style-type: disc">String.format (<a class="ulink" href="http://developer.android.com/reference/java/lang/String.html#format(java.lang.String,%20java.lang.Object...">http://developer.android.com/reference/java/lang/String.html#format(java.lang.String,%20java.lang.Object</a>) or DecimalFormat (<a class="ulink" href="http://developer.android.com/reference/java/text/DecimalFormat.html">http://developer.android.com/reference/java/text/DecimalFormat.html</a>) for numbers and currency</li><li class="listitem" style="list-style-type: disc">PhoneNumberUtils (<a class="ulink" href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html">http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html</a>) for phone numbers</li></ul></div></div></div></div><div class="section" title="Localizing your app – best practices"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Localizing your app – best practices</h2></div></div></div><p>Localizing your app is a powerful way of attracting potentially <span class="emphasis"><em>millions</em></span> more users. Why limit yourself to just one market? Implementing the following best practices will increase your app's chances of connecting with a worldwide audience.</p><div class="section" title="Design a single set of flexible layouts"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec73"/>Design a single set of flexible layouts</h3></div></div></div><p>Depending on the languages that you choose to support, some of your alternative string resources may expand or shrink dramatically during the translation process to the point where they no longer fit your layout.</p><p>To minimize the chances of this happening in your app, you should create flexible layouts that can accommodate alternate string resources of all sizes. One useful trick is to give your app's default text more space than it requires, so your UI already has some wiggle room when it comes to accommodating slight variations in size.</p><p>You should design UI elements that contain text to be able to expand horizontally and vertically in order to accommodate minor changes in text height and width, for example, buttons that can grow and shrink depending on the size of their button labels. However, you should also consider how these expanding and shrinking UI elements might impact the rest of your UI. Could an expanding button make your UI look cramped or lopsided? Or worse, could it push the neighboring buttons off the screen, rendering them unreachable?</p><p>Pay particular attention to UI elements that the user can interact with, such as buttons; if these elements change size, it can quickly impact your user experience. Two touchable objects that inch closer to one another as they expand can result in frustrated users who keep catching the wrong button by accident.</p><p>If you design your layouts with flexibility in mind, then typically you'll be able to use the same layout across all locales. However, if you're struggling to design a layout that's flexible enough to accommodate all your alternate strings, you may want to make some changes to your text.</p><p>Simple, straight-to-the-point text typically means less variation during the translation process, so if you're struggling with text that shrinks or expands dramatically, start at the root of the problem—your app's default text. Look for any opportunities to simplify this text, any unnecessary text you can remove from your UI, plus any words that you can replace with a universally understood picture or symbol, such as replacing the <span class="strong"><strong>OK</strong></span> text with a checkmark or <span class="strong"><strong>Cancel</strong></span> with a cross<span class="strong"><strong>.</strong></span>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note93"/>Note</h3><p>Simplifying your app's text and removing any words that aren't strictly necessary will provide a better user experience all round, regardless of whether the user is viewing a localized version of your app or accessing your app in its default language.</p></div></div><p>Depending on the amount of text you need to display and the locales your app supports, it may be impossible to create a single layout that can accommodate text across <span class="emphasis"><em>all</em></span> your target languages. Layouts can only flex so far after all!</p><p>As a final resort, you can create alternate layouts specifically for the language (or languages) that are causing your app so many problems, which leads onto the next point.</p></div><div class="section" title="Create alternate languages only when needed"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec74"/>Create alternate languages only when needed</h3></div></div></div><p>You can create a layout that targets a specific language by creating a new layout directory with the relevant configuration qualifier. For example, if you wanted to create a version of your project's <code class="literal">main.xml</code> layout that's optimized to display your tricky German translations, you'd create a <code class="literal">res/layout-de/main.xml</code> directory, and then place your German layout resource file inside this directory.</p><p>However, alternate layouts do make your app harder to maintain, so only use them as a last resort.</p></div></div><div class="section" title="Testing your app across different locales"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Testing your app across different locales</h2></div></div></div><p>Once you've created all your locale-specific layouts and resources, you need to make sure that your app really is ready for an international audience. This means testing the localized versions of your app across a wide range of AVDs with localization settings that correspond to your different target locales, plus at least one AVD that's set to a language and locale that your app <span class="emphasis"><em>doesn't</em></span> explicitly support.</p><p>When testing your app across different locales, be sure to check for the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Your project is displaying the correct string resources, layouts, and any other locale-specific resources for the device it's currently installed on. Placing a <code class="literal">strings.xml</code> file in the wrong directory and missing a configuration qualifier or even a simple typo is all it takes for your app to display Korean text (<code class="literal">res/values-ko/strings.xml</code>) when it should really be displaying Kurdish text (<code class="literal">res/values-ku/strings.xml</code>).</li><li class="listitem" style="list-style-type: disc">Your locale-specific resources are displaying correctly in the current layout and aren't causing any usability problems.</li></ul></div><p>You should also be aware that some screen configurations, hardware, and software may be more common in certain locales. Make sure you research the most popular devices in all your target locales to see whether you need to incorporate support for specific hardware, software, or screen configurations into the localized versions of your app.</p><div class="section" title="Testing for different locales"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec75"/>Testing for different locales</h3></div></div></div><p>You can test your app's language settings on a physical device by opening that device's <span class="strong"><strong>Settings</strong></span> app, selecting <span class="strong"><strong>Language</strong></span>, and then choosing a new language from the menu. This is useful for getting an idea of how the localized version of your app functions across devices with different language settings. However, you should also test how your app functions with different country and region settings, something you can't easily change on a physical Android device, which is where AVDs come in.</p><p>Although you can't create an AVD with specific language, locale, or region settings, you can change these settings once you have an AVD up and running in the emulator.</p><p>Start by creating an AVD with the screen configuration, hardware, and software settings you want to test your app against, and launch your project in this AVD.</p><p>Open your Mac terminal or Windows command prompt and <span class="strong"><strong>change directory</strong></span> (<code class="literal">cd</code>) so it's pointing at the directory where the<span class="strong"><strong>Android Debug Bridge</strong></span> (<code class="literal">adb</code>) is located. For example, the command I'm using is:</p><pre class="programlisting">cd /Users/jessica/Downloads/adt-bundle-mac/sdk/platform-tools &#13;
</pre><p>Once your AVD is up and running, you can change its locale by issuing adb commands. To do this, you'll need the ISO code of the language you're targeting (<code class="literal">ISO 639-1</code>), and any country or region code (<code class="literal">ISO 3166-1</code>) you're using.</p><p>In your <code class="literal">adb</code> window, enter the following command:</p><pre class="programlisting">
<span class="strong"><strong>adb shell</strong></span>
</pre><p>After a few moments, you will see a <code class="literal">#</code> prompt. At this point, you can enter the following command:</p><pre class="programlisting">
<span class="strong"><strong>setprop persist.sys.locale [ISO language code, with optional country/region code] ;stop;sleep 5;start </strong></span>
</pre><p>For example, if you wanted to test your app on a device that's set to Spanish (<code class="literal">es</code>), you'd run the following:</p><pre class="programlisting">
<span class="strong"><strong>setprop persist.sys.locale es;stop;sleep 5;start</strong></span>
</pre><p>If you wanted to check your app on a device that's set to use the Spanish language in the Mexican locale, you'd run the following:</p><pre class="programlisting">
<span class="strong"><strong>setprop persist.sys.locale es-Rmex;stop;sleep 5;start</strong></span>
</pre><p>At this point, the emulator will restart with the new locale settings. Relaunch your app and that's it—you're ready to test your app against your new locale settings.</p><div class="section" title="Look for common localization issues"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec23"/>Look for common localization issues</h4></div></div></div><p>So, once you've set up your test environment, what <span class="emphasis"><em>specific</em></span> issues should you be looking for?</p><p>Firstly, you should check every screen in your app to make sure there's no instances of clipped text, poor line wrapping, strange-looking word or line breaks, or incorrect alphabetical sorting. You should also be aware of any locales where the text should run RTL and check that this is actually what's happening in your layouts.</p><p>You should also be on the lookout for any unintentionally untranslated text; unintentional because there may be instances where you want to use the same text consistently across your app, such as your app's title and your contact details. If you spot any <span class="emphasis"><em>unintentionally</em></span> untranslated text, then you should dig into your app's code to see exactly what's going wrong.</p><p>Also, be on the lookout for any wrongly translated text. This kind of error can be difficult to spot, as chances are that you're not fluent in all the languages your app supports. This is one of the few occasions where it's acceptable to use an online translator, such as Google Translate, as it's often the quickest and easiest way of double-checking that your app's Spanish text really is Spanish.</p><p>You should also look for any instances where text or other locale-specific resources don't fit with your current layout. This could be the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Resources that are smaller than the default version, such as the text that shrinks dramatically during the translation process. Shrinking resources can leave gaping holes in your layout, or they can throw other UI elements off balance and create a layout that, while not completely broken, does look pretty odd.</li><li class="listitem" style="list-style-type: disc">Resources that are present in some versions of your UI and missing in others. Again, this can cause awkward gaps and aesthetic problems in your layout. If you're intentionally omitting certain resources, you might want to look for something to fill the gap this resource leaves behind, or as a last resort, supply an alternative layout that's designed specifically for this locale.</li><li class="listitem" style="list-style-type: disc">Resources that are much larger than the default version, which can result in a cluttered, cramped-looking UI or usability problems, such as touchable areas that are pushed too close to one another.</li><li class="listitem" style="list-style-type: disc">Resources that aren't appropriate for the current screen configuration. As already mentioned, different locales may also mean different hardware, software, and screen configurations. If you're targeting multiple countries and regions, make sure you research the most popular Android devices within these specific demographics, and then test your app across AVDs that reflect the hardware, software, and screen configurations that are most commonly used within these different areas.</li></ul></div></div></div><div class="section" title="Testing for default resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec76"/>Testing for default resources</h3></div></div></div><p>After you've tested your app across all the languages, countries, and regions that you want to support, you should install your app on an AVD with locale settings that it <span class="emphasis"><em>doesn't</em></span> explicitly support. This may sound strange, but it's the most effective way of checking that you've included a default version of every resource your app requires.</p><p>As I've mentioned several times throughout this chapter, including default resources means that if your app gets into difficulties, it has something to gracefully fall back on rather than crashing. Providing default versions of all your project's strings, drawables, and other resources guarantees that your app will run even if it winds up on a device with locale settings that it doesn't explicitly support.</p><p>To test your app, open your Terminal or Command Prompt window and tell your emulator to switch to a locale that your app doesn't explicitly support. If you've provided the necessary default resources, your app should load these resources, including the contents of your project's <code class="literal">res/values/strings.xml</code> file. If your app crashes, then this is an indication that your project is missing at least one default resource.</p></div><div class="section" title="Plan a beta release in key countries"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec77"/>Plan a beta release in key countries</h3></div></div></div><p>Once you've finished testing your app across different locales, and you're confident that it'll functions correctly regardless of the user's language, country, or region settings, then you may want to consider opening your app up to feedback from your potential target audience, in particular the native speakers of all the languages your app supports. This usually takes the form of beta testing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note94"/>Note</h3><p>Users who install beta versions of your app cannot leave reviews on your Google Play page, so don't worry about these early versions of your app negatively (and unfairly!) impacting your Google Play rating.</p></div></div><p>Getting real-world feedback is always valuable, but this feedback becomes even more valuable when you're planning an international launch. Native speakers will be able to easily pinpoint any grammar or spelling mistakes in your text, or even something that just sounds a bit <span class="emphasis"><em>off</em></span>. They can also quickly flag up anything about your app's content that's inappropriate, confusing, or difficult for them to relate to.</p><p>This is all invaluable feedback that can help you perfect the localized versions of your app and create something that feels like it was created specifically for this section of your target audience, rather than a translation that was knocked together in a last-minute bid to rack up some extra downloads.</p><p>If you're looking to launch a beta testing program, then Google Play can help. After you sign into Developer Console and upload your APK, you can set up groups of users for beta testing.</p><p>You may want to start small with a closed beta test, where you specify a group of testers by entering their Gmail addresses. If you happen to have a list of testers to hand, you can launch a closed beta program by doing the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log in to the Developer Console and selecting <span class="strong"><strong>APK</strong></span> from the left-hand side menu.</li><li class="listitem">Select the <span class="strong"><strong>Upload your first APK to beta</strong></span> button and following the onscreen instructions to upload your APK.</li><li class="listitem">Once your APK is uploaded, select <span class="strong"><strong>Beta testing</strong></span>.</li><li class="listitem">If you see a <span class="strong"><strong>Choose a testing method</strong></span> option, open the accompanying drop-down menu and select <span class="strong"><strong>Set Up Closed Beta Listing</strong></span>, followed by <span class="strong"><strong>Create list</strong></span>.</li><li class="listitem">Enter the e-mail addresses of all the people who you want to participate in the beta test. Click on <span class="strong"><strong>Save</strong></span>.</li><li class="listitem">Copy <span class="strong"><strong>Beta opt-in URL</strong></span>. You can then share this link with your testers. When a potential tester clicks this link, they'll see an explanation about what being a beta tester entails. They can then decide whether to participate in the test or not.</li><li class="listitem">After copying <span class="strong"><strong>Beta opt-in URL</strong></span>, you'll need to enter an e-mail address or URL that you'll use to collect feedback from your testers. Enter this information in the <span class="strong"><strong>Feedback channel </strong></span>field, then click on <span class="strong"><strong>Save</strong></span>.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip95"/>Tip</h3><p>
<span class="strong"><strong>Gathering tester feedback</strong></span></p><p>Since testers can't leave reviews on your app's Google Play page, you'll need to provide them with an alternative way of sending you their feedback. Whenever you launch a testing program through Developer Console, it's crucial you complete the <span class="strong"><strong>Feedback channel</strong></span> field as this is your testers' primary way of communicating with you.</p><p>This feedback channel could take the form of an address or URL, but you may also want to consider setting up a Google+ page or Google Group for your testers. Whatever your preferred method of gathering feedback, it's important to recognize that anyone who tests your app is doing you a favor, so you should make it as easy as possible for them to send you their feedback.</p><p>If providing feedback feels like hard work, then your testers simply won't bother—they'll keep their thoughts to themselves, and your project will suffer as a result.</p></div></div><p>After a round of closed beta testing, you may want to move on to open beta testing, where you specify a maximum number of testers but don't specify their e-mail addresses.</p><p>To launch an open beta testing program, make sure you're logged into Developer Console, and then select <span class="strong"><strong>APK</strong></span> from the left-hand side menu. Select <span class="strong"><strong>Beta testing</strong></span>, open the drop-down menu, select <span class="strong"><strong>Set up Open Beta Testing</strong></span>, and then specify the maximum number of users who'll be able to beta test your app.</p><p>Copy <span class="strong"><strong>Beta opt-in URL</strong></span> and share it with your testers. Again, make sure you enter an e-mail address or URL in <span class="strong"><strong>Feedback channel</strong></span>, and then click on <span class="strong"><strong>Save</strong></span>.</p></div><div class="section" title="Get ready for lift off!"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec78"/>Get ready for lift off!</h3></div></div></div><p>If you want your app to make a splash in the international market, supporting multiple languages and locales is just the beginning. You'll also need to devise some form of international marketing campaign.</p><p>This may sound like the kind of thing that requires a massive budget and a dedicated marketing team, but you can tailor the scope of your campaign to suit your budget and how much free time you have to promote your app. Even if your app is a one-person project, there's no end to budget-friendly (and in some cases, free) ways of promoting your app to an international audience, especially when you're promoting your app online.</p><p>A marketing campaign could be as simple as writing a press release announcing the release of your app, and then arranging for this text to be translated into the various languages your app supports. You could then spread your press release across the World Wide Web via social networks, free news and press release websites, your own blog, or any other places where you can post content for free.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note96"/>Note</h3><p>Don't get carried away and post your marketing materials absolutely everywhere just for the sake of it. Spamming is only going to hurt your app's reputation in the long run.</p></div></div><p>You should also translate any other promotional materials you create, such as banners, virtual badges, adverts, or memes.</p><p>Even if your promotional graphics don't feature any text, you should still look for opportunities to tweak these graphics, so they're more likely to resonate with each of your target locales. For example, could you include any geographical or cultural references that would make your graphics more appealing to users in specific regions? In our recipe app example, this might mean identifying recipes that are more likely to appeal to sections of our target audience and then featuring these recipes more prominently in the app's promotional banners and adverts.</p><p>If you create any promotional videos, you should also create localized versions of these videos for every language your app supports. This may mean recording entirely new audio for every video or providing subtitles.</p><p>Remember, the key to attracting an international audience is to create the illusion that your app was designed with each user's specific locale in mind.</p></div></div><div class="section" title="Localize your Google Play store listing"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Localize your Google Play store listing</h2></div></div></div><p>Your app's Google Play listing is the first impression that international users will have of your app. To make sure this first impression is a positive one, you'll need to localize your store listing, which means translating its text for every locale your app supports.</p><p>You can create multiple localized versions of your app's Google Play listing via Developer Console. Then, when a user opens your app's listing, Google Play will automatically determine that user's location, and it'll display the version of your listing that's the most appropriate for their language, country, or region settings. If Google Play can't find a suitable locale-specific version of your app's listing, it'll display your app's default Google Play page instead.</p><p>To create localized Google Play listings, log into your Developer Console account, and select <span class="strong"><strong>App applications</strong></span> from the left-hand side menu. Select the app you want to work with, followed by <span class="strong"><strong>Store listing</strong></span>.</p><p>To create a new, localized version, click on the <span class="strong"><strong>Manage translations</strong></span> button. At this point, you can purchase a translation by clicking on <span class="strong"><strong>Purchase translations</strong></span> and following the onscreen instructions:</p><p>
</p><div class="mediaobject"><img src="graphics/B05061_8_4.jpg" alt="Localize your Google Play store listing"/></div><p>
</p><p>If you already have some translated text you want to add to your localized store listing, select <span class="strong"><strong>Add your own translation</strong></span>. Select all the languages you want to create a localized listing for (don't worry, you can always add more later on), and click on <span class="strong"><strong>Add</strong></span>.</p><p>At this point, Developer Console will take you back to the store listing form, but now, if you click on the <span class="strong"><strong>Languages</strong></span> button, you'll see a drop-down list of all the languages you've just added. Clicking on any of these languages will take you to a separate form where you can craft an entirely new store listing, which will be displayed whenever someone views your app in Google Play with these locale settings.</p><p>If you need to delete one of your localized pages at any point, simply click on the <span class="strong"><strong>Manage Translations</strong></span> button, followed by <span class="strong"><strong>Remove translations</strong></span>, and then choose the language you want to remove. If you want to change what version of your Google Play page is considered the default, click on the <span class="strong"><strong>Manage Translations</strong></span> button again, and select <span class="strong"><strong>Change default language</strong></span>.</p><p>Creating a localized store listing isn't just about translating your app's description; you should also supply alternate graphics. Even when a user is viewing a localized version of your Google Play page, they may still be unsure whether your app actually supports their language. Don't leave any room for doubt; take screenshots of your UI in all the languages it supports, and then upload these screenshots to the corresponding version of your app's Google Play page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note97"/>Note</h3><p>As you're building your app's Google Play page, Developer Console will offer hints about how your app can reach the widest possible audience. These tips contain some useful information, so make sure you check them out by selecting <span class="strong"><strong>Optimization Tips</strong></span> from the left-hand side menu.</p></div></div></div><div class="section" title="After launching your project"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>After launching your project</h2></div></div></div><p>The hard work doesn't end when you successfully launch your app. Once you hit the <span class="strong"><strong>Publish</strong></span> button and send your app out into the big wild world, there's a whole new bunch of things you can do to help that app reach the widest possible audience.</p><div class="section" title="Following a successful launch – supporting international users"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec79"/>Following a successful launch – supporting international users</h3></div></div></div><p>Once you've attracted an international audience, you need to hang on to that audience—which means offering support in a variety of languages.</p><p>Exactly how much support you can offer will vary depending on whether you have created your app as part of a team, or whether you're a solo developer creating Android apps in your spare time. But offering <span class="emphasis"><em>some</em></span> level of support is crucial if you're going to hang on to the users that you worked so hard to gain in the first place.</p><p>At the very least, you should monitor your app's Google Play reviews. The Google Play store helpfully translates all reviews for you, and you should try and respond to any question or suggestions that come in via Google Play, regardless of the language they're written in.</p><p>Wherever possible, you should respond to Google Play reviews in the poster's language, even if it means resorting to an online translation tool. Just be aware that translation tools tend to generate responses that are a little <span class="emphasis"><em>off,</em></span> so it's a good idea to let users know that you're using a translation tool, just so they know to overlook any clunky phrasing or grammatical errors.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip98"/>Tip</h3><p>
<span class="strong"><strong>Create a Google Play badge</strong></span></p><p>Once you app is live, your goal is to drive as many people to its Google Play page as possible. One way of doing this is to create a Google Play badge. Whenever someone clicks on this badge, it'll take them direct to your app's Google Play listing.</p><p>You can post this badge anywhere you want—on your website, blog, social media accounts, or you can incorporate it into your e-mail signature. Just don't get carried away; no-one likes a spammer, and spamming your app's Play badge isn't going to earn your app a loyal following in the long run.</p><p>You can create a badge using the Google Play Badges generator (<a class="ulink" href="https://play.google.com/intl/en_us/badges">https://play.google.com/intl/en_us/badges</a>).</p></div></div><div class="section" title="Monitor your app's international performance"><div class="titlepage"><div><div><h4 class="title"><a id="ch08lvl4sec24"/>Monitor your app's international performance</h4></div></div></div><p>When you support multiple locales, your app is inevitability going to be more popular in one part of the world than it is in others. There's a whole host of reasons why this might be the case, ranging from things you can control (such as the quality of your translations), to thing you <span class="emphasis"><em>can't</em></span> control (such as a rival app that's already dominating the market in one of your target locales).</p><p>Having a clear picture of your app's popularity across all supported locales is essential for identifying areas where you need to focus more time and effort, and areas where it might make more sense to scale back your efforts or even stop supporting them completely.</p><p>If your app is proving massively popular in one locale, you may decide to put increased effort into meeting the needs of this part of your demographic, such as performing more market research in this area, creating localized content specifically for these users, or even creating language-specific user groups, such as a Google+ community, LinkedIn group, or Facebook page.</p><p>So, how do you identify locales where users <span class="emphasis"><em>love</em></span> your app? Developer Console provides stats about the number of downloads, installs, and uninstalls that your app is racking up across all the different locales it supports. To access this information, log in to your Developer Console account, select the app you want to investigate, and then select <span class="strong"><strong>Statistics</strong></span> from the left-hand side menu.</p><p>But, let's be realistic, these stats aren't always going to be good news, and sometimes they may reveal that your app is struggling to attract users in certain locales. If this is the case, then you should try and figure out what might be hindering your app's success.</p><p>It might be something that you can fix, such as a less-than-perfect translation, or the fact that your app has hardware, software, or screen configuration requirements that aren't representative of the Android devices commonly used in this locale. However, the problem may be something that isn't quite so easy to fix, such as a lack of interest in your app's genre or subject matter, or a rival app that's already dominating the marketplace.</p><p>Depending on the reasons behind your app's poor performance, you may decide to try and address the issue, or you may decide that it makes more sense to drop support for this particular locale and redirect the time and effort into areas where your app has already found an enthusiastic audience.</p><p>Just remember that launching your app internationally is only phase one. If your app is going to find global success, then you'll have to make an ongoing effort to support users from all over the world, as well as continuously monitor how your app is faring in all the different locales.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl2sec114"/>Summary</h1></div></div></div><p>In this chapter, we looked at how to reach the widest possible audience, from supporting different versions of the Android operating system, to optimizing your app for different hardware, software, screen sizes, screen densities, and orientations. We even covered translating our app into different languages. We also touched on how to promote your app via advertising and marketing campaigns.</p><p>Now that you know how to attract an audience, in the next chapter, we'll look at how to wow this audience by optimizing our app's UI.</p></div></body></html>