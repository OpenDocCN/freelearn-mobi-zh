- en: Chapter 2. OpenGL ES 3.0 Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：OpenGL ES 3.0 基础
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下小节：
- en: Building prototypes using the GLPI framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GLPI 框架构建原型
- en: Implementing touch events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现触摸事件
- en: Rendering primitives with vertex arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点数组渲染原语
- en: Drawing APIs in OpenGL ES 3.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的绘图 API
- en: Efficient rendering with Vertex Buffer Object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点缓冲对象进行高效渲染
- en: Transformations with the model, view, and projection analogies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型、视图和投影类比进行变换
- en: Understanding the projection system in GLPI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GLPI 中理解投影系统
- en: Culling in OpenGL ES 3.0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的剔除
- en: Depth testing in OpenGL ES 3.0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的深度测试
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will provide a detailed description of the basic concepts that
    are required to understand 3D graphics and implement them using OpenGL ES 3.0\.
    In the beginning of this chapter, we will build a mini portable 3D engine that
    will be helpful in creating small prototype-based projects quickly. It manages
    the code effortlessly in the OpenGL ES 3.0 programmable pipeline. You will learn
    event handling to manage gestures on the screen surface under Android and iOS
    platforms. These will be helpful in implementing gesture-based applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细描述理解 3D 图形并使用 OpenGL ES 3.0 实现它们所需的基本概念。在本章的开始，我们将构建一个迷你便携式 3D 引擎，这将有助于快速创建基于原型的项目。它在
    OpenGL ES 3.0 可编程管道中轻松管理代码。您将学习事件处理，以在 Android 和 iOS 平台上管理屏幕表面的手势。这些将有助于实现基于手势的应用程序。
- en: As we move on, we will discuss the fundamental transformation in the 3D graphics
    with the help of the model, view, and projection analogy. At the core side, we
    will look at the different types of available primitives to render a given geometry
    in OpenGL ES 3.0 and discuss optimization techniques that could increase rendering
    performance using **Vertex Buffer Object** (**VBO**). As we approach the end,
    we will understand geometry culling. It controls the rendering of front or back
    faces of an object. The last recipe of the chapter will implement depth testing,
    which is a very important aspect of computational graphics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将借助模型、视图和投影的类比来讨论 3D 图形中的基本变换。在核心方面，我们将探讨在 OpenGL ES 3.0 中渲染给定几何形状的不同原语类型，并讨论使用
    **顶点缓冲对象**（**VBO**）可能提高渲染性能的优化技术。随着接近尾声，我们将了解几何剔除。它控制着对象的前面或后面的渲染。本章的最后一个小节将实现深度测试，这是计算机图形学中的一个非常重要的方面。
- en: Building prototypes using the GLPI framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GLPI 框架构建原型
- en: The GLPI is an OpenGL ES platform-independent framework. It is a mini 3D engine
    that is highly useful for developing prototype applications rapidly. It provides
    higher-level utility classes to render engines, shader compilations, 3D transformations,
    mesh management, buffer management, textures, and many more. The framework primarily
    supports Android and iOS platforms and is designed to be easily portable to other
    platforms such as WinCE, Blackberry, Bada, and so on. We will go through each
    module of this framework in detail in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GLPI 是一个 OpenGL ES 平台无关的框架。它是一个高度有用的迷你 3D 引擎，可以快速开发原型应用程序。它为渲染引擎、着色器编译、3D 变换、网格管理、缓冲区管理、纹理等提供了高级实用类。该框架主要支持
    Android 和 iOS 平台，并设计为易于移植到其他平台，如 WinCE、Blackberry、Bada 等。在本章中，我们将详细讨论此框架的每个模块。
- en: 'This framework provides dedicated modules for rapid development of the OpenGL
    ES 3.0 prototype applications. It comprises of three main modules, as shown in
    the following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架为 OpenGL ES 3.0 原型应用程序的快速开发提供了专用模块。它包括以下三个主要模块，如图所示：
- en: '![Building prototypes using the GLPI framework](img/5527OT_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GLPI 框架构建原型](img/5527OT_02_01.jpg)'
- en: 'Let''s look at each of them in detail:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细探讨它们：
- en: '**GLPI module**: This module is the backbone of the GLPI framework. It contains
    the following classes inside it:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLPI 模块**：此模块是 GLPI 框架的骨干。它包含以下类：'
- en: '| Class | Function |'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 类别 | 功能 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Program Manager` | This class is responsible for creating the shader program
    from program objects. It maintains all the program objects in a single manageable
    piece that other modules can use as and when required. |'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `程序管理器` | 此类负责从程序对象创建着色器程序。它维护所有程序对象在一个可管理的单一组件中，其他模块可以在需要时使用。|'
- en: '| `Shader Manager` | This class is responsible for generating the shader''s
    object. It automates the processes of loading, compiling, and generating the shader
    object for the program manager. |'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `着色器管理器` | 此类负责生成着色器对象。它自动化了为程序管理器加载、编译和生成着色器对象的流程。|'
- en: '| `Transform` | This class provides high-level APIs for 3D transformation operations.
    It also provides wrapper functions to mimic fixed function pipeline APIs, such
    as transformation, model-view-projection matrices, push and pop matrix operation,
    and so on. |'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `变换` | 此类提供用于3D变换操作的高级API。它还提供了包装函数来模拟固定功能管道API，例如变换、模型视图投影矩阵、推和弹出矩阵操作等。|'
- en: '| `GLUtils` | This class provides helper functions for the GLPI module. |'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `GLUtils` | 此类为GLPI模块提供辅助函数。|'
- en: '**Model module**: This module will help us create custom models for our application.
    A `Model` class essentially represents any type of geometric object that we are
    interested in rendering on the device screen. This class provides the model''s
    initialization, state management, processing, and rendering routines. It also
    provides touch events handling within the model.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型模块**：此模块将帮助我们为我们的应用程序创建定制模型。`Model`类本质上代表我们在设备屏幕上感兴趣渲染的任何类型的几何对象。此类提供模型的初始化、状态管理、处理和渲染例程。它还在模型内提供触摸事件处理。'
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Model` class of the renderer module represents any kind of 3D rendering
    object that we are interested to render on the screen. For example, if we are
    willing to render a triangle, then we should be creating a `Triangle` class that
    must be derived from the `Model` class and should be added to the `Renderer` class
    as a child member.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 渲染模块的`Model`类代表我们在屏幕上感兴趣渲染的任何类型的3D渲染对象。例如，如果我们愿意渲染一个三角形，那么我们应该创建一个`Triangle`类，这个类必须从`Model`类派生，并且应该作为子成员添加到`Renderer`类中。
- en: '**Renderer module**: This is the rendering engine''s manager that acts as an
    interface between the underlying platform (such as Android or iOS) and our platform-independent
    graphics framework. It manages the entire graphics system rendering life cycle.
    In addition to this, the custom models created by us will also be managed by it.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染模块**：这是渲染引擎的管理器，它充当底层平台（如Android或iOS）和我们的平台无关图形框架之间的接口。它管理整个图形系统渲染的生命周期。除此之外，我们创建的定制模型也将由它管理。'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the previous chapter, we implemented the Hello World Triangle recipe for
    Android and iOS platforms. Now, you will learn to use the GLPI framework by reimplementing
    the same recipe in GLPI. You can refer to the source code of this recipe by locating
    `GLPIFrameworkIntro` in the sample code of this chapter. In the following steps,
    we will set up the GLPI framework for Android/iOS platforms and learn to use it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为Android和iOS平台实现了Hello World三角形的配方。现在，你将通过在GLPI中重新实现相同的配方来学习使用GLPI框架。你可以通过在本章的示例代码中定位`GLPIFrameworkIntro`来参考此配方的源代码。在以下步骤中，我们将为Android/iOS平台设置GLPI框架，并学习如何使用它。
- en: '**Follow these instructions to set up GLPI for the Android platform**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**按照以下说明为Android平台设置GLPI**：'
- en: 'Create the `Android.mk` makefile as. The makefile includes the path of the
    `zlib` makefile for compilation purpose. It is used to read/write compressed files.
    The `zlib` file is compiled as a shared library and included in the project. The
    additional libraries include `-lEGL -lGLESv3`, which provides support for EGL,
    and OpenGL ES 3.0 and `-llog`, which allow log information that would be helpful
    in debugging the application:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Android.mk` make文件。make文件包括用于编译目的的`zlib` make文件的路径。它用于读取/写入压缩文件。`zlib`文件被编译为共享库并包含在项目中。附加库包括`-lEGL
    -lGLESv3`，它提供对EGL、OpenGL ES 3.0的支持，以及`-llog`，它允许记录有助于调试应用程序的日志信息：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new make-file `Application.mk` in the same directory and add STL,
    RTTI, and exception support to your project as shown in the following lines of
    code. For OpenGL ES 3.0, the Android platform API level must be 18 or greater:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个新的`Application.mk` make文件，并将STL、RTTI和异常支持添加到你的项目中，如下面的代码行所示。对于OpenGL
    ES 3.0，Android平台的API级别必须为18或更高：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The chapters from now onwards contain two separate sections for Android and
    iOS development. These sections will be identified by folder names called Android
    and iOS. `NativeTemplate.h` and `NativeTemplate.cpp` (as described in the first
    chapter) are placed next to these folders. If we look at these files now, we will
    realize that they are much cleaner and contain lesser code than earlier. We have
    moved the code from these files to other files in the `Scene` folder:![How to
    do it...](img/5527OT_02_02.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Scene` folder contains the `Model` and `Renderer` classes that take care
    of generating models and rendering them. Another class that is present in this
    folder is the `Triangle` class. It contains the code to render the blue triangle.
    Make sure that all classes are included in `Android.mk`:![How to do it...](img/5527OT_02_03.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder called `Shader` under the `assets` folder and create the
    shader files (`BlueTriangleVertex.glsl` and `BlueTriangleFragment.glsl`) inside
    this folder. Move the shader programs that were earlier present in `NativeTemplate.cpp`
    (in the form of a string) into the newly created `Shader` folder. From now on,
    we will manage our shader programs in this folder.![How to do it...](img/5527OT_02_04.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For iOS, the steps to set up the framework are relatively easy and are listed
    here**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Import (**Xcode** | **File** | **Add Files to <Project>**) all the GLPI framework
    contents into your project, except the `zlib` library. This library is only used
    for Android for file management. It is not required by iOS.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the imported contents, go to the `glm` library and remove the `core` folder
    (this folder contains some sample programs that may cause errors in the existing
    project because of the presence of multiple `main()` entries).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the shader files by going to `Android` | `Asset` | `Shader` folder (`BlueTriangleVertex.glsl`
    and `BlueTriangleFragment.glsl` ) into the current project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `"FILESYSTEM"` environment variable in `main.m`. This will provide
    the current path of the application in the device:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![How to do it...](img/5527OT_02_05.jpg)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The use of the GLPI framework is very simple. We must follow this set of rules
    in order to render our 3D geometric models:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new custom model class that is derived from the `Model` class. For
    example, we have created the `Triangle` class that was derived from the `Model`
    class in `Triangle.h`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open `constant.h` and edit enum `ModelType`. Add the enumeration of your choice
    to recognize the model type. For example, there are two enums added for `Triangle`
    and `Cube`. This enumeration will be helpful for the renderer to manage model
    objects:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the constructor of `Triangle`, define `ModelType`. Each model contains the
    renderer object as its parent. It also contains reference to `ProgramManager`
    and `Transform`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the `VERTEX_SHADER_PRG` and `FRAGMENT_SHADER_PRG` macros in `Triangle.cpp`
    to define the relative path of the shader files in the iOS and Android platforms.
    These macros provides a platform-independent way to access the shader source code
    files from the project solution:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `InitModel()` function. Here, we need to compile our shader and
    register it with `ProgramManager` for the future use. `ProgramManager` stores
    the compiled shaders in an optimal way to provide quick access to the queried
    attributes. Always provide a name to the shader (in our case, `Triangle`). `ProgramManager`
    uses it as a handle, which will be helpful to retrieve the shader from any type
    of model class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Override the `Render()` function. It is responsible for rendering the colored
    triangle on the screen surface. In this function, first, the shader program is
    used to query the respective attributes. These attributes are used to send the
    data to the shader. Each frame of the triangle is rotated by 1 degree and updated
    in the shader:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Destroy the shaders when they are not required. For this recipe, we will use
    the destructor:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The shader created in our class is publicly accessible to other models in our
    rendering engine. Therefore, it is completely up to us whether to destroy it or
    to keep it in the rendering engine.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `Renderer.cpp`, add the `Triangle` model in `Renderer::createModels()`
    after the `clearModels()` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `clearModels()` ensures that there is no conflict in the rendering engine
    for the `Model` object and shaders. Therefore, it provides a clean approach to
    avoid any redundancy in OpenGL ES shaders.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Override the `Render()` function. This function is responsible for making the
    rendering model to appear on the screen.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Renderer` class is the manager of the rendering system. Each custom model
    defined in the GLPI framework acts as a registered member of `Renderer` and is
    recognized by its unique model type. `Renderer` provides services to the registered
    components through utility and helper classes such as `Transform` and `ProgramManager`
    interfaces. The rendering engine iterates through the entire registered models
    to define their life cycles. It ensures that the initialization, rendering, and
    destruction of the models takes place at the right time and in the right order.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgramManager` is responsible for compiling the shader and caches it for
    later use. Transform plays a vital role in the geometric transformation operations.
    For example, it helps in placing models in the 3D space using rotation, translation,
    and scaling operations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the internals of the 3D transformation, you can refer
    to *Understanding transformation in 3D graphics* in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0*.
    This topic covers types of transformation, transformation matrix conventions,
    homogenous coordinates, and transformation operations such as translation, scaling,
    and rotation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the `Renderer` class, the scene's projection can be adjusted using the
    `setUpProjection()` function. This function is responsible for setting the view
    clipping planes. The clipping plane can be defined in the form of frustum (perspective)
    or cuboid (orthographic) shape. We will discuss more about projections later in
    this chapter in the *Understanding the projection system in GLPI* recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Developing an Android OpenGL ES 3.0 application* and *Developing
    an iOS OpenGL ES 3.0 application* recipes in [Chapter 1](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing touch events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's smartphones are capable of interacting with applications through gestures.
    These gestures are made on the surface of the touch-sensitive device screen. When
    the device senses these gesture inputs, it reports the touch events to the corresponding
    application handler. The application handler receives these events and filters
    them out, according to the application's requirement. In this recipe, we will
    implement the touch events using OpenGL ES 3.0 on iOS and Android platforms. You
    will learn to receive the events and handle them in a platform-independent way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GLSurfaceView` class in Android and `GLKViewController` in iOS provide
    the necessary APIs to implement touch events. These APIs report the nature of
    detected touch events, such as if the user has tapped or moved their figure on
    the device screen. These APIs are exposed to the GLPI framework through common
    touch event interfaces. These interfaces are responsible for reporting and propagating
    the touch events to the registered members. The base class of the registered member
    (`Model`) contains all the touch event interfaces that can be handled by the derived
    versions. Since these are the only interfaces, the registered members need to
    override them in order to use them according to their custom needs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will provide a detailed description of how to set up and implement
    touch events on the Android and iOS platforms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: First, implement the common interfaces in the `NativeTemple` and `Renderer`
    classes that can receive the touch events in a common fashion, irrespective of
    the platform implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare and define the touch event interface in the `Renderer` class. For example,
    the following code shows the tap event implementation:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `NativeTemple.h`/`.cpp`, call the renderer''s touch events from the globally
    declared and defined wrapper functions:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the Android platform, we need to define new JNI native methods in `NativeTemplate.h`/`.cpp`
    that can communication with the Android framework in order to retrieve the touch
    events. For this, define the following interface for tap events in the `GLESNativeLib`
    Java class:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `NativeTemplate`, declare and define the JNI interface for the tap event
    declared earlier:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Repeat steps 1 to 4 to implement the move and release touch events.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override `onTouchEvent()` of the `GLSurfaceView` class. This function provides
    various types of touch events. For example, the tap, move, single/multi touch,
    and so on are some of the important events. These events needs to be filtered
    in order that they can be used:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the iOS platform, the GLKit''s `GLKViewController` class provides touch
    functions that need to be overridden in order that they can be used in our application.
    For example, have a look at the following code. It implements the tap, move, and
    release events similar to the Android case. Each of the definitions calls the
    global wrapper functions of `NativeTemplate.h`/`.cpp`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an Android or iOS application receives the touch event from the device,
    it is the responsibility of `GLSurfaceView` and `GLKViewController` to convey
    these touch events to the external world. These classes report the touch events
    to the global wrapper function that is defined in the `NativeTemple`. This file
    provides higher level cross-platform functions for touch events such as tap, move,
    and release. These functions are internally interfaced with the corresponding
    touch event interfaces of the `Renderer` class. The `Renderer` class provides
    the interface to handle touch events in an abstracted way in which it works seamlessly
    on either platform. These functions or interfaces are called from the Android
    or iOS platform through `NativeTemplates` global methods and propagated to all
    the registered models. For instance, the following example shows the handling
    of the move event:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Depth testing in OpenGL ES 3.0*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering primitives with vertex arrays
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In OpenGL ES 3.0, the vertex array is a simplest mean to draw the objects in
    the 3D space. The objects are drawn with the help of vertices, which are arranged
    in a specific order guided by the rendering primitives. The rendering primitives
    represent how an individual or a set of vertices can assemble to draw a geometry.
    For example, four vertices can be represented by a point, line, or triangle, as
    shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering primitives with vertex arrays](img/5527OT_02_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: The vertex array is the way in which the geometric data, such as vertex coordinates,
    normal coordinates, color information, and texture coordinates, are specified
    in the form of arrays. In this recipe, you will learn to program a vertex array
    in the GLPI framework. In addition to this, we will also demonstrate various available
    rendering primitives in OpenGL ES 3.0.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new class called `Primitive` derived from the `Model` class and follow
    this step-by-step procedure to implement the rendering primitive with the vertex
    array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `PrimitiveVertex.glsl` and `PrimitiveFragment.glsl` and use the following
    code for the vertex and fragment shaders:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a set of 10 vertices, as shown in the following figure. Then, store the
    information into the vertices array and assign colors to each vertex. The color
    information is stored in the form of RGB in the colors array.![How to do it...](img/5527OT_02_07.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `initModel` function, compile and link the vertex and fragment shaders.
    On successful creation of the shader program object, query the vertex attributes
    `VertexPosition` and `VertexColor` using a GLPI wrapper function called `ProgramGetVertexAttribLocation`.
    This function internally uses OpenGL ES 3.0 generic vertex attribute query APIs.
    Using the wrapper APIs decreases the chances of errors and increases the performance,
    as these queries are optimized:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ProgramGetVertexAttribLocation` returns the generic attribute location ID.
    A negative value of the location ID specifies that no attribute with that name
    exists in the shader.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Variable | Description |'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the attribute in the shader source program |'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Within the same `initModel` function, query the uniform using another wrapper
    API from the GLPI framework:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ProgramManager` in the GLPI framework provides a high-level wrapper function
    `ProgramGetUniformLocation` to query any uniform type variable from the shader
    program.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Variable | Description |'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the uniform object in the shader source program
    |'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Create a `RenderPrimitive` function and call it inside `Render`. Inside this
    function, send the uniform and per-vertex attribute data to the shader:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Enable the vertex and color-generic attributes and draw various primitives
    using switch case statements:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe has two arrays, vertices, and colors, which contains the vertex
    information and color information. There are 10 vertices, and each vertex stores
    an `X`, `Y` component. The color information also contains 10 different colors
    for each vertex. The color information is specified in the RGB color space in
    the range of 0.0 to 1.0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader contains two per-vertex attributes, `VertexPosition` and `VertexColor`.
    These attributes are uniquely recognized in the program via the attribute location.
    This location is queried using the `ProgramGetVertexAttribLocation` function.
    The queried attribute serves the purpose of binding vertex array information to
    the per-vertex attributes. The vertex attribute data is sent using `glVertexAttribPointer`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the uniform variable is also queried in the same fashion using a
    separate function called `ProgramGetUniformLocation`. The uniform variable is
    a 4 x 4 matrix of `ModelViewProjection`. Therefore, the data is sent to the shader
    using `glUniformMatrix4fv`. The `glLineWidth` function is meant for the `GL_LINE`
    variant primitives to define the width of the line as 10 pixels wide.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the OpenGL ES 3.0 primitives are rendered using `glDrawArrays`. Various
    primitive rendering can be seen in action by a simple tap on the screen. Upon
    tapping, the tap event will invoke the `TouchEventDown` function of the `Primitive`
    class, which is responsible for changing the current primitive type for rendering:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: In computer 3D graphics, the polygon shapes are rendered using the triangle
    primitives. Using `GL_TRIANGLE_STRIP`, as compared to `GL_TRIANGLES`, is preferred
    because the number of vertices needed to specify the shape of the triangle is
    lesser when compared to `GL_TRIANGLES`. In the latter case, more data has to be
    sent from the CPU to the GPU, as adjacent edges share common vertices. In the
    former case, the vertices are arranged in a special order in which duplicate vertices
    from the shared edges are avoided. Hence, it requires less data. It is true that
    `GL_TRIANGLE_STRIP` may be better in certain cases due to lesser data needed to
    be defined. However, this needs to be considered on a case-by-case basis, depending
    on the 3D model format.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of tools available that can be used to convert the geometry
    information in the triangle-strip form. For example, nVIDIA's `NvTriStrip` library
    generates triangle strips from an arbitrary 3D geometry. For more information,
    visit [http://www.nvidia.com/object/nvtristrip_library.html](http://www.nvidia.com/object/nvtristrip_library.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the drawing APIs, refer to the *Drawing APIs in OpenGL
    ES 3.0* recipe. It demonstrates `glDrawArrays` and `glDrawElements`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will focus on the basic rendering primitives available in OpenGL
    ES 3.0\. Primitives are the simplest shapes that can be used to generate any complex
    shape in 3D graphics. The OpenGL ES 3.0 primitives can be categorized into three
    basic types: point, line and triangle. The rest are variations of these.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes all the variant primitives of point, line, and
    triangle available in OpenGL ES 3.0:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '| Primitive types | Input vertex | Output shape | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `GL_POINTS` | ![There''s more…](img/5527OT_02_09.jpg) | ![There''s more…](img/5527OT_02_10.jpg)
    | A point on the screen that represents each vertex. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINES` | ![There''s more…](img/5527OT_02_11.jpg) | ![There''s more…](img/5527OT_02_12.jpg)
    | Each pair of vertices is used to render a line between them. We can use the
    `glLineWidth()` API to control the width of the line rendering. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINE_LOOP` | ![There''s more…](img/5527OT_02_13.jpg) | ![There''s more…](img/5527OT_02_14.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. The last
    vertex always joins the first vertex to form a closed loop. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINE_STRIP` | ![There''s more…](img/5527OT_02_15.jpg) | ![There''s more…](img/5527OT_02_16.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLES` | ![There''s more…](img/5527OT_02_17.jpg) | ![There''s more…](img/5527OT_02_18.jpg)
    | A set of three vertices is used to form a filled triangle. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLE_STRIP` | ![There''s more…](img/5527OT_02_19.jpg) | ![There''s
    more…](img/5527OT_02_20.jpg) | Every vertex makes a triangle with the preceding
    two vertices. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLE_FAN` | ![There''s more…](img/5527OT_02_21.jpg) | ![There''s
    more…](img/5527OT_02_22.jpg) | Every vertex makes a triangle with the first vertex
    and the vertex preceding it. This generates a fan-like pattern. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using uniform* *variables to send data to a* *shader* and *Using
    per-vertex attribute to send data to a shader* recipes in [Chapter 1](ch01.html
    "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing APIs in OpenGL ES 3.0
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenGL ES 3.0 provides two types of rendering APIs: `glDrawArrays` and `glDrawElements`.
    These APIs allows us to render the geometric data on the screen in the form of
    primitives. In this recipe, you will learn how these APIs are used in programming
    and understand the difference between them.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will render a cube by using the two different rendering APIs mentioned
    earlier. The datasets used by these APIs are entirely different. Tap on the screen
    to see the difference between the two APIs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glDrawArray` API reads the vertex information in the form of an array in
    sequential order, starting from the first index to total number of indexes specified
    by the count. The `glDrawArray` API renders primitives specified by the mode argument
    using vertex array data information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Variable | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This specifies the type of OpenGL ES primitive that needs to be
    rendered |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `first` | This is the start index of the data array |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `count` | This denotes the total number of indices to be rendered |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: 'For example, a square can be rendered as a set of two triangles:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In contrast, the `glDrawElement` API maps each vertex using an index similar
    to the one that accesses elements in an array using C++/Java. This method of rendering
    consumes less memory compared to `glDrawArray`, where each redundant vertex needs
    to be mentioned with its `X`, `Y`, and `Z` components. For example, take a case
    of regular cube geometry and calculate the memory saving offered by `glDrawElement`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Variable | Description |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This specifies the primitive type as described in the preceding
    table |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `count` | This specifies the number of elements to be rendered |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `type` | This specifies the data type of indices |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `indices` | This specifies the order of indices for vertex arrangement in
    an array form |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: 'For example, the same square can be represented as follows using this API:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following instructions will provide a step-by-step procedure to demonstrate
    the use of the `glDrawArrays` and `glDrawElements` APIs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Cube` class derived from `Model`. There is no change required in the
    vertex and fragment shaders. `Shaders` from the previous recipe can be reused.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the vertex and color dataset for the `glDrawArray` API:![How to do it...](img/5527OT_02_23.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, define the dataset for the `glDrawElement` API:![How to do it...](img/5527OT_02_24.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `InitModel`, compile and link the shaders. On successful compilation, query
    `ModelViewProjectionMatrix`, `VertexPosition`, `VertexColor` and store them into
    `MVP`, `attribVertex`, `attribColor`, respectively. Enable vertex and color-generic
    attributes:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the render function, implement the following code to demonstrate both
    APIs in action:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glDrawArray` rendering API uses vertex attributes, such as vertex coordinates,
    color information, and texture coordinate, in the form of a continuous data array
    in which the data reading cannot be skipped or hopped. The information is highly
    redundant, as the same vertices share among the different face are repeatedly
    written. In this recipe, `vertexBuffer` and `colorBufferData` store vertex coordinates
    and color information. This information is sent to the vertex shader using `attribVertex`
    and `attribColor`. Finally, the `glDrawArray` call is made with parameters specifying
    the type of primitive and index of the vertices that need to go for rendering
    (the start and end index).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `glDrawElement` uses `cubeVert` and `cubeColors`, which contain
    the nonredundant vertex and color information. It uses an additional array that
    contains the indices of the vertex information. Using this array, the primitives
    are rendered by hopping around the vertex arrays. Unlike `glDrawArray`, which
    works on the continuous set of vertex data, `glDrawElement` can jump from one
    vertex to another using the index information provided to it in the last parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In OpenGL ES 3.0, the polygons are drawn as a set of triangles. Each of these
    triangles has two faces: a front face and back face. For example, the following
    image represents a square geometry with vertices v0, v1, v2, and v3\. It is made
    up of two triangles. The order of vertex winding (clockwise or anticlockwise)
    is used by OpenGL ES 3.0 to determine whether the triangle is front facing or
    back facing. In this case, the vertices are winded in an anticlockwise direction.
    By default, OpenGL ES 3.0 considers the anticlockwise windings as front facing.
    This convention can be changed by setting `glFrontFace` (counter clockwise) as
    `GL_CW` or `GL_CCW` (counter clockwise).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The winding order is always specified from the user's visualization point of
    view. The OpenGL ES pipeline takes care of this winding and displays them correctly
    from the camera's point of view. For example, when we specify the vertices of
    a cube geometry, it should be in the counter-clockwise order as per the default
    convention. However, we know very well that the faces that are parallel to each
    other have opposite winding orders when viewed from the camera's point of view,
    as shown in the following figure. OpenGL ES automatically generates the correct
    winding order from the camera's point of view.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The front and back faces are used in geometry culling. For more information
    on geometry culling and front/back face definitions, refer to the *Culling in
    OpenGL ES 3.0* recipe later in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_02_25.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing* *APIs in OpenGL ES 3.0*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Culling in OpenGL ES 3.0*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient rendering with Vertex Buffer Object
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertex information comprises of geometric coordinates, color information,
    texture coordinates, and normal vectors. This information is stored in the form
    of an array and always resides in the local memory (RAM, which is accessible by
    the CPU) of the device. Each frame when rendering command is executed. This information
    is copied from the local memory and sent to the GPU. This vertex information is
    sent over the data bus, which has a slower speed compared to the GPU's processing
    speed. Additionally, the latency time on the local memory also adds a slight delay.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: VBO is a faster way to render 3D objects. The VBO uses the full advantage of
    **Graphics Processor Unit** (**GPU**) and store the geometric data on GPU's memory
    instead of storing it on the local RAM memory. This helps OpenGL ES to avoid continuous
    sending of data from local memory to the GPU each time a draw call is made.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the VBO can be divided into four steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Create a new buffer object using `glGenBuffers()`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind this buffer object to pipeline with `glBindBuffer()`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory to store data using `glBufferData()`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store/modify the data into portions of the allocated buffer object with `glBufferSubData()`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow this step-by-step procedure to implement the VBO recipe:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: First, create a vertex buffer object using the `glGenBuffers` API. This API
    generates n number of vertex buffer objects, where each vertex buffer object is
    recognized by a unique name or handle returned by this API. This handle is an
    unsigned `int` ID that is used to perform various operations on the VBO.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Variable | Description |'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `N` | This is a number of buffer object names that need to be generated |'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `buffers` | This specifies an array that contains buffer objects on successful
    creation |'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Bind the created vertex buffer object IDs to the underlying pipeline with the
    `glBindBuffer` API.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| Variable | Description |'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This specifies the symbolic constant target to which the buffer
    object name needs to be bound. It could accept `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`,
    `GL_UNIFORM_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, and so on. |'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `buffers` | This is the name of the buffer object that we created using `glGenBuffer`.
    |'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Allocate and initialize the memory by specifying the size of the geometric arrays,
    such as vertex, color, normal, and so on, with `glBufferData`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Variable | Description |'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This parameter is similar to what is defined in `glBindBuffer`,
    as described earlier. |'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `size` | The size of the buffer needs to be allocated in bytes. |'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `data` | This is a pointer to the data array that contains geometry information.
    If this is `NULL`, then no data would be copied. The data can be copied later
    using the `glBufferSubData` API. |'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `usage` | This is the expected type of pattern used for data store. |'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The `usage` parameter provides hints to the OpenGL ES system about how the
    data is patterned, so that it can be handled intelligently and efficiently when
    it comes to storing or accessing the data. This parameter can accept one of the
    following types:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Types | Meaning |'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_STREAM_DRAW` | This type of vertex buffer data is rendered for a small
    number of times and then discarded |'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_STATIC_DRAW` | This is a type of buffer data that is rendered many times,
    and its contents never changes |'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_DYNAMIC_DRAW` | This type of buffer data is rendered many times, and
    its content changes during rendering |'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The `glBufferData` creates the buffer data store for the current bound target
    with the required size. If the data parameter is initialized with `NULL`, then
    the buffer remains uninitialized. This VBO can be initialized later using the
    `glBufferSubData` API.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| Variable | Description |'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This parameter is similar to what is defined in the `glBindBuffer`
    as described earlier |'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `offset` | This is the index on the buffer store, specifying the start location
    from where the data will be written |'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `size` | This is the data size in bytes that needs to be filled in the buffer
    store, starting from the offset position |'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `data` | This is a pointer to the new data that will be copied into the data
    store |'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The following program implements the VBO with all the APIs discussed earlier:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the rendering will be performed by binding the VBO and specifying
    the generic attribute data in terms of offset in the buffer object, as shown here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glGenBuffers` API creates a number of vertex buffer objects specified by
    the first parameter `n`. It returns the VBO ID (handle) array if the vertex buffer
    objects are successfully created.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Once the VBO are created, they need to bind to the target with the `glBindBuffer`
    API. Basically, the target tells the VBO what type of vertex data it can store.
    This data can be either a vertex array or an index array data. The vertex array
    data contains vertex information, such as position, color, texture coordinate,
    and so on. However, the index array contains the order vertex index information.
    Therefore, the target could be specified as `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了VBO（顶点缓冲对象），它们需要通过`glBindBuffer` API绑定到目标。基本上，目标告诉VBO它可以存储哪种类型的顶点数据。这些数据可以是顶点数组或索引数组数据。顶点数组数据包含顶点信息，如位置、颜色、纹理坐标等。然而，索引数组包含顶点索引的顺序信息。因此，目标可以指定为`GL_ARRAY_BUFFER`或`GL_ELEMENT_ARRAY_BUFFER`。
- en: The data size required to fill into the bound vertex buffer object is specified
    using `glBufferData`. We also need to specify the nature of data the VBO is going
    to store. The final `step` is to fill in the buffer object with data. We can use
    `glBufferSubData` to fill the vertex data. The VBO allows us to specify multiple
    arrays in the same buffer object. We can use offset and size one after the other.
    Make sure that you bind the buffer object to the current rendering state before
    rendering with the `glBindBuffer` API. The VBO can be deleted using `glDeleteBuffers`
    as per the program requirement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glBufferData`指定填充到已绑定顶点缓冲对象中的数据大小。我们还需要指定VBO将要存储的数据的性质。最后的`步骤`是将数据填充到缓冲对象中。我们可以使用`glBufferSubData`来填充顶点数据。VBO允许我们在同一个缓冲对象中指定多个数组。我们可以依次使用偏移量和大小。确保在用`glBindBuffer`
    API渲染之前，将缓冲对象绑定到当前渲染状态。根据程序要求，可以使用`glDeleteBuffers`删除VBO。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an application uses multiple VBO, then it is advisable to bind the VBO to
    `0` after rendering of the model. This way, the original states remain preserved.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用多个VBO，那么在模型渲染后将其绑定到`0`是明智的。这样，原始状态得以保留。
- en: Transformations with the model, view, and projection analogies
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型、视图和投影类比进行变换
- en: To define a rendering scene in computer 3D graphics, model, view, and projection
    is the cleanest approach. It dissects a scene into these three logical concepts
    that helps us visualize the scene clearly before it appears on paper or in the
    form of a program. It will not be wrong to say that it is a modular approach to
    scene visualization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机3D图形中定义渲染场景，模型、视图和投影是最干净利落的方法。它将场景分解为这三个逻辑概念，帮助我们清晰地可视化场景，在它以纸张或程序形式出现之前。可以说，这是一种模块化的场景可视化方法。
- en: '**Object**: An object is a defined by a set of vertices in the 3D space. Each
    object has its own origin. For example, a cube contains eight vertices with respect
    to the origin at the center. The vertices used to define the object are called
    object coordinates:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**：一个对象是由3D空间中的一组顶点定义的。每个对象都有自己的原点。例如，一个立方体相对于中心原点包含八个顶点。用于定义对象的顶点称为对象坐标：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_26.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_26.jpg)'
- en: '**Model**: Modeling in 3D graphics is a transformation process where an object
    is displaced to an arbitrary position in the 3D space. This 3D space is called
    world space (also known as model space). For example, we can use several instances
    of our cube object and place them in the 3D space so that they form the English
    alphabet **T**.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**：在3D图形中建模是一个变换过程，其中对象被移动到3D空间中的任意位置。这个3D空间被称为世界空间（也称为模型空间）。例如，我们可以使用我们立方体对象的几个实例，并将它们放置在3D空间中，以便它们形成英文字母**T**。'
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modeling is achievable by a 4 x 4 matrix called the Model Matrix. Programmatically,
    an identity matrix, which is multiplied by transformation matrices, contains scale,
    translation, and rotation information. The resultant is the Model Matrix.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 建模可以通过一个4x4的矩阵实现，称为模型矩阵。从程序的角度来看，一个单位矩阵，它与变换矩阵相乘，包含缩放、平移和旋转信息。结果是模型矩阵。
- en: '**Viewing**: In simpler terms, we can say that the view is a position in the
    3D space from which the model needs to be viewed. For example, in engineering
    drawing, there are three types of views: the top, front, and side views. These
    are produced by moving the camera in the *x*, *y*, and *z* axes and looking towards
    the origin of the viewing object. The viewing is a transformation that applies
    on the world coordinates to produce eye coordinates.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**：用更简单的话来说，我们可以这样说，视图是在三维空间中的一个位置，从该位置需要观察模型。例如，在工程制图中，有三种类型的视图：俯视图、正视图和侧视图。这些是通过在*x*、*y*和*z*轴上移动相机并朝向观察对象的起点来产生的。观察是一个变换，它应用于世界坐标以产生眼睛坐标。'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_27.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_27.jpg)'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Model-view analogy: The model and view concepts we discussed earlier are completely
    interchangeable. This means that we can do all the view transformations with model
    transformation and vice versa. For example, we can make the object scale by viewing
    it closer or placing it near the viewing location. Similarly, translation and
    rotation operations can also be performed on this object. Therefore, many books
    represent it as a model-view approach, so don''t get confused with this term.
    Mathematically, model view is just another 4 x 4 matrix that is achieved by multiplying
    view matrix and the model matrix.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图类比：我们之前讨论的模型和视图概念是完全可互换的。这意味着我们可以使用模型变换来完成所有视图变换，反之亦然。例如，我们可以通过靠近观察对象或将其放置在观察位置附近来调整对象的缩放。同样，也可以对这个对象执行平移和旋转操作。因此，许多书籍将其表示为模型-视图方法，所以不要对这个术语感到困惑。从数学上讲，模型视图只是通过乘以视图矩阵和模型矩阵而得到的另一个4x4矩阵。
- en: '**Projection**: Projection transformation is the process where a scene is restricted
    by a clipping region in the form of a frustum or cuboidal. Both forms have six
    clipping planes that are helpful in restricting the objects, by clipping the objects
    present outside these clipping planes. This stage helps the graphics system increase
    the performance by considering only a finite set of objects within the frustum
    box. The following figure shows the role of frustum clipping planes. The result
    of the eye coordinates on projection system is clip coordinates:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**投影**：投影变换是将场景限制在以截锥体或立方体形式存在的裁剪区域内的过程。这两种形式都有六个裁剪平面，有助于通过裁剪位于这些裁剪平面之外的对象来限制对象。这一阶段通过只考虑截锥体框内的有限对象集来帮助图形系统提高性能。以下图显示了截锥裁剪平面的作用。投影系统上眼睛坐标的结果是裁剪坐标：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_28.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_28.jpg)'
- en: '**Normalize view**: The clip coordinates are used to create normalize device
    coordinates that shrink the clipped view to a unity range by dividing it by **W**,
    where W is the constant used to create homogenous coordinates.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化视图**：裁剪坐标用于创建归一化设备坐标，通过除以**W**来缩小裁剪视图到单位范围，其中W是用于创建齐次坐标的常数。'
- en: '**Viewport transformation**: This is the final transformation in which the
    normalize device coordinates are converted into screen coordinates system (that
    is, window coordinates):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**视口变换**：这是最终的变换，其中归一化设备坐标被转换为屏幕坐标系（即窗口坐标）：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_29.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_29.jpg)'
- en: The preceding figure shows how the vertex processing takes place in 3D graphics
    that is transformed from object-coordinate system to appear onto the physical
    screen in the window-coordinate system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了3D图形中的顶点处理过程，它从对象坐标系变换到窗口坐标系中物理屏幕上的显示。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The model-view-projection is purely a mathematical transformation concept. This
    is not a part of OpenGL ES 3.0; it's entirely up to an end user to implement these
    transformations in its own way. This book uses transformations through an open
    source `maths` library called `glm` and uses the 0.9.4 version of this library.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-投影纯粹是一个数学变换概念。这不是OpenGL ES 3.0的一部分；完全由最终用户根据自己的方式实现这些变换。本书通过一个名为`glm`的开源`maths`库来实现变换，并使用该库的0.9.4版本。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**OpenGL Mathematics** (**GLM**) is a header only C++ mathematics library for
    graphics software based on the **OpenGL Shading Language** (**GLSL**) specification.
    You can download this library at [http://glm.g-truc.net](http://glm.g-truc.net).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The transformation-based function of the GLM library is wrapped under a higher-level
    class called `Transform` in the GLPI framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of transformation**:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation is a process by which one coordinate space is converted to another
    coordinate space, for example, translation, rotation, and scaling. There are two
    types of transformations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Geometric transformation**: This specifies when an object undergoes the transformation
    relative to the coordinate system.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate transformation**: This specifies when the coordinate system undergoes
    the transformation and the object remains still.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the computer, these transformations are stored in the form of 4 x 4 transformation
    matrices. The transformation matrix used for 3D systems contain 16 elements in
    a continuous memory location. There are two ways in which multidimensional arrays
    can be represented in the memory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Row Major**: The element in the memory location is stored row-wise'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column Major**: The element in the memory location is stored column-wise![Getting
    ready](img/5527OT_02_37.jpg)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical representation of matrix in **Row Major** (**RM**) and **Column Major**
    (**CM**):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '| Offset | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| RM | e1 | e5 | e9 | e13 | e2 | e6 | e10 | e14 | e3 | e7 | e11 | e15 | e4
    | e8 | e12 | e16 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| CM | e1 | e2 | e3 | e4 | e5 | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 |
    e14 | e15 | e16 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: In order to fix the pipeline OpenGL ES, the convention used for matrices is
    column major. Programmers have to abide by this convention. However, there is
    no restriction in the programmable pipeline to use either the row major or column
    major convention because all matrixes are managed by programmers themselves. It's
    advisable to stick to the column matrix representation as a convention to avoid
    any confusion.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex representation in the matrix form**: A vertex in 3D space is represented
    by three coordinates (x, y, and z). However, in reality, it''s represented by
    four tuples(x, y, z, and w) instead of three. The forth tuple is called as homogeneous
    coordinate. In OpenGL ES, all three-dimensional coordinates and vectors use homogenous
    coordinates.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Homogenous coordinates**: In homogenous coordinates, one set of coordinates
    can be represented by different types of coordinates. For example, for 1, 2, and
    3, the various homogenous representations can be 5, 10, 15, and 5 or 4, 8, 12,
    and 4 because they can be simplified in a general form:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Therefore, the preceding two coordinates can be deduced as 5/5, 10/5, 15/5,
    and 5/5 or 4/4, 8/4, 12/4, and 4/4\. This is logically equal to 1, 2, 3, and 1.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The perspective division stage in the fixed/programmable pipeline uses the `w`
    component of clip coordinates to normalize them. For translation purposes, always
    use the `w` component as 1\. Therefore, any 3D vertex (x, y, and z) is represented
    as (x, y, z, and 1).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following procedure to implement the model-view-projection paradigm
    with the help of various mathematical transformation operations:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the internals of the 3D transformation, you can refer
    to the *There's more…* section in this recipe. This section covers transformation
    operations, such as translation, scaling, and rotation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: When a scene is rendered to the model-view-project information stored in the
    model, view, and projection matrices. In order to use any of these matrices, use
    the `TransformSetMatrixMode` function from the `Transform` class. This class allows
    you to set the relevant matrix as per the requirement of the application. This
    API accepts one parameter called mode, which tells the GLPI framework what kind
    of operation it is presently in; the accepted values of this parameter will be
    `MODEL_MATRIX` (modeling), `VIEW_MATRIX` (viewing), or `PROJECTION_MATRIX` (projection).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manipulate these matrices in any arbitrary order before executing the
    drawing command. This book follows the convention of first processing the projection
    matrix, which is followed by view and model matrix operations.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The projection information is computed in the `Renderer::setupProjection` function.
    For this, the projection matrix needs to be activated first. For more information
    on projection systems and the working logic under this function, refer to the
    *Understanding the projection system in GLPI* recipe. This function is responsible
    for defining the clipping planes for projection frustum; any object that stays
    in this frustum box will be visible:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as an
    identity matrix. This can be done using the `TransformLoadIdentity()` function
    from the `Transform` class.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activate the view matrix in the `Renderer::setupView` function. This function
    is responsible for viewing information. For example, in this recipe, the viewer
    is `-2` and `-15` units away from the origin (`0.0f`, `0.0f`, and `0.0f`):'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we are good to go; the rendering where the modeling transformation is
    preserved. The model matrix is activated in the `Renderer::setupModel`. From now
    on, any modeling transformation is always applied to the model matrix because
    it''s the most recent activated matrix:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Render the drawing objects; the transformation applied to these objects will
    affect the model matrix.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create eight simple 3D cubes, such as C1, C2, C3, C4, C5, C6, C7, and C8 each
    with a dimension of 2 x 2 x 2 logical units (length x breadth x height). Note
    that units in OpenGL ES are logical.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the C1 at origin. Displace C2 by 2 units, C3 by 4 units, and C4 by 6 units
    along positive *y* axis.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Displace C5 by 6 units in the positive *y* axis and 2 units in the negative
    *x* axis. Displace C6 by 6 units in the positive *y* axis and 2 units in the positive
    *x* axis.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Displace C7 by 6 units in the positive *y* axis and 6 units in the negative
    *x* axis.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Displace C8 by 6 units in the positive *y* axis and 6 units in the positive
    *x* axis:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it...](img/5527OT_02_30.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A scene is a composition of model, view, and projection. Each of these has a
    specific responsibility. Model stores the modeling transformation that is applied
    to the rendering items, such as rotation or translation. The model matrix (`MODEL_MATRIX`)
    is activated in the `setupModel` function. From here on, any kind of model rendering
    transformation is applied to the model matrix. For example, in the present recipe,
    various transformations (such as rotation and translation) are applied to a simple
    3D cube to render it to different spatial positions. When object coordinates of
    the cube geometry are applied to model transformations, it yields world coordinates.
    The selection of the required matrix (model, view, and projection) can be done
    using `TransformSetMatrixMode`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The viewing transformation is the middle stage in the scene construction, which
    is responsible for setting up the view or camera in the 3D space. In other words,
    it tells you how a scene will be viewed in a 3D space. In the present recipe,
    the scene is viewed from a position 15 units away from the origin on the *z* axis
    and `-2` units away from the *y* axis. The view transformation is carried out
    in the `setupView` function and it affects the view matrix (`VIEW_MATRIX`). The
    view matrix is applied to world coordinates in order to produce eye coordinates.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: The projection system defines a view volume and keeps track of all objects that
    falls in it. Only these objects will be rendered. The viewing volume or the frustum
    consists of six clipping planes. These are constructed in the `setupProject` function.
    Here, the transformation is carried out on the projection matrix (`PROJECTION_MATRIX`).
    This projection matrix uses eye coordinates and converts them to clipping coordinates.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the complete process of the vertex life cycle for
    transformation purposes:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_31.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Transformation operation**: There are mainly three types of transformations
    that are majorly used. Each of these transformations is stored in the mathematical
    column major matrix form under the OpenGL ES convention. These transformations
    are represented by a 4 x 4 matrix.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation**: This translation operation occupies the 13th, 14th, and the
    15th position in the 4 x 4 transformation matrix or in the row-column format,
    that is, [0, 3], [1, 3], and [2, 3]. The P vertex (Vx, Vy, and Vz) with T translation
    (Tx, Ty, and Tz) can be represented in a general form: *P'' = T.P*.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformTranslate` API for the translation
    operation.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| Variables | Description |'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Tx | This specifies the translation distance in a logical unit along the
    *x* axis |'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Ty | This specifies the translation distance in a logical unit along the
    *y* axis |'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Tz | This specifies the translation distance in a logical unit along the
    *z* axis |'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Scale**: Scale components along *x*, *y*, and *z* components in matrices
    are represented using diagonal elements. The P vertex (Vx, Vy, and Vz) scaled
    by the S factor (Sx, Sy, and Sz) can be generalized, as shown in the following
    figure:![There''s more...](img/5527OT_02_38.jpg)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformScale` API for the scale operation.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| **Sx** | **This denotes scaling along the x axis** |'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| **Sy** | **This denotes scaling along the y axis** |'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| **Sz** | **This denotes scaling along the z axis** |'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Rotation**: This transformation along the *x*, *y*, and *z* axis through
    zero degree can be represented in the matrix form, as given in the following diagram:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume, cos (θ) = C and sin (θ) = S.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_02_39.jpg)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformRotate` API for the rotation operation.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| Variable | Description |'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `angle` | This indicates the degree of rotation |'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Rx` | This indicates the degree of rotation along the *x* axis |'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Ry` | This indicates the degree of rotation along the *y* axis |'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Rz` | This indicates the degree of rotation along the *z* axis |'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: See also
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the projection system in GLPI* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the projection system in GLPI
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will understand two types of projection systems that are
    very commonly used in 3D graphics: perspective projection system and orthographic
    projection system:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**Perspective projection system**: This type of projection system creates a
    view that is similar to how our eyes view the objects. This means that the objects
    that are near to us will appear bigger when compared to the far off objects. This
    type of projection system uses a frustum-clipping region, as shown on the left-hand
    side of the next figure.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the GLPI framework, the `Transform::TransformSetPerspective()` function can
    be used to create a perspective view.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| Variable | Description |'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `fov` | This defines the field of view |'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `aspect_ratio` | This is the rendering aspect ratio (width/height) |'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `screen_orientation` | These are the vertical or horizontal orientation for
    scene rendering |'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Orthographic projection system**: This type of projection system is specially
    used in engineering applications where near and far objects always appear with
    the same dimensions. Therefore, the orthographic projection system retains the
    geometric dimensions. This projection system uses a clipping region in the cuboidal
    shape, as shown in the next figure.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GLPI framework provides orthographic projection with the `TransformOrtho()`
    function. Any model rendered within this clipping plane range will be displayed
    on the screen, and the rest will be clipped out.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Variable | Description |'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `left` and `right` | These are the left and right range of the clipping planes
    |'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `bottom` and `top` | These are the bottom and top range of clipping planes
    |'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The following figure shows that the cubes nearer to the camera are appearing
    bigger compared to others placed at far distance. On the right-hand side, the
    projection generated by this is displayed. This projection clearly shows that
    irrespective of the distance of the cube from the camera, they all appear with
    same dimensions:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the projection system in GLPI](img/5527OT_02_32.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement the perspective and orthographic projection
    systems:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: In order to apply a specific projection onto the scene, we will use the setup
    `Projection()` function in the `Renderer` class. This will be the first function
    that gets called before rendering each frame. It is very important to set the
    current matrix as the projection matrix using the `TransformSetMatrixMode` (`PROJECTION_MATRIX`)
    function. This will ensure that the projection matrix will be in current use.
    Now, the orthographic or perspective projection systems can be applied using the
    `TransformOrtho()` or `TransformSetPerspective()` function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting the projection system, it is important to set the current matrix
    as `VIEW_MATRIX` in order to set the camera position in the 3D space. Finally,
    before rendering the object's models, set the current matrix as `MODEL_MATRIX`,
    using `TransformSetMatrixMode`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as identity
    matrix. This can be done using the `TransformLoadIdentity()` function.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe renders a few cubes arranged in a linear manner in the perspective
    and orthographic projection systems. The projection systems can be switched on
    by a single tap on the screen.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: This recipe first defines a 3D space volume (frustum or cuboid) using the projection
    system with the projection matrix. This 3D space volume consists of six planes
    that are responsible for displaying the object contents that are falling under
    this volume. The objects outside of this 3D volume will be clipped off. The view
    matrix is responsible for setting the eye or camera in the 3D space. In our recipe,
    the camera is 10 units away from the origin. Finally, set the model matrix to
    render the objects in the 3D space.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Culling in OpenGL ES 3.0
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Culling is an important technique in 3D graphics. It is used to discard the
    faces that are not visible to the user. In an enclosed geometry, the faces pointing
    towards the camera hide the faces behind it, either partially or completely. These
    faces can be easily avoided during rendering by the culling technique. This is
    an easier way to speed up the performance in OpenGL ES graphics. There are two
    types of faces:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '**Front face**: The face in an enclosed 3D object that points outward are considered
    to be the front face'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back face**: The face in an enclosed 3D object that points inside of these
    faces are considered as to be the back face'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Culling can be enabled in OpenGL ES 3.0 using the `glenable` API with `GL_CULL_FACE`
    as state flag. By default, OpenGL ES 3.0 culls the back face. This can be changed
    using the `glCullFace` API. Tap on the screen to switch between the front and
    back culling modes. This recipe will display the outside faces of the cube when
    back face culling is set; otherwise, it displays the inside faces when front face
    culling is enabled:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '| Variable | Description |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This is the mode argument parameter accepts symbolic constant `GL_FRONT`
    (front faces are discarded), `GL_BACK` (back faces are discarded), and `GL_FRONT_AND_BACK`
    (no facets are drawn) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: 'Depending on the application requirement, culling can be applied during initialization
    of the graphics engine or before rendering the primitives:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following figure shows the back-face culling and front-face culling:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_02_33.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike human eyes, the computer recognizes the front face and back face of
    an object from the order of the vertices winding. There are two ways in which
    these vertices can be arranged: clockwise and anticlockwise. In the following
    figure, the rectangle is comprised of two triangles whose vertices are specified
    in a counterclockwise direction:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_34.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: When culling is enabled using the `glEnable` API, then the order of arrangement
    of vertices in the array data defines the orientation of vertices in a face. This
    orientation plays an important role in defining the front and back faces. Using
    `glCullFaces` APIs, the OpenGL ES knows which all faces can be discarded. All
    the faces that satisfy culling rules are discarded. By convention, the default
    way of orientation is counterclockwise. We can change this using the `glFrontFace`
    API by specifying the argument as `GL_CCW` (counter clockwise) or `GL_CW` (clockwise).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Depth testing in OpenGL ES 3.0
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depth testing allows us to render the object in the order of distance from the
    viewer. Without depth testing the rendering of the objects is similar to the painter's
    algorithm on the device screen. It will render the object on first-come-first-draw
    basis. For example, if there are three different colored triangles rendered in
    the order of, say, red, green, and blue, then as per painter's algorithm, it draws
    red first, green second, and blue at last. The result will appear on the screen
    in an opposite order, with blue on the top, green in the middle, and red at the
    bottom. This type of rendering does not take the distance of the triangle objects
    from the camera into consideration. In real life, the object closer to the camera
    hides the objects behind them. In order to deal with such real-time scenarios,
    depth testing is used. It renders the objects based on the depth of the distance
    from the camera, instead of using the drawing order (painter's algorithm).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: In depth testing, each fragment's depth is stored in a special buffer called
    depth buffer. Unlike the color buffer that stores the color information, the depth
    buffer stores depth information of the primitive's corresponding fragment from
    the camera view. The depth buffer's dimension is usually the same as the color
    buffer. The depth buffer stores the depth information as 16-, 24-, or 32-bit float
    values.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Apart from rendering the objects in the correct depth order, there are many
    other applications in which the depth buffer is used. One of the most common use
    of depth buffer is to produce real-time shadows with the shadow-mapping technique.
    For more information, refer to the *Creating shadows with shadow mapping* recipe
    in [Chapter 11](ch11.html "Chapter 11. Anti-aliasing Techniques"), *Anti-aliasing
    Techniques*.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth testing in OpenGL ES 3.0](img/5527OT_02_35.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will render three objects and apply depth testing in the
    toggle fashion (enable/disable) to see the effect of depth test in rendering the
    scene. In order to toggle the behavior, single tap on the screen.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the triangle object is in the center, and two cubes are revolving
    around the triangle object. The depth testing is disabled by default in OpenGL
    ES 3.0\. It needs to be enabled by using the `glEnable` API with the `GL_DEPTH_TEST`
    as symbolic constant. Once depth testing is enabled, then behind the curtains,
    OpenGL ES creates a depth buffer. This depth buffer is used during the rendering
    of scenes to predict the correct order of the appearance of model objects. Make
    sure that you clear the depth buffer before rendering each frame with `glClear(GL_DEPTH_BUFFER_BIT)`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The depth buffer is a kind of buffer that contains the depth information of
    all the fragments on the window screen. The depth buffer contains `z` (depth)
    values that range between 0.0 and 1.0\. The depth buffer compares its content
    with `z` value of all the objects in the scene, as seen from the camera view.
    When the `glClear(GL_DEPTH_BUFFER_BIT)` function is called, it sets the `z` values
    of all fragments with the depth value as 1.0\. Depth buffer with pixel value 0.0
    is considered to be the closest to the camera position (at near plane), whereas
    a fragment value of 1.0 is considered to be the farthest (at far plane). When
    an object is rendered, the associated fragment depth is compared to the corresponding
    value already present in the depth buffer. This comparison is based on the `glDepthFunction`
    depth API.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The depth test always passes if the depth test is disabled or no depth buffer
    exists.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The depth value can be controlled by the `glDepthFunction` API. This API specifies
    how the incoming depth values will be compared with the values already present
    in the depth buffer.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| Variable | Description |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| `func` | This indicates the condition under which the pixel will be drawn
    |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: 'The following table specifies the conditional checks that can be used to pass
    or fail the depth test. Here are the defined meanings of the symbolic constants:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbolic constant | Meaning |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| `GL_NEVER` | Never passes |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| `GL_LESS` | Passes if the incoming depth value is less than the stored value
    |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| `GL_EQUAL` | Passes if the incoming depth value is equal to the stored value
    |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| `GL_LEQUAL` | Passes if the incoming depth value is less than or equal to
    the stored value |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| `GL_GREATER` | Passes if the incoming depth value is greater than the stored
    value |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| `GL_NOTEQUAL` | Passes if the incoming depth value is not equal to the stored
    value |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| `GL_GEQUAL` | Passes if the incoming depth value is greater than or equal
    to the stored value |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| `GL_ALWAYS` | Always passes |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: There's more...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `z` value of an object in the view space could be any value in between frustum's
    near and far planes. Therefore, we need some conversion formulas to produce `z`
    values in the range 0.0 and 1.0\. The following image shows the mathematical formula
    to calculate the depth of an object inside the frustum using a linear transformation.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, the linear transformation to calculate the `z` value is hardly
    used because it gives constant precision at all depths. However, we need more
    precision for items that are closer to the viewer''s eyes and less precision that
    are farther. For this purpose, a nonlinear function is used that is proportional
    to `1/z` to calculate the depth. Clearly in the second image, the nonlinear function
    produces an enormous precision at the near plane for the objects falling in the
    range `[1, 20]`. In contrast, the farther object has less precision that is fulfilling
    the ideal requirements:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，用于计算`z`值的线性变换几乎不被使用，因为它在所有深度上提供的是恒定的精度。然而，对于靠近观察者眼睛的物品，我们需要更高的精度，而对于远离观察者的物品，则需要较低的精度。为此，使用了一个与`1/z`成比例的非线性函数来计算深度。显然，在第二幅图像中，非线性函数在范围
    `[1, 20]` 内的对象在近平面产生了巨大的精度。相比之下，远处的物体精度较低，这满足了理想的要求：
- en: '![There''s more...](img/5527OT_02_36.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_02_36.jpg)'
