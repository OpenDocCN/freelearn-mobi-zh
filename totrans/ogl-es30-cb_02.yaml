- en: Chapter 2. OpenGL ES 3.0 Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building prototypes using the GLPI framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering primitives with vertex arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing APIs in OpenGL ES 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient rendering with Vertex Buffer Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformations with the model, view, and projection analogies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the projection system in GLPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Culling in OpenGL ES 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth testing in OpenGL ES 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide a detailed description of the basic concepts that
    are required to understand 3D graphics and implement them using OpenGL ES 3.0\.
    In the beginning of this chapter, we will build a mini portable 3D engine that
    will be helpful in creating small prototype-based projects quickly. It manages
    the code effortlessly in the OpenGL ES 3.0 programmable pipeline. You will learn
    event handling to manage gestures on the screen surface under Android and iOS
    platforms. These will be helpful in implementing gesture-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we move on, we will discuss the fundamental transformation in the 3D graphics
    with the help of the model, view, and projection analogy. At the core side, we
    will look at the different types of available primitives to render a given geometry
    in OpenGL ES 3.0 and discuss optimization techniques that could increase rendering
    performance using **Vertex Buffer Object** (**VBO**). As we approach the end,
    we will understand geometry culling. It controls the rendering of front or back
    faces of an object. The last recipe of the chapter will implement depth testing,
    which is a very important aspect of computational graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Building prototypes using the GLPI framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GLPI is an OpenGL ES platform-independent framework. It is a mini 3D engine
    that is highly useful for developing prototype applications rapidly. It provides
    higher-level utility classes to render engines, shader compilations, 3D transformations,
    mesh management, buffer management, textures, and many more. The framework primarily
    supports Android and iOS platforms and is designed to be easily portable to other
    platforms such as WinCE, Blackberry, Bada, and so on. We will go through each
    module of this framework in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This framework provides dedicated modules for rapid development of the OpenGL
    ES 3.0 prototype applications. It comprises of three main modules, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building prototypes using the GLPI framework](img/5527OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at each of them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLPI module**: This module is the backbone of the GLPI framework. It contains
    the following classes inside it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Class | Function |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Program Manager` | This class is responsible for creating the shader program
    from program objects. It maintains all the program objects in a single manageable
    piece that other modules can use as and when required. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Shader Manager` | This class is responsible for generating the shader''s
    object. It automates the processes of loading, compiling, and generating the shader
    object for the program manager. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Transform` | This class provides high-level APIs for 3D transformation operations.
    It also provides wrapper functions to mimic fixed function pipeline APIs, such
    as transformation, model-view-projection matrices, push and pop matrix operation,
    and so on. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GLUtils` | This class provides helper functions for the GLPI module. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**Model module**: This module will help us create custom models for our application.
    A `Model` class essentially represents any type of geometric object that we are
    interested in rendering on the device screen. This class provides the model''s
    initialization, state management, processing, and rendering routines. It also
    provides touch events handling within the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Model` class of the renderer module represents any kind of 3D rendering
    object that we are interested to render on the screen. For example, if we are
    willing to render a triangle, then we should be creating a `Triangle` class that
    must be derived from the `Model` class and should be added to the `Renderer` class
    as a child member.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Renderer module**: This is the rendering engine''s manager that acts as an
    interface between the underlying platform (such as Android or iOS) and our platform-independent
    graphics framework. It manages the entire graphics system rendering life cycle.
    In addition to this, the custom models created by us will also be managed by it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the Hello World Triangle recipe for
    Android and iOS platforms. Now, you will learn to use the GLPI framework by reimplementing
    the same recipe in GLPI. You can refer to the source code of this recipe by locating
    `GLPIFrameworkIntro` in the sample code of this chapter. In the following steps,
    we will set up the GLPI framework for Android/iOS platforms and learn to use it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Follow these instructions to set up GLPI for the Android platform**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Android.mk` makefile as. The makefile includes the path of the
    `zlib` makefile for compilation purpose. It is used to read/write compressed files.
    The `zlib` file is compiled as a shared library and included in the project. The
    additional libraries include `-lEGL -lGLESv3`, which provides support for EGL,
    and OpenGL ES 3.0 and `-llog`, which allow log information that would be helpful
    in debugging the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new make-file `Application.mk` in the same directory and add STL,
    RTTI, and exception support to your project as shown in the following lines of
    code. For OpenGL ES 3.0, the Android platform API level must be 18 or greater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The chapters from now onwards contain two separate sections for Android and
    iOS development. These sections will be identified by folder names called Android
    and iOS. `NativeTemplate.h` and `NativeTemplate.cpp` (as described in the first
    chapter) are placed next to these folders. If we look at these files now, we will
    realize that they are much cleaner and contain lesser code than earlier. We have
    moved the code from these files to other files in the `Scene` folder:![How to
    do it...](img/5527OT_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Scene` folder contains the `Model` and `Renderer` classes that take care
    of generating models and rendering them. Another class that is present in this
    folder is the `Triangle` class. It contains the code to render the blue triangle.
    Make sure that all classes are included in `Android.mk`:![How to do it...](img/5527OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder called `Shader` under the `assets` folder and create the
    shader files (`BlueTriangleVertex.glsl` and `BlueTriangleFragment.glsl`) inside
    this folder. Move the shader programs that were earlier present in `NativeTemplate.cpp`
    (in the form of a string) into the newly created `Shader` folder. From now on,
    we will manage our shader programs in this folder.![How to do it...](img/5527OT_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**For iOS, the steps to set up the framework are relatively easy and are listed
    here**:'
  prefs: []
  type: TYPE_NORMAL
- en: Import (**Xcode** | **File** | **Add Files to <Project>**) all the GLPI framework
    contents into your project, except the `zlib` library. This library is only used
    for Android for file management. It is not required by iOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the imported contents, go to the `glm` library and remove the `core` folder
    (this folder contains some sample programs that may cause errors in the existing
    project because of the presence of multiple `main()` entries).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the shader files by going to `Android` | `Asset` | `Shader` folder (`BlueTriangleVertex.glsl`
    and `BlueTriangleFragment.glsl` ) into the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `"FILESYSTEM"` environment variable in `main.m`. This will provide
    the current path of the application in the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/5527OT_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The use of the GLPI framework is very simple. We must follow this set of rules
    in order to render our 3D geometric models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new custom model class that is derived from the `Model` class. For
    example, we have created the `Triangle` class that was derived from the `Model`
    class in `Triangle.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `constant.h` and edit enum `ModelType`. Add the enumeration of your choice
    to recognize the model type. For example, there are two enums added for `Triangle`
    and `Cube`. This enumeration will be helpful for the renderer to manage model
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor of `Triangle`, define `ModelType`. Each model contains the
    renderer object as its parent. It also contains reference to `ProgramManager`
    and `Transform`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `VERTEX_SHADER_PRG` and `FRAGMENT_SHADER_PRG` macros in `Triangle.cpp`
    to define the relative path of the shader files in the iOS and Android platforms.
    These macros provides a platform-independent way to access the shader source code
    files from the project solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `InitModel()` function. Here, we need to compile our shader and
    register it with `ProgramManager` for the future use. `ProgramManager` stores
    the compiled shaders in an optimal way to provide quick access to the queried
    attributes. Always provide a name to the shader (in our case, `Triangle`). `ProgramManager`
    uses it as a handle, which will be helpful to retrieve the shader from any type
    of model class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Render()` function. It is responsible for rendering the colored
    triangle on the screen surface. In this function, first, the shader program is
    used to query the respective attributes. These attributes are used to send the
    data to the shader. Each frame of the triangle is rotated by 1 degree and updated
    in the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Destroy the shaders when they are not required. For this recipe, we will use
    the destructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The shader created in our class is publicly accessible to other models in our
    rendering engine. Therefore, it is completely up to us whether to destroy it or
    to keep it in the rendering engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `Renderer.cpp`, add the `Triangle` model in `Renderer::createModels()`
    after the `clearModels()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `clearModels()` ensures that there is no conflict in the rendering engine
    for the `Model` object and shaders. Therefore, it provides a clean approach to
    avoid any redundancy in OpenGL ES shaders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Override the `Render()` function. This function is responsible for making the
    rendering model to appear on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Renderer` class is the manager of the rendering system. Each custom model
    defined in the GLPI framework acts as a registered member of `Renderer` and is
    recognized by its unique model type. `Renderer` provides services to the registered
    components through utility and helper classes such as `Transform` and `ProgramManager`
    interfaces. The rendering engine iterates through the entire registered models
    to define their life cycles. It ensures that the initialization, rendering, and
    destruction of the models takes place at the right time and in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgramManager` is responsible for compiling the shader and caches it for
    later use. Transform plays a vital role in the geometric transformation operations.
    For example, it helps in placing models in the 3D space using rotation, translation,
    and scaling operations.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the internals of the 3D transformation, you can refer
    to *Understanding transformation in 3D graphics* in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0*.
    This topic covers types of transformation, transformation matrix conventions,
    homogenous coordinates, and transformation operations such as translation, scaling,
    and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside the `Renderer` class, the scene's projection can be adjusted using the
    `setUpProjection()` function. This function is responsible for setting the view
    clipping planes. The clipping plane can be defined in the form of frustum (perspective)
    or cuboid (orthographic) shape. We will discuss more about projections later in
    this chapter in the *Understanding the projection system in GLPI* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Developing an Android OpenGL ES 3.0 application* and *Developing
    an iOS OpenGL ES 3.0 application* recipes in [Chapter 1](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's smartphones are capable of interacting with applications through gestures.
    These gestures are made on the surface of the touch-sensitive device screen. When
    the device senses these gesture inputs, it reports the touch events to the corresponding
    application handler. The application handler receives these events and filters
    them out, according to the application's requirement. In this recipe, we will
    implement the touch events using OpenGL ES 3.0 on iOS and Android platforms. You
    will learn to receive the events and handle them in a platform-independent way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GLSurfaceView` class in Android and `GLKViewController` in iOS provide
    the necessary APIs to implement touch events. These APIs report the nature of
    detected touch events, such as if the user has tapped or moved their figure on
    the device screen. These APIs are exposed to the GLPI framework through common
    touch event interfaces. These interfaces are responsible for reporting and propagating
    the touch events to the registered members. The base class of the registered member
    (`Model`) contains all the touch event interfaces that can be handled by the derived
    versions. Since these are the only interfaces, the registered members need to
    override them in order to use them according to their custom needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will provide a detailed description of how to set up and implement
    touch events on the Android and iOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: First, implement the common interfaces in the `NativeTemple` and `Renderer`
    classes that can receive the touch events in a common fashion, irrespective of
    the platform implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare and define the touch event interface in the `Renderer` class. For example,
    the following code shows the tap event implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemple.h`/`.cpp`, call the renderer''s touch events from the globally
    declared and defined wrapper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the Android platform, we need to define new JNI native methods in `NativeTemplate.h`/`.cpp`
    that can communication with the Android framework in order to retrieve the touch
    events. For this, define the following interface for tap events in the `GLESNativeLib`
    Java class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `NativeTemplate`, declare and define the JNI interface for the tap event
    declared earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat steps 1 to 4 to implement the move and release touch events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override `onTouchEvent()` of the `GLSurfaceView` class. This function provides
    various types of touch events. For example, the tap, move, single/multi touch,
    and so on are some of the important events. These events needs to be filtered
    in order that they can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the iOS platform, the GLKit''s `GLKViewController` class provides touch
    functions that need to be overridden in order that they can be used in our application.
    For example, have a look at the following code. It implements the tap, move, and
    release events similar to the Android case. Each of the definitions calls the
    global wrapper functions of `NativeTemplate.h`/`.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an Android or iOS application receives the touch event from the device,
    it is the responsibility of `GLSurfaceView` and `GLKViewController` to convey
    these touch events to the external world. These classes report the touch events
    to the global wrapper function that is defined in the `NativeTemple`. This file
    provides higher level cross-platform functions for touch events such as tap, move,
    and release. These functions are internally interfaced with the corresponding
    touch event interfaces of the `Renderer` class. The `Renderer` class provides
    the interface to handle touch events in an abstracted way in which it works seamlessly
    on either platform. These functions or interfaces are called from the Android
    or iOS platform through `NativeTemplates` global methods and propagated to all
    the registered models. For instance, the following example shows the handling
    of the move event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Depth testing in OpenGL ES 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering primitives with vertex arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In OpenGL ES 3.0, the vertex array is a simplest mean to draw the objects in
    the 3D space. The objects are drawn with the help of vertices, which are arranged
    in a specific order guided by the rendering primitives. The rendering primitives
    represent how an individual or a set of vertices can assemble to draw a geometry.
    For example, four vertices can be represented by a point, line, or triangle, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering primitives with vertex arrays](img/5527OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The vertex array is the way in which the geometric data, such as vertex coordinates,
    normal coordinates, color information, and texture coordinates, are specified
    in the form of arrays. In this recipe, you will learn to program a vertex array
    in the GLPI framework. In addition to this, we will also demonstrate various available
    rendering primitives in OpenGL ES 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new class called `Primitive` derived from the `Model` class and follow
    this step-by-step procedure to implement the rendering primitive with the vertex
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `PrimitiveVertex.glsl` and `PrimitiveFragment.glsl` and use the following
    code for the vertex and fragment shaders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a set of 10 vertices, as shown in the following figure. Then, store the
    information into the vertices array and assign colors to each vertex. The color
    information is stored in the form of RGB in the colors array.![How to do it...](img/5527OT_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `initModel` function, compile and link the vertex and fragment shaders.
    On successful creation of the shader program object, query the vertex attributes
    `VertexPosition` and `VertexColor` using a GLPI wrapper function called `ProgramGetVertexAttribLocation`.
    This function internally uses OpenGL ES 3.0 generic vertex attribute query APIs.
    Using the wrapper APIs decreases the chances of errors and increases the performance,
    as these queries are optimized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ProgramGetVertexAttribLocation` returns the generic attribute location ID.
    A negative value of the location ID specifies that no attribute with that name
    exists in the shader.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the attribute in the shader source program |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Within the same `initModel` function, query the uniform using another wrapper
    API from the GLPI framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ProgramManager` in the GLPI framework provides a high-level wrapper function
    `ProgramGetUniformLocation` to query any uniform type variable from the shader
    program.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | This is the name of the uniform object in the shader source program
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'Create a `RenderPrimitive` function and call it inside `Render`. Inside this
    function, send the uniform and per-vertex attribute data to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the vertex and color-generic attributes and draw various primitives
    using switch case statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe has two arrays, vertices, and colors, which contains the vertex
    information and color information. There are 10 vertices, and each vertex stores
    an `X`, `Y` component. The color information also contains 10 different colors
    for each vertex. The color information is specified in the RGB color space in
    the range of 0.0 to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader contains two per-vertex attributes, `VertexPosition` and `VertexColor`.
    These attributes are uniquely recognized in the program via the attribute location.
    This location is queried using the `ProgramGetVertexAttribLocation` function.
    The queried attribute serves the purpose of binding vertex array information to
    the per-vertex attributes. The vertex attribute data is sent using `glVertexAttribPointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the uniform variable is also queried in the same fashion using a
    separate function called `ProgramGetUniformLocation`. The uniform variable is
    a 4 x 4 matrix of `ModelViewProjection`. Therefore, the data is sent to the shader
    using `glUniformMatrix4fv`. The `glLineWidth` function is meant for the `GL_LINE`
    variant primitives to define the width of the line as 10 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the OpenGL ES 3.0 primitives are rendered using `glDrawArrays`. Various
    primitive rendering can be seen in action by a simple tap on the screen. Upon
    tapping, the tap event will invoke the `TouchEventDown` function of the `Primitive`
    class, which is responsible for changing the current primitive type for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In computer 3D graphics, the polygon shapes are rendered using the triangle
    primitives. Using `GL_TRIANGLE_STRIP`, as compared to `GL_TRIANGLES`, is preferred
    because the number of vertices needed to specify the shape of the triangle is
    lesser when compared to `GL_TRIANGLES`. In the latter case, more data has to be
    sent from the CPU to the GPU, as adjacent edges share common vertices. In the
    former case, the vertices are arranged in a special order in which duplicate vertices
    from the shared edges are avoided. Hence, it requires less data. It is true that
    `GL_TRIANGLE_STRIP` may be better in certain cases due to lesser data needed to
    be defined. However, this needs to be considered on a case-by-case basis, depending
    on the 3D model format.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of tools available that can be used to convert the geometry
    information in the triangle-strip form. For example, nVIDIA's `NvTriStrip` library
    generates triangle strips from an arbitrary 3D geometry. For more information,
    visit [http://www.nvidia.com/object/nvtristrip_library.html](http://www.nvidia.com/object/nvtristrip_library.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the drawing APIs, refer to the *Drawing APIs in OpenGL
    ES 3.0* recipe. It demonstrates `glDrawArrays` and `glDrawElements`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will focus on the basic rendering primitives available in OpenGL
    ES 3.0\. Primitives are the simplest shapes that can be used to generate any complex
    shape in 3D graphics. The OpenGL ES 3.0 primitives can be categorized into three
    basic types: point, line and triangle. The rest are variations of these.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes all the variant primitives of point, line, and
    triangle available in OpenGL ES 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Primitive types | Input vertex | Output shape | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_POINTS` | ![There''s more…](img/5527OT_02_09.jpg) | ![There''s more…](img/5527OT_02_10.jpg)
    | A point on the screen that represents each vertex. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINES` | ![There''s more…](img/5527OT_02_11.jpg) | ![There''s more…](img/5527OT_02_12.jpg)
    | Each pair of vertices is used to render a line between them. We can use the
    `glLineWidth()` API to control the width of the line rendering. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINE_LOOP` | ![There''s more…](img/5527OT_02_13.jpg) | ![There''s more…](img/5527OT_02_14.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. The last
    vertex always joins the first vertex to form a closed loop. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LINE_STRIP` | ![There''s more…](img/5527OT_02_15.jpg) | ![There''s more…](img/5527OT_02_16.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLES` | ![There''s more…](img/5527OT_02_17.jpg) | ![There''s more…](img/5527OT_02_18.jpg)
    | A set of three vertices is used to form a filled triangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLE_STRIP` | ![There''s more…](img/5527OT_02_19.jpg) | ![There''s
    more…](img/5527OT_02_20.jpg) | Every vertex makes a triangle with the preceding
    two vertices. |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_TRIANGLE_FAN` | ![There''s more…](img/5527OT_02_21.jpg) | ![There''s
    more…](img/5527OT_02_22.jpg) | Every vertex makes a triangle with the first vertex
    and the vertex preceding it. This generates a fan-like pattern. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using uniform* *variables to send data to a* *shader* and *Using
    per-vertex attribute to send data to a shader* recipes in [Chapter 1](ch01.html
    "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing APIs in OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenGL ES 3.0 provides two types of rendering APIs: `glDrawArrays` and `glDrawElements`.
    These APIs allows us to render the geometric data on the screen in the form of
    primitives. In this recipe, you will learn how these APIs are used in programming
    and understand the difference between them.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will render a cube by using the two different rendering APIs mentioned
    earlier. The datasets used by these APIs are entirely different. Tap on the screen
    to see the difference between the two APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glDrawArray` API reads the vertex information in the form of an array in
    sequential order, starting from the first index to total number of indexes specified
    by the count. The `glDrawArray` API renders primitives specified by the mode argument
    using vertex array data information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This specifies the type of OpenGL ES primitive that needs to be
    rendered |'
  prefs: []
  type: TYPE_TB
- en: '| `first` | This is the start index of the data array |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | This denotes the total number of indices to be rendered |'
  prefs: []
  type: TYPE_TB
- en: 'For example, a square can be rendered as a set of two triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In contrast, the `glDrawElement` API maps each vertex using an index similar
    to the one that accesses elements in an array using C++/Java. This method of rendering
    consumes less memory compared to `glDrawArray`, where each redundant vertex needs
    to be mentioned with its `X`, `Y`, and `Z` components. For example, take a case
    of regular cube geometry and calculate the memory saving offered by `glDrawElement`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This specifies the primitive type as described in the preceding
    table |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | This specifies the number of elements to be rendered |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | This specifies the data type of indices |'
  prefs: []
  type: TYPE_TB
- en: '| `indices` | This specifies the order of indices for vertex arrangement in
    an array form |'
  prefs: []
  type: TYPE_TB
- en: 'For example, the same square can be represented as follows using this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following instructions will provide a step-by-step procedure to demonstrate
    the use of the `glDrawArrays` and `glDrawElements` APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Cube` class derived from `Model`. There is no change required in the
    vertex and fragment shaders. `Shaders` from the previous recipe can be reused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the vertex and color dataset for the `glDrawArray` API:![How to do it...](img/5527OT_02_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, define the dataset for the `glDrawElement` API:![How to do it...](img/5527OT_02_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `InitModel`, compile and link the shaders. On successful compilation, query
    `ModelViewProjectionMatrix`, `VertexPosition`, `VertexColor` and store them into
    `MVP`, `attribVertex`, `attribColor`, respectively. Enable vertex and color-generic
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the render function, implement the following code to demonstrate both
    APIs in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glDrawArray` rendering API uses vertex attributes, such as vertex coordinates,
    color information, and texture coordinate, in the form of a continuous data array
    in which the data reading cannot be skipped or hopped. The information is highly
    redundant, as the same vertices share among the different face are repeatedly
    written. In this recipe, `vertexBuffer` and `colorBufferData` store vertex coordinates
    and color information. This information is sent to the vertex shader using `attribVertex`
    and `attribColor`. Finally, the `glDrawArray` call is made with parameters specifying
    the type of primitive and index of the vertices that need to go for rendering
    (the start and end index).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `glDrawElement` uses `cubeVert` and `cubeColors`, which contain
    the nonredundant vertex and color information. It uses an additional array that
    contains the indices of the vertex information. Using this array, the primitives
    are rendered by hopping around the vertex arrays. Unlike `glDrawArray`, which
    works on the continuous set of vertex data, `glDrawElement` can jump from one
    vertex to another using the index information provided to it in the last parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In OpenGL ES 3.0, the polygons are drawn as a set of triangles. Each of these
    triangles has two faces: a front face and back face. For example, the following
    image represents a square geometry with vertices v0, v1, v2, and v3\. It is made
    up of two triangles. The order of vertex winding (clockwise or anticlockwise)
    is used by OpenGL ES 3.0 to determine whether the triangle is front facing or
    back facing. In this case, the vertices are winded in an anticlockwise direction.
    By default, OpenGL ES 3.0 considers the anticlockwise windings as front facing.
    This convention can be changed by setting `glFrontFace` (counter clockwise) as
    `GL_CW` or `GL_CCW` (counter clockwise).'
  prefs: []
  type: TYPE_NORMAL
- en: The winding order is always specified from the user's visualization point of
    view. The OpenGL ES pipeline takes care of this winding and displays them correctly
    from the camera's point of view. For example, when we specify the vertices of
    a cube geometry, it should be in the counter-clockwise order as per the default
    convention. However, we know very well that the faces that are parallel to each
    other have opposite winding orders when viewed from the camera's point of view,
    as shown in the following figure. OpenGL ES automatically generates the correct
    winding order from the camera's point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The front and back faces are used in geometry culling. For more information
    on geometry culling and front/back face definitions, refer to the *Culling in
    OpenGL ES 3.0* recipe later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Drawing* *APIs in OpenGL ES 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Culling in OpenGL ES 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient rendering with Vertex Buffer Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertex information comprises of geometric coordinates, color information,
    texture coordinates, and normal vectors. This information is stored in the form
    of an array and always resides in the local memory (RAM, which is accessible by
    the CPU) of the device. Each frame when rendering command is executed. This information
    is copied from the local memory and sent to the GPU. This vertex information is
    sent over the data bus, which has a slower speed compared to the GPU's processing
    speed. Additionally, the latency time on the local memory also adds a slight delay.
  prefs: []
  type: TYPE_NORMAL
- en: VBO is a faster way to render 3D objects. The VBO uses the full advantage of
    **Graphics Processor Unit** (**GPU**) and store the geometric data on GPU's memory
    instead of storing it on the local RAM memory. This helps OpenGL ES to avoid continuous
    sending of data from local memory to the GPU each time a draw call is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the VBO can be divided into four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new buffer object using `glGenBuffers()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind this buffer object to pipeline with `glBindBuffer()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate memory to store data using `glBufferData()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store/modify the data into portions of the allocated buffer object with `glBufferSubData()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow this step-by-step procedure to implement the VBO recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a vertex buffer object using the `glGenBuffers` API. This API
    generates n number of vertex buffer objects, where each vertex buffer object is
    recognized by a unique name or handle returned by this API. This handle is an
    unsigned `int` ID that is used to perform various operations on the VBO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `N` | This is a number of buffer object names that need to be generated |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `buffers` | This specifies an array that contains buffer objects on successful
    creation |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Bind the created vertex buffer object IDs to the underlying pipeline with the
    `glBindBuffer` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This specifies the symbolic constant target to which the buffer
    object name needs to be bound. It could accept `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`,
    `GL_UNIFORM_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, and so on. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `buffers` | This is the name of the buffer object that we created using `glGenBuffer`.
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: Allocate and initialize the memory by specifying the size of the geometric arrays,
    such as vertex, color, normal, and so on, with `glBufferData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This parameter is similar to what is defined in `glBindBuffer`,
    as described earlier. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `size` | The size of the buffer needs to be allocated in bytes. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `data` | This is a pointer to the data array that contains geometry information.
    If this is `NULL`, then no data would be copied. The data can be copied later
    using the `glBufferSubData` API. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `usage` | This is the expected type of pattern used for data store. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The `usage` parameter provides hints to the OpenGL ES system about how the
    data is patterned, so that it can be handled intelligently and efficiently when
    it comes to storing or accessing the data. This parameter can accept one of the
    following types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Types | Meaning |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_STREAM_DRAW` | This type of vertex buffer data is rendered for a small
    number of times and then discarded |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_STATIC_DRAW` | This is a type of buffer data that is rendered many times,
    and its contents never changes |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `GL_DYNAMIC_DRAW` | This type of buffer data is rendered many times, and
    its content changes during rendering |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: The `glBufferData` creates the buffer data store for the current bound target
    with the required size. If the data parameter is initialized with `NULL`, then
    the buffer remains uninitialized. This VBO can be initialized later using the
    `glBufferSubData` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `target` | This parameter is similar to what is defined in the `glBindBuffer`
    as described earlier |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `offset` | This is the index on the buffer store, specifying the start location
    from where the data will be written |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `size` | This is the data size in bytes that needs to be filled in the buffer
    store, starting from the offset position |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `data` | This is a pointer to the new data that will be copied into the data
    store |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The following program implements the VBO with all the APIs discussed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the rendering will be performed by binding the VBO and specifying
    the generic attribute data in terms of offset in the buffer object, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `glGenBuffers` API creates a number of vertex buffer objects specified by
    the first parameter `n`. It returns the VBO ID (handle) array if the vertex buffer
    objects are successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: Once the VBO are created, they need to bind to the target with the `glBindBuffer`
    API. Basically, the target tells the VBO what type of vertex data it can store.
    This data can be either a vertex array or an index array data. The vertex array
    data contains vertex information, such as position, color, texture coordinate,
    and so on. However, the index array contains the order vertex index information.
    Therefore, the target could be specified as `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`.
  prefs: []
  type: TYPE_NORMAL
- en: The data size required to fill into the bound vertex buffer object is specified
    using `glBufferData`. We also need to specify the nature of data the VBO is going
    to store. The final `step` is to fill in the buffer object with data. We can use
    `glBufferSubData` to fill the vertex data. The VBO allows us to specify multiple
    arrays in the same buffer object. We can use offset and size one after the other.
    Make sure that you bind the buffer object to the current rendering state before
    rendering with the `glBindBuffer` API. The VBO can be deleted using `glDeleteBuffers`
    as per the program requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an application uses multiple VBO, then it is advisable to bind the VBO to
    `0` after rendering of the model. This way, the original states remain preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations with the model, view, and projection analogies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a rendering scene in computer 3D graphics, model, view, and projection
    is the cleanest approach. It dissects a scene into these three logical concepts
    that helps us visualize the scene clearly before it appears on paper or in the
    form of a program. It will not be wrong to say that it is a modular approach to
    scene visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object**: An object is a defined by a set of vertices in the 3D space. Each
    object has its own origin. For example, a cube contains eight vertices with respect
    to the origin at the center. The vertices used to define the object are called
    object coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Model**: Modeling in 3D graphics is a transformation process where an object
    is displaced to an arbitrary position in the 3D space. This 3D space is called
    world space (also known as model space). For example, we can use several instances
    of our cube object and place them in the 3D space so that they form the English
    alphabet **T**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modeling is achievable by a 4 x 4 matrix called the Model Matrix. Programmatically,
    an identity matrix, which is multiplied by transformation matrices, contains scale,
    translation, and rotation information. The resultant is the Model Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing**: In simpler terms, we can say that the view is a position in the
    3D space from which the model needs to be viewed. For example, in engineering
    drawing, there are three types of views: the top, front, and side views. These
    are produced by moving the camera in the *x*, *y*, and *z* axes and looking towards
    the origin of the viewing object. The viewing is a transformation that applies
    on the world coordinates to produce eye coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Model-view analogy: The model and view concepts we discussed earlier are completely
    interchangeable. This means that we can do all the view transformations with model
    transformation and vice versa. For example, we can make the object scale by viewing
    it closer or placing it near the viewing location. Similarly, translation and
    rotation operations can also be performed on this object. Therefore, many books
    represent it as a model-view approach, so don''t get confused with this term.
    Mathematically, model view is just another 4 x 4 matrix that is achieved by multiplying
    view matrix and the model matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Projection**: Projection transformation is the process where a scene is restricted
    by a clipping region in the form of a frustum or cuboidal. Both forms have six
    clipping planes that are helpful in restricting the objects, by clipping the objects
    present outside these clipping planes. This stage helps the graphics system increase
    the performance by considering only a finite set of objects within the frustum
    box. The following figure shows the role of frustum clipping planes. The result
    of the eye coordinates on projection system is clip coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Normalize view**: The clip coordinates are used to create normalize device
    coordinates that shrink the clipped view to a unity range by dividing it by **W**,
    where W is the constant used to create homogenous coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewport transformation**: This is the final transformation in which the
    normalize device coordinates are converted into screen coordinates system (that
    is, window coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding figure shows how the vertex processing takes place in 3D graphics
    that is transformed from object-coordinate system to appear onto the physical
    screen in the window-coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model-view-projection is purely a mathematical transformation concept. This
    is not a part of OpenGL ES 3.0; it's entirely up to an end user to implement these
    transformations in its own way. This book uses transformations through an open
    source `maths` library called `glm` and uses the 0.9.4 version of this library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**OpenGL Mathematics** (**GLM**) is a header only C++ mathematics library for
    graphics software based on the **OpenGL Shading Language** (**GLSL**) specification.
    You can download this library at [http://glm.g-truc.net](http://glm.g-truc.net).'
  prefs: []
  type: TYPE_NORMAL
- en: The transformation-based function of the GLM library is wrapped under a higher-level
    class called `Transform` in the GLPI framework.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of transformation**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformation is a process by which one coordinate space is converted to another
    coordinate space, for example, translation, rotation, and scaling. There are two
    types of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geometric transformation**: This specifies when an object undergoes the transformation
    relative to the coordinate system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate transformation**: This specifies when the coordinate system undergoes
    the transformation and the object remains still.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the computer, these transformations are stored in the form of 4 x 4 transformation
    matrices. The transformation matrix used for 3D systems contain 16 elements in
    a continuous memory location. There are two ways in which multidimensional arrays
    can be represented in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Row Major**: The element in the memory location is stored row-wise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column Major**: The element in the memory location is stored column-wise![Getting
    ready](img/5527OT_02_37.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical representation of matrix in **Row Major** (**RM**) and **Column Major**
    (**CM**):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Offset | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RM | e1 | e5 | e9 | e13 | e2 | e6 | e10 | e14 | e3 | e7 | e11 | e15 | e4
    | e8 | e12 | e16 |'
  prefs: []
  type: TYPE_TB
- en: '| CM | e1 | e2 | e3 | e4 | e5 | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 |
    e14 | e15 | e16 |'
  prefs: []
  type: TYPE_TB
- en: In order to fix the pipeline OpenGL ES, the convention used for matrices is
    column major. Programmers have to abide by this convention. However, there is
    no restriction in the programmable pipeline to use either the row major or column
    major convention because all matrixes are managed by programmers themselves. It's
    advisable to stick to the column matrix representation as a convention to avoid
    any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex representation in the matrix form**: A vertex in 3D space is represented
    by three coordinates (x, y, and z). However, in reality, it''s represented by
    four tuples(x, y, z, and w) instead of three. The forth tuple is called as homogeneous
    coordinate. In OpenGL ES, all three-dimensional coordinates and vectors use homogenous
    coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Homogenous coordinates**: In homogenous coordinates, one set of coordinates
    can be represented by different types of coordinates. For example, for 1, 2, and
    3, the various homogenous representations can be 5, 10, 15, and 5 or 4, 8, 12,
    and 4 because they can be simplified in a general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the preceding two coordinates can be deduced as 5/5, 10/5, 15/5,
    and 5/5 or 4/4, 8/4, 12/4, and 4/4\. This is logically equal to 1, 2, 3, and 1.
  prefs: []
  type: TYPE_NORMAL
- en: The perspective division stage in the fixed/programmable pipeline uses the `w`
    component of clip coordinates to normalize them. For translation purposes, always
    use the `w` component as 1\. Therefore, any 3D vertex (x, y, and z) is represented
    as (x, y, z, and 1).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following procedure to implement the model-view-projection paradigm
    with the help of various mathematical transformation operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the internals of the 3D transformation, you can refer
    to the *There's more…* section in this recipe. This section covers transformation
    operations, such as translation, scaling, and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: When a scene is rendered to the model-view-project information stored in the
    model, view, and projection matrices. In order to use any of these matrices, use
    the `TransformSetMatrixMode` function from the `Transform` class. This class allows
    you to set the relevant matrix as per the requirement of the application. This
    API accepts one parameter called mode, which tells the GLPI framework what kind
    of operation it is presently in; the accepted values of this parameter will be
    `MODEL_MATRIX` (modeling), `VIEW_MATRIX` (viewing), or `PROJECTION_MATRIX` (projection).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manipulate these matrices in any arbitrary order before executing the
    drawing command. This book follows the convention of first processing the projection
    matrix, which is followed by view and model matrix operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The projection information is computed in the `Renderer::setupProjection` function.
    For this, the projection matrix needs to be activated first. For more information
    on projection systems and the working logic under this function, refer to the
    *Understanding the projection system in GLPI* recipe. This function is responsible
    for defining the clipping planes for projection frustum; any object that stays
    in this frustum box will be visible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as an
    identity matrix. This can be done using the `TransformLoadIdentity()` function
    from the `Transform` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activate the view matrix in the `Renderer::setupView` function. This function
    is responsible for viewing information. For example, in this recipe, the viewer
    is `-2` and `-15` units away from the origin (`0.0f`, `0.0f`, and `0.0f`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are good to go; the rendering where the modeling transformation is
    preserved. The model matrix is activated in the `Renderer::setupModel`. From now
    on, any modeling transformation is always applied to the model matrix because
    it''s the most recent activated matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Render the drawing objects; the transformation applied to these objects will
    affect the model matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create eight simple 3D cubes, such as C1, C2, C3, C4, C5, C6, C7, and C8 each
    with a dimension of 2 x 2 x 2 logical units (length x breadth x height). Note
    that units in OpenGL ES are logical.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the C1 at origin. Displace C2 by 2 units, C3 by 4 units, and C4 by 6 units
    along positive *y* axis.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Displace C5 by 6 units in the positive *y* axis and 2 units in the negative
    *x* axis. Displace C6 by 6 units in the positive *y* axis and 2 units in the positive
    *x* axis.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Displace C7 by 6 units in the positive *y* axis and 6 units in the negative
    *x* axis.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Displace C8 by 6 units in the positive *y* axis and 6 units in the positive
    *x* axis:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/5527OT_02_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A scene is a composition of model, view, and projection. Each of these has a
    specific responsibility. Model stores the modeling transformation that is applied
    to the rendering items, such as rotation or translation. The model matrix (`MODEL_MATRIX`)
    is activated in the `setupModel` function. From here on, any kind of model rendering
    transformation is applied to the model matrix. For example, in the present recipe,
    various transformations (such as rotation and translation) are applied to a simple
    3D cube to render it to different spatial positions. When object coordinates of
    the cube geometry are applied to model transformations, it yields world coordinates.
    The selection of the required matrix (model, view, and projection) can be done
    using `TransformSetMatrixMode`.
  prefs: []
  type: TYPE_NORMAL
- en: The viewing transformation is the middle stage in the scene construction, which
    is responsible for setting up the view or camera in the 3D space. In other words,
    it tells you how a scene will be viewed in a 3D space. In the present recipe,
    the scene is viewed from a position 15 units away from the origin on the *z* axis
    and `-2` units away from the *y* axis. The view transformation is carried out
    in the `setupView` function and it affects the view matrix (`VIEW_MATRIX`). The
    view matrix is applied to world coordinates in order to produce eye coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The projection system defines a view volume and keeps track of all objects that
    falls in it. Only these objects will be rendered. The viewing volume or the frustum
    consists of six clipping planes. These are constructed in the `setupProject` function.
    Here, the transformation is carried out on the projection matrix (`PROJECTION_MATRIX`).
    This projection matrix uses eye coordinates and converts them to clipping coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the complete process of the vertex life cycle for
    transformation purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Transformation operation**: There are mainly three types of transformations
    that are majorly used. Each of these transformations is stored in the mathematical
    column major matrix form under the OpenGL ES convention. These transformations
    are represented by a 4 x 4 matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Translation**: This translation operation occupies the 13th, 14th, and the
    15th position in the 4 x 4 transformation matrix or in the row-column format,
    that is, [0, 3], [1, 3], and [2, 3]. The P vertex (Vx, Vy, and Vz) with T translation
    (Tx, Ty, and Tz) can be represented in a general form: *P'' = T.P*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformTranslate` API for the translation
    operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variables | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Tx | This specifies the translation distance in a logical unit along the
    *x* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Ty | This specifies the translation distance in a logical unit along the
    *y* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Tz | This specifies the translation distance in a logical unit along the
    *z* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Scale**: Scale components along *x*, *y*, and *z* components in matrices
    are represented using diagonal elements. The P vertex (Vx, Vy, and Vz) scaled
    by the S factor (Sx, Sy, and Sz) can be generalized, as shown in the following
    figure:![There''s more...](img/5527OT_02_38.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformScale` API for the scale operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| **Sx** | **This denotes scaling along the x axis** |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| **Sy** | **This denotes scaling along the y axis** |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| **Sz** | **This denotes scaling along the z axis** |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Rotation**: This transformation along the *x*, *y*, and *z* axis through
    zero degree can be represented in the matrix form, as given in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume, cos (θ) = C and sin (θ) = S.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_02_39.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Transform` class provides the `TransformRotate` API for the rotation operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `angle` | This indicates the degree of rotation |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Rx` | This indicates the degree of rotation along the *x* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Ry` | This indicates the degree of rotation along the *y* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `Rz` | This indicates the degree of rotation along the *z* axis |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the projection system in GLPI* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the projection system in GLPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will understand two types of projection systems that are
    very commonly used in 3D graphics: perspective projection system and orthographic
    projection system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perspective projection system**: This type of projection system creates a
    view that is similar to how our eyes view the objects. This means that the objects
    that are near to us will appear bigger when compared to the far off objects. This
    type of projection system uses a frustum-clipping region, as shown on the left-hand
    side of the next figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the GLPI framework, the `Transform::TransformSetPerspective()` function can
    be used to create a perspective view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `fov` | This defines the field of view |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `aspect_ratio` | This is the rendering aspect ratio (width/height) |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `screen_orientation` | These are the vertical or horizontal orientation for
    scene rendering |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '**Orthographic projection system**: This type of projection system is specially
    used in engineering applications where near and far objects always appear with
    the same dimensions. Therefore, the orthographic projection system retains the
    geometric dimensions. This projection system uses a clipping region in the cuboidal
    shape, as shown in the next figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GLPI framework provides orthographic projection with the `TransformOrtho()`
    function. Any model rendered within this clipping plane range will be displayed
    on the screen, and the rest will be clipped out.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `left` and `right` | These are the left and right range of the clipping planes
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `bottom` and `top` | These are the bottom and top range of clipping planes
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The following figure shows that the cubes nearer to the camera are appearing
    bigger compared to others placed at far distance. On the right-hand side, the
    projection generated by this is displayed. This projection clearly shows that
    irrespective of the distance of the cube from the camera, they all appear with
    same dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the projection system in GLPI](img/5527OT_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps to implement the perspective and orthographic projection
    systems:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to apply a specific projection onto the scene, we will use the setup
    `Projection()` function in the `Renderer` class. This will be the first function
    that gets called before rendering each frame. It is very important to set the
    current matrix as the projection matrix using the `TransformSetMatrixMode` (`PROJECTION_MATRIX`)
    function. This will ensure that the projection matrix will be in current use.
    Now, the orthographic or perspective projection systems can be applied using the
    `TransformOrtho()` or `TransformSetPerspective()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting the projection system, it is important to set the current matrix
    as `VIEW_MATRIX` in order to set the camera position in the 3D space. Finally,
    before rendering the object's models, set the current matrix as `MODEL_MATRIX`,
    using `TransformSetMatrixMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as identity
    matrix. This can be done using the `TransformLoadIdentity()` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe renders a few cubes arranged in a linear manner in the perspective
    and orthographic projection systems. The projection systems can be switched on
    by a single tap on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe first defines a 3D space volume (frustum or cuboid) using the projection
    system with the projection matrix. This 3D space volume consists of six planes
    that are responsible for displaying the object contents that are falling under
    this volume. The objects outside of this 3D volume will be clipped off. The view
    matrix is responsible for setting the eye or camera in the 3D space. In our recipe,
    the camera is 10 units away from the origin. Finally, set the model matrix to
    render the objects in the 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: Culling in OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Culling is an important technique in 3D graphics. It is used to discard the
    faces that are not visible to the user. In an enclosed geometry, the faces pointing
    towards the camera hide the faces behind it, either partially or completely. These
    faces can be easily avoided during rendering by the culling technique. This is
    an easier way to speed up the performance in OpenGL ES graphics. There are two
    types of faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front face**: The face in an enclosed 3D object that points outward are considered
    to be the front face'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back face**: The face in an enclosed 3D object that points inside of these
    faces are considered as to be the back face'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Culling can be enabled in OpenGL ES 3.0 using the `glenable` API with `GL_CULL_FACE`
    as state flag. By default, OpenGL ES 3.0 culls the back face. This can be changed
    using the `glCullFace` API. Tap on the screen to switch between the front and
    back culling modes. This recipe will display the outside faces of the cube when
    back face culling is set; otherwise, it displays the inside faces when front face
    culling is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | This is the mode argument parameter accepts symbolic constant `GL_FRONT`
    (front faces are discarded), `GL_BACK` (back faces are discarded), and `GL_FRONT_AND_BACK`
    (no facets are drawn) |'
  prefs: []
  type: TYPE_TB
- en: 'Depending on the application requirement, culling can be applied during initialization
    of the graphics engine or before rendering the primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the back-face culling and front-face culling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike human eyes, the computer recognizes the front face and back face of
    an object from the order of the vertices winding. There are two ways in which
    these vertices can be arranged: clockwise and anticlockwise. In the following
    figure, the rectangle is comprised of two triangles whose vertices are specified
    in a counterclockwise direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When culling is enabled using the `glEnable` API, then the order of arrangement
    of vertices in the array data defines the orientation of vertices in a face. This
    orientation plays an important role in defining the front and back faces. Using
    `glCullFaces` APIs, the OpenGL ES knows which all faces can be discarded. All
    the faces that satisfy culling rules are discarded. By convention, the default
    way of orientation is counterclockwise. We can change this using the `glFrontFace`
    API by specifying the argument as `GL_CCW` (counter clockwise) or `GL_CW` (clockwise).
  prefs: []
  type: TYPE_NORMAL
- en: Depth testing in OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depth testing allows us to render the object in the order of distance from the
    viewer. Without depth testing the rendering of the objects is similar to the painter's
    algorithm on the device screen. It will render the object on first-come-first-draw
    basis. For example, if there are three different colored triangles rendered in
    the order of, say, red, green, and blue, then as per painter's algorithm, it draws
    red first, green second, and blue at last. The result will appear on the screen
    in an opposite order, with blue on the top, green in the middle, and red at the
    bottom. This type of rendering does not take the distance of the triangle objects
    from the camera into consideration. In real life, the object closer to the camera
    hides the objects behind them. In order to deal with such real-time scenarios,
    depth testing is used. It renders the objects based on the depth of the distance
    from the camera, instead of using the drawing order (painter's algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: In depth testing, each fragment's depth is stored in a special buffer called
    depth buffer. Unlike the color buffer that stores the color information, the depth
    buffer stores depth information of the primitive's corresponding fragment from
    the camera view. The depth buffer's dimension is usually the same as the color
    buffer. The depth buffer stores the depth information as 16-, 24-, or 32-bit float
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from rendering the objects in the correct depth order, there are many
    other applications in which the depth buffer is used. One of the most common use
    of depth buffer is to produce real-time shadows with the shadow-mapping technique.
    For more information, refer to the *Creating shadows with shadow mapping* recipe
    in [Chapter 11](ch11.html "Chapter 11. Anti-aliasing Techniques"), *Anti-aliasing
    Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth testing in OpenGL ES 3.0](img/5527OT_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will render three objects and apply depth testing in the
    toggle fashion (enable/disable) to see the effect of depth test in rendering the
    scene. In order to toggle the behavior, single tap on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the triangle object is in the center, and two cubes are revolving
    around the triangle object. The depth testing is disabled by default in OpenGL
    ES 3.0\. It needs to be enabled by using the `glEnable` API with the `GL_DEPTH_TEST`
    as symbolic constant. Once depth testing is enabled, then behind the curtains,
    OpenGL ES creates a depth buffer. This depth buffer is used during the rendering
    of scenes to predict the correct order of the appearance of model objects. Make
    sure that you clear the depth buffer before rendering each frame with `glClear(GL_DEPTH_BUFFER_BIT)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The depth buffer is a kind of buffer that contains the depth information of
    all the fragments on the window screen. The depth buffer contains `z` (depth)
    values that range between 0.0 and 1.0\. The depth buffer compares its content
    with `z` value of all the objects in the scene, as seen from the camera view.
    When the `glClear(GL_DEPTH_BUFFER_BIT)` function is called, it sets the `z` values
    of all fragments with the depth value as 1.0\. Depth buffer with pixel value 0.0
    is considered to be the closest to the camera position (at near plane), whereas
    a fragment value of 1.0 is considered to be the farthest (at far plane). When
    an object is rendered, the associated fragment depth is compared to the corresponding
    value already present in the depth buffer. This comparison is based on the `glDepthFunction`
    depth API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The depth test always passes if the depth test is disabled or no depth buffer
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: The depth value can be controlled by the `glDepthFunction` API. This API specifies
    how the incoming depth values will be compared with the values already present
    in the depth buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `func` | This indicates the condition under which the pixel will be drawn
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following table specifies the conditional checks that can be used to pass
    or fail the depth test. Here are the defined meanings of the symbolic constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbolic constant | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_NEVER` | Never passes |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LESS` | Passes if the incoming depth value is less than the stored value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_EQUAL` | Passes if the incoming depth value is equal to the stored value
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_LEQUAL` | Passes if the incoming depth value is less than or equal to
    the stored value |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_GREATER` | Passes if the incoming depth value is greater than the stored
    value |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_NOTEQUAL` | Passes if the incoming depth value is not equal to the stored
    value |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_GEQUAL` | Passes if the incoming depth value is greater than or equal
    to the stored value |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_ALWAYS` | Always passes |'
  prefs: []
  type: TYPE_TB
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `z` value of an object in the view space could be any value in between frustum's
    near and far planes. Therefore, we need some conversion formulas to produce `z`
    values in the range 0.0 and 1.0\. The following image shows the mathematical formula
    to calculate the depth of an object inside the frustum using a linear transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, the linear transformation to calculate the `z` value is hardly
    used because it gives constant precision at all depths. However, we need more
    precision for items that are closer to the viewer''s eyes and less precision that
    are farther. For this purpose, a nonlinear function is used that is proportional
    to `1/z` to calculate the depth. Clearly in the second image, the nonlinear function
    produces an enormous precision at the near plane for the objects falling in the
    range `[1, 20]`. In contrast, the farther object has less precision that is fulfilling
    the ideal requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
