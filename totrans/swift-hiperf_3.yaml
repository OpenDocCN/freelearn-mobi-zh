- en: Chapter 3. Testing and Identifying Slow Code with the Swift Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of application development can usually be split into three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Trying out new ideas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing code and checking whether it works correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the performance of the result obtained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first phase involves trying out a new idea. Let's say you would like to
    implement a sorting algorithm and you want to quickly prototype a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the second phase, you would actually implement the solution and check whether
    it is working correctly. In this chapter, we will cover how we can test and check
    whether a solution is implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final phase involves measuring the performance of the software
    created. You would do this when you have developed enough code to test, or if
    you see bad performance characteristics while developing.
  prefs: []
  type: TYPE_NORMAL
- en: REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REPL** stands for **read-eval-print-loop**. Swift REPL is an interactive
    Swift code interpreter that executes code immediately. To launch Swift REPL, open
    Terminal. app and execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can start typing Swift code and see the result. A nice thing about
    evaluating code in REPL is that if you make an error that would eventually stop
    the application execution if you compile and run it, you can still continue evaluating
    the code and preserve all of the progress. Let''s play around and try this code
    in Swift REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![REPL](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Writing code in the REPL console is not as convenient as in the modern Xcode
    IDE, but being familiar with it is a useful skill. On top of the Swift REPL, Apple
    has built more powerful tools, such as Playgrounds, which has a nice source code
    editor and flexibility of Swift REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Playgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playgrounds is a powerful tool for trying out code and getting the result. As
    its name suggests, it's a place to play. In a playground, Swift code is evaluated
    immediately, which is the same as in REPL. You can create a new playground by
    going to **File** | **New** | **Playground**. Enter the file name and create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A playground consists of two parts, which are shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Playgrounds](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Almost all the code examples shown in this book were created in playgrounds.
    As an example, let''s create an array and play with it. We can apply filter and
    map functions and print the count of objects in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playgrounds](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see the result of the evaluated code appearing as you type. If you
    move the cursor to the one of the lines in the result section, it will become
    highlighted and two buttons will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick Look**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show / Hide result**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick Look** will display more details about the executed operation. This
    functionality is particularly interesting for functions. As an example, if you
    click on the `filter` function, you can see the result of every iteration; the
    results are `true` or `false` values. If you show the details of a function that
    has a numerical result, a `map` function, for example, it can show a nice graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Show / Hide Result** allows you to add a **Quick Look** result directly to
    the playground editor. It will always be visible and refresh the data unless you
    hide it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Showing the Result View of a function with a numerical return type is very
    useful when you are working with the math functions and you want to see the results
    in a visual representation. As an example, let''s show the result of the `sin`
    and `pow` functions, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playgrounds](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The other useful use case is for displaying the result of an algorithm. We
    will create a selection sort algorithm. It is often very useful to see the result
    of the algorithm at every step. You can easily inspect it in a playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playgrounds](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Interactive documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other use case for playgrounds is in making interactive documentation. You
    can add markup-formatted text to the playgrounds. In this way, you can combine
    interactive code examples that run in the playground with rich-formatted text
    descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The markup syntax is based on the well-known Markdown syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heading**: `# Heading`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong**: `**Bold Text**` or `__Bold Text__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inline code**: `` `Int` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete Markdown documentation can be found at [http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two markup text styles in Playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One line**: One line markup text style is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Multiline**: The multiline markup text style is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now add some markup text to playgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The markup text can be presented in a playground in two modes, raw and rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive documentation](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To switch between raw mode and rendered mode, go to **Editor** | **Show Rendered
    Markup / Show Raw Markup**. You can also switch between these modes by enabling
    the **Render Documentation** checkbox in the **Playground Settings** section in
    the **Utility** panel, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive documentation](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The full documentation of the Playgrounds markup format can be found at [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref).
  prefs: []
  type: TYPE_NORMAL
- en: The folder structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The playground file is actually not a simple file but a package that contains
    multiple files. You can explore its full contents by opening it in **Finder**.
    Right-click on **Show Package Contents**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xcode, you can expand a playground file in **Project Navigator**. It contains
    three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: A folder for additional Swift source files for the Playground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: A folder for additional resources for Playground such as images,
    text files, and other things'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages**: A collection of playground files of a parent playground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By splitting a playground's source code into several Swift source code files,
    you can make the playground cleaner and faster. Every time you make a change in
    the playground, it will rerun the entire code in that playground. The more code
    you put into the playground, the slower it gets. The Swift source files in the
    `source` folder don't rerun every time you make a change in the playground file;
    they rerun only when you make a change to the content of that file. As an example,
    when we were playing with `Person`, it's the perfect use case for adding a `Person`
    type to a separate Swift source file in the `source` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swift files in the source folder are compiled into the framework. In the
    framework, you have to mark your types and functions with a `public` keyword to
    make them visible outside the framework, in our case in the playground.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By including assets in the `Resources` folder, you can reference them in the
    playground. The simplest example would be adding a `circle.png` image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The files in the `Resources` folder are available via `NSBundle.mainBundle`.
    Let''s create the same circle, `UIImage`, but this time with the `NSBundle` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A playground file can contain many sub-playground files, called pages. A page
    is a fully functional playground file with its own sources and resources folders.
    A playground can contain many pages. To add a new page, go to **File** | **New**
    | **Playground Page**, or simply right-click on the playground file and select
    **New Playground Page**.
  prefs: []
  type: TYPE_NORMAL
- en: Playground pages are great for splitting content into separate parts, such as
    a page or section of a book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For easy navigation among the pages in a playground, there is a page navigation
    markup. You can jump to the first, last, next, previous, or any specific page.
    The page navigation markup consists of two parts: `[Visible text]` and `(page-link)`.
    Let''s see some examples of this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Many code examples in this book are created using playground pages.
  prefs: []
  type: TYPE_NORMAL
- en: XCPlayground
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`XCPlayground` is a module specially created for working with playgrounds.
    It''s a very small module, with four main functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XCPCaptureValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XCPShowView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XCPSetExecutionShouldContinueIndefinitely`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XCPSharedDataDirectoryPath`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let take a quick look at these functions. The results of all of these functions
    are shown in the Playground timeline. To see it, go to **View** | **Assistant
    Editor** | **Show Assistant Editor**, and select the timeline for the current
    playground.
  prefs: []
  type: TYPE_NORMAL
- en: '`XCPCaptureValue` allows you to manually capture a value and display it in
    the timeline view. In this way, you can create your own graph results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`XCPShowView` displays a view in the playground timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`XCPSetExecutionShouldContinueIndefinitely` is very useful for asynchronous
    code execution in a playground. It tells playground to keep executing its run
    loop infinitely after the last instruction completes, and in this way, we can
    wait for asynchronous callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '`XCPSharedDataDirectoryPath` returns a path to the directory that is shared
    between all the playgrounds. In this way, you can save and share data between
    playgrounds and between each playground run.'
  prefs: []
  type: TYPE_NORMAL
- en: LLDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLDB is a high-performance command-line debugger. It is available in Xcode.
    The easiest way to start it is to set a breakpoint and run the application. In
    the Xcode debug area view, you will find a console in which you can execute LLDB
    commands. Because we made an iOS app, we will set a breakpoint in the AppDelegate's
    `didFinishLaunchingWithOptions` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the content of a variable, we can use the `p` LLDB command. Just run
    `p` with the variable name, for example, `p name`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LLDB](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: LLDB is a very powerful debugger. You can read more about the LLDB debugger
    at [www.objc.io/issues/19-debugging/lldb-debugging/](http://www.objc.io/issues/19-debugging/lldb-debugging/)
    and [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide).
  prefs: []
  type: TYPE_NORMAL
- en: REPL in Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more interesting functionalities available in the Xcode LLDB console
    is that you can run Swift REPL there. You can enter and execute Swift code when
    you stop the application execution in the debugger. This is very useful for debugging
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: REPL can only access public types, functions, and public global variables. Local
    variables are not visible in REPL. If you need to work with local variables, use
    LLDB commands instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter an REPL console, we first have to stop the program execution and enter
    the LLDB debugger. There are three commands for interacting with REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter REPL**: `repl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exit REPL**: `:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute the LLDB** **command in REPL**: `: command`, for example, `:p name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can execute the same function as before, but now use REPL commands in the
    debug console, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REPL in Xcode](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's look at more interesting use cases of REPL. When you enter REPL, you
    can enter and execute Swift code. You also have access to publicly declared Swift
    code in your application in REPL. To summarize, you can run existing code and
    add new code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great use case here is adding test code directly to REPL while debugging
    the application. As an example, let''s implement a function for skipping negative
    numbers in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `skipNegatives` function's implementation is very simple, and it is easy
    to check whether it works correctly in this example, but your other functions
    could be much bigger and harder to understand. Also, the `numbers` array contains
    only three elements and the result should contain two elements. We can easily
    check this by looking out for it in the debugger view.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if our numbers array contained 1,000 elements? It would be harder
    to go through the array and verify that it doesn''t contain negative elements.
    In this example, we have 505 non-negative elements in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We could write a test function in REPL to check whether all the elements are
    positive. Let''s do that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REPL in Xcode](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, as usual, run the program and stop at a breakpoint. The next step is
    to enter REPL and write an `isAllPositive` function to check whether all the numbers
    are positive. Then, just call `skipNegatives` and `isAllPositive`, and see whether
    the result is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to use a test function more than once in REPL, it is better
    to create a Swift source file for debugging purposes and add it there. Then, you
    can call it from REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Console logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other powerful debugging tool, which you should already be familiar with,
    is the console log. Console logs can be used to log all types of information,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: Operation results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance measurement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To log a statement to the console, you can use one of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debugPrint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these functions accept any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide custom text formatting for print functions, you must conform to
    the `CustomStringConvertible` protocol, and for `debugPrint`, the `CustomDebugStringConvertible`
    protocol. Both of these protocols require the implementation of only one property.
    Let''s create a simple `Person` type and implement custom log formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, when `print` or `debugPrint` is called with an instance of a `Person` type,
    it will show a custom description.
  prefs: []
  type: TYPE_NORMAL
- en: A more interesting use case of console logs is a method's performance logging.
    We would like to know how much time a particular method or piece of code took
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first idea would be to use `NSDate` to measure time. `NSDate` works well,
    but there is a better solution for this in the `QuartzCore` framework—a `CACurrentMediaTime`
    function. It returns the result based on `mach_absolute_time`. The base pseudocode
    for our case would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We would like to use this performance-measuring function very often, and it
    would be very useful to extract this code into a separate reusable function. Because
    Swift supports the functional programming style, we can easily do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a measure function. It will take another function that will
    perform a task for which we need to measure time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we want to find out how much time it takes to create 1,000
    instances of a `Person` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to do is simply wrap this code into a closure and pass it to the
    measure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this measurement in the playground would give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Performance measuring in unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a new project, Xcode creates a unit test target for that project
    with the name `ProjectName` + `Tests`. If you are not familiar with unit testing,
    you can read about testing in Xcode at [https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode will also create a simple unit test file for you. In our project, it''s
    `Swift_ToolkitTests.swift`. The unit test has three main methods, with different
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`teardown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The unit test function must begin with the `test` prefix, like this for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The names of these functions reflect their purposes. The `setup` function performs
    additional setup before the unit test is run, and `teardown` performs a cleanup,
    but the most interesting function for us is `test`, which performs testing.
  prefs: []
  type: TYPE_NORMAL
- en: The `XCTestCase` unit test class has a `measureBlock` function that works in
    a way similar to the `measure` function that we have implemented. Let's implement
    a unit test to measure the performance for creating 1,000 people.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make a `Person` type and other types in our application available
    to the unit test target. To do so, we need to import an app module with the `@testable
    attribute`—`@testable import {ModuleName}`. Now, all the `public` and `internal`
    types and methods in that module become available in the unit test target:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable `@testable`, the **Enable Testability** project build setting must
    be set to **Yes**. Xcode sets it to **Yes** for the **Debug** mode by default.
    You should never enable it for release mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you run the unit tests, by going to **Product** | **Test** or using the
    *CMD* + *U* shortcut, you will see the performance characteristics on the right-hand
    side of the function name. When you click on it, you will see more details and
    a button for setting the baseline performance values, which will be used to compare
    future measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `measureBlock` runs a block of code a few times and shows an average time.
    You can see the performance for 10 different iterations in a detailed popup, as
    shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance measuring in unit tests](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now set a baseline and run the unit test again. The test passes!
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of performance unit tests is to measure performance and make sure
    that it doesn''t decrease dramatically. By default, the allowed standard deviation
    is 10%. This means that if the performance for code decreases by more than 10%,
    the test fails. Let''s try to simulate this and see what happens. To simulate
    the extra work, we will add a delay in the `person` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now let's run the test again. You will see that test fails and shows a red sign
    next to the test function's name.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, unit testing allows you to both measure performance and make sure
    that it doesn't decrease while you are working on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Instruments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last tool that we are going to take a look at in this chapter is instruments.
    Although we are mentioning it towards the end of the chapter, it''s is the most
    powerful tool for measuring all sorts of characteristics of an application: performance,
    memory usage and leaks, networking, monitoring, animation, hard drive, and file
    activity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to launch Instruments for the application is by going to **Product**
    | **Profile** or by using the *CMD* + *I* keyboard shortcut. This will launch
    the instrument for the current target and show you the available instrument measurement
    templates. We will choose a **Time Profiler** template and click on **Record**.
    This will start the application and record the performance for every called function.
    Now we can analyze the functions'' performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Instruments](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Instruments is a very powerful tool, and it would take a separate chapter to
    cover its functionality completely. If you are not familiar with Instruments,
    you should read more about it at [https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide).
  prefs: []
  type: TYPE_NORMAL
- en: A reminder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you are doing any performance measurement, do it in release mode. The
    Swift compiler performs many optimization steps in the release mode and dramatically
    increases performance. To set release mode, go to **Product** | **Scheme** | **Edit
    Scheme** | **Run**, and adjust the **Build Configuration** setting to **Release**.
    Always use release mode for performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many tools that would boost your productivity. REPL
    and Playgrounds are perfect for trying out new code and quick code prototyping.
    Playgrounds can also be used to create interactive documentation and tutorials.
    Then we covered debugging tools (such as LLDB and REPL) in Xcode, which are very
    useful for checking the results of operations performed at runtime. The performance
    of an application can be measured in Instruments or using the console log. To
    make sure that the performance doesn't decrease, you should use unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, in this chapter, you learned many tools for discovering slow and
    problematic code, and in the next chapter, you will learn how to improve and optimize
    it.
  prefs: []
  type: TYPE_NORMAL
