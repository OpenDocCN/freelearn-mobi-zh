<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Swift Playgrounds&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p class="p1">Throughout this book, we have been using Swift Playgrounds to work through code examples as we explore the Swift language. Playgrounds are great for this use case, as they allow you to explore code and framework APIs without needing the infrastructure of an iOS, macOS, or tvOS app to execute the code.</p>&#13;
<p class="p1">Their features go beyond how we have used them so far in this book, and in this chapter, we will explore some of those features, from using additional code and resources to creating fully interactive experiences.</p>&#13;
<p> In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Using Swift Playgrounds for UI</li>&#13;
<li>Importing resources into playgrounds</li>&#13;
<li>Importing code into playgrounds</li>&#13;
<li>Multi-page playgrounds</li>&#13;
<li>Using Swift Playgrounds on iPadOS</li>&#13;
</ul>&#13;
<h1 id="uuid-45e8b544-bff2-4bf9-ad5e-2dc1ab82dca0">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/37t4f0A" target="_blank">https://bit.ly/37t4f0A</a>.</p>&#13;
<h1 id="uuid-c567d04a-a138-4b1d-9182-4401d1b16949" class="p1">Using Swift Playgrounds for UI</h1>&#13;
<p>We can use Playgrounds to experiment with UI and test custom views and interfaces. In this recipe, we will build a bar chart view that we can use to display numerical data in chart form and use a playground to test it.</p>&#13;
<h2 id="uuid-2563d3bd-43a4-4337-8722-44c2dab883ba">Getting ready</h2>&#13;
<p>First, we'll create an iOS-based playground to build our bar chart. In <a href="">Chapter 1</a>, <em>Swift Building Blocks</em>, we went through creating a new playground, so return there if you need a refresher.</p>&#13;
<p>We will create a custom view that will display information in bar chart form, and use that to test some features of playgrounds. You can either enter the following code into a new iOS-based playground or download the playground named <kbd>Simple_iOS.playground</kbd> from this book's GitHub repository:</p>&#13;
<ol>&#13;
<li>Create a <kbd>Color</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import UIKit<br/><br/>struct Color {<br/>    let red: Float<br/>    let green: Float<br/>    let blue: Float<br/>    let alpha: Float = 1.0<br/>    <br/>    var displayColor: UIColor {<br/>        return UIColor(red: CGFloat(red),<br/>                       green: CGFloat(green),<br/>                       blue: CGFloat(blue),<br/>                       alpha: CGFloat(alpha))<br/>    }<br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create a <kbd>Bar</kbd> struct and <kbd>BarView</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">struct Bar {<br/>    var value: Float<br/>    var color: Color<br/>}<br/><br/>class BarView: UIView {<br/>    <br/>    init(frame: CGRect, color: UIColor) {<br/>        super.init(frame: frame)<br/>        backgroundColor = color<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        super.init(coder: coder)<br/>        backgroundColor = .red<br/>    }<br/>}</pre>&#13;
<ol start="3">&#13;
<li>Create the <kbd>BarChart</kbd> view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">class BarChart: UIView {<br/>    <br/>    private var barViews: [BarView] = []<br/>    private var maxValue: Float = 0.0<br/><br/>    var interBarMargin: CGFloat = 5.0<br/><br/>    var bars: [Bar] = [] {<br/>        didSet {<br/>            self.barViews.forEach { $0.removeFromSuperview() }<br/>            <br/>            var barViews = [BarView]()<br/>            <br/>            let barCount = CGFloat(bars.count)<br/>            <br/>            // Calculate the max value before calculating size<br/>            for bar in bars {<br/>                maxValue = max(maxValue, bar.value)<br/>            }<br/>            <br/>            var xOrigin: CGFloat = interBarMargin<br/><br/>            let margins = interBarMargin * (barCount+1)<br/>            let width = (frame.width - margins) / barCount<br/>            <br/>            for bar in bars {<br/><br/>                let height = barHeight(forValue: bar.value)<br/>                let rect = CGRect(x: xOrigin, <br/>                                  y: bounds.height - height, <br/>                                  width: width, <br/>                                  height: height)<br/>                let view = BarView(frame: rect, <br/>                                   color: bar.color.displayColor)<br/>                barViews.append(view)<br/>                addSubview(view)<br/>                <br/>                xOrigin = view.frame.maxX + interBarMargin<br/>            }<br/>            self.barViews = barViews<br/>        }<br/>    }<br/>    <br/>    private func barHeight(forValue value: Float) -&gt; CGFloat {<br/>        return (frame.size.height / CGFloat(maxValue)) * <br/>          CGFloat(value)<br/>    }<br/>}</pre>&#13;
<h2 id="uuid-6acb4eca-1f98-4ec5-8883-6c3893683370" class="p1">How to do it...</h2>&#13;
<p class="p1">In the code that we defined in the <strong>Getting ready</strong> section, the <kbd>BarChart</kbd> view can be created with a frame and a background color, and then bars can be added in the form of a <kbd>Bar</kbd> struct containing a value and a color. The <kbd>BarChart</kbd> view uses these to create subviews of the correct relative size and scale to represent the values of the bars.</p>&#13;
<p class="p1">Let's write some code to make use of our <kbd>BarChart</kbd> view:</p>&#13;
<ol>&#13;
<li>Enter the following into the playground at the bottom:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">let barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: <br/>  300))<br/>barView.backgroundColor = .white<br/>let bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))<br/>let bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))<br/>let bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))<br/>barView.bars = [bar1, bar2, bar3]</pre>&#13;
<ol start="2">&#13;
<li>Press the blue play button at the bottom-left of the playground window to execute the code. As your code executes, you will see that the playground sidebar fills up with information.</li>&#13;
<li class="CDPAlignLeft CDPAlign">In <a href="">Chapter 1</a>, <em>Swift Building Blocks</em>, we saw that playgrounds have a timeline that provides information about each line of execution. As you pass your cursor over the line, you see an eye-shaped icon that will display a preview of the result of that line of execution. Where the line involves a UI element such as <kbd>view</kbd>, the playground will render that view and display it in a preview box:</li>&#13;
</ol>&#13;
<div><img src="img/38e889da-668d-46db-909a-ca90e823c1c9.png" style="" width="1240" height="511"/></p>&#13;
<p>Figure 7.1 – BarChart preview box</p>&#13;
<ol start="4">&#13;
<li class="CDPAlignLeft CDPAlign">The same is true for the pinned inline preview that you can get by pressing the square button in the timeline:</li>&#13;
</ol>&#13;
<div><img src="img/9d5b513b-badc-43c0-a5ff-b7845022ad43.png" style="" width="685" height="354"/></div>&#13;
<p>Figure 7.2 – BarChart inline preview</p>&#13;
<p class="p1">These features can be great for testing and tweaking view code.</p>&#13;
<p>If the purpose of the playground is to demo or experiment with a custom view component and you'd like a more prominent view output, you can use the playground's live view feature:</p>&#13;
<ol start="1">&#13;
<li>Import the <kbd>PlaygroundSupport</kbd> framework at the top of the playground:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport</pre>&#13;
<p style="padding-left: 60px">The <kbd>PlaygroundSupport</kbd> framework provides a number of features for accessing various features of the playground.</p>&#13;
<ol start="2">&#13;
<li>Add the following to set our <kbd>BarChart</kbd> view to be the playground's live view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">PlaygroundPage.current.liveView = barView</pre>&#13;
<ol start="3">&#13;
<li>If the playground's live view isn't visible, you can display it from the menu. Go to Editor | Live View:</li>&#13;
</ol>&#13;
<div><img src="img/86c567e5-614c-4f42-befc-e780e44af661.png" style="" width="2115" height="1285"/></div>&#13;
<p>Figure 7.3 – Live view</p>&#13;
<p>This view will be updated as the code in the playground changes. Try changing the value of the bars and see the view change.</p>&#13;
<h2 id="uuid-52b32adb-64c6-4997-a865-1246dc6f8e4e" class="p1">How it works...</h2>&#13;
<p>A playground's live view can be anything that conforms to <kbd>PlaygroundLiveViewable</kbd>. On iOS, both <kbd>UIView</kbd> and <kbd>UIViewController</kbd> conform to <kbd>PlaygroundLiveViewable</kbd>, as do their equivalents on macOS: <kbd>NSView</kbd> and <kbd>NSViewController</kbd>.</p>&#13;
<p>In the preceding code, we construct a <kbd>BarChart</kbd>, which is a <kbd>UIView</kbd>, and assign it to the <kbd>liveView</kbd> property of the current <kbd>PlaygroundPage</kbd>.</p>&#13;
<p class="p1">These live views respond to touch events just as they would in a macOS app or in the iOS simulator. Therefore, you can use them to test interactive views and controls.</p>&#13;
<p class="p1">Unfortunately, playgrounds do not currently support interface builder layout files, which are the <kbd>.xibs</kbd> and <kbd>.storyboard</kbd> files. Therefore, to use Playgrounds with your custom views, you will have to lay out your views programmatically.</p>&#13;
<p class="p1">Be aware that iOS-based playgrounds support many, but not all, of the frameworks available in the iOS SDK, so this may limit what you can do in a playground.</p>&#13;
<h2 id="uuid-151fdb5a-b643-4adb-a7ba-bfc151025b90">There's more...</h2>&#13;
<p>In the preceding example, and for most of this book, we focused on iOS-based playgrounds. However, macOS-based playgrounds are just as useful for the macOS platform and can also be used for UI testing and experimentation.</p>&#13;
<p>You will find a macOS-based playground called <kbd>Simple_macOS.playground</kbd> that also creates a simple bar chart view in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI</a></p>&#13;
<p>Alternatively, you can create a new macOS-based playground and enter the following code:</p>&#13;
<ol>&#13;
<li>Create a <kbd>Color</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport<br/>import Cocoa<br/><br/>struct Color {<br/>    let red: CGFloat<br/>    let green: CGFloat<br/>    let blue: CGFloat<br/>    let alpha: CGFloat = 1.0<br/>    <br/>    var displayColor: NSColor {<br/>        return NSColor(calibratedRed: red, <br/>                       green: green, <br/>                       blue: blue, <br/>                       alpha: alpha)<br/>    }<br/>}</pre>&#13;
<ol start="2">&#13;
<li>Create a <kbd>Bar</kbd> struct and <kbd>BarView</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">struct Bar {<br/>    var value: Float<br/>    var color: Color<br/>}<br/><br/>class BarView: NSView {<br/>    <br/>    let color: NSColor<br/>    <br/>    init(frame: NSRect, color: NSColor) {<br/>        self.color = color<br/>        super.init(frame: frame)<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        self.color = .red<br/>        super.init(coder: coder)<br/>    }<br/>    <br/>    override func draw(_ dirtyRect: NSRect) {<br/>        super.draw(dirtyRect)<br/>        color.set()<br/>        NSBezierPath.fill(dirtyRect)<br/>    }<br/>}</pre>&#13;
<ol start="3">&#13;
<li>Create the <kbd>BarChart</kbd> view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">class BarChart: NSView {<br/>    <br/>    let color: NSColor<br/>    <br/>    init(frame: NSRect, color: NSColor) {<br/>        self.color = color<br/>        super.init(frame: frame)<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        self.color = .white<br/>        super.init(coder: coder)<br/>    }<br/>    <br/>    var bars: [Bar] = [] {<br/>        didSet {<br/>            self.barViews.forEach { $0.removeFromSuperview() }<br/>            <br/>            var barViews = [BarView]()<br/>            <br/>            let barCount = CGFloat(bars.count)<br/>            <br/>            // Calculate the max value before calculating size<br/>            for bar in bars {<br/>                maxValue = max(maxValue, bar.value)<br/>            }<br/>            <br/>            var xOrigin: CGFloat = interBarMargin<br/><br/>            let margins = interBarMargin * (barCount+1)<br/>            let width = (frame.width - margins) / barCount<br/>            <br/>            for bar in bars {<br/><br/>                let height = barHeight(forValue: bar.value)<br/>                let rect = NSRect(x: xOrigin, <br/>                                  y: 0, <br/>                                  width: width, <br/>                                  height: height)<br/>                let view = BarView(frame: rect, <br/>                                   color: bar.color.displayColor)<br/>                barViews.append(view)<br/>                addSubview(view)<br/>                <br/>                xOrigin = rect.maxX + interBarMargin<br/>            }<br/>            self.barViews = barViews<br/>        }<br/>    }<br/>    var interBarMargin: CGFloat = 5.0<br/>    <br/>    private var barViews: [NSView] = []<br/>    private var maxValue: Float = 0.0<br/>    <br/>    override func draw(_ dirtyRect: NSRect) {<br/>        super.draw(dirtyRect)<br/>        color.set()<br/>        NSBezierPath.fill(dirtyRect)<br/>    }<br/>    <br/>    private func barHeight(forValue value: Float) -&gt; CGFloat {<br/>        return (frame.size.height / CGFloat(maxValue)) * <br/>          CGFloat(value)<br/>    }<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Use the <kbd>BarChart</kbd> to display information:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">let frame = CGRect(x: 0, y: 0, width: 300, height: 300)<br/>let barView = BarChart(frame: frame,<br/>                       color: .white)<br/>PlaygroundPage.current.liveView = barView<br/>let bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))<br/>let bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))<br/>let bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))<br/>barView.bars = [bar1, bar2, bar3]<br/><br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<p>This macOS version of our custom <kbd>barView</kbd> works exactly like the iOS version, and the live view for a macOS-based playground works exactly like its iOS-based counterparts.</p>&#13;
<p>Similar to iOS, macOS-based playgrounds support many, but not all, of the frameworks available in the macOS SDK, so this may limit what you can do in a playground.</p>&#13;
<p class="p1">Hopefully, you can see from this recipe that Swift Playgrounds can be really useful for viewing UI experimentation on both iOS and macOS.</p>&#13;
<h2 id="uuid-4b63823e-8085-4a81-86c5-2e9b562442d8" class="p1">See also</h2>&#13;
<p>Apple's reference for the Playground Support framework can be found at <a href="http://swiftbook.link/docs/playgroundsupport">http://swiftbook.link/docs/playgroundsupport</a>.</p>&#13;
<h1 id="uuid-d1a9f036-fcce-4d75-8303-ab2809b57723" class="p1">Importing resources into playgrounds</h1>&#13;
<p class="p1">While building apps, we will often need to include resources, such as images. How can we do the same with playgrounds so that our UI can incorporate these images? That is what we will investigate in this recipe.</p>&#13;
<p>We will improve our bar chart custom view from the previous recipe by adding a semi-transparent image to provide a texture for the bars.</p>&#13;
<h2 id="uuid-15e0fde7-4c88-426a-91be-765b0b448bb0" class="p1">Getting ready</h2>&#13;
<p class="p1">For this recipe, we will start with the playground from the previous recipe. The playground is called <kbd>Simple_iOS.playground</kbd>, and you can get it from the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI</a></p>&#13;
<p class="p1">We will be using a semi-transparent texture image for this recipe. You can supply your own, or download a sample one from here: <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources</a></p>&#13;
<h2 id="uuid-6f7871ee-ff9a-4383-9c95-a1a6e5e28343" class="p1">How to do it...</h2>&#13;
<p class="p1">Let's take a look at the following steps to understand how to add our image to the playground:</p>&#13;
<ol>&#13;
<li class="p1">We need to open up Xcode's project navigator, which is often not visible by default when a playground is opened. To reveal the project navigator, select View | Navigators | Project from the menu. Alternatively, you can select the left pane reveal button in the top-left corner of the Xcode window:</li>&#13;
</ol>&#13;
<div><img src="img/43cbb9b5-0d88-41a1-bb7c-5ff765b0dad2.png" style="" width="224" height="56"/></div>&#13;
<p>Figure 7.4 – Project navigator</p>&#13;
<p style="padding-left: 60px">The playground will be listed at the top of the project navigator, along with a disclosure triangle.</p>&#13;
<ol start="2">&#13;
<li>Select the triangle to reveal folders named <kbd>Sources</kbd> and <kbd>Resources</kbd>.</li>&#13;
<li class="p1">Drag the texture image from Finder into the <kbd>Resources</kbd> folder:</li>&#13;
</ol>&#13;
<div><img src="img/9252bd56-5d3a-4cc4-b9c5-39ad0c0f7279.png" style="" width="530" height="309"/></div>&#13;
<p>Figure 7.5 – Adding a file to the project</p>&#13;
<p style="padding-left: 60px">Now that we have embedded our texture image within our playground, we need to make use of it. We want each bar in the bar chart to have a settable color, but for the texture to sit on top of that color.</p>&#13;
<ol start="4">&#13;
<li>Update the <kbd>BarView</kbd> part of our code to use the texture image:</li>&#13;
</ol>&#13;
<p>&#13;
<pre style="padding-left: 60px" class="p1">class BarView: UIView {<br/>    <br/>    init(frame: CGRect, color: UIColor) {<br/>        super.init(frame: frame)<br/>        backgroundColor = color<br/>        setupTexture()<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        super.init(coder: coder)<br/>        backgroundColor = UIColor.red<br/>        setupTexture()<br/>    }<br/>    <br/>    private func setupTexture() {<br/>        guard let textureImage = UIImage(named: "texture") else {<br/>          return }<br/>        let textureColor = UIColor(patternImage: textureImage)<br/>        let frame = CGRect(origin: .zero, size: bounds.size)<br/>        let textureView = UIView(frame: frame)<br/>        textureView.backgroundColor = textureColor<br/>        addSubview(textureView)<br/>    }<br/>}</pre></p>&#13;
<ol start="5">&#13;
<li>We can retrieve the image in the same way we would in a full app by referencing the filename of the image, without the file extension, in a <kbd>UIImage</kbd> initializer:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">let textureImage = UIImage(named: "texture")</pre>&#13;
<p class="p1">When the playground is executed, you will see that our bar chart looks a lot more interesting:</p>&#13;
<div><img src="img/82aa36b1-7709-45fe-ac97-d578eb0237bf.png" style="" width="701" height="737"/></div>&#13;
<p>Figure 7.6 – Textured bar chart</p>&#13;
<h2 id="uuid-7e4ffaf0-bf1f-4bc3-a4eb-32574a771f42" class="p1">How it works...</h2>&#13;
<p class="p1">To understand where the image that we added is stored, it helps to know how playgrounds are structured.</p>&#13;
<p class="p1">A playground is actually a folder, but with a <kbd>.playground</kbd> file extension. We can see this by taking a playground file and showing the context menu, which can be done by right-clicking or holding <em>Ctrl</em> while clicking on the file. From this menu, select Show Package Contents:</p>&#13;
<div><img src="img/ac4a88cc-26b3-4f6a-9efe-284d1b2f6daf.png" style="" width="523" height="269"/></div>&#13;
<p>Figure 7.7 – Viewing Package Contents</p>&#13;
<p class="p1">This will open the playground as a folder, showing its contents. In there, you will find a number of files, including one called <kbd>Contents.swift</kbd>, which is the Swift file containing the code that is executed. There is also a folder called <kbd>Resources</kbd>, which contains the texture image we imported:</p>&#13;
<div><img src="img/a5abe1ff-9729-4f31-b307-fde116dc58df.png" style="" width="371" height="237"/></div>&#13;
<p>Figure 7.8 – Package Contents</p>&#13;
<p class="p1 CDPAlignLeft CDPAlign">By dragging the image into the file navigator, Xcode created this folder and placed the image in it. Alternatively, we could have created this folder manually and dropped it in the image. Playgrounds will look for a folder named <kbd>Resources</kbd>, and all the resources in it will be made available from the playground.</p>&#13;
<h2 id="uuid-bd4e6bad-4c1e-461b-b27f-303644dc396e" class="p1">See also</h2>&#13;
<p class="p1">The result of this recipe is available as <kbd>EmbeddedResources.playground</kbd> in the GitHub repository for this book, in the <kbd>chapter 7</kbd> folder.</p>&#13;
<h1 id="uuid-09771bc2-103d-4547-91a7-cf41d04540e9" class="p1">Importing code into playgrounds</h1>&#13;
<p class="p1">As we have seen throughout this chapter, and this book, playgrounds are a great canvas for exploring APIs, frameworks, and custom code. However, if you want to explore uses for your own code, it appears that you need to include all the code needed in the playground, and that can make it long and unwieldy.</p>&#13;
<p class="p1">It doesn't need to be that way. In this recipe, we will see how you can embed Swift code in your playground and make use of it from your playground code.</p>&#13;
<h2 id="uuid-b7630181-d0f3-44a8-9e25-500745524e55" class="p1">Getting ready</h2>&#13;
<p class="p1">For this recipe, we will use the playground from the previous recipe, called <kbd>EmbeddedResources.playground</kbd>, which can be retrieved from this book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds</a>.</p>&#13;
<h2 id="uuid-f9f9d049-c007-4d72-a35e-40124f661cf0" class="p1">How to do it...</h2>&#13;
<p class="p1">We will take the <kbd>BarChart</kbd> custom view and related code and move it to a separate file embedded within the playground, leaving us free to use the playground to experiment with our custom view:</p>&#13;
<ol>&#13;
<li class="p1">If the playground's project navigator isn't visible, select View | Navigators | Project from the menu.</li>&#13;
<li class="p1">Select the Sources folder and then select File | New | File from the menu to create a new Swift file in your <kbd><strong>Sources</strong></kbd> folder:</li>&#13;
</ol>&#13;
<div><img src="img/aa82d350-1fc3-440d-a597-f7f798c30d73.png" style="" width="403" height="302"/></div>&#13;
<p>Figure 7.9 – Sources folder</p>&#13;
<ol start="3">&#13;
<li>If you already have Swift files that you want to embed in a playground, you can drag the files into the <kbd>Sources</kbd> folder, just like we did with our texture image in the previous recipe.</li>&#13;
<li class="p1">Rename the new file <kbd>Color.swift</kbd>, as we will use this to hold our <kbd>Color</kbd> struct that is currently in the main playground content.</li>&#13;
<li class="p1">Enter the following code into <kbd>Color.swift</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import UIKit<br/><br/>public struct Color {<br/>    let red: Float<br/>    let green: Float<br/>    let blue: Float<br/>    let alpha: Float<br/>    <br/>    public init(red:Float, green:Float, blue:Float, alpha:Float = 1) {<br/>        self.red = red<br/>        self.green = green<br/>        self.blue = blue<br/>        self.alpha = alpha<br/>    }<br/>    <br/>    var displayColor: UIColor {<br/>        return UIColor(red: CGFloat(red),<br/>                       green: CGFloat(green),<br/>                       blue: CGFloat(blue),<br/>                       alpha: CGFloat(alpha))<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px" class="p1">Note that we have added <kbd>public</kbd> access controls to the <kbd>Color</kbd> struct and its initializer; we will see more about that as we progress.</p>&#13;
<ol start="6">&#13;
<li class="p1">Create another new Swift file in the <kbd>Sources</kbd> folder as we did earlier, called <kbd>BarChart.swift</kbd>, and then enter the rest of the code needed to define the <kbd>BarChart</kbd> custom view, starting with the <kbd>Bar</kbd> struct:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import UIKit<br/><br/>public struct Bar {<br/>    var value: Float<br/>    var color: Color<br/>    <br/>    public init(value: Float, color: Color) {<br/>        self.value = value<br/>        self.color = color<br/>    }<br/>}<br/></pre>&#13;
<p style="padding-left: 60px">This is followed by <kbd>BarView</kbd>:</p>&#13;
<pre style="padding-left: 60px" class="p1">class BarView: UIView {<br/>    <br/>    init(frame: CGRect, color: UIColor) {<br/>        super.init(frame: frame)<br/>        backgroundColor = color<br/>        setupTexture()<br/>    }<br/>    <br/>    required init?(coder: NSCoder) {<br/>        super.init(coder: coder)<br/>        backgroundColor = UIColor.red<br/>        setupTexture()<br/>    }<br/>    <br/>    private func setupTexture() {<br/>        guard let textureImage = UIImage(named: "texture") else { <br/>          return }<br/>        let textureColor = UIColor(patternImage: textureImage)<br/>        let textureView = UIView(frame: bounds)<br/>        textureView.backgroundColor = textureColor<br/>        addSubview(textureView)<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">And finally, we have <kbd>BarChart</kbd>:</p>&#13;
<pre style="padding-left: 60px" class="p1">public class BarChart: UIView {<br/>    <br/>    private var barViews: [BarView] = []<br/>    private var maxValue: Float = 0.0<br/><br/>    var interBarMargin: CGFloat = 5.0<br/>    <br/>    public var bars: [Bar] = [] {<br/>        didSet {<br/>            self.barViews.forEach { $0.removeFromSuperview() }<br/>            <br/>            var barViews = [BarView]()<br/>            <br/>            let barCount = CGFloat(bars.count)<br/>            <br/>            // Calculate the max value before calculating size<br/>            for bar in bars {<br/>                maxValue = max(maxValue, bar.value)<br/>            }<br/>            <br/>            var xOrigin: CGFloat = interBarMargin<br/><br/>            let margins = interBarMargin * (barCount+1)<br/>            let width = (frame.width - margins) / barCount<br/>            <br/>            for bar in bars {<br/><br/>                let height = barHeight(forValue: bar.value)<br/>                let rect = CGRect(x: xOrigin, <br/>                                  y: bounds.height - height, <br/>                                  width: width, <br/>                                  height: height)<br/>                let view = BarView(frame: rect, <br/>                                   color: bar.color.displayColor)<br/>                barViews.append(view)<br/>                addSubview(view)<br/>                <br/>                xOrigin = view.frame.maxX + interBarMargin<br/>            }<br/>            self.barViews = barViews<br/>        }<br/>    }<br/>    <br/>    private func barHeight(forValue value: Float) -&gt; CGFloat {<br/>        return (frame.size.height / CGFloat(maxValue))*<br/>          CGFloat(value)<br/>    }<br/>}</pre>&#13;
<ol start="7">&#13;
<li class="p1">With the <kbd>BarChart</kbd> implementation code contained in the <kbd>Sources</kbd> folder, the playground contents can be just for experimenting with the <kbd>BarChart</kbd> custom view. Remove the code we placed in the other files and you are left with the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport<br/>import UIKit<br/><br/>let barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: <br/>  300))<br/>barView.backgroundColor = .white<br/>let bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))<br/>let bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))<br/>let bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))<br/>barView.bars = [bar1, bar2, bar3]<br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<h2 id="uuid-37ba073a-2a62-4bd2-af04-7672b5c1b267" class="p1">How it works...</h2>&#13;
<p class="p1">In moving the <kbd>BarChart</kbd> implementation to embedded Swift files, we added <kbd>public</kbd> access control at points where we wanted it to be accessible from the playground content. This is because code within the <kbd>Sources</kbd> folder acts as a kind of lightweight module in terms of access control.</p>&#13;
<p class="p1">Anything with the default <kbd>internal</kbd> access control is only accessible to other code inside the <kbd>Sources</kbd> folder. To make it accessible to code in the main playground content, it needs to be declared as <kbd>public</kbd> or <kbd>open</kbd>. This is really useful, as it allows you to be in control of what you expose to the playground content; so, you can provide well-designed APIs that don't expose the underlying complexity.</p>&#13;
<p>If you require a refresher on access controls or want to learn more, check out the recipe entitled <em>Controlling access with access control</em>, in <a href="67605929-e031-49f6-83a9-9f7352e9bad3.xhtml">Chapter 2</a>, <em>Mastering the Building Blocks</em>.</p>&#13;
<h2 id="uuid-6c401c68-3081-4801-bf5f-ef22390c2fdb" class="p1">See also</h2>&#13;
<p class="p1">The result of this recipe can be found in <kbd>EmbeddedSources.playground</kbd> in this book's GitHub repository.</p>&#13;
<p class="p1">Further information about Swift access controls can be found in <a href="67605929-e031-49f6-83a9-9f7352e9bad3.xhtml">Chapter 2</a>, <em>Mastering the Building Blocks</em>.</p>&#13;
<h1 id="uuid-e5a06d5e-7e33-4d7c-9731-bc220519a6b9" class="p1">Multi-page playgrounds</h1>&#13;
<p class="p1">We've discussed how playgrounds can be a great tool for exploring APIs and experimenting with UIs. However, playgrounds can also be used for documenting APIs, and providing rich, linkable content. Swift Playgrounds provides support for rich text formatting in comments and multiple pages of content, and we will explore those features in this recipe.</p>&#13;
<h2 id="uuid-5ac97f59-fc99-4b55-b533-053c2915d429" class="p1">Getting ready</h2>&#13;
<p class="p1">We will start with the playground we used in the last recipe, which displayed our custom <kbd>BarChart</kbd> view. You can get the playground, called <kbd>EmbeddedSources.playground</kbd>, from the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07</a>.</p>&#13;
<p class="p1">We will use our <kbd>BarChart</kbd> view to display the price in US dollars of three different cryptocurrencies over a 6-month period between January 2020 and June 2020. We can show each type of currency on a different playground page.</p>&#13;
<p>If you want to know more about cryptocurrencies, you can watch this explanatory video: <br/>&#13;
<a href="http://swiftbook.link/videos/cryptocurrencies">http://swiftbook.link/videos/cryptocurrencies</a>.<a href="http://swiftbook.link/videos/cryptocurrencies"/></p>&#13;
<h2 id="uuid-2e211d23-7706-40c7-869f-7dbe58ebb9b4" class="p1">How to do it...</h2>&#13;
<p class="p1">By default, playgrounds have just one Swift content file, but for our purpose, we want to have three pages in our playground, one for each of the three cryptocurrencies we will document: Bitcoin, Etherium, and Lightcoin. Let's get started:</p>&#13;
<ol>&#13;
<li class="p1">If the project navigator isn't visible, you should make it visible using the menu by selecting View | Navigators | Project.</li>&#13;
<li class="p1">To create a new playground page, you can click on the plus button in the bottom left-hand corner of the project navigator, or select File | New | Playground Page from the menu:</li>&#13;
</ol>&#13;
<div><img src="img/8d036058-f503-42c7-9d68-8f2750155e88.png" style="" width="469" height="97"/></div>&#13;
<p>Figure 7.10 – New Playground Page</p>&#13;
<p style="padding-left: 60px">When creating a new playground page, the existing contents of the playground become a playground page, and another blank page is created:</p>&#13;
<div><img src="img/b19ed5fc-387a-433b-9621-055121c7a461.png" style="" width="522" height="360"/></div>&#13;
<p>Figure 7.11 – Creating a new page in Playgrounds</p>&#13;
<ol start="3">&#13;
<li>Create three pages in total, as we will display data on three different cryptocurrencies, and rename them as follows:</li>&#13;
</ol>&#13;
<ul>&#13;
<li class="p1"><kbd>Bitcoin</kbd></li>&#13;
<li class="p1"><kbd>Etherium</kbd></li>&#13;
<li class="p1"><kbd>Lightcoin</kbd></li>&#13;
</ul>&#13;
<p style="padding-left: 60px">Each of these pages can use the <kbd>BarChart</kbd> code in the <kbd>Sources</kbd> folder that we added in the previous recipe, so we can create a <kbd>BarChart</kbd> view on each page to chart the value of each currency.</p>&#13;
<ol start="4">&#13;
<li class="p1">Enter the following code into the <kbd>Bitcoin</kbd> playground page:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport<br/>import UIKit<br/><br/>let frame = CGRect(x: 0, y: 0, width: 300, height: 300)<br/>let barView = BarChart(frame: frame)<br/>barView.backgroundColor = .white<br/><br/>let green =  Color(red: 0, green: 1, blue: 0)<br/><br/>let jan2020 = Bar(value: 9388.88, color: green)<br/>let feb2020 = Bar(value: 8639.59, color: green)<br/>let mar2020 = Bar(value: 6483.74, color: green)<br/>let apr2020 = Bar(value: 8773.11, color: green)<br/>let may2020 = Bar(value: 9437.05, color: green)<br/>let jun2020 = Bar(value: 9164.54, color: green)<br/><br/>barView.bars = [jan2020,<br/>                feb2020,<br/>                mar2020,<br/>                apr2020,<br/>                may2020,<br/>                jun2020]<br/><br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<ol start="5">&#13;
<li>Next, enter the following code into the <kbd>Etherium</kbd> playground page:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport<br/>import UIKit<br/><br/>let frame = CGRect(x: 0, y: 0, width: 300, height: 300)<br/>let barView = BarChart(frame: frame)<br/>barView.backgroundColor = .white<br/><br/>let blue = Color(red: 0, green: 0, blue: 1)<br/><br/>let jan2020 = Bar(value: 181.73, color: blue)<br/>let feb2020 = Bar(value: 223.5, color: blue)<br/>let mar2020 = Bar(value: 133.76, color: blue)<br/>let apr2020 = Bar(value: 209.42, color: blue)<br/>let may2020 = Bar(value: 245.76, color: blue)<br/>let jun2020 = Bar(value: 225.71, color: blue)<br/><br/>barView.bars = [jan2020,<br/>                feb2020,<br/>                mar2020,<br/>                apr2020,<br/>                may2020,<br/>                jun2020]<br/><br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<ol start="6">&#13;
<li>Lastly, enter the following code into the <kbd>Lightcoin</kbd> playground page:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="p1">import PlaygroundSupport<br/>import UIKit<br/><br/>let frame = CGRect(x: 0, y: 0, width: 300, height: 300)<br/>let barView = BarChart(frame: frame)<br/>barView.backgroundColor = .white<br/><br/>let red = Color(red: 1, green: 0, blue: 0)<br/><br/>let jan2020 = Bar(value: 67.58, color: red)<br/>let feb2020 = Bar(value: 58.09, color: red)<br/>let mar2020 = Bar(value: 39.13, color: red)<br/>let apr2020 = Bar(value: 46.19, color: red)<br/>let may2020 = Bar(value: 44.23, color: red)<br/>let jun2020 = Bar(value: 41.21, color: red)<br/><br/>barView.bars = [jan2020,<br/>                feb2020,<br/>                mar2020,<br/>                apr2020,<br/>                may2020,<br/>                jun2020]<br/><br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<p class="p1">Each page displays the value history as a bar chart when run, and you can use the project navigator to switch between them.</p>&#13;
<h2 id="uuid-fe9e7531-a718-49ad-a05e-9f766a48a644" class="p1">How it works...</h2>&#13;
<p class="p1">As we did in previous recipes, we can take a look inside the playground to see how each playground page is represented. Right-click on the playground, or hold <em>Ctrl</em> while clicking on it. From this menu, select Show Package Contents:</p>&#13;
<div><img src="img/6507b3a7-71a9-4d35-b158-fadb2227bf4e.png" style="" width="498" height="264"/></div>&#13;
<p>Figure 7.12 – Viewing Package Contents</p>&#13;
<p class="p1">You will see that the <kbd>Contents.swift</kbd> folder that we saw earlier has been replaced with a folder containing three <kbd>.xcplaygroundpage</kbd> files, one for each page in the playground:</p>&#13;
<div><img src="img/6b6ba5b8-7ac1-4e6a-9ed9-1c9facc79830.png" style="" width="452" height="504"/></div>&#13;
<p>Figure 7.13 – Extracted content</p>&#13;
<p class="p1">Each of these <kbd>.playgroundpage</kbd> files is essentially a playground in itself. You can right-click on <kbd>.playgroundpage</kbd> and select Show Package Contents, and you will see the same playground structure that we saw previously. Much like the normal playground, a <kbd>.xcplaygroundpage</kbd> file can contain the <kbd>Sources</kbd> and <kbd>Resources</kbd> subfolders, and placing code and resources in these will make them visible to just that page.</p>&#13;
<h2 id="uuid-a54584a4-6110-4dea-9f23-f54df729bf6d" class="p1">There's more...</h2>&#13;
<p class="p1">Since we can now add multiple pages of content and have the ability to embed code and resources, Swift Playgrounds appears very useful in terms of interactive code documentation. To assist in this use case, it would be great if we could have some control over the presentation of our comments; well we can, as playgrounds support comments in <strong>Markdown</strong>.</p>&#13;
<p class="p1">Markdown is a lightweight text formatting syntax, invented by <em>John Gruber</em>, and is widely used to write text that can then be rendered with rich text formatting. More details about Markdown can be found at <a href="http://swiftbook.link/markdown/docs">http://swiftbook.link/markdown/docs</a>.</p>&#13;
<p class="p1">We won't delve into the Markdown syntax, but you can find a useful <em>cheat sheet</em> at <a href="http://swiftbook.link/markdown/cheatsheet">http://swiftbook.link/markdown/cheatsheet</a>.<a href="http://swiftbook.link/markdown/cheatsheet"/></p>&#13;
<p class="p1">In our playground, open up the File Inspector window by selecting from the menu View | Inspectors | File and look under Playground Settings. You will see an option for Render Documentation. Ensure that this is set to off while we write some Markdown comments:</p>&#13;
<div><img src="img/5120e954-28b5-446c-aa7f-8fec187b91d0.png" style="" width="501" height="152"/></div>&#13;
<p>Figure 7.14 – Playground Settings</p>&#13;
<p class="p1">Let's now add some comments to our <kbd>Bitcoin</kbd> page:</p>&#13;
<pre class="p1">/*:<br/> # Crypto Currencies<br/> ## Bitcoin<br/> */<br/><br/>import PlaygroundSupport<br/>import UIKit<br/><br/>/*:<br/> ### Usage<br/> * Create Bar Chart<br/> * Create Bars and add to chart<br/> * Make Bar Chart the LiveView<br/> */<br/>let barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: <br/>  300))<br/>barView.backgroundColor = .white<br/>let green =  Color(red: 0, green: 1, blue: 0, alpha: 1.0)<br/><br/>/*:<br/> * Note: <br/> Bitcoin Price (in USD)<br/> - Jan 2017 -  $970.17<br/> - Feb 2017 -  $960.05<br/> - Mar 2017 - $1203.02<br/> - Apr 2017 - $1076.90<br/> - May 2017 - $1390.24<br/> - Jun 2017 - $2414.11<br/><br/>Taken from [Statista](https://www.statista.com/statistics/326707/bitcoin-price-index)<br/> */<br/>let jan2017 = Bar(value: 970.17, color: green)<br/>let feb2017 = Bar(value: 960.05, color: green)<br/>let mar2017 = Bar(value: 1203.02, color: green)<br/>let apr2017 = Bar(value: 1076.90, color: green)<br/>let may2017 = Bar(value: 1390.24, color: green)<br/>let jun2017 = Bar(value: 2414.11, color: green)<br/><br/>barView.bars = [jan2017, feb2017, mar2017, apr2017, may2017, jun2017]<br/>PlaygroundPage.current.liveView = barView</pre>&#13;
<p class="p1">To indicate to the playground that your comments contain Markdown formatting, a colon, <kbd>:</kbd>, is added after the opening of the comment block. This works for multi-line comments, <kbd>/*:</kbd>, and single-line comments, <kbd>//:</kbd>.</p>&#13;
<p class="p1">With these comments in place, let's turn Render Documentation back on and see what the comments look like:</p>&#13;
<div><img src="img/d24515e8-fc57-49e2-a82a-6f46534368e5.png" style="" width="879" height="1503"/></div>&#13;
<p>Figure 7.15 – Rendered document</p>&#13;
<p class="p1">In addition, playgrounds also support the creation of Markdown links between the playground pages; you can link to the next page with <kbd>@next</kbd> and to the previous page with <kbd>@previous</kbd>. So, in Markdown, the links will be as follows:</p>&#13;
<pre class="p1">//: [Next page](@next)<br/>//: [Previous page](@previous)</pre>&#13;
<p class="p1">It is left as an exercise to the reader to add Markdown comments to the other two pages and provide links between the pages.</p>&#13;
<h2 id="uuid-e6a85677-2fc2-41f2-8188-b72983e7131f" class="p1">See also</h2>&#13;
<p>The result of this recipe can be found as <kbd>MultiplePages.playground</kbd> in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground</a>.</p>&#13;
<p>Further information pertaining to the Markdown syntax can be found at <a href="http://swiftbook.link/markdown/docs">http://swiftbook.link/markdown/docs</a>.<a href="http://swiftbook.link/markdown/docs"/></p>&#13;
<h1 id="uuid-981a866b-71f8-4356-a66e-f686a28fad29">Using Swift Playgrounds on iPadOS</h1>&#13;
<p>In 2016, Apple released an iPad-only app called Swift Playgrounds. Taken from the success of Playgrounds from Xcode, Swift Playgrounds for iPadOS went a step further and added an additional educational element to the app. In 2020, Apple also released a version for macOS, opening the doors for educational purposes and to those starting out who may feel a little intimidated by the Xcode IDE.</p>&#13;
<p>In this recipe, we'll take a look at how we can more easily replicate a recipe similar to that from <a href="32abd392-d947-461c-a9e9-912b34704c9b.xhtml">Chapter 6</a>, <em>Building iOS Apps with Swift</em>, straight on our iPad.</p>&#13;
<h2 id="uuid-ed0e7195-47a2-4515-acd2-520cb387f8b7">Getting ready</h2>&#13;
<p>For this recipe, you'll need either an iPad running iOS 14.0 in order to download Swift Playgrounds from the App Store or alternatively, you can download the macOS version from the Mac App Store and follow along with this recipe too.</p>&#13;
<h2 id="uuid-6a3d6e7b-7022-4050-90a6-bdaa192d4b07">How to do it...</h2>&#13;
<ol>&#13;
<li>We'll start by launching the Swift Playgrounds app from your device. You should be presented with the following:</li>&#13;
</ol>&#13;
<div><img src="img/4202ce08-141b-4d26-b348-ca71a4ebdf8e.png" style="" width="1638" height="2378"/></div>&#13;
<p>Figure 7.16 – Swift Playgrounds on iPadOS</p>&#13;
<ol start="2">&#13;
<li>Next, you can either scroll along with the Get a Playground carousel until you see Blank or tap on the new document icon on the top left next to Locations.</li>&#13;
<li>A new document will be created and added to your playgrounds. Tap on this to open it.</li>&#13;
</ol>&#13;
<p>Welcome to the Playgrounds Editor. This is where we can go ahead and write code, with a sense of familiarity that you'll get from developing in Xcode:</p>&#13;
<div><img src="img/1b43150d-b4d6-4f00-b312-fa0d08b4fb98.png" style="" width="1656" height="830"/></div>&#13;
<p>Figure 7.17 – My Playground</p>&#13;
<p>We'll start by doing something simple, just to get familiar with the IDE (<em>yes, I'm calling it an IDE - it kind of is in a way...</em>):</p>&#13;
<ol>&#13;
<li>Tap on the screen to raise the keyboard. If the keyboard doesn't raise, simply press the chevron on the right-hand side of the bottom toolbar. While you are down there, take a look at some of the available keyword suggestions – let, var, if, and so on.</li>&#13;
<li>Go ahead and tap on the let constant. You will notice that the following is autopopulated for you:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let name = value</pre>&#13;
<ol start="3">&#13;
<li>With the name placeholder highlighted, simply start typing your variable name, create one called <kbd>isSwitchedOn</kbd>, and now press the <em>tab</em> key to move the highlighted placeholder over to the <kbd>value</kbd><strong> </strong>here. Then, type the word <kbd>true</kbd>. </li>&#13;
</ol>&#13;
<p style="padding-left: 60px">Just as you would expect in Swift, type inference kicks in and we've created a constant Bool called <kbd>isSwitchedOn</kbd> with the value of <kbd>true</kbd>.</p>&#13;
<ol start="4">&#13;
<li>Next, on a new line, tap on <kbd>if</kbd> and complete the following highlighted code snippet:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let isSwitchedOn = true<br/><strong>if isSwitchedOn {</strong><br/><strong>    print("Switched On")</strong><br/><strong>}</strong></pre>&#13;
<ol start="5">&#13;
<li>Once done, press the Run My Code button and you should observe that a red indicator appears on the icon to the left of this button. Tap on that to reveal the console window and check out your print statement.</li>&#13;
</ol>&#13;
<p>Pretty cool hey! OK, so let's do something a bit more complex and fun. Create another project and call it <kbd>Quotes</kbd> (or whatever name you prefer):</p>&#13;
<ol>&#13;
<li>First, we need to add a couple of imports if they are not already there:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import UIKit<br/>import PlaygroundSupport<br/><br/>PlaygroundPage.current.needsIndefiniteExecution = true</pre>&#13;
<p style="padding-left: 60px">This is followed by the third line, which sets the playground to run continuously. We'll go into more details as to why we need that in our <em>How it works...</em> section.</p>&#13;
<ol start="2">&#13;
<li>Next, we'll continue by creating a couple of structs, as follows:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct RootResponse: Codable {<br/>    let response: [Response]?<br/>}<br/><br/>struct Response: Codable {<br/>    let id: String?<br/>    let quote: String<br/>}</pre>&#13;
<ol start="3">&#13;
<li>These match the response type from the API we are about to call. Next, let's create a function similar to the <kbd>fetchRepos()</kbd> function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fetchQuotes(completionHandler: @escaping (<strong>[Response]</strong>?) -&gt; Void) <br/>  -&gt; URLSessionDataTask? {<br/>    <br/>    var session = URLSession.shared<br/>    <br/><strong>    let urlString = "https://api.bobross.dev/api/10"</strong><br/>    <br/>    guard let url = URL(string: urlString) else {<br/>        return nil<br/>    }<br/>    var request = URLRequest(url: url)<br/>    let task = session.dataTask(with: request) { (data, response, <br/>      error) in<br/>        <br/>        // First unwrap the optional data<br/>        guard let data = data else {<br/>            completionHandler(nil)<br/>            return<br/>        }<br/>        <br/>        do {<br/>            let decoder = JSONDecoder()<br/>            let responseObject = try <br/>              decoder.decode(RootResponse.self, from: data)<br/>            <br/>            completionHandler(responseObject.response)<br/>        } catch {<br/>            completionHandler(nil)<br/>        }<br/>    }<br/>    task.resume()<br/>    <br/>    return task<br/>}</pre>&#13;
<p style="padding-left: 60px">For simplicity, I've made some small tweaks here, as highlighted in the preceding code. We have just made an adjustment to the <kbd>return</kbd> type, returning our codable object that we created in the previous step.</p>&#13;
<p style="padding-left: 60px">We're also calling a different API, one that will return us with an array of quotes that we can iterate through.</p>&#13;
<ol start="4">&#13;
<li>Next, let's call our function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">fetchQuotes { (response) in<br/>    guard let quotes = response as? [Response] else { return }<br/>    <br/>    for item in quotes {<br/>        print(item.quote ?? "")<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">Here, we're just iterating around the response, but you should see the following red badge appear next to our console icon:</p>&#13;
<div><img src="img/7150ec30-df04-400a-9e2b-5bb0f5286afa.jpeg" style="" width="514" height="106"/></div>&#13;
<p>Figure 7.18 – The Stop running button</p>&#13;
<ol start="5">&#13;
<li>Go ahead and tap on the icon and see the results logged to the console. If everything is going well, you should now see a list of 10 quotes.</li>&#13;
</ol>&#13;
<p>With this all working, let's take a look at how we can arrange our code a little better, much like Playgrounds in Xcode. Our main Swift file is embedded within a single root file; however, we are given support for <strong>modules</strong> with the addition of shared code files:</p>&#13;
<ol>&#13;
<li>To access these, press on the navigation icon in the top-left corner next to the close button. When pressed, it should look something like this:</li>&#13;
</ol>&#13;
<div><img src="img/c14fb91a-fc89-4bf8-8120-2ec132994266.jpeg" style="" width="2076" height="786"/></div>&#13;
<p>Figure 7.19 – Project navigation window</p>&#13;
<p style="padding-left: 60px">Don't worry too much about the file structure, we'll go through that in the <em>How it works...</em> section later; all you need to know for now is that all code that can be used (or <em>shared</em>) by the playground file is within a module called UserModule (which can be renamed should you wish).</p>&#13;
<ol start="2">&#13;
<li>Under here is a file called <kbd>SharedCode.swift</kbd>. Highlight this and cut and paste the codable structs from the main project into here. You can rename <kbd>SharedCode.swift</kbd> to <kbd>Models.swift</kbd> if you like.</li>&#13;
</ol>&#13;
<ol start="3">&#13;
<li>Run the project again and you'll notice that you're given the following compiler error – Property cannot be declared public because its type uses an internal type<em>.</em> Basically, due to the way Swift Playgrounds interprets external files, you need to make the structs public:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px" class="mce-root"><strong>public struct RootResponse: Codable {<br/>    public let response: [Response]?<br/>}<br/><br/>public</strong> struct Response: Codable {<br/>    <strong>public</strong> let id: String?<br/>    <strong>public</strong> let quote: String<br/>}</pre>&#13;
<p>Run this again and you'll see the logic working again in all its glory, but as nice as it is to see this in the output window, let's again take a look at how we can add this to our <kbd>liveView</kbd> canvas:</p>&#13;
<ol>&#13;
<li>We start by programmatically creating a <kbd>TableViewController()</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class TableViewController: UITableViewController { }</pre>&#13;
<ol start="2">&#13;
<li class="mce-root">We'll override <kbd>viewWillLoad()</kbd> and add in our code here to call our <kbd>fetchQuotes()</kbd> function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>        <br/>    // Fetch Quotes code to go here<br/>        <br/>}</pre>&#13;
<ol start="3">&#13;
<li>Now we'll need to add a couple of class properties, so incorporate the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var quotes = [String]()<br/>var session = URLSession.shared</pre>&#13;
<p style="padding-left: 60px"><kbd>URLSession</kbd> will be used for our <kbd>fetchQuotes()</kbd> function just as we needed before. The quotes array will be where we store all our quotes from the API response.</p>&#13;
<ol start="4">&#13;
<li>Next, copy the <kbd>fetchQuotes()</kbd> function into the <kbd>TableViewController</kbd> class (currently this will sit outside).</li>&#13;
<li>Now, we can extend <kbd>viewDidLoad()</kbd> to call our function:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func viewDidLoad() {<br/>    super.viewDidLoad()<br/>        <br/><strong>    fetchQuotes { (response) in</strong><br/><strong>            </strong><br/><strong>        guard let quotes = response as? [Response] else { return }</strong><br/><strong>        for item in quotes {</strong><br/><strong>            self.quotes.append(item.quote)</strong><br/><strong>        }</strong><br/><strong>        DispatchQueue.main.async {</strong><br/><strong>            self.tableView.reloadData()</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/>        <br/>}</pre>&#13;
<p style="padding-left: 60px">Notice that in the preceding code, rather than printing the output to the console, we'll now add this to our quotes array. Once our array has been populated and we're no longer iterating around the response, we can call <kbd>reloadData()</kbd> on our table view, which we'll need to do inside <kbd>DispatchQueue.main.async</kbd> to force the reload on the main thread (as we're currently inside an asynchronous response callback from our API).</p>&#13;
<ol start="6">&#13;
<li>Once this is done, let's add in some <kbd>UITableView</kbd> delegates that are required in order for our Table view to display our data:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func numberOfSections(in tableView: UITableView) -&gt; Int {<br/>    return 1<br/>}<br/>    <br/>override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {<br/>    return quotes.count<br/>}</pre>&#13;
<p style="padding-left: 60px">We will now need to add <kbd>numberOfSections()</kbd> in any order, which will return <kbd>1</kbd> followed by <kbd>numberOfRowsInSection()</kbd>, which will return the number of quotes in our array.</p>&#13;
<ol start="7">&#13;
<li>Finally, we need to add in the <kbd>cellForRowAt()</kbd> delegate:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {<br/>        <br/>    let quote = quotes[indexPath.row]<br/>    var cell = UITableViewCell()<br/>    if let _ = tableView.dequeueReusableCell(withIdentifier: <br/>      "table.view.cell") {<br/>        cell = UITableViewCell(style: .default, reuseIdentifier:<br/>          "table.view.cell")<br/>    }<br/><br/>    cell.textLabel?.text = quote<br/>    return cell<br/>        <br/>}</pre>&#13;
<p style="padding-left: 60px">Here, we simply create an instance of <kbd>UITableViewCell()</kbd>. If no reuse identifier is set, we'll add one to our cell (we've called ours <kbd>table.view.cell</kbd>, but you can call it anything you want). Then, using the current index of the cell being called, we obtain the text from our quotes array.</p>&#13;
<ol start="8">&#13;
<li>Finally, we need to assign <kbd>TableViewContoller</kbd> to our Live view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">PlaygroundPage.current.liveView = TableViewController()</pre>&#13;
<ol start="9">&#13;
<li>Press Run My Code and you should see the following:</li>&#13;
</ol>&#13;
<div><img src="img/0474ab16-5dc9-44e2-ad2f-e80ec4dcc0b1.png" width="411" height="476"/></div>&#13;
<p>Figure 7.20 – Results live view</p>&#13;
<p>Whether your using Playground on the iPad or via the Mac App Store, it goes without saying that it's certainly a powerful alternative to Xcode.</p>&#13;
<h2 id="uuid-2ccc62a3-b4f6-413b-80eb-32b11fce07ef">How it works...</h2>&#13;
<p>Swift Playgrounds has some powerful features, and especially if you're used to using Xcode, you'll immediately start to make a comparison (I know I did). But taking a step back and seeing how it all wonderfully knits together certainly opened my eyes to not only writing code but developing on an iPad.</p>&#13;
<p>Let's take a look at the code completion. Normally with Xcode, we'll expect this to show up when we're typing away, in a small dialog/table next to our text, but with Swift Playgrounds on iPadOS, we get this in the form of a horizontal scroll bar at the bottom of the screen:</p>&#13;
<div><img src="img/44568049-8fcc-4144-90a9-8d82003a2d7f.jpeg" style="" width="1752" height="402"/></div>&#13;
<p>Figure 7.21 – Syntax suggestions</p>&#13;
<p>Here, we can see an example of code completion on <kbd>UITableView</kbd>. Notice that immediately we're given multiple options that refer to just UITableViews. Go ahead and re-implement the delegate you did earlier, and you will then see another show up in the suggestions as you start to type <kbd>numberOf</kbd> – it just works.</p>&#13;
<p>Another thing to note is compiler errors, displayed in a similar way to how Xcode does it (although more in line with your code in the editor). The following red symbol with a description of your error will be presented when running your code. Tapping on the button will collapse the error, allowing you to inspect your code in a little more detail:</p>&#13;
<div><img src="img/9e2c5a79-418d-401c-874d-707eb8dc6ed0.jpeg" style="" width="816" height="198"/></div>&#13;
<p>Figure 7.22 – Error inspection</p>&#13;
<p>Alternatively, if you have a number of errors, then you can simply click on the red icon to the left of the + icon in the menu bar to display a list of current errors:</p>&#13;
<div><img src="img/4dc3ee08-c202-44a4-afea-d96bccf41625.jpeg" style="" width="720" height="455"/></div>&#13;
<p>Figure 7.23 – Error indicator</p>&#13;
<p>With this in mind, the compiler may not always give you errors and you may be forced to "step through" your code in order to find out what exactly is going on in your logic. If we refer back to the <em>How to do it... </em>section, you'll remember that we needed to add the following line of code to make our function work:</p>&#13;
<pre>PlaygroundPage.current.needsIndefiniteExecution = true</pre>&#13;
<p>This was due to our playground finishing its execution before our API had returned the call. Let's comment this out for the moment and run our code and you will notice that it never displays our list of quotes, but we want to see what is happening.</p>&#13;
<p>To the left of the Run My Code button is a timer icon. Tap on this to see the following options:</p>&#13;
<div><img src="img/5c61087e-06f9-4c53-8261-6ebd7ec40d27.png" style="" width="591" height="640"/></div>&#13;
<p>Figure 7.24 – Running my code options</p>&#13;
<p><strong>Run My Code</strong> is highlighted by default, but two additional options exist – <strong>Step Through My Code</strong> and <strong>Step Slowly</strong>. What these do (essentially the same thing, although one does it more slowly than the other) is highlight each line of code as it is executed, or intended to be executed, allowing you to follow and check any potential logic issues. For those who are already familiar with Xcode's IDE, this is common practice for debugging.</p>&#13;
<p>Tap on one of these two options with the preceding code commented out and you'll see that our code never finishes (because the main, synchronous function finished before the completion handler fired). If you try this a few times, you'll notice that it does occasionally stop at different points inside the completion. Uncomment the line and watch it step through right to the end.</p>&#13;
<p>Another thing to note is the object menu to the top right. Pressing on the plus button provides a plethora of code snippets to choose from, while you can also import images into an asset like a catalog, allowing you to reference image literals just like you can in Xcode:</p>&#13;
<div><img src="img/d13fa924-6cdd-48a8-afd6-9f150121f4a4.jpeg" style="" width="748" height="1312"/></div>&#13;
<p>Figure 7.25 – Layout result</p>&#13;
<p class="mce-root">Finally, I'd like to touch on the file inspector again over on the left-hand side. If you open this up again, you'll see an Edit button, which, in turn, does what it says on the tin. It lets you edit, rename, and re-order Swift files for your project and module.</p>&#13;
<p>As mentioned earlier in this recipe, Swift Playgrounds is designed for both iPadOS and macOS, with both working in identical ways, and you should be able to follow this recipe perfectly on both (hint, I wrote half of this recipe on the iPad and the other on the Mac version just to test it out!).</p>&#13;
<h2 id="uuid-6f02dcf3-41d8-4d17-8b05-cc349062a64e">There's more</h2>&#13;
<p>One final section worth going over is the Tools section. Click on the three dots to the right of the <strong>+</strong> icon in the top-right corner. You should now be presented with the following:</p>&#13;
<div><img src="img/3b1ec6b2-f46b-46b3-bccf-f89daa373fa9.jpeg" style="" width="667" height="1251"/></div>&#13;
<p>Figure 7.26 – Playground options</p>&#13;
<p>We will go through each of these individually or collectively:</p>&#13;
<ul>&#13;
<li><strong>Playgrounds Help / Documentation</strong></li>&#13;
</ul>&#13;
<p style="padding-left: 60px" class="mce-root">As you would expect, Help is focused around the App/IDE and interface giving you an overview of what is available, while Documentation is Apple-specific API documentation.</p>&#13;
<ul>&#13;
<li><strong>Take Picture / Create PDF</strong></li>&#13;
</ul>&#13;
<p style="padding-left: 60px">These options share a screenshot or PDF of the canvas in its current state. Other standard iPadOS sharing options are also available.</p>&#13;
<ul>&#13;
<li><strong>Record Movie / Broadcast Live</strong></li>&#13;
</ul>&#13;
<p style="padding-left: 60px">Record Movie starts a "screen recorder"-like scenario with stop and record controls that appear at the top of your screen. Broadcasting alternatively hooks into third-party apps that can be found on the Apple App Store that support broadcasting.</p>&#13;
<ul>&#13;
<li><strong>Share / Advanced</strong></li>&#13;
</ul>&#13;
<p style="padding-left: 60px">Share initiates the default iPadOS share sheet for the option to share your current playbook.</p>&#13;
<p style="padding-left: 60px">Advanced gives you two options, one to export your playbook, and the second to take a more in-depth look at your current playbook's hierarchy. </p>&#13;
<ul>&#13;
<li><strong>License agreements</strong></li>&#13;
</ul>&#13;
<p style="padding-left: 60px">This is nothing to write home about, just your usual software license agreement information.</p>&#13;
<h2 id="uuid-a81ee347-1df3-4abc-b390-06b34c04723a">See also</h2>&#13;
<p><strong>Apple's Swift Playgrounds page</strong>: <a href="https://www.apple.com/swift/playgrounds/">https://www.apple.com/swift/playgrounds/</a></p>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>