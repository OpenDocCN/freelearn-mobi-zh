- en: Chapter 3. Creating an iOS Swift App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the release of Xcode 6 in 2014, it has been possible to build Swift applications
    for iOS and OS X and submit them to the App Store for publication. This chapter
    will present both a single view application and a master-detail application, and
    use these to explain the concepts behind iOS applications, as well as introduce
    classes in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How iOS applications are structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-view iOS applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating classes in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols and enums in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `XCTest` to test Swift code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master-detail iOS applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AppDelegate` and `ViewController` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding iOS applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iOS application is a compiled executable along with a set of supporting files
    in a bundle. The application bundle is packaged into an archive file to be installed
    onto a device or upload to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xcode can be used to run iOS applications in a simulator, as well as testing
    them on a local device. Submitting an application to the App Store requires a
    developer signing key, which is included as part of the Apple Developer Program
    at [https://developer.apple.com](https://developer.apple.com).
  prefs: []
  type: TYPE_NORMAL
- en: Most iOS applications to date have been written in Objective-C, a crossover
    between C and Smalltalk. With the advent of Swift, it is likely that many developers
    will move at least parts of their applications to Swift for performance and maintenance
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Objective-C is likely to be around for a while, it is clear that Swift
    is the future of iOS development and probably OS X as well. Applications contain
    a number of different types of files, which are used both at compile time and
    also at runtime. These files include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Info.plist` file, which contains information about which languages the
    application is localized for, what the identity of the application is, and the
    configuration requirements, such as the supported interface types (iPad, iPhone,
    and Universal), and orientations (Portrait, Upside Down, Landscape Left, and Landscape
    Right)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *interface builder* files with a `.xib` extension, which contain
    user interface screens (which supersedes the previous `.nib` files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *image asset* files with a `.xcassets` extension, which store groups
    of related icons at different sizes, such as the application icon or graphics
    for display on screen (which supersedes the previous `.icns` files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more *storyboard* files with a `.storyboard` extension, which are used
    to coordinate between different screens in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more `.swift` files that contain application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a single-view iOS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single-view iOS application is one where the application is presented in a
    single screen, without any transitions or other views. This section will show
    how to create an application that uses a single view without storyboards. (Storyboards
    are covered in [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*.)
  prefs: []
  type: TYPE_NORMAL
- en: When Xcode starts, it displays a welcome message that includes the ability to
    create a new project. This welcome message can be redisplayed at any time by navigating
    to **Window** | **Welcome to Xcode** or by pressing *Command* + *Shift* + *1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the welcome dialog''s **Create a new Xcode project** option, or navigating
    to **File** | **New** | **Project...**, or by pressing *Command* + *Shift* + *N*,
    create a new **iOS** project with **Single View Application** as the template,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a single-view iOS application](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the **Next** button is pressed, the new project dialog will ask for more
    details. The product name here is `SingleView` with appropriate values for **Organization
    Name** and **Identifier**. Ensure that the language selected is **Swift** and
    the device type is **Universal**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a single-view iOS application](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Organization Identifier** is a reverse domain name representation of the
    organization, and the **Bundle Identifier** is the concatenation of the **Organization
    Identifier** with the **Product Name**. Publishing to the App Store requires that
    the **Organization Identifier** be owned by the publisher and is managed in the
    online developer center at [https://developer.apple.com/membercenter/](https://developer.apple.com/membercenter/).
  prefs: []
  type: TYPE_NORMAL
- en: When **Next** is pressed, Xcode will ask where to save the project and whether
    a repository should be created. The selected location will be used to create the
    product directory, and an option to create a Git repository will be offered.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2014, Git became the most widely used version control system, surpassing
    all other distributed and centralized version control systems. It would be foolish
    not to create a Git repository when creating a new Xcode project.
  prefs: []
  type: TYPE_NORMAL
- en: When **Create** is pressed, Xcode will create the project, set up template files,
    and then initialize the Git repository locally or on a shared server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the triangular play button at the top-left of Xcode to launch the simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a single-view iOS application](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If everything has been set up correctly, the simulator will start with a white
    screen and the time and battery shown at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a single-view iOS application](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Removing the storyboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default template for a single-view application includes a *storyboard*.
    This creates the view for the first (only) screen and performs some additional
    setup behind the scenes. To understand what happens, the storyboard will be removed
    and replaced with code instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most applications are built with one or more storyboards. It is being removed
    here for demonstration purposes only; refer to the [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*, for more information on how to use storyboards.
  prefs: []
  type: TYPE_NORMAL
- en: The storyboard can be deleted by going to the project navigator, finding the
    `Main.storyboard` file, and pressing the *Delete* key or selecting **Delete**
    from the context-sensitive menu. When the confirmation dialog is shown, select
    the **Move to Trash** option to ensure that the file is deleted rather than just
    being removed from the list of files that Xcode knows about.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the project navigator, press *Command* + *1* or navigate to **View**
    | **Navigators** | **Show Project Navigator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Main.storyboard` file has been deleted, it needs to be removed from
    `Info.plist`, to prevent iOS from trying to open it at startup. Open the `Info.plist`
    file under the `Supporting` `Files` folder of `SingleView`. A set of key-value
    pairs will be displayed; clicking on the **Main storyboard file base name** row
    will present the (**+**) and (**-**) options. Clicking on the delete icon (**-**)
    will remove the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the storyboard](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now when the application is started, a black screen will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple `Info.plist` files that are created by Xcode's template;
    one file is used for the real application, while the other files are used for
    the test applications that get built when running tests. Testing is covered in
    the *Subclasses and testing in Swift* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the view controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *view controller* is responsible for setting up the view when it is activated.
    Typically, this is done through either the storyboard or the interface file. As
    these have been removed, the window and the view controller need to be instantiated
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: When iOS applications start, `application:didFinishLaunchingWithOptions:` is
    called on the corresponding `UIApplicationDelegate`. The optional `window` variable
    is initialized automatically when it is loaded from an interface file or a storyboard,
    but it needs to be explicitly initialized if the user interface is being implemented
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `application:didFinishLaunchingWithOptions:` method in the `AppDelegate`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To open a class by name, press *Command* + *Shift* + *O* and type in the class
    name. Alternatively, navigate to **File** | **Open Quickly...**
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to create the view''s content, which is typically done in
    the `viewDidLoad` method of the `ViewController` class. As an example user interface,
    a `UILabel` will be created and added to the view. Each view controller has an
    associated `view` property, and child views can be added with the `addSubview`
    method. To make the view stand out, the background of the view will be changed
    to black and the text color will be changed to white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates a label, which is sized to the full size of the screen, with a
    white text color and a centered text alignment. When run, this displays **Welcome
    to Swift** on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, views will be implemented in their own class rather than being in-lined
    into the view controller. This allows the views to be reused in other controllers.
    This technique will be demonstrated in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When the screen is rotated, the label will be rotated off screen. Logic would
    need to be added in a real application to handle rotation changes in the view
    controller, such as `willRotateToInterfaceOrientation`, and to appropriately add
    rotations to the views using the `transform` property of the view. Usually, an
    interface builder file or storyboard would be used so that this is handled automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Swift classes, protocols, and enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all Swift applications will be object oriented. [Chapter 1](part0016_split_000.html#F8901-d7e55eb5242648e89c396442afe4f84b
    "Chapter 1. Exploring Swift"), *Exploring Swift*, and [Chapter 2](part0023_split_000.html#LTSU2-d7e55eb5242648e89c396442afe4f84b
    "Chapter 2. Playing with Swift"), *Playing with Swift*, both demonstrated functional
    and procedural Swift code. Classes, such as `Process` from the `CoreFoundation`
    framework, and `UIColor` and `UIImage` from the `UIKit` framework, were used to
    demonstrate how classes can be used in applications. This section describes how
    to create classes, protocols, and enums in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Classes in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is created in Swift using the `class` keyword, and braces are used to
    enclose the class body. The body can contain variables called *properties*, as
    well as functions called *methods*, which are collectively referred to as *members*.
    Instance members are unique to each instance, while static members are shared
    between all instances of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes are typically defined in a file named for the class; so a `GitHubRepository`
    class would typically be defined in a `GitHubRepository.swift` file. A new Swift
    file can be created by navigating to **File** | **New** | **File…** and selecting
    the **Swift File** option under **iOS**. Ensure that it is added to the **Tests**
    and **UITests** targets as well. Once created, implement the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class can be instantiated and used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to create static members, which are the same for all instances
    of a class. In the `GitHubRepository` class, the `api` URL is likely to remain
    the same for all invocations, so it can be refactored into a `static` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the `api` URL needs to be changed (for example, to support mock testing
    or to support an in-house GitHub Enterprise server), there is a single place to
    change it. Before Swift 2, a **class variables are not yet supported** error message
    may be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use static variables in Swift prior to version 2, a different approach must
    be used. It is possible to define *computed properties*, which are not stored
    but are calculated on demand. These have a *getter* (also known as an *accessor*)
    and optionally a *setter* (also known as a *mutator*). The previous example can
    be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although this is logically a read-only constant (there is no associated `set`
    block), it is not possible to define the `let` constants with accessors.
  prefs: []
  type: TYPE_NORMAL
- en: To refer to a class variable, use the type name—which in this case is `GitHubRepository`.
    When the `GitHubRepository.api` expression is evaluated, the body of the getter
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses and testing in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple Swift class with no explicit parent is known as a *base class*. However,
    classes in Swift frequently *inherit* from another class by specifying a superclass
    after the class name. The syntax for this is `class` `SubClass:SuperClass{...}`.
  prefs: []
  type: TYPE_NORMAL
- en: Tests in Swift are written using the **XCTest** framework, which is included
    by default in Xcode templates. This allows an application to have tests written
    and then executed in place to confirm that no bugs have been introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XCTest replaces the previous testing framework OCUnit.
  prefs: []
  type: TYPE_NORMAL
- en: The `XCTest` framework has a base class called `XCTestCase` that all tests inherit
    from. Methods beginning with `test` (and that take no arguments) in the test case
    class are invoked automatically when the tests are run. Test code can indicate
    success or failure by calling the `XCTAssert*` functions, such as `XCTAssertEquals`
    and `XCTAssertGreaterThan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests for the `GitHubRepository` class conventionally exist in a corresponding
    `GitHubRepositoryTest` class, which will be a subclass of `XCTestCase`. Create
    a new Swift file by navigating to **File | New | File...** and choosing a **Swift
    File** under the **Source** category for **iOS**. Ensure that the **Tests** and
    **UITests** targets are selected but the application target is not. It can be
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the `GitHubRepositoryTest` class is added to the test targets.
    If not added when the file is created, it can be done by selecting the file and
    pressing *Command* + *Option* + *1* to show the **File Inspector**. The checkbox
    next to the test target should be selected. Tests should never be added to the
    main target. The `GitHubRepository` class should be added to both test targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subclasses and testing in Swift](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the tests are run by pressing *Command* + *U* or by navigating to **Product**
    | **Test**, the results of the test will be displayed. Changing either the implementation
    or the expected test result will demonstrate whether the test is being executed
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check whether a failing test causes the build to fail; this will confirm
    that the test is actually being run. For example, in the `GitHubRepositoryTest`
    class, modify the URL to remove `https` from the front and check whether a test
    failure is shown. There is nothing more useless than a correctly implemented test
    that never runs.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **protocol** is similar to an interface in other languages; it is a named
    type that has method signatures but no method implementations. Classes can implement
    zero or more protocols; when they do, they are said to **adopt** or **conform**
    to the protocol. A protocol may have a number of methods that are either **required**
    (the default) or **optional** (marked with the `optional` keyword).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optional protocol methods are only supported when the protocol is marked with
    the `@objc` attribute. This declares that the class will be backed by an `NSObject`
    class for interoperability with Objective-C. Pure Swift protocols cannot have
    optional methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to define a protocol looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocols cannot have functions with default arguments. Protocols can be used
    with the `struct`, `class`, and `enum` types unless the `@objc` class attribute
    is used; in which case, they can only be used against Objective-C classes or enums.
  prefs: []
  type: TYPE_NORMAL
- en: Classes conform to protocols by listing the protocol names after the class name,
    similar to a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a class has both a superclass and one or more protocols, the superclass
    must be listed first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `GitHubDetails` protocol can be used as a type in the same places as an
    existing Swift type, such as a variable type, method return type, or argument
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocols are widely used in Swift to allow callbacks from frameworks that would,
    otherwise, not know about specific callback handlers. If a superclass was required
    instead, then a single class cannot be used to implement multiple callbacks. Common
    protocols include `UIApplicationDelegate`, `Printable`, and `Comparable`.
  prefs: []
  type: TYPE_NORMAL
- en: Enums in Swift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final concept to understand in Swift is *enumeration*, or *enum* for short.
    An enum is a closed set of values, such as `North`, `East`, `South`, and `West`,
    or `Up`, and `Down`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An enumeration is defined using the `enum` keyword, followed by a type name,
    and a block, which contains the `case` keywords followed by comma-separated values
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike C, enumerated values do not have a specific type by default, so they
    cannot generally be converted to and from an integer value. Enumerations can be
    defined with **raw values** that allow conversion to and from integer values.
    Enum values are assigned to variables using the type name and the `enum` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the type of the expression is known, then the type prefix does
    not need to be explicitly specified; the following form is much more common in
    Swift code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Raw values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the `enum` values that have specific meanings, it is possible to extend
    the `enum` from a different type, such as `Int`. These are known as *raw values*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A raw value enum can be converted to and from its raw value with the `rawValue`
    property and the failable initializer `Rank(rawValue:)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The failable initializer returns an optional `enum` value, because the equivalent
    `Rank` may not exist. The expression `Rank(rawValue:0)` will return `nil`, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Associated values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enums can also have *associated values*, such as a value or case class in other
    languages. For example, a combination of a `Suit` and a `Rank` can be combined
    to form a `Card`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instances can be created by passing values into an `enum` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated values of an `enum` instance cannot be extracted (as they can
    with properties of a `struct`), but the `enum` value can be accessed by pattern
    matching in a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Swift compiler will require that the `switch` statement be exhaustive. As
    the `enum` only contains these two types, no `default` block is needed. If another
    `enum` value is added to `Card` in the future, the compiler will report an error
    in this `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a master-detail iOS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having covered how classes, protocols, and enums are defined in Swift, a more
    complex master-detail application can be created. A master-detail application
    is a specific type of iOS application that initially presents a master table view,
    and when an individual element is selected, a secondary details view will show
    more information about the selected item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Create a new Xcode project** option from the welcome screen, or
    by navigating to **File** | **New** | **Project…** or by pressing *Command* +
    *Shift* + *N*, create a new project and select **Master-Detail Application** from
    the **iOS Application** category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the subsequent dialog, enter appropriate values for the project, such as
    the name (`MasterDetail`), the organization identifier (typically based on the
    reverse DNS name), ensure that the **Language** dropdown reads **Swift** and that
    it is targeted for **Universal** devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the project is created, an Xcode window will open containing all the files
    that are created by the wizard itself, including the `MasterDetail.app` and `MasterDetailTests.xctest`
    products. The `MasterDetail.app` is a bundle that is executed by the simulator
    or a connected device, while the `MasterDetailTests.xctest` and `MasterDetailsUITests.xctest`
    products are used to execute unit tests for the application's code.
  prefs: []
  type: TYPE_NORMAL
- en: The application can be launched by pressing the triangular play button on the
    top-left corner of Xcode or by pressing *Command* + *R*, which will run the application
    against the currently selected target.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After a brief compile and build cycle, the iOS Simulator will open with a master
    page that contains an empty table, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The default `MasterDetail` application can be used to add items to the list
    by clicking on the add (**+**) button on the top-right corner of the screen. This
    will add a new timestamped entry to the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When this item is clicked, the screen will switch to the details view, which,
    in this case, presents the time in the center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master-detail iOS application](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This kind of master-detail application is common in iOS applications for displaying
    a top-level list (such as a shopping list, a set of contacts, to-do notes, and
    so on) while allowing the user to tap to see the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main classes in the master-detail application:'
  prefs: []
  type: TYPE_NORMAL
- en: The `AppDelegate` class is defined in the `AppDelegate.swift` file, and it is
    responsible for starting the application and set up the initial state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MasterViewController` class is defined in the `MasterViewController.swift`
    file, and it is used to manage the first (master) screen's content and interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DetailViewController` class is defined in the `DetailViewController.swift`
    file, and it is used to manage the second (detail) screen's content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to understand what the classes do in more detail, the next three sections
    will present each of them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code that is generated in this section was created from Xcode 7.0, so the
    templates might differ slightly if using a different version of Xcode. An exact
    copy of the corresponding code can be acquired from the Packt website or from
    this book's GitHub repository at [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/).
  prefs: []
  type: TYPE_NORMAL
- en: The AppDelegate class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppDelegate` class is the main entry point to the application. When a set
    of Swift source files are compiled, if the `main.swift` file exists, it is used
    as the entry point for the application by running that code. However, to simplify
    setting up an application for iOS, a `@UIApplicationMain` special attribute exists
    that will both synthesize the `main` method and set up the associated class as
    the application delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppDelegate` class for iOS extends the `UIResponder` class, which is the
    parent of all the UI content on iOS. It also adopts two protocols, `UIApplicationDelegate`,
    and `UISplitViewControllerDelegate`, which are used to provide callbacks when
    certain events occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On OS X, the `AppDelegate` class will be a subclass of `NSApplication` and will
    adopt the `NSApplicationDelegate` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The synthesized `main` function calls the `UIApplicationMain` method that reads
    the `Info.plist` file. If the `UILaunchStoryboardName` key exists and points to
    a suitable file (the `LaunchScreen.xib` interface file in this case), it will
    be shown as a splash screen before doing any further work. After the rest of the
    application has loaded, if the `UIMainStoryboardFile` key exists and points to
    a suitable file (the `Main.storyboard` file in this case), the storyboard is launched
    and the initial view controller is shown.
  prefs: []
  type: TYPE_NORMAL
- en: The storyboard has references to the `MasterViewController` and `DetailViewController`
    classes. The `window` variable is assigned to the storyboard's window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `application:didFinishLaunchingWithOptions` is called once the application
    has started. It is passed with a reference to the `UIApplication` instance and
    a dictionary of options that notifies how the application has been started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the sample `MasterDetail` application, the `application:didFinishLaunchingWithOptions`
    method acquires a reference to the `splitViewController` from the explicitly unwrapped
    optional `window`, and the `AppDelegate` is set as its delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `… as! UISplitViewController` syntax performs a type cast so that the generic
    `rootViewController` can be assigned to the more specific type; in this case,
    `UISplitViewController`. An alternative version `as?` provides a runtime checked
    cast, and it returns an optional value that either contains the value with the
    correctly casted type or `nil` otherwise. The difference with `as!` is a runtime
    error will occur if the item is not of the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a `navigationController` is acquired from the `splitViewController`,
    which stores an array of `viewControllers`. This allows the `DetailView` to display
    a button on the left-hand side to expand the details view if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only difference this makes is when running on a wide-screen device, such
    as an iPhone 6 Plus or an iPad, where the views are displayed side-by-side in
    landscape mode. This is a new feature in iOS 8 applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AppDelegate class](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, when the device is in portrait mode, it will be rendered as a standard
    back button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AppDelegate class](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The method concludes with `return` `true` to let the OS know that the application
    has opened successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The MasterViewController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MasterViewController` class is responsible for coordinating the data that
    is shown on the first screen (when the device is in portrait orientation) or the
    left-half of the screen (when a large device is in landscape orientation). This
    is rendered with a `UITableView`, and data is coordinated through the parent `UITableViewController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `viewDidLoad` method is used to set up or initialize the view after it
    has loaded. In this case, a `UIBarButtonItem` is created so that the user can
    add new entries to the table. The `UIBarButtonItem` takes a `@selector` in Objective-C,
    and in Swift is treated as a string literal convertible (so that `"insertNewObject:"`
    will result in a call to the `insertNewObject` method). Once created, the button
    is added to the navigation on the right-hand side, using the standard `.Add` type
    which will be rendered as a **+** sign on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects are `NSDate` values, and are stored inside the class as an Array
    of `AnyObject` elements. The `insertNewObject` method is called when the **+**
    button is pressed, and it creates a new `NSDate` instance which is then inserted
    into the array. The `sender` event is passed as an argument of the `AnyObject`
    type, which will be a reference to the `UIBarButtonItem` (although it is not needed
    or used here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UIBarButtonItem` class was created before blocks were available on iOS
    devices, so it uses the older Objective-C `@selector` mechanism. A future release
    of iOS may provide an alternative that takes a block, in which case Swift functions
    can be passed instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent class contains a reference to the `tableView`, which is automatically
    created by the storyboard. When an item is inserted, the `tableView` is notified
    that a new object is available. Standard `UITableViewController` methods are used
    to access the data from the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `numberOfSectionsInTableView` function returns `1` in this case, but a `tableView`
    can have multiple sections; for example, to permit a contacts application having
    a different section for A, B, C through Z. The `numberOfRowsInSection` method
    returns the number of elements in each section; in this case, as there is only
    one section, the number of objects in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why each method is called `tableView` and takes a `tableView` argument
    is a result of the Objective-C heritage of UIKit. The Objective-C convention combined
    the method name as the first named argument, so the original method was `[delegate`
    `tableView:UITableView,` `numberOfRowsInSection:NSInteger]`. As a result, the
    name of the first argument is reused as the name of the method in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The `cellForRowAtIndexPath` method is expected to return `UITableViewCell` for
    an object. In this case, a cell is acquired from the `tableView` using the `dequeueReusableCellWithIdentifier`
    method (which caches cells as they go off screen to save object instantiation),
    and then the `textLabel` is populated with the object's `description` (which is
    a `String` representation of the object; in this case, the date).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough to display elements in the table, but in order to permit editing
    (or just removal, as in the sample application), there are some additional protocol
    methods that are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `canEditRowAtIndexPath` method returns `true` if the row is editable; if
    all the rows can be edited, then this will return `true` for all the values.
  prefs: []
  type: TYPE_NORMAL
- en: The `commitEditingStyle` method takes a table, a path, and a style, which is
    an enumeration that indicates which operation occurred. In this case, `UITableViewCellEditingStyle.Delete`
    is passed in order to delete the item from both the underlying object array and
    also from the `tableView`. (The enumeration can be abbreviated to `.Delete` because
    the type of `editingStyle` is known to be `UITableViewCellEditingStyle`.)
  prefs: []
  type: TYPE_NORMAL
- en: The DetailViewController class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The detail view is shown when an element is selected in the `MasterViewController`.
    The transition is managed by the storyboard controller; the views are connected
    with a *segue* (pronounced *seg-way*; the product of the same name based it on
    the word *segue* which is derived from the Italian word for *follows*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass the selected item between controllers, a property exists in the `DetailViewController`
    class called `detailItem`. When the value is changed, additional code is run,
    which is implemented in a `didSet` property notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When `DetailViewController` has the `detailItem` set, the `configureView` method
    will be invoked. The `didSet` body is run after the value has been changed, but
    before the setter returns to the caller. This is triggered by the `segue` in the
    `MasterViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `prepareForSegue` method is called when the user selects an item in the
    table. In this case, it grabs the selected row index from the table and uses this
    to acquire the selected date object. The navigation controller hierarchy is searched
    to acquire the `DetailViewController`, and once this has been obtained, the selected
    value is set with `controller.detailItem` `=` `object`, which triggers the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The label is ultimately displayed in the `DetailViewController` through the
    `configureView` method, which stamps the `description` of the object onto the
    `label` in the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `configureView` method is called both when the `detailItem` is changed and
    when the view is loaded for the first time. If the `detailItem` has not been set,
    then this has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation introduces some new concepts, which are worth highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@IBOutlet` attribute indicates that the property will be exposed in interface
    builder and can be wired up to the object instance. This will be covered in more
    detail in [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*, and in [Chapter 5](part0039_split_000.html#1565U1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 5. Creating Custom Views in Swift"), *Creating Custom Views in Swift*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `weak` attribute indicates that the property will not store a *strong* reference
    to the object; in other words, the detail view will not own the object but merely
    reference it. Generally, all `@IBOutlet` references should be declared as `weak`
    to avoid cyclic dependency references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type is defined as `UILabel!` which is an *implicitly unwrapped optional*.
    When accessed, it performs an explicit unwrapping of the optional value; otherwise
    the `@IBOutlet` will be wired up as a `UILabel?` optional type. Implicitly unwrapped
    optional types are used when the variable is known to never be `nil` at runtime,
    which is usually the case for the `@IBOutlet` references. Generally, all `@IBOutlet`
    references should be implicitly unwrapped optionals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented two sample iOS applications; one in which the UI was
    created programmatically, and another in which the UI was loaded from a storyboard.
    Together with an overview of classes, protocols, and enums, and an explanation
    of how iOS applications start, this chapter gives a springboard to understand
    the Xcode templates that are frequently used to start new projects.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter, *Storyboard Applications with Swift and iOS*, will go into
    more detail about how storyboards are created and how an application can be built
    from scratch.
  prefs: []
  type: TYPE_NORMAL
