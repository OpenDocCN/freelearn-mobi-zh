- en: Chapter 3. Creating an iOS Swift App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。创建 iOS Swift 应用程序
- en: After the release of Xcode 6 in 2014, it has been possible to build Swift applications
    for iOS and OS X and submit them to the App Store for publication. This chapter
    will present both a single view application and a master-detail application, and
    use these to explain the concepts behind iOS applications, as well as introduce
    classes in Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年发布 Xcode 6 之后，已经可以构建适用于 iOS 和 OS X 的 Swift 应用程序，并将它们提交到 App Store 进行发布。本章将介绍单视图应用程序和主从视图应用程序，并使用这些应用程序来解释
    iOS 应用程序背后的概念，以及介绍 Swift 中的类。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: How iOS applications are structured
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 应用程序的架构
- en: Single-view iOS applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单视图 iOS 应用程序
- en: Creating classes in Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Swift 中创建类
- en: Protocols and enums in Swift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中的协议和枚举
- en: Using `XCTest` to test Swift code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `XCTest` 测试 Swift 代码
- en: Master-detail iOS applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主从视图 iOS 应用程序
- en: The `AppDelegate` and `ViewController` classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDelegate` 和 `ViewController` 类'
- en: Understanding iOS applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 iOS 应用程序
- en: An iOS application is a compiled executable along with a set of supporting files
    in a bundle. The application bundle is packaged into an archive file to be installed
    onto a device or upload to the App Store.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用程序是一个编译后的可执行文件，以及一个包含在包中的支持文件集。应用程序包被打包成一个存档文件，用于安装到设备或上传到 App Store。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Xcode can be used to run iOS applications in a simulator, as well as testing
    them on a local device. Submitting an application to the App Store requires a
    developer signing key, which is included as part of the Apple Developer Program
    at [https://developer.apple.com](https://developer.apple.com).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 可以用于在模拟器中运行 iOS 应用程序，以及在本地设备上进行测试。将应用程序提交到 App Store 需要一个开发者签名密钥，该密钥包含在
    Apple 开发者计划中，请访问 [https://developer.apple.com](https://developer.apple.com)。
- en: Most iOS applications to date have been written in Objective-C, a crossover
    between C and Smalltalk. With the advent of Swift, it is likely that many developers
    will move at least parts of their applications to Swift for performance and maintenance
    reasons.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数 iOS 应用程序都是用 Objective-C 编写的，它是 C 和 Smalltalk 的交叉语言。随着 Swift 的出现，许多开发者可能会将他们应用程序的至少部分迁移到
    Swift，以实现性能和维护。
- en: 'Although Objective-C is likely to be around for a while, it is clear that Swift
    is the future of iOS development and probably OS X as well. Applications contain
    a number of different types of files, which are used both at compile time and
    also at runtime. These files include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Objective-C可能会存在一段时间，但很明显，Swift 是 iOS 开发的未来，也许也是 OS X 的未来。应用程序包含多种不同类型的文件，这些文件在编译时和运行时都会使用。这些文件包括以下内容：
- en: The `Info.plist` file, which contains information about which languages the
    application is localized for, what the identity of the application is, and the
    configuration requirements, such as the supported interface types (iPad, iPhone,
    and Universal), and orientations (Portrait, Upside Down, Landscape Left, and Landscape
    Right)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Info.plist` 文件，其中包含有关应用程序本地化语言的信息，应用程序的身份，以及配置要求，例如支持的界面类型（iPad、iPhone 和通用），以及方向（纵向、颠倒、横屏左和横屏右）'
- en: Zero or more *interface builder* files with a `.xib` extension, which contain
    user interface screens (which supersedes the previous `.nib` files)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个扩展名为 `.xib` 的 *界面构建器* 文件，这些文件包含用户界面屏幕（这取代了之前的 `.nib` 文件）
- en: Zero or more *image asset* files with a `.xcassets` extension, which store groups
    of related icons at different sizes, such as the application icon or graphics
    for display on screen (which supersedes the previous `.icns` files)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个扩展名为 `.xcassets` 的 *图像资源* 文件，这些文件存储不同尺寸的相关图标组，例如应用程序图标或用于屏幕显示的图形（这取代了之前的
    `.icns` 文件）
- en: Zero or more *storyboard* files with a `.storyboard` extension, which are used
    to coordinate between different screens in an application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个扩展名为 `.storyboard` 的 *故事板* 文件，这些文件用于协调应用程序中不同的屏幕
- en: One or more `.swift` files that contain application code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个包含应用程序代码的 `.swift` 文件
- en: Creating a single-view iOS application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单视图 iOS 应用程序
- en: A single-view iOS application is one where the application is presented in a
    single screen, without any transitions or other views. This section will show
    how to create an application that uses a single view without storyboards. (Storyboards
    are covered in [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单视图iOS应用程序是指应用程序在一个屏幕上展示，没有任何过渡或其他视图。本节将展示如何创建一个不使用故事板的单视图应用程序。（关于使用Swift和iOS的故事板应用程序，请参阅[第4章](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "第4章。使用Swift和iOS的故事板应用程序")，*使用Swift和iOS的故事板应用程序*。）
- en: When Xcode starts, it displays a welcome message that includes the ability to
    create a new project. This welcome message can be redisplayed at any time by navigating
    to **Window** | **Welcome to Xcode** or by pressing *Command* + *Shift* + *1*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当Xcode启动时，它显示一个包含创建新项目能力的欢迎信息。此欢迎信息可以通过导航到**窗口** | **欢迎使用Xcode**或通过按*Command*
    + *Shift* + *1*在任何时候重新显示。
- en: 'Using the welcome dialog''s **Create a new Xcode project** option, or navigating
    to **File** | **New** | **Project...**, or by pressing *Command* + *Shift* + *N*,
    create a new **iOS** project with **Single View Application** as the template,
    as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欢迎对话框中的**创建一个新的Xcode项目**选项，或通过导航到**文件** | **新建** | **项目...**，或通过按*Command*
    + *Shift* + *N*，创建一个新的**iOS**项目，以**单视图应用程序**作为模板，如图所示：
- en: '![Creating a single-view iOS application](img/00023.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建单视图iOS应用程序](img/00023.jpeg)'
- en: 'When the **Next** button is pressed, the new project dialog will ask for more
    details. The product name here is `SingleView` with appropriate values for **Organization
    Name** and **Identifier**. Ensure that the language selected is **Swift** and
    the device type is **Universal**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**下一步**按钮时，新项目对话框将要求提供更多详细信息。这里的产品名称是`SingleView`，**组织名称**和**标识符**有适当的值。确保选定的语言是**Swift**，设备类型是**通用**：
- en: '![Creating a single-view iOS application](img/00024.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建单视图iOS应用程序](img/00024.jpeg)'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Organization Identifier** is a reverse domain name representation of the
    organization, and the **Bundle Identifier** is the concatenation of the **Organization
    Identifier** with the **Product Name**. Publishing to the App Store requires that
    the **Organization Identifier** be owned by the publisher and is managed in the
    online developer center at [https://developer.apple.com/membercenter/](https://developer.apple.com/membercenter/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**组织标识符**是组织的反向域名表示，**捆绑标识符**是**组织标识符**与**产品名称**的连接。发布到App Store需要**组织标识符**由发布者拥有，并在[https://developer.apple.com/membercenter/](https://developer.apple.com/membercenter/)的在线开发者中心中进行管理。'
- en: When **Next** is pressed, Xcode will ask where to save the project and whether
    a repository should be created. The selected location will be used to create the
    product directory, and an option to create a Git repository will be offered.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**下一步**按钮时，Xcode将询问项目保存的位置以及是否创建仓库。所选位置将用于创建产品目录，并将提供创建Git仓库的选项。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In 2014, Git became the most widely used version control system, surpassing
    all other distributed and centralized version control systems. It would be foolish
    not to create a Git repository when creating a new Xcode project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，Git成为了最广泛使用的版本控制系统，超过了所有其他分布式和集中式版本控制系统。在创建新的Xcode项目时不创建Git仓库是愚蠢的。
- en: When **Create** is pressed, Xcode will create the project, set up template files,
    and then initialize the Git repository locally or on a shared server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**创建**按钮时，Xcode将创建项目，设置模板文件，然后在本地上或共享服务器上初始化Git仓库。
- en: 'Press the triangular play button at the top-left of Xcode to launch the simulator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode的左上角按下三角形的播放按钮以启动模拟器：
- en: '![Creating a single-view iOS application](img/00025.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![创建单视图iOS应用程序](img/00025.jpeg)'
- en: 'If everything has been set up correctly, the simulator will start with a white
    screen and the time and battery shown at the top of the screen:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，模拟器将以白色屏幕启动，并在屏幕顶部显示时间和电池：
- en: '![Creating a single-view iOS application](img/00026.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建单视图iOS应用程序](img/00026.jpeg)'
- en: Removing the storyboard
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除故事板
- en: The default template for a single-view application includes a *storyboard*.
    This creates the view for the first (only) screen and performs some additional
    setup behind the scenes. To understand what happens, the storyboard will be removed
    and replaced with code instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单视图应用的默认模板包含一个*故事板*。这将为第一个（唯一）屏幕创建视图，并在幕后执行一些额外的设置。为了理解发生了什么，故事板将被移除，并用代码代替。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most applications are built with one or more storyboards. It is being removed
    here for demonstration purposes only; refer to the [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*, for more information on how to use storyboards.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都是使用一个或多个故事板构建的。这里移除它只是为了演示目的；有关如何使用故事板的更多信息，请参阅[第4章](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "第4章。使用Swift和iOS的故事板应用")，*使用Swift和iOS的故事板应用*。
- en: The storyboard can be deleted by going to the project navigator, finding the
    `Main.storyboard` file, and pressing the *Delete* key or selecting **Delete**
    from the context-sensitive menu. When the confirmation dialog is shown, select
    the **Move to Trash** option to ensure that the file is deleted rather than just
    being removed from the list of files that Xcode knows about.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过前往项目导航器，找到`Main.storyboard`文件，然后按*Delete*键或从上下文相关菜单中选择**Delete**来删除故事板。当显示确认对话框时，选择**Move
    to Trash**选项以确保文件被删除，而不是仅仅从Xcode所知的文件列表中移除。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To see the project navigator, press *Command* + *1* or navigate to **View**
    | **Navigators** | **Show Project Navigator**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看项目导航器，请按*Command* + *1*或导航到**View** | **Navigators** | **Show Project Navigator**。
- en: 'Once the `Main.storyboard` file has been deleted, it needs to be removed from
    `Info.plist`, to prevent iOS from trying to open it at startup. Open the `Info.plist`
    file under the `Supporting` `Files` folder of `SingleView`. A set of key-value
    pairs will be displayed; clicking on the **Main storyboard file base name** row
    will present the (**+**) and (**-**) options. Clicking on the delete icon (**-**)
    will remove the line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦删除了`Main.storyboard`文件，它需要从`Info.plist`中移除，以防止iOS在启动时尝试打开它。打开位于`SingleView`文件夹下的`Supporting`文件夹中的`Info.plist`文件。将显示一组键值对；点击**Main
    storyboard file base name**行将显示(**+**)和(**-**)选项。点击删除图标(**-**)将移除以下行：
- en: '![Removing the storyboard](img/00027.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![移除故事板](img/00027.jpeg)'
- en: Now when the application is started, a black screen will be displayed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用启动时，将显示一个黑色屏幕。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are multiple `Info.plist` files that are created by Xcode's template;
    one file is used for the real application, while the other files are used for
    the test applications that get built when running tests. Testing is covered in
    the *Subclasses and testing in Swift* section later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode模板创建了多个`Info.plist`文件；一个文件用于实际应用，而其他文件用于在运行测试时构建的测试应用。测试将在本章后面的*Swift中的子类和测试*部分中介绍。
- en: Setting up the view controller
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置视图控制器
- en: The *view controller* is responsible for setting up the view when it is activated.
    Typically, this is done through either the storyboard or the interface file. As
    these have been removed, the window and the view controller need to be instantiated
    manually.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图控制器*负责在激活时设置视图。通常，这是通过故事板或界面文件来完成的。由于这些已经被移除，因此需要手动实例化窗口和视图控制器。'
- en: When iOS applications start, `application:didFinishLaunchingWithOptions:` is
    called on the corresponding `UIApplicationDelegate`. The optional `window` variable
    is initialized automatically when it is loaded from an interface file or a storyboard,
    but it needs to be explicitly initialized if the user interface is being implemented
    in code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当iOS应用启动时，`application:didFinishLaunchingWithOptions:`会在相应的`UIApplicationDelegate`上被调用。可选的`window`变量在从界面文件或故事板加载时自动初始化，但如果用户界面是通过代码实现的，则需要显式初始化。
- en: 'Implement the `application:didFinishLaunchingWithOptions:` method in the `AppDelegate`
    class as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类中实现`application:didFinishLaunchingWithOptions:`方法如下：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To open a class by name, press *Command* + *Shift* + *O* and type in the class
    name. Alternatively, navigate to **File** | **Open Quickly...**
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要按名称打开一个类，请按*Command* + *Shift* + *O*并输入类名。或者，导航到**File** | **Open Quickly...**
- en: 'The final step is to create the view''s content, which is typically done in
    the `viewDidLoad` method of the `ViewController` class. As an example user interface,
    a `UILabel` will be created and added to the view. Each view controller has an
    associated `view` property, and child views can be added with the `addSubview`
    method. To make the view stand out, the background of the view will be changed
    to black and the text color will be changed to white:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建视图的内容，这通常在`ViewController`类的`viewDidLoad`方法中完成。作为一个示例用户界面，将创建并添加一个`UILabel`到视图中。每个视图控制器都有一个关联的`view`属性，可以通过`addSubview`方法添加子视图。为了使视图突出，将视图的背景改为黑色，并将文字颜色改为白色：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates a label, which is sized to the full size of the screen, with a
    white text color and a centered text alignment. When run, this displays **Welcome
    to Swift** on the screen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个标签，其大小为整个屏幕的大小，文字颜色为白色，文字对齐方式为居中。运行时，屏幕上会显示**欢迎使用Swift**。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Typically, views will be implemented in their own class rather than being in-lined
    into the view controller. This allows the views to be reused in other controllers.
    This technique will be demonstrated in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，视图将在它们自己的类中实现，而不是直接内联到视图控制器中。这允许视图在其他控制器中重用。这种技术将在下一章中演示。
- en: When the screen is rotated, the label will be rotated off screen. Logic would
    need to be added in a real application to handle rotation changes in the view
    controller, such as `willRotateToInterfaceOrientation`, and to appropriately add
    rotations to the views using the `transform` property of the view. Usually, an
    interface builder file or storyboard would be used so that this is handled automatically.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕旋转时，标签将旋转出屏幕。在实际应用中，需要添加逻辑来处理视图控制器中的旋转变化，例如`willRotateToInterfaceOrientation`，并使用视图的`transform`属性适当地添加旋转。通常，会使用界面构建器文件或故事板来自动处理这一点。
- en: Swift classes, protocols, and enums
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift类、协议和枚举
- en: Almost all Swift applications will be object oriented. [Chapter 1](part0016_split_000.html#F8901-d7e55eb5242648e89c396442afe4f84b
    "Chapter 1. Exploring Swift"), *Exploring Swift*, and [Chapter 2](part0023_split_000.html#LTSU2-d7e55eb5242648e89c396442afe4f84b
    "Chapter 2. Playing with Swift"), *Playing with Swift*, both demonstrated functional
    and procedural Swift code. Classes, such as `Process` from the `CoreFoundation`
    framework, and `UIColor` and `UIImage` from the `UIKit` framework, were used to
    demonstrate how classes can be used in applications. This section describes how
    to create classes, protocols, and enums in Swift.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Swift应用程序都将面向对象。[第1章](part0016_split_000.html#F8901-d7e55eb5242648e89c396442afe4f84b
    "第1章。探索Swift")，*探索Swift*，以及[第2章](part0023_split_000.html#LTSU2-d7e55eb5242648e89c396442afe4f84b
    "第2章。玩转Swift")，*玩转Swift*，都展示了函数式和过程式Swift代码。使用来自`CoreFoundation`框架的`Process`类，以及来自`UIKit`框架的`UIColor`和`UIImage`类来展示如何在应用程序中使用类。本节描述了如何在Swift中创建类、协议和枚举。
- en: Classes in Swift
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift中的类
- en: A class is created in Swift using the `class` keyword, and braces are used to
    enclose the class body. The body can contain variables called *properties*, as
    well as functions called *methods*, which are collectively referred to as *members*.
    Instance members are unique to each instance, while static members are shared
    between all instances of that class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中使用`class`关键字创建类，并使用花括号括起来类体。类体可以包含称为*属性*的变量，以及称为*方法*的函数，它们统称为*成员*。实例成员对每个实例都是唯一的，而静态成员在该类的所有实例之间共享。
- en: 'Classes are typically defined in a file named for the class; so a `GitHubRepository`
    class would typically be defined in a `GitHubRepository.swift` file. A new Swift
    file can be created by navigating to **File** | **New** | **File…** and selecting
    the **Swift File** option under **iOS**. Ensure that it is added to the **Tests**
    and **UITests** targets as well. Once created, implement the class as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常定义在以类命名的文件中；因此，`GitHubRepository`类通常定义在`GitHubRepository.swift`文件中。可以通过导航到**文件**
    | **新建** | **文件…**并选择**iOS**下的**Swift文件**选项来创建一个新的Swift文件。确保将其添加到**测试**和**UI测试**目标中。创建后，按照以下方式实现类：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class can be instantiated and used as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此类可以按如下方式实例化和使用：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is possible to create static members, which are the same for all instances
    of a class. In the `GitHubRepository` class, the `api` URL is likely to remain
    the same for all invocations, so it can be refactored into a `static` property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建静态成员，这些成员对于类的所有实例都是相同的。在`GitHubRepository`类中，`api` URL对于所有调用可能都是相同的，因此它可以重构为一个`static`属性：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if the `api` URL needs to be changed (for example, to support mock testing
    or to support an in-house GitHub Enterprise server), there is a single place to
    change it. Before Swift 2, a **class variables are not yet supported** error message
    may be displayed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果需要更改`api` URL（例如，为了支持模拟测试或支持内部GitHub Enterprise服务器），只需在一个地方进行更改。在Swift
    2之前，可能会显示一个错误信息**类变量尚未支持**。
- en: 'To use static variables in Swift prior to version 2, a different approach must
    be used. It is possible to define *computed properties*, which are not stored
    but are calculated on demand. These have a *getter* (also known as an *accessor*)
    and optionally a *setter* (also known as a *mutator*). The previous example can
    be rewritten as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift版本2之前使用静态变量，必须使用不同的方法。可以定义*计算属性*，这些属性不是存储的，而是在需要时计算。它们有一个*getter*（也称为*访问器*）和可选的*setter*（也称为*修改器*）。前面的例子可以重写如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although this is logically a read-only constant (there is no associated `set`
    block), it is not possible to define the `let` constants with accessors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在逻辑上是一个只读常量（没有相关的`set`块），但无法使用访问器定义`let`常量。
- en: To refer to a class variable, use the type name—which in this case is `GitHubRepository`.
    When the `GitHubRepository.api` expression is evaluated, the body of the getter
    is called.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用类变量，使用类型名——在这个例子中是`GitHubRepository`。当`GitHubRepository.api`表达式被评估时，会调用getter的主体。
- en: Subclasses and testing in Swift
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift中的子类和测试
- en: A simple Swift class with no explicit parent is known as a *base class*. However,
    classes in Swift frequently *inherit* from another class by specifying a superclass
    after the class name. The syntax for this is `class` `SubClass:SuperClass{...}`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式父类的简单Swift类被称为*基类*。然而，Swift中的类经常通过在类名后指定一个超类来*继承*另一个类。这种语法的格式是`class` `SubClass:SuperClass{...}`。
- en: Tests in Swift are written using the **XCTest** framework, which is included
    by default in Xcode templates. This allows an application to have tests written
    and then executed in place to confirm that no bugs have been introduced.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的测试使用**XCTest**框架编写，该框架默认包含在Xcode模板中。这允许应用程序在本地编写和执行测试，以确认没有引入错误。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: XCTest replaces the previous testing framework OCUnit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: XCTest取代了之前的测试框架OCUnit。
- en: The `XCTest` framework has a base class called `XCTestCase` that all tests inherit
    from. Methods beginning with `test` (and that take no arguments) in the test case
    class are invoked automatically when the tests are run. Test code can indicate
    success or failure by calling the `XCTAssert*` functions, such as `XCTAssertEquals`
    and `XCTAssertGreaterThan`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCTest`框架有一个基类叫做`XCTestCase`，所有测试都继承自这个类。在测试用例类中，以`test`开头（且不带参数）的方法在运行测试时会被自动调用。测试代码可以通过调用`XCTAssert*`函数，如`XCTAssertEquals`和`XCTAssertGreaterThan`，来指示成功或失败。'
- en: 'Tests for the `GitHubRepository` class conventionally exist in a corresponding
    `GitHubRepositoryTest` class, which will be a subclass of `XCTestCase`. Create
    a new Swift file by navigating to **File | New | File...** and choosing a **Swift
    File** under the **Source** category for **iOS**. Ensure that the **Tests** and
    **UITests** targets are selected but the application target is not. It can be
    implemented as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GitHubRepository`类的测试通常存在于相应的`GitHubRepositoryTest`类中，它将是`XCTestCase`的子类。通过导航到**文件
    | 新 | 文件...**并选择**源**类别下的**iOS**中的**Swift文件**来创建一个新的Swift文件。确保选择**Tests**和**UITests**目标，但不选择应用程序目标。它可以实现如下：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make sure that the `GitHubRepositoryTest` class is added to the test targets.
    If not added when the file is created, it can be done by selecting the file and
    pressing *Command* + *Option* + *1* to show the **File Inspector**. The checkbox
    next to the test target should be selected. Tests should never be added to the
    main target. The `GitHubRepository` class should be added to both test targets:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`GitHubRepositoryTest`类添加到测试目标中。如果文件创建时没有添加，可以通过选择文件并按*Command* + *Option*
    + *1*来显示**文件检查器**。测试目标旁边的复选框应该被选中。测试永远不会添加到主目标中。`GitHubRepository`类应该添加到两个测试目标中：
- en: '![Subclasses and testing in Swift](img/00028.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Swift中的子类和测试](img/00028.jpeg)'
- en: When the tests are run by pressing *Command* + *U* or by navigating to **Product**
    | **Test**, the results of the test will be displayed. Changing either the implementation
    or the expected test result will demonstrate whether the test is being executed
    correctly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check whether a failing test causes the build to fail; this will confirm
    that the test is actually being run. For example, in the `GitHubRepositoryTest`
    class, modify the URL to remove `https` from the front and check whether a test
    failure is shown. There is nothing more useless than a correctly implemented test
    that never runs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Protocols in Swift
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **protocol** is similar to an interface in other languages; it is a named
    type that has method signatures but no method implementations. Classes can implement
    zero or more protocols; when they do, they are said to **adopt** or **conform**
    to the protocol. A protocol may have a number of methods that are either **required**
    (the default) or **optional** (marked with the `optional` keyword).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optional protocol methods are only supported when the protocol is marked with
    the `@objc` attribute. This declares that the class will be backed by an `NSObject`
    class for interoperability with Objective-C. Pure Swift protocols cannot have
    optional methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to define a protocol looks similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocols cannot have functions with default arguments. Protocols can be used
    with the `struct`, `class`, and `enum` types unless the `@objc` class attribute
    is used; in which case, they can only be used against Objective-C classes or enums.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Classes conform to protocols by listing the protocol names after the class name,
    similar to a superclass.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a class has both a superclass and one or more protocols, the superclass
    must be listed first.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `GitHubDetails` protocol can be used as a type in the same places as an
    existing Swift type, such as a variable type, method return type, or argument
    type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protocols are widely used in Swift to allow callbacks from frameworks that would,
    otherwise, not know about specific callback handlers. If a superclass was required
    instead, then a single class cannot be used to implement multiple callbacks. Common
    protocols include `UIApplicationDelegate`, `Printable`, and `Comparable`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Enums in Swift
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final concept to understand in Swift is *enumeration*, or *enum* for short.
    An enum is a closed set of values, such as `North`, `East`, `South`, and `West`,
    or `Up`, and `Down`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'An enumeration is defined using the `enum` keyword, followed by a type name,
    and a block, which contains the `case` keywords followed by comma-separated values
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unlike C, enumerated values do not have a specific type by default, so they
    cannot generally be converted to and from an integer value. Enumerations can be
    defined with **raw values** that allow conversion to and from integer values.
    Enum values are assigned to variables using the type name and the `enum` name:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, if the type of the expression is known, then the type prefix does
    not need to be explicitly specified; the following form is much more common in
    Swift code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果已知表达式的类型，则不需要显式指定类型前缀；在 Swift 代码中，以下形式更为常见：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Raw values
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始值
- en: 'For the `enum` values that have specific meanings, it is possible to extend
    the `enum` from a different type, such as `Int`. These are known as *raw values*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有特定意义的 `enum` 值，可以从不同的类型扩展 `enum`，例如 `Int`。这些被称为*原始值*：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A raw value enum can be converted to and from its raw value with the `rawValue`
    property and the failable initializer `Rank(rawValue:)` as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `rawValue` 属性和可失败初始化器 `Rank(rawValue:)` 将原始值 `enum` 转换为其原始值，如下所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The failable initializer returns an optional `enum` value, because the equivalent
    `Rank` may not exist. The expression `Rank(rawValue:0)` will return `nil`, for
    example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可失败初始化器返回一个可选的 `enum` 值，因为等效的 `Rank` 可能不存在。例如，表达式 `Rank(rawValue:0)` 将返回 `nil`。
- en: Associated values
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联值
- en: 'Enums can also have *associated values*, such as a value or case class in other
    languages. For example, a combination of a `Suit` and a `Rank` can be combined
    to form a `Card`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 还可以有*关联值*，例如其他语言中的值或案例类。例如，可以将 `Suit` 和 `Rank` 的组合组合起来形成 `Card`：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instances can be created by passing values into an `enum` initializer:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将值传递给 `enum` 初始化器来创建实例：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The associated values of an `enum` instance cannot be extracted (as they can
    with properties of a `struct`), but the `enum` value can be accessed by pattern
    matching in a `switch` statement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `enum` 实例的关联值不能被提取（如 `struct` 的属性那样），但可以通过 `switch` 语句中的模式匹配来访问 `enum` 值：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Swift compiler will require that the `switch` statement be exhaustive. As
    the `enum` only contains these two types, no `default` block is needed. If another
    `enum` value is added to `Card` in the future, the compiler will report an error
    in this `switch` statement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编译器将要求 `switch` 语句是详尽的。由于 `enum` 只包含这两种类型，因此不需要 `default` 块。如果将来在 `Card`
    中添加了另一个 `enum` 值，编译器将在该 `switch` 语句中报告错误。
- en: Creating a master-detail iOS application
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 master-detail iOS 应用程序
- en: Having covered how classes, protocols, and enums are defined in Swift, a more
    complex master-detail application can be created. A master-detail application
    is a specific type of iOS application that initially presents a master table view,
    and when an individual element is selected, a secondary details view will show
    more information about the selected item.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Swift 中如何定义类、协议和 `enum` 之后，可以创建一个更复杂的 master-detail 应用程序。master-detail
    应用程序是一种特定的 iOS 应用程序，它最初显示主表视图，当选择一个单独的元素时，将显示一个次要的详细信息视图，显示有关所选项目的更多信息。
- en: 'Using the **Create a new Xcode project** option from the welcome screen, or
    by navigating to **File** | **New** | **Project…** or by pressing *Command* +
    *Shift* + *N*, create a new project and select **Master-Detail Application** from
    the **iOS Application** category:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欢迎屏幕上的**创建新 Xcode 项目**选项，或通过导航到**文件** | **新建** | **项目…**或按*Command* + *Shift*
    + *N*，创建一个新项目，并从**iOS 应用**类别中选择**Master-Detail 应用程序**：
- en: '![Creating a master-detail iOS application](img/00029.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![创建 master-detail iOS 应用程序](img/00029.jpeg)'
- en: 'In the subsequent dialog, enter appropriate values for the project, such as
    the name (`MasterDetail`), the organization identifier (typically based on the
    reverse DNS name), ensure that the **Language** dropdown reads **Swift** and that
    it is targeted for **Universal** devices:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的对话框中，输入项目的适当值，例如名称（`MasterDetail`）、组织标识符（通常基于反向 DNS 名称），确保**语言**下拉菜单读取为**Swift**，并且它针对**通用**设备：
- en: '![Creating a master-detail iOS application](img/00030.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![创建 master-detail iOS 应用程序](img/00030.jpeg)'
- en: When the project is created, an Xcode window will open containing all the files
    that are created by the wizard itself, including the `MasterDetail.app` and `MasterDetailTests.xctest`
    products. The `MasterDetail.app` is a bundle that is executed by the simulator
    or a connected device, while the `MasterDetailTests.xctest` and `MasterDetailsUITests.xctest`
    products are used to execute unit tests for the application's code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目创建时，一个包含由向导本身创建的所有文件的 Xcode 窗口将打开，包括 `MasterDetail.app` 和 `MasterDetailTests.xctest`
    产品。`MasterDetail.app` 是一个由模拟器或连接的设备执行的包，而 `MasterDetailTests.xctest` 和 `MasterDetailsUITests.xctest`
    产品用于执行应用程序代码的单元测试。
- en: The application can be launched by pressing the triangular play button on the
    top-left corner of Xcode or by pressing *Command* + *R*, which will run the application
    against the currently selected target.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过按 Xcode 左上角的三角形播放按钮或按 *Command* + *R* 来启动应用程序，这将针对当前选定的目标运行应用程序。
- en: '![Creating a master-detail iOS application](img/00031.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个主详情 iOS 应用程序](img/00031.jpeg)'
- en: 'After a brief compile and build cycle, the iOS Simulator will open with a master
    page that contains an empty table, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在简短的编译和构建周期之后，iOS 模拟器将打开一个包含空表的首页，如下面的截图所示：
- en: '![Creating a master-detail iOS application](img/00032.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个主详情 iOS 应用程序](img/00032.jpeg)'
- en: The default `MasterDetail` application can be used to add items to the list
    by clicking on the add (**+**) button on the top-right corner of the screen. This
    will add a new timestamped entry to the list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `MasterDetail` 应用程序可以通过点击屏幕右上角的添加（**+**）按钮来向列表中添加项目。这将向列表中添加一个新的带时间戳的条目。
- en: '![Creating a master-detail iOS application](img/00033.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个主详情 iOS 应用程序](img/00033.jpeg)'
- en: 'When this item is clicked, the screen will switch to the details view, which,
    in this case, presents the time in the center of the screen:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击此项目时，屏幕将切换到详情视图，在这种情况下，屏幕中央显示时间：
- en: '![Creating a master-detail iOS application](img/00034.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个主详情 iOS 应用程序](img/00034.jpeg)'
- en: This kind of master-detail application is common in iOS applications for displaying
    a top-level list (such as a shopping list, a set of contacts, to-do notes, and
    so on) while allowing the user to tap to see the details.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种主详情应用在 iOS 应用程序中很常见，用于显示顶层列表（如购物清单、一组联系人、待办笔记等），同时允许用户点击查看详情。
- en: 'There are three main classes in the master-detail application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主详情应用程序中有三个主要类：
- en: The `AppDelegate` class is defined in the `AppDelegate.swift` file, and it is
    responsible for starting the application and set up the initial state
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDelegate` 类定义在 `AppDelegate.swift` 文件中，它负责启动应用程序并设置初始状态'
- en: The `MasterViewController` class is defined in the `MasterViewController.swift`
    file, and it is used to manage the first (master) screen's content and interactions
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterViewController` 类定义在 `MasterViewController.swift` 文件中，它用于管理第一个（主）屏幕的内容和交互'
- en: The `DetailViewController` class is defined in the `DetailViewController.swift`
    file, and it is used to manage the second (detail) screen's content
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetailViewController` 类定义在 `DetailViewController.swift` 文件中，它用于管理第二个（详情）屏幕的内容'
- en: In order to understand what the classes do in more detail, the next three sections
    will present each of them in turn.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解这些类的作用，接下来的三个部分将依次介绍它们。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The code that is generated in this section was created from Xcode 7.0, so the
    templates might differ slightly if using a different version of Xcode. An exact
    copy of the corresponding code can be acquired from the Packt website or from
    this book's GitHub repository at [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本节生成的代码是从 Xcode 7.0 创建的，因此如果使用不同版本的 Xcode，模板可能会有所不同。可以从 Packt 网站或本书的 GitHub
    仓库 [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/)
    获取相应的代码的精确副本。
- en: The AppDelegate class
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AppDelegate` 类'
- en: The `AppDelegate` class is the main entry point to the application. When a set
    of Swift source files are compiled, if the `main.swift` file exists, it is used
    as the entry point for the application by running that code. However, to simplify
    setting up an application for iOS, a `@UIApplicationMain` special attribute exists
    that will both synthesize the `main` method and set up the associated class as
    the application delegate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDelegate` 类是应用程序的主要入口点。当一组 Swift 源文件被编译时，如果存在 `main.swift` 文件，它将作为应用程序的入口点运行该代码。然而，为了简化
    iOS 应用程序的设置，存在一个 `@UIApplicationMain` 特殊属性，它将生成 `main` 方法并设置关联的类作为应用程序代理。'
- en: 'The `AppDelegate` class for iOS extends the `UIResponder` class, which is the
    parent of all the UI content on iOS. It also adopts two protocols, `UIApplicationDelegate`,
    and `UISplitViewControllerDelegate`, which are used to provide callbacks when
    certain events occur:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 的 `AppDelegate` 类扩展了 `UIResponder` 类，它是 iOS 上所有 UI 内容的父类。它还采用了两个协议，`UIApplicationDelegate`
    和 `UISplitViewControllerDelegate`，用于在发生某些事件时提供回调：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On OS X, the `AppDelegate` class will be a subclass of `NSApplication` and will
    adopt the `NSApplicationDelegate` protocol.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 上，`AppDelegate` 类将是 `NSApplication` 的子类，并采用 `NSApplicationDelegate` 协议。
- en: The synthesized `main` function calls the `UIApplicationMain` method that reads
    the `Info.plist` file. If the `UILaunchStoryboardName` key exists and points to
    a suitable file (the `LaunchScreen.xib` interface file in this case), it will
    be shown as a splash screen before doing any further work. After the rest of the
    application has loaded, if the `UIMainStoryboardFile` key exists and points to
    a suitable file (the `Main.storyboard` file in this case), the storyboard is launched
    and the initial view controller is shown.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 合成的 `main` 函数调用 `UIApplicationMain` 方法，该方法读取 `Info.plist` 文件。如果存在 `UILaunchStoryboardName`
    键，并且指向一个合适的文件（在这种情况下是 `LaunchScreen.xib` 接口文件），它将在进行任何进一步工作之前显示为启动画面。在应用程序的其余部分加载完毕后，如果存在
    `UIMainStoryboardFile` 键，并且指向一个合适的文件（在这种情况下是 `Main.storyboard` 文件），则启动故事板并显示初始视图控制器。
- en: The storyboard has references to the `MasterViewController` and `DetailViewController`
    classes. The `window` variable is assigned to the storyboard's window.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 故事板引用了 `MasterViewController` 和 `DetailViewController` 类。`window` 变量被分配给故事板的窗口。
- en: 'The `application:didFinishLaunchingWithOptions` is called once the application
    has started. It is passed with a reference to the `UIApplication` instance and
    a dictionary of options that notifies how the application has been started:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动后，会调用 `application:didFinishLaunchingWithOptions` 方法。该方法通过一个指向 `UIApplication`
    实例的引用和一个字典传递，字典通知应用程序是如何启动的：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the sample `MasterDetail` application, the `application:didFinishLaunchingWithOptions`
    method acquires a reference to the `splitViewController` from the explicitly unwrapped
    optional `window`, and the `AppDelegate` is set as its delegate:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 `MasterDetail` 应用程序中，`application:didFinishLaunchingWithOptions` 方法从显式解包的
    `window` 中获取对 `splitViewController` 的引用，并将 `AppDelegate` 设置为其代理：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `… as! UISplitViewController` syntax performs a type cast so that the generic
    `rootViewController` can be assigned to the more specific type; in this case,
    `UISplitViewController`. An alternative version `as?` provides a runtime checked
    cast, and it returns an optional value that either contains the value with the
    correctly casted type or `nil` otherwise. The difference with `as!` is a runtime
    error will occur if the item is not of the correct type.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`… as! UISplitViewController` 语法执行类型转换，以便可以将泛型 `rootViewController` 赋值给更具体的类型；在这种情况下，`UISplitViewController`。一个替代版本
    `as?` 提供了运行时检查的转换，并返回一个可选值，该值要么包含正确转换的类型值，要么在否则返回 `nil`。与 `as!` 的区别是，如果项目不是正确的类型，将发生运行时错误。'
- en: 'Finally, a `navigationController` is acquired from the `splitViewController`,
    which stores an array of `viewControllers`. This allows the `DetailView` to display
    a button on the left-hand side to expand the details view if necessary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 `splitViewController` 获取一个 `navigationController`，它存储了一个 `viewControllers`
    数组。这允许 `DetailView` 在必要时在左侧显示一个按钮以展开详细视图：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only difference this makes is when running on a wide-screen device, such
    as an iPhone 6 Plus or an iPad, where the views are displayed side-by-side in
    landscape mode. This is a new feature in iOS 8 applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这唯一的区别在于在宽屏设备上运行时，例如 iPhone 6 Plus 或 iPad，在横向模式下视图并排显示。这是 iOS 8 应用程序中的新功能。
- en: '![The AppDelegate class](img/00035.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![AppDelegate 类](img/00035.jpeg)'
- en: 'Otherwise, when the device is in portrait mode, it will be rendered as a standard
    back button:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，当设备处于纵向模式时，它将渲染为一个标准的后退按钮：
- en: '![The AppDelegate class](img/00036.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![AppDelegate 类](img/00036.jpeg)'
- en: The method concludes with `return` `true` to let the OS know that the application
    has opened successfully.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法以 `return true` 结束，以让操作系统知道应用程序已成功打开。
- en: The MasterViewController class
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MasterViewController` 类'
- en: 'The `MasterViewController` class is responsible for coordinating the data that
    is shown on the first screen (when the device is in portrait orientation) or the
    left-half of the screen (when a large device is in landscape orientation). This
    is rendered with a `UITableView`, and data is coordinated through the parent `UITableViewController`
    class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`MasterViewController` 类负责协调在第一屏（当设备处于纵向模式时）或屏幕左侧（当大设备处于横向模式时）显示的数据。这是通过 `UITableView`
    渲染的，并且数据通过父 `UITableViewController` 类进行协调：'
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `viewDidLoad` method is used to set up or initialize the view after it
    has loaded. In this case, a `UIBarButtonItem` is created so that the user can
    add new entries to the table. The `UIBarButtonItem` takes a `@selector` in Objective-C,
    and in Swift is treated as a string literal convertible (so that `"insertNewObject:"`
    will result in a call to the `insertNewObject` method). Once created, the button
    is added to the navigation on the right-hand side, using the standard `.Add` type
    which will be rendered as a **+** sign on the screen:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad` 方法用于在视图加载后设置或初始化视图。在这种情况下，创建了一个 `UIBarButtonItem`，以便用户可以向表中添加新条目。`UIBarButtonItem`
    在 Objective-C 中使用 `@selector`，在 Swift 中被视为可转换为字符串字面量的（因此 `"insertNewObject:"`
    将导致调用 `insertNewObject` 方法）。一旦创建，按钮就被添加到右侧的导航中，使用标准的 `.Add` 类型，它将在屏幕上显示为 **+**
    号：'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The objects are `NSDate` values, and are stored inside the class as an Array
    of `AnyObject` elements. The `insertNewObject` method is called when the **+**
    button is pressed, and it creates a new `NSDate` instance which is then inserted
    into the array. The `sender` event is passed as an argument of the `AnyObject`
    type, which will be a reference to the `UIBarButtonItem` (although it is not needed
    or used here):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是 `NSDate` 值，作为 `AnyObject` 元素的数组存储在类中。当按下 **+** 按钮时调用 `insertNewObject`
    方法，它创建一个新的 `NSDate` 实例，然后将其插入到数组中。`sender` 事件作为 `AnyObject` 类型的参数传递，它将是一个对 `UIBarButtonItem`
    的引用（尽管在这里不需要或使用它）：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The `UIBarButtonItem` class was created before blocks were available on iOS
    devices, so it uses the older Objective-C `@selector` mechanism. A future release
    of iOS may provide an alternative that takes a block, in which case Swift functions
    can be passed instead.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 设备上可用 blocks 之前，就创建了 `UIBarButtonItem` 类，因此它使用较旧的 Objective-C `@selector`
    机制。iOS 的未来版本可能提供一个接受 block 的替代方案，在这种情况下，可以传递 Swift 函数。
- en: 'The parent class contains a reference to the `tableView`, which is automatically
    created by the storyboard. When an item is inserted, the `tableView` is notified
    that a new object is available. Standard `UITableViewController` methods are used
    to access the data from the array:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 父类包含对 `tableView` 的引用，该引用由 storyboard 自动创建。当插入一个项目时，`tableView` 被通知有一个新的对象可用。使用标准的
    `UITableViewController` 方法从数组中访问数据：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `numberOfSectionsInTableView` function returns `1` in this case, but a `tableView`
    can have multiple sections; for example, to permit a contacts application having
    a different section for A, B, C through Z. The `numberOfRowsInSection` method
    returns the number of elements in each section; in this case, as there is only
    one section, the number of objects in the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`numberOfSectionsInTableView` 函数返回 `1`，但 `tableView` 可以有多个分区；例如，为了允许联系人应用程序有
    A、B、C 到 Z 的不同分区。`numberOfRowsInSection` 方法返回每个分区的元素数量；在这种情况下，因为只有一个分区，所以数组中的对象数量。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The reason why each method is called `tableView` and takes a `tableView` argument
    is a result of the Objective-C heritage of UIKit. The Objective-C convention combined
    the method name as the first named argument, so the original method was `[delegate`
    `tableView:UITableView,` `numberOfRowsInSection:NSInteger]`. As a result, the
    name of the first argument is reused as the name of the method in Swift.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法之所以被称为 `tableView` 并接受一个 `tableView` 参数，是因为 UIKit 的 Objective-C 继承的结果。Objective-C
    中的约定将方法名作为第一个命名参数，因此原始方法是 `[delegate` `tableView:UITableView,` `numberOfRowsInSection:NSInteger]`。因此，第一个参数的名称被重用作
    Swift 中方法的名称。
- en: The `cellForRowAtIndexPath` method is expected to return `UITableViewCell` for
    an object. In this case, a cell is acquired from the `tableView` using the `dequeueReusableCellWithIdentifier`
    method (which caches cells as they go off screen to save object instantiation),
    and then the `textLabel` is populated with the object's `description` (which is
    a `String` representation of the object; in this case, the date).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellForRowAtIndexPath` 方法预期返回一个 `UITableViewCell` 对象。在这种情况下，通过使用 `dequeueReusableCellWithIdentifier`
    方法（该方法在单元格离开屏幕时缓存单元格以节省对象实例化）从 `tableView` 中获取一个单元格，然后使用对象的 `description`（这是对象的
    `String` 表示形式；在这种情况下，是日期）填充 `textLabel`。'
- en: 'This is enough to display elements in the table, but in order to permit editing
    (or just removal, as in the sample application), there are some additional protocol
    methods that are required:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以在表中显示元素，但为了允许编辑（或只是删除，如示例应用程序中所示），还需要一些额外的协议方法：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `canEditRowAtIndexPath` method returns `true` if the row is editable; if
    all the rows can be edited, then this will return `true` for all the values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`canEditRowAtIndexPath` 方法如果行可编辑则返回 `true`；如果所有行都可以编辑，则对于所有值都将返回 `true`。'
- en: The `commitEditingStyle` method takes a table, a path, and a style, which is
    an enumeration that indicates which operation occurred. In this case, `UITableViewCellEditingStyle.Delete`
    is passed in order to delete the item from both the underlying object array and
    also from the `tableView`. (The enumeration can be abbreviated to `.Delete` because
    the type of `editingStyle` is known to be `UITableViewCellEditingStyle`.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitEditingStyle` 方法接受一个表格、一个路径和一个样式，这是一个枚举，表示发生了哪个操作。在这种情况下，传入 `UITableViewCellEditingStyle.Delete`
    以从底层对象数组以及从 `tableView` 中删除项目。（枚举可以缩写为 `.Delete`，因为 `editingStyle` 的类型已知为 `UITableViewCellEditingStyle`。）'
- en: The DetailViewController class
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DetailViewController` 类'
- en: The detail view is shown when an element is selected in the `MasterViewController`.
    The transition is managed by the storyboard controller; the views are connected
    with a *segue* (pronounced *seg-way*; the product of the same name based it on
    the word *segue* which is derived from the Italian word for *follows*).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MasterViewController` 中选择元素时，将显示详细视图。过渡由故事板控制器管理；视图通过 *segue*（发音为 *seg-way*；基于意大利语中
    *follows* 一词的 *segue* 一词的产物）连接。
- en: 'To pass the selected item between controllers, a property exists in the `DetailViewController`
    class called `detailItem`. When the value is changed, additional code is run,
    which is implemented in a `didSet` property notification:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控制器之间传递选定的项目，`DetailViewController` 类中存在一个名为 `detailItem` 的属性。当值更改时，将运行额外的代码，这通过
    `didSet` 属性通知实现：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When `DetailViewController` has the `detailItem` set, the `configureView` method
    will be invoked. The `didSet` body is run after the value has been changed, but
    before the setter returns to the caller. This is triggered by the `segue` in the
    `MasterViewController`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `DetailViewController` 设置了 `detailItem` 时，将调用 `configureView` 方法。在值更改后，`didSet`
    主体将运行，但在设置器返回调用者之前。这是由 `MasterViewController` 中的 `segue` 触发的：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `prepareForSegue` method is called when the user selects an item in the
    table. In this case, it grabs the selected row index from the table and uses this
    to acquire the selected date object. The navigation controller hierarchy is searched
    to acquire the `DetailViewController`, and once this has been obtained, the selected
    value is set with `controller.detailItem` `=` `object`, which triggers the update.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在表格中选择一个项目时，将调用 `prepareForSegue` 方法。在这种情况下，它从表格中获取选定的行索引，并使用此索引获取选定的日期对象。搜索导航控制器层次结构以获取
    `DetailViewController`，一旦获取到，就使用 `controller.detailItem` `=` `object` 设置选定的值，这触发了更新。
- en: 'The label is ultimately displayed in the `DetailViewController` through the
    `configureView` method, which stamps the `description` of the object onto the
    `label` in the center:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 标签最终通过 `configureView` 方法在 `DetailViewController` 中显示，该方法将对象的 `description`
    打印到中心的 `label` 上：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `configureView` method is called both when the `detailItem` is changed and
    when the view is loaded for the first time. If the `detailItem` has not been set,
    then this has no effect.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `detailItem` 发生变化或首次加载视图时，将调用 `configureView` 方法。如果 `detailItem` 未设置，则此操作没有效果。
- en: 'The implementation introduces some new concepts, which are worth highlighting:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现引入了一些新的概念，这些概念值得强调：
- en: The `@IBOutlet` attribute indicates that the property will be exposed in interface
    builder and can be wired up to the object instance. This will be covered in more
    detail in [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*, and in [Chapter 5](part0039_split_000.html#1565U1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 5. Creating Custom Views in Swift"), *Creating Custom Views in Swift*.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@IBOutlet` 属性表示该属性将在界面构建器中公开，并可以连接到对象实例。这将在[第4章](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "第4章。使用Swift和iOS的Storyboard应用程序")、*使用Swift和iOS的Storyboard应用程序*和[第5章](part0039_split_000.html#1565U1-d7e55eb5242648e89c396442afe4f84b
    "第5章。在Swift中创建自定义视图")、*在Swift中创建自定义视图*中更详细地介绍。'
- en: The `weak` attribute indicates that the property will not store a *strong* reference
    to the object; in other words, the detail view will not own the object but merely
    reference it. Generally, all `@IBOutlet` references should be declared as `weak`
    to avoid cyclic dependency references.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak` 属性表示该属性不会存储对象的 *strong* 引用；换句话说，详情视图不会拥有该对象，而只是引用它。通常，所有 `@IBOutlet`
    引用都应该声明为 `weak` 以避免循环依赖引用。'
- en: The type is defined as `UILabel!` which is an *implicitly unwrapped optional*.
    When accessed, it performs an explicit unwrapping of the optional value; otherwise
    the `@IBOutlet` will be wired up as a `UILabel?` optional type. Implicitly unwrapped
    optional types are used when the variable is known to never be `nil` at runtime,
    which is usually the case for the `@IBOutlet` references. Generally, all `@IBOutlet`
    references should be implicitly unwrapped optionals.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型定义为 `UILabel!`，这是一个 *隐式解包的可选类型*。当访问时，它会对可选值执行显式解包；否则，`@IBOutlet` 将被连接为一个 `UILabel?`
    可选类型。隐式解包的可选类型用于变量在运行时已知永远不会是 `nil` 的情况，这对于 `@IBOutlet` 引用通常是这种情况。通常，所有 `@IBOutlet`
    引用都应该使用隐式解包的可选类型。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented two sample iOS applications; one in which the UI was
    created programmatically, and another in which the UI was loaded from a storyboard.
    Together with an overview of classes, protocols, and enums, and an explanation
    of how iOS applications start, this chapter gives a springboard to understand
    the Xcode templates that are frequently used to start new projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两个 iOS 应用程序的示例；一个是通过编程创建 UI 的，另一个是从故事板中加载 UI 的。结合对类、协议和枚举的概述，以及解释 iOS 应用程序是如何启动的，本章为理解经常用于启动新项目的
    Xcode 模板提供了一个起点。
- en: The next chapter, *Storyboard Applications with Swift and iOS*, will go into
    more detail about how storyboards are created and how an application can be built
    from scratch.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，*使用 Swift 和 iOS 的故事板应用*，将更详细地介绍故事板的创建方式以及如何从头开始构建一个应用程序。
