<html><head></head><body>
		<div><h1 id="_idParaDest-190" class="chapter number"><a id="_idTextAnchor638"/>12</h1>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor639"/>Persisting Data</h1>
			<p><a id="_idTextAnchor640"/>This chapter goes in depth about data persistence in Android. By the end of the chapter, you will know multiple ways to store (persist) data directly on a device and the frameworks accessible to do this. When dealing with a filesystem, you will know how it’s partitioned and how you can read and write files in different locations and use different frameworks.</p>
			<p><a id="_idTextAnchor641"/>In the previous chapter, you learned how to structure your code and save data. In the activity, you also had the opportunity to build a repository and use it to access and save data through Room. In this chapter, you will learn about alternative ways to persist data on a device through the Android filesystem and how it’s structured into external and internal memory.</p>
			<p>You’ll also develop your understanding of read and write permissions, learn how to create the <code>FileProvider</code> class to offer other apps access to your files, and learn how you can save those files without requesting permissions on external drives. You’ll also see how to download files from the internet and save them on a filesystem.</p>
			<p>Another concept that will be explored in this chapter is using the <strong class="bold">Camera</strong> application to take photos and videos on your application’s behalf and save them to external storage using FileProviders.</p>
			<p>We will cover the following topics in the chapter:</p>
			<ul>
				<li>Preferences and DataStore</li>
				<li>Files</li>
				<li>Scoped storage</li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor642"/><a id="_idTextAnchor643"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/XlTwZ">https://packt.link/XlTwZ</a></p>
			<h1 id="_idParaDest-193">Pre<a id="_idTextAnchor644"/>ferences and DataStore</h1>
			<p>Imagine you are tasked<a id="_idIndexMarker1012"/> with integrating a third-party <a id="_idIndexMarker1013"/>API that uses something such as OAuth to implement logging in with Facebook, Google, and suchlike. The way these mechanisms work is as follows – they give you a token that you have to store locally and that can then be used to send other requests to access user data.</p>
			<p>This raises several questions. How can you store that token? Do you use Room just for one token? Do you save the token in a separate file and implement methods for writing the file? What if that file has to be accessed in multiple places at the same time? <code>SharedPreferences</code> and <code>DataStore</code> are answers to these questions. <code>SharedPreferences</code> is a functionality that allows you to save Booleans, integers, floats, longs, strings, and sets of strings into an XML file.</p>
			<p>When you want to save new values, you specify what values you want to save for the associated keys, and when you are done, you commit the change, which will trigger the save to the XML file in an asynchronous way. The <code>SharedPreferences</code> mappings are also kept in memory so that when you want to read these values, it’s instantaneous, thereby removing the need for an asynchronous call to read the XML file.</p>
			<p>We now have two ways<a id="_idIndexMarker1014"/> to store data in key-value<a id="_idIndexMarker1015"/> pairs in the form of <code>SharedPreferences</code> and <code>DataStore</code>. We will now look at how each of them works and the benefits each one provid<a id="_idTextAnchor645"/>es.<a id="_idTextAnchor646"/></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor647"/>SharedPreferences</h2>
			<p>The way to access the <code>SharedPreference</code> object<a id="_idIndexMarker1016"/> is through the <code>Context</code> object:</p>
			<pre class="source code">
val prefs = getSharedPreferences("my-prefs-file",
Context.MODE_PRIVATE)</pre>
			<p>The first parameter is where you specify the name of your preferences, and the second is how you want to expose a file to other apps. Currently, the best mode is the private one. All of the others present potential security risks.</p>
			<p>If you want to write data into your preferences file, you first need to get access to the Preferences editor. The editor will give you access to write the data. You can then write your data in it. Once you finish writing, you will have to apply the changes that will trigger persistence to the XML file and change the in-memory values as well.</p>
			<p>You have two choices to apply the changes on your preference file – <code>apply</code> or <code>commit</code>. Choosing <code>apply</code> will save your changes in memory instantly, but then writing to disk will be asynchronous, which is useful if you want to save data from from your app’s main thread. <code>commit</code> does everything synchronously and gives you a Boolean result, informing you whether the operation was successful or not. In practice, <code>apply</code> tends to be favored over <code>commit</code>:</p>
			<pre class="source code">
    val editor = prefs.edit()
    editor.putBoolean("my_key_1", true)
    editor.putString("my_key_2", "my string")
    editor.putLong("my_key_3", 1L)
    editor.apply()</pre>
			<p>Now, you want to clear your entire data. The same principle will apply; you’ll need <code>editor</code>, <code>clear</code>, and <code>apply</code>:</p>
			<pre class="source code">
    val editor = prefs.edit()
    editor.clear()
    editor.apply()</pre>
			<p>If you want to read the values you previously saved, you can use the <code>SharedPreferences</code> object to read the stored values. If there is no saved value, you can opt for a default value to be returned instead:</p>
			<pre class="source code">
    prefs.getBoolean("my_key_1", false)
    prefs.getString("my_key_2", "")
    prefs.getLong("my_key_3", 0L)</pre>
			<p>We should now have an<a id="_idIndexMarker1017"/> idea about how we can persist data with <code>SharedPreferences</code>, and we can apply this in an exercise in the following sec<a id="_idTextAnchor648"/>tio<a id="_idTextAnchor649"/>n.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor650"/>Exercise 12.01 – wrapping SharedPreferences</h2>
			<p>We’re going to build<a id="_idIndexMarker1018"/> an application that displays <code>TextView</code>, <code>EditText</code>, and a button. <code>TextView</code> will display the previously saved value in <code>SharedPreferences</code>. The user can type new text, and when the button is clicked, the text will be saved in <code>SharedPreferences</code> and <code>TextView</code> will display the updated text. We will need to use <code>ViewModel</code> and <code>LiveData</code> to make the code more testable.</p>
			<p>In order to complete<a id="_idIndexMarker1019"/> this exercise, we will need to create a <code>Wrapper</code> class, which will be responsible for saving the text. This class will return the value of the text as <code>LiveData</code>. This will be injected into our <code>ViewModel</code>, which will be bound to the activity:</p>
			<ol>
				<li>Create a new Android Studio project with an empty activity.</li>
				<li>Let’s begin by adding the appropriate libraries to <code>app/build.gradle</code>:<pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Let’s make our <code>Wrapper</code> class in the <code>main/java</code> folder in the <code>root</code> package, which will listen for changes in <code>SharedPreferences</code> and update the value of <code>LiveData</code> when the preferences change. The class will contain methods to save the new text and retrieve <code>LiveData</code>:<pre class="source code">
const val KEY_TEXT = "keyText"
class PreferenceWrapper(private val sharedPreferences:
SharedPreferences) {
    private val textLiveData =
        MutableLiveData&lt;String&gt;()
    init {
        sharedPreferences
        .registerOnSharedPreferenceChangeListener {
        _, key -&gt;
            when (key) {
                KEY_TEXT -&gt; {
                    textLiveData.postValue(
                    sharedPreferences
                    .getString(KEY_TEXT, ""))
                }
            }
        }
<a id="_idTextAnchor651"/>    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/a2RuN">https://packt.link/a2RuN</a>.</p>
			<p>Note the top of the file. We’ve added a listener<a id="_idIndexMarker1020"/> so that when our <code>SharedPreferences</code> values change, we can look up the new value and update our <code>LiveData</code> model. This will allow us to observe <code>LiveData</code> for any changes and just update the UI.</p>
			<p>The <code>saveText</code> method will open the editor, set the new value, and apply the changes. The <code>getText</code> method will read the last saved value, set it in <code>LiveData</code>, and return the <code>LiveData</code> object. This is helpful in scenarios where the app is opened and we want to access the last value prior to the app closing.</p>
			<ol>
				<li value="4">Now, let’s set up the <code>Application</code> class with the instance of the preferences in the <code>main/java</code> folder in the root package:<pre class="source code">
class PreferenceApplication : Application() {
    lateinit var preferenceWrapper: PreferenceWrapper
    override fun onCreate() {
        super.onCreate()
        preferenceWrapper =
            PreferenceWrapper(getSharedPreferences(
            "prefs", Context.MODE_PRIVATE))
    }
}</pre></li>
				<li>Now, let’s add the appropriate attributes in the <code>application</code> tag to <code>Android</code><strong class="source inline">
</strong><code>Manifest.xml</code>:<pre class="source code">
android:name=".PreferenceApplication"</pre></li>
				<li>Next, let’s build the <code>ViewModel</code> component in the <code>main/java</code> folder<a id="_idIndexMarker1021"/> in the root package:<pre class="source code">
class PreferenceViewModel(private val
preferenceWrapper: PreferenceWrapper) : ViewModel() {
    fun saveText(text: String) {
        preferenceWrapper.saveText(text)
    }
    fun getText(): LiveData&lt;String&gt; {
        return preferenceWrapper.getText()
    }
}</pre></li>
				<li>Now, let’s define our <code>activity_main.xml</code> layout file in the <code>res/layout</code> folder:<pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;EditText
        android:id="@+id/activity_main_edit_text"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:inputType="none"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_text_view" /&gt;</pre></li>
			</ol>
			<p>The complete<a id="_idIndexMarker1022"/> code for this step can be found at <a href="https://packt.link/2c5Ay">https://packt.link/2c5Ay</a>.</p>
			<ol>
				<li value="8">Finally, in <code>MainActivity</code>, perform the following steps:<pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        preferenceViewModel.getText().observe(this,
        Observer {
            findViewById&lt;TextView&gt;(
            R.id.activity_main_text_view) .text = it
        })
        findViewById&lt;Button&gt;(R.id.activity_main_button
        ) .setOnClickListener {
            preferenceViewModel.saveText(findViewById
            &lt;EditText&gt; (R.id.activity_main_edit_text)
            .text.toString())
        }
    }
}</pre></li>
			</ol>
			<p>The complete code<a id="_idIndexMarker1023"/> for this step can be found at <a href="https://packt.link/ZRWNc">https://packt.link/ZRWNc</a>.</p>
			<p>The preceding code will produce the output presented in <em class="italic">Fi<a id="_idTextAnchor652"/>gure 12</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B19411_12_01.jpg" alt="Figure 12.1 – Output of Exercise 12.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Output of Exercise 12.01</p>
			<p>Once you insert a value, try closing<a id="_idIndexMarker1024"/> the application and reopening it. The app will display the last persisted value.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor653"/>DataStore</h2>
			<p>The <code>DataStore</code> persistence library represents<a id="_idIndexMarker1025"/> an alternative to <code>SharedPreferences</code> when we want to store data in key-value pairs through the Preference <code>DataStore</code>, or if we want to store entire objects through the Proto <code>DataStore</code>. Both libraries avoid dependencies with the Android framework (unlike <code>SharedPreferences</code>, which requires a <code>Context</code> object to be initialized) and are built using coroutines and flows, making them the ideal candidate when coroutines and flows are used in your project.</p>
			<p>This integration allows the <code>DataStore</code> to notify subscribers of all changes, which means that developers no longer have to concern themselves with handling the changes:</p>
			<pre class="source code">
val Context.dataStore: DataStore&lt;Preferences&gt; by
preferencesDataStore(name = "myDataStore")
val KEY_MY_INT = intPreferencesKey("my_int_key")
val KEY_MY_BOOLEAN =
    booleanPreferencesKey("my_boolean_key")
val KEY_MY_STRING = stringPreferencesKey("my_string_key")
class MyAppSettings(private val context: Context) {
    val myIntValue: Flow&lt;Int&gt; = context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_INT] ?: 0
        }
    val myBooleanValue: Flow&lt;Boolean&gt; =
        context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_BOOLEAN] ?: false
        }
    val myStringValue: Flow&lt;String&gt; =
        context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_STRING] ?: ""
        }
}</pre>
			<p>In the preceding<a id="_idIndexMarker1026"/> snippet, we initialize <code>Context.dataStore</code> in the top-level Kotlin file. We then define three separate keys for separate types we want to read from. Inside <code>MyAppSettings</code>, we map the values from <code>context.dataStore.data</code> and extract the values from our keys.</p>
			<p>If we want to store data in our <code>DataStore</code>, then we need to do the following:</p>
			<pre class="source code">
class MyAppSettings(private val context: Context) {
    …
    suspend fun saveMyIntValue(intValue: Int) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_INT] = intValue
        }
    }
    suspend fun saveMyBooleanValue(booleanValue: Boolean) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_BOOLEAN] = booleanValue
        }
    }
    suspend fun saveMyStringValue(stringValue: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_STRING] = stringValue
        }
    }
}</pre>
			<p>The <code>suspend</code> keyword comes from coroutines, and it signals that we need to place the method invocation<a id="_idIndexMarker1027"/> into an asynchronous call. <code>context.dataStore.edit</code> will make the preferences in the <code>DataStore</code> mutable and allow us to change the values.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor654"/>Exercise 12.02 – Preference DataStore</h2>
			<p>We’re going to build<a id="_idIndexMarker1028"/> an application that displays <code>TextView</code>, <code>EditText</code>, and a button. <code>TextView</code> will display the value that was added to <code>DataStore</code>. The user can type new text, and when the button is clicked, the text will be saved in <code>DataStore</code> and <code>TextView</code> will display the updated text.</p>
			<p>We will need to use <code>ViewModel</code> and <code>LiveData</code>. In the <code>ViewModel</code>, we will collect the data coming from <code>DataStore</code> and place it in a <code>LiveData</code> object:</p>
			<ol>
				<li>Create a new Android Studio<a id="_idIndexMarker1029"/> project with an empty activity.</li>
				<li>Let’s begin by adding the appropriate libraries to <code>app/build.gradle</code>:<pre class="source code">
    implementation "androidx.datastore:
        datastore-preferences:1.0.0"
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Create a class called <code>SettingsStore</code> in the <code>main/java</code> folder in the root package, which will contain methods to load and save data from <code>DataStore</code>:<pre class="source code">
val Context.dataStore: DataStore&lt;Preferences&gt; by
preferencesDataStore(name = "settingsStore")
val KEY_TEXT = stringPreferencesKey("key_text")
class SettingsStore(private val context: Context) {
    val text: Flow&lt;String&gt; = context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_TEXT] ?: ""
        }
    suspend fun saveText(text: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_TEXT] = text
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we have defined a key for storing the text, a field to retrieve the saved text, and a method to save it.</p>
			<ol>
				<li value="4">Create a new class called <code>SettingsViewModel</code> in the <code>main/java</code> folder in the root package, which<a id="_idIndexMarker1030"/> will collect the data from <code>SettingsStore</code> in <code>LiveData</code> and invoke it to save the new text values:<pre class="source code">
class SettingsViewModel(private val settingsStore:
SettingsStore) : ViewModel() {
    private val _textLiveData =
        MutableLiveData&lt;String&gt;()
    val textLiveData: LiveData&lt;String&gt; = _textLiveData
    init {
        viewModelScope.launch {
            settingsStore.text.collect {
                _textLiveData.value = it
            }
        }
    }
    fun saveText(text: String) {
        viewModelScope.launch {
            settingsStore.saveText(text)
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, <code>viewModelScope</code> is an extension of <code>ViewModel</code> and represents <code>CoroutineScope</code>, which ensures that the background work is done while <code>ViewModel</code> is still active to avoid any possible leaks. Using this, we can collect the existing text into <code>LiveData</code> when <code>ViewModel</code> is initialized and then invoke the <code>saveText</code> method from <code>SettingsStore</code>.</p>
			<ol>
				<li value="5">Now, let’s set up the <code>Application</code> class with the <code>SettingsStore</code> instance in the <code>main/java</code> folder<a id="_idIndexMarker1031"/> in the root package:<pre class="source code">
class SettingsApplication : Application() {
    lateinit var settingsStore: SettingsStore
    override fun onCreate() {
        super.onCreate()
        settingsStore = SettingsStore(this)
    }
}</pre></li>
				<li>Next, let’s add the appropriate attributes in the <code>application</code> tag to <code>Android</code><strong class="source inline">
</strong><code>Manifest.xml</code>:<pre class="source code">
android:name=".SettingsApplication"</pre></li>
				<li>Finally, let’s define our <code>activity_main.xml</code> layout file in the <code>res/layout</code> folder:<pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;EditText
        android:id="@+id/activity_main_edit_text"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:inputType="none"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_text_view" /&gt;</pre></li>
			</ol>
			<p>The complete<a id="_idIndexMarker1032"/> code for this step can be found at <a href="https://packt.link/8f854">https://packt.link/8f854</a>.</p>
			<ol>
				<li value="8">And finally, in <code>MainActivity</code>, perform the following steps:<pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val preferenceWrapper =
            (application as SettingsApplication)
            .settingsStore
        val preferenceViewModel =
            ViewModelProvider(this, object :
            ViewModelProvider.Factory {
                override fun &lt;T : ViewModel&gt;
                create(modelClass: Class&lt;T&gt;): T {
                    return SettingsViewModel(
                    preferenceWrapper) as T
            }
        }).get(SettingsViewModel::class.java)
    }
}</pre></li>
			</ol>
			<p>The complete code<a id="_idIndexMarker1033"/> for this step can be found at <a href="https://packt.link/gydeC">https://packt.link/gydeC</a>.</p>
			<p>If we now run the application, we should see the following screen:</p>
			<div><div><img src="img/B19411_12_02.jpg" alt="Figure 12.2 – Output of Exercise 12.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Output of Exercise 12.02</p>
			<p>If we enter a new text and click the <code>DataStore</code> will emit a new value for each change. We will look at flows and other reactive streams in future chapters.</p>
			<p>In this exercise, we have looked<a id="_idIndexMarker1034"/> at how the <code>DataStore</code> library works and its benefits, especially regarding streams of data. In the following chapters, we will continue to look at other ways of persistin<a id="_idTextAnchor655"/>g dat<a id="_idTextAnchor656"/>a, using files.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor657"/>Files</h1>
			<p>We’ve discussed<a id="_idIndexMarker1035"/> Room, <code>SharedPreferences</code>, and <code>DataStore</code> and specified how the data they store is written to files. You may ask yourself, where are these files stored? These particular files are stored in internal storage. Internal storage is a dedicated space for every app that other apps are unable to access (unless a device is rooted). There is no limit to the amount of storage your app can use.</p>
			<p>However, users have the ability to delete their app’s files from the <strong class="bold">Settings</strong> menu. Internal storage occupies a smaller part of the total available space, which means that you should be careful when it comes to storing files there. There is also external storage. The files your app stores in external storage are accessible to other apps and the files from other apps are accessible<a id="_idIndexMarker1036"/> to your one.</p>
			<p class="callout heading">Note</p>
			<p class="callout">In Android<a id="_idIndexMarker1037"/> Studio, you can use the <code>/data/data/{packageName}</code>. If you have access to this folder, this means that the device is rooted. Using this, you can visualize the database files and the <code>SharedPreferences</code> files.</p>
			<p>An example of how the <strong class="bold">Device File Explorer</strong> looks can be viewed in<a id="_idTextAnchor658"/> the following figure:</p>
			<div><div><img src="img/Image100608.jpg" alt="Figure 12.3 – Android’s Device File Explorer ﻿for an﻿ emulated device"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Android’s Device File Explorer <a id="_idTextAnchor659"/>for an<a id="_idTextAnchor660"/> emulated device</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor661"/>Internal storage</h2>
			<p>Internal storage<a id="_idIndexMarker1038"/> requires no permissions<a id="_idIndexMarker1039"/> from the user. To access the internal storage directories, you can use one of the following methods from the <code>Context</code> object:</p>
			<ul>
				<li><code>getDataDir()</code>: Returns the root folder of your application sandbox.</li>
				<li><code>getFilesDir()</code>: A dedicated folder for application files – recommended for usage.</li>
				<li><code>getCacheDir()</code>: A dedicated folder where files can be cached. Storing files here does not guarantee that you can retrieve them later because the system may decide to delete this directory to free up memory. This folder is linked to the <strong class="bold">Clear Cache</strong> option in <strong class="bold">Settings</strong>.</li>
				<li><code>getDir(name, mode)</code>: Returns a folder that will be created if it does not exist, based on the name specified.</li>
			</ul>
			<p>When users use the <strong class="bold">Clear Data</strong> option from <strong class="bold">Settings</strong>, most of these folders will be deleted, bringing the app<a id="_idIndexMarker1040"/> to a similar state as a fresh installation. When the app<a id="_idIndexMarker1041"/> is uninstalled, these files will be deleted as well.</p>
			<p>A typical example of reading a cache file is as follows:</p>
			<pre class="source code">
        val cacheDir = context.cacheDir
        val fileToReadFrom = File(cacheDir, "my-file.txt")
        val size = fileToReadFrom.length().toInt()
        val bytes = ByteArray(size)
        val tmpBuff = ByteArray(size)
        val fis = FileInputStream(fileToReadFrom)
        try {
            var read = fis.read(bytes, 0, size)
            if (read &lt; size) {
                var remain = size - read
                while (remain &gt; 0) {
                    read = fis.read(tmpBuff, 0, remain)
                    System.arraycopy(tmpBuff, 0, bytes,
                        size - remain, read)
                    remain -= read
                }
            }
        } catch (e: IOException) {
            throw e
        } finally {
            fis.close()
        }</pre>
			<p>The preceding example will read from <code>my-file.txt</code>, located in the <code>Cache</code> directory, and will create <code>FileInputStream</code> for that file. Then, a buffer will be used that will collect the bytes from the file. The collected<a id="_idIndexMarker1042"/> bytes will be placed in the <code>bytes</code> byte array, which will contain <a id="_idIndexMarker1043"/>all of the data read from that file. Reading will stop when the entire length of the file has been read.</p>
			<p>Writing to the <code>my-file.txt</code> file will look something like this:</p>
			<pre class="source code">
        val bytesToWrite = ByteArray(100)
        val cacheDir = context.cacheDir
        val fileToWriteIn = File(cacheDir, "my-file.txt")
        try {
            if (!fileToWriteIn.exists()) {
                fileToWriteIn.createNewFile()
            }
            val fos = FileOutputStream(fileToWriteIn)
            fos.write(bytesToWrite)
            fos.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }</pre>
			<p>What the preceding example does is take the byte array you want to write, create a new <code>File</code> object, create the file if it doesn’t exist, and write<a id="_idIndexMarker1044"/> the bytes into the file<a id="_idIndexMarker1045"/> through <code>FileOutputStream</code>.</p>
			<p class="callout heading">Note</p>
			<p class="callout">There are many alternatives to dealing with files. The readers (<code>StreamReader</code>, <code>StreamWriter</code>, and so on) are better equipped for character-based data. There are also third-party libraries that help with disk I/O operations. One of the most common third parties<a id="_idIndexMarker1046"/> that help with I/O operations is called <code>OkHttp</code> library, which is used in combination with Retrofit to make API calls. The methods provided by Okio are the same methods it uses to write and re<a id="_idTextAnchor662"/>ad dat<a id="_idTextAnchor663"/>a in HTTP communications.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor664"/>External storage</h2>
			<p>Reading and writing in external storage<a id="_idIndexMarker1047"/> requires user permission for reading<a id="_idIndexMarker1048"/> and writing. If write permission is granted, then your app has the ability to read the external storage. Once these permissions are granted, then your app can do whatever it pleases on the external storage.</p>
			<p>That may present a problem because users may not choose to grant these permissions. However, there are specialized methods that offer you the possibility to write to the external storage in folders dedicated to your application.</p>
			<p>Some of the most common ways of accessing external storage are from the <code>Context</code> and <code>Environment</code> objects:</p>
			<ul>
				<li><code>Context.getExternalFilesDir(mode)</code>: This method will return the path to the directory on the external storage dedicated to your application. Specifying different modes (pictures, movies, and so on) will create different subfolders, depending on how you want your files saved. This method <em class="italic">does not </em><em class="italic">require permissions</em>.</li>
				<li><code>Context.getExternalCacheDir()</code>: This will point toward an application’s cache directory on the external storage. The same considerations should be applied to this <code>cache</code> folder as to the internal storage option. This method <em class="italic">does not </em><em class="italic">require permissions</em>.</li>
				<li>The <code>Environment</code> class has access to paths of some of the most common folders on a device. However, on newer devices, apps may<a id="_idIndexMarker1049"/> not have access to those files<a id="_idIndexMarker1050"/> and folders.</li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Avoid using hardcoded paths to files and folders. The Android operating system may shift the location of folders around, dependin<a id="_idTextAnchor665"/>g on t<a id="_idTextAnchor666"/>he device or Android version.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor667"/>FileProvider</h2>
			<p>This represents<a id="_idIndexMarker1051"/> a specialized implementation of <code>ContentProviders</code> that is useful in organizing the file and folder structure of your application. It allows you to specify an XML file, in which you define how your files should be split between internal and external storage if you choose to do so. It also gives you the ability to grant access to other apps to your files by hiding the path and generating a unique URI to identify and query your file.</p>
			<p><code>FileProvider</code> lets you pick between six different folders, where you can set up your folder hierarchies:</p>
			<ul>
				<li><code>Context.getFilesDir()</code> (files-path)</li>
				<li><code>Context.getCacheDir()</code> (cache-path)</li>
				<li><code>Environment.getExternalStorageDirectory()</code> (external-path)</li>
				<li><code>Context.getExternalFilesDir(null)</code> (external-files-path)</li>
				<li><code>Context.getExternalCacheDir()</code> (external-cache-path)</li>
				<li>The first result of <code>Context.getExternalMediaDirs()</code> (external-media-path)</li>
			</ul>
			<p>The main benefits of <code>FileProvider</code> are the abstractions it provides in organizing your files while leaving a developer to define the paths in an XML file, and more importantly, if you choose to use it to store files in external storage, you do not have to ask for permissions from the user.</p>
			<p>Another benefit is the fact that it makes sharing of internal files easier while giving a developer control of what files other apps can access without exposing their real location.</p>
			<p>Let us understand better through the following example:</p>
			<pre class="source code">
&lt;paths
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;files-path name="my-visible-name" path="/
    my-folder-name" /&gt;
&lt;/paths&gt;</pre>
			<p>The preceding<a id="_idIndexMarker1052"/> example will make <code>FileProvider</code> use the internal <code>files</code> directory and create a folder named <code>my-folder-name</code>. When the path is converted to a URI, t<a id="_idTextAnchor668"/>hen the UR<a id="_idTextAnchor669"/>I will use <code>my-visible-name</code>.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor670"/>The Storage Access Framework (SAF)</h2>
			<p>The SAF is a file picker introduced in Android KitKat<a id="_idIndexMarker1053"/> that apps can use for their users<a id="_idIndexMarker1054"/> to pick files, with a view to them being processed or uploaded. You can use it in your app in the following scenarios:</p>
			<ul>
				<li>Your app requires a user to process a file saved on a device by another app (photos and videos)</li>
				<li>You want to save a file on a device and give a user the choice of where to save the file and the name of the file</li>
				<li>You want to offer the files your application uses to other apps for scenarios similar to the first scenario in this list</li>
			</ul>
			<p>This is again useful because your app will avoid read and write permissions and still write and access external storage. The way this works is based on intents. You can register for an activity result for <code>GetDocument</code> or <code>CreateDocument</code>. Then, in the activity result callback, the system will give you a URI that grants you temporary permissions to that file, allowing you to read and write.</p>
			<p>Another benefit of the SAF is the fact that files don’t have to be on a device. Apps such as Google Drive expose their content in the SAF, and when a Google Drive file is selected, it will be downloaded to the device and the URI will be sent as a result.</p>
			<p>Another important thing to mention is the SAF’s support for virtual files, meaning that it will expose Google docs, which have their own format, but when those docs are downloaded through the SAF, their formats<a id="_idIndexMarker1055"/> will be c<a id="_idTextAnchor671"/>onvert<a id="_idTextAnchor672"/>ed to a common format<a id="_idIndexMarker1056"/> such as PDF.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor673"/>Asset files</h2>
			<p><code>assets</code> folder inside your project. You can then group your files inside your assets using folders.</p>
			<p>You can access these files at runtime through the <code>AssetManager</code> class, which itself can be accessed through the context object. <code>AssetManager</code> offers you the ability to look up the files and read them, but it does not permit any write operations:</p>
			<pre class="source code">
        val assetManager = context.assets
        val root = ""
        val files = assetManager.list(root)
        files?.forEach {
            val inputStream = assetManager.open(root + it)
        }</pre>
			<p>The preceding example lists all files inside the root of the <code>assets</code> folder. The <code>open</code> function returns <code>inputStream</code>, which can be used to read the file information if necessary.</p>
			<p>One common usage of the <code>assets</code> folder is for custom fonts. If your application uses custom fonts, then you can<a id="_idTextAnchor674"/> use the <code>assets</code> folder to store font files.</p>
			<p class="callout heading">Note</p>
			<p class="callout">For the following exercise, you will need an emulator. You can do so by selecting <strong class="bold">Tools</strong> | <strong class="bold">AVD Manager</strong> in Android Studio. Then, you can create one with the <strong class="bold">Create Virtual Device</strong> option, selecting the type of emulator, clicking <strong class="bold">Next</strong>, and then selecting an x86 image. Any image larger than Lollipop should be acceptable for this exercise. Next, you can giv<a id="_idTextAnchor675"/>e your image a name and click <strong class="bold">Finish</strong>.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor676"/>Exercise 12.03 – copying files</h2>
			<p>Let’s create an app<a id="_idIndexMarker1059"/> that will keep a file named <code>my-app-file.txt</code> in the <code>assets</code> directory. The app will display two buttons called <code>FileProvider</code> and <code>SAF</code>. When the <code>FileProvider</code> button is clicked, the file will be saved on the external storage inside the app’s external storage dedicated area (<code>Context.getExternalFilesDir(null)</code>). The <code>SAF</code> button will open the SAF and allow a user to indicate where the file should be saved.</p>
			<p>In order to implement this exercise, follow these steps:</p>
			<ol>
				<li>Define a file provider that will use the <code>Context.getExternalFilesDir(null)</code> location.</li>
				<li>Copy <code>my-app-file.txt</code> to the preceding location when the <code>FileProvider</code> button is clicked.</li>
				<li>Use <code>Intent.ACTION_CREATE_DOCUMENT</code> when the <code>SAF</code> button is clicked and copy the file to the location provided.</li>
				<li>Use a separate thread for the file copy to comply with the Android guidelines.</li>
				<li>Use the Apache IO library to help with the file copy functionality, by providing methods that allow us to copy data from <code>InputStream</code> to <code>OutputStream</code>.</li>
			</ol>
			<p>The steps for completion are as follows:</p>
			<ol>
				<li>Create a new Android Studio project with an empty activity.</li>
				<li>Let’s start with our Gradle configuration:<pre class="source code">
    implementation 'commons-io:commons-io:2.6'</pre></li>
				<li>Create the <code>my-app-file.txt</code> file in the <code>main/assets</code> folder. Feel free to fill it up with the text you want to be read. If the <code>main/assets</code> folder doesn’t exist, then you can create it. To create the <code>assets</code> folder, you can right-click on the <code>main</code> folder, select <code>assets</code>.</li>
			</ol>
			<p>This folder will now be recognized<a id="_idIndexMarker1060"/> by the build system, and any file inside it will also be installed on the device along with the app. You may need to switch <strong class="bold">Project View</strong> from <strong class="bold">Android</strong> to <strong class="bold">Project</strong> to be able to view this file structure.</p>
			<ol>
				<li value="4">We can also define a class that will wrap <code>AssetManager</code> in the <code>main/java</code> folder in the root package and define a method to access this particular file:<pre class="source code">
class AssetFileManager(private val assetManager:
AssetManager) {
    fun getMyAppFileInputStream() =
        assetManager.open("my-app-file.txt")
}</pre></li>
				<li>Now, let’s work on the <code>FileProvider</code> aspect. Create the <code>xml</code> folder in the <code>res</code> folder. Define <code>file_provider_paths.xml</code> inside the new folder. We will define <code>external-files-path</code>, name it <code>docs</code>, and place it in the <code>docs/</code> folder:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;paths&gt;
    &lt;external-files-path name="docs" path="docs/"/&gt;
&lt;/paths&gt;</pre></li>
				<li>Next, we need to add <code>FileProvider</code> to the <code>AndroidManifest.xml</code> file and link it with the new path we defined inside the <code>&lt;</code><code>application</code> tag:<pre class="source code">
        &lt;provider
            android:name=
                "androidx.core.content.FileProvider"
            android:authorities=
                "com.android.testable.files"
            android:exported="false"
            android:grantUriPermissions="true"&gt;
            &lt;meta-data
                android:name="android.support
                    .FILE_PROVIDER_PATHS"
                android:resource="@xml/
                    file_provider_paths" /&gt;
        &lt;/provider&gt;</pre></li>
			</ol>
			<p>The name will point to the <code>FileProvider</code> path that’s part<a id="_idIndexMarker1061"/> of the Android Support Library. The <code>authorities</code> field represents the domain your application has (usually the package name of the application).</p>
			<p>The exported field indicates whether we wish to share our provider with other apps, and <code>grantUriPermissions</code> indicates whether we wish to grant other applications access to certain files through the URI. The metadata links the XML file we defined previously with <code>FileProvider</code>.</p>
			<ol>
				<li value="7">Define the <code>ProviderFileManager</code> class in the <code>main/java</code> folder in the root package, which is responsible for accessing the <code>docs</code> folder and writing data into the file:<pre class="source code">
class ProviderFileManager(
<strong class="bold">) {</strong>
<strong class="bold">    fun writeStream(name: String, inputStream:</strong>
<strong class="bold">    InputStream) {</strong>
<strong class="bold">        executor.execute {</strong>
<strong class="bold">            val fileToSave = File(getDocsFolder(),</strong>
<strong class="bold">            name)</strong>
<strong class="bold">            val outputStream =</strong>
<strong class="bold">                context.contentResolver</strong>
<strong class="bold">                .openOutputStream(fileToUriMapper</strong>
<strong class="bold">                .getUriFromFile(context, fileToSave),</strong>
<strong class="bold">                "rw")</strong>
<strong class="bold">            IOUtils.copy(inputStream, outputStream)</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/Gp0Ph">https://packt.link/Gp0Ph</a>.</p>
			<p><code>getDocsFolder</code> will return<a id="_idIndexMarker1062"/> the path to the <code>docs</code> folder we defined in the XML. If the folder does not exist, then it will be created.</p>
			<p>The <code>writeStream</code> method will extract the URI for the file we wish to save and, using the Android <code>ContentResolver</code> class, will give us access to the <code>OutputStream</code> class of the file we will be saving in. Note that <code>FileToUriMapper</code> doesn’t exist yet. The code is moved into a separate class in order to make this class testable.</p>
			<ol>
				<li value="8">Create the <code>FileToUriMapper</code> class in the <code>main/java</code> folder in the root package:<pre class="source code">
class FileToUriMapper {
    fun getUriFromFile(context: Context, file: File):
    Uri {
        <strong class="bold">return FileProvider.getUriForFile(context,</strong>
<strong class="bold">        "com.android.testable.files", file)</strong>
    }
}</pre></li>
			</ol>
			<p>The <code>getUriForFile</code> method is part of the <code>FileProvider</code> class, and its role is to convert the path of a file into a URI that can be used by <code>ContentProviders</code> and <code>ContentResolvers</code> to access data. Because the method is static, it prevents us from testing properly.</p>
			<ol>
				<li value="9">Make sure that the following<a id="_idIndexMarker1063"/> strings are added to <code>strings.xml</code>:<pre class="source code">
    &lt;string name="file_provider"&gt;FileProvider&lt;/string&gt;
    &lt;string name="saf"&gt;SAF&lt;/string&gt;</pre></li>
				<li>Let’s now move on to defining our UI for the <code>activity_main.xml</code> file in the <code>res/layout</code> folder:<pre class="source code">
    &lt;Button
        android:id="@+id/activity_main_file_provider"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="200dp"
        android:text="@string/file_provider"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;Button
        android:id="@+id/activity_main_saf"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        android:text="@string/saf"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_file_provider" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/Pw37X">https://packt.link/Pw37X</a>.</p>
			<ol>
				<li value="11">Now, let’s define<a id="_idIndexMarker1064"/> our <code>MainActivity</code> class in the <code>main/java</code> folder in the root package:<pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById&lt;Button&gt;(
        R.id.activity_main_file_provider)
        .setOnClickListener {
            val newFileName = "Copied.txt"
<strong class="bold">            providerFileManager.writeStream(</strong>
<strong class="bold">                newFileName, assetFileManager</strong>
<strong class="bold">                .getMyAppFileInputStream())</strong>
        }
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/FBXgY">https://packt.link/FBXgY</a>.</p>
			<p>For this example, we chose <code>MainActivity</code> to create our objects and inject data into the different<a id="_idIndexMarker1065"/> classes we have. If we execute this code and click the <code>FileProvider</code> button, we don’t see an output on the UI.</p>
			<p>However, if we look at Android’s <strong class="bold">Device File Explorer</strong>, we can locate where the file was saved. The path may be different on different devices and operating systems. The paths could be as follows:</p>
			<ul>
				<li><code>mnt/sdcard/Android/data/&lt;package_name&gt;/files/docs</code></li>
				<li><code>sdcard/Android/data/&lt;package_name&gt;/files/docs</code></li>
				<li><code>storage/emulated/0/Android/data/&lt;packag<a id="_idTextAnchor677"/>e_name&gt;/files/docs</code></li>
			</ul>
			<p>The output will be as follows:</p>
			<div><div><img src="img/B19411_12_04.jpg" alt="Figure 12.4 – Output of copy through FileProvider"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Output of copy through FileProvider</p>
			<ol>
				<li value="12">Let’s add the logic for the <code>SAF</code> button. We will need<a id="_idIndexMarker1066"/> to start an activity pointing toward <code>SAF</code> with the <code>CREATE_DOCUMENT</code> intent, in which we specify that we want to create a text file.</li>
			</ol>
			<p>We will then need the result of <code>SAF</code> so that we can copy the file to the location selected by a user. In <code>MainActivity</code> in <code>onCreate</code>, we can add the following:</p>
			<pre class="source code">
      val createDocumentResult =
          registerForActivityResult(
          ActivityResultContracts.CreateDocument(
          "text/plain")) { uri -&gt;
              uri?.let {
                  val newFileName = "Copied.txt"
                  providerFileManager
                  .writeStreamFromUri(newFileName,
                  assetFileManager
                  .getMyAppFileInputStream(), uri)
              }
            }
        findViewById&lt;Button&gt;(R.id.activity_main_saf)
        .setOnClickListener {
            createDocumentResult.launch("Copied.txt")
        }</pre>
			<p>What the preceding code<a id="_idIndexMarker1067"/> will do is register for an <code>Activity</code> result when a user creates a new file. We will then invoke <code>writeStreamFromUri</code> from <code>ProviderFileManager</code> to save the contents from the file in the <code>assets</code> folder in the file created by the user. When the button is clicked, we will then launch the file creation screen from the SAF.</p>
			<ol>
				<li value="13">We now have the URI. We can add a method to <code>ProviderFileManager</code> that will copy our file to a location given by <code>uri</code>:<pre class="source code">
    fun writeStreamFromUri(name: String, inputStream:
    InputStream, uri:Uri){
        executor.execute {
            val outputStream =
                context.contentResolver
                .openOutputStream(uri, "rw")
            IOUtils.copy(inputStream, outputStream)
        }
    }</pre></li>
			</ol>
			<p>If we run the preceding code and click on the <strong class="bold">SAF</strong> button<a id="_idTextAnchor678"/>, we will see the output presented in <em class="italic">Figure 12</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B19411_12_05.jpg" alt="Figure 12.5 – Output of copy through the SAF"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Output of copy through the SAF</p>
			<p>If you choose to save the file, the SAF will be closed and the callback from <code>registerForActivityResult</code> will be invoked, which will trigger the file copy. Afterward, you can navigate the Android Device File Manage<a id="_idTextAnchor679"/><a id="_idTextAnchor680"/>r<a id="_idIndexMarker1068"/> tool to see whether the file was saved properly.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor681"/>Scoped storage</h1>
			<p>Since Android 10 and with further<a id="_idIndexMarker1069"/> updates in Android 11, the notion of scoped storage was introduced. The main idea behind this is to allow apps to gain more control of their files in external storage and prevent other apps from accessing these files.</p>
			<p>The consequences of this mean that <code>READ_EXTERNAL_STORAGE</code> and <code>WRITE_EXTERNAL_STORAGE</code> will only apply to files a user interacts with (such as media files). This discourages apps from creating their own directories in external storage, instead sticking with the one already provided to them through <code>Context.getExternalFilesDir</code>.</p>
			<p>FileProviders and the SAF are a good way of making your app comply with scoped storage practices, with one allowing the app to use <code>Context.getExternalFilesDir</code> and the other using the built-in File Explorer app, which will now avoid files from other applications in the <code>Andro<a id="_idTextAnchor682"/>id/data</code> <a id="_idTextAnchor683"/>and <code>Android/obb</code> folders<a id="_idIndexMarker1070"/> in external storage.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor684"/>Camera and media storage</h2>
			<p>Android offers a variety of ways<a id="_idIndexMarker1071"/> to interact with media on its devices, from building<a id="_idIndexMarker1072"/> your own camera application and controlling how users take<a id="_idIndexMarker1073"/> photos and videos to using an existing camera application<a id="_idIndexMarker1074"/> and instructing it on how to take photos and videos.</p>
			<p>Android also comes with a <code>MediaStore</code> content provider, allowing applications to extract information about media files that are set on a device and shared between applications.</p>
			<p>This is useful in situations where you want a custom display for media files that exist on a device (such as a photo or music player application) and in situations where you use the <code>MediaStore.ACTION_PICK</code> intent to select a photo from the device and want to extract the information about the selected media image (this is usually the case for older applications where the SAF cannot be used).</p>
			<p>In order to use an existing camera application, you will need to use the <code>MediaStore.ACTION_IMAGE_CAPTURE</code> intent to start a camera application for a result and pass the URI of the image you wish to save. The user will then go to the camera activity and take the photo, and then you handle the result of the operation:</p>
			<pre class="source code">
        val imageCaptureLauncher =
            registerForActivityResult(
            ActivityResultContracts.TakePicture()){
            }
        imageCaptureLauncher.launch(photoUri)</pre>
			<p>The <code>photoUri</code> parameter will represent the location of where you want your photo to be saved. It should point to an empty file with a JPEG extension. You can build this file in two ways:</p>
			<ul>
				<li>Create a file on the external storage using the <code>File</code> object (this requires the <code>WRITE_EXTERNAL_STORAGE</code> permission) and then use the <code>Uri.fromFile()</code> method to convert it into <code>URI</code> (this is no longer applicable on Android 10 and above)</li>
				<li>Create a file in a <code>FileProvider</code> location using the <code>File</code> object, and then use the <code>FileProvider.getUriForFile()</code> method to obtain the URI and grant it permissions if necessary (the recommended approach for when your app targets Android 10 and Android 11)</li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">The same mechanism can be applied to videos using <code>MediaStore.ACTION_VIDEO_CAPTURE</code>.</p>
			<p>If your application relies<a id="_idIndexMarker1075"/> heavily on camera<a id="_idIndexMarker1076"/> features, then you<a id="_idIndexMarker1077"/> can exclude the application<a id="_idIndexMarker1078"/> from users whose devices don’t have cameras by adding the <code>&lt;uses-feature&gt;</code> tag to the <code>AndroidManifest.xml</code> file. You can also specify the camera as non-required and query whether the camera is available using the <code>Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)</code> method.</p>
			<p>If you wish to have your file saved in <code>MediaStore</code>, there are multiple ways to achieve this:</p>
			<ol>
				<li>Send an <code>ACTION_MEDIA_SCANNER_SCAN_FILE</code> broadcast with the URI of your media:<pre class="source code">
      val intent = Intent(Intent.ACTION_MEDIA_SCANNER_
      SCAN_FILE)
      intent.data = photoUri
      sendBroadcast(intent)</pre></li>
				<li>Use the media scanner to scan files directly:<pre class="source code">
        val paths = arrayOf("path1", "path2")
        val mimeTypes= arrayOf("type1", "type2")
        MediaScannerConnection.scanFile(context,paths,
            mimeTypes) { path, uri -&gt;
        }</pre></li>
				<li>Insert<a id="_idIndexMarker1079"/> the media<a id="_idIndexMarker1080"/> into <code>ContentProvider</code> directly<a id="_idIndexMarker1081"/> using<a id="_idIndexMarker1082"/> <code>ContentResolver</code>:<pre class="source code">
        val contentValues = ContentValues()
        contentValues.put(MediaStore.Images
            .ImageColumns.TITLE, "my title")
        contentValues.put(MediaStore.Images
            .ImageColumns .DATE_ADDED, timeInMillis)
        contentValues.put(MediaStore.Images
            .ImageColumns .MIME_TYPE, "image/*")
        contentValues.put(MediaStore.Images
            .ImageColumns .DATA, "my-path")
        val newUri =
            contentResolver.insert(MediaStore.Video
            .Media.EXTERNAL_CONTENT_URI,
            contentValues)
newUri?.let {
    val outputStream = contentResolver
    .openOutputStream(newUri)
    // Copy content in outputstream
}</pre></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The <code>MediaScanner</code> functionality no longer adds files from <code>Context.getExternal</code><strong class="source inline">
FilesDir</strong> in Android 10 and above. Apps should rely on the <code>insert</code> method i<a id="_idTextAnchor685"/>nstead i<a id="_idTextAnchor686"/>f they choose to share their media files with other apps.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor687"/>Exercise 12.04 – taking photos</h2>
			<p>We’re going to build<a id="_idIndexMarker1083"/> an application<a id="_idIndexMarker1084"/> that has two buttons; the first button will open a camera app<a id="_idIndexMarker1085"/> to take a photo, and the second button will open the camera app to record a video. We will use <code>FileProvider</code> to save the photos to external storage (external-path) in two folders, <code>pictures</code> and <code>movies</code>.</p>
			<p>The photos will be saved using <code>img_{timestamp}.jpg</code>, and the videos will be saved using <code>video_{timestamp}.mp4</code>. After a photo and video have been saved, you will copy the file from <code>FileProvider</code> into <code>MediaStore</code> so that they will be visible for other apps:</p>
			<ol>
				<li>Create a new Android Studio project with an empty activity.</li>
				<li>Let’s add the libraries in <code>app/build.gradle</code>:<pre class="source code">
    implementation 'commons-io:commons-io:2.6'</pre></li>
				<li>We will need to request the <code>WRITE_EXTERNAL_STORAGE</code> permission for devices that predate Android 10, which means we need the following in <code>AndroidManifest.xml</code> outside of the <code>&lt;</code><code>application</code> tag:<pre class="source code">
&lt;uses-permission
    android:name="android.permission
    .WRITE_EXTERNAL_STORAGE"
    android:maxSdkVersion="28" /&gt;</pre></li>
				<li>Let’s define a <code>FileHelper</code> class, which will contain methods that are harder to test in the <code>test</code> folder in the root package:<pre class="source code">
class FileHelper(private val context: Context) {
    fun getUriFromFile(file: File): Uri {
        return FileProvider.getUriForFile(context,
        "com.android.testable.camera", file)
    }
    fun getPicturesFolder(): String =
        Environment.DIRECTORY_PICTURES
    fun getVideosFolder(): String =
        Environment.DIRECTORY_MOVIES
}</pre></li>
				<li>Let’s define our <code>FileProvider</code> paths in <code>res/xml/file_provider_paths.xml</code>. Make sure<a id="_idIndexMarker1086"/> to include the appropriate package name<a id="_idIndexMarker1087"/> for your<a id="_idIndexMarker1088"/> application in <code>FileProvider</code>:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;paths&gt;
    &lt;external-path
        name="photos"
        path="Android/data/com.android.testable
        .myapplication/files/Pictures" /&gt;
    &lt;external-path
        name="videos"
        path="Android/data/com.android.testable
        .myapplication/files/Movies" /&gt;
&lt;/paths&gt;</pre></li>
			</ol>
			<p>Let’s add the file provider paths to the <code>AndroidManifest.xml</code> file inside the <code>&lt;</code><code>application</code> tag:</p>
			<pre class="source code">
        &lt;provider
            android:name=
                "androidx.core.content.FileProvider"
            android:authorities=
                "com.android.testable.camera"
            android:exported="false"
            android:grantUriPermissions="true"&gt;
            &lt;meta-data
                android:name="android.support
                .FILE_PROVIDER_PATHS"
                android:resource="@xml/
                file_provider_paths" /&gt;
        &lt;/provider&gt;</pre>
			<ol>
				<li value="6">Let’s now define a model<a id="_idIndexMarker1089"/> that will hold<a id="_idIndexMarker1090"/> both <code>Uri</code> and the associated path for a file in the <code>main/java</code> folder in the root<a id="_idIndexMarker1091"/> package:<pre class="source code">
data class FileInfo(
    val uri: Uri,
    val file: File,
    val name: String,
    val relativePath:String,
    val mimeType:String
)</pre></li>
				<li>Let’s create a <code>ContentHelper</code> class in the <code>main/java</code> folder in the root package, which will provide us with the data required for <code>ContentResolver</code>. We will define two methods for accessing the photo and video content URI and two methods that will create <code>ContentValues</code>.</li>
			</ol>
			<p>We do this because of the static methods required to obtain URIs and create <code>ContentValues</code>, which makes<a id="_idIndexMarker1092"/> this functionality hard to test. The following code is truncated for space. The full code<a id="_idIndexMarker1093"/> you need to add can be found via the link that follows<a id="_idIndexMarker1094"/> this code block:</p>
			<pre class="source code">
    class MediaContentHelper {
        fun getImageContentUri(): Uri =
            if (android.os.Build.VERSION.SDK_INT &gt;=
            android.os.Build.VERSION_CODES.Q) {
                MediaStore.Images.Media.getContentUri
                (MediaStore.VOLUME_EXTERNAL_PRIMARY)
            } else {
                MediaStore.Images.Media
                .EXTERNAL_CONTENT_URI
            }
        fun generateImageContentValues(fileInfo:
        FileInfo) = ContentValues().apply {
            this.put(MediaStore.Images.Media
            .DISPLAY_NAME, fileInfo.name)
        if (android.os.Build.VERSION.SDK_INT &gt;=
            android.os.Build.VERSION_CODES.Q) {
                this.put(MediaStore.Images.Media
                .RELATIVE_PATH, fileInfo.relativePath)
        }
        this.put(MediaStore.Images.Media .MIME_TYPE,
            fileInfo.mimeType)
    }</pre>
			<p>The complete code for this step can be found at <a href="https://packt.link/DhOLR">https://packt.link/DhOLR</a>.</p>
			<ol>
				<li value="8">Now, let’s create the <code>ProviderFileManager</code> class in the <code>main/java</code> folder in the root<a id="_idIndexMarker1095"/> package, where we will define methods to generate files for photos and videos that will then be used<a id="_idIndexMarker1096"/> by the camera and the methods that will save<a id="_idIndexMarker1097"/> to the media store. Again, the code has been truncated for brevity. Please see the link that follows this code block for the full code that you need to use:<pre class="source code">
    class ProviderFileManager(
    ) {
        fun generatePhotoUri(time: Long): FileInfo {
            val name = "img_$time.jpg"
            val file = File(
                context.getExternalFilesDir(
                fileHelper .getPicturesFolder()), name
            )
            return FileInfo(
                fileHelper.getUriFromFile(file),
                file, name,
                fileHelper.getPicturesFolder(),
                "image/jpeg"
            )
        }</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/ohv7a">https://packt.link/ohv7a</a>.</p>
			<p>Note how we defined the root folders as <code>context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</code> and <code>context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)</code>. This connects to <code>file_provider_paths.xml</code> and it will create a set of folders called <code>Movies</code> and <code>Pictures</code> in the application’s dedicated folder in external storage. The <code>insertToStore</code> method is where the files will be then copied to the <code>MediaStore</code>.</p>
			<p>First, we will create an entry<a id="_idIndexMarker1098"/> into that store that will give us a URI<a id="_idIndexMarker1099"/> for that entry. Next, we copy<a id="_idIndexMarker1100"/> the contents of the files from the URI generated by <code>FileProvider</code> into <code>OutputStream</code>, pointing to the <code>MediaStore</code> entry.</p>
			<ol>
				<li value="9">Add the following strings to <code>strings.xml</code>:<pre class="source code">
    &lt;string name="photo"&gt;Photo&lt;/string&gt;
    &lt;string name="video"&gt;Video&lt;/string&gt;</pre></li>
				<li>Let’s define the layout for our activity in <code>res/layout/activity_main.xml</code>:<pre class="source code">
    &lt;Button
        android:id="@+id/photo_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/photo" /&gt;
    &lt;Button
        android:id="@+id/video_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:text="@string/video" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/6iSNp">https://packt.link/6iSNp</a>.</p>
			<ol>
				<li value="11">Let’s create the <code>MainActivity</code> class in the <code>main/java</code> folder in the root package, where we<a id="_idIndexMarker1101"/> will check whether<a id="_idIndexMarker1102"/> we need to request <code>WRITE_STORAGE_PERMISSION</code>, request it if we need to, and after it is granted, open the camera to take<a id="_idIndexMarker1103"/> a photo or a video. As before, the code here has been truncated for brevity. You can access the full code using the link<a id="_idIndexMarker1104"/> that follows<a id="_idIndexMarker1105"/> the code<a id="_idIndexMarker1106"/> block:<pre class="source code">
class MainActivity : AppCompatActivity() {
        private lateinit var providerFileManager:
            ProviderFileManager
        private var photoInfo: FileInfo? = null
        private var videoInfo: FileInfo? = null
        private var isCapturingVideo = false
    override fun onCreate(savedInstanceState:
    Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        providerFileManager =
            ProviderFileManager(applicationContext,
            FileHelper(applicationContext),
            contentResolver, Executors
            .newSingleThreadExecutor(),
            MediaContentHelper()
            )</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/YeHWC">https://packt.link/YeHWC</a>.</p>
			<p>If we execute<a id="_idIndexMarker1107"/> the preceding<a id="_idIndexMarker1108"/> code, we will<a id="_idIndexMarker1109"/> see the following:</p>
			<div><div><img src="img/B19411_12_06.jpg" alt="Figure 12.6 – Output of Exercise 12.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Output of Exercise 12.04</p>
			<ol>
				<li value="12">By clicking on either of the buttons, you will be redirected to the camera application, where you can take a photo or a video if you are running the example on Android 10 and above. If you’re running on lower Android versions, then the permissions will be asked first.</li>
			</ol>
			<p>Once you have taken your photo<a id="_idIndexMarker1110"/> and confirmed<a id="_idIndexMarker1111"/> it, you will be taken b<a id="_idTextAnchor688"/>ack to the application. The photo will be saved in the location you defined in <code>FileProvider</code>:</p>
			<div><div><img src="img/B19411_12_07.jpg" alt="Figure 12.7 – The location of the captured files through the camera app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – The location of the captured files through the camera app</p>
			<p>In the preceding screenshot, you can see where<a id="_idIndexMarker1112"/> the files are located with the help<a id="_idIndexMarker1113"/> of Android<a id="_idIndexMarker1114"/> Studio’s <strong class="bold">Device File Explorer</strong>. If you open any file-exploring app, such as th<a id="_idTextAnchor689"/>e <strong class="bold">Files</strong>, <strong class="bold">Gallery</strong>, or <strong class="bold">Google Photos</strong> app, you will be able to see the vide<a id="_idTextAnchor690"/>os and pic<a id="_idTextAnchor691"/>tures taken.</p>
			<div><div><img src="img/B19411_12_08.jpg" alt="Figure 12.8 – The files from the app present in the File Explorer app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – The files from the app present in the File Explorer app</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor692"/>Activity 12.01 – dog downloader</h2>
			<p>You are tasked with building<a id="_idIndexMarker1115"/> an application that will target Android versions above API 21 and<a id="_idIndexMarker1116"/> display a list of URLs for dog photos. The URL you will connect to is <code>https://dog.ceo/api/breed/hound/images/random/{number}</code>, where <code>number</code> will be controlled through a <strong class="bold">Settings</strong> screen, where a user can choose the number of URLs they want to be displayed.</p>
			<p>The <strong class="bold">Settings</strong> screen will be opened through an option presented on the home screen. When a user clicks on a URL, an image will be downloaded locally in the application’s external cache path. While the image is being downloaded, the user will see an indeterminate progress bar. The list of URLs will be persisted locally using Room.</p>
			<p>The technologies that we will use are the following:</p>
			<ul>
				<li>Retrofit to retrieve the list of URLs and download files</li>
				<li>Room to persist the list of URLs</li>
				<li><code>SharedPreferences</code> to store the number of URLs to retrieve</li>
				<li><code>FileProvider</code> to store the files in the cache</li>
				<li>Apache IO to write the files</li>
				<li>Repository to combine all the data sources</li>
				<li><code>LiveData</code> and <code>ViewModel</code> to handle the logic from the user</li>
				<li><code>RecyclerView</code> for the list of items</li>
			</ul>
			<p>The response JSON <a id="_idIndexMarker1117"/>will look similar<a id="_idIndexMarker1118"/> to this:</p>
			<pre class="source code">
{
    "message": [
        "https://images.dog.ceo/breeds/hound-
        afghan/n02088094_4837.jpg",
        "https://images.dog.ceo/breeds/hound-
        basset/n02088238_13908.jpg",
        "https://images.dog.ceo/breeds/hound-
        ibizan/n02091244_3939.jpg"
    ],
    "status": "success"
}</pre>
			<p>Perform the following steps to complete this activity:</p>
			<ol>
				<li>Create an <code>api</code> package that will contain the network-related classes.</li>
				<li>Create a data class that will model the response JSON.</li>
				<li>Create a Retrofit <code>Service</code> class that will contain two methods. The first method will represent the API call to return a list of breeds, and the second method will represent the API call to download the file.</li>
				<li>Create a <code>storage</code> package, and inside it, create a <code>room</code> package.</li>
				<li>Create the <code>Dog</code> entity, which will contain an autogenerated ID and a URL.</li>
				<li>Create the <code>DogDao</code> class, which will contain methods to insert a list of <code>Dogs</code>, delete all <code>Dogs</code>, and query all <code>Dogs</code>. The <code>delete</code> method is required because the API model does not have any unique identifiers.</li>
				<li>Inside the <code>storage</code> package, create a <code>preference</code> package.</li>
				<li>Inside the <code>preference</code> package, create<a id="_idIndexMarker1119"/> a wrapper class around <code>SharedPreferences</code> that will return the number of URLs we need to use and set<a id="_idIndexMarker1120"/> the number. The default will be <code>10</code>.</li>
				<li>In <code>res/xml</code>, define your folder structure for <code>FileProvider</code>. The files should be saved in the root folder of the <code>external-cache-path</code> tag.</li>
				<li>Inside the <code>storage</code> package, create a <code>filesystem</code> package.</li>
				<li>Inside the <code>filesystem</code> package, define a class that will be responsible for writing <code>InputStream</code> into a file in <code>FileProvider</code>, using <code>Context.externalCacheDir</code>.</li>
				<li>Create a <code>repository</code> package.</li>
				<li>Inside the <code>repository</code> package, create a sealed class that will hold the result of an API call. The subclasses of the sealed class will be <code>Success</code>, <code>Error</code>, and <code>Loading</code>.</li>
				<li>Define a <code>Repository</code> interface that will contain two methods, one to load the list of URLs and the other to download a file.</li>
				<li>Define a <code>DogUi</code> model class that will be used in the UI layer of your application and that will be created in your repository.</li>
				<li>Define a mapper class that will convert your API models into entities and entities into UI models.</li>
				<li>Define an implementation for <code>Repository</code> that will implement the preceding two methods. The repository will hold references to <code>DogDao</code>, the Retrofit <code>Service</code> class, the <code>Preferences</code> wrapper class, the class managing the files, the <code>Dog</code> mapping class, and the <code>Executor</code> class for multithreading. When downloading the files, we will use the filename extracted from the URL.</li>
				<li>Create a class that will extend <code>Application</code>, which will initialize the repository.</li>
				<li>Define the <code>ViewModel</code> class used by your UI, which will have a reference to <code>Repository</code> and call it to load the URL list and download the images.</li>
				<li>Define your UI, which will be composed of two activities:<ul><li><code>MainActivity</code> which displays the list of URLs and will have a click action to start the downloads. This activity will have a progress bar, which will be displayed when the download takes place. The screen will also have a <code>SettingsActivity</code>.</li><li>The <code>SettingsActivity</code>, which<a id="_idIndexMarker1121"/> will display <code>EditText</code> and <code>Button</code> and save the number<a id="_idIndexMarker1122"/> of URLs.</li></ul></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/z6g5j">https://packt.link/z6g5j</a>.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor693"/>Summary</h1>
			<p>In this chapter, we analyzed alternatives to Room when it comes to persisting data. We looked first at <code>SharedPreferences</code> and how it constitutes a handy solution for data persistence when it’s in a key-value format and the amount of data is small. We also looked at <code>DataStore</code> and how we can use it like <code>SharedPreferences</code> but with built-in observability, which notifies us when values are changed.</p>
			<p>Next, we looked over something that was continuously changing when it comes to the Android framework – the evolution of abstractions regarding a filesystem. We started with an overview of the types of storage that Android has and then took a more in-depth look at two of the abstractions – <code>FileProvider</code>, which your app can use to store files on a device and share them with others if necessary, and the SAF, which can be used to save files on the device in a location selected by a user.</p>
			<p>We also used the benefits of <code>FileProvider</code> to generate URIs for files in order to use camera applications to take photos and record videos, saving them in the application’s files while also adding them to <code>MediaStore</code>.</p>
			<p>The activity performed in this chapter combines all the elements discussed previously to illustrate the point that even though you have to balance multiple sources inside an application, you can do it in a more readable way.</p>
			<p>Note that for the activity and exercises in this chapter and the previous one, we kept having to use the <code>application</code> class to instantiate the data sources. In the next chapter, you will lea<a id="_idTextAnchor694"/>rn how to overcome this through dependency injection and see how it can benefit Android applications.</p>
		</div>
	</body></html>