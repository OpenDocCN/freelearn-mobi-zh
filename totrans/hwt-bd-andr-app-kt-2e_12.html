<html><head></head><body>
		<div id="_idContainer202">
			<h1 id="_idParaDest-190" class="chapter number"><a id="_idTextAnchor638"/>12</h1>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor639"/>Persisting Data</h1>
			<p><a id="_idTextAnchor640"/>This chapter goes in depth about data persistence in Android. By the end of the chapter, you will know multiple ways to store (persist) data directly on a device and the frameworks accessible to do this. When dealing with a filesystem, you will know how it’s partitioned and how you can read and write files in different locations and use <span class="No-Break">different frameworks.</span></p>
			<p><a id="_idTextAnchor641"/>In the previous chapter, you learned how to structure your code and save data. In the activity, you also had the opportunity to build a repository and use it to access and save data through Room. In this chapter, you will learn about alternative ways to persist data on a device through the Android filesystem and how it’s structured into external and <span class="No-Break">internal memory.</span></p>
			<p>You’ll also develop your understanding of read and write permissions, learn how to create the <strong class="source inline">FileProvider</strong> class to offer other apps access to your files, and learn how you can save those files without requesting permissions on external drives. You’ll also see how to download files from the internet and save them on <span class="No-Break">a filesystem.</span></p>
			<p>Another concept that will be explored in this chapter is using the <strong class="bold">Camera</strong> application to take photos and videos on your application’s behalf and save them to external storage <span class="No-Break">using FileProviders.</span></p>
			<p>We will cover the following topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Preferences <span class="No-Break">and DataStore</span></li>
				<li><span class="No-Break">Files</span></li>
				<li><span class="No-Break">Scoped storage</span></li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor642"/><a id="_idTextAnchor643"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/XlTwZ"><span class="No-Break">https://packt.link/XlTwZ</span></a></p>
			<h1 id="_idParaDest-193">Pre<a id="_idTextAnchor644"/>ferences and DataStore</h1>
			<p>Imagine you are tasked<a id="_idIndexMarker1012"/> with integrating a third-party <a id="_idIndexMarker1013"/>API that uses something such as OAuth to implement logging in with Facebook, Google, and suchlike. The way these mechanisms work is as follows – they give you a token that you have to store locally and that can then be used to send other requests to access <span class="No-Break">user data.</span></p>
			<p>This raises several questions. How can you store that token? Do you use Room just for one token? Do you save the token in a separate file and implement methods for writing the file? What if that file has to be accessed in multiple places at the same time? <strong class="source inline">SharedPreferences</strong> and <strong class="source inline">DataStore</strong> are answers to these questions. <strong class="source inline">SharedPreferences</strong> is a functionality that allows you to save Booleans, integers, floats, longs, strings, and sets of strings into an <span class="No-Break">XML file.</span></p>
			<p>When you want to save new values, you specify what values you want to save for the associated keys, and when you are done, you commit the change, which will trigger the save to the XML file in an asynchronous way. The <strong class="source inline">SharedPreferences</strong> mappings are also kept in memory so that when you want to read these values, it’s instantaneous, thereby removing the need for an asynchronous call to read the <span class="No-Break">XML file.</span></p>
			<p>We now have two ways<a id="_idIndexMarker1014"/> to store data in key-value<a id="_idIndexMarker1015"/> pairs in the form of <strong class="source inline">SharedPreferences</strong> and <strong class="source inline">DataStore</strong>. We will now look at how each of them works and the benefits each <span class="No-Break">one provid<a id="_idTextAnchor645"/>es.</span><a id="_idTextAnchor646"/></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor647"/>SharedPreferences</h2>
			<p>The way to access the <strong class="source inline">SharedPreference</strong> object<a id="_idIndexMarker1016"/> is through the <span class="No-Break"><strong class="source inline">Context</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source code">
val prefs = getSharedPreferences("my-prefs-file",
Context.MODE_PRIVATE)</pre>
			<p>The first parameter is where you specify the name of your preferences, and the second is how you want to expose a file to other apps. Currently, the best mode is the private one. All of the others present potential <span class="No-Break">security risks.</span></p>
			<p>If you want to write data into your preferences file, you first need to get access to the Preferences editor. The editor will give you access to write the data. You can then write your data in it. Once you finish writing, you will have to apply the changes that will trigger persistence to the XML file and change the in-memory values <span class="No-Break">as well.</span></p>
			<p>You have two choices to apply the changes on your preference file – <strong class="source inline">apply</strong> or <strong class="source inline">commit</strong>. Choosing <strong class="source inline">apply</strong> will save your changes in memory instantly, but then writing to disk will be asynchronous, which is useful if you want to save data from from your app’s main thread. <strong class="source inline">commit</strong> does everything synchronously and gives you a Boolean result, informing you whether the operation was successful or not. In practice, <strong class="source inline">apply</strong> tends to be favored <span class="No-Break">over </span><span class="No-Break"><strong class="source inline">commit</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
    val editor = prefs.edit()
    editor.putBoolean("my_key_1", true)
    editor.putString("my_key_2", "my string")
    editor.putLong("my_key_3", 1L)
    editor.apply()</pre>
			<p>Now, you want to clear your entire data. The same principle will apply; you’ll need <strong class="source inline">editor</strong>, <strong class="source inline">clear</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">apply</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
    val editor = prefs.edit()
    editor.clear()
    editor.apply()</pre>
			<p>If you want to read the values you previously saved, you can use the <strong class="source inline">SharedPreferences</strong> object to read the stored values. If there is no saved value, you can opt for a default value to be <span class="No-Break">returned instead:</span></p>
			<pre class="source code">
    prefs.getBoolean("my_key_1", false)
    prefs.getString("my_key_2", "")
    prefs.getLong("my_key_3", 0L)</pre>
			<p>We should now have an<a id="_idIndexMarker1017"/> idea about how we can persist data with <strong class="source inline">SharedPreferences</strong>, and we can apply this in an exercise in the <span class="No-Break">following sec<a id="_idTextAnchor648"/>tio<a id="_idTextAnchor649"/>n.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor650"/>Exercise 12.01 – wrapping SharedPreferences</h2>
			<p>We’re going to build<a id="_idIndexMarker1018"/> an application that displays <strong class="source inline">TextView</strong>, <strong class="source inline">EditText</strong>, and a button. <strong class="source inline">TextView</strong> will display the previously saved value in <strong class="source inline">SharedPreferences</strong>. The user can type new text, and when the button is clicked, the text will be saved in <strong class="source inline">SharedPreferences</strong> and <strong class="source inline">TextView</strong> will display the updated text. We will need to use <strong class="source inline">ViewModel</strong> and <strong class="source inline">LiveData</strong> to make the code <span class="No-Break">more testable.</span></p>
			<p>In order to complete<a id="_idIndexMarker1019"/> this exercise, we will need to create a <strong class="source inline">Wrapper</strong> class, which will be responsible for saving the text. This class will return the value of the text as <strong class="source inline">LiveData</strong>. This will be injected into our <strong class="source inline">ViewModel</strong>, which will be bound to <span class="No-Break">the activity:</span></p>
			<ol>
				<li>Create a new Android Studio project with an <span class="No-Break">empty activity.</span></li>
				<li>Let’s begin by adding the appropriate libraries <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Let’s make our <strong class="source inline">Wrapper</strong> class in the <strong class="source inline">main/java</strong> folder in the <strong class="source inline">root</strong> package, which will listen for changes in <strong class="source inline">SharedPreferences</strong> and update the value of <strong class="source inline">LiveData</strong> when the preferences change. The class will contain methods to save the new text and <span class="No-Break">retrieve </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">:</span><pre class="source code">
const val KEY_TEXT = "keyText"
class PreferenceWrapper(private val sharedPreferences:
SharedPreferences) {
    private val textLiveData =
        MutableLiveData&lt;String&gt;()
    init {
        sharedPreferences
        .registerOnSharedPreferenceChangeListener {
        _, key -&gt;
            when (key) {
                KEY_TEXT -&gt; {
                    textLiveData.postValue(
                    sharedPreferences
                    .getString(KEY_TEXT, ""))
                }
            }
        }
<a id="_idTextAnchor651"/>    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/a2RuN"><span class="No-Break">https://packt.link/a2RuN</span></a><span class="No-Break">.</span></p>
			<p>Note the top of the file. We’ve added a listener<a id="_idIndexMarker1020"/> so that when our <strong class="source inline">SharedPreferences</strong> values change, we can look up the new value and update our <strong class="source inline">LiveData</strong> model. This will allow us to observe <strong class="source inline">LiveData</strong> for any changes and just update <span class="No-Break">the UI.</span></p>
			<p>The <strong class="source inline">saveText</strong> method will open the editor, set the new value, and apply the changes. The <strong class="source inline">getText</strong> method will read the last saved value, set it in <strong class="source inline">LiveData</strong>, and return the <strong class="source inline">LiveData</strong> object. This is helpful in scenarios where the app is opened and we want to access the last value prior to the <span class="No-Break">app closing.</span></p>
			<ol>
				<li value="4">Now, let’s set up the <strong class="source inline">Application</strong> class with the instance of the preferences in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class PreferenceApplication : Application() {
    lateinit var preferenceWrapper: PreferenceWrapper
    override fun onCreate() {
        super.onCreate()
        preferenceWrapper =
            PreferenceWrapper(getSharedPreferences(
            "prefs", Context.MODE_PRIVATE))
    }
}</pre></li>
				<li>Now, let’s add the appropriate attributes in the <strong class="source inline">application</strong> tag <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">Android</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">Manifest.xml</strong></span><span class="No-Break">:</span><pre class="source code">
android:name=".PreferenceApplication"</pre></li>
				<li>Next, let’s build the <strong class="source inline">ViewModel</strong> component in the <strong class="source inline">main/java</strong> folder<a id="_idIndexMarker1021"/> in the <span class="No-Break">root package:</span><pre class="source code">
class PreferenceViewModel(private val
preferenceWrapper: PreferenceWrapper) : ViewModel() {
    fun saveText(text: String) {
        preferenceWrapper.saveText(text)
    }
    fun getText(): LiveData&lt;String&gt; {
        return preferenceWrapper.getText()
    }
}</pre></li>
				<li>Now, let’s define our <strong class="source inline">activity_main.xml</strong> layout file in the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;EditText
        android:id="@+id/activity_main_edit_text"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:inputType="none"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_text_view" /&gt;</pre></li>
			</ol>
			<p>The complete<a id="_idIndexMarker1022"/> code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/2c5Ay"><span class="No-Break">https://packt.link/2c5Ay</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="8">Finally, in <strong class="source inline">MainActivity</strong>, perform the <span class="No-Break">following steps:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        preferenceViewModel.getText().observe(this,
        Observer {
            findViewById&lt;TextView&gt;(
            R.id.activity_main_text_view) .text = it
        })
        findViewById&lt;Button&gt;(R.id.activity_main_button
        ) .setOnClickListener {
            preferenceViewModel.saveText(findViewById
            &lt;EditText&gt; (R.id.activity_main_edit_text)
            .text.toString())
        }
    }
}</pre></li>
			</ol>
			<p>The complete code<a id="_idIndexMarker1023"/> for this step can be found <span class="No-Break">at </span><a href="https://packt.link/ZRWNc"><span class="No-Break">https://packt.link/ZRWNc</span></a><span class="No-Break">.</span></p>
			<p>The preceding code will produce the output presented in <span class="No-Break"><em class="italic">Fi<a id="_idTextAnchor652"/>gure 12</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B19411_12_01.jpg" alt="Figure 12.1 – Output of Exercise 12.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Output of Exercise 12.01</p>
			<p>Once you insert a value, try closing<a id="_idIndexMarker1024"/> the application and reopening it. The app will display the last <span class="No-Break">persisted value.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor653"/>DataStore</h2>
			<p>The <strong class="source inline">DataStore</strong> persistence library represents<a id="_idIndexMarker1025"/> an alternative to <strong class="source inline">SharedPreferences</strong> when we want to store data in key-value pairs through the Preference <strong class="source inline">DataStore</strong>, or if we want to store entire objects through the Proto <strong class="source inline">DataStore</strong>. Both libraries avoid dependencies with the Android framework (unlike <strong class="source inline">SharedPreferences</strong>, which requires a <strong class="source inline">Context</strong> object to be initialized) and are built using coroutines and flows, making them the ideal candidate when coroutines and flows are used in <span class="No-Break">your project.</span></p>
			<p>This integration allows the <strong class="source inline">DataStore</strong> to notify subscribers of all changes, which means that developers no longer have to concern themselves with handling <span class="No-Break">the changes:</span></p>
			<pre class="source code">
val Context.dataStore: DataStore&lt;Preferences&gt; by
preferencesDataStore(name = "myDataStore")
val KEY_MY_INT = intPreferencesKey("my_int_key")
val KEY_MY_BOOLEAN =
    booleanPreferencesKey("my_boolean_key")
val KEY_MY_STRING = stringPreferencesKey("my_string_key")
class MyAppSettings(private val context: Context) {
    val myIntValue: Flow&lt;Int&gt; = context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_INT] ?: 0
        }
    val myBooleanValue: Flow&lt;Boolean&gt; =
        context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_BOOLEAN] ?: false
        }
    val myStringValue: Flow&lt;String&gt; =
        context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_MY_STRING] ?: ""
        }
}</pre>
			<p>In the preceding<a id="_idIndexMarker1026"/> snippet, we initialize <strong class="source inline">Context.dataStore</strong> in the top-level Kotlin file. We then define three separate keys for separate types we want to read from. Inside <strong class="source inline">MyAppSettings</strong>, we map the values from <strong class="source inline">context.dataStore.data</strong> and extract the values from <span class="No-Break">our keys.</span></p>
			<p>If we want to store data in our <strong class="source inline">DataStore</strong>, then we need to do <span class="No-Break">the following:</span></p>
			<pre class="source code">
class MyAppSettings(private val context: Context) {
    …
    suspend fun saveMyIntValue(intValue: Int) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_INT] = intValue
        }
    }
    suspend fun saveMyBooleanValue(booleanValue: Boolean) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_BOOLEAN] = booleanValue
        }
    }
    suspend fun saveMyStringValue(stringValue: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_MY_STRING] = stringValue
        }
    }
}</pre>
			<p>The <strong class="source inline">suspend</strong> keyword comes from coroutines, and it signals that we need to place the method invocation<a id="_idIndexMarker1027"/> into an asynchronous call. <strong class="source inline">context.dataStore.edit</strong> will make the preferences in the <strong class="source inline">DataStore</strong> mutable and allow us to change <span class="No-Break">the values.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor654"/>Exercise 12.02 – Preference DataStore</h2>
			<p>We’re going to build<a id="_idIndexMarker1028"/> an application that displays <strong class="source inline">TextView</strong>, <strong class="source inline">EditText</strong>, and a button. <strong class="source inline">TextView</strong> will display the value that was added to <strong class="source inline">DataStore</strong>. The user can type new text, and when the button is clicked, the text will be saved in <strong class="source inline">DataStore</strong> and <strong class="source inline">TextView</strong> will display the <span class="No-Break">updated text.</span></p>
			<p>We will need to use <strong class="source inline">ViewModel</strong> and <strong class="source inline">LiveData</strong>. In the <strong class="source inline">ViewModel</strong>, we will collect the data coming from <strong class="source inline">DataStore</strong> and place it in a <span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break"> object:</span></p>
			<ol>
				<li>Create a new Android Studio<a id="_idIndexMarker1029"/> project with an <span class="No-Break">empty activity.</span></li>
				<li>Let’s begin by adding the appropriate libraries <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation "androidx.datastore:
        datastore-preferences:1.0.0"
    implementation "androidx.lifecycle:
        lifecycle-viewmodel-ktx:2.5.1"
    implementation "androidx.lifecycle:
        lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li>Create a class called <strong class="source inline">SettingsStore</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which will contain methods to load and save data <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">DataStore</strong></span><span class="No-Break">:</span><pre class="source code">
val Context.dataStore: DataStore&lt;Preferences&gt; by
preferencesDataStore(name = "settingsStore")
val KEY_TEXT = stringPreferencesKey("key_text")
class SettingsStore(private val context: Context) {
    val text: Flow&lt;String&gt; = context.dataStore.data
        .map { preferences -&gt;
            preferences[KEY_TEXT] ?: ""
        }
    suspend fun saveText(text: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[KEY_TEXT] = text
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we have defined a key for storing the text, a field to retrieve the saved text, and a method to <span class="No-Break">save it.</span></p>
			<ol>
				<li value="4">Create a new class called <strong class="source inline">SettingsViewModel</strong> in the <strong class="source inline">main/java</strong> folder in the root package, which<a id="_idIndexMarker1030"/> will collect the data from <strong class="source inline">SettingsStore</strong> in <strong class="source inline">LiveData</strong> and invoke it to save the new <span class="No-Break">text values:</span><pre class="source code">
class SettingsViewModel(private val settingsStore:
SettingsStore) : ViewModel() {
    private val _textLiveData =
        MutableLiveData&lt;String&gt;()
    val textLiveData: LiveData&lt;String&gt; = _textLiveData
    init {
        viewModelScope.launch {
            settingsStore.text.collect {
                _textLiveData.value = it
            }
        }
    }
    fun saveText(text: String) {
        viewModelScope.launch {
            settingsStore.saveText(text)
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding example, <strong class="source inline">viewModelScope</strong> is an extension of <strong class="source inline">ViewModel</strong> and represents <strong class="source inline">CoroutineScope</strong>, which ensures that the background work is done while <strong class="source inline">ViewModel</strong> is still active to avoid any possible leaks. Using this, we can collect the existing text into <strong class="source inline">LiveData</strong> when <strong class="source inline">ViewModel</strong> is initialized and then invoke the <strong class="source inline">saveText</strong> method <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">SettingsStore</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Now, let’s set up the <strong class="source inline">Application</strong> class with the <strong class="source inline">SettingsStore</strong> instance in the <strong class="source inline">main/java</strong> folder<a id="_idIndexMarker1031"/> in the <span class="No-Break">root package:</span><pre class="source code">
class SettingsApplication : Application() {
    lateinit var settingsStore: SettingsStore
    override fun onCreate() {
        super.onCreate()
        settingsStore = SettingsStore(this)
    }
}</pre></li>
				<li>Next, let’s add the appropriate attributes in the <strong class="source inline">application</strong> tag <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">Android</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">Manifest.xml</strong></span><span class="No-Break">:</span><pre class="source code">
android:name=".SettingsApplication"</pre></li>
				<li>Finally, let’s define our <strong class="source inline">activity_main.xml</strong> layout file in the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
    &lt;TextView
        android:id="@+id/activity_main_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;EditText
        android:id="@+id/activity_main_edit_text"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:inputType="none"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_text_view" /&gt;</pre></li>
			</ol>
			<p>The complete<a id="_idIndexMarker1032"/> code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/8f854"><span class="No-Break">https://packt.link/8f854</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="8">And finally, in <strong class="source inline">MainActivity</strong>, perform the <span class="No-Break">following steps:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val preferenceWrapper =
            (application as SettingsApplication)
            .settingsStore
        val preferenceViewModel =
            ViewModelProvider(this, object :
            ViewModelProvider.Factory {
                override fun &lt;T : ViewModel&gt;
                create(modelClass: Class&lt;T&gt;): T {
                    return SettingsViewModel(
                    preferenceWrapper) as T
            }
        }).get(SettingsViewModel::class.java)
    }
}</pre></li>
			</ol>
			<p>The complete code<a id="_idIndexMarker1033"/> for this step can be found <span class="No-Break">at </span><a href="https://packt.link/gydeC"><span class="No-Break">https://packt.link/gydeC</span></a><span class="No-Break">.</span></p>
			<p>If we now run the application, we should see the <span class="No-Break">following screen:</span></p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B19411_12_02.jpg" alt="Figure 12.2 – Output of Exercise 12.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Output of Exercise 12.02</p>
			<p>If we enter a new text and click the <strong class="bold">OK</strong> button, we see that the text is instantly updated, unlike the previous exercise. This is because of the usage of flows and how <strong class="source inline">DataStore</strong> will emit a new value for each change. We will look at flows and other reactive streams in <span class="No-Break">future chapters.</span></p>
			<p>In this exercise, we have looked<a id="_idIndexMarker1034"/> at how the <strong class="source inline">DataStore</strong> library works and its benefits, especially regarding streams of data. In the following chapters, we will continue to look at other ways of persistin<a id="_idTextAnchor655"/>g dat<a id="_idTextAnchor656"/>a, <span class="No-Break">using files.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor657"/>Files</h1>
			<p>We’ve discussed<a id="_idIndexMarker1035"/> Room, <strong class="source inline">SharedPreferences</strong>, and <strong class="source inline">DataStore</strong> and specified how the data they store is written to files. You may ask yourself, where are these files stored? These particular files are stored in internal storage. Internal storage is a dedicated space for every app that other apps are unable to access (unless a device is rooted). There is no limit to the amount of storage your app <span class="No-Break">can use.</span></p>
			<p>However, users have the ability to delete their app’s files from the <strong class="bold">Settings</strong> menu. Internal storage occupies a smaller part of the total available space, which means that you should be careful when it comes to storing files there. There is also external storage. The files your app stores in external storage are accessible to other apps and the files from other apps are accessible<a id="_idIndexMarker1036"/> to <span class="No-Break">your one.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">In Android<a id="_idIndexMarker1037"/> Studio, you can use the <strong class="bold">Device File Explorer</strong> tool to navigate through the files on a device or emulator. Internal storage is located in <strong class="source inline">/data/data/{packageName}</strong>. If you have access to this folder, this means that the device is rooted. Using this, you can visualize the database files and the <span class="No-Break"><strong class="source inline">SharedPreferences</strong></span><span class="No-Break"> files.</span></p>
			<p>An example of how the <strong class="bold">Device File Explorer</strong> looks can be viewed in<a id="_idTextAnchor658"/> the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/Image100608.jpg" alt="Figure 12.3 – Android’s Device File Explorer ﻿for an﻿ emulated device"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Android’s Device File Explorer <a id="_idTextAnchor659"/>for an<a id="_idTextAnchor660"/> emulated device</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor661"/>Internal storage</h2>
			<p>Internal storage<a id="_idIndexMarker1038"/> requires no permissions<a id="_idIndexMarker1039"/> from the user. To access the internal storage directories, you can use one of the following methods from the <span class="No-Break"><strong class="source inline">Context</strong></span><span class="No-Break"> object:</span></p>
			<ul>
				<li><strong class="source inline">getDataDir()</strong>: Returns the root folder of your <span class="No-Break">application sandbox.</span></li>
				<li><strong class="source inline">getFilesDir()</strong>: A dedicated folder for application files – recommended <span class="No-Break">for usage.</span></li>
				<li><strong class="source inline">getCacheDir()</strong>: A dedicated folder where files can be cached. Storing files here does not guarantee that you can retrieve them later because the system may decide to delete this directory to free up memory. This folder is linked to the <strong class="bold">Clear Cache</strong> option <span class="No-Break">in </span><span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source inline">getDir(name, mode)</strong>: Returns a folder that will be created if it does not exist, based on the <span class="No-Break">name specified.</span></li>
			</ul>
			<p>When users use the <strong class="bold">Clear Data</strong> option from <strong class="bold">Settings</strong>, most of these folders will be deleted, bringing the app<a id="_idIndexMarker1040"/> to a similar state as a fresh installation. When the app<a id="_idIndexMarker1041"/> is uninstalled, these files will be deleted <span class="No-Break">as well.</span></p>
			<p>A typical example of reading a cache file is <span class="No-Break">as follows:</span></p>
			<pre class="source code">
        val cacheDir = context.cacheDir
        val fileToReadFrom = File(cacheDir, "my-file.txt")
        val size = fileToReadFrom.length().toInt()
        val bytes = ByteArray(size)
        val tmpBuff = ByteArray(size)
        val fis = FileInputStream(fileToReadFrom)
        try {
            var read = fis.read(bytes, 0, size)
            if (read &lt; size) {
                var remain = size - read
                while (remain &gt; 0) {
                    read = fis.read(tmpBuff, 0, remain)
                    System.arraycopy(tmpBuff, 0, bytes,
                        size - remain, read)
                    remain -= read
                }
            }
        } catch (e: IOException) {
            throw e
        } finally {
            fis.close()
        }</pre>
			<p>The preceding example will read from <strong class="source inline">my-file.txt</strong>, located in the <strong class="source inline">Cache</strong> directory, and will create <strong class="source inline">FileInputStream</strong> for that file. Then, a buffer will be used that will collect the bytes from the file. The collected<a id="_idIndexMarker1042"/> bytes will be placed in the <strong class="source inline">bytes</strong> byte array, which will contain <a id="_idIndexMarker1043"/>all of the data read from that file. Reading will stop when the entire length of the file has <span class="No-Break">been read.</span></p>
			<p>Writing to the <strong class="source inline">my-file.txt</strong> file will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
        val bytesToWrite = ByteArray(100)
        val cacheDir = context.cacheDir
        val fileToWriteIn = File(cacheDir, "my-file.txt")
        try {
            if (!fileToWriteIn.exists()) {
                fileToWriteIn.createNewFile()
            }
            val fos = FileOutputStream(fileToWriteIn)
            fos.write(bytesToWrite)
            fos.close()
        } catch (e: Exception) {
            e.printStackTrace()
        }</pre>
			<p>What the preceding example does is take the byte array you want to write, create a new <strong class="source inline">File</strong> object, create the file if it doesn’t exist, and write<a id="_idIndexMarker1044"/> the bytes into the file<a id="_idIndexMarker1045"/> <span class="No-Break">through </span><span class="No-Break"><strong class="source inline">FileOutputStream</strong></span><span class="No-Break">.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">There are many alternatives to dealing with files. The readers (<strong class="source inline">StreamReader</strong>, <strong class="source inline">StreamWriter</strong>, and so on) are better equipped for character-based data. There are also third-party libraries that help with disk I/O operations. One of the most common third parties<a id="_idIndexMarker1046"/> that help with I/O operations is called <strong class="bold">Okio</strong>. It started life as part of the <strong class="source inline">OkHttp</strong> library, which is used in combination with Retrofit to make API calls. The methods provided by Okio are the same methods it uses to write and re<a id="_idTextAnchor662"/>ad dat<a id="_idTextAnchor663"/>a in <span class="No-Break">HTTP communications.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor664"/>External storage</h2>
			<p>Reading and writing in external storage<a id="_idIndexMarker1047"/> requires user permission for reading<a id="_idIndexMarker1048"/> and writing. If write permission is granted, then your app has the ability to read the external storage. Once these permissions are granted, then your app can do whatever it pleases on the <span class="No-Break">external storage.</span></p>
			<p>That may present a problem because users may not choose to grant these permissions. However, there are specialized methods that offer you the possibility to write to the external storage in folders dedicated to <span class="No-Break">your application.</span></p>
			<p>Some of the most common ways of accessing external storage are from the <strong class="source inline">Context</strong> and <span class="No-Break"><strong class="source inline">Environment</strong></span><span class="No-Break"> objects:</span></p>
			<ul>
				<li><strong class="source inline">Context.getExternalFilesDir(mode)</strong>: This method will return the path to the directory on the external storage dedicated to your application. Specifying different modes (pictures, movies, and so on) will create different subfolders, depending on how you want your files saved. This method <em class="italic">does not </em><span class="No-Break"><em class="italic">require permissions</em></span><span class="No-Break">.</span></li>
				<li><strong class="source inline">Context.getExternalCacheDir()</strong>: This will point toward an application’s cache directory on the external storage. The same considerations should be applied to this <strong class="source inline">cache</strong> folder as to the internal storage option. This method <em class="italic">does not </em><span class="No-Break"><em class="italic">require permissions</em></span><span class="No-Break">.</span></li>
				<li>The <strong class="source inline">Environment</strong> class has access to paths of some of the most common folders on a device. However, on newer devices, apps may<a id="_idIndexMarker1049"/> not have access to those files<a id="_idIndexMarker1050"/> <span class="No-Break">and folders.</span></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">Avoid using hardcoded paths to files and folders. The Android operating system may shift the location of folders around, dependin<a id="_idTextAnchor665"/>g on t<a id="_idTextAnchor666"/>he device or <span class="No-Break">Android version.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor667"/>FileProvider</h2>
			<p>This represents<a id="_idIndexMarker1051"/> a specialized implementation of <strong class="source inline">ContentProviders</strong> that is useful in organizing the file and folder structure of your application. It allows you to specify an XML file, in which you define how your files should be split between internal and external storage if you choose to do so. It also gives you the ability to grant access to other apps to your files by hiding the path and generating a unique URI to identify and query <span class="No-Break">your file.</span></p>
			<p><strong class="source inline">FileProvider</strong> lets you pick between six different folders, where you can set up your <span class="No-Break">folder hierarchies:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source inline">Context.getFilesDir()</strong></span><span class="No-Break"> (files-path)</span></li>
				<li><span class="No-Break"><strong class="source inline">Context.getCacheDir()</strong></span><span class="No-Break"> (cache-path)</span></li>
				<li><span class="No-Break"><strong class="source inline">Environment.getExternalStorageDirectory()</strong></span><span class="No-Break"> (external-path)</span></li>
				<li><span class="No-Break"><strong class="source inline">Context.getExternalFilesDir(null)</strong></span><span class="No-Break"> (external-files-path)</span></li>
				<li><span class="No-Break"><strong class="source inline">Context.getExternalCacheDir()</strong></span><span class="No-Break"> (external-cache-path)</span></li>
				<li>The first result of <span class="No-Break"><strong class="source inline">Context.getExternalMediaDirs()</strong></span><span class="No-Break"> (external-media-path)</span></li>
			</ul>
			<p>The main benefits of <strong class="source inline">FileProvider</strong> are the abstractions it provides in organizing your files while leaving a developer to define the paths in an XML file, and more importantly, if you choose to use it to store files in external storage, you do not have to ask for permissions from <span class="No-Break">the user.</span></p>
			<p>Another benefit is the fact that it makes sharing of internal files easier while giving a developer control of what files other apps can access without exposing their <span class="No-Break">real location.</span></p>
			<p>Let us understand better through the <span class="No-Break">following example:</span></p>
			<pre class="source code">
&lt;paths
xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;files-path name="my-visible-name" path="/
    my-folder-name" /&gt;
&lt;/paths&gt;</pre>
			<p>The preceding<a id="_idIndexMarker1052"/> example will make <strong class="source inline">FileProvider</strong> use the internal <strong class="source inline">files</strong> directory and create a folder named <strong class="source inline">my-folder-name</strong>. When the path is converted to a URI, t<a id="_idTextAnchor668"/>hen the UR<a id="_idTextAnchor669"/>I will <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">my-visible-name</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor670"/>The Storage Access Framework (SAF)</h2>
			<p>The SAF is a file picker introduced in Android KitKat<a id="_idIndexMarker1053"/> that apps can use for their users<a id="_idIndexMarker1054"/> to pick files, with a view to them being processed or uploaded. You can use it in your app in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>Your app requires a user to process a file saved on a device by another app (photos <span class="No-Break">and videos)</span></li>
				<li>You want to save a file on a device and give a user the choice of where to save the file and the name of <span class="No-Break">the file</span></li>
				<li>You want to offer the files your application uses to other apps for scenarios similar to the first scenario in <span class="No-Break">this list</span></li>
			</ul>
			<p>This is again useful because your app will avoid read and write permissions and still write and access external storage. The way this works is based on intents. You can register for an activity result for <strong class="source inline">GetDocument</strong> or <strong class="source inline">CreateDocument</strong>. Then, in the activity result callback, the system will give you a URI that grants you temporary permissions to that file, allowing you to read <span class="No-Break">and write.</span></p>
			<p>Another benefit of the SAF is the fact that files don’t have to be on a device. Apps such as Google Drive expose their content in the SAF, and when a Google Drive file is selected, it will be downloaded to the device and the URI will be sent as <span class="No-Break">a result.</span></p>
			<p>Another important thing to mention is the SAF’s support for virtual files, meaning that it will expose Google docs, which have their own format, but when those docs are downloaded through the SAF, their formats<a id="_idIndexMarker1055"/> will be c<a id="_idTextAnchor671"/>onvert<a id="_idTextAnchor672"/>ed to a common format<a id="_idIndexMarker1056"/> such <span class="No-Break">as PDF.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor673"/>Asset files</h2>
			<p><strong class="bold">Asset files</strong> are files you can package as part of your APK. If you’ve used<a id="_idIndexMarker1057"/> an app that played certain videos<a id="_idIndexMarker1058"/> or GIFs when the app is launched or as part of a tutorial, odds are that the videos were bundled with the APK. To add files to your assets, you need the <strong class="source inline">assets</strong> folder inside your project. You can then group your files inside your assets <span class="No-Break">using folders.</span></p>
			<p>You can access these files at runtime through the <strong class="source inline">AssetManager</strong> class, which itself can be accessed through the context object. <strong class="source inline">AssetManager</strong> offers you the ability to look up the files and read them, but it does not permit any <span class="No-Break">write operations:</span></p>
			<pre class="source code">
        val assetManager = context.assets
        val root = ""
        val files = assetManager.list(root)
        files?.forEach {
            val inputStream = assetManager.open(root + it)
        }</pre>
			<p>The preceding example lists all files inside the root of the <strong class="source inline">assets</strong> folder. The <strong class="source inline">open</strong> function returns <strong class="source inline">inputStream</strong>, which can be used to read the file information <span class="No-Break">if necessary.</span></p>
			<p>One common usage of the <strong class="source inline">assets</strong> folder is for custom fonts. If your application uses custom fonts, then you can<a id="_idTextAnchor674"/> use the <strong class="source inline">assets</strong> folder to store <span class="No-Break">font files.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">For the following exercise, you will need an emulator. You can do so by selecting <strong class="bold">Tools</strong> | <strong class="bold">AVD Manager</strong> in Android Studio. Then, you can create one with the <strong class="bold">Create Virtual Device</strong> option, selecting the type of emulator, clicking <strong class="bold">Next</strong>, and then selecting an x86 image. Any image larger than Lollipop should be acceptable for this exercise. Next, you can giv<a id="_idTextAnchor675"/>e your image a name and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor676"/>Exercise 12.03 – copying files</h2>
			<p>Let’s create an app<a id="_idIndexMarker1059"/> that will keep a file named <strong class="source inline">my-app-file.txt</strong> in the <strong class="source inline">assets</strong> directory. The app will display two buttons called <strong class="source inline">FileProvider</strong> and <strong class="source inline">SAF</strong>. When the <strong class="source inline">FileProvider</strong> button is clicked, the file will be saved on the external storage inside the app’s external storage dedicated area (<strong class="source inline">Context.getExternalFilesDir(null)</strong>). The <strong class="source inline">SAF</strong> button will open the SAF and allow a user to indicate where the file should <span class="No-Break">be saved.</span></p>
			<p>In order to implement this exercise, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Define a file provider that will use the <span class="No-Break"><strong class="source inline">Context.getExternalFilesDir(null)</strong></span><span class="No-Break"> location.</span></li>
				<li>Copy <strong class="source inline">my-app-file.txt</strong> to the preceding location when the <strong class="source inline">FileProvider</strong> button <span class="No-Break">is clicked.</span></li>
				<li>Use <strong class="source inline">Intent.ACTION_CREATE_DOCUMENT</strong> when the <strong class="source inline">SAF</strong> button is clicked and copy the file to the <span class="No-Break">location provided.</span></li>
				<li>Use a separate thread for the file copy to comply with the <span class="No-Break">Android guidelines.</span></li>
				<li>Use the Apache IO library to help with the file copy functionality, by providing methods that allow us to copy data from <strong class="source inline">InputStream</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">OutputStream</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The steps for completion are <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Create a new Android Studio project with an <span class="No-Break">empty activity.</span></li>
				<li>Let’s start with our <span class="No-Break">Gradle configuration:</span><pre class="source code">
    implementation 'commons-io:commons-io:2.6'</pre></li>
				<li>Create the <strong class="source inline">my-app-file.txt</strong> file in the <strong class="source inline">main/assets</strong> folder. Feel free to fill it up with the text you want to be read. If the <strong class="source inline">main/assets</strong> folder doesn’t exist, then you can create it. To create the <strong class="source inline">assets</strong> folder, you can right-click on the <strong class="source inline">main</strong> folder, select <strong class="bold">New</strong>, then <strong class="bold">Directory</strong>, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source inline">assets</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>This folder will now be recognized<a id="_idIndexMarker1060"/> by the build system, and any file inside it will also be installed on the device along with the app. You may need to switch <strong class="bold">Project View</strong> from <strong class="bold">Android</strong> to <strong class="bold">Project</strong> to be able to view this <span class="No-Break">file structure.</span></p>
			<ol>
				<li value="4">We can also define a class that will wrap <strong class="source inline">AssetManager</strong> in the <strong class="source inline">main/java</strong> folder in the root package and define a method to access this <span class="No-Break">particular file:</span><pre class="source code">
class AssetFileManager(private val assetManager:
AssetManager) {
    fun getMyAppFileInputStream() =
        assetManager.open("my-app-file.txt")
}</pre></li>
				<li>Now, let’s work on the <strong class="source inline">FileProvider</strong> aspect. Create the <strong class="source inline">xml</strong> folder in the <strong class="source inline">res</strong> folder. Define <strong class="source inline">file_provider_paths.xml</strong> inside the new folder. We will define <strong class="source inline">external-files-path</strong>, name it <strong class="source inline">docs</strong>, and place it in the <span class="No-Break"><strong class="source inline">docs/</strong></span><span class="No-Break"> folder:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;paths&gt;
    &lt;external-files-path name="docs" path="docs/"/&gt;
&lt;/paths&gt;</pre></li>
				<li>Next, we need to add <strong class="source inline">FileProvider</strong> to the <strong class="source inline">AndroidManifest.xml</strong> file and link it with the new path we defined inside the <strong class="source inline">&lt;</strong><span class="No-Break"><strong class="source inline">application</strong></span><span class="No-Break"> tag:</span><pre class="source code">
        &lt;provider
            android:name=
                "androidx.core.content.FileProvider"
            android:authorities=
                "com.android.testable.files"
            android:exported="false"
            android:grantUriPermissions="true"&gt;
            &lt;meta-data
                android:name="android.support
                    .FILE_PROVIDER_PATHS"
                android:resource="@xml/
                    file_provider_paths" /&gt;
        &lt;/provider&gt;</pre></li>
			</ol>
			<p>The name will point to the <strong class="source inline">FileProvider</strong> path that’s part<a id="_idIndexMarker1061"/> of the Android Support Library. The <strong class="source inline">authorities</strong> field represents the domain your application has (usually the package name of <span class="No-Break">the application).</span></p>
			<p>The exported field indicates whether we wish to share our provider with other apps, and <strong class="source inline">grantUriPermissions</strong> indicates whether we wish to grant other applications access to certain files through the URI. The metadata links the XML file we defined previously <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">FileProvider</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="7">Define the <strong class="source inline">ProviderFileManager</strong> class in the <strong class="source inline">main/java</strong> folder in the root package, which is responsible for accessing the <strong class="source inline">docs</strong> folder and writing data into <span class="No-Break">the file:</span><pre class="source code">
class ProviderFileManager(
<strong class="bold">) {</strong>
<strong class="bold">    fun writeStream(name: String, inputStream:</strong>
<strong class="bold">    InputStream) {</strong>
<strong class="bold">        executor.execute {</strong>
<strong class="bold">            val fileToSave = File(getDocsFolder(),</strong>
<strong class="bold">            name)</strong>
<strong class="bold">            val outputStream =</strong>
<strong class="bold">                context.contentResolver</strong>
<strong class="bold">                .openOutputStream(fileToUriMapper</strong>
<strong class="bold">                .getUriFromFile(context, fileToSave),</strong>
<strong class="bold">                "rw")</strong>
<strong class="bold">            IOUtils.copy(inputStream, outputStream)</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/Gp0Ph"><span class="No-Break">https://packt.link/Gp0Ph</span></a><span class="No-Break">.</span></p>
			<p><strong class="source inline">getDocsFolder</strong> will return<a id="_idIndexMarker1062"/> the path to the <strong class="source inline">docs</strong> folder we defined in the XML. If the folder does not exist, then it will <span class="No-Break">be created.</span></p>
			<p>The <strong class="source inline">writeStream</strong> method will extract the URI for the file we wish to save and, using the Android <strong class="source inline">ContentResolver</strong> class, will give us access to the <strong class="source inline">OutputStream</strong> class of the file we will be saving in. Note that <strong class="source inline">FileToUriMapper</strong> doesn’t exist yet. The code is moved into a separate class in order to make this <span class="No-Break">class testable.</span></p>
			<ol>
				<li value="8">Create the <strong class="source inline">FileToUriMapper</strong> class in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class FileToUriMapper {
    fun getUriFromFile(context: Context, file: File):
    Uri {
        <strong class="bold">return FileProvider.getUriForFile(context,</strong>
<strong class="bold">        "com.android.testable.files", file)</strong>
    }
}</pre></li>
			</ol>
			<p>The <strong class="source inline">getUriForFile</strong> method is part of the <strong class="source inline">FileProvider</strong> class, and its role is to convert the path of a file into a URI that can be used by <strong class="source inline">ContentProviders</strong> and <strong class="source inline">ContentResolvers</strong> to access data. Because the method is static, it prevents us from <span class="No-Break">testing properly.</span></p>
			<ol>
				<li value="9">Make sure that the following<a id="_idIndexMarker1063"/> strings are added <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">strings.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;string name="file_provider"&gt;FileProvider&lt;/string&gt;
    &lt;string name="saf"&gt;SAF&lt;/string&gt;</pre></li>
				<li>Let’s now move on to defining our UI for the <strong class="source inline">activity_main.xml</strong> file in the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
    &lt;Button
        android:id="@+id/activity_main_file_provider"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="200dp"
        android:text="@string/file_provider"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;Button
        android:id="@+id/activity_main_saf"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="50dp"
        android:text="@string/saf"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf=
            "@id/activity_main_file_provider" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/Pw37X"><span class="No-Break">https://packt.link/Pw37X</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="11">Now, let’s define<a id="_idIndexMarker1064"/> our <strong class="source inline">MainActivity</strong> class in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById&lt;Button&gt;(
        R.id.activity_main_file_provider)
        .setOnClickListener {
            val newFileName = "Copied.txt"
<strong class="bold">            providerFileManager.writeStream(</strong>
<strong class="bold">                newFileName, assetFileManager</strong>
<strong class="bold">                .getMyAppFileInputStream())</strong>
        }
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/FBXgY"><span class="No-Break">https://packt.link/FBXgY</span></a><span class="No-Break">.</span></p>
			<p>For this example, we chose <strong class="source inline">MainActivity</strong> to create our objects and inject data into the different<a id="_idIndexMarker1065"/> classes we have. If we execute this code and click the <strong class="source inline">FileProvider</strong> button, we don’t see an output on <span class="No-Break">the UI.</span></p>
			<p>However, if we look at Android’s <strong class="bold">Device File Explorer</strong>, we can locate where the file was saved. The path may be different on different devices and operating systems. The paths could be <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source inline">mnt/sdcard/Android/data/&lt;package_name&gt;/files/docs</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">sdcard/Android/data/&lt;package_name&gt;/files/docs</strong></span></li>
				<li><span class="No-Break"><strong class="source inline">storage/emulated/0/Android/data/&lt;packag<a id="_idTextAnchor677"/>e_name&gt;/files/docs</strong></span></li>
			</ul>
			<p>The output will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B19411_12_04.jpg" alt="Figure 12.4 – Output of copy through FileProvider"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Output of copy through FileProvider</p>
			<ol>
				<li value="12">Let’s add the logic for the <strong class="source inline">SAF</strong> button. We will need<a id="_idIndexMarker1066"/> to start an activity pointing toward <strong class="source inline">SAF</strong> with the <strong class="source inline">CREATE_DOCUMENT</strong> intent, in which we specify that we want to create a <span class="No-Break">text file.</span></li>
			</ol>
			<p>We will then need the result of <strong class="source inline">SAF</strong> so that we can copy the file to the location selected by a user. In <strong class="source inline">MainActivity</strong> in <strong class="source inline">onCreate</strong>, we can add <span class="No-Break">the following:</span></p>
			<pre class="source code">
      val createDocumentResult =
          registerForActivityResult(
          ActivityResultContracts.CreateDocument(
          "text/plain")) { uri -&gt;
              uri?.let {
                  val newFileName = "Copied.txt"
                  providerFileManager
                  .writeStreamFromUri(newFileName,
                  assetFileManager
                  .getMyAppFileInputStream(), uri)
              }
            }
        findViewById&lt;Button&gt;(R.id.activity_main_saf)
        .setOnClickListener {
            createDocumentResult.launch("Copied.txt")
        }</pre>
			<p>What the preceding code<a id="_idIndexMarker1067"/> will do is register for an <strong class="source inline">Activity</strong> result when a user creates a new file. We will then invoke <strong class="source inline">writeStreamFromUri</strong> from <strong class="source inline">ProviderFileManager</strong> to save the contents from the file in the <strong class="source inline">assets</strong> folder in the file created by the user. When the button is clicked, we will then launch the file creation screen from <span class="No-Break">the SAF.</span></p>
			<ol>
				<li value="13">We now have the URI. We can add a method to <strong class="source inline">ProviderFileManager</strong> that will copy our file to a location given <span class="No-Break">by </span><span class="No-Break"><strong class="source inline">uri</strong></span><span class="No-Break">:</span><pre class="source code">
    fun writeStreamFromUri(name: String, inputStream:
    InputStream, uri:Uri){
        executor.execute {
            val outputStream =
                context.contentResolver
                .openOutputStream(uri, "rw")
            IOUtils.copy(inputStream, outputStream)
        }
    }</pre></li>
			</ol>
			<p>If we run the preceding code and click on the <strong class="bold">SAF</strong> button<a id="_idTextAnchor678"/>, we will see the output presented in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B19411_12_05.jpg" alt="Figure 12.5 – Output of copy through the SAF"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Output of copy through the SAF</p>
			<p>If you choose to save the file, the SAF will be closed and the callback from <strong class="source inline">registerForActivityResult</strong> will be invoked, which will trigger the file copy. Afterward, you can navigate the Android Device File Manage<a id="_idTextAnchor679"/><a id="_idTextAnchor680"/>r<a id="_idIndexMarker1068"/> tool to see whether the file was <span class="No-Break">saved properly.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor681"/>Scoped storage</h1>
			<p>Since Android 10 and with further<a id="_idIndexMarker1069"/> updates in Android 11, the notion of scoped storage was introduced. The main idea behind this is to allow apps to gain more control of their files in external storage and prevent other apps from accessing <span class="No-Break">these files.</span></p>
			<p>The consequences of this mean that <strong class="source inline">READ_EXTERNAL_STORAGE</strong> and <strong class="source inline">WRITE_EXTERNAL_STORAGE</strong> will only apply to files a user interacts with (such as media files). This discourages apps from creating their own directories in external storage, instead sticking with the one already provided to them <span class="No-Break">through </span><span class="No-Break"><strong class="source inline">Context.getExternalFilesDir</strong></span><span class="No-Break">.</span></p>
			<p>FileProviders and the SAF are a good way of making your app comply with scoped storage practices, with one allowing the app to use <strong class="source inline">Context.getExternalFilesDir</strong> and the other using the built-in File Explorer app, which will now avoid files from other applications in the <strong class="source inline">Andro<a id="_idTextAnchor682"/>id/data</strong> <a id="_idTextAnchor683"/>and <strong class="source inline">Android/obb</strong> folders<a id="_idIndexMarker1070"/> in <span class="No-Break">external storage.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor684"/>Camera and media storage</h2>
			<p>Android offers a variety of ways<a id="_idIndexMarker1071"/> to interact with media on its devices, from building<a id="_idIndexMarker1072"/> your own camera application and controlling how users take<a id="_idIndexMarker1073"/> photos and videos to using an existing camera application<a id="_idIndexMarker1074"/> and instructing it on how to take photos <span class="No-Break">and videos.</span></p>
			<p>Android also comes with a <strong class="source inline">MediaStore</strong> content provider, allowing applications to extract information about media files that are set on a device and shared <span class="No-Break">between applications.</span></p>
			<p>This is useful in situations where you want a custom display for media files that exist on a device (such as a photo or music player application) and in situations where you use the <strong class="source inline">MediaStore.ACTION_PICK</strong> intent to select a photo from the device and want to extract the information about the selected media image (this is usually the case for older applications where the SAF cannot <span class="No-Break">be used).</span></p>
			<p>In order to use an existing camera application, you will need to use the <strong class="source inline">MediaStore.ACTION_IMAGE_CAPTURE</strong> intent to start a camera application for a result and pass the URI of the image you wish to save. The user will then go to the camera activity and take the photo, and then you handle the result of <span class="No-Break">the operation:</span></p>
			<pre class="source code">
        val imageCaptureLauncher =
            registerForActivityResult(
            ActivityResultContracts.TakePicture()){
            }
        imageCaptureLauncher.launch(photoUri)</pre>
			<p>The <strong class="source inline">photoUri</strong> parameter will represent the location of where you want your photo to be saved. It should point to an empty file with a JPEG extension. You can build this file in <span class="No-Break">two ways:</span></p>
			<ul>
				<li>Create a file on the external storage using the <strong class="source inline">File</strong> object (this requires the <strong class="source inline">WRITE_EXTERNAL_STORAGE</strong> permission) and then use the <strong class="source inline">Uri.fromFile()</strong> method to convert it into <strong class="source inline">URI</strong> (this is no longer applicable on Android 10 <span class="No-Break">and above)</span></li>
				<li>Create a file in a <strong class="source inline">FileProvider</strong> location using the <strong class="source inline">File</strong> object, and then use the <strong class="source inline">FileProvider.getUriForFile()</strong> method to obtain the URI and grant it permissions if necessary (the recommended approach for when your app targets Android 10 and <span class="No-Break">Android 11)</span></li>
			</ul>
			<p class="callout heading">Note</p>
			<p class="callout">The same mechanism can be applied to videos <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">MediaStore.ACTION_VIDEO_CAPTURE</strong></span><span class="No-Break">.</span></p>
			<p>If your application relies<a id="_idIndexMarker1075"/> heavily on camera<a id="_idIndexMarker1076"/> features, then you<a id="_idIndexMarker1077"/> can exclude the application<a id="_idIndexMarker1078"/> from users whose devices don’t have cameras by adding the <strong class="source inline">&lt;uses-feature&gt;</strong> tag to the <strong class="source inline">AndroidManifest.xml</strong> file. You can also specify the camera as non-required and query whether the camera is available using the <span class="No-Break"><strong class="source inline">Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)</strong></span><span class="No-Break"> method.</span></p>
			<p>If you wish to have your file saved in <strong class="source inline">MediaStore</strong>, there are multiple ways to <span class="No-Break">achieve this:</span></p>
			<ol>
				<li>Send an <strong class="source inline">ACTION_MEDIA_SCANNER_SCAN_FILE</strong> broadcast with the URI of <span class="No-Break">your media:</span><pre class="source code">
      val intent = Intent(Intent.ACTION_MEDIA_SCANNER_
      SCAN_FILE)
      intent.data = photoUri
      sendBroadcast(intent)</pre></li>
				<li>Use the media scanner to scan <span class="No-Break">files directly:</span><pre class="source code">
        val paths = arrayOf("path1", "path2")
        val mimeTypes= arrayOf("type1", "type2")
        MediaScannerConnection.scanFile(context,paths,
            mimeTypes) { path, uri -&gt;
        }</pre></li>
				<li>Insert<a id="_idIndexMarker1079"/> the media<a id="_idIndexMarker1080"/> into <strong class="source inline">ContentProvider</strong> directly<a id="_idIndexMarker1081"/> <span class="No-Break">using</span><span class="No-Break"><a id="_idIndexMarker1082"/></span><span class="No-Break"> </span><span class="No-Break"><strong class="source inline">ContentResolver</strong></span><span class="No-Break">:</span><pre class="source code">
        val contentValues = ContentValues()
        contentValues.put(MediaStore.Images
            .ImageColumns.TITLE, "my title")
        contentValues.put(MediaStore.Images
            .ImageColumns .DATE_ADDED, timeInMillis)
        contentValues.put(MediaStore.Images
            .ImageColumns .MIME_TYPE, "image/*")
        contentValues.put(MediaStore.Images
            .ImageColumns .DATA, "my-path")
        val newUri =
            contentResolver.insert(MediaStore.Video
            .Media.EXTERNAL_CONTENT_URI,
            contentValues)
newUri?.let {
    val outputStream = contentResolver
    .openOutputStream(newUri)
    // Copy content in outputstream
}</pre></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The <strong class="source inline">MediaScanner</strong> functionality no longer adds files <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">Context.getExternal</strong></span><strong class="source inline">
FilesDir</strong> in Android 10 and above. Apps should rely on the <strong class="source inline">insert</strong> method i<a id="_idTextAnchor685"/>nstead i<a id="_idTextAnchor686"/>f they choose to share their media files with <span class="No-Break">other apps.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor687"/>Exercise 12.04 – taking photos</h2>
			<p>We’re going to build<a id="_idIndexMarker1083"/> an application<a id="_idIndexMarker1084"/> that has two buttons; the first button will open a camera app<a id="_idIndexMarker1085"/> to take a photo, and the second button will open the camera app to record a video. We will use <strong class="source inline">FileProvider</strong> to save the photos to external storage (external-path) in two folders, <strong class="source inline">pictures</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">movies</strong></span><span class="No-Break">.</span></p>
			<p>The photos will be saved using <strong class="source inline">img_{timestamp}.jpg</strong>, and the videos will be saved using <strong class="source inline">video_{timestamp}.mp4</strong>. After a photo and video have been saved, you will copy the file from <strong class="source inline">FileProvider</strong> into <strong class="source inline">MediaStore</strong> so that they will be visible for <span class="No-Break">other apps:</span></p>
			<ol>
				<li>Create a new Android Studio project with an <span class="No-Break">empty activity.</span></li>
				<li>Let’s add the libraries <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation 'commons-io:commons-io:2.6'</pre></li>
				<li>We will need to request the <strong class="source inline">WRITE_EXTERNAL_STORAGE</strong> permission for devices that predate Android 10, which means we need the following in <strong class="source inline">AndroidManifest.xml</strong> outside of the <strong class="source inline">&lt;</strong><span class="No-Break"><strong class="source inline">application</strong></span><span class="No-Break"> tag:</span><pre class="source code">
&lt;uses-permission
    android:name="android.permission
    .WRITE_EXTERNAL_STORAGE"
    android:maxSdkVersion="28" /&gt;</pre></li>
				<li>Let’s define a <strong class="source inline">FileHelper</strong> class, which will contain methods that are harder to test in the <strong class="source inline">test</strong> folder in the <span class="No-Break">root package:</span><pre class="source code">
class FileHelper(private val context: Context) {
    fun getUriFromFile(file: File): Uri {
        return FileProvider.getUriForFile(context,
        "com.android.testable.camera", file)
    }
    fun getPicturesFolder(): String =
        Environment.DIRECTORY_PICTURES
    fun getVideosFolder(): String =
        Environment.DIRECTORY_MOVIES
}</pre></li>
				<li>Let’s define our <strong class="source inline">FileProvider</strong> paths in <strong class="source inline">res/xml/file_provider_paths.xml</strong>. Make sure<a id="_idIndexMarker1086"/> to include the appropriate package name<a id="_idIndexMarker1087"/> for your<a id="_idIndexMarker1088"/> application <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">FileProvider</strong></span><span class="No-Break">:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;paths&gt;
    &lt;external-path
        name="photos"
        path="Android/data/com.android.testable
        .myapplication/files/Pictures" /&gt;
    &lt;external-path
        name="videos"
        path="Android/data/com.android.testable
        .myapplication/files/Movies" /&gt;
&lt;/paths&gt;</pre></li>
			</ol>
			<p>Let’s add the file provider paths to the <strong class="source inline">AndroidManifest.xml</strong> file inside the <strong class="source inline">&lt;</strong><span class="No-Break"><strong class="source inline">application</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source code">
        &lt;provider
            android:name=
                "androidx.core.content.FileProvider"
            android:authorities=
                "com.android.testable.camera"
            android:exported="false"
            android:grantUriPermissions="true"&gt;
            &lt;meta-data
                android:name="android.support
                .FILE_PROVIDER_PATHS"
                android:resource="@xml/
                file_provider_paths" /&gt;
        &lt;/provider&gt;</pre>
			<ol>
				<li value="6">Let’s now define a model<a id="_idIndexMarker1089"/> that will hold<a id="_idIndexMarker1090"/> both <strong class="source inline">Uri</strong> and the associated path for a file in the <strong class="source inline">main/java</strong> folder in the <span class="No-Break">root</span><span class="No-Break"><a id="_idIndexMarker1091"/></span><span class="No-Break"> package:</span><pre class="source code">
data class FileInfo(
    val uri: Uri,
    val file: File,
    val name: String,
    val relativePath:String,
    val mimeType:String
)</pre></li>
				<li>Let’s create a <strong class="source inline">ContentHelper</strong> class in the <strong class="source inline">main/java</strong> folder in the root package, which will provide us with the data required for <strong class="source inline">ContentResolver</strong>. We will define two methods for accessing the photo and video content URI and two methods that will <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">ContentValues</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>We do this because of the static methods required to obtain URIs and create <strong class="source inline">ContentValues</strong>, which makes<a id="_idIndexMarker1092"/> this functionality hard to test. The following code is truncated for space. The full code<a id="_idIndexMarker1093"/> you need to add can be found via the link that follows<a id="_idIndexMarker1094"/> this <span class="No-Break">code block:</span></p>
			<pre class="source code">
    class MediaContentHelper {
        fun getImageContentUri(): Uri =
            if (android.os.Build.VERSION.SDK_INT &gt;=
            android.os.Build.VERSION_CODES.Q) {
                MediaStore.Images.Media.getContentUri
                (MediaStore.VOLUME_EXTERNAL_PRIMARY)
            } else {
                MediaStore.Images.Media
                .EXTERNAL_CONTENT_URI
            }
        fun generateImageContentValues(fileInfo:
        FileInfo) = ContentValues().apply {
            this.put(MediaStore.Images.Media
            .DISPLAY_NAME, fileInfo.name)
        if (android.os.Build.VERSION.SDK_INT &gt;=
            android.os.Build.VERSION_CODES.Q) {
                this.put(MediaStore.Images.Media
                .RELATIVE_PATH, fileInfo.relativePath)
        }
        this.put(MediaStore.Images.Media .MIME_TYPE,
            fileInfo.mimeType)
    }</pre>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/DhOLR"><span class="No-Break">https://packt.link/DhOLR</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="8">Now, let’s create the <strong class="source inline">ProviderFileManager</strong> class in the <strong class="source inline">main/java</strong> folder in the root<a id="_idIndexMarker1095"/> package, where we will define methods to generate files for photos and videos that will then be used<a id="_idIndexMarker1096"/> by the camera and the methods that will save<a id="_idIndexMarker1097"/> to the media store. Again, the code has been truncated for brevity. Please see the link that follows this code block for the full code that you need <span class="No-Break">to use:</span><pre class="source code">
    class ProviderFileManager(
    ) {
        fun generatePhotoUri(time: Long): FileInfo {
            val name = "img_$time.jpg"
            val file = File(
                context.getExternalFilesDir(
                fileHelper .getPicturesFolder()), name
            )
            return FileInfo(
                fileHelper.getUriFromFile(file),
                file, name,
                fileHelper.getPicturesFolder(),
                "image/jpeg"
            )
        }</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/ohv7a"><span class="No-Break">https://packt.link/ohv7a</span></a><span class="No-Break">.</span></p>
			<p>Note how we defined the root folders as <strong class="source inline">context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</strong> and <strong class="source inline">context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)</strong>. This connects to <strong class="source inline">file_provider_paths.xml</strong> and it will create a set of folders called <strong class="source inline">Movies</strong> and <strong class="source inline">Pictures</strong> in the application’s dedicated folder in external storage. The <strong class="source inline">insertToStore</strong> method is where the files will be then copied to <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">MediaStore</strong></span><span class="No-Break">.</span></p>
			<p>First, we will create an entry<a id="_idIndexMarker1098"/> into that store that will give us a URI<a id="_idIndexMarker1099"/> for that entry. Next, we copy<a id="_idIndexMarker1100"/> the contents of the files from the URI generated by <strong class="source inline">FileProvider</strong> into <strong class="source inline">OutputStream</strong>, pointing to the <span class="No-Break"><strong class="source inline">MediaStore</strong></span><span class="No-Break"> entry.</span></p>
			<ol>
				<li value="9">Add the following strings <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">strings.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;string name="photo"&gt;Photo&lt;/string&gt;
    &lt;string name="video"&gt;Video&lt;/string&gt;</pre></li>
				<li>Let’s define the layout for our activity <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">res/layout/activity_main.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;Button
        android:id="@+id/photo_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/photo" /&gt;
    &lt;Button
        android:id="@+id/video_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="5dp"
        android:text="@string/video" /&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/6iSNp"><span class="No-Break">https://packt.link/6iSNp</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="11">Let’s create the <strong class="source inline">MainActivity</strong> class in the <strong class="source inline">main/java</strong> folder in the root package, where we<a id="_idIndexMarker1101"/> will check whether<a id="_idIndexMarker1102"/> we need to request <strong class="source inline">WRITE_STORAGE_PERMISSION</strong>, request it if we need to, and after it is granted, open the camera to take<a id="_idIndexMarker1103"/> a photo or a video. As before, the code here has been truncated for brevity. You can access the full code using the link<a id="_idIndexMarker1104"/> that follows<a id="_idIndexMarker1105"/> the <span class="No-Break">code</span><span class="No-Break"><a id="_idIndexMarker1106"/></span><span class="No-Break"> block:</span><pre class="source code">
class MainActivity : AppCompatActivity() {
        private lateinit var providerFileManager:
            ProviderFileManager
        private var photoInfo: FileInfo? = null
        private var videoInfo: FileInfo? = null
        private var isCapturingVideo = false
    override fun onCreate(savedInstanceState:
    Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        providerFileManager =
            ProviderFileManager(applicationContext,
            FileHelper(applicationContext),
            contentResolver, Executors
            .newSingleThreadExecutor(),
            MediaContentHelper()
            )</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/YeHWC"><span class="No-Break">https://packt.link/YeHWC</span></a><span class="No-Break">.</span></p>
			<p>If we execute<a id="_idIndexMarker1107"/> the preceding<a id="_idIndexMarker1108"/> code, we will<a id="_idIndexMarker1109"/> see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B19411_12_06.jpg" alt="Figure 12.6 – Output of Exercise 12.04"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Output of Exercise 12.04</p>
			<ol>
				<li value="12">By clicking on either of the buttons, you will be redirected to the camera application, where you can take a photo or a video if you are running the example on Android 10 and above. If you’re running on lower Android versions, then the permissions will be <span class="No-Break">asked first.</span></li>
			</ol>
			<p>Once you have taken your photo<a id="_idIndexMarker1110"/> and confirmed<a id="_idIndexMarker1111"/> it, you will be taken b<a id="_idTextAnchor688"/>ack to the application. The photo will be saved in the location you defined <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">FileProvider</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B19411_12_07.jpg" alt="Figure 12.7 – The location of the captured files through the camera app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – The location of the captured files through the camera app</p>
			<p>In the preceding screenshot, you can see where<a id="_idIndexMarker1112"/> the files are located with the help<a id="_idIndexMarker1113"/> of Android<a id="_idIndexMarker1114"/> Studio’s <strong class="bold">Device File Explorer</strong>. If you open any file-exploring app, such as th<a id="_idTextAnchor689"/>e <strong class="bold">Files</strong>, <strong class="bold">Gallery</strong>, or <strong class="bold">Google Photos</strong> app, you will be able to see the vide<a id="_idTextAnchor690"/>os and <span class="No-Break">pic<a id="_idTextAnchor691"/>tures taken.</span></p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B19411_12_08.jpg" alt="Figure 12.8 – The files from the app present in the File Explorer app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – The files from the app present in the File Explorer app</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor692"/>Activity 12.01 – dog downloader</h2>
			<p>You are tasked with building<a id="_idIndexMarker1115"/> an application that will target Android versions above API 21 and<a id="_idIndexMarker1116"/> display a list of URLs for dog photos. The URL you will connect to is <strong class="source inline">https://dog.ceo/api/breed/hound/images/random/{number}</strong>, where <strong class="source inline">number</strong> will be controlled through a <strong class="bold">Settings</strong> screen, where a user can choose the number of URLs they want to <span class="No-Break">be displayed.</span></p>
			<p>The <strong class="bold">Settings</strong> screen will be opened through an option presented on the home screen. When a user clicks on a URL, an image will be downloaded locally in the application’s external cache path. While the image is being downloaded, the user will see an indeterminate progress bar. The list of URLs will be persisted locally <span class="No-Break">using Room.</span></p>
			<p>The technologies that we will use are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Retrofit to retrieve the list of URLs and <span class="No-Break">download files</span></li>
				<li>Room to persist the list <span class="No-Break">of URLs</span></li>
				<li><strong class="source inline">SharedPreferences</strong> to store the number of URLs <span class="No-Break">to retrieve</span></li>
				<li><strong class="source inline">FileProvider</strong> to store the files in <span class="No-Break">the cache</span></li>
				<li>Apache IO to write <span class="No-Break">the files</span></li>
				<li>Repository to combine all the <span class="No-Break">data sources</span></li>
				<li><strong class="source inline">LiveData</strong> and <strong class="source inline">ViewModel</strong> to handle the logic from <span class="No-Break">the user</span></li>
				<li><strong class="source inline">RecyclerView</strong> for the list <span class="No-Break">of items</span></li>
			</ul>
			<p>The response JSON <a id="_idIndexMarker1117"/>will look similar<a id="_idIndexMarker1118"/> <span class="No-Break">to this:</span></p>
			<pre class="source code">
{
    "message": [
        "https://images.dog.ceo/breeds/hound-
        afghan/n02088094_4837.jpg",
        "https://images.dog.ceo/breeds/hound-
        basset/n02088238_13908.jpg",
        "https://images.dog.ceo/breeds/hound-
        ibizan/n02091244_3939.jpg"
    ],
    "status": "success"
}</pre>
			<p>Perform the following steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create an <strong class="source inline">api</strong> package that will contain the <span class="No-Break">network-related classes.</span></li>
				<li>Create a data class that will model the <span class="No-Break">response JSON.</span></li>
				<li>Create a Retrofit <strong class="source inline">Service</strong> class that will contain two methods. The first method will represent the API call to return a list of breeds, and the second method will represent the API call to download <span class="No-Break">the file.</span></li>
				<li>Create a <strong class="source inline">storage</strong> package, and inside it, create a <span class="No-Break"><strong class="source inline">room</strong></span><span class="No-Break"> package.</span></li>
				<li>Create the <strong class="source inline">Dog</strong> entity, which will contain an autogenerated ID and <span class="No-Break">a URL.</span></li>
				<li>Create the <strong class="source inline">DogDao</strong> class, which will contain methods to insert a list of <strong class="source inline">Dogs</strong>, delete all <strong class="source inline">Dogs</strong>, and query all <strong class="source inline">Dogs</strong>. The <strong class="source inline">delete</strong> method is required because the API model does not have any <span class="No-Break">unique identifiers.</span></li>
				<li>Inside the <strong class="source inline">storage</strong> package, create a <span class="No-Break"><strong class="source inline">preference</strong></span><span class="No-Break"> package.</span></li>
				<li>Inside the <strong class="source inline">preference</strong> package, create<a id="_idIndexMarker1119"/> a wrapper class around <strong class="source inline">SharedPreferences</strong> that will return the number of URLs we need to use and set<a id="_idIndexMarker1120"/> the number. The default will <span class="No-Break">be </span><span class="No-Break"><strong class="source inline">10</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source inline">res/xml</strong>, define your folder structure for <strong class="source inline">FileProvider</strong>. The files should be saved in the root folder of the <span class="No-Break"><strong class="source inline">external-cache-path</strong></span><span class="No-Break"> tag.</span></li>
				<li>Inside the <strong class="source inline">storage</strong> package, create a <span class="No-Break"><strong class="source inline">filesystem</strong></span><span class="No-Break"> package.</span></li>
				<li>Inside the <strong class="source inline">filesystem</strong> package, define a class that will be responsible for writing <strong class="source inline">InputStream</strong> into a file in <strong class="source inline">FileProvider</strong>, <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">Context.externalCacheDir</strong></span><span class="No-Break">.</span></li>
				<li>Create a <span class="No-Break"><strong class="source inline">repository</strong></span><span class="No-Break"> package.</span></li>
				<li>Inside the <strong class="source inline">repository</strong> package, create a sealed class that will hold the result of an API call. The subclasses of the sealed class will be <strong class="source inline">Success</strong>, <strong class="source inline">Error</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">Loading</strong></span><span class="No-Break">.</span></li>
				<li>Define a <strong class="source inline">Repository</strong> interface that will contain two methods, one to load the list of URLs and the other to download <span class="No-Break">a file.</span></li>
				<li>Define a <strong class="source inline">DogUi</strong> model class that will be used in the UI layer of your application and that will be created in <span class="No-Break">your repository.</span></li>
				<li>Define a mapper class that will convert your API models into entities and entities into <span class="No-Break">UI models.</span></li>
				<li>Define an implementation for <strong class="source inline">Repository</strong> that will implement the preceding two methods. The repository will hold references to <strong class="source inline">DogDao</strong>, the Retrofit <strong class="source inline">Service</strong> class, the <strong class="source inline">Preferences</strong> wrapper class, the class managing the files, the <strong class="source inline">Dog</strong> mapping class, and the <strong class="source inline">Executor</strong> class for multithreading. When downloading the files, we will use the filename extracted from <span class="No-Break">the URL.</span></li>
				<li>Create a class that will extend <strong class="source inline">Application</strong>, which will initialize <span class="No-Break">the repository.</span></li>
				<li>Define the <strong class="source inline">ViewModel</strong> class used by your UI, which will have a reference to <strong class="source inline">Repository</strong> and call it to load the URL list and download <span class="No-Break">the images.</span></li>
				<li>Define your UI, which will be composed of <span class="No-Break">two activities:</span><ul><li><strong class="source inline">MainActivity</strong> which displays the list of URLs and will have a click action to start the downloads. This activity will have a progress bar, which will be displayed when the download takes place. The screen will also have a <strong class="bold">Settings</strong> option, which will open <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">SettingsActivity</strong></span><span class="No-Break">.</span></li><li>The <strong class="source inline">SettingsActivity</strong>, which<a id="_idIndexMarker1121"/> will display <strong class="source inline">EditText</strong> and <strong class="source inline">Button</strong> and save the number<a id="_idIndexMarker1122"/> <span class="No-Break">of URLs.</span></li></ul></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/z6g5j"><span class="No-Break">https://packt.link/z6g5j</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor693"/>Summary</h1>
			<p>In this chapter, we analyzed alternatives to Room when it comes to persisting data. We looked first at <strong class="source inline">SharedPreferences</strong> and how it constitutes a handy solution for data persistence when it’s in a key-value format and the amount of data is small. We also looked at <strong class="source inline">DataStore</strong> and how we can use it like <strong class="source inline">SharedPreferences</strong> but with built-in observability, which notifies us when values <span class="No-Break">are changed.</span></p>
			<p>Next, we looked over something that was continuously changing when it comes to the Android framework – the evolution of abstractions regarding a filesystem. We started with an overview of the types of storage that Android has and then took a more in-depth look at two of the abstractions – <strong class="source inline">FileProvider</strong>, which your app can use to store files on a device and share them with others if necessary, and the SAF, which can be used to save files on the device in a location selected by <span class="No-Break">a user.</span></p>
			<p>We also used the benefits of <strong class="source inline">FileProvider</strong> to generate URIs for files in order to use camera applications to take photos and record videos, saving them in the application’s files while also adding them <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">MediaStore</strong></span><span class="No-Break">.</span></p>
			<p>The activity performed in this chapter combines all the elements discussed previously to illustrate the point that even though you have to balance multiple sources inside an application, you can do it in a more <span class="No-Break">readable way.</span></p>
			<p>Note that for the activity and exercises in this chapter and the previous one, we kept having to use the <strong class="source inline">application</strong> class to instantiate the data sources. In the next chapter, you will lea<a id="_idTextAnchor694"/>rn how to overcome this through dependency injection and see how it can benefit <span class="No-Break">Android applications.</span></p>
		</div>
	</body></html>