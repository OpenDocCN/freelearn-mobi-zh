<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor137"/>3</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor138"/>Handling the UI State in Jetpack Compose and Using Hilt</h1>
<p>All Android applications display the state to users, which helps inform users on what the outcome is and when. The <strong class="bold">state</strong> in an Android application is any value that changes over time, and a good example <a id="_idIndexMarker179"/>is a toast that shows a message when there is an error. In this chapter, readers will learn how to handle the UI state better with the new Jetpack library.</p>
<p>It is fair to say with great power comes great responsibility, and managing the state of any Composable component requires a distinct approach compared to using the older way of building Android views, or as many might call it, the imperative way. This means Jetpack’s library, Compose, is entirely different from XML layouts.</p>
<p>Handling the UI state in the XML <strong class="bold">View System</strong> is very straightforward. The process entails setting the properties of the views to reflect the current state – that is, showing or hiding the views accordingly. For instance, when loading data from an API, you can hide the loading view, show the content view, and populate it with the desired views.</p>
<p>In Compose, however, it is impossible to change a Composable component once the application has drawn it. You can, however, change the values passed to each Composable by changing the state each Composable receives. Hence, learning about managing the state better when building robust Android applications will be handy.</p>
<p>In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Implementing <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) with Jetpack Hilt</li>
<li>Implementing <code>ViewModel</code> classes and understanding the state in Compose</li>
<li>Implementing Compose in existing an XML layout-based project</li>
<li>Understanding and handling recomposition in Jetpack Compose</li>
<li>Writing UI tests for your Compose views<a id="_idTextAnchor139"/></li>
<li>Writing tests for your <code>ViewModel</code> classes<a id="_idTextAnchor140"/></li>
</ul>
<h1 id="_idParaDest-82"><a id="_idTextAnchor141"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three</a>.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor142"/>Implementing DI with Jetpack Hilt</h1>
<p>In object-oriented programming, DI is vital. Some people use it, and some prefer not to use it for their <a id="_idIndexMarker180"/>own reasons. However, DI is <a id="_idIndexMarker181"/>the practice of designing objects in a manner where they receive instances of the object from other pieces of code instead of constructing them internally.</p>
<p>If you know of the SOLID principles, you know their primary goal is to make software design easier to maintain, read, test, and build upon. In addition, DI helps us follow some of the SOLID principles. The dependency inversion principle allows the code base to be easily expanded and extended with new functionalities and improves reusability. In Modern Android Development, DI is essential, and we will implement it in our application in this recipe.</p>
<p>There are different types of libraries that you can use in Android for DI, such as Koin, Dagger, and Hilt; Hilt harnesses the power of Dagger and benefits from compile-time correctness, good runtime performance, Android studio support, and scalability. For this recipe, we will use Hilt, which provides containers for every Android class in our project and automatic<a id="_idTextAnchor143"/>ally manages their life cycle.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor144"/>Getting ready</h2>
<p>Just like in previous recipes, we will use the project we have used in previous recipes to add DI.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor145"/>How to do it…</h2>
<p>Hilt uses Java features; make sure your project is in the <code>app/build.gradle</code>, and you have the following compile options:</p>
<pre class="source-code">
android {
    ...
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11
    }
}</pre>
<p>This is already added automatically, but make sure you check that you have it just in case. Let's get started:</p>
<ol>
<li>First, we must add the <code>Hilt-android-gradle-plugin</code> plugin into our project’s root file, <code>build.gradle(Project:SampleLogin)</code>:<pre class="source-code">
plugins {</pre><pre class="source-code">
    id 'com.google.dagger.Hilt.android' version '2.44'</pre><pre class="source-code">
apply false</pre><pre class="source-code">
}</pre></li>
<li>Then, in our <code>app/build.gradle</code> file, add these dependencies, and sync the project. It should run without any issues:<pre class="source-code">
plugins {</pre><pre class="source-code">
    id 'kotlin-kapt'</pre><pre class="source-code">
    id 'dagger.Hilt.android.plugin'</pre><pre class="source-code">
}</pre><pre class="source-code">
dependencies {</pre><pre class="source-code">
    implementation "com.google.dagger:Hilt-</pre><pre class="source-code">
        android:2.44"</pre><pre class="source-code">
    kapt "com.google.dagger:Hilt-compiler:2.44"</pre><pre class="source-code">
}</pre></li>
<li>Now, let’s go <a id="_idIndexMarker182"/>ahead and <a id="_idIndexMarker183"/>add the <code>Application</code> class. All apps that use Hilt must have an <code>Application</code> class annotated with <code>@HiltAndroidApp</code>, and we need to call the <code>Application</code> class that we create in <code>Manifest</code>:<pre class="source-code">
@HiltAndroidApp</pre><pre class="source-code">
class LoginApp : Application()</pre></li>
<li>In our <code>Manifest</code> folder, let’s add <code>LoginApp</code>:<pre class="source-code">
&lt;application</pre><pre class="source-code">
    android:name=".LoginApp"</pre><pre class="source-code">
  ...</pre></li>
<li>Now that we <a id="_idIndexMarker184"/>have the setup <a id="_idIndexMarker185"/>done, we need to start working with Hilt by adding the required annotations to our class. In <code>MainActivity.kt</code>, we need to add the <code>@</code><code>AndroidEntryPoint</code> annotation:<pre class="source-code">
@AndroidEntryPoint</pre><pre class="source-code">
class MainActivity : ComponentActivity() {</pre><pre class="source-code">
  ...</pre></li>
<li>Let’s go ahead and display what we did by running the <code>./gradlew :app:dependencies</code> command, and we will see something similar to <em class="italic">Figure 3</em><em class="italic">.1</em>.</li>
</ol>
<div><div><img alt="Figure 3.1 – Dagger Hilt dependency tree" src="img/Figure_3.4_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Dagger Hilt dependency tree</p>
<p>You can also view the dependency in Android Studio. That is by clicking on the <strong class="bold">Gradle</strong> tab on the right-hand side and selecting <strong class="bold">expand:yourmodule</strong> | <strong class="bold">Tasks</strong> | <strong class="bold">android</strong>. Then, finally, double-click on <strong class="bold">androidDependencies</strong> to run it.</p>
<p>Finally, compile and run the pr<a id="_idTextAnchor146"/>oject; it should run successfully.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor147"/>How it works…</h2>
<p><code>@HiltAndroidApp</code> triggers Hilt’s code generation, including a base class for our application, which acts as the application-level dependency container. The <code>@AndroidEntryPoint</code> annotation adds a DI container to the Android class annotated with it. When <a id="_idIndexMarker186"/>using Hilt, the <a id="_idIndexMarker187"/>generated Hilt component is attached to the Application object’s life cycle and provides its dependencies. Hilt currently supports the following Android classes:</p>
<ul>
<li><code>ViewModel</code> annotated as <code>@HiltViewModel</code></li>
<li><code>Application</code> annotated as <code>@HiltAndroidApp</code></li>
<li><code>Activity</code></li>
<li><code>Fragment</code></li>
<li><code>View</code></li>
<li><code>Service</code></li>
<li><code>BroadcastReceiver</code></li>
</ul>
<p>We will use other necessary annotations in Hilt later, for instance, the <code>@Module</code> annotation, <code>@InstallIn</code>, and <code>@Provides</code>. The <code>@Module</code> annotation means the class in which you <a id="_idIndexMarker188"/>can add binding for <a id="_idIndexMarker189"/>types that cannot be injected in the constructor. <code>@InstallIn</code> indicates which Hilt-generated DI container (or singleton component) has to be available in the code module binding.</p>
<p>Finally, <code>@Provides</code> binds a type that cannot be constructor injected. Its return type is the binding type, it can take dependency parameters, and every time you need an instance, the function body is executed if the type is not scoped.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor148"/>Implementing ViewModel classes and understanding the state in Compose</h1>
<p>In Android, a <code>ViewModel</code> is a class responsible for consciously managing the UI-related data life cycle. There is also <a id="_idIndexMarker190"/>a lot of debate in the community about <a id="_idIndexMarker191"/>whether developers should use <code>ViewModel</code> in Compose or not. However, Manuel Vivo, a senior Android developer relations engineer at Google, says:</p>
<p><em class="italic">“I’d include them if their benefits apply to your app. No need to use them if you handle all configuration changes yourself and don’t use Navigation Compose. Otherwise, use ViewModels not to reinvent </em><em class="italic">the wheel.”</em></p>
<p><em class="italic">“On the other hand, the debate as to why one should not use ViewModels is based on the argument that in pure Compose, since Compose handles configuration changes, having your Composable functions reference the ViewModel </em><em class="italic">is unnecessary.”</em></p>
<p>You can also refer to this tweet by Jim Sproch: <a href="https://twitter.com/JimSproch/status/1397169679647444993">https://twitter.com/JimSproch/status/1397169679647444993</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find more <a id="_idIndexMarker192"/>info about the benefits of using the ViewModel here: <a href="https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth">https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth</a>.</p>
<p>This means using <code>ViewModel</code> to handle the state in your application will be a question of personal <a id="_idIndexMarker193"/>choice with Jetpack Compose. The currently recommended architecture pattern in Android is <strong class="bold">Model-View-View-Model</strong> (<strong class="bold">MVVM</strong>), and many applications use it.</p>
<p>Jetpack Compose uses a unidirectional data flow design pattern; this means the data or state only streams down while the events stream up. Hence, a clear understanding of how we can utilize the <a id="_idIndexMarker194"/>unidirectional pattern to make our code more <a id="_idIndexMarker195"/>readable, maintainable, and testable as much as possible using the <code>ViewModel</code> class will be helpful.</p>
<p>In addition, <code>ViewModel</code> is suitable for providing your application with access to business logic, preparing the data for presentation on the screen, and making your code test<a id="_idTextAnchor149"/>able.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor150"/>Getting ready</h2>
<p>In this recipe, we will work with a pre-built skeleton <code>SampleLogin</code> project, which you can download from the <em class="italic">Technical requirements</em> se<a id="_idTextAnchor151"/>ction. We will use Hilt in this recipe since the project uses Hilt, but we will explain Hilt in a next recipe.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor152"/>How to do it…</h2>
<p>You will now create a <code>ViewModel</code> class and modify most of the code in the <code>LoginContent</code> Kotlin file:</p>
<ol>
<li>To keep our classes and files well organized, let’s go ahead and first create a package to hold our UI and view models. Navigate to the main <code>Package</code> folder, right-click to open a prompt, then go down to <strong class="bold">Package</strong>, and a dialog with a package name will appear.</li>
</ol>
<div><div><img alt="Figure 3.2 – How to create a package" src="img/Figure_3.1_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – How to create a package</p>
<ol>
<li value="2">Name the package <code>Login</code>; inside <code>LoginContent</code> file and add the new class, <code>LoginViewModel</code>, there. Go ahead and create a <code>ViewModel</code> class:<pre class="source-code">
class LoginViewModel {...}</pre></li>
<li>Now that we have created a <code>LoginViewModel</code> class, we need to add a DI annotation of <code>HiltViewModel</code> and ensure we extend the <code>ViewModel</code> class:<pre class="source-code">
@HiltViewModel</pre><pre class="source-code">
class LoginViewModel @Inject constructor(</pre><pre class="source-code">
): ViewModel(){. . .}</pre></li>
<li>In our <code>ViewModel</code> constructor, we will need to add <code>stateHandle: SavedStateHandle</code>, which <a id="_idIndexMarker196"/>will help us maintain and retrieve <a id="_idIndexMarker197"/>objects to and from the saved state. These values persist even after the system kills the process and remain available through the same object:<pre class="source-code">
@HiltViewModel</pre><pre class="source-code">
class LoginViewModel @Inject constructor(</pre><pre class="source-code">
    stateHandle: SavedStateHandle</pre><pre class="source-code">
) : ViewModel() {...}</pre></li>
<li>Before we build our <code>ViewModel</code>, let’s go ahead and create a data class, <code>AuthenticationState()</code>. This class will come in handy during our testing since we need to be able to test most of our validation cases. A <code>View</code> state class, plus <a id="_idIndexMarker198"/>having a single source of truth, has many advantages and is one of the principles of <strong class="bold">Model-View-Intent</strong> (<strong class="bold">MVI</strong>):<pre class="source-code">
data class AuthenticationState(</pre><pre class="source-code">
    val userName: String = "",</pre><pre class="source-code">
    val password: String = "",</pre><pre class="source-code">
    val loading: Boolean = false,</pre><pre class="source-code">
    var togglePasswordVisibility: Boolean = true</pre><pre class="source-code">
) {</pre><pre class="source-code">
    companion object {</pre><pre class="source-code">
        val EMPTY_STATE = AuthenticationState()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now, let’s go <a id="_idIndexMarker199"/>ahead and create a helper class, <code>MutableSavedState&lt;T&gt;()</code>, which will take in <code>savedStateHandle</code>, a key, and a<a id="_idIndexMarker200"/> default value. This class acts as a <code>MutableStateFlow()</code> but saves the data and value and retrieves it upon the application’s death with the help of <code>SavedStateHandle</code>:<pre class="source-code">
class MutableSavedState&lt;T&gt;(</pre><pre class="source-code">
    private val savedStateHandle: SavedStateHandle,</pre><pre class="source-code">
    private val key: String,</pre><pre class="source-code">
    defValue: T,</pre><pre class="source-code">
) {</pre><pre class="source-code">
 . . .</pre><pre class="source-code">
}</pre></li>
<li>Now, let’s go ahead and create callbacks that will be invoked when a user enters their username and password in our <code>LoginViewModel</code>:<pre class="source-code">
private val username = MutableSavedState(</pre><pre class="source-code">
    stateHandle,</pre><pre class="source-code">
    "UserName",</pre><pre class="source-code">
    defValue = ""</pre><pre class="source-code">
)</pre><pre class="source-code">
fun userNameChanged(userName: String){</pre><pre class="source-code">
    username.value = userName</pre><pre class="source-code">
}</pre></li>
<li>Go ahead and do the same for password and password toggle visibility.</li>
<li>Now, we need to create a <code>combineFlows</code> helper class. You can combine more than two flows <a id="_idIndexMarker201"/>in Kotlin; a coroutine <code>flow</code> is a type that <a id="_idIndexMarker202"/>emits multiple values sequentially, as opposed to the <code>suspend</code> function, which returns a single value. More details on how to combine flows can be found at <code>combine(flow1</code>, <code>flow2</code>, <code>flow3</code>, <code>flow4) {t1, t2, t3, t4 -&gt; </code><code>resultMapper}.stateIn(scope)</code>:<pre class="source-code">
fun &lt;T1, T2, T3, T4, T5, T6, R&gt; combine(</pre><pre class="source-code">
    flow: Flow&lt;T1&gt;,</pre><pre class="source-code">
    flow2: Flow&lt;T2&gt;,</pre><pre class="source-code">
    flow3: Flow&lt;T3&gt;,</pre><pre class="source-code">
    flow4: Flow&lt;T4&gt;,</pre><pre class="source-code">
    flow5: Flow&lt;T5&gt;,</pre><pre class="source-code">
    flow6: Flow&lt;T6&gt;,</pre><pre class="source-code">
    transform: suspend (T1, T2, T3, T4, T5, T6) -&gt; R</pre><pre class="source-code">
): Flow&lt;R&gt; = combine(</pre><pre class="source-code">
        combine(flow, flow2, flow3, ::Triple),</pre><pre class="source-code">
        combine(flow4, flow5, flow6, ::Triple)</pre><pre class="source-code">
) { t1, t2 -&gt;</pre><pre class="source-code">
    transform(</pre><pre class="source-code">
        t1.first,</pre><pre class="source-code">
        t1.second,</pre><pre class="source-code">
        t1.third,</pre><pre class="source-code">
        t2.first,</pre><pre class="source-code">
        t2.second,</pre><pre class="source-code">
        t2.third</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Read <a id="_idIndexMarker203"/>more here – <a href="https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows">https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows</a>:</p>
<pre class="source-code">
val state = combineFlows(
    username.flow,
    password.flow,
    passwordVisibilityToggle.flow,
    loadingProgress.flow
) { username, password, passwordToggle, isLoading -&gt;
    AuthenticationState(
        userName = username,
        password = password,
        togglePasswordVisibility = passwordToggle,
        loading = isLoading
    )
}.stateIn(. . .)</pre>
<ol>
<li value="10">Now, let’s go ahead and create our helper class for using coroutines and call it <code>SampleLoginDispatchers()</code>; it will help us in testing our code and ensuring our code is easily readable. In addition, we use coroutine dispatchers that help determine what thread the corresponding coroutine should use for execution:<pre class="source-code">
.stateIn(</pre><pre class="source-code">
   coroutineScope = viewModelScope + dispatchers.main,</pre><pre class="source-code">
   initialValue = AuthenticationState.EMPTY_STATE</pre><pre class="source-code">
)</pre></li>
</ol>
<p><code>SharedFlow</code> represents a read-only state with a single updatable data value, which emits any updates to its collectors. On the other hand, a state flow is a hot flow because its active instance exists independently of the presence of collectors.</p>
<ol>
<li value="11">The <code>SharingStarted </code>coroutine flow operator in Android is used to share the execution of a flow <a id="_idIndexMarker204"/>among multiple collectors. It is <a id="_idIndexMarker205"/>commonly used to create a “hot” flow, which means that the flow starts emitting data as soon as it is created, and the data is shared among all the active collectors of the flow. These can be back-to-back emissions of the same command and have no effect:<pre class="source-code">
fun &lt;T&gt; Flow&lt;T&gt;.stateIn(</pre><pre class="source-code">
    coroutineScope: CoroutineScope,</pre><pre class="source-code">
    initialValue: T</pre><pre class="source-code">
): StateFlow&lt;T&gt; = stateIn(</pre><pre class="source-code">
    scope = coroutineScope,</pre><pre class="source-code">
    started = SharingStarted.WhileSubscribed(5000),</pre><pre class="source-code">
    initialValue = initialValue</pre><pre class="source-code">
)</pre></li>
<li>There are four types of dispatchers. In our example, we will only use three. In addition, you <a id="_idIndexMarker206"/>can inject a single dispatcher and <a id="_idIndexMarker207"/>achieve the same result without the class; hence, this can be preference-based. See how it works for the four types of dispatchers:<pre class="source-code">
class SampleLoginDispatchers(</pre><pre class="source-code">
    val default: CoroutineDispatcher,</pre><pre class="source-code">
    val main: CoroutineDispatcher,</pre><pre class="source-code">
    val io: CoroutineDispatcher</pre><pre class="source-code">
) {</pre><pre class="source-code">
    companion object {</pre><pre class="source-code">
        fun createTestDispatchers(coroutineDispatcher:</pre><pre class="source-code">
        CoroutineDispatcher): SampleLoginDispatchers {</pre><pre class="source-code">
            return SampleLoginDispatchers(</pre><pre class="source-code">
                default = coroutineDispatcher,</pre><pre class="source-code">
                main = coroutineDispatcher,</pre><pre class="source-code">
                io = coroutineDispatcher</pre><pre class="source-code">
            )</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
</ol>
<p>Now that we have created our helper class, we must provide the dispatcher via DI. We have an entire recipe dedicated to Hilt, so we will look at the concepts and what the annotations mean in the Hilt recipe.</p>
<ol>
<li value="13">Create a new package and call the package <code>di</code>. In this package, create a new object and call it <code>AppModule</code>; we will provide our dispatcher to the <code>ViewModel</code> constructor via the dependency graph:<pre class="source-code">
@Module</pre><pre class="source-code">
@InstallIn(SingletonComponent::class)</pre><pre class="source-code">
object AppModule {</pre><pre class="source-code">
    @Provides</pre><pre class="source-code">
    fun provideSlimeDispatchers():</pre><pre class="source-code">
    SampleLoginDispatchers {</pre><pre class="source-code">
        return SampleLoginDispatchers(</pre><pre class="source-code">
        default = Dispatchers.Default,</pre><pre class="source-code">
        main = Dispatchers.Main,</pre><pre class="source-code">
        io = Dispatchers.IO</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>We will now need to go to <code>LoginContent</code> and modify the code – that is, by adding callbacks <a id="_idIndexMarker208"/>that will correspond to our <code>ViewModel</code>, and <a id="_idIndexMarker209"/>whenever we have a view – for example, <code>UserNameField()</code> – we will use the callback. See the sample code:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun LoginContent(</pre><pre class="source-code">
    modifier: Modifier = Modifier,</pre><pre class="source-code">
    uiState: AuthenticationState,</pre><pre class="source-code">
    onUsernameUpdated: (String) -&gt; Unit,</pre><pre class="source-code">
    onPasswordUpdated: (String) -&gt; Unit,</pre><pre class="source-code">
    onLogin: () -&gt; Unit,</pre><pre class="source-code">
    passwordToggleVisibility: (Boolean) -&gt; Unit</pre><pre class="source-code">
){</pre><pre class="source-code">
. . .</pre><pre class="source-code">
UserNameField(authState = uiState, onValueChanged =</pre><pre class="source-code">
onUsernameUpdated)</pre><pre class="source-code">
PasswordInputField(</pre><pre class="source-code">
    text = stringResource(id = R.string.password),</pre><pre class="source-code">
    authState = uiState,</pre><pre class="source-code">
    onValueChanged = onPasswordUpdated,</pre><pre class="source-code">
    passwordToggleVisibility =</pre><pre class="source-code">
        passwordToggleVisibility</pre><pre class="source-code">
)</pre><pre class="source-code">
LoginButton(</pre><pre class="source-code">
    text = stringResource(id = R.string.sign_in),</pre><pre class="source-code">
    enabled = if (uiState.isValidForm()) {</pre><pre class="source-code">
        !uiState.loading</pre><pre class="source-code">
    } else {</pre><pre class="source-code">
        false</pre><pre class="source-code">
    },</pre><pre class="source-code">
    onLoginClicked = {</pre><pre class="source-code">
        onLogin.invoke()</pre><pre class="source-code">
    },</pre><pre class="source-code">
    isLoading = uiState.loading</pre><pre class="source-code">
). . .}</pre></li>
<li>Now, in <a id="_idIndexMarker210"/>our <code>LoginContentScreen</code> Composable <a id="_idIndexMarker211"/>function, we will pass our <code>LoginViewModel</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun LoginContentScreen(</pre><pre class="source-code">
    loginViewModel: LoginViewModel,</pre><pre class="source-code">
    onRegisterNavigateTo: () -&gt; Unit</pre><pre class="source-code">
) {</pre><pre class="source-code">
    val viewState by</pre><pre class="source-code">
        loginViewModel.state.collectAsState()</pre><pre class="source-code">
    LoginContent(</pre><pre class="source-code">
        uiState = viewState,</pre><pre class="source-code">
        onUsernameUpdated =</pre><pre class="source-code">
            loginViewModel::userNameChanged,</pre><pre class="source-code">
         onPasswordUpdated =</pre><pre class="source-code">
            loginViewModel::passwordChanged,</pre><pre class="source-code">
         onLogin = loginViewModel::login,</pre><pre class="source-code">
         passwordToggleVisibility =</pre><pre class="source-code">
             loginViewModel::passwordVisibility,</pre><pre class="source-code">
         onRegister = onRegisterNavigateTo</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Finally, in <code>MainActivity</code>, we can now go ahead and call <code>LoginContentScreen</code>, pass in our <code>ViewModel</code>, and also specify what action we want when the user clicks <code>onRegister</code>:<pre class="source-code">
LoginContentScreen(loginViewModel = HiltViewModel(), onRegisterNavigateTo = {. . .}</pre></li>
<li>For the entire <a id="_idIndexMarker212"/>code, please ensure you check out the <a id="_idIndexMarker213"/>link in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</li>
</ol>
<div><div><img alt="Figure 3.3 – Error state display when we enter﻿ a special character !" src="img/Figure_3.2_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Error state display when we enter<a id="_idTextAnchor153"/> a special character !</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor154"/>How it works…</h2>
<p>Jetpack Compose uses a unidirectional data flow design pattern. This means the data or state only streams down while the events stream up, as shown in <em class="italic">Figure 3</em><em class="italic">.4</em>.</p>
<div><div><img alt="Figure 3.4 – A unidirectional data flow" src="img/Figure_3.3_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – A unidirectional data flow</p>
<p>That is to say, Composable functions receive the state and then display it on the screen. On the other hand, an event can cause the state to need to be updated and come from either a Composable or any other part of your application. Furthermore, whatever handles the state, in our case, <code>ViewModel</code>, receives the event and adjusts the state for us.</p>
<p>We also use <a id="_idIndexMarker214"/>coroutines, which are nothing but lightweight threads, and <a id="_idIndexMarker215"/>they help us handle synchronous and asynchronous programming easily. Furthermore, coroutines allow execution to be suspended and resumed later. The main advantages are that they are lightweight, have built-in cancellation support, have lower chances of memory leaks, and the Jetpack libraries provide coroutine support.</p>
<p>There are four types of dispatchers:</p>
<ul>
<li><code>Main</code> dispatcher executes in the main thread, which is usually <a id="_idIndexMarker216"/>used when your application needs to perform some UI operations within a coroutine. This is because the UI can only be changed from the main thread. Another name for the main thread is the UI thread.</li>
<li><code>IO</code> dispatcher starts the coroutine in the I/O thread; I/O simply means input <a id="_idIndexMarker217"/>and output in programming. This is also used to perform all data work, such as networking, reading, or writing from the database. You can simply say fetching data from the I/O operation is done in the I/O thread.</li>
<li><code>Default</code> dispatcher starts in the default state. Your application <a id="_idIndexMarker218"/>can utilize this if you plan on doing complex long-running calculations, which can block the UI/main thread and make your UI freeze or cause an <code>GlobalScope</code>, and you can use it by simply calling <code>GlobalScope.launch{...}</code>.</li>
<li><code>Unconfined</code>, as the name suggests, is a dispatcher not <a id="_idIndexMarker220"/>confined to any specific thread. This executes the dispatcher to perform its work in a current call frame and lets the coroutine resume whatever threads that are used by the corresponding function.</li>
</ul>
<h2 id="_idParaDest-91"><a id="_idTextAnchor155"/>See also…</h2>
<p>A lot was covered <a id="_idIndexMarker221"/>in this chapter, and it is fair to acknowledge that just this simple recipe cannot explain <code>ViewModel</code> in its entirety. To find out more, see the following link: <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">https://developer.android.com/topic/libraries/architecture/viewmodel</a>.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor157"/>Implementing Compose in an existing XML layout-based project</h1>
<p>Since Compose is a new UI framework, many code bases still rely heavily on XML layouts. However, many <a id="_idIndexMarker222"/>companies are <a id="_idIndexMarker223"/>opting to build new screens using Compose, and this is achievable by utilizing existing XML layouts and adding unique views using <code>ComposeView</code> XML tags. This recipe will look into<a id="_idTextAnchor158"/> adding a Compose view to an XML layout.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor159"/>Getting ready</h2>
<p>In this recipe, we can create a new project or opt to use an existing project that does not heavily rely on Compose. We will try to display <code>GreetingDialog</code> and use an XML layout to show how we can use the <code>ComposeView</code> tag in XML layouts. If you already have a project, you do not need to set this up; you can skip to <em class="italic">step 4<a id="_idTextAnchor160"/></em> in the preceding <em class="italic">How to do </em><em class="italic">it…</em> section.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor161"/>How to do it…</h2>
<p>Now let us go ahead and explore how we can utilize existing XML layouts with Compose:</p>
<ol>
<li>Let’s start by creating a new project or using a preexisting one; if you create a new activity that is not Compose, you can use <code>EmptyActivity</code>, and give it any name.</li>
<li>If you already have a project set up, you can skip this step. If you opt to create a new project, you will have <code>MainActivity</code>, and since this is the old way of creating views, you will notice an XML layout in the <code>resource</code> folder with a TextView that has <code>Hello world</code>. We can go ahead and remove that since we will not use it.</li>
<li>If you already have a project ready, you can launch <code>GreetingDialog</code> on any screen you want. Also, if you opt to create a button instead of a dialog, that is fine, too since the idea is to showcase how we can use XML tags in Jetpack Compose.</li>
<li>Now, let us go ahead and add an XML tag inside <code>activity_main.xml</code> and give <a id="_idIndexMarker224"/>our Compose view an <code>id</code> value. The <a id="_idIndexMarker225"/>first time you add <code>ComposeView</code>, you will see an error message if you still need to add the dependency. Go ahead and click <strong class="bold">Add dependency on android.compose.ui:ui</strong> and the project will sync as shown in <em class="italic">Figure 3</em><em class="italic">.5</em>.</li>
</ol>
<div><div><img alt="Figure 3.5 – A Compose view in XML" src="img/Figure_3.5_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – A Compose view in XML</p>
<ol>
<li value="5">Once you have synced your project, the error will disappear, and you should be able to use this view in <code>MainActivity</code>, or where you want to use <code>ComposeView</code>:<pre class="source-code">
&lt;androidx.Compose.ui.platform.ComposeView</pre><pre class="source-code">
    android:id="@+id/alert_dialog"</pre><pre class="source-code">
    android:layout_width="match_parent"</pre><pre class="source-code">
    android:layout_height="match_parent"/&gt;</pre></li>
<li>Let’s also add <code>viewBinding</code> to our <code>build.gradle(Module:app)</code> so that we can easily access our view in <code>MainActivity</code>. Also, if you already have <code>viewBinding</code> set up, you can skip this part:<pre class="source-code">
buildFeatures{</pre><pre class="source-code">
    viewBinding true</pre><pre class="source-code">
}</pre></li>
<li>Once we <a id="_idIndexMarker226"/>have synced the project, we <a id="_idIndexMarker227"/>can go ahead and, in <code>MainActivity</code>, access <code>ComposeView</code> through binding. Furthermore, it will have a <code>setContent{}</code> method where you can set all your Composables and wrap it into your Theme:<pre class="source-code">
class MainActivity : AppCompatActivity() {</pre><pre class="source-code">
    private lateinit var activityBinding:</pre><pre class="source-code">
    ActivityMainBinding</pre><pre class="source-code">
    override fun onCreate(savedInstanceState: Bundle?)</pre><pre class="source-code">
    {</pre><pre class="source-code">
        super.onCreate(savedInstanceState)</pre><pre class="source-code">
        activityBinding =</pre><pre class="source-code">
           ActivityMainBinding.inflate(layoutInflater)</pre><pre class="source-code">
        setContentView(activityBinding.root)</pre><pre class="source-code">
        activityBinding.alertDialog.setContent {</pre><pre class="source-code">
            GreetingAlertDialog()</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Our <code>GreetingAlertDialog()</code> will have an <code>AlertDialog()</code> Composable, a <a id="_idIndexMarker228"/>title, and text, which will <a id="_idIndexMarker229"/>provide our message as a simple text element. The title will say <code>Hello</code> since this is a greeting, and the message will be <code>Hello, and thank you for being part of the Android community</code>. You can customize this to fit your needs:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun SimpleAlertDialog() {</pre><pre class="source-code">
    AlertDialog(</pre><pre class="source-code">
        onDismissRequest = { },</pre><pre class="source-code">
        confirmButton = {</pre><pre class="source-code">
            TextButton(onClick = {})</pre><pre class="source-code">
            { Text(text = "OK") }</pre><pre class="source-code">
        },</pre><pre class="source-code">
        dismissButton = {</pre><pre class="source-code">
            TextButton(onClick = {})</pre><pre class="source-code">
            { Text(text = "OK") }</pre><pre class="source-code">
        },</pre><pre class="source-code">
        title = { Text(text = "Hello") },</pre><pre class="source-code">
        text = { Text(text = "Hello, and thank you for</pre><pre class="source-code">
        being part of the Android community") }</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>To create Compose components, you will need to add the Compose Material Design dependency to your gradle app. Depending on what your application supports, you can utilize Compose Material 3 components, which is the next evolution of Material Design and comes with updated theming.</li>
<li>You can <a id="_idIndexMarker230"/>easily customize features such <a id="_idIndexMarker231"/>as dynamic color and more. We look into Material 3 in <a href="B18827_11.xhtml#_idTextAnchor619"><em class="italic">Chapter 11</em></a>, <em class="italic">GUI Alerts – What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern Android Development</em>. Hence, for now, since the application that I am using has not migrated to Material 3, I will use this import – <code>implementation "androidx.Compose.material:material:1.x.x"</code>. Here, you can use any import that fits your need.</li>
<li>You can also create a custom view that extends from <code>AbstractComposeView</code>:<pre class="source-code">
class ComposeAlertDialogComponent @JvmOverloads constructor(</pre><pre class="source-code">
    context: Context,</pre><pre class="source-code">
    attrs: AttributeSet? = null,</pre><pre class="source-code">
    defStyle: Int = 0</pre><pre class="source-code">
) : AbstractComposeView(context, attrs, defStyle) {</pre><pre class="source-code">
        @Composable</pre><pre class="source-code">
    override fun Content() {</pre><pre class="source-code">
        GreetingAlertDialog()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, when <a id="_idIndexMarker232"/>you run your application, you <a id="_idIndexMarker233"/>should have a dialog that has a title and text; <em class="italic">Figure 3</em><em class="italic">.6</em> shows a dialog from an already pre-existing project, so this will definitely vary based on what steps you<a id="_idTextAnchor162"/> took:</li>
</ol>
<div><div><img alt="Figure 3.6 – Dialog Compose view in XML" src="img/Figure_3.6_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Dialog Compose view in XML</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor163"/>How it works…</h2>
<p>First, we inflate the XML layout, which we define in our layout <code>resource</code> folder. Then, using binding, we got <code>ComposeView</code> using the created XML ID, set a Compose strategy that works best for our host view, and called <code>setContent</code> to use Compose. In your activity, to be able to create any Compose-based screen, you have to ensure that you call the <code>setContent{}</code> method and pass whatever Composable function you have created.</p>
<p>To further explore the <code>setContent</code> method, it is written as an extension function of <code>ComponentActivity</code>, and it expects a Composable function as the last parameter. There is also <a id="_idIndexMarker234"/>a better way to demonstrate <a id="_idIndexMarker235"/>how <code>setContent{}</code> works to integrate a Composable tree into your Android application.</p>
<div><div><img alt="Figure 3.7 – This happens when you call setContent{}" src="img/Figure_3.7_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – This happens when you call setContent{}</p>
<p><code>ViewCompositionStrategy</code> helps determines when to dispose of the composition; hence, Compose UI views such as <code>ComposeView</code> and the <code>AbstractComposeView</code> use <code>ViewCompositonStrategy</code>, which helps define this behavior.</p>
<p>You can learn <a id="_idIndexMarker236"/>more by following this link to learn more about the interoperability APIs: <a href="https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy">https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy</a>.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor164"/>Understanding and handling recomposition in Jetpack Compose</h1>
<p>Jetpack Compose is still very new, and many companies are starting to use it. Furthermore, Google <a id="_idIndexMarker237"/>has done a great job by giving <a id="_idIndexMarker238"/>developers significant documentation to help them embrace this new UI toolkit. However, despite all the documentation, one concept needs to be clarified. And that is recomposition.</p>
<p>Fair enough, all new software has its ups and downs, and as many people start using it, more people start giving feedback – hence, the need for more improvement. Recomposition, in Compose, involves calling your Composable again when the input changes. Or you can think of it when the composition structure and relation change.</p>
<p>Unless its parameters change, we want to avoid a Composable function being re-invoked in most use cases. So, in this recipe, we look into how recomposition happens and how you can de<a id="_idTextAnchor165"/>bug and solve <a id="_idTextAnchor166"/>any recomposition in your application.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor167"/>How to do it…</h2>
<p>Since our view system is simple, we will be checking whether we have any recomposition in our <code>Login</code> project:</p>
<ol>
<li>We can look at a simple example and how recomposition will occur:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun UserDetails(</pre><pre class="source-code">
    name: String,</pre><pre class="source-code">
    gender: String,</pre><pre class="source-code">
) {</pre><pre class="source-code">
    Box() {</pre><pre class="source-code">
        Text(name)</pre><pre class="source-code">
        Spacer()</pre><pre class="source-code">
        Text(gender)</pre><pre class="source-code">
    }}</pre></li>
</ol>
<p>In our given example, the <code>Text</code> function will recompose when <code>name</code> changes and not when <code>gender</code> changes. In addition, the <code>gender:String</code> input value will recompose only when <code>gender</code> changes.</p>
<ol>
<li value="2">You can also launch and utilize <code>LoginContent</code> and see whether we have any recomposition.</li>
</ol>
<div><div><img alt="Figure 3.8 – Layout Inspector" src="img/Figure_3.8_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Layout Inspector</p>
<ol>
<li value="3">Once you launch <strong class="bold">Layout Inspector</strong>, you need to ensure you have your emulator hooked to it.</li>
</ol>
<div><div><img alt="Figure 3.9 – Linking the inspector" src="img/Figure_3.9_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Linking the inspector</p>
<ol>
<li value="4">Go ahead and expand the <code>SampleLoginTheme</code> entry point, and you will notice our current view system is not complex. As you can see, <strong class="bold">Layout Inspector</strong> does not show any recomposition counts.</li>
</ol>
<p>That is to say, if our application had any recomposition counts, they would show up in <strong class="bold">Layout Inspector</strong>.</p>
<div><div><img alt="Figure 3.10 – The component tree" src="img/Figure_3.10_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The component tree</p>
<ol>
<li value="5">Finally, as <a id="_idIndexMarker241"/>you have seen, our application <a id="_idIndexMarker242"/>does not have any recomposition happening, but it is always beneficial to check your application to know what might be causing the recomposition and fix it.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Using side-effects might lead to users of your application experiencing strange and unpredictable behavior in your app. In addition, a side-effect is any change that is visible to the rest of your application. For instance, writing to a property of a shared object, updating an observable in <code>ViewModel</code>, and updati<a id="_idTextAnchor168"/>ng shared preferences are all dangerous side effects.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor169"/>How it works…</h2>
<p>For adaptability, Compose skips <code>lambda</code> calls or any child function that does not have any changes to its input. This better handling of resources makes sense since, in Compose, animations and other UI elements can trigger recomposition in every frame.</p>
<p>We can go in depth <a id="_idIndexMarker243"/>and use a diagram to <a id="_idIndexMarker244"/>showcase how the Jetpack composition life cycle works. In short, the life cycle of a Composable function is defined by three significant events:</p>
<ul>
<li>Being composed</li>
<li>Getting recomposed or not getting recomposed</li>
<li>No longer being composed</li>
</ul>
<div><div><img alt="Figure 3.11 – The composition life cycle of a Composable" src="img/Figure_3.11_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – The composition life cycle of a Composable</p>
<p>To fathom how Compose works, it’s good to know what constitutes the Compose architectural layer. A high-level overview of the Jetpack Compose architectural layer includes <strong class="bold">Material</strong>, <strong class="bold">Foundation</strong>, <strong class="bold">UI</strong>, and <strong class="bold">Runtime</strong> aspects.</p>
<div><div><img alt="Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers" src="img/Figure_3.12_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers</p>
<p>In <strong class="bold">Material</strong>, this module implements the Material Design system for the Compose UI.</p>
<p>Furthermore, it <a id="_idIndexMarker245"/>provides a theming system, styled <a id="_idIndexMarker246"/>components, and more. <code>Row</code>, <code>Column</code>, and more. The <strong class="bold">UI</strong> layer is made of multiple mod<a id="_idTextAnchor170"/>ules that<a id="_idTextAnchor171"/> implement the fundamentals of the UI toolkit.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor172"/>See also</h2>
<p>The Compose team is launching Jetpack Compose Composition Tracing, the first alpha that will help developers<a id="_idTextAnchor173"/> trace their composition easily; you can read more here:</p>
<ul>
<li><a href="https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535">https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535</a></li>
<li><a href="https://developer.android.com/jetpack/compose/lifecycle">https://developer.android.com/jetpack/compose/lifecycle</a></li>
</ul>
<h1 id="_idParaDest-100"><a id="_idTextAnchor175"/>Writing UI tests for your Compose views</h1>
<p>It is essential to test your code when developing Android applications, especially if your applications <a id="_idIndexMarker247"/>have many users. Furthermore, when you <a id="_idIndexMarker248"/>write tests for your code, you basically verify the functions, behavior, correctness, and versatility of the Android application. The most popular UI testing tools in Android are Espresso, UI Automator, Calabash, and Detox.</p>
<p>In this book, however, we will use Espresso. The most notable advantages of Espresso are as follows:</p>
<ul>
<li>It is easy to set up</li>
<li>It has <a id="_idIndexMarker249"/>highly stable test cycles</li>
<li>It supports JUnit 4</li>
<li>It is made purely for Android UI testing</li>
<li>It is suitable for writing black-box tests</li>
<li>It s<a id="_idTextAnchor176"/>upports testing activities outside the application as well</li>
</ul>
<h2 id="_idParaDest-101"><a id="_idTextAnchor177"/>Getting ready</h2>
<p>You will need to have<a id="_idTextAnchor178"/> completed previous recipes to follow along with this one.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor179"/>How to do it…</h2>
<p>As with the other recipes in this chapter, we will use the new project we created in <a href="B18827_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Modern Android </em><em class="italic">Development Skills</em>:</p>
<ol>
<li>Let’s go ahead and navigate into the <code>androidTest</code> package in our project folder.</li>
<li>Start by creating a new class in the <code>androidTest</code> package and call it <code>LoginContentTest.kt</code>. In Jetpack Compose, testing is made more accessible, and we need to have unique tags for our views.</li>
<li>So, for this step, let’s go back to our main package (<code>com.name.SampleLogin</code>) and create a new package and call it <code>util</code>. Inside <code>util</code>, let’s create a new class and call it <code>TestTags</code>, which will be an object. Here, we will have another object, name it <code>LoginContent</code>, and create constant values that we can call in our view:<pre class="source-code">
object TestTags {</pre><pre class="source-code">
    object LoginContent {</pre><pre class="source-code">
        const val SIGN_IN_BUTTON = "sign_in_button"</pre><pre class="source-code">
        const val LOGO_IMAGE = "logo_image_button"</pre><pre class="source-code">
        const val ANDROID_TEXT = "community_text"</pre><pre class="source-code">
        const val USERNAME_FIELD = "username_fields"</pre><pre class="source-code">
        const val PASSWORD_FIELD = "password_fields"</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Now that we have created the test tags, let’s go back to our <code>LoginContent</code> and <a id="_idIndexMarker250"/>add them to all views in the <code>Modifier()</code> so that <a id="_idIndexMarker251"/>when we test, it is easier to identify the view using the test tag we have added. See the following code snippet:<pre class="source-code">
Image(</pre><pre class="source-code">
    modifier = modifier.testTag(LOGO_IMAGE),</pre><pre class="source-code">
    painter = painterResource(id =</pre><pre class="source-code">
        R.drawable.ic_launcher_foreground),</pre><pre class="source-code">
    contentDescription = "Logo"</pre><pre class="source-code">
)</pre></li>
<li>Inside our <code>LoginCotentTest</code> class, let’s now go ahead and set up our testing environment. We will need to create <code>@get:Rule</code>, which annotates fields that reference rules or methods that return a rule. Under the rule, let’s create <code>ComposeRuleTest</code> and initialize it:<pre class="source-code">
@get:Rule</pre><pre class="source-code">
val ComposeRuleTest = createAndroidComposeRule&lt;MainActivity&gt;()</pre></li>
<li>Add the following function to help us set up the content. We should call this function in our <code>Test</code> annotated function:<pre class="source-code">
private fun initCompose() {</pre><pre class="source-code">
    ComposeRuleTest.activity.setContent {</pre><pre class="source-code">
        SampleLoginTheme {</pre><pre class="source-code">
            LoginContent()</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, let’s <a id="_idIndexMarker252"/>go ahead and add our first test. For <a id="_idIndexMarker253"/>the tests we will write, we will verify that the views are displayed on the screen as we expect them to be:<pre class="source-code">
@Test</pre><pre class="source-code">
fun assertSignInButtonIsDisplayed(){</pre><pre class="source-code">
    initCompose()</pre><pre class="source-code">
    ComposeRuleTest.onNodeWithTag(SIGN_IN_BUTTON,</pre><pre class="source-code">
    true).assertIsDisplayed()</pre><pre class="source-code">
}</pre><pre class="source-code">
@Test</pre><pre class="source-code">
fun assertUserInputFieldIsDisplayed(){</pre><pre class="source-code">
    initCompose()</pre><pre class="source-code">
    ComposeRuleTest.onNodeWithTag(USERNAME_FIELD,</pre><pre class="source-code">
    true).assertIsDisplayed()</pre><pre class="source-code">
}</pre></li>
<li><code>SIGN_IN_BUTTON</code> and <code>USERNAME_FIELD</code> are imported from the test tags that we have created and are already used by only one view, the sign-in button.</li>
<li>Go ahead <a id="_idIndexMarker254"/>and run the tests, and a dialog will pop <a id="_idIndexMarker255"/>up showing the running process; if successful, the tests will pass. In our case, the tests should pass.</li>
</ol>
<div><div><img alt="" src="img/Figure_3.13_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – A screenshot showing passing tests</p>
<p class="callout-heading">Important note</p>
<p class="callout">For these tests, you will not need to add any dep<a id="_idTextAnchor180"/>endencies; everything we need is already available for our use.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor181"/>How it works…</h2>
<p>We use <code>createAndroidComposeRule&lt;&gt;()</code> when accessing an activity. Testing and ensuring your applications display the expected outcome is essential. This is why Android Studio uses the emulator to help developers test their code to ensure their application functions as it would on standard devices.</p>
<p>Furthermore, Android phones come with a developers’ option ready for developers to use, making it even easier for the different number of devices that Android supports and helping reproduce bugs that are hard to find in emulators.</p>
<p>When we test our Compose code, we improve our app’s quality by catching errors early on in the development process. In this chapter, we touched on creating more views to demonstrate how Jetpack Compose works; furthermore, our test cases need to address user action since we did not implement any.</p>
<p>In a different setting, we can write more crucial tests to confirm the intended action, and we will do this in later chapters. Furthermore, Compose provides testing APIs to find elements, verify their attributes, and perform user actions. Moreover, they also include advanced features such as time manipulation, among others.</p>
<p>Explicitly <a id="_idIndexMarker256"/>calling the <code>@Test</code> annotation is very important <a id="_idIndexMarker257"/>when writing tests since this annotation tells JUnit that the function to which it is attached is to run as a <code>Test</code> function. In addition, UI tests in Compose use <code>.onNodeWithTag</code>.</p>
<p>A UI portion or element can mean anything from a single Composable to a full screen. If you try to access the wrong node, the semantics tree, which is generated alongside the UI hierarchy, will complain.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor182"/>There’s more…</h2>
<p>There are other testing tools as follows:</p>
<ul>
<li><strong class="bold">Espresso Test Recorder</strong> provides developers with a faster, interactive way to test <a id="_idIndexMarker258"/>their app’s everyday user input behavior and visual elements.</li>
<li><strong class="bold">App Crawler</strong> undoubtedly uses a more hands-off approach to help you test user actions <a id="_idIndexMarker259"/>without needing to maintain or write any code. With this tool, you can easily configure your inputs, such as entering your username and password credentials.</li>
<li><strong class="bold">Monkey</strong> is a command-line <a id="_idIndexMarker260"/>device that also stress-tests your app by sending a random flow of user validation/input or tap actions into the device or emulator instance.</li>
</ul>
<p>To learn more <a id="_idIndexMarker261"/>about testing and semantics in Compose, read the following: <a href="https://developer.android.com/jetpack/compose/semantics">https://developer.android.com/jetpack/compose/semantics</a>.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor183"/>Writing tests for your ViewModels</h1>
<p>Unlike <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) and <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), MVVM is the favored <a id="_idIndexMarker262"/>design pattern in Modern Android Development <a id="_idIndexMarker263"/>because of its unidirectional data and <a id="_idIndexMarker264"/>dependency flow. Furthermore, <a id="_idTextAnchor184"/>it becomes more accessible <a id="_idIndexMarker265"/>to unit test, as you will see in this recipe.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor185"/>Getting ready</h2>
<p>We will use our previous recipe, <em class="italic">Implementing ViewModel and<a id="_idTextAnchor186"/> understanding the state in Compose</em>, to test our logic and state changes.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor187"/>How to do it…</h2>
<p>In this recipe, we will write unit tests to verify our authentication state changes since that is what we have implemented so far:</p>
<ol>
<li>Start by creating a <code>LoginViewModelTest</code> class in the <code>test</code> package:</li>
</ol>
<div><div><img alt="Figure 3.14 – Created unit test" src="img/Figure_3.14_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Created unit test</p>
<ol>
<li value="2">We will use the <code>cashapp/turbine</code> testing library for coroutine flows to test the flow we <a id="_idIndexMarker266"/>have created. Hence, you will need to <a id="_idIndexMarker267"/>include the processing code snippet in <code>build.gradle</code>:<pre class="source-code">
repositories {</pre><pre class="source-code">
  mavenCentral()</pre><pre class="source-code">
}</pre><pre class="source-code">
dependencies {</pre><pre class="source-code">
  testImplementation 'app.cash.turbine:turbine:0.x.x'</pre><pre class="source-code">
}</pre></li>
<li>Once you have created the class, go ahead and set up <code>@Before</code>, which will run before each test:<pre class="source-code">
class LoginViewModelTest {</pre><pre class="source-code">
   private lateinit var loginViewModel: LoginViewModel</pre><pre class="source-code">
   @Before</pre><pre class="source-code">
   fun setUp(){</pre><pre class="source-code">
      loginViewModel = LoginViewModel(</pre><pre class="source-code">
         dispatchers =</pre><pre class="source-code">
         SampleLoginDispatchers.createTestDispatchers(</pre><pre class="source-code">
         UnconfinedTestDispatcher()),</pre><pre class="source-code">
         stateHandle = SavedStateHandle()</pre><pre class="source-code">
      )</pre><pre class="source-code">
   }</pre><pre class="source-code">
}</pre></li>
<li> As you can see, we utilized <code>SampleLoginDispatchers.createTestDispatchers</code>. For <code>UnconfinedTestDispatcher</code>, you must include the testing dependencies and import, <code>import kotlinx.coroutines.test.UnconfinedTestDispatcher</code>.</li>
<li>Now that <a id="_idIndexMarker268"/>we have our setup ready let us go ahead <a id="_idIndexMarker269"/>and create our test, verifying the authentication state changes:<pre class="source-code">
@Test</pre><pre class="source-code">
fun `test authentication state changes`() = runTest {...}</pre></li>
<li>Inside our <code>Test</code> function, we will now need to access the <code>loginViewModel</code> functions and pass fake values to the parameters:<pre class="source-code">
@Test</pre><pre class="source-code">
fun `test authentication state changes`() = runTest {</pre><pre class="source-code">
    loginViewModel.userNameChanged("Madona")</pre><pre class="source-code">
    loginViewModel.passwordChanged("home")</pre><pre class="source-code">
    loginViewModel.passwordVisibility(true)</pre><pre class="source-code">
    loginViewModel.state.test {</pre><pre class="source-code">
        val stateChange = awaitItem()</pre><pre class="source-code">
        Truth.assertThat(stateChange).isEqualTo(</pre><pre class="source-code">
            AuthenticationState(</pre><pre class="source-code">
                userName = "Madona",</pre><pre class="source-code">
                password = "home",</pre><pre class="source-code">
                togglePasswordVisibility = true</pre><pre class="source-code">
            )</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, go ah<a id="_idTextAnchor188"/>ead and run the test, and it should pass.</li>
</ol>
<div><div><img alt="Figure 3.15 – Unit test passing" src="img/Figure_3.15_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Unit test passing</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor189"/>How it works…</h2>
<p>As mentioned before, the most notable advantage of MVVM is being able to write code you can quickly <a id="_idIndexMarker270"/>test. In addition, architecture in Android is all about <a id="_idIndexMarker271"/>selecting the trade-offs. Each architecture has its pros and cons; based on your company’s needs, you might work with a different one.</p>
<p>We create <code>lateint var loginViewModel</code> to set up a class for testing, and this is because the logic to be tested is in <code>ViewModel</code>.</p>
<p>We use <code>UnconfinedDispatcher</code>, which creates an instance of an <code>Unconfined</code> dispatcher. That means the tasks it executes are not confined to any particular thread and form an event loop. It is different in that it skips delays, as all <code>TestDispatcher</code> instances do. And by default, <code>runTest()</code> provides <code>StandardTestDispatcher</code>, which does not execute child coroutines immediately.</p>
<p>We use <code>Truth</code> for our assertation to help us make more readable code, and the significant advantages of <code>Truth</code> are as follows:</p>
<ul>
<li>It aligns the actual values to the left</li>
<li>It gives us more detailed failure messages</li>
<li>It offers richer operations to help with testing</li>
</ul>
<p>There are <a id="_idIndexMarker272"/>also other alternatives, such as Mockito, Mockk, and <a id="_idIndexMarker273"/>more, but in this section, we have used <code>Truth</code>. We have also used a library by Cashapp that helps us test coroutine flows. You can learn more <a id="_idIndexMarker274"/>about the <code>turbine</code> library here: <a href="https://github.com/cashapp/turbine">https://github.com/cashapp/turbine</a>.</p>
</div>
</body></html>