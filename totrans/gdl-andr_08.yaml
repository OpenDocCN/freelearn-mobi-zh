- en: Chapter 8. Setting Up Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is a development practice that requires
    the developers in a team to integrate their work regularly, often multiple times
    per day. Every push to the main repository is verified by an automated build.
    This practice helps with detecting problems as soon as possible, thereby speeding
    up development, and increasing the quality of the code. The great Martin Fowler
    wrote an article about the subject that explains the concepts and describes the
    best practices ([http://martinfowler.com/articles/continuousIntegration.html](http://martinfowler.com/articles/continuousIntegration.html))'
  prefs: []
  type: TYPE_NORMAL
- en: There are several options to set up CI for Android. The most widely used are
    **Jenkins**, **TeamCity**, and **Travis CI**. Jenkins has the biggest ecosystem,
    with around a thousand available plugins. It is also an open source effort with
    a lot of contributors. TeamCity is a product from JetBrains, the company that
    also created IntelliJ IDEA. Travis CI is a relatively new player, and is mostly
    focused on open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at these CI systems and how to make Gradle work on them. At the
    end of the chapter, we will mention some Gradle tricks to make CI easier, regardless
    of the chosen CI system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TeamCity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Travis CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins was originally released as Hudson in 2005 by Sun Microsystems. Over
    the years, it grew to become the most popular CI system in the Java community.
    Shortly after Sun Microsystems was acquired by Oracle, there was a conflict between
    Oracle and the Java community regarding Hudson. When that could not be resolved,
    the community continued to work on the project under the name Jenkins because
    the name Hudson is owned by Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: The power of Jenkins lies in its plugin system. Everyone who has a need for
    new functionality in the build system can create a new plugin that extends the
    capabilities of Jenkins. This is also why setting up an automated build for Android
    apps or libraries is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not already have Jenkins installed and running on your build machine,
    download it from the website ([https://jenkins-ci.org](https://jenkins-ci.org))
    and follow the steps.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can get started with the actual Jenkins setup, you need to make sure
    you have all the required libraries for building Android apps and libraries. To
    build anything in Java, you need to download and install the JDK first, which
    can be downloaded from the Java website ([http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: You also need to make sure you have the Android SDK and build tools installed.
    It is not necessary to install an IDE on your build server, unless you plan on
    opening the project on the build machine. If you just want to install the SDK
    tools, you can download those from the Android developer website ([https://developer.android.com/sdk/index.html#Other](https://developer.android.com/sdk/index.html#Other)).
    Once you have downloaded and installed the package, you need to run the `android`
    executable in the SDK directory, so you can install the APIs and build tools you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Java and the Android SDK are installed, you need to configure these in
    Jenkins. Start by opening your web browser and navigating to Jenkins'' home page
    on your build server. Go to **Manage Jenkins** | **Configure System** and scroll
    to **Global properties**. Add two environment variables, `ANDROID_HOME` and `JAVA_HOME`,
    and set their values to the correct directories, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Jenkins](img/B01061_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You also need to install the Gradle plugin. Go to **Manage Jenkins** | **Manage
    Plugins**, navigate to the **Available** tab, and search for `Gradle`. When you
    locate the Gradle plugin, simply check the box and click on **Download now and
    install after restart**. This plugin makes it possible to create build steps that
    involve Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have installed everything you need, you can create a CI project in
    Jenkins. The first thing you should do is to set up the VCS repository, so that
    Jenkins knows where to get the source code for your project. You can set up Jenkins
    to build your app or library automatically based on repository activity, using
    build triggers, or you can choose to only do manual builds. To perform the actual
    build, you need to add a new build step that invokes a Gradle script. You can
    configure Jenkins to use the Gradle Wrapper, which is present by default in Android
    projects. Using the Gradle Wrapper not only eliminates the need for manually installing
    Gradle on your build server, it also makes sure that any updates of Gradle are
    handled automatically. It is a good idea to also check the **Make gradlew executable**
    box. This solves an issue with permission for executing the Gradle Wrapper, when
    the project is created on a Microsoft Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can enter a nice description for the build step, and optionally add two
    switches `info` and `stacktrace`. The `info` switch is used to print out more
    information of the build process, which can be useful in case something goes wrong.
    If the build causes an exception, the `stacktrace` switch prints out the stack
    trace of this exception. Sometimes you might need more detailed information, in
    which case you can use the `full-stacktrace` switch instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize the configuration, specify the Gradle tasks you want to execute.
    First, execute the `clean` task, to make sure there is no output left from any
    previous builds. Second, execute the `build` task, which triggers a build of all
    variants. The Jenkins configuration should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the build](img/B01061_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have saved the project configuration, you can run the build.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your build server is installed on a 64-bit Linux machine, you might run
    into this exception `java.io.IOException: Cannot run program "aapt": error=2,
    No such file or directory`. This is because AAPT is a 32 bit application and needs
    some extra libraries in order to run on a 64 bit machine. To install the necessary
    libraries, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the build finishes without any issues, it creates APKs for all your build
    variants. You can use specific Gradle tasks to distribute these APKs. We will
    mention automatic distribution at the end of the chapter, as it is not specific
    to any build system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the build](img/B01061_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TeamCity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike Jenkins, TeamCity is a proprietary product that is free to use only for
    open source projects. It is created and managed by JetBrains. This is the same
    company that also created IntelliJ IDEA, which is the IDE that Android Studio
    is based on. TeamCity supports Android builds with Gradle out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up TeamCity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not have a running TeamCity installation yet, download it from the
    JetBrains website ([https://www.jetbrains.com/teamcity](https://www.jetbrains.com/teamcity))
    and follow the steps.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with building Android apps and libraries with TeamCity, you need
    to make sure the JDK, the Android SDK, and the Android build tools are installed
    on your build server. You can find the instructions for this in the *Jenkins*
    section. You also need to add `ANDROID_HOME` to the environment variables of the
    machine, and point it to the Android SDK directory.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Jenkins, TeamCity does not require any plugins to trigger Gradle builds,
    as TeamCity has built-in support for running Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up an Android build, you start by creating a new project. All you need
    to provide is a name. Once the project is created, you can start configuring it.
    First, you need to add a VCS root so that TeamCity can find the source code for
    your project. Then you need to create a new build configuration. You also need
    to attach the VCS root to the build configuration. When that is set up, you can
    add a new build step. If you press the **Auto-detect build steps** button, TeamCity
    will try to determine the necessary build steps, based on the content of the project.
    In case of a Gradle-based Android project, the result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the build](img/B01061_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TeamCity detects that the project uses Gradle, and even that the Gradle wrapper
    is present. You can just select the Gradle build step, and add it to the build
    configuration. If you do not need to do anything advanced, this is enough to make
    sure your Android app gets built. You can test the configuration by opening the
    project overview and clicking on the **Run…** button for the Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your project's repository is hosted on GitHub, you can use Travis CI for
    your automated builds. Travis CI ([https://travis-ci.org](https://travis-ci.org))
    is an open source hosted continuous integration system, and is free to use for
    public repositories. There is a paid plan for private repositories, but in this
    book we will only look at the free option.
  prefs: []
  type: TYPE_NORMAL
- en: Travis detects when a new commit is pushed to the repository and starts a new
    build automatically. By default, Travis builds all branches, not just the master
    branch. It also builds pull requests automatically; a useful feature for open
    source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Because of how Travis works internally, you cannot configure the build server
    itself. Instead, you need to create a configuration file that contains all the
    information that Travis needs to build your app or library.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to enable Travis builds for your project, you first need to log
    in to Travis CI and connect your account to GitHub. Once that is done, you need
    to enable the project you want to build in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure the build process, Travis requires you to create a file
    called `.travis.yml` that contains the entire setup. To configure an Android project,
    you need to define the language and add a few Android-specific properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The language setting specifies which kind of build process you want to run.
    In this case, you are building an Android app. The Android-specific properties
    include the version of the build tools and the Android SDK version that need to
    be used. Travis will download those prior to running the `build` tasks. If you
    make use of the support library or Google Play Services, you need to specify that
    explicitly because Travis needs to download the repositories for those dependencies
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not mandatory to configure the build tools and SDK version, but you will
    encounter fewer issues if you make sure the version aligns with what you have
    specified in the `build.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create an Android project on Microsoft Windows, the Gradle Wrapper file
    is known to have issues with permissions. Therefore, it is a good idea to fix
    the permission before running the actual build script. You can add a prebuild
    step like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the build itself, add this line to the Travis configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will run the Gradle Wrapper, just like you would on a developer
    machine, and execute the `clean` and `build` tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done configuring the Travis build, you can commit and push the
    file to the project''s GitHub repository. If everything is set up correctly, Travis
    will start the build process, which you can follow on the Travis website. This
    is what it looks like when a project is successfully built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the build](img/B01061_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Travis also sends an e-mail report after every build. This can be especially
    useful if you are the maintainer of an open source library that regularly gets
    pull requests. The report e-mail from Travis looks like this when a build is successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the build](img/B01061_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will quickly notice that Travis has a big downside, and that is speed. Travis
    does not give you one specific machine, but boots up a vanilla virtual machine
    for every build you trigger. This means for every new build, Travis has to download
    and install the Android SDK and build tools, before it can start building your
    app or library.
  prefs: []
  type: TYPE_NORMAL
- en: On the upside, Travis is free and public, which makes it perfect for open source
    projects. Travis also builds pull requests automatically, which can give you peace
    of mind when someone submits a patch to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Further automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern continuous integration systems support Gradle, either by default
    or through a plugin. This means that instead of just building your app or library,
    you can create all kinds of Gradle tasks to further automate the build. The advantage
    of defining extra build steps with Gradle tasks, instead of in the CI system itself
    is that the extra build steps become much more portable. It is easy to run a custom
    Gradle task on your development machine. A custom Jenkins build step, on the other
    hand, is impossible to run without having Jenkins installed. Having extra build
    steps in a certain CI system also makes it harder to switch to a different CI
    system. Gradle tasks can also easily be ported to different projects. In this
    section, we will look at a few ways to further automate building and deploying
    apps and libraries, using Gradle tasks and plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK manager plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An issue you might run into at some point is that the Android SDK on the build
    server is not up to date. When you update the SDK version for your app or library,
    you also need to install the new SDK on the build server. If you have multiple
    build agents, this becomes a real hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to community efforts, there is a Gradle plugin that takes care of checking
    whether the build depends on an Android SDK version that is not present. If the
    SDK is not present, the plugin will download it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK manager plugin will download not only the compilation SDK specified
    in the build configuration file, but also the correct version of the build tools
    and platform tools. If your project has a dependency on the support library or
    Google Play Services, the plugin will download the specified version of those
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The SDK manager plugin is an open source plugin, you can find the source code
    for it on GitHub ([https://github.com/JakeWharton/sdk-manager-plugin](https://github.com/JakeWharton/sdk-manager-plugin)).
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to run unit tests (JUnit or Robolectric) during the build process
    on the build server, you simply need to add the corresponding tasks to the Gradle
    execution. If you want to run any functional tests, you will need an emulator
    to install your app on, so you can run the tests with `gradlew connectedAndroidTest`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest option for running an emulator is to just launch an emulator on
    the build server, and keep it open all the time. Unfortunately, this is not an
    optimal solution, because the Android emulators are quite prone to random crashes,
    especially when you keep them open for multiple days.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Jenkins, there is a plugin called **Android Emulator Plugin**
    ([https://wiki.jenkins-ci.org/display/JENKINS/Android+Emulator+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Android+Emulator+Plugin))
    that can be configured to launch an emulator for every build of your app or library.
    TeamCity also has a lively plugin ecosystem, and there is a plugin called **Android
    Emulator** that helps setting up an emulator in the same way as the Jenkins plugin.
    You can find it, along with other TeamCity plugins, on the official TeamCity plugins
    page ([https://confluence.jetbrains.com/display/TW/TeamCity+Plugins](https://confluence.jetbrains.com/display/TW/TeamCity+Plugins)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Travis CI has the ability to start an emulator, but this is an experimental
    functionality. If you want to try it anyway, add this snippet to your `.travis.yml`
    configuration file to launch an Android emulator during your Travis builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `android-wait-for-emulator` instruction tells Travis to wait for the emulator
    to start. When the emulator is booted, `adb shell input keyevent 82 &` is executed
    to unlock the screen. After that, you can just tell Gradle to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help developers with automatic deployment of Android apps, Google released
    the Google Play Developer API, an API for pushing APKs to Google Play programmatically
    ([https://developers.google.com/android-publisher](https://developers.google.com/android-publisher)).
    This API removes the need for you to open a browser, log in to Google Play, and
    upload APKs using the web interface. Instead of creating your own publishing script
    based on the Google Play Developer API, you can use one of the many plugins to
    push APKs to Google Play directly after a successful build, straight from the
    build system.
  prefs: []
  type: TYPE_NORMAL
- en: There is a Jenkins plugin called **Google Play Android Publisher** ([https://wiki.jenkins-ci.org/display/JENKINS/Google+Play+Android+Publisher+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Google+Play+Android+Publisher+Plugin))
    that can handle this for you. A better option, though, is to use a Gradle plugin,
    so that you can execute the publishing task from any device and any kind of continuous
    integration system. Some people in the Android community created a Gradle plugin
    built around the Google Play Developer API that enables you to configure the entire
    publishing process. You can find the Gradle Play Publisher Gradle plugin source
    code on GitHub ([https://github.com/Triple-T/gradle-play-publisher](https://github.com/Triple-T/gradle-play-publisher)).
    It is also available through Maven Central or JCenter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using this plugin, add this to your main `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then apply the plugin in your Android module''s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you apply the Gradle Play Publisher plugin to your build, you will have
    a few new tasks to your availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '`publishApkRelease` uploads the APK and the recent changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publishListingRelease` uploads the descriptions and images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publishRelease` uploads everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have different build variants, you can also execute a variant-specific
    version of these tasks, for example, `publishApkFreeRelease` and `publishApkPaidRelease`.
  prefs: []
  type: TYPE_NORMAL
- en: To get access to the Google Play Developer API, you need to set up a service
    account. This setup is out of the scope of this book, but it is required if you
    want to use the Gradle Play Publisher plugin. To get started, follow the steps
    in the documentation for the Google Play Developer API at [https://developers.google.com/android-publisher/getting_started](https://developers.google.com/android-publisher/getting_started).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created a service account, you can enter the credentials in your
    build configuration file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `play` block is for properties that are specific for the Gradle Play Publisher
    plugin. In addition to the service account credentials, you can also specify the
    track the APK should push to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The default track is `alpha`, but you can change it to `beta` or `production`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Beta distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of options for beta testing of Android apps, such as the beta
    track on the Google Play store itself. Another option is **Crashlytics** ([https://crashlytics.com](https://crashlytics.com)),
    which has a very nice integration with Gradle. The team at Crashlytics created
    a custom plugin that not only creates new Gradle tasks to publish builds to their
    platform, but also hooks into the Android plugin's tasks to handle ProGuard mapping.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Crashlytics, follow the steps on their website. Once you
    have set it up, it will start hooking into your builds. The Crashlytics plugin
    exposes a new task called `crashlyticsUploadDistributionInternal` that can be
    used to upload APKs to Crashlytics. To push a new version of your app, you first
    need to build it using the `build` or `assemble` tasks. Once the APK is ready,
    you can upload it to Crashlytics using the `crashlyticsUploadDistributionInternal`
    task. The Crashlytics plugin creates an upload task for every build variant in
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the custom Gradle plugin, it is very easy for developers to get started
    with Crashlytics. It also makes it a breeze to upload your test builds to Crashlytics,
    because you just need to execute one extra task during the build process. This
    is a great example of how powerful the proper use of Gradle can be, and how a
    good Gradle plugin can make developers' lives a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a few popular continuous integration systems,
    and explained how we can use them to automate building Android apps and libraries.
    You learned how to configure the CI systems to build Android projects using Gradle.
    Then we looked at several Gradle plugins to help us further automate the build
    and deployment processes, and we explained how to run tests automatically on the
    build server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some more advanced features of Gradle and
    optimizations for Gradle-based builds. We will also see how we can migrate a big
    Ant build configuration by using Ant tasks directly from Gradle, and porting them
    to Gradle in small steps.
  prefs: []
  type: TYPE_NORMAL
