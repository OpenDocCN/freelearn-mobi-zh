<html><head></head><body>
<div class="book" title="Arrays, matrices, sets, and dictionaries" id="G6PI1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="2D arrays / matrices"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec12" class="calibre1"/>2D arrays / matrices</h2></div></div></div><p class="calibre8">A common <a id="id13" class="calibre1"/>collection type used in physics calculations, graphics, and game <a id="id14" class="calibre1"/>design, particularly grid-based puzzle games, is two-dimensional arrays / matrices. 2D arrays are simply arrays that have arrays as their members. These arrays can be expressed in a rectangular fashion in rows and columns.</p><p class="calibre8">For example, the 4x4 (4 rows, 4 columns) tile board in the 15-puzzle game can be represented as follows:</p><div class="informalexample"><pre class="programlisting">var tileBoard = [[1,2,3,4],
                 [5,6,7,8],
                 [9,10,11,12],
                 [13,14,15,""]]</pre></div><p class="calibre8">In the 15 puzzle game, your goal is to shift the tiles using the one empty spot (represented with the blank string <code class="email">""</code>), to all end up in the 1-15 order as we saw. The game would start with the numbers arranged in a random and solvable order, and the player would then have to swap the numbers and the blank space.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">To better perform various actions on and/or store information about each tile in the 15 game (and other games), it'd be better to create a tile object as opposed to using raw values seen here. For the sake of understanding what a matrix or 2D array is, simply make a note of how the array is surrounded by doubly encapsulated brackets <code class="email">[[]]</code>. We will later use one of our example games, <code class="email">SwiftSweeper</code>, to better understand how puzzle games use 2D arrays of objects to create a full game.</p></div><p class="calibre8">Here are <a id="id15" class="calibre1"/>ways to <a id="id16" class="calibre1"/>declare blank 2D arrays with strict types:</p><div class="informalexample"><pre class="programlisting">var twoDTileArray : [[Tiles]] = []     //blank 2D array of type,Tiles
var anotherArray = Array&lt;Array&lt;Tile&gt;&gt;()  //same array, using Generics</pre></div><p class="calibre8">The variable <code class="email">twoDTileArray</code> uses the double brackets <code class="email">[[Tiles]]</code> to declare it as a blank 2D array/matrix for the made-up type, tiles. The variable <code class="email">anotherArray</code> is a rather oddly declared array that uses angle bracket characters <code class="email">&lt;&gt;</code> for enclosures. It utilizes what's known as <a id="id17" class="calibre1"/><span class="strong"><strong class="calibre9">Generics</strong></span>. Generics is a rather advanced topic that we will touch more on later. They allow very flexible functionality among a wide array of data types and classes. For the moment, we can think of them as a catch-all way of working with objects.</p><p class="calibre8">To fill in the data for either version of this array, we would then use for-loops. More on loops and iterations will be explained later in the chapter.</p></div></div>

<div class="book" title="Arrays, matrices, sets, and dictionaries" id="G6PI1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Sets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec13" class="calibre1"/>Sets</h2></div></div></div><p class="calibre8">This is <a id="id18" class="calibre1"/>how we would make a set of various game items in Swift:</p><div class="informalexample"><pre class="programlisting">var keyItems = Set([Dungeon_Prize, Holy_Armor, Boss_Key,"A"])</pre></div><p class="calibre8">This set <code class="email">keyItems</code> has various objects and a character <code class="email">A</code>. Unlike an array, a set is not ordered and contains unique items. So, unlike <code class="email">stageNames</code>, attempting to get <code class="email">keyItems[1]</code> would return an error and <code class="email">items[1]</code> might not necessarily be the <code class="email">Holy_Armor</code> object, as the placement of objects is internally random in a set. The advantage sets have over arrays is that sets are great at checking for duplicated objects and specific content searching in the collection overall. Sets make use of hashing to pinpoint the item in the collections, so checking for items in a set's content can be much faster than in an array. In game development, a game's key items, which the player may only get once and should never have duplicates of, could work great as a set. Using the function <code class="email">keyItems.contains(Boss_Key)</code> returns the Boolean value of <code class="email">true</code> in this case.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">Sets were added in Swift 1.2 and Xcode 6.3. Their class is represented by the generic type <code class="email">Set&lt;T&gt;</code>, where <code class="email">T</code> is the class type of the collection. In other words, the set, <code class="email">Set([45, 66, 1233, 234])</code>. would be of the type <code class="email">Set&lt;Int&gt;</code>, and our example here would be a <code class="email">Set&lt;NSObject&gt;</code> instance due to it having a collection of various data types.</p><p class="calibre8">We will <a id="id19" class="calibre1"/>discuss more on Generics and class hierarchy later in this chapter.</p></div></div></div>

<div class="book" title="Arrays, matrices, sets, and dictionaries" id="G6PI1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Dictionaries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec14" class="calibre1"/>Dictionaries</h2></div></div></div><p class="calibre8">A <a id="id20" class="calibre1"/>dictionary can be represented this way in Swift:</p><div class="informalexample"><pre class="programlisting">var playerInventory: [Int : String]  =  [1 : "Buster Sword",  43 : "Potion", 22: "StrengthBooster"]</pre></div><p class="calibre8">Dictionaries use a <code class="email">key : value</code> association, so <code class="email">playerInventory[22]</code> returns the value <code class="email">StrengthBooster</code> based on the key <code class="email">22</code>. Both the key and value could be initialized to almost any class type<span class="strong"><em class="calibre10">*</em></span>. In addition to the inventory example given, we can have the following code:</p><div class="informalexample"><pre class="programlisting">var stageReward: [Int : GameItem] = [:] //blank initialization
//use of the Dictionary at the end of a current stage
stageReward = [currentStage.score : currentStage.rewardItem]
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8"><span class="strong"><em class="calibre10">*</em></span>The values of a dictionary, though rather flexible in Swift, do have limitations. The key must conform to what's known as the hashable protocol. Basic data types, such as <code class="email">Int</code> and <code class="email">String</code>, already have this functionality. So, if you are to make your own classes / data structures that are to be used in dictionaries, say mapping a player actions with player input, this protocol must be utilized first. We will discuss more about protocols later in this chapter.</p></div><p class="calibre8">Dictionaries are like sets in that they are unordered but with the additional layer of having a key and a value associated with their content instead of just the hash key. Like sets, dictionaries are great for quick insertion and retrieval of specific data. In iOS apps and in web applications, dictionaries are used to parse and select items from JavaScript Object Notation (JSON) data.</p><p class="calibre8">In the realm of game development, dictionaries using JSON or via Apple's internal data class, <code class="email">NSUserDefaults</code>, can be used to save and load game data, set up game configurations, or access specific members of a game's API.</p><p class="calibre8">For example, here's one way to save a player's high score in an iOS game using Swift:</p><div class="informalexample"><pre class="programlisting">let newBestScore : Void = NSUserDefaults.standardUserDefaults().setInteger(bestScore, forKey: "bestScore")</pre></div><p class="calibre8">This code comes directly from a published Swift-developed game named PikiPop, which we will use from time to time to show code used in actual game applications.</p><p class="calibre8">Again, note that dictionaries are unordered, but Swift has ways to iterate or search through an entire dictionary. We <a id="id21" class="calibre1"/>will go more in depth in the next section and later on when we move on to loops and control flow.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Mutable/immutable collections" id="H5A41-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Mutable/immutable collections</h1></div></div></div><p class="calibre8">One rather important discussion that we've left out is how to subtract, edit, or add to arrays, sets, and dictionaries. However, before we do this, you should understand the concept of mutable and immutable data/collections.</p><p class="calibre8">A <a id="id22" class="calibre1"/>mutable collection is simple data that can be changed, added to, or subtracted from, whereas an immutable collection cannot be changed, added to, or subtracted from.</p><p class="calibre8">To work with mutable and immutable collections<a id="id23" class="calibre1"/> efficiently in Objective-C, we had to explicitly state the mutability of the collection beforehand. For example, an array of the type <code class="email">NSArray</code> in Objective-C is always immutable. There are methods we can call on <code class="email">NSArray</code> that would edit the collection, but behind the scenes, this would be creating brand new <code class="email">NSArray</code> objects, thus would be rather inefficient to do this often in the life of our game. Objective-C has solved this issue with the class type, <code class="email">NSMutableArray</code>.</p><p class="calibre8">Thanks to the flexibility of Swift's type inference, we already know how to make a collection mutable or immutable! The concept of constants and variables has us covered when it comes to data mutability in Swift. Using the keyword <code class="email">let</code> when creating a collection will make that collection immutable, while using <code class="email">var</code> will initialize it as a mutable collection.</p><div class="informalexample"><pre class="programlisting">//mutable Array
var unlockedLevels : [Int] =  [1, 2, 5, 8]

//immutable Dictionary
let playersForThisRound : [PlayerNumber:PlayerUserName] = [453:"userName3344xx5", 233:"princeTrunks", 6567: "noScopeMan98", 211: "egoDino"]</pre></div><p class="calibre8">The array of integers, <code class="email">unlockedLevels</code>, can be edited simply because it's a variable. The immutable dictionary <code class="email">playersForThisRound</code> can't be changed since it's already been declared as a constant. There is no additional layer of ambiguity concerning additional class types.</p></div>

<div class="book" title="Mutable/immutable collections" id="H5A41-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Editing/accessing collection data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec15" class="calibre1"/>Editing/accessing collection data</h2></div></div></div><p class="calibre8">As long as a <a id="id24" class="calibre1"/>collection type is a variable, using the <code class="email">var</code> keyword, we can<a id="id25" class="calibre1"/> do various edits to the data. Let's go back to our <code class="email">unlockedLevels</code> array. Many games have the functionality of unlocking levels as the player progresses. Let's say that the player has reached the high score needed to unlock the previously <a id="id26" class="calibre1"/>locked level 3 (as <code class="email">3</code> isn't a member of the array). We can add <code class="email">3</code> to the array using the <code class="email">append</code> function:</p><div class="informalexample"><pre class="programlisting">unlockedLevels.append(3)</pre></div><p class="calibre8">Another neat <a id="id27" class="calibre1"/>attribute of Swift is that we can add data to an array using the <code class="email">+=</code> assignment operator:</p><div class="informalexample"><pre class="programlisting">unlockedLevels += [3]</pre></div><p class="calibre8">Doing it this way however will simply add <code class="email">3</code> to the end of the array. So, our previous array <code class="email">[1, 2, 5, 8]</code> is now <code class="email">[1, 2, 5, 8, 3]</code>. This probably isn't a desirable order, so to insert the number <code class="email">3</code> in the third spot, <code class="email">unlockedLevels[2]</code>, we can use the following method:</p><div class="informalexample"><pre class="programlisting">unlockedLevels.insert(3, atIndex: 2)</pre></div><p class="calibre8">Now, our array of unlocked levels is ordered to <code class="email">[1, 2, 3, 5, 8]</code>.</p><p class="calibre8">This is assuming though that we know a member of the array prior to <code class="email">3</code> is sorted already. There are various sorting functionalities provided by Swift that could help keeping an array sorted. We will leave the details of sorting to our discussions of loops and control flow later in this chapter.</p><p class="calibre8">Removing items from an array is just simple. Let's again use our <code class="email">unlockedLevels</code> array. Imagine that our game has an overworld for the player to travel to and from and the player has just unlocked a secret that triggered an event that blocked off access to level 1. Level 1 would now have to be removed from the unlocked levels. We can do it like this:</p><div class="informalexample"><pre class="programlisting">unlockedLevels.removeAtIndex(0) // array is now  [2, 3, 5, 8]</pre></div><p class="calibre8">Alternately, imagine that the player has lost all of their lives and got a <span class="strong"><strong class="calibre9">Game Over</strong></span> message. A penalty for this could be to lock the furthest level. Though probably a rather infuriating method and us knowing that level 8 is the furthest level in our array, we can remove it using the <code class="email">.removeLast()</code> function of array types.</p><div class="informalexample"><pre class="programlisting">unlockedLevels.removeLast() // array is now [2,3,5]</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">This is assuming that we know the exact order of the collection. Sets or dictionaries might be better at controlling certain aspects of your game.</p></div><p class="calibre8">Here are some ways to edit a set or a dictionary as a quick guide.</p><p class="calibre8">
<span class="strong"><strong class="calibre9">Set</strong></span>
</p><div class="informalexample"><pre class="programlisting">inventory.insert("Power Ring")    //.insert() adds items to a set
inventory.remove("Magic Potion")  //.remove() removes a specific item
inventory.count                   //counts # of items in the Set
inventory.union(EnemyLoot)        //combines two Sets
inventory.removeAll()             //removes everything from the Set
inventory.isEmpty                 //returns true</pre></div><p class="calibre8">
<span class="strong"><strong class="calibre9">Dictionary</strong></span>
</p><div class="informalexample"><pre class="programlisting">var inventory = [Float : String]() //creates a mutable dictionary

/*
one way to set an equipped weapon in a game; where 1.0 could represent the first "item slot" that would be placeholder for the player's "current weapon"  
*/
inventory.updateValue("Broadsword", forKey: 1.0)


//removes an item from a Dictionary based on the key value
inventory.removeValueForKey("StatusBooster")

inventory.count                   //counts items in the Dictionary
inventory.removeAll(keepCapacity: false) //deletes the Dictionary
inventory.isEmpty                 //returns false

//creates an array of the Dictionary's values
let inventoryNames = [String](inventory.values)

//creates an array of the Dictionary's keys
let inventoryKeys = [String](inventory.keys)</pre></div><div class="book" title="Iterating through collection types"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Iterating through collection types</h3></div></div></div><p class="calibre8">We can't <a id="id28" class="calibre1"/>discuss collection types without mentioning how to iterate through them en masse.</p><p class="calibre8">Here's some way we'd iterate though an array, a set, or a dictionary in Swift:</p><div class="informalexample"><pre class="programlisting">//(a) outputs every item through the entire collection
  //works for Arrays, Sets and Dictionaries but output will vary
for item in inventory {
    print(item)
}

//(b) outputs sorted item list using Swift's sorted() function
  //works for Sets
for item in sorted(inventory) {
    print("\(item)")
}

//(c) outputs every item as well as its current index
  //works for Arrays, Sets and Dictionaries
for (index, value) in enumerate(inventory) {
    print("Item \(index + 1): \(value)")
}

//(d)
//Iterate through and through the keys of a Dictionary
for itemCode in inventory.keys {
    print("Item code: \(itemCode)")
}

//(e)
//Iterate through and through the values of a Dictionary
for itemName in inventory.values {
    print("Item name: \(itemName)")
}</pre></div><p class="calibre8">As stated previously, this<a id="id29" class="calibre1"/> is done with what's known as a for-loop; with these examples, we show how Swift utilizes the for-in variation using the <code class="email">in</code> keyword. The code will repeat until it reaches the end of the collection in all of these examples. In example <code class="email">(c)</code>, we also see the use of the Swift function, <code class="email">enumerate()</code>. This function returns a compound value, <code class="email">(index,value)</code>, for each item. This compound value is known as a tuple, and Swift's use of tuples makes for a wide variety of functionalities for functions, loops, as well as code blocks.</p><p class="calibre8">We will delve more into tuples, loops, and blocks later on.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Objective-C and Swift comparison" id="I3QM1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Objective-C and Swift comparison</h1></div></div></div><p class="calibre8">Here's a quick review <a id="id30" class="calibre1"/>of our Swift code with a comparison to the Objective-C equivalent.</p></div>

<div class="book" title="Objective-C and Swift comparison" id="I3QM1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Objective-C"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec16" class="calibre1"/>Objective-C</h2></div></div></div><p class="calibre8">Here's a<a id="id31" class="calibre1"/> sample code in Objective-C:</p><div class="informalexample"><pre class="programlisting">const int MAX_ENEMIES = 10;  //constant
float playerPower = 1.3;     //variable

//Array of NSStrings
NSArray * stageNames = @[@"Downtown Tokyo", @"Heaven Valley", @" Nether"];

//Set of various NSObjects
NSSet *items = [NSSet setWithObjects: Weapons, Armor,
 HealingItems,"A", nil];

//Dictionary with an Int:String key:value
NSDictionary *inventory = [NSDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithInt:1], @"Buster Sword",
             [NSNumber numberWithInt:43], @"Potion",
             [NSNumber numberWithInt:22], @"Strength",
nil];</pre></div></div></div>

<div class="book" title="Objective-C and Swift comparison" id="I3QM1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Swift"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec17" class="calibre1"/>Swift</h2></div></div></div><p class="calibre8">Here's the <a id="id32" class="calibre1"/>equivalent code in Swift:</p><div class="informalexample"><pre class="programlisting">let MAX_ENEMIES = 10          //constant
var playerPower = 1.3         //variable

//Array of Strings
let stageNames : [String] = ["Downtown Tokyo","Heaven Valley","Nether"]    

//Set of various NSObjects
var items = Set([Weapons, Armor, HealingItems,"A"])
          
//Dictionary with an Int:String key:value
var playerInventory: [Int : String]  =  [1 : "Buster Sword",  43 : "Potion", 22: "StrengthBooster"]</pre></div><p class="calibre8">In the preceding code, we used some examples of variables, constants, arrays, sets, and dictionaries. First, we see their Objective-C syntax and then the equivalent declarations using Swift's syntax. From this example, we can see how compact Swift is compared with Objective-C.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Characters and strings" id="J2B81-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Characters and strings</h1></div></div></div><p class="calibre8">For some<a id="id33" class="calibre1"/> time in this chapter, we've been mentioning strings. Strings are also a collection of data types, but a specially dealt collection of characters, of the class type, string. Swift <a id="id34" class="calibre1"/>is Unicode-compliant, so we can have strings like the following:</p><div class="informalexample"><pre class="programlisting">let gameOverText =  "Game Over!"</pre></div><p class="calibre8">We can have strings with emoji characters like the following:</p><div class="informalexample"><pre class="programlisting">let cardSuits =  "♠ ♥ ♣ ♦"</pre></div><p class="calibre8">What we <a id="id35" class="calibre1"/>did <a id="id36" class="calibre1"/>in the preceding code was create what's known as a string literal. A string literal is when we explicitly define a string around two quotes "".</p><p class="calibre8">We can create empty string variables for later use in our games such as:</p><div class="informalexample"><pre class="programlisting">var emptyString = ""               // empty string literal
var anotherEmptyString = String()  // using type initializer</pre></div><p class="calibre8">Both are valid ways to create an empty string "".</p></div>

<div class="book" title="Characters and strings" id="J2B81-d06b23b4a4554b3182353558917969c2">
<div class="book" title="String Interpolation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec18" class="calibre1"/>String Interpolation</h2></div></div></div><p class="calibre8">We can also<a id="id37" class="calibre1"/> create a string from a mixture of other data types, known as <span class="strong"><strong class="calibre9">String Interpolation</strong></span>. String Interpolation is rather common in game development, debugging, and string use in general.</p><p class="calibre8">The most notable of examples are displaying the player's score and lives. This is how one of our example games, PikiPop, uses String Interpolation to display the current player stats:</p><div class="informalexample"><pre class="programlisting">//displays the player's current lives
var livesLabel = "x \(currentScene.player!.lives)"

//displays the player's current score
var scoreText = "Score: \(score)"</pre></div><p class="calibre8">Take note of the <code class="email">\(variable_name)</code> formatting. We've actually seen this before in our past code snippets. In the various <code class="email">print()</code> outputs, we used this to display the variable, collection, and so on we wanted to get information on. In Swift, the way to output the value of a data type in a string is by using this formatting.</p><p class="calibre8">For those of us who came from Objective-C, it's the same as the following:</p><div class="informalexample"><pre class="programlisting">NSString *livesLabel = @"Lives: ";
int lives = 3;
NSString *livesText = [NSString stringWithFormat:@" %@ (%d days ago)", livesLabel, lives];</pre></div><p class="calibre8">Note how Swift makes String Interpolation much cleaner and easier to read than its Objective-C predecessor.</p><div class="book" title="Mutating strings"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Mutating strings</h3></div></div></div><p class="calibre8">There are <a id="id38" class="calibre1"/>various ways to change strings, such as adding characters to a string as we did to collection objects. Here are some basic examples:</p><div class="informalexample"><pre class="programlisting">var gameText = "The player enters the stage"
gameText += " and quickly lost due to not leveling up"
/* gameText now says
"The player enters the stage and lost due to not leveling up" */</pre></div><p class="calibre8">Since strings <a id="id39" class="calibre1"/>are essentially arrays of characters, like arrays, we can use the <code class="email">+=</code> assignment operator to add to the previous string.</p><p class="calibre8">Also, akin to arrays, we can use the <code class="email">append()</code> function to add a character to the end of a string.</p><div class="informalexample"><pre class="programlisting"> let exclamationMark: Character = "!"
gameText.append(exclamationMark)
//gameText now says "The player enters the stage and lost due to not leveling up!"</pre></div><p class="calibre8">Here's how we iterate through the characters in a string, in Swift:</p><div class="informalexample"><pre class="programlisting">for character in "Start!" {
    print(character)
}
//outputs:
//S
//t
//a
//r
//t
//!</pre></div><p class="calibre8">Note how again we use the for-in loop and even have the flexibility of using a string literal if we'd so like to be what's iterated through by the loop.</p></div><div class="book" title="String indices"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>String indices</h3></div></div></div><p class="calibre8">Another similarity between arrays and strings is the fact that a string's individual chara<a id="id40" class="calibre1"/>cters can be located via indices. Unlike arrays, however, since a character can be a varying size of data, broken in 21-bit numbers known as Unicode scalars, they can not be located in Swift with <code class="email">Int</code> type index values.</p><p class="calibre8">Instead, we can use the <code class="email">.startIndex</code> and <code class="email">.endIndex</code> properties of a string and move one place ahead or one place behind the index with the <code class="email">.successor()</code> and <code class="email">.predecessor()</code> functions, respectively, to retrieve the needed character or characters of a string.</p><p class="calibre8">Here are some examples that use these properties and functions using our previous <code class="email">gameText</code> string:</p><div class="informalexample"><pre class="programlisting">gameText[gameText.startIndex]              // = T
gameText[gameText.endIndex]                // = !
gameText[gameText.startIndex.successor()]  // = h
gameText[gameText.endIndex.predecessor()]  // = p</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">There are many ways to manipulate, mix, remove, and retrieve various aspects of strings and characters. For more information, be sure to check out the official Swift documentation on characters and strings at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html</a>.</p></div></div></div></div>
<div class="book" title="Commenting in Swift" id="K0RQ1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Commenting in Swift</h1></div></div></div><p class="calibre8">In our <a id="id41" class="calibre1"/>code snippets thus far, one might note notations with double forward slashes <code class="email">//</code> or with forward slashes and asterisks <code class="email">/* */</code>. These are how we can comment or make notations in our Swift code. Anyone who's coded in C++, Java, Objective-C, JavaScript, or other languages will see that Swift works practically the same.</p><p class="calibre8">Single-line <a id="id42" class="calibre1"/>comments are started with the double forward slashes, <code class="email">//</code>, while multiline comments or a comment block begins with <code class="email">/*</code> and ends with <code class="email">*/</code>.</p><p class="calibre8">Take the following example:</p><div class="informalexample"><pre class="programlisting">//This is a single line comment
/*
This is a comment block
that won't end until it reaches the closing asterisk/forward slash characters
 */</pre></div><p class="calibre8">Commenting is used to help navigate your code, understand what it might do, and comment out lines of code we might not want to execute, but at the same time want to keep for later (that is, <code class="email">print()</code> log calls or alternative starting property values).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">From Xcode 6 Beta 4 onward, we can also utilize the following comments:</p><p class="calibre8">
<code class="email">// MARK</code>:, <code class="email">// TODO:</code>, and <code class="email">// FIXME</code>. <code class="email">//MARK</code> is equivalent to Objective-C's <code class="email">#pragma</code> mark, which allows the programmer to label a <span class="strong"><em class="calibre10">section</em></span> of your code that is accessible in Xcode's top breadcrumb dropdown list. <code class="email">// TODO:</code> and <code class="email">// FIXME</code> give us the ability to section off parts of code that we wish to maybe add features to in the future or debug. Even games with well-organized class structuring can be daunting to sift through. The addition of these additional mark-up tools makes planning and searching through our games' code that much easier to do.</p></div></div>
<div class="book" title="Boolean" id="KVCC1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Boolean</h1></div></div></div><p class="calibre8">An<a id="id43" class="calibre1"/> integral part of all programming, game, or otherwise is the use of <span class="strong"><strong class="calibre9">Boolean</strong></span> values. Boolean values typically return either <code class="email">true</code> or <code class="email">false</code> values, <code class="email">yes</code> or <code class="email">no</code>, or <code class="email">0</code> or <code class="email">1</code>. In Swift, this is the job of the <code class="email">Bool</code> class of objects. The use of the function <code class="email">.isEmpty()</code> in our past collection data type examples returns a Boolean value of <code class="email">true</code> or <code class="email">false</code> based on whether that collection is empty or not.</p><p class="calibre8">In game development, one way we could use Boolean values is to have a global variable (a variable accessible in scope throughout our game/app) that checks if the game is over.</p><div class="informalexample"><pre class="programlisting">var isGameOver = false</pre></div><p class="calibre8">This variable, taken from the PikiPop game, starts the game off with a variable of type <code class="email">bool</code> named <code class="email">isGameOver</code> with a starting value of <code class="email">false</code>. If the events of the game cause this value to change to <code class="email">true</code>, then this triggers the events associated with the game over state.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">Unlike Boolean values in Objective-C, Swift uses only <code class="email">true</code> or <code class="email">false</code> values to represent Boolean variables. <span class="strong"><em class="calibre10">Swift strict type safety</em></span> does not allow the use of <code class="email">YES</code> and <code class="email">NO</code> or <code class="email">0</code> and <code class="email">1</code>, as we have seen in Objective-C and other programming languages.</p></div><p class="calibre8">However, reading and controlling this type of information about our game, known as the game's state, is best controlled with more than just a single Boolean value. This is because your game and the characters in your game could have various states, such as <span class="strong"><em class="calibre10">game over</em></span>, <span class="strong"><em class="calibre10">paused</em></span>, <span class="strong"><em class="calibre10">spawn</em></span>, <span class="strong"><em class="calibre10">idle</em></span>, <span class="strong"><em class="calibre10">running</em></span>, <span class="strong"><em class="calibre10">falling</em></span>, and more. A special object known as a <span class="strong"><em class="calibre10">state machine</em></span> best manages this type of information. State machines shall be covered in more detail when we discuss the <a id="id44" class="calibre1"/><span class="strong"><strong class="calibre9">GameplayKit</strong></span> framework.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Ints, UInts, floats, and doubles" id="LTSU1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec17" class="calibre1"/>Ints, UInts, floats, and doubles</h1></div></div></div><p class="calibre8">In addition to Boolean values, another basic data type we have up to this point briefly mentioned is the various numeric objects, such as integers (Ints), unsigned integers (UInts), floating point numbers / decimals (floats), and double precision floating point numbers / decimals (doubles).</p></div>

<div class="book" title="Ints, UInts, floats, and doubles" id="LTSU1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Integers and unsigned integers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec19" class="calibre1"/>Integers and unsigned integers</h2></div></div></div><p class="calibre8">Integers <a id="id45" class="calibre1"/>represent <a id="id46" class="calibre1"/>negative and positive whole numbers, while unsigned integers represent positive whole numbers. Like with C and other programming languages, Swift lets us create various types of integers and unsigned integers from 8, 16, 32, and 64 bits. For example, an Int32 type is a 32-bit integer, while a UInt8 type is an 8-bit unsigned integer. The size of the bits for Ints and UInts represents how much space is being allocated to store the values. Using our UInt8 example, a number made from this type of unsigned Int can only store the values 0-255 (or 11111111 in a base-2 system). This is also known as 1 byte (8 bits). If we need to store numbers larger than 255 or negative numbers, then maybe an Int16 type would suffice as that can store numbers between –32767 and 32767. Usually, we don't have to worry too much about the size allocated by our integer variables and constants. So, using just the class name of <code class="email">Int</code> will work fine in most cases.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">The size of <code class="email">Int</code> will differ depending on the type of system we are working on. If we are compiling our code on a 32-bit system, an integer will be equal to Int32, while the same integer would be an Int64 on a 64-bit system.</p><p class="calibre8">Swift can let us see what our minimum and maximum values are for an <code class="email">Int</code> variable with the <code class="email">.min</code> or <code class="email">.max</code> class variables (that is, <code class="email">Int16.max = 32767</code> and <code class="email">UInt.min = 0</code>).</p></div></div></div>

<div class="book" title="Ints, UInts, floats, and doubles" id="LTSU1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Floats and doubles"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec20" class="calibre1"/>Floats and doubles</h2></div></div></div><p class="calibre8">Floats<a id="id47" class="calibre1"/> are 32bit floating point numbers / fractions, such as pi (3.14), or the golden ratio, phi (1.61803).</p><p class="calibre8">In game designing, we work with floating point values and ranges rather often, be it to determine the CGPoint in <span class="strong"><em class="calibre10">x</em></span> and <span class="strong"><em class="calibre10">y</em></span> of a 2D sprite, using linear interpolation for smoothing a game's camera movement in 3D space, or applying various physics forces on an object or 2D/3D vector. The precision needed for each situation will determine if a float is needed or if the 64-bit floating point value, the double is needed. Doubles<a id="id48" class="calibre1"/> can be as precise as 15 decimal places, while a float is six decimal places precise.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">It's actually best practice to use doubles in situations that would work for either floats or doubles.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Objects in Swift" id="MSDG1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec18" class="calibre1"/>Objects in Swift</h1></div></div></div><p class="calibre8">The<a id="id49" class="calibre1"/> core aspect of <a id="id50" class="calibre1"/><span class="strong"><strong class="calibre9">object-oriented programming</strong></span> (<span class="strong"><strong class="calibre9">OOP</strong></span>) is of course the concept of objects. C++ began this paradigm in programming, while Java, C#, Apple's Objective-C, and other languages were all essentially built from this foundation.</p><p class="calibre8">Swift is an OOP language with the same dynamic object model as Objective-C, but presented in a cleaner, type-safe, and compact way.</p><p class="calibre8">You can think of an object exactly as it sounds, an abstract <span class="strong"><em class="calibre10">thing</em></span> or <span class="strong"><em class="calibre10">container</em></span>. An object can be something as simple as a string, or something as complex as the player object in the latest video game. Technically speaking, an object in a program is a <span class="strong"><em class="calibre10">reference</em></span> to a set of various data in an allocated chunk of memory, but it's sufficient to just understand that an object can be a variable or a reference to an instance of a class, Struct, or block of code.</p><p class="calibre8">An object can have various data fields/aspects associated with it, such as properties, functions, parent objects, child objects, and protocols. In languages such as C for example, an integer variable is usually represented as just raw data, but the integer type in Swift is actually an object. Thus, we can access extra information and perform functions on <code class="email">Int</code> objects in our code. We previously saw this with the <code class="email">Int.max</code> variable, which returns the highest number that can be represented by the <code class="email">Int</code> class. Again, depending on the machine you are working on, this could be the same value as <code class="email">Int32.max</code> or <code class="email">Int64.max</code>.</p><div class="informalexample"><pre class="programlisting">var highestIntNumber : Int = Int.max</pre></div><p class="calibre8">Access to functions and properties of an object uses dot notation, as we saw with the previous example. <code class="email">Int.max</code> and <code class="email">Int.min</code> are actually special properties known as <span class="strong"><strong class="calibre9">class variables</strong></span>, which represent all instances of an <code class="email">Int</code> type object.</p><p class="calibre8">Let's look at how Swift deals with obtaining properties and functions of an instance of an object using a made-up <code class="email">Player</code> type object.</p><div class="informalexample"><pre class="programlisting">let currentPlayer = Player(name:"Fumi")       //(a)
let playerName = currentPlayer.getName()      //(b)
var playerHealth = currentPlayer.health       //(c)
currentPlayer.attackEnemy()                   //(d)</pre></div><p class="calibre8">We'll get back to the second half of line <code class="email">(a)</code>, but just understand that it creates an instance of an object of the type <code class="email">Player</code> named <code class="email">currentPlayer</code>. Line <code class="email">(c)</code> creates a variable named <code class="email">playerHealth</code> that's set by the <code class="email">health</code> property of <code class="email">currentPlayer</code>; here with the <span class="strong"><em class="calibre10">dot notation</em></span>. Lines <code class="email">(b)</code> and <code class="email">(d)</code> use the dot notation to call the functions <code class="email">getName()</code> and <code class="email">attackEnemy()</code>. The <code class="email">getName()</code> function in this case is a function that returns a string that's assigned to the constant, <code class="email">playerName</code>. Line <code class="email">(c)</code> creates a variable named <code class="email">playerHealth</code> that is created by referencing the health property of <code class="email">currentPlayer</code>, also using dot notation. Line <code class="email">(d)</code> is a direct call to the <code class="email">Player</code> class' <code class="email">attackEnemy()</code> function, which you can imagine for now just performs what would make <code class="email">currentPlayer</code> do her attack. This function doesn't return a value and thus is what's known as a <code class="email">void</code> type function.</p><p class="calibre8">As for line <code class="email">(a)</code>, one <a id="id51" class="calibre1"/>might note that it doesn't use the dot notation. This is how Swift does what's known as a class initializer; designated by the parenthesis <code class="email">()</code> after the class name and with the parameter called <code class="email">name</code>: that sends a string, <code class="email">Fumi</code>, to the object's class initializer.</p><p class="calibre8">We will be diving deeper in to the use of <span class="strong"><em class="calibre10">objects</em></span> momentarily as we move on to functions and classes.</p></div>

<div class="book" title="Objects in Swift" id="MSDG1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Type safety and type inference"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl3sec04" class="calibre1"/>Type safety and type inference</h2></div></div></div><p class="calibre8">Objects and, as we'll see, functions <a id="id52" class="calibre1"/>on these objects in Swift are type-safe. What this means is that if we perform a function on a string object when the code was expecting an integer, then the compiler will warn us early on in the process. In the vein of game design, if we were to have the player perform an action only an enemy supposed to do, then Swift will know through its inherently type-safe nature.</p><p class="calibre8">Swift's type inference <a id="id53" class="calibre1"/>is something we've mentioned before. Unlike other languages where you have to declare the object's type every time it's initialized, Swift will infer what type you mean. For example, we have the following:</p><div class="informalexample"><pre class="programlisting">var playerHealth = 100
//Swift automatically infers that playerHealth is an Int object</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Optionals"><div class="book" id="NQU22-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec19" class="calibre1"/>Optionals</h1></div></div></div><p class="calibre8">As we stated before, Swift is a type-safe language. Apple also created Swift with the intention of keeping as many potential errors and bugs in the compilation state of development as opposed to runtime. Though Xcode has some great debugging tools, from the use of breaks, logging, and the LLDB debugger, runtime errors, particularly in games can be tough to spot, thus bringing the development process to a halt. To keep everything type-safe and as bug-free <a id="id54" class="calibre1"/>as possible during compilation, Swift deals with the concept of <span class="strong"><strong class="calibre9">optionals</strong></span>.</p><p class="calibre8">Optionals, in short, are objects that potentially can be or start as nil. Nil, of course, is an object that has no reference.</p><p class="calibre8">In Objective-C, we could declare the following string variable for a game:</p><div class="informalexample"><pre class="programlisting">NSString *playerStatus = @"Poisoned";
playerStatus = nil;</pre></div><p class="calibre8">In Swift, we would write this in the same way, but we'd find out very quickly that Xcode would give us a compiler error in doing so:</p><div class="informalexample"><pre class="programlisting">var playerStatus = "Poisoned"
playerStatus = nil      //error!</pre></div><p class="calibre8">Even more<a id="id55" class="calibre1"/> confusing for anyone new to Swift, we'd also get an error if we did something as simple as this:</p><div class="informalexample"><pre class="programlisting">var playerStatus : String   //error</pre></div><p class="calibre8">Creating empty/undeclared objects in our games makes sense and is something we'd often want to do at the start of our classes. We want that flexibility to assign a value later on based on the events of our game. Swift seems to be making such a basic concept impossible to do! No worries; Xcode will inform you in most cases to suffix a question mark, <code class="email">?,</code> at the end of these <code class="email">nil</code> objects. This is how you declare an object as an optional.</p><p class="calibre8">So, if we want to plan our game's properties and objects in Swift, we can do the following:</p><div class="informalexample"><pre class="programlisting">var playerStatus : String?  //optional String
var stageBoss : Boss?       //optional Boss object</pre></div></div>

<div class="book" title="Optionals">
<div class="book" title="Unwrapping optionals"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec22" class="calibre1"/>Unwrapping optionals</h2></div></div></div><p class="calibre8">Let's imagine<a id="id56" class="calibre1"/> that we want to display what caused a player to lose in the game.</p><div class="informalexample"><pre class="programlisting">var causedGameOver:String? = whatKilledPlayer(enemy.recentAttack)
let text = "Player Lost Because: "
<span class="strong"><strong class="calibre9">let gameOverMessage = text + causedGameOver  //error</strong></span>
</pre></div><p class="calibre8">Because the string <code class="email">causedGameOver</code> is optional, Xcode will give us a compile error because we didn't unwrap the optional. To unwrap the value in an optional, we suffix an exclamation point <code class="email">!</code> at the end of the optional.</p><p class="calibre8">Here's our <code class="email">Game Over</code> message code, now fixed using the unwrapped optional:</p><div class="informalexample"><pre class="programlisting">var causedGameOver:String? = whatKilledPlayer(enemy.recentAttack)
let text = "Player Lost Because: "
<span class="strong"><strong class="calibre9">let gameOverMessage = text + causedGameOver!  //code now compiles!</strong></span>
</pre></div><p class="calibre8">We can also force unwrap optionals early at declaration to allow any potential errors to be taken care of at runtime instead of when compiling. This happens often with <code class="email">@IBOutlets</code> and <code class="email">@IBActions</code> (objects and functions linked to various storyboards and other tools that are based on menu/view tools).</p><div class="informalexample"><pre class="programlisting">@IBOutlet var titleLabel: UILabel!      //label from a Storyboard
var someUnwrappedOptional : GameObject! //our own unwrapped optional</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">If possible, though it's recommended to use the basic wrapped optional <code class="email">?</code> as much as possible to allow the compiler to find any potential errors. Using what's known as optional binding and chaining, we can do some great early logic checks on optionals that in prior languages would have involved various <code class="email">if</code> statements / control flow statements to simply check for nil objects.</p><p class="calibre8">Keeping code clean, safe, and easy to read is what Swift aims to do and why Swift goes out of its way sometimes to force many of these rules with optionals.</p></div></div></div>

<div class="book" title="Optionals">
<div class="book" title="Optional binding and chaining"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec23" class="calibre1"/>Optional binding and chaining</h2></div></div></div><p class="calibre8">Optional binding is<a id="id57" class="calibre1"/> checking whether an optional has a value or not. This is done using the very handy if-let or if-var statements. Let's look back at our earlier code:</p><div class="informalexample"><pre class="programlisting">var causedGameOver:String? = whatKilledPlayer(enemy.recentAttack)
let text = "Player Lost Because: "
if let gotCauseOfDeath = causedGameOver {
    let gameOverMessage = text + gotCauseOfDeath
}</pre></div><p class="calibre8">The code block, <code class="email">if let gotCauseOfDeath = causedGameOver{…}</code>, does two things. First, using the key words, <code class="email">if let</code>, it automatically creates a constant named <code class="email">gotCauseOfDeath</code> and then binds it to the optional <code class="email">causedGameOver</code>. This simultaneously checks whether <code class="email">causedGameOver</code> is <code class="email">nil</code> or has a value. If it's not nil, then the <code class="email">if</code> statement's code block will run; in this case, creating the constant <code class="email">gameOverMessage</code> that combines the <code class="email">text</code> constant with <code class="email">gotCauseOfDeath</code>.</p><p class="calibre8">We can use if-var to simplify this even further:</p><div class="informalexample"><pre class="programlisting">let text = "Player Lost Because: "
if var causedGameOver = whatKilledPlayer(enemy.recentAttack) {
    let message = text + causedGameOver
}</pre></div><p class="calibre8">The if-var statement creates a temporary variable using our previously used optional <code class="email">causedGameOver</code> and does a Boolean logic check based on the result of <code class="email">whatKilledPlayer(enemy.recentAttack)</code>. The statement is true if there's a non-nil value returned. Note how we don't have to use either wrapped (<code class="email">?</code>) or forced unwrapping (<code class="email">!</code>) of the optional in such a case.</p><p class="calibre8">Optional chaining<a id="id58" class="calibre1"/> is when we query down into the properties of an object using the dot operator while also doing a nil/value check as we did with optional binding. For example, let's say that we have a game where certain Enemy types can cause a player to lose instantly via an Enemy instance named <code class="email">currentEnemy</code>. In this example, <code class="email">currentEnemy.type</code> would be a string that returns the name of the kind of enemy that hit the player. Optional chaining uses the custom dot modifier <code class="email">?.</code> while accessing a potentially nil check on a property. Here's the code to get a better idea of how this works:</p><div class="informalexample"><pre class="programlisting">if let enemyType = currentEnemy?.type {
    if enemyType == "OneHitKill"
    {
      player.loseLife()  //run the player's lost l
    }
}</pre></div><p class="calibre8">Chances are <a id="id59" class="calibre1"/>that we'd probably not make an enemy without a designated type, but for the sake of understanding optional chaining, observe how this checks for the possible nil object that'd be returned by <code class="email">currentEnemy.type</code> using <code class="email">currentEnemy?.type</code>. Like how the dot operator functions where you can drill down the properties and properties of properties, the same can be done with the recurring <code class="email">?.per</code> property that is drilled down. In this code, we do a Boolean comparison with <code class="email">==</code> to see if <code class="email">enemyType</code> is the string <code class="email">OneHitKill</code>.</p><p class="calibre8">Don't worry if the syntax of the <code class="email">if</code> statement syntax is a bit of a mystery; next, we discuss how Swift uses <code class="email">if</code> statements, loops, and other ways we can control various object data and their functions.</p></div></div>

<div class="book" title="Optionals">
<div class="book" title="Control flow in Swift"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec24" class="calibre1"/>Control flow in Swift</h2></div></div></div><p class="calibre8">Control flow <a id="id60" class="calibre1"/>in any program is simply the order of instructions and logic in your code. Swift, like any other programming language, uses various statements and blocks of code to loop, change, and/or iterate through your objects and data. This includes blocks of code such as <code class="email">if</code> statements, for-loops, do-while loops and Switch statements. These are contained within functions, which make up larger structures like classes.</p><div class="book" title="If statements"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>If statements</h3></div></div></div><p class="calibre8">Before <a id="id61" class="calibre1"/>we move <a id="id62" class="calibre1"/>on to how Swift handles one of the main topics of OOP, functions and classes, let's quickly run through if-else statements. An <code class="email">if</code> statement checks whether a Boolean statement is <code class="email">true</code> or <code class="email">false</code>. We have the example as follows:</p><div class="informalexample"><pre class="programlisting">if player.health &lt;= 0{
   gameOver()
}</pre></div><p class="calibre8">This checks whether or not the player's health is less than or equal to <code class="email">0</code>, designated by the <code class="email">&lt;=</code> operator. Note that Swift is OK with there not being parenthesis, but we can use this if we wish or if the statement gets more complicated, as in this example:</p><div class="informalexample"><pre class="programlisting">if (player.health &lt;=0) &amp;&amp; (player.lives &lt;=0){ //&amp;&amp; = "and"
   gameOver()
}</pre></div><p class="calibre8">Here, we <a id="id63" class="calibre1"/>check <a id="id64" class="calibre1"/>not just whether the player has lost all of their health, but also if all of their lives are gone with the and (<code class="email">&amp;&amp;</code>) operator. In Swift, like in other languages, we separate out the individual Boolean checks with parentheses, and like other languages, we do a logic-or check with two bar keys (<code class="email">||</code>).</p><p class="calibre8">Here are some more ways to write <code class="email">if</code> statements in Swift with the added key words, else-if and else, as well as how Swift can check if-not a certain statement:</p><div class="informalexample"><pre class="programlisting">//(a)
if !didPlayerWin { stageLost() }

//(b)
if didPlayerWin
{            
   stageWon()
}
else
{
  stageLost()
}

//(c)
if (enemy == Enemy.angelType){enemy.aura = angelEffects}
else if(enemy == Enemy.demonType){enemy.aura = demonEffects}
else{ enemy.aura = normalEffects }

//(d)
if let onlinePlayerID = onlineConnection()?.packetID?.playerID
{
  print("Connected PlayerID: /(onlinePlayerID)"
}

//(e)
if let attack = player.attackType, power = player.power where power != 0 {
    hitEnemy(attack, power)
}

//(f)
let playerPower = basePower + (isPoweredUp ? 250 : 50)</pre></div><p class="calibre8">Let's look at <a id="id65" class="calibre1"/>what <a id="id66" class="calibre1"/>we put in the code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">(a)</code>: This checks the not / reverse of a statement with the exclamation point, <code class="email">!</code>, via <code class="email">!statement</code>.</li><li class="listitem"><code class="email">(b)</code>: This checks whether the player has won or not. Otherwise, the <code class="email">stageLost()</code> function is called, using the key word <code class="email">else</code>.</li><li class="listitem"><code class="email">(c)</code>: This checks if an enemy is an angel and sets its aura effect accordingly. If this is not, then it will check if it's a demon using else-if, and if that's not the case, then we catch all other instances with the <code class="email">else</code> statement. We could have a number of else-if statements one after another, but if we start to stack too many, then using for-loops and Switch statements would be a better approach.</li><li class="listitem"><code class="email">(d)</code>: Using optional chaining, we create an <code class="email">onlineID</code> constant based on <code class="email">if</code>; we are able to get a non-nil <code class="email">playerID</code> property using if-let.</li><li class="listitem"><code class="email">(e)</code>: This uses if-let, where optional binding became a feature in Swift 1.2. Instead of having nested if-lets and other logic checks, akin to how SQL queries are done in backend web development, we can create very compact, powerful early logic checking. In the case of example <code class="email">(e)</code>, we have an enemy receive an attack based on what type of attack it is and the power of the player.</li><li class="listitem"><code class="email">(f)</code>: This is an example of combining the creation of a constant with the keyword <code class="email">let</code> and doing a shorthand version of an <code class="email">if</code> statement. We shorthen an <code class="email">if</code> statement in Swift with the question mark <code class="email">?</code> and colon <code class="email">:</code>. Here is the format for short handing an <code class="email">if</code> statement: <code class="email">bool ? trueResult : falseResult</code>. If <code class="email">isPoweredUp</code> is <code class="email">true</code>, then <code class="email">playerPower</code> will equal <code class="email">basepower + 250</code>; if <code class="email">false</code>, then it's <code class="email">basepower + 50</code>.</li></ul></div></div><div class="book" title="For loops"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>For loops</h3></div></div></div><p class="calibre8">We<a id="id67" class="calibre1"/> touched <a id="id68" class="calibre1"/>on for-in loops before dealing with collections. Here again is a for-in loop in Swift that will iterate through a collection object:</p><div class="informalexample"><pre class="programlisting">for itemName in inventory.values {
    print("Item name: \(itemName)")
}</pre></div><p class="calibre8">For some of us programmers who are used to the older way of using for-loops, don't worry, Swift lets us write for-loops in the C-style, which many of us are probably used to:</p><div class="informalexample"><pre class="programlisting">for var index = 0; index &lt; 3; ++index {
    print("index is \(index)")  
}</pre></div><p class="calibre8">Here's another <a id="id69" class="calibre1"/>way of using a for-loop without using an index variable, noted with the underscore <a id="id70" class="calibre1"/>character <code class="email">_</code> but of course using a <code class="email">Range&lt;Int&gt;</code> object type to determine how many times the for-loop iterates:</p><div class="informalexample"><pre class="programlisting">let limit = 10
var someNumber = 1
for _ in 1...limit {
    someNumber *= 2
}</pre></div><p class="calibre8">Note the <code class="email">…</code> between the <code class="email">1</code> and <code class="email">limit</code>. This means that this for-in loop will iterate from 1-10. If we wanted it to iterate from <code class="email">0</code> to <code class="email">limit-1</code> (similar to iterating between the bounds of an array's index), we could have instead typed <code class="email">0..&lt;limit</code> where <code class="email">limit</code> is equal to the array's <code class="email">.count</code> property.</p></div><div class="book" title="Do-while loops"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>Do-while loops</h3></div></div></div><p class="calibre8">Another <a id="id71" class="calibre1"/>very common iteration loop in programming is the <a id="id72" class="calibre1"/>do-while loop. Many times we can just utilize the while portion of this logic, so let's look into how and why we might use a while loop:</p><div class="informalexample"><pre class="programlisting">let score = player.score
var scoreCountNum = 0
while scoreCountNum &lt; score {
    HUD.scoreText = String(scoreCountNum)
    scoreCountNum = scoreCountNum * 2
}</pre></div><p class="calibre8">In game development, one use of the while loop (though executed differently in a game app, this accommodates iterating once per frame) is for displaying the counting up of a player's score from 0 to the score the player reached—a common esthetic of many games at the end of a stage. This while loop will iterate until it reaches the player's score, displaying on HUD object showing the intermediate values up until that score.</p><p class="calibre8">A do-while loop is practically the same as the while-loop with the extra caveat of iterating through the code block at least once. The end-stage score count example can also illustrate why we would need such a loop. For example, let's imagine that the player did really bad and got no score when the stage ended. In the while loop given, a score of zero won't let us enter the block of code in the while loop since it doesn't fulfill the logic check of <code class="email">scoreCountNum &lt; score</code>. In the while loop, we also have code that displays the score text. Though maybe embarrassing to the player, we would want to count up to the score and more importantly, still display a score. Here's the same code done with a do-while loop:</p><div class="informalexample"><pre class="programlisting">let score = player.score
var scoreCountNum = 0
do {
    HUD.scoreText = String(scoreCountNum)
    scoreCountNum = scoreCountNum * 2
} while scoreCountNum &lt; score</pre></div><p class="calibre8">Now score<a id="id73" class="calibre1"/> text will <a id="id74" class="calibre1"/>display even if the player scored nothing.</p></div><div class="book" title="Switch statements"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Switch statements</h3></div></div></div><p class="calibre8">Switch statements<a id="id75" class="calibre1"/> are useful when we wish to check <a id="id76" class="calibre1"/>many different conditions of an object in a fully encompassing and neat way without having a wall of else-if statements. Here's a code snippet from the game PikiPop that uses a Switch statement from the game, PikiPop, that sets the percentage a <code class="email">GameCenter</code> achievement (in this case, a 6x combo) based on the number of times the combo was achieved by the player. Don't worry too much about the <code class="email">GameCenter</code> code (used with the <code class="email">GCHelper</code> singleton object); that's something we will go over in future chapters when we make games in SpriteKit and SceneKit.</p><div class="informalexample"><pre class="programlisting">switch (comboX6_counter) {
                
            case 2:
                GCHelper.sharedInstance.reportAchievementIdentifier("Piki_ComboX6", percent: 25)
                break

            case 5:
                GCHelper.sharedInstance.reportAchievementIdentifier("Piki_ComboX6", percent: 50)
                break
                
            case 10:
                GCHelper.sharedInstance.reportAchievementIdentifier("Piki_ComboX6", percent: 100)
                
            default:
                break
                
        }</pre></div><p class="calibre8">The switch statement here takes the variable used to count how many times the player hit a 6X combo, <code class="email">comboX6_counter</code>, and performs different tasks based on the value of <code class="email">comboX6_counter</code>. For example, when the player has done a 6X Combo twice, the Piki_ComboX6 <a id="id77" class="calibre1"/>achievement gets 25% fulfilled. The player gets the achievement (when at 100%) when the counter hits 10. The purpose of the keyword <code class="email">break</code> is to tell the loop to exit at that point; otherwise, the next case block will iterate. Sometimes, this might be desired <a id="id78" class="calibre1"/>by your game's logic, but keep in mind that Swift, like many other languages, will continue through the switch statement without <code class="email">break</code>. The keyword <code class="email">default</code> is the catch-all block and is called when the value of the item checked by the switch statement is anything but the various cases. It can be thought of as an equivalent to the <code class="email">else{}</code> block, while all of the cases are similar to <code class="email">else if(){}</code>. The difference though is that Swift requires all cases of the switch be handled. So, though we can suffice with an <code class="email">if</code> without an <code class="email">else</code>, we have to have a default case for a switch statement. Again, this is done to keep Swift code safe and clean earlier in the coding process.</p></div></div></div>

<div class="book" title="Optionals">
<div class="book" title="Functions and classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec25" class="calibre1"/>Functions and classes</h2></div></div></div><p class="calibre8">Up until this point, we have kept from discussing probably the most important aspects of Swift or any OOP languages for that matter—how the language handles functions on objects and how it organizes these objects, object properties, and functions and performs various object-oriented design concepts, such as polymorphism and inheritance with classes, Structs, enums, protocols, and other data structures. There is much more to discuss about how Swift utilizes these concepts, more than we can fit in this chapter but throughout the course of this book, especially as we get into how to use Apple's game-centric SpriteKit and SceneKit frameworks, we will flesh out more on these topics.</p><div class="book" title="Functions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec09" class="calibre1"/>Functions</h3></div></div></div><p class="calibre8">In Objective-C, functions <a id="id79" class="calibre1"/>are written the following way:</p><div class="informalexample"><pre class="programlisting">-(int) getPlayerHealth() {
    return player.health;
}</pre></div><p class="calibre8">This is a simple function that returns the player's health as an integer—the <code class="email">Int</code> equivalent in Objective-C.</p><p class="calibre8">The structure of the function/method is as follows in Objective-C:</p><div class="informalexample"><pre class="programlisting">- (return_type) method_name:( argumentType1 )argumentName1
joiningArgument2:( argumentType2 )argumentName2 ...
joiningArgumentN:( argumentTypeN )argumentNameN
{
  function body
}</pre></div><p class="calibre8">Here's the same<a id="id80" class="calibre1"/> function in Swift:</p><div class="informalexample"><pre class="programlisting">func getPlayerHealth() -&gt; Int {
    return player.health
}
//How we'd use the function
var currentHealth : Int = 0
currentHealth = getPlayerHealth()</pre></div><p class="calibre8">This is how a function is structured in Swift:</p><div class="informalexample"><pre class="programlisting">func function_name(argumentName1 : argumentType1, argumentName2 : argumentType2, argumentNameN : argumentTypeN) -&gt; return_type
{
  function body
}</pre></div><p class="calibre8">Note how we use the keyword <code class="email">func</code> to create a function and how the argument/parameter names are first with the types second, separated by the colon (<code class="email">:</code>) and within parenthesis.</p><p class="calibre8">Here's what a typical void function looks like in Swift. A void-type function is a function that doesn't return a value.</p><div class="informalexample"><pre class="programlisting">//with a Player type as a parameter
func displayPlayerName (player:Player){
     print(player.name)
}

//without any parameters; using a class property
func displayPlayerName(){
     print(currentPlayer.name)
}</pre></div><p class="calibre8">In a void function, there's no need to write <code class="email">-&gt;returnType</code>, but even if there are no parameters, we do have to put in the <code class="email">()</code> parenthesis at the end of the function name.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Tuples" id="OPEK1-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec20" class="calibre1"/>Tuples</h1></div></div></div><p class="calibre8">A rather<a id="id81" class="calibre1"/> powerful aspect of Swift is that function return types (and constants/variables) can include a combination of values into a single value. These combinations are called <span class="strong"><strong class="calibre9">tuples</strong></span>. Here's an example of an unnamed tuple:</p><div class="informalexample"><pre class="programlisting">let http503Error = (503, "Service Unavailable")</pre></div><p class="calibre8">Here's a tuple used as a return type in a function direct from Apple's Swift documentation. Observe <a id="id82" class="calibre1"/>how it uses much of what we've learned thus far:</p><div class="informalexample"><pre class="programlisting">func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..&lt;array.count] {
        if value &lt; currentMin {
            currentMin = value
        } else if value &gt; currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
Excerpt From: Apple Inc. "IOS Developer Library". https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID164</pre></div></div>

<div class="book" title="Tuples" id="OPEK1-d06b23b4a4554b3182353558917969c2">
<div class="book" title="Classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec26" class="calibre1"/>Classes</h2></div></div></div><p class="calibre8">In OOP, classes <a id="id83" class="calibre1"/>make up the basic frame of an object, its functionality and interactions with other classes, objects, and various data structures, such as protocols, Structs, extensions, generics, and enumerations. In the following chapters, as we begin to structure our games, we will dive deeper into all of these concepts, but for now, let's understand the basics of classes and how they differ in Swift from Objective-C and other languages.</p><p class="calibre8">Here's the basic structure of a class in Swift:</p><div class="informalexample"><pre class="programlisting">//(a)
Global-project wide properties/variables
//(b)
class className : parentClassName, protocolName…protocolnName
{
//(c)
  class scope properties
//(d)
initializers (init(), convenience, required, etc)

//(e)
  func function_name1(argumentName1 : argumentType1, argumentName2 :    argumentType2, argumentNameN : argumentTypeN) -&gt; return_type
 {
   function-scope variables and body
 }
                         .
                         .
                         .
  func function_nameN(argumentName1 : argumentType1, argumentName2 :    argumentType2, argumentNameN : argumentTypeN) -&gt; return_type
 {
   function-scope variables and body
 }
//(f)
deinit()

} // end of the class
//(g)
global-project wide properties/variables (alternative position)</pre></div><p class="calibre8">The Swift class<a id="id84" class="calibre1"/> structure works somewhat similar to what we see in C# and Java, as opposed to Objective-C's two files' (<code class="email">.h</code>/<code class="email">header</code>, <code class="email">.m</code>/<code class="email">.mm</code>/ implementation) setup:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">(a)</code>: We can have properties (like variables, constants, Structs, and enums) outside of the class declaration, which would make them global in scope, aka accessible throughout the entire project/game/app.</li><li class="listitem"><code class="email">(b)</code>: This is the actual class represented by what we named our <code class="email">.swift</code> file. Again, this is different from Objective-C's <code class="email">classname.h - classname.m/.mm</code> dual file setup for a single class. A class can be a child class of another class. We don't have to declare a parent/base class in Swift. Classes we make can be their own base classes. We can make classes as Objective-C classes by subclassing them from NSObject. The benefit of that is getting Objective-C runtime metadata and capabilities, but we take a hit in performance from the extra <span class="strong"><em class="calibre10">baggage</em></span>. Either in the same place as the <code class="email">parentClass</code> or after the colon <code class="email">:</code> of <code class="email">parentClass</code>, we can declare which protocols this class will adhere to. We'll discuss more on protocols later in the book, but just think of them as making sure your class utilizes the same functions as the protocol dictates.</li><li class="listitem"><code class="email">(c)</code>: These are where we'd place variables, constants, Structs, enums, and objects that are relevant for use in the scope of the class.</li><li class="listitem"><code class="email">(d)</code>: Initializers are special functions we use to set up the properties in section <code class="email">(c)</code> when other classes and data structures use instances of the class via <code class="email">className(initializer parameters)</code>. We will discuss more on initializers more in the next chapter as we structure our games. They don't have to be at the top of the class, but it's a good practice to do so.</li><li class="listitem"><code class="email">(e)</code>: These <a id="id85" class="calibre1"/>are where your class functions will be declared and developed. We can have functions that are known as class functions. These are designated with the keywords <code class="email">class func</code>. In short, class functions are part of the class as a whole as opposed to an instance of the class. It's best practice to place these above the next, more common type of function, the public functions, that can be accessed by other classes and properties via the dot operator (that is, <code class="email">className.function(parameters)</code>). Using the <code class="email">private func</code> keywords, as in C# and Java, we can create private functions that are only accessible to the class's own functions and properties.</li><li class="listitem"><code class="email">(f)</code>: The <code class="email">deinit()</code> function is a special optional function that deals with how we clean up the data allocated by our class with memory management and eliminating what's known as memory leaks. Apple's <span class="strong"><strong class="calibre9">ARC</strong></span> (<span class="strong"><strong class="calibre9">Automated Reference Counting</strong></span>) handles most of this, but there are key words, such as weak and unowned, that we will at times have to put before various properties to make sure that they don't hang around after use.<p class="calibre14">This is a rather involved topic, but worth looking into to avoid memory leaks in your game. ARC does take care of most of this, but there might be objects in your game that could potentially hang around. It's highly recommended to read Apple's own documentation on this topic, as memory management in iOS is always in the evolving stage. You can view the full documentation on ARC and memory management in Swift at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html</a>.</p></li><li class="listitem"><code class="email">(g)</code>: If we wish, we can have global properties also at the bottom of our <code class="email">.swift</code> files, after the end of the class declaration. Apple's own game example, Adventure (<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html</a>), places global properties in this spot.</li></ul></div></div></div>
<div class="book" title="Summary" id="PNV61-d06b23b4a4554b3182353558917969c2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec21" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">There's much more about the Swift programming language than we could fit here. Throughout the course of this book, we will throw in a few extra tidbits and nuances about Swift as it becomes relevant to our upcoming gaming programming needs.</p><p class="calibre8">If you wish to become more versed in the Swift programming language, Apple actually provides a wonderful tool in what's known as a <span class="strong"><strong class="calibre9">Playground</strong></span>.</p><p class="calibre8">Playgrounds were introduced with the Swift programming language at <span class="strong"><em class="calibre10">WWDC14</em></span> in June of 2014 and allow us to test various code outputs and syntaxes without having to create a project, build it, and run it and repeat again, when in many cases we simply needed to tweak a few variables and function loop iterations.</p><p class="calibre8">There are a number of resources to check out on the official Swift developer page (<a class="calibre1" href="https://developer.apple.com/swift/resources/">https://developer.apple.com/swift/resources/</a>).</p><p class="calibre8">Two highly recommended Playgrounds to check out are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">The Guided Tour Playground</strong></span> (<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip">https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip</a>): This Playground covers many of the topics we mentioned in this chapter and more, from <span class="strong"><strong class="calibre9">Hello World</strong></span> all the way to <span class="strong"><strong class="calibre9">Generics</strong></span>.</li><li class="listitem"><span class="strong"><strong class="calibre9">The Balloons Playground</strong></span> (<a class="calibre1" href="https://developer.apple.com/swift/blog/downloads/Balloons.zip">https://developer.apple.com/swift/blog/downloads/Balloons.zip</a>): The Balloons Playground was the keynote Playgrounds demonstration from <span class="strong"><em class="calibre10">WWDC14</em></span> and shows off many of the features Playgrounds have to offer, particularly to make and test games.</li></ul></div><p class="calibre8">Sometimes, the best way to learn a programming language is to test live code, and that's exactly what Playgrounds allow us to do.</p><p class="calibre8">In addition to testing snippets of code in our games, iOS 9 also allows us to plan and structure our games, which is the topic of the next chapter.</p></div></body></html>