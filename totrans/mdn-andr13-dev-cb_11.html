<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-303"><a id="_idTextAnchor619"/>11</h1>
<h1 id="_idParaDest-304"><a id="_idTextAnchor620"/>GUI Alerts – What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern Android Development</h1>
<p><strong class="bold">Graphic User Interface</strong> (<strong class="bold">GUI</strong>) alerts are essential to users because they provide critical information about a program or application’s status and can help users avoid errors and make informed decisions. Alerts can be triggered in various situations, such as when an error occurs, a program performs a critical operation, or when a user is about to perform an irreversible action.</p>
<p>One of the main benefits of GUI alerts is that they provide immediate feedback to users. For example, if a user enters incorrect information into a form, an alert can quickly inform them of the error, allowing them to correct it before proceeding. This can help to prevent mistakes and save time in the long run.</p>
<p>Another benefit of GUI alerts is that they can help to prevent accidental actions. For example, if a user is about to delete an important file, an alert can warn them of the potential consequences of this action, giving them a chance to reconsider before proceeding. This chapter will examine how a GUI is implemented in Modern Android Development.</p>
<p>In this chapter, we’ll cover the following recipes:</p>
<ul>
<li>Creating and displaying a menu in Modern Android Development</li>
<li>Implementing Toast/Snackbars to alert users</li>
<li>Creating an alert dialog</li>
<li>Creating a <code>BottomSheet</code> dialog</li>
<li>Creating a radio button</li>
<li>Creating <strong class="bold">Floating Action Buttons</strong> (<strong class="bold">FABs</strong>) and extended FABs</li>
</ul>
<h1 id="_idParaDest-305"><a id="_idTextAnchor621"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eleven</a>.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor622"/>Creating and displaying a menu in Modern Android Development</h1>
<p>Creating a<a id="_idIndexMarker693"/> menu<a id="_idIndexMarker694"/> in an Android app can provide several benefits:</p>
<ul>
<li>Menus can help users quickly access different features and functionalities within an app. A well-designed menu can improve the user experience by making it easy to navigate and use the app.</li>
<li>A consistent menu across different screens in an app can help users quickly find what they’re looking for, making the app feel more polished and professional.</li>
<li>A menu can be used to group related options and functions in one place, reducing the need for cluttered screens with many buttons and options.</li>
<li>Menus can also be customized to fit an app’s specific needs, including different types of menus, such as context menus, pop-up menus, and navigation drawers.</li>
<li>Menus should be designed with accessibility in mind, making it easier for users with disabilities to navigate the app.</li>
</ul>
<p>That is to say, creating a menu in an Android app can improve the user experience, provide consistency, save space, and increase accessibility.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor623"/>Getting ready</h2>
<p>For this chapter, we will create a new Material 3 project and call it <code>GUIAlerts</code>; this is where we will add all our UI components for this chapter, and you can take advantage of the project to modify the views to suit your needs.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor624"/>How to do it…</h2>
<p>Follow the following steps to build your first hamburger menu:</p>
<ol>
<li>Inside our newly created project, <code>GUIAlerts</code>, let’s create a package component, and inside the package, create a Kotlin file and call it <code>MenuComponent.kt</code>.</li>
<li>Let’s create a composable function, <code>OurMenu</code>, in our Kotlin file:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun OurMenu(){ }</pre></li>
<li>Now, let's go ahead and create our menu. For our purposes, we will just showcase some items, and when someone clicks, nothing will happen since we will not implement the <code>onClick</code> function. First, we need to ensure it does not start as <code>expanded</code>, which means users will click to expand the menu and it will change to <code>true</code><a id="_idIndexMarker695"/> in <a id="_idIndexMarker696"/>response:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun OurMenu(){</pre><pre class="source-code">
var expanded by remember { mutableStateOf(false) }</pre><pre class="source-code">
val menuItems = listOf("Item 1", "Item 2", "Item 3",</pre><pre class="source-code">
"Item 4") }</pre></li>
</ol>
<p>For our menu items, we will just showcase four items.</p>
<ol>
<li value="4">Next, we must create a <code>Box()</code>, align it to the center, and react to the <code>expanded</code> state in the modifier. We will also need to add an icon, <code>ArrowDropDown</code>, to inform users they can click and that we have more items:<pre class="source-code">
Box(</pre><pre class="source-code">
    contentAlignment = Alignment.Center,</pre><pre class="source-code">
    modifier = Modifier</pre><pre class="source-code">
        .clickable { expanded = true }</pre><pre class="source-code">
) {</pre><pre class="source-code">
    Text(stringResource(id = R.string.menu))</pre><pre class="source-code">
    Icon(</pre><pre class="source-code">
        imageVector = Icons.Default.ArrowDropDown,</pre><pre class="source-code">
        contentDescription = stringResource(</pre><pre class="source-code">
            id = R.string.menu_drop_down),</pre><pre class="source-code">
        modifier = Modifier.align(Alignment.CenterEnd)</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Finally, we will need to add <code>DropDownMenu</code>, which will expand when we click the icon, and we will set <code>onDismissRequest</code> to <code>false</code>; it is called when the user requests to dismiss the menu, for instance, when tapping.</li>
<li>Then, we will display <a id="_idIndexMarker697"/>our<a id="_idIndexMarker698"/> items on the <code>DropdownMenuItem</code> function so that when it is clicked, it performs an action. For our example, we don’t do anything:<pre class="source-code">
DropdownMenu(</pre><pre class="source-code">
    expanded = expanded,</pre><pre class="source-code">
    onDismissRequest = { expanded = false }</pre><pre class="source-code">
) {</pre><pre class="source-code">
    menuItems.forEachIndexed { index, item -&gt;</pre><pre class="source-code">
        DropdownMenuItem(text = { Text(item)},</pre><pre class="source-code">
            onClick = { /*TODO*/ })</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>Finally, when you run the app, you should see a menu dropdown with items you can click.</li>
</ol>
<div><div><img alt="Figure 11.1 – The drop-down menu" src="img/Figure_11.1_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The drop-down menu</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can customize the drop-down menu to fit your needs and style.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor625"/>How it works…</h2>
<p>In our example, we<a id="_idIndexMarker699"/> first<a id="_idIndexMarker700"/> declare a mutable state variable, <code>expanded</code>, to keep track of whether the menu is expanded or not and another mutable state variable, <code>selectedMenuItem</code>, to keep track of the currently selected menu<a id="_idTextAnchor626"/> item.</p>
<p>We also define a list of <code>menuItems</code> which helps us know the menu<a id="_idTextAnchor627"/> list.</p>
<p>Inside our <code>Box</code>, we define a <code>Column(){}</code>, which contains the menu title, a clickable <code>Box</code>, which displays the selected menu item, and a <code>DropdownMenu</code>, which displays the menu items when expanded. We use the <code>Box</code> and <code>DropdownMenu</code> components to position the menu items relative to the clickabl<a id="_idTextAnchor628"/>e <code>Box</code>.</p>
<p><code>DropDownMenu</code> takes in a couple of inputs, as you can see in <em class="italic">Figure 11</em><em class="italic">.2</em>, and this helps you customize your drop-down menu based on your n<a id="_idTextAnchor629"/>eeds.</p>
<div><div><img alt="Figure 11.2 – The DropDownMenuItem input param﻿eters" src="img/Figure_11.2_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The DropDownMenuItem input param<a id="_idTextAnchor630"/>eters</p>
<p>Finally, we use <a id="_idIndexMarker701"/>the <code>DropdownMenuItem</code> component <a id="_idIndexMarker702"/>to display each menu item and update the <code>selectedMenuItem</code> and <code>expanded</code> variables when a menu item is c<a id="_idTextAnchor631"/>licked.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor632"/>Implementing a Toast/Snackbar to alert users</h1>
<p>In Android<a id="_idIndexMarker703"/> development, a Toast/Snackbar is<a id="_idIndexMarker704"/> a small pop-up message that appears on the screen, usually at the bottom. It’s used to provide brief information or feedback to the user. It is a simple way to display short messages to the user without interrupting the user’s <a id="_idTextAnchor633"/>workflow.</p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor634"/>Getting ready</h2>
<p>In this section, we will react to the items we created in our <code>DropMenuItem</code>, so you must have followed the previous recipe to continue with this one.</p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor635"/>How to do it…</h2>
<p>Execute the following steps to add a message when the items are clicked to tell the users they’ve picked a particular item:</p>
<ol>
<li>Creating a Toast is very straightforward in Android; you can simply do that using the <code>Toast</code> class the Android SDK provides. You can create a new <code>Toast</code> object by calling the static <code>makeText()</code> method of the <code>Toast</code> class and passing it the context, message, and duration of the Toast.</li>
<li>Once you <a id="_idIndexMarker705"/>have<a id="_idIndexMarker706"/> created the <code>Toast</code> object, you can call the <code>show()</code> method to display it on the screen:<pre class="source-code">
Toast.makeText(context, "Hello, Android!", Toast.LENGTH_SHORT).show();</pre></li>
<li>In Jetpack Compose, however, to display a <code>Toast</code>, we will need to use <code>coroutineScope</code>, but note you do not need a coroutine to display a Toast in all instances, in our example however, we will use the <code>launch</code> function to launch a coroutine that displays the Toast message:<pre class="source-code">
val coroutineScope = rememberCoroutine()</pre><pre class="source-code">
coroutineScope.launch {</pre><pre class="source-code">
    Toast.makeText(</pre><pre class="source-code">
        context,</pre><pre class="source-code">
        "Selected item: $item",</pre><pre class="source-code">
        Toast.LENGTH_SHORT</pre><pre class="source-code">
    ).show()</pre><pre class="source-code">
}</pre></li>
<li>To hook up <code>onClick()</code>, please see the code in the <em class="italic">Technical requirements</em> section to get the entire code. Finally, when you run the app, you should see a <code>Toast</code> message with the item selected as the message.</li>
</ol>
<div><div><img alt="Figure 11.3 – The Toast message displayed" src="img/Figure_11.3_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The Toast message displayed</p>
<ol>
<li value="5">In the<a id="_idIndexMarker707"/> following<a id="_idIndexMarker708"/> example, we will use a Snackbar now instead of a Toast:<pre class="source-code">
coroutineScope.launch {</pre><pre class="source-code">
    Toast.makeText(</pre><pre class="source-code">
        context,</pre><pre class="source-code">
        "Selected item: $item",</pre><pre class="source-code">
        Toast.LENGTH_SHORT</pre><pre class="source-code">
    ).show()</pre><pre class="source-code">
}</pre></li>
</ol>
<p>There are different ways of using a Snackbar in Jetpack Compose; you can use it with a <code>Scaffold</code> or without it. However, it is recommended to use a Snackbar with a <code>Scaffold</code>. In <a id="_idIndexMarker709"/>our <a id="_idIndexMarker710"/>example, we will use a <code>Scaffold</code>:</p>
<pre class="source-code">
menuItems.forEachIndexed { index, item -&gt;
    DropdownMenuItem(
        text = { Text(item) },
        onClick = {
            coroutineScope.launch {
                snackbarHostState.showSnackbar(
                    message = "Selected Item: $item"
                )
            }
        }
    )
}</pre>
<ol>
<li value="6">Finally, when you run the app, you will see a Snackbar with the selected item text and item selected. Both <code>Toast</code> and <code>Snackbar</code> serve the same purpose.</li>
</ol>
<div><div><img alt="Figure 11.4 – The Snackbar message displayed" src="img/Figure_11.4_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – The Snackbar message displayed</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor636"/>How it works…</h2>
<p>Toasts and Snackbars are<a id="_idIndexMarker711"/> two<a id="_idIndexMarker712"/> types of notification messages that can be used in Android applications to display short messages to the user.</p>
<p>The main differences between Toasts and Snackbars are as follows:</p>
<ul>
<li>Toast messages are typically displayed in the center of the screen, while Snackbar messages are usually displayed at the bottom of the screen.</li>
<li>Toast messages typically last for a short period of time, usually around 2-3 seconds, and then disappear automatically. Snackbar messages are usually displayed for a more extended period of time and can be dismissed by the user by swiping them away or by tapping on a button.</li>
<li>Toast messages are not interactive and cannot be dismissed by the user. Snackbar messages, on the other hand, can contain action buttons that allow the user to take specific actions in response to the message.</li>
<li>Toast messages are typically plain text messages that appear in a small pop-up window. Snackbar messages, on the other hand, can be styled to include icons, colors, and other visual elements to make them more visually appealing and informative.</li>
</ul>
<p>We modify the <code>onClick</code> callback of the <code>DropdownMenuItem</code> component to launch a coroutine that displays the <code>Toast</code> message using the <code>Toast.makeText</code> function. We pass in the current context using <code>LocalContext.current</code>, which gets the current context function and the text to display in the <code>Toast</code> message as a string. You should also specify the duration of your <code>Toast</code>, either <code>Short</code> or <code>Long</code>.</p>
<p>When using <code>Snackbar</code>, we create a <code>SnackbarHostState</code>, which we pass in our <code>Scaffold</code>. Our composable includes a <code>snackbarHost</code> parameter specifying a function to display the Snackbar when shown. The <code>SnackbarHost</code> function takes two parameters: <code>snackbarData</code>, which contains the message and action button of the Snackbar, and a lambda <a id="_idIndexMarker713"/>that <a id="_idIndexMarker714"/>specifies how to create the <code>Snackbar</code> composable.</p>
<p>In Android, <code>Scaffold</code> is a pre-built UI component or layout that provides an essential structure for building screens and UI components. The term <strong class="bold">Scaffold</strong> is often used interchangeably with the term template or boilerplate.</p>
<p>Scaffolds are commonly used in Android app development frameworks such as Flutter or Jetpack Compose to provide a starting point for creating new screens or UI components.</p>
<p>For example, the Material Design library in Android provides several pre-built scaffolds for common screen types, such as a login screen, a settings screen, or a list screen. These scaffolds provide a consistent look and feel and help ensure the app follows the Material Design guidelines.</p>
<p>Using scaffolds can save time and effort in app development by providing a starting point for building <a id="_idIndexMarker715"/>screens <a id="_idIndexMarker716"/>and UI components. However, developers can also customize and extend scaffolds to meet the specific require<a id="_idTextAnchor637"/>ments of their app.</p>
<h1 id="_idParaDest-314"><a id="_idTextAnchor638"/>Creating an alert dialog</h1>
<p>Pop-up alert dialogs<a id="_idIndexMarker717"/> are an essential component of the UI in Android applications. They are used to display important messages, notifications, and warnings to the user. Some reasons why using a pop-up alert dialog is essential in Android are as follows:</p>
<ul>
<li>They can help highlight important information the user needs to know. For example, if the user is about to perform an action resulting in data loss or damage, the app can display a warning message in a pop-up alert dialog to ensure the user knows the consequences.</li>
<li>They can be used to obtain user confirmation for necessary actions, such as deleting a file or purchasing something. By displaying a message that asks the user to confirm the action, the app can help prevent accidental or unwanted actions.</li>
<li>They can be used to provide feedback to the user, such as letting them know that an action was successful or unsuccessful. For example, if the user tries to save a file that already exists, the app can display a pop-up alert dialog that informs the user of the issue and provides suggestions on how to proceed.</li>
<li>They can help improve the overall user experience of an app by providing precise and concise messages that help users understand what is happening within the app.</li>
</ul>
<p>Alert dialogs are an essential component of Android app design. They can be used to highlight important information, obtain user confirmation, provide feedback, and improve the overall user experience.</p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor639"/>Getting ready</h2>
<p>We will continue using the same project, so ensure you have completed previous recipes. To follow along, please also ensure you get the code in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor640"/>How to do it…</h2>
<p>Follow these steps to create an alert dialog:</p>
<ol>
<li>Let’s start by<a id="_idIndexMarker718"/> creating a Kotlin file and calling it <code>AlertDialogDemo.kt</code>.</li>
<li>Inside <code>AlertDialogDemo</code>, create a composable function and call it <code>AlertDialogExample()</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun AlertDialogExample() {...}</pre></li>
</ol>
<p>There are different ways to implement <code>AlertDialog()</code>; in our example, we will create a button that will be clicked to start <code>dialog()</code>.</p>
<ol>
<li value="3">Then, we must add the title and text properties to <code>AlertDialog</code>. We use the <code>Text</code> component to define the title and message text and set the <code>fontWeight</code> and <code>color</code> properties as needed:<pre class="source-code">
AlertDialog(</pre><pre class="source-code">
    onDismissRequest = { dialog.value = false },</pre><pre class="source-code">
    title = {</pre><pre class="source-code">
        Text(</pre><pre class="source-code">
            text = stringResource(</pre><pre class="source-code">
                id = R.string.title_message),</pre><pre class="source-code">
            fontWeight = FontWeight.Bold,</pre><pre class="source-code">
            color = Color.Black</pre><pre class="source-code">
        )</pre><pre class="source-code">
    },</pre><pre class="source-code">
    text = {</pre><pre class="source-code">
        Text(</pre><pre class="source-code">
            text = stringResource(id = R.string.body),</pre><pre class="source-code">
            color = Color.Gray</pre><pre class="source-code">
        )</pre><pre class="source-code">
    },</pre><pre class="source-code">
    . . .</pre></li>
<li>Then, we will add the <code>confirmButton</code> and <code>dismissButton</code> properties to <code>AlertDialog</code>. We use the <code>Button</code> component to define the buttons and set the <code>onClick</code> property <a id="_idIndexMarker719"/>to a lambda that will perform the appropriate action when the button is clicked:<pre class="source-code">
    confirmButton = {</pre><pre class="source-code">
        Button(</pre><pre class="source-code">
            onClick = {/*TODO*/ }</pre><pre class="source-code">
        ) {</pre><pre class="source-code">
            Text(text = stringResource(</pre><pre class="source-code">
                id = R.string.ok))</pre><pre class="source-code">
        }</pre><pre class="source-code">
    },</pre><pre class="source-code">
    dismissButton = {</pre><pre class="source-code">
        Button(</pre><pre class="source-code">
            onClick = { dialog.value = false }</pre><pre class="source-code">
        ) {</pre><pre class="source-code">
            Text(text = stringResource(</pre><pre class="source-code">
                id = R.string.cancel))</pre><pre class="source-code">
        }</pre><pre class="source-code">
    },</pre><pre class="source-code">
)</pre><pre class="source-code">
}</pre><pre class="source-code">
    . . .</pre></li>
<li>Finally, when you run the application, you will see a dialog with a title, message, and two calls <a id="_idIndexMarker720"/>to action, <strong class="bold">Confirm</strong> or <strong class="bold">Cancel</strong>.</li>
</ol>
<div><div><img alt="Figure 11.5 – The alert dialog" src="img/Figure_11.5_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – The alert dialog</p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor641"/>How it works…</h2>
<p>In our example, we first create a <code>mutableStateOf</code> variable called <code>openDialog</code> with a Boolean value indicating whether the dialog should be displayed. We then use this variable to render the <code>AlertDialog</code> component using an <code>if</code> st<a id="_idTextAnchor642"/>atement conditionally.</p>
<p>The <code>AlertDialog</code> component has several properties that we can set, including the title, text, <code>confirmButton</code>, and <code>dismissButton</code>. We can also set the background and content colors using the <code>backgroundColor</code> and <code>co<a id="_idTextAnchor643"/>ntentColor</code> properties.</p>
<p>Finally, we add <a id="_idIndexMarker721"/>a <code>Button</code> component that toggles the <code>openDialog</code> variable when clicked, causing the dialog to <a id="_idTextAnchor644"/>be displayed or hidden.</p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor645"/>Creating a bottom sheet dialog</h1>
<p>Bottom sheet<a id="_idIndexMarker722"/> dialogs are a popular design pattern in Android because they provide a simple and efficient way to display contextual information or actions without taking up too much space on the screen. When developing Android apps, here are some of the reasons why bottom sheet dialogs are considered a good choice:</p>
<ul>
<li>They are designed to slide up from the bottom of the screen, taking up minimal screen space. This makes them an excellent option for displaying supplementary information or actions without overwhelming the user.</li>
<li>They are often used to provide additional information relevant to the current context, such as options or settings specific to the current view.</li>
<li>Because bottom sheet dialogs are designed to slide up from the bottom of the screen, they give users a sense of control over the interaction. Users can easily dismiss the dialog by swiping it down or tapping outside of the dialog.</li>
</ul>
<p>Overall, bottom sheet dialogs are an excellent choice because they provide a space-saving, contextual, and user-friendly way to display additional information or actions to the user.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor646"/>Getting ready</h2>
<p>We will continue using the same project, so ensure you have completed previous recipes.</p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor647"/>How to do it…</h2>
<p>Using the same project, follow these steps to build your first <code>BottomSheet</code> dialog:</p>
<ol>
<li>Let’s start by creating a Kotlin file and calling it <code>BottomSheetDemo.kt</code>.</li>
<li>Inside <code>BottomSheetDemo</code>, create a composable function and call it <code>BottomSheetExample()</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun BottomSheetExample() {...}</pre></li>
<li>Since we are using Material 3, we will acknowledge that most of the APIs are still experimental, meaning <a id="_idIndexMarker723"/>a lot might change. Let’s create our state for our bottom sheet dialog:<pre class="source-code">
val bottomSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)</pre></li>
</ol>
<p>The <code>skipPartiallyExpanded</code> Boolean checks whether the partially expanded state should be skipped if the sheet is tall enough.</p>
<ol>
<li value="4">Now we need to go ahead and create our <code>ModalBottomSheet()</code>, which takes in several parameters; we will just use <code>onDismiss</code> and <code>sheetState</code>:<pre class="source-code">
ModalBottomSheet(</pre><pre class="source-code">
    onDismissRequest = { openBottomSheet = false },</pre><pre class="source-code">
    sheetState = bottomSheetState,</pre><pre class="source-code">
) {</pre><pre class="source-code">
    Column(Modifier.fillMaxWidth(),</pre><pre class="source-code">
        horizontalAlignment =</pre><pre class="source-code">
            Alignment.CenterHorizontally) {</pre><pre class="source-code">
        Button(</pre><pre class="source-code">
            onClick = {</pre><pre class="source-code">
                coroutineScope.launch {</pre><pre class="source-code">
                    bottomSheetState.hide() }</pre><pre class="source-code">
                       .invokeOnCompletion {</pre><pre class="source-code">
                       if (</pre><pre class="source-code">
                           !bottomSheetState.isVisible</pre><pre class="source-code">
                       ) {</pre><pre class="source-code">
                           openBottomSheet = false</pre><pre class="source-code">
                       }</pre><pre class="source-code">
                }</pre><pre class="source-code">
            }</pre><pre class="source-code">
        ) {</pre><pre class="source-code">
            Text(text = stringResource(</pre><pre class="source-code">
                id = R.string.content))</pre><pre class="source-code">
    }</pre><pre class="source-code">
. . .</pre></li>
<li>Following<a id="_idIndexMarker724"/> the <em class="italic">Technical requirements</em> section, now let’s go ahead and implement the two buttons and get the entire code.</li>
<li>Finally, run the app, and you will have implemented your bottom sheet dialog. Note you might want to add more logic based on your needs.</li>
</ol>
<div><div><img alt="Figure 11.6 – The ﻿bottom sheet dialog" src="img/Figure_11.6_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The bottom sheet dialog</p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor648"/>How it works…</h2>
<p>In our example, <code>ModalBottomSheet</code> is used as an alternative to inline menus or simple dialogs <a id="_idIndexMarker725"/>on mobile, especially when offering a long list of action items or when items require longe<a id="_idTextAnchor649"/>r descriptions and icons.</p>
<p>Like any other dialog in Android, modal bottom sheets appear before a<a id="_idTextAnchor650"/>pp content.</p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor651"/>There is more…</h2>
<p>Read more<a id="_idIndexMarker726"/> about bottom sheet dialogs and the available experimental<a id="_idIndexMarker727"/> features by going to the following link: <a href="https://m3.material.io/components/bottom-sheets/overview">https://m3.material.io/components/bottom-sheets/overview</a>.</p>
<h1 id="_idParaDest-323"><a id="_idTextAnchor652"/>Creating a radio button</h1>
<p>In Modern <a id="_idIndexMarker728"/>Android Development, <code>RadioButton</code> is used similarly to how it is used in traditional Android development. <code>RadioButton</code> allows users to select a single item from a list of mutually exclusive options, meaning only one option can be selected at a time.</p>
<p>In Jetpack Compose, <code>RadioButton</code> is part of the Material Design library and can be used by importing the <code>Androidx.compose.Material.RadioButton</code> package. To create a group of <code>RadioButton</code> instances, you would typically use the <code>RadioGroup</code> composable, which is also part of the Material Design library.</p>
<p>The <code>RadioGroup</code> composable takes a list of options as input, along with a selected option and a callback that is called when the selected option changes. The individual <code>RadioButton</code> instances can be created using the <code>RadioButton</code> composable and add<a id="_idTextAnchor653"/>ed as children of <code>RadioGroup</code>.</p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor654"/>Getting ready</h2>
<p>In this recipe, we will continue using the same project, so ensure you have completed previous recipes.</p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor655"/>How to do it…</h2>
<p>Using the same project, follow these steps to build your first <code>RadioButton</code>:</p>
<ol>
<li>Let’s start by creating a Kotlin file and calling it <code>RadioButtonDemo.kt</code>.</li>
<li>Inside <code>RadioButtonDemo</code>, create a composable function and call it <code>RadioButtonExample()</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun RadioButtonExample() {...}</pre></li>
<li>We will start creating a list of choices, and in our example, we can use fruit, then keep track of selected choices:<pre class="source-code">
val choices = listOf("Mangoes", "Avocado", "Oranges")</pre><pre class="source-code">
var selectedOption by remember {</pre><pre class="source-code">
    mutableStateOf(choices[0]) }</pre></li>
<li>Since we are using the <code>RadioButton</code> composable provided by Google, based on your needs, you<a id="_idIndexMarker729"/> can customize your <code>RadioButton</code> however you like:<pre class="source-code">
Row(</pre><pre class="source-code">
    Modifier.fillMaxWidth(),</pre><pre class="source-code">
    verticalAlignment = Alignment.CenterVertically</pre><pre class="source-code">
) {</pre><pre class="source-code">
    RadioButton(</pre><pre class="source-code">
        selected = selectedOption == option,</pre><pre class="source-code">
        onClick = { selectedOption = option }</pre><pre class="source-code">
    )</pre><pre class="source-code">
    Text(</pre><pre class="source-code">
        text = option,</pre><pre class="source-code">
        style = MaterialTheme.typography.body1,</pre><pre class="source-code">
        modifier = Modifier.padding(start = 6.dp)</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Finally, when we run the app, you should see something similar to <em class="italic">Figure 11</em><em class="italic">.7</em>.</li>
</ol>
<div><div><img alt="Figure 11.7 – T﻿he ﻿radio ﻿button" src="img/Figure_11.7_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – T<a id="_idTextAnchor656"/>he radio button</p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor657"/>How it works…</h2>
<p>In our example, we create a <code>RadioButtonExample()</code> composable that displays a group of <code>RadioButton</code> instances<a id="_idIndexMarker730"/> with the following choices– <a id="_idTextAnchor658"/><code>Mangoes</code>, <code>Avocado</code>, and <code>Oranges</code>.</p>
<p>The selected option is stored in a <code>selectedOption</code> variable using the <code>remember</code> composable to maintain the state across recomposition. Each <code>RadioButton</code> is wrapped in a <code>Row(){...}</code> that includes the choice text, and the selected property of the <code>RadioButton</code> is set based on whether the current option<a id="_idTextAnchor659"/> matches the selected option.</p>
<p>When the user<a id="_idIndexMarker731"/> clicks on <code>RadioButton</code>, the <code>selectedOption</code> variable is updated <a id="_idTextAnchor660"/>with the newly selected option.</p>
<h1 id="_idParaDest-327"><a id="_idTextAnchor661"/>Creating a FAB/extended FAB</h1>
<p>A <strong class="bold">FAB</strong> is a circular<a id="_idIndexMarker732"/> button that <a id="_idIndexMarker733"/>appears to <em class="italic">float</em> above the UI of an Android application. It is often used to represent a primary action in the app and is placed in a visible location for easy access.</p>
<p>An extended FAB is a variation of a FAB in Android that provides users with more options and functionality. The extended FAB is a rectangular button that can display text and an icon and expands into a menu <a id="_idTextAnchor662"/>of related actions when pressed.</p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor663"/>Getting ready</h2>
<p>In this recipe, we will continue using the same project, so ensure you<a id="_idTextAnchor664"/> have completed previous recipes.</p>
<h2 id="_idParaDest-329"><a id="_idTextAnchor665"/>How to do it…</h2>
<p>Using the same project, follow these steps to build a FAB and extended FAB:</p>
<ol>
<li>Let’s start by creating a Kotlin file and calling it <code>ActionComponentsDemo.kt</code>.</li>
<li>Inside <code>ActionComponentsDemo</code>, create a composable function and call it <code>ActionComponentsExample()</code>:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun RadioButtonExample() {...}</pre></li>
<li>Inside <code>ActionComponentsDemo</code>, create a composable function and call it <code>ActionComponentsExample()</code>.</li>
<li>We will start by creating a FAB. <code>FloatingActionButton</code> is a circular button that floats above the UI and is typically used to trigger the primary action in an app. You can use <code>FloatingActionButton</code> in Jetpack Compose to create a <code>FloatingActionButton</code> composable:<pre class="source-code">
FloatingActionButton(onClick = { /* do something */ }) {</pre><pre class="source-code">
    Icon(Icons.Default.Add, contentDescription =</pre><pre class="source-code">
        stringResource(id = R.string.add))</pre><pre class="source-code">
}</pre></li>
</ol>
<p><code>ExtendedFloatingActionButton</code> is a <code>FloatingActionButton</code> instance with additional text or iconography. It’s often used for secondary actions in an app.</p>
<ol>
<li value="5">To create <code>ExtendedFloatingActionButton</code> in Jetpack Compose, you can use the <code>ExtendedFloatingActionButton</code> composable. This code creates it with a text label of <code>"Add item"</code> and an plus icon. The <code>onClick</code> parameter<a id="_idIndexMarker734"/> specifies the action to perform when the button is<a id="_idIndexMarker735"/> clicked:<pre class="source-code">
ExtendedFloatingActionButton(</pre><pre class="source-code">
    text = { Text("Add item") },</pre><pre class="source-code">
    onClick = { /* do something */ },</pre><pre class="source-code">
    icon = {</pre><pre class="source-code">
        Icon(</pre><pre class="source-code">
            Icons.Default.Add,</pre><pre class="source-code">
            contentDescription = stringResource(</pre><pre class="source-code">
                id = R.string.add)</pre><pre class="source-code">
        )</pre><pre class="source-code">
    }</pre><pre class="source-code">
)</pre></li>
<li>When you run the app, you should see two buttons, a floating button and an extended button:</li>
</ol>
<div><div><img alt="Figu﻿re 11.8 – The FAB and extended FAB" src="img/Figure_11.8_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figu<a id="_idTextAnchor666"/>re 11.8 – The FAB and extended FAB</p>
<h2 id="_idParaDest-330"><a id="_idTextAnchor667"/>How it works…</h2>
<p>An extended FAB<a id="_idIndexMarker736"/> is<a id="_idIndexMarker737"/> similar to a FAB but provides additional space for text and/or an icon. It is typically used to provide more context or information about the action that will be performed when the button is tapped. For<a id="_idIndexMarker738"/> example, an <strong class="bold">Extended Floating Action Button </strong>(<strong class="bold">EFAB</strong>) might display the text <strong class="bold">Cre<a id="_idTextAnchor668"/>ate new budget</strong> along with a pen icon.</p>
<p>Both FABs and EFABs are part of the Material Design guidelines and are availab<a id="_idTextAnchor669"/>le as a compo<a id="_idTextAnchor670"/>nent in Jetpack Compose.</p>
<h2 id="_idParaDest-331"><a id="_idTextAnchor671"/>There more …</h2>
<p>To learn more about<a id="_idIndexMarker739"/> Material 3 Components and guidelines, see the following links: <a href="https://m3.Material.io/">https://m3.Material.io/</a> and <a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary">https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary</a>.</p>
</div>
</body></html>