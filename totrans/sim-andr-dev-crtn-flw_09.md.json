["```kt\ndependencies {\n```", "```kt\n    …\n```", "```kt\n    testImplementation 'junit:junit:4.13.2'\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    …\n```", "```kt\n    testImplementation 'org.mockito:mockito-core:4.0.0'\n```", "```kt\n    testImplementation 'org.mockito.kotlin:mockito-\n```", "```kt\n      kotlin:4.0.0'\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    …\n```", "```kt\n    testImplementation 'org.mockito.kotlin:mockito-\n```", "```kt\n      kotlin:4.0.0'\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    …\n```", "```kt\n    testImplementation 'org.jetbrains.kotlinx:kotlinx-\n```", "```kt\n      coroutines-test:1.6.0'\n```", "```kt\n}\n```", "```kt\nclass MovieViewModel(private val movieRepository:\n```", "```kt\n  MovieRepository) {\n```", "```kt\n    ...\n```", "```kt\n    suspend fun fetchMovies() {\n```", "```kt\n        movieRepository.fetchMovies().collect {\n```", "```kt\n            _movies.value = it\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        val list = listOf(movie1, movie2)\n```", "```kt\n        val expected = MutableLiveData<List<Movie>>()\n```", "```kt\n        expectedMovies.value = list\n```", "```kt\n        val movieRepository: MovieRepository = mock {\n```", "```kt\n            onBlocking { fetchMoviesFlow() } doReturn\n```", "```kt\n              flowOf(movies)\n```", "```kt\n        }\n```", "```kt\n        val dispatcher = StandardTestDispatcher()\n```", "```kt\n        val movieViewModel =\n```", "```kt\n          MovieViewModel(movieRepository, dispatcher)\n```", "```kt\n        runTest {\n```", "```kt\n            movieViewModel.fetchMovies()\n```", "```kt\n            dispatcher.scheduler.advanceUntilIdle()\n```", "```kt\n            assertEquals(expectedMovies.value,\n```", "```kt\n              movieViewModel.movies.value)\n```", "```kt\n            ...\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModel(private val movieRepository:\n```", "```kt\n  MovieRepository) {\n```", "```kt\n    ...\n```", "```kt\n    fun fetchFavoriteMovies(): Flow<List<Movie>> {\n```", "```kt\n        ...\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchFavoriteMovies() {\n```", "```kt\n        ...\n```", "```kt\n        val expectedList = listOf(movie1, movie2)\n```", "```kt\n        val movieRepository: MovieRepository = mock {\n```", "```kt\n            onBlocking { fetchFavoriteMovies() } doReturn\n```", "```kt\n              flowOf(expectedList)\n```", "```kt\n        }\n```", "```kt\n        val movieViewModel =\n```", "```kt\n          MovieViewModel(movieRepository)\n```", "```kt\n        runTest {\n```", "```kt\n            ...\n```", "```kt\n            assertEquals(expectedList,\n```", "```kt\n             movieViewModel.fetchFavoriteMovies().toList())\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieRepositoryTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMoviesFlowWithError() {\n```", "```kt\n        val movieService: MovieService = mock {\n```", "```kt\n            onBlocking { getMovies(anyString()) } doThrow\n```", "```kt\n              IOException(exception)\n```", "```kt\n        }\n```", "```kt\n        val movieRepository = MovieRepository(movieService)\n```", "```kt\n        runTest {\n```", "```kt\n            movieRepository.fetchMoviesFlow().catch {\n```", "```kt\n                assertEquals(exception, it.message)\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest { \n```", "```kt\n    ... \n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMoviesWithError() { \n```", "```kt\n        ...\n```", "```kt\n        val movies = listOf(Movie(title = \"Movie\"))\n```", "```kt\n        val exception = \"Exception\"\n```", "```kt\n        val hasRetried = false\n```", "```kt\n        val movieRepository: MovieRepository = mock { \n```", "```kt\n            onBlocking { fetchMoviesFlow() } doAnswer {\n```", "```kt\n                flow {\n```", "```kt\n                    if (hasRetried) emit(movies) else throw\n```", "```kt\n                      IOException (exception)\n```", "```kt\n                }\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n        ...\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    …\n```", "```kt\n    testImplementation 'app.cash.turbine:turbine:0.8.0'\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        val expectedList = listOf(movie1, movie2)\n```", "```kt\n        val movieRepository: MovieRepository = mock {\n```", "```kt\n            onBlocking { fetchMovies() } doReturn\n```", "```kt\n              flowOf(expectedList)\n```", "```kt\n        }\n```", "```kt\n        val movieViewModel =\n```", "```kt\n          MovieViewModel(movieRepository)\n```", "```kt\n        runTest {\n```", "```kt\n            movieViewModel.fetchMovies().test {\n```", "```kt\n               assertEquals(movie1, awaitItem())\n```", "```kt\n               assertEquals(movie2, awaitItem())\n```", "```kt\n               awaitComplete()\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMoviesError() {\n```", "```kt\n        ...\n```", "```kt\n        val exception = \"Test Exception\"\n```", "```kt\n        val movieRepository: MovieRepository = mock {\n```", "```kt\n            onBlocking { fetchMovies() } doAnswer\n```", "```kt\n                flow {\n```", "```kt\n                    throw RuntimeException(exception)\n```", "```kt\n                }\n```", "```kt\n            }\n```", "```kt\n        }//mock\n```", "```kt\n        val movieViewModel =\n```", "```kt\n          MovieViewModel(movieRepository)\n```", "```kt\n        runTest {\n```", "```kt\n            movieViewModel.fetchMovies().test {\n```", "```kt\n                assertEquals(exception,\n```", "```kt\n                  awaitError().message)\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        val expectedList = listOf(movie1, movie2)\n```", "```kt\n        val movieRepository: MovieRepository = mock {\n```", "```kt\n            onBlocking { fetchMovies() } doReturn\n```", "```kt\n              flowOf(expectedList)\n```", "```kt\n        }\n```", "```kt\n        val movieViewModel =\n```", "```kt\n          MovieViewModel(movieRepository)\n```", "```kt\n        runTest {\n```", "```kt\n            movieViewModel.fetchMovies().test {\n```", "```kt\n               assertEquals(movie1, awaitItem())\n```", "```kt\n               cancelAndIgnoreRemainingEvents()\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\n    @Test\n    fun fetchMovies() {\n        val dispatcher = StandardTestDispatcher()\n\n        val movies = listOf(Movie(title = \"Movie\"))\n        val expectedMovies =\n          MutableLiveData<List<Movie>>()\n        expectedMovies.postValue(movies)\n\n        val movieRepository: MovieRepository = mock {\n            onBlocking { fetchMoviesFlow() } doReturn\n              flowOf(movies)\n        }\n\n        val movieViewModel =\n          MovieViewModel(movieRepository, dispatcher)\n    }\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        ...\n\n        runTest {\n            movieViewModel.fetchMovies()\n            dispatcher.scheduler.advanceUntilIdle()\n            assertEquals(expectedMovies.value,\n              movieViewModel.movies.value)\n        }\n    }\n    ```", "```kt\n    assertTrue(movieViewModel.loading.value)\n    dispatcher.scheduler.advanceUntilIdle()\n    assertFalse(movieViewModel.loading.value)\n    ```", "```kt\n    @Test\n    fun fetchMoviesFlow() {\n        val movies = listOf(Movie(id = 3), Movie(id = 4))\n        val response = MoviesResponse(1, movies)\n\n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doReturn\n              response\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n\n        runTest {\n            movieRepository.fetchMoviesFlow().collect {\n                assertEquals(movies, it)\n            }\n        }\n    }\n    ```", "```kt\n    @Test\n    fun fetchMoviesFlowWithError() {\n        val exception = \"Test Exception\"\n\n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doThrow\n              RuntimeException(exception)\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n\n        runTest {\n            movieRepository.fetchMoviesFlow().catch {\n                assertEquals(exception, it.message)\n            }\n        }\n    }\n    ```", "```kt\n    testImplementation 'app.cash.turbine:turbine:0.8.0'\n    ```", "```kt\n    @Test\n    fun fetchMoviesFlowTurbine() {\n        val movies = listOf(Movie(id = 3), Movie(id = 4))\n        val response = MoviesResponse(1, movies)\n\n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doReturn\n              response\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n\n        runTest {\n            movieRepository.fetchMoviesFlow().test {\n                assertEquals(movies, awaitItem())\n                awaitComplete()\n            }\n        }\n    }\n    ```", "```kt\n    @Test\n    fun fetchMoviesFlowWithErrorTurbine() {\n        val exception = \"Test Exception\"\n\n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doThrow\n              RuntimeException(exception)\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n\n        runTest {\n            movieRepository.fetchMoviesFlow().test {\n                assertEquals(exception,\n                  awaitError().message)\n            }\n        }\n    }\n    ```"]