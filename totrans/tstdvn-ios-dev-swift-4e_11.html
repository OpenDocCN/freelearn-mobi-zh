<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor317"/>Chapter 8</em>: Building a Simple Detail View</h1>
			<p>Often in iOS development, table views or collection views just give a brief summary of the presented items. To figure out all the details of the shown items, the user has to select an item so that they can be redirected to the details. In the details view, the user can often interact with the shown item.</p>
			<p>For example, in a mail app, the summary only shows the sender, the subject, and the first few lines of the mail. To read the complete mail and to answer it, the user has to open it in the details view.</p>
			<p>In this chapter, we will build the details view for our to-do items. The chapter is structured as follows:</p>
			<ul>
				<li>Adding labels, a button, and a map</li>
				<li>Filling in the data</li>
				<li>Checking the to-do item</li>
			</ul>
			<p>We start by adding the user interface elements to the view.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>The source code for this chapter is available here: </p>
			<p><a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter08">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter08</a></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor319"/>Adding labels, a button, and a map</h1>
			<p>We have done<a id="_idIndexMarker264"/> this so often<a id="_idIndexMarker265"/> already that<a id="_idIndexMarker266"/> you might guess<a id="_idIndexMarker267"/> what we have<a id="_idIndexMarker268"/> to do first. That's right, we<a id="_idIndexMarker269"/> need a test case class for our tests. Select the <strong class="bold">ToDoTests</strong> group in the project navigator in Xcode and add a new <strong class="bold">Unit Test Case Class</strong> called <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>. Make sure that it is added to the unit test target:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_8.01_B16497.jpg" alt="Figure 8.1 – The test case needs to be added to the unit test target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The test case needs to be added to the unit test target</p>
			<p>Remove<a id="_idIndexMarker270"/> the two template<a id="_idIndexMarker271"/> tests in the created<a id="_idIndexMarker272"/> test case class<a id="_idIndexMarker273"/> and add <strong class="source-inline">@testable import ToDo</strong> below<a id="_idIndexMarker274"/> the existing import<a id="_idIndexMarker275"/> statement:</p>
			<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p>
			<p class="source-code">import XCTest</p>
			<p class="source-code">@testable import ToDo </p>
			<p class="source-code">class ToDoItemDetailsViewControllerTests: XCTestCase { </p>
			<p class="source-code">  override func setUpWithError() throws {</p>
			<p class="source-code">  } </p>
			<p class="source-code">  override func tearDownWithError() throws {</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The details view needs some labels to show the information of the to-do item. Let's start with the label<a id="_idIndexMarker276"/> for the title. Follow<a id="_idIndexMarker277"/> these steps:</p>
			<ol>
				<li>Add the<a id="_idIndexMarker278"/> following<a id="_idIndexMarker279"/> property for the<a id="_idIndexMarker280"/> system under<a id="_idIndexMarker281"/> test:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">var sut: ToDoItemDetailsViewController!</p></li>
			</ol>
			<p>Xcode complains that it <strong class="bold">Cannot find type 'ToDoItemDetailsViewController' in scope</strong>.</p>
			<ol>
				<li value="2">Select the <strong class="bold">ToDo</strong> group in the project navigator and add a new Cocoa Touch<strong class="bold"> Class</strong> with the name <strong class="source-inline">ToDoItemDetailsViewController</strong>. Make it a subclass of <strong class="bold">UIViewController</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_8.02_B16497.jpg" alt="Figure 8.2 – Options for the view controller class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Options for the view controller class</p>
			<ol>
				<li value="3">Remove the template code inside the created class. Go back to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>. Xcode should remove the error after a few seconds. If it doesn't, select the <strong class="bold">Product</strong> | <strong class="bold">Build</strong> menu item to compile the project.</li>
				<li>Now we have<a id="_idIndexMarker282"/> two choices. One, we could build the user<a id="_idIndexMarker283"/> interface in code as we did for the table view cells<a id="_idIndexMarker284"/> in the previous chapter. Two, we could use<a id="_idIndexMarker285"/> a storyboard<a id="_idIndexMarker286"/> for the user interface. To give<a id="_idIndexMarker287"/> you a broader picture in this book, we will use the storyboard for the user interface in this chapter.</li>
			</ol>
			<p>Replace the <strong class="source-inline">setUpWithError()</strong> and the <strong class="source-inline">tearDownWithError()</strong> methods with the following implementation:</p>
			<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p>
			<p class="source-code">override func setUpWithError() throws {</p>
			<p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle:</p>
			<p class="source-code">    nil)</p>
			<p class="source-code">  sut = (storyboard.instantiateViewController(</p>
			<p class="source-code">    withIdentifier: "ToDoItemDetailsViewController")</p>
			<p class="source-code">    as! ToDoItemDetailsViewController)</p>
			<p class="source-code">  sut.loadViewIfNeeded()</p>
			<p class="source-code">}</p>
			<p class="source-code">override func tearDownWithError() throws {</p>
			<p class="source-code">  sut = nil</p>
			<p class="source-code">}</p>
			<p>The parentheses around <strong class="source-inline">(storyboard.instantiateViewController(withIdentifier: "ToDoItemDetailsViewController") as! ToDoItemDetailsViewController)</strong> are needed to silence a warning produced by Xcode. Try and see what Xcode tells you do when you omit them.</p>
			<ol>
				<li value="5">With the setup<a id="_idIndexMarker288"/> and the teardown<a id="_idIndexMarker289"/> methods in<a id="_idIndexMarker290"/> place, we can<a id="_idIndexMarker291"/> write the first test<a id="_idIndexMarker292"/> of that test case<a id="_idIndexMarker293"/> class:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_view_shouldHaveTitleLabel() throws {</p><p class="source-code">  let subview = try XCTUnwrap(sut.titleLabel)</p><p class="source-code">}</p></li>
			</ol>
			<p>This test is not finished yet but we have to pause here because the <strong class="source-inline">titleLabel</strong> property is missing.</p>
			<ol>
				<li value="6">Add the property to <strong class="source-inline">ToDoItemDetailsViewController</strong>:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">class ToDoItemDetailsViewController: UIViewController { </p><p class="source-code">  @IBOutlet var titleLabel: UILabel!</p><p class="source-code">}</p></li>
				<li>Now we can finish the test method:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_view_shouldHaveTitleLabel() throws {</p><p class="source-code">  let subview = try XCTUnwrap(sut.titleLabel)</p><p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p><p class="source-code">}</p></li>
				<li>Run all tests to confirm that this new test fails. This test fails in <strong class="source-inline">setUpWithError()</strong>. Click the red diamond in the failure message to see what the problem is:</li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_8.03_B16497.jpg" alt="Figure 8.3 – The storyboard doesn't have a view controller with the identifier 'ToDoItemDetailsViewController'&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The storyboard doesn't have a view controller with the identifier 'ToDoItemDetailsViewController'</p>
			<p>Looking at the problem<a id="_idIndexMarker294"/> shown in <em class="italic">Figure 8.3</em>, we need<a id="_idIndexMarker295"/> to add a new<a id="_idIndexMarker296"/> scene for that view <a id="_idIndexMarker297"/>controller<a id="_idIndexMarker298"/> to the<a id="_idIndexMarker299"/> storyboard.</p>
			<ol>
				<li value="9">Open the <strong class="source-inline">Main.storyboard</strong> file in the Interface Builder in Xcode and click the plus (<strong class="bold">+</strong>) button in the toolbar:</li>
			</ol>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_8.04_B16497.jpg" alt="Figure 8.4 – Open the library&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Open the library</p>
			<ol>
				<li value="10">Search for <strong class="source-inline">view controller</strong> and<a id="_idIndexMarker300"/> drag a <strong class="bold">View Controller</strong> object<a id="_idIndexMarker301"/> onto the<a id="_idIndexMarker302"/> storyboard. Open<a id="_idIndexMarker303"/> the <strong class="bold">Identity</strong> inspector<a id="_idIndexMarker304"/> by selecting the <strong class="bold">View</strong> | <strong class="bold">Inspectors</strong> | <strong class="bold">Identity</strong> menu<a id="_idIndexMarker305"/> item. Change <strong class="bold">Class</strong> and <strong class="bold">Storyboard ID</strong> to <strong class="bold">ToDoItemDetailsViewController</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_8.05_B16497.jpg" alt="Figure 8.5 – Changing the class and the storyboard ID of the scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Changing the class and the storyboard ID of the scene</p>
			<p>Run the tests<a id="_idIndexMarker306"/> again. The new<a id="_idIndexMarker307"/> test<a id="_idIndexMarker308"/> still fails<a id="_idIndexMarker309"/> because<a id="_idIndexMarker310"/> the <strong class="source-inline">titleLabel</strong> property<a id="_idIndexMarker311"/> is <strong class="source-inline">nil</strong>.</p>
			<ol>
				<li value="11">We need to add a label to the storyboard scene and connect it with <strong class="source-inline">IBOutlet</strong>. Open the library by selecting the <strong class="bold">View</strong> | <strong class="bold">Show Library</strong> menu item. Drag a <strong class="bold">Label</strong> object onto the storyboard scene of <strong class="source-inline">ToDoItemDetailsViewController</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_8.06_B16497.jpg" alt="Figure 8.6 – The added label on the To Do Item Details View Controller scene&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – The added label on the To Do Item Details View Controller scene</p>
			<ol>
				<li value="12">Open the <strong class="bold">Assistant</strong> editor<a id="_idIndexMarker312"/> by selecting<a id="_idIndexMarker313"/> the <strong class="bold">Editor</strong> | <strong class="bold">Assistant </strong>menu item. Xcode automatically<a id="_idIndexMarker314"/> opens <strong class="source-inline">ToDoItemsDetailsViewController</strong> in the <strong class="bold">Assistant</strong> editor. If it<a id="_idIndexMarker315"/> opens another<a id="_idIndexMarker316"/> file, close Xcode and<a id="_idIndexMarker317"/> restart it.</li>
			</ol>
			<p>Hold down the <em class="italic">Ctrl</em> key and drag a connection from the label in the storyboard to the <strong class="source-inline">IBOutlet</strong> property in the code:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_8.07_B16497.jpg" alt="Figure 8.7 – Connect the label in the scene with the IBOutlet property&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Connect the label in the scene with the IBOutlet property</p>
			<p>Run the tests again. All tests pass.</p>
			<p>As we have hardly written any code, there is nothing to refactor.</p>
			<p>In the same way, you can add<a id="_idIndexMarker318"/> the labels for the date, the location, and the description<a id="_idIndexMarker319"/> of the to-do item. We won't show<a id="_idIndexMarker320"/> this here because it works exactly the same as adding the label<a id="_idIndexMarker321"/> for the title. Follow the steps again<a id="_idIndexMarker322"/> with a different<a id="_idIndexMarker323"/> name for the property. To get you started, here are the three tests for these three new labels:</p>
			<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p>
			<p class="source-code">func test_view_shouldHaveDateLabel() throws {</p>
			<p class="source-code">  let subview = try XCTUnwrap(sut.dateLabel)</p>
			<p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p>
			<p class="source-code">}</p>
			<p class="source-code">func test_view_shouldHaveLocationLabel() throws {</p>
			<p class="source-code">  let subview = try XCTUnwrap(sut.locationLabel)</p>
			<p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p>
			<p class="source-code">}</p>
			<p class="source-code">func test_view_shouldHaveDescriptionLabel() throws {</p>
			<p class="source-code">  let subview = try XCTUnwrap(sut.descriptionLabel)</p>
			<p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p>
			<p class="source-code">}</p>
			<p>Add these tests one by one and make them pass. But make sure to only have one failing test at any time.</p>
			<p>Next, we need a map view to show the location of the to-do item if the location is set. Follow these steps to add it to the view:</p>
			<ol>
				<li value="1">Add the following test to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_view_shouldHaveMapView() throws {</p><p class="source-code">  let subview = try XCTUnwrap(sut.mapView)</p><p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the test to confirm that this new test fails.</p>
			<ol>
				<li value="2">Add<a id="_idIndexMarker324"/> the <strong class="source-inline">MapKit</strong> import<a id="_idIndexMarker325"/> to <strong class="source-inline">ToDoItemDetailsViewController</strong> and<a id="_idIndexMarker326"/> add an outlet<a id="_idIndexMarker327"/> for the <strong class="source-inline">mapView</strong> view:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">import UIKit</p><p class="source-code">import MapKit</p><p class="source-code"> </p><p class="source-code">class ToDoItemDetailsViewController: UIViewController {</p><p class="source-code">  @IBOutlet var titleLabel: UILabel!</p><p class="source-code">  @IBOutlet var dateLabel: UILabel!</p><p class="source-code">  @IBOutlet var locationLabel: UILabel!</p><p class="source-code">  @IBOutlet var descriptionLabel: UILabel!</p><p class="source-code">  @IBOutlet var mapView: MKMapView!</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the test<a id="_idIndexMarker328"/> again. It still fails, but<a id="_idIndexMarker329"/> this time because the <strong class="source-inline">mapView</strong> property is <strong class="source-inline">nil</strong>.</p>
			<ol>
				<li value="3">Open <strong class="source-inline">Main.storyboard</strong> and drag a <strong class="bold">Map Kit View</strong> onto the <strong class="bold">To Do Item Details View Controller</strong> scene. Next, open the Assistant editor and hold down the <em class="italic">Ctrl</em> key while you drag a connection to the <strong class="source-inline">IBOutlet</strong> property of the map view.</li>
			</ol>
			<p>Run the tests to confirm that all tests now pass.</p>
			<p>The last UI element we<a id="_idIndexMarker330"/> have to add to the<a id="_idIndexMarker331"/> view is the button to mark an item as <strong class="bold">Done</strong>. This works the same<a id="_idIndexMarker332"/> way as adding the labels previously. So again, this is left<a id="_idIndexMarker333"/> as an exercise for you. Here<a id="_idIndexMarker334"/> is the test<a id="_idIndexMarker335"/> to get you started:</p>
			<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p>
			<p class="source-code">func test_view_shouldHaveDoneButton() throws {</p>
			<p class="source-code">  let subview = try XCTUnwrap(sut.doneButton)</p>
			<p class="source-code">  XCTAssertTrue(subview.isDescendant(of: sut.view))</p>
			<p class="source-code">}</p>
			<p>Make this test pass by adding a <strong class="source-inline">UIButton</strong> instance to the view controller.</p>
			<p>Before we move on, you should take some time to make this user interface better. Move the elements and add layout constraints so that the user interface is more pleasing to the eye. When you've finished, your result could look similar to the following figure:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_8.08_B16497.jpg" alt="Figure 8.8 – The user interface for the details view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – The user interface for the details view</p>
			<p>Now that we have<a id="_idIndexMarker336"/> the user interface<a id="_idIndexMarker337"/> for the details view, we can present the data of the to-do item when<a id="_idIndexMarker338"/> the details are pushed<a id="_idIndexMarker339"/> onto the screen. This<a id="_idIndexMarker340"/> is what we will implement<a id="_idIndexMarker341"/> in the following section.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor320"/>Filling in the data</h1>
			<p>Follow these steps<a id="_idIndexMarker342"/> to update the user interface<a id="_idIndexMarker343"/> with the data from the to-do item:</p>
			<ol>
				<li value="1">We start with a new test. Add the following test method to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// TodoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_settingToDoItem_shouldUpdateTitleLabel() {</p><p class="source-code">  let title = "dummy title"</p><p class="source-code">  let toDoItem = ToDoItem(title: title)</p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code">}</p></li>
			</ol>
			<p>At this point, we get an error from Xcode that <strong class="bold">Value of type 'ToDoItemDetailsViewController' has no member 'toDoItem'</strong>.</p>
			<ol>
				<li value="2">Go to <strong class="source-inline">ToDoItemDetailsViewController</strong> and add the <strong class="source-inline">toDoItem</strong> property:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">class ToDoItemDetailsViewController: UIViewController {</p><p class="source-code">  @IBOutlet var titleLabel: UILabel!</p><p class="source-code">  @IBOutlet var dateLabel: UILabel!</p><p class="source-code">  @IBOutlet var locationLabel: UILabel!</p><p class="source-code">  @IBOutlet var descriptionLabel: UILabel!</p><p class="source-code">  @IBOutlet var mapView: MKMapView!</p><p class="source-code">  @IBOutlet var doneButton: UIButton!</p><p class="source-code">  var toDoItem: ToDoItem?</p><p class="source-code">}</p></li>
				<li>Now we can finish writing<a id="_idIndexMarker344"/> the test by adding<a id="_idIndexMarker345"/> the <strong class="source-inline">Assert</strong> call:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_settingToDoItem_shouldUpdateTitleLabel() {</p><p class="source-code">  let title = "dummy title"</p><p class="source-code">  let toDoItem = ToDoItem(title: title) </p><p class="source-code">  sut.toDoItem = toDoItem  </p><p class="source-code">  XCTAssertEqual(sut.titleLabel.text, title)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="4">Go back to the implementation code and replace the property declaration with the following:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">var toDoItem: ToDoItem? {</p><p class="source-code">  didSet {</p><p class="source-code">    titleLabel.text = toDoItem?.title</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests again to confirm that all tests now pass.</p>
			<p>The tests and the implementation for the other labels work in a similar way, and are left for you to do as an exercise. To get you started, here are the tests:</p>
			<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p>
			<p class="source-code">func test_settingToDoItem_shouldUpdateDateLabel() {</p>
			<p class="source-code">  let date = Date()</p>
			<p class="source-code">  let toDoItem = ToDoItem(</p>
			<p class="source-code">    title: "dummy title",</p>
			<p class="source-code">    timestamp: date.timeIntervalSince1970)</p>
			<p class="source-code"> </p>
			<p class="source-code">  sut.toDoItem = toDoItem</p>
			<p class="source-code"> </p>
			<p class="source-code">  XCTAssertEqual(sut.dateLabel.text,</p>
			<p class="source-code">                 sut.dateFormatter.string(from: date))</p>
			<p class="source-code">}</p>
			<p class="source-code">func test_settingToDoItem_shouldUpdateDescriptionLabel() {</p>
			<p class="source-code">  let description = "dummy discription"</p>
			<p class="source-code">  let toDoItem = ToDoItem(</p>
			<p class="source-code">    title: "dummy title",</p>
			<p class="source-code">    itemDescription: description)</p>
			<p class="source-code"> </p>
			<p class="source-code">  sut.toDoItem = toDoItem</p>
			<p class="source-code"> </p>
			<p class="source-code">  XCTAssertEqual(sut.descriptionLabel.text, description)</p>
			<p class="source-code">}</p>
			<p class="source-code">func test_settingToDoItem_shouldUpdateLocationLabel() {</p>
			<p class="source-code">  let location = "dummy location"</p>
			<p class="source-code">  let toDoItem = ToDoItem(</p>
			<p class="source-code">    title: "dummy title",</p>
			<p class="source-code">    location: Location(name: location))</p>
			<p class="source-code"> </p>
			<p class="source-code">  sut.toDoItem = toDoItem</p>
			<p class="source-code"> </p>
			<p class="source-code">  XCTAssertEqual(sut.locationLabel.text, location)</p>
			<p class="source-code">}</p>
			<p>Make these tests pass one by one. Make sure that you never have more than one failing test.</p>
			<p>The map view should<a id="_idIndexMarker346"/> show a map of the location<a id="_idIndexMarker347"/> of the to-do item when the to-do item contains a location with a coordinate. Follow these steps to add that feature:</p>
			<ol>
				<li value="1">Add the following test to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_settingToDoItem_shouldUpdateMapView() {</p><p class="source-code">  let latitude = 51.225556</p><p class="source-code">  let longitude = 6.782778</p><p class="source-code">  let toDoItem = ToDoItem(</p><p class="source-code">    title: "dummy title",</p><p class="source-code">    location: Location(</p><p class="source-code">      name: "dummy location",</p><p class="source-code">      coordinate: Coordinate(latitude: latitude,</p><p class="source-code">        longitude: longitude)))</p><p class="source-code"> </p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code"> </p><p class="source-code">  let center = sut.mapView.centerCoordinate</p><p class="source-code">  XCTAssertEqual(center.latitude,</p><p class="source-code">    latitude,</p><p class="source-code">    accuracy: 0.000_01)</p><p class="source-code">  XCTAssertEqual(center.longitude,</p><p class="source-code">    longitude,</p><p class="source-code">    accuracy: 0.000_01)</p><p class="source-code">}</p></li>
			</ol>
			<p>With this test, we test if the center coordinate of the map view is set to the coordinate of the location of the to-do item.</p>
			<p>Run all tests<a id="_idIndexMarker348"/> to confirm<a id="_idIndexMarker349"/> that this new test fails.</p>
			<ol>
				<li value="2">To make this test pass, add the following code to the <strong class="source-inline">didSet</strong> handler of the <strong class="source-inline">toDoItem</strong> property in <strong class="source-inline">ToDoItemDetailsViewController</strong>:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">if let coordinate = toDoItem?.location?.coordinate {</p><p class="source-code">  mapView.setCenter(</p><p class="source-code">    CLLocationCoordinate2D(</p><p class="source-code">      latitude: coordinate.latitude,</p><p class="source-code">      longitude: coordinate.longitude),</p><p class="source-code">    animated: false)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests again to confirm that all tests now pass.</p>
			<p>When the presented to-do item is already done, the <strong class="bold">Done</strong> button should be disabled. Follow these steps to implement this feature:</p>
			<ol>
				<li value="1">Add the following test to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_settingToDoItem_shouldUpdateButtonState() {</p><p class="source-code">  var toDoItem = ToDoItem(title: "dummy title")</p><p class="source-code">  toDoItem.done = true</p><p class="source-code"> </p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code"> </p><p class="source-code">  XCTAssertFalse(sut.doneButton.isEnabled)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="2">To make this new test<a id="_idIndexMarker350"/> pass, add the following code<a id="_idIndexMarker351"/> to the <strong class="source-inline">didSet</strong> handler of the <strong class="source-inline">toDoItem</strong> property:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">doneButton.isEnabled = false</p></li>
			</ol>
			<p>This code makes the test pass. Try it by running all tests. But this line of code is clearly wrong because it disables the <strong class="bold">Done</strong> button for all to-do items, even for those that are not done yet. To fix this bug, we need another test.</p>
			<ol>
				<li value="3">Add the following test to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_settingToDoItem_whenItemNotDone_</p><p class="source-code"> shouldUpdateButtonState() {</p><p class="source-code">  let toDoItem = ToDoItem(title: "dummy title")</p><p class="source-code"> </p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code"> </p><p class="source-code">  XCTAssertTrue(sut.doneButton.isEnabled)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests. This new test fails.</p>
			<ol>
				<li value="4">To make it pass, replace the <strong class="source-inline">doneButton.isEnabled = false</strong> line with the following code:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">doneButton.isEnabled = (toDoItem?.done == false)</p></li>
			</ol>
			<p>Run all tests again to confirm that this code fixes the bug.</p>
			<p>Great! We are finished with updating the user interface with the information from the to-do item. In the following section, we will implement the functionality of the <strong class="bold">Done</strong> button.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor321"/>Checking the to-do item</h1>
			<p>When the user <a id="_idIndexMarker352"/>of the app taps the <strong class="bold">Done</strong> button, our app has to tell the to-do item store to change the item's status to <strong class="bold">Done</strong>. Follow these steps to implement that feature:</p>
			<ol>
				<li value="1">Add the following test method to <strong class="source-inline">ToDoItemDetailsViewControllerTests</strong>:<p class="source-code">// ToDoItemDetailsViewControllerTest.swift</p><p class="source-code">func test_sendingButtonAction_shouldCheckItem() {</p><p class="source-code">  let toDoItem = ToDoItem(title: "dummy title")</p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code">  let storeMock = ToDoItemStoreProtocolMock()</p><p class="source-code">  sut.toDoItemStore = storeMock</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">ToDoItemDetailsViewController</strong> doesn't have a property for <strong class="source-inline">toDoItemStore</strong>. This means we have<a id="_idIndexMarker353"/> to pause writing this test and add this property first.</p>
			<ol>
				<li value="2">Go to <strong class="source-inline">ToDoItemDetailsViewController</strong> and add the <strong class="source-inline">toDoItemStore</strong> property:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">var toDoItemStore: ToDoItemStoreProtocol?</p></li>
				<li>Now we can finish the test:<p class="source-code">// ToDoItemDetailsViewControllerTests.swift</p><p class="source-code">func test_sendingButtonAction_shouldCheckItem() {</p><p class="source-code">  let toDoItem = ToDoItem(title: "dummy title")</p><p class="source-code">  sut.toDoItem = toDoItem</p><p class="source-code">  let storeMock = ToDoItemStoreProtocolMock()</p><p class="source-code">  sut.toDoItemStore = storeMock</p><p class="source-code"> </p><p class="source-code">  sut.doneButton.sendActions(for: .touchUpInside)</p><p class="source-code"> </p><p class="source-code">  XCTAssertEqual(storeMock.checkLastCallArgument,</p><p class="source-code">    toDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>With the <strong class="source-inline">sut.doneButton.sendActions(for: .touchUpInside)</strong> call, we send the <strong class="source-inline">.touchUpInside</strong> action to the target of the <strong class="bold">Done</strong> button. The test assertion checks if the check method of <strong class="source-inline">toDoItemStore</strong> was called with the <strong class="source-inline">toDoItem</strong> variable of the system under test.</p>
			<ol>
				<li value="4">To add an action to the <strong class="bold">Done</strong> button, open the <strong class="source-inline">Main.storyboard</strong> file and the <strong class="source-inline">ToDoItemDetailsViewController.swift</strong> file side by side. Hold down the <em class="italic">Ctrl</em> key and drag a connection from the <strong class="bold">Done</strong> button<a id="_idIndexMarker354"/> into the code:</li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_8.09_B18127.jpg" alt="Figure 8.9 – Drag a connection from the Done button to the code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Drag a connection from the Done button to the code</p>
			<ol>
				<li value="5">Change <strong class="bold">Connection</strong> to <strong class="bold">Action</strong>, put <strong class="source-inline">checkItem</strong> in the <strong class="bold">Name</strong> field, and change <strong class="bold">Type</strong> to <strong class="bold">UIButton</strong>. Then click <strong class="bold">Connect</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_8.10_B16497.jpg" alt="Figure 8.10 – Options for the button action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Options for the button action</p>
			<ol>
				<li value="6">Next, change the action code to the following:<p class="source-code">// ToDoItemDetailsViewController.swift</p><p class="source-code">@IBAction func checkItem(_ sender: UIButton) {</p><p class="source-code">  if let toDoItem = toDoItem {</p><p class="source-code">    toDoItemStore?.check(toDoItem)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to confirm that this makes all tests pass again.</p>
			<p>When the item is checked as <strong class="bold">Done</strong>, the <strong class="bold">Done</strong> button should be disabled to show the user that this task<a id="_idIndexMarker355"/> is finished. You will implement this feature in the exercises for this chapter.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor322"/>Summary</h1>
			<p>In this chapter, we built a simple detail view controller following test-driven development. We learned how to test a view controller that is set up using a storyboard. And finally, we figured out what we have to do to test the action of a button. </p>
			<p>The skills you gained in this chapter will help you in writing tests for all kinds of user interfaces, even those that are more complicated. You are now able to test the presence and the interaction of user interface elements with the rest of the code.</p>
			<p>In the next chapter, we will write tests for a view that is created using SwiftUI. For that task, we will have to add a third-party library from GitHub to our test target.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor323"/>Exercises</h1>
			<ol>
				<li value="1">When the user selects the <strong class="bold">Done</strong> button to show the task as finished, the <strong class="bold">Done</strong> button should be disabled to show the user that this action was successful. Implement this feature.</li>
				<li>Change the code so that the map view is hidden when no coordinate is set in the to-do item.</li>
			</ol>
		</div>
	</body></html>