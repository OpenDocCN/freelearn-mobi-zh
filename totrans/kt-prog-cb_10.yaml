- en: Databases and Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库和依赖注入
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Using SQLite database in Kotlin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中使用SQLite数据库
- en: Creating database tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库表
- en: Injecting dependencies in Kotlin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中注入依赖
- en: Reading data from database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库读取数据
- en: Converting database cursor into list of objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库游标转换为对象列表
- en: Using parseOpt for nullable objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用parseOpt处理可空对象
- en: Inserting data into database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库中插入数据
- en: Creating singletons in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中创建单例
- en: Using Dagger2 with Kotlin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中使用Dagger2
- en: Using Butterknife with Kotlin
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中使用Butterknife
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When we develop an app, we should bear in mind those situations when the app
    won't be connected to the internet. The user might be in an elevator or there
    might not be any network coverage when they try to use the app. To provide a great
    user experience, we need to ensure that some parts our app work even when there
    isn't any network connection. To be able to do this, we need a persistent storage
    mechanism in our app. It can be achieved by either using shared preferences or
    using the database. Shared preferences can come in handy when we have small amounts
    of data such as the app's setting values. Databases are much more powerful for
    situations when we need to store structured data. In this chapter, we will learn
    how to use Android's built-in database SQLite and will also learn about dependency
    injection with Dagger2, which is considered among the best practices for developing
    a quality app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发应用程序时，我们应该考虑到应用程序可能无法连接到互联网的情况。用户可能在电梯里，或者在他们尝试使用应用程序时可能没有网络覆盖。为了提供良好的用户体验，我们需要确保应用程序的一些部分在没有网络连接的情况下也能工作。为了能够做到这一点，我们需要在应用程序中有一个持久存储机制。这可以通过使用共享首选项或使用数据库来实现。当我们需要存储少量数据，如应用程序的设置值时，共享首选项会很有用。数据库在需要存储结构化数据的情况下功能更强大。在本章中，我们将学习如何使用Android内置的数据库SQLite，还将学习使用Dagger2进行依赖注入，这被认为是开发优质应用程序的最佳实践之一。
- en: Using SQLite database in Kotlin
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kotlin中使用SQLite数据库
- en: SQLite is a relational database. Android comes with a built-in SQLite database.
    It is an open source SQL database and is widely used in Android apps. However,
    doing it in a raw manner is very time-consuming and eats up a lot of development
    and testing time. You have to work with cursors, iterate over them row by row,
    and wrap code in `try-finally`, and such. Of course, you can use libraries that
    provide ORM mapping, which makes it easier to deal with a SQLite database, but
    if the database is small, it is expensive and is generally overkill. Kotlin, with
    Anko, provides a really easy way to deal with SQLite database. So let's get to
    work and see how we can use SQLite database in Kotlin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个关系型数据库。Android自带内置的SQLite数据库。它是一个开源的SQL数据库，在Android应用程序中得到广泛应用。然而，以原始方式操作非常耗时，消耗了大量的开发和测试时间。你必须与游标一起工作，逐行迭代它们，并将代码包裹在`try-finally`中，等等。当然，你可以使用提供ORM映射的库，这使得处理SQLite数据库更容易，但如果数据库很小，这很昂贵，并且通常是过度设计。Kotlin，结合Anko，提供了一个处理SQLite数据库的简单方法。那么，让我们开始工作，看看我们如何在Kotlin中使用SQLite数据库。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll be using Android Studio 3.0 for coding. First, we need to add anko-sqlite to
    our `build.gradle` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0进行编码。首先，我们需要将`anko-sqlite`添加到我们的`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can replace `$anko_version` with the latest version of the library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`$anko_version`替换为库的最新版本。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Anko provides a wrapper around our built-in SQLite API, which helps eliminate
    a lot of boilerplate code and also adds safety mechanisms such as closing the
    database after the code execution is complete and more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Anko为我们内置的SQLite API提供了一个包装器，这有助于消除大量的样板代码，并增加了诸如在代码执行完成后关闭数据库等安全机制。
- en: While implementing a SQLite database, the first step is to create the database
    helper class. In this case, we need the class to extend the `ManagedSQLiteOpenHelper`
    class instead of the `SQLiteOpenHelper` class, which we used to do. `ManagedSQLiteOpenHelper`
    is concurrency aware and closes the database at the end of query executions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现SQLite数据库时，第一步是创建数据库辅助类。在这种情况下，我们需要这个类扩展`ManagedSQLiteOpenHelper`类，而不是我们之前使用的`SQLiteOpenHelper`类。`ManagedSQLiteOpenHelper`是并发感知的，并在查询执行结束时关闭数据库。
- en: 'Check out the following code for a simple database helper that I am using for
    this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码，这是一个简单的数据库辅助工具，我将在示例中使用它：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So basically, in `onCreate`, we create tables and in `onUpgrade`, we upgrade
    tables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，在`onCreate`中，我们创建表，在`onUpgrade`中，我们升级表。
- en: I am creating a single table in my database, which is `Requests`. In the `Requests`
    table, we have the `name`, `message`, and `id` fields as primary keys.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的数据库中创建了一个单独的表，名为`Requests`。在`Requests`表中，我们拥有`name`、`message`和`id`字段作为主键。
- en: 'We can provide access to the database by adding it as an extension property
    to the context. This allows access to the database by any class that requires
    context. The following code adds the database as an extension property to the
    context:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其添加为上下文的扩展属性来提供对数据库的访问。这允许任何需要上下文的类访问数据库。以下代码将数据库添加为上下文的扩展属性：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I added the preceding code to the same file as that of the database helper,
    outside the class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我将前面的代码添加到了与数据库助手相同的文件中，在类外部。
- en: 'Now, here''s my code for the activity, where I have fields for a name and message
    and on pressing the Enter button, the details are stored in the database:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是我的活动代码，其中包含姓名和消息字段，在按下Enter按钮时，详细信息将存储在数据库中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the code in bold. So basically, we can perform operations on the database
    inside the use block. The database will be opened at the beginning of the use
    block and closed after its execution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意粗体代码。基本上，我们可以在use块内部对数据库执行操作。数据库将在use块开始时打开，并在执行后关闭。
- en: 'The following screenshot is how our layout looks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们布局的截图：
- en: '![](img/a522b58a-b12c-4b18-9dec-7f7953ce331d.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a522b58a-b12c-4b18-9dec-7f7953ce331d.jpeg)'
- en: 'Now try to put something in the database. Here''s a screenshot of my database,
    and the insert operation worked:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试将一些内容放入数据库。下面是我的数据库截图，插入操作已成功执行：
- en: '![](img/da4899d4-09cb-4571-a6ff-bb4207b30bcc.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da4899d4-09cb-4571-a6ff-bb4207b30bcc.png)'
- en: I am using Stetho ([https://github.com/facebook/stetho](https://github.com/facebook/stetho))
    to view the database in Chrome dev tools.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用Stetho ([https://github.com/facebook/stetho](https://github.com/facebook/stetho))在Chrome开发者工具中查看数据库。
- en: For the layout of the activity, I have used Anko DSL layouts. You can refer
    to [Chapter 9](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/52df376c-f81c-4fee-b607-3c954d405230.xhtml), *Anko
    Layouts*, of this book to learn more about them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于活动的布局，我使用了Anko DSL布局。您可以参考本书的[第9章](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/52df376c-f81c-4fee-b607-3c954d405230.xhtml)，*Anko
    Layouts*，以了解更多信息。
- en: Creating database tables
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库表
- en: Now that you have learned how to add anko-sqlite dependencies to your project
    and how to use SQLite database in the first recipe, the next step is learning
    how to create database tables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何将anko-sqlite依赖项添加到您的项目中，以及如何在第一个菜谱中使用SQLite数据库，下一步是学习如何创建数据库表。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using Android Studio 3 for coding. Ensure that you have added anko-sqlite to
    your `build.gradle` file and gone through the first recipe on how to use a SQLite
    database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3进行编码。确保您已将anko-sqlite添加到您的`build.gradle`文件中，并完成了关于如何使用SQLite数据库的第一个菜谱。
- en: How to do it…
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will be creating two tables: `Requests` and `customers`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个表：`Requests`和`customers`：
- en: 'For the `Requests` table, we have the `name` and `message` fields, and we can
    directly create them in the `onCreate` method of our database helper, as shown:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Requests`表，我们有`name`和`message`字段，我们可以在数据库助手的`onCreate`方法中直接创建它们，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the `customers` table, we will be using a better coding practice by making
    a data class and using it to define the columns of the `customers` table.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`customers`表，我们将通过创建数据类并使用它来定义`customers`表的列来采用更好的编码实践。
- en: 'Given here is the code for our `Customer` data class:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里提供了我们的`Customer`数据类的代码：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will use this data class to create our table like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个数据类来创建我们的表，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is how our database helper finally looks after filling in the
    code for drop tables:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在为drop tables填充代码后，我们的数据库助手最终的样子：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s do a fresh install of our app and see whether the two tables have
    been formed in our database. The following is how our database screenshot looks
    (using Stetho), and our tables have successfully been created:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新安装我们的应用程序，看看是否在我们的数据库中形成了两个表。以下是我们数据库截图的样式（使用Stetho），并且我们的表已成功创建：
- en: '![](img/ec9fe063-9d31-49f3-8124-91cf8e725368.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec9fe063-9d31-49f3-8124-91cf8e725368.png)'
- en: Injecting dependencies in Kotlin
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的依赖注入
- en: In Android development, Dagger 2 is the most popular dependency injection framework.
    You define the dependency objects, and with the help of a Dagger component, you
    inject it where you want. In this recipe, we will see how to inject the dependencies.
    We won't be going into the details of how to work with Dagger 2 in detail; for
    that, you can refer to the *Using Dagger2 with Kotlin* recipe in this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，Dagger 2是最受欢迎的依赖注入框架。你定义依赖对象，然后借助Dagger组件，将其注入到你想要的位置。在本食谱中，我们将了解如何注入依赖。我们不会深入探讨如何详细使用Dagger
    2；关于这一点，你可以参考本章中的“使用Kotlin与Dagger2”食谱。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0 for this recipe. Ensure that you have its
    latest version.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0进行本食谱。请确保你有其最新版本。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'When you''ve defined all the dependency objects you need in the module class,
    you can get the component. Let''s take look at the mentioned steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模块类中定义了所有需要的依赖对象后，你可以获取组件。让我们看看以下步骤：
- en: 'To inject the object, you just need to add the `@Inject` annotation before
    the variable, then the object will be injected there. Let’s look at the following
    example:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要注入对象，你只需在变量前添加`@Inject`注解，然后对象就会被注入到那里。让我们看看以下示例：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have also used the `lateinit` modifier to void null checks before using the
    variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`lateinit`修饰符来避免在使用变量之前进行空检查。
- en: 'Another way to do it is by constructor injection. To understand it, let’s take
    a look at the given code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是构造函数注入。为了理解它，让我们看看以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we have sent `AddActivityPresenter` in the `providesAddActivityPresenter`,
    but the module doesn’t provide it. This usually won’t work unless you provide
    `AddActivityPresnter` as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们在`providesAddActivityPresenter`中发送了`AddActivityPresenter`，但模块没有提供它。除非你按照以下方式提供`AddActivityPresnter`，否则这通常不会起作用：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you use the `@Inject` annotation in the constructor, it means that the
    class needs the `DataManager` object before it can be created. Dagger2 will look
    into the dependency tree and provide you the dependency if it can.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构造函数中使用`@Inject`注解时，这意味着在创建类之前，它需要`DataManager`对象。Dagger2将检查依赖树，并在可能的情况下提供依赖。
- en: Reading data from database
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库读取数据
- en: Now that we have seen how to create a database and how to create tables, let's
    learn how to read from a database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建数据库和如何创建表，让我们学习如何从数据库中读取。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by adding
    anko-sqlite dependencies to your project and creating a SQLite database with the `Requests`
    table in it by going through and implementing the *Using SQLite database in Kotlin* recipe in
    this chapter. By using the form we created in this recipe, add some data to your
    `Requests` table.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。你可以通过将anko-sqlite依赖项添加到你的项目中，并通过实现本章中的“使用Kotlin与SQLite数据库”食谱来创建一个包含`Requests`表的SQLite数据库来开始。通过使用本食谱中创建的表单，向你的`Requests`表添加一些数据。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s take look at the given steps to understand how to read data from the
    database:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，以了解如何从数据库中读取数据：
- en: 'Now, let''s add a button to our existing layout from the first recipe; on clicking,
    it should retrieve all data from our `Requests` table. Check out the updated code,
    which is as follows, where I have added a button with a click listener on it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将一个按钮添加到第一个食谱中现有的布局中；点击时，它应该从我们的`Requests`表中检索所有数据。查看以下更新后的代码，其中我添加了一个带有点击监听器的按钮：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I am using Anko DSL to create the layout for my activity. As we discussed in
    previous recipes, we do all database operations inside the `database.use{...}`
    block. To read data from the database, we use the `select` function. The syntax
    is this:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我正在使用Anko DSL来创建我的活动的布局。正如我们在之前的食谱中讨论的那样，我们在`database.use{...}`块内执行所有数据库操作。要从数据库中读取数据，我们使用`select`函数。语法如下：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside `database.use {...}` , `this` is the database instance, so we can directly
    use methods such as `select` and `insert`. The following is the data and the output
    in the database table:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`database.use {...}`内部，`this`是数据库实例，因此我们可以直接使用`select`和`insert`等方法。以下是在数据库表中的数据和输出：
- en: 'This is the data:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据：
- en: '![](img/b46f6904-b0f4-486a-b351-e9503fcf68ec.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b46f6904-b0f4-486a-b351-e9503fcf68ec.png)'
- en: 'Here''s the output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There''s a lot more we can do with the query builder; listed here are the methods
    provided by Anko:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询构建器还有很多我们可以做的事情；以下是Anko提供的方法列表：
- en: '`column(String)`: used to add a column to our `select` query'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column(String)`: 用于将列添加到我们的 `select` 查询中'
- en: '`distinct(Boolean)`: used to add distinct to the query'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct(Boolean)`: 用于在查询中添加 distinct'
- en: '`whereArgs(String)`: used to specify the raw `where` string'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereArgs(String)`: 用于指定原始 `where` 字符串'
- en: '`whereArgs(String, args)`: used to specify the `where` query and corresponding
    arguments'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereArgs(String, args)`: 用于指定 `where` 查询及其对应的参数'
- en: '`whereSimple(String, args) `: used to specify a `where` query with the `?`
    marks and corresponding arguments for `?`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whereSimple(String, args)`: 用于指定带有 `?` 标记的 `where` 查询及其对应的参数'
- en: '`orderBy(String, [ASC/DESC])`  : used to specify a column for order by'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderBy(String, [ASC/DESC])`：用于指定用于排序的列'
- en: '`groupBy(String)`: used to specify a column for group by'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy(String)`: 用于指定用于分组的列'
- en: '`limit(count: Int)`: used to limit the number of rows returned by the query'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit(count: Int)`: 用于限制查询返回的行数'
- en: '`limit(offset: Int, count: Int)`: used to limit the number of rows returned
    by the query after an `offset`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit(offset: Int, count: Int)`: 用于在 `offset` 之后限制查询返回的行数'
- en: '`having(String)`: used to specify the raw `having` expression'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`having(String)`: 用于指定原始 `having` 表达式'
- en: '`having(String, args)`: used to specify the raw `having` expression with arguments'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`having(String, args)`: 用于指定带有参数的原始 `having` 表达式'
- en: 'Let''s try another example. In this example, we will select data from a database
    using the `where` clause:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子。在这个例子中，我们将使用 `where` 子句从数据库中选择数据：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the output of the preceding query:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一个查询的输出：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After getting the query results, we also need to parse the result. We get a
    cursor as a result from the query and using methods provided by Anko, we can easily
    parse them into regular classes. In the preceding example, we made a class named
    `Request`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获取查询结果后，我们还需要解析结果。我们从查询中获取一个游标，并使用 Anko 提供的方法，我们可以轻松地将它们解析到常规类中。在上一个例子中，我们创建了一个名为
    `Request` 的类：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The class has all the fields that we may get as columns from our query result
    cursor. The following are the methods that we can use for parsing results:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类包含我们可能从查询结果游标中获取的所有字段。以下是我们用于解析结果的方法：
- en: '`parseSingle(rowParser): T` : Parses exactly and only one row; if there''s
    more than one row in the cursor, then it throws an exception'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseSingle(rowParser): T`：解析正好且仅一行；如果游标中有多于一行，则抛出异常'
- en: '`parseOpt(rowParser): T?` : Parses zero or one row, but if there''s more than
    one row in the cursor, then it throws an exception'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseOpt(rowParser): T?`：解析零行或一行，但如果游标中有多于一行，则抛出异常'
- en: '`parseList(rowParser): List<T>`  : Parses zero or more rows'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseList(rowParser): List<T>`：解析零行或多行'
- en: 'We used `parseList` in the preceding example. You can pass row parsers or map
    parsers, and you can also use `classParser` of the type of your custom class,
    which passes a row parser, like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个例子中使用了 `parseList`。你可以传递行解析器或映射解析器，你也可以使用你自定义类的 `classParser`，它传递一个行解析器，如下所示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Converting database cursor into list of objects
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库游标转换为对象列表
- en: In the previous recipe, we learned how to query data from a database table.
    We receive a cursor as result of the query. In this recipe, we will learn how
    to use `parseList` to convert the cursor into a list of objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们学习了如何从数据库表中查询数据。查询的结果是一个游标。在这个菜谱中，我们将学习如何使用 `parseList` 将游标转换为对象的列表。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project and creating a database helper like we did in the *Using SQLite
    database in Kotlin* recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Android Studio 3 来编写代码。你可以通过向项目中添加 anko-sqlite 依赖项并创建一个类似于我们在 *在 Kotlin
    中使用 SQLite 数据库* 菜谱中做的数据库辅助类来开始。
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to convert the cursor into a list of objects:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将游标转换为对象列表：
- en: 'Let''s start by creating a `Customer` class as a model for our `customers`
    table:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个 `Customer` 类开始，作为我们的 `customers` 表的模型：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we will write code to create the `customers` table inside the database
    helper class. Check out the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写代码在数据库辅助类中创建 `customers` 表。查看以下代码：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will create a form to enter customers and a button that shows all customers
    in the database table using the `select` function. We will use the `parseList`
    method to get rows in the resulting cursor as a `List`. We need to pass in a row
    parser or map parser inside the `parseList` method. The easiest way of doing this
    is using `classParser` provided by Anko and using our `Customer` class constructor
    to get a row parser, like this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个表单来输入客户，并使用`select`函数显示数据库表中的所有客户。我们将使用`parseList`方法获取结果游标中的行作为`List`。我们需要在`parseList`方法中传递一个行解析器或映射解析器。这样做最简单的方法是使用Anko提供的`classParser`，并使用我们的`Customer`类构造函数来获取行解析器，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I suggest that you try this exercise on your own before moving to the solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在查看解决方案之前先自己尝试这个练习。
- en: 'The following is my version of the activity that also contains DSL layout:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我的包含DSL布局的活动版本：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The result of the query, that is, `customers`, is the list of objects that we
    can now iterate on to get individual rows as objects of the `Customer` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果，即`customers`，是我们现在可以迭代的对象列表，以获取`Customer`类的单个行对象。
- en: Using parseOpt for nullable object
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`parseOpt`处理可空对象
- en: We use `parseList` when we get multiple rows in our cursor, but when we get
    only one row, we use `parseSingle` or `parseOpt`. However, what is the difference
    between `parseSingle` and `parseOpt`?  In this recipe, we will understand the
    difference between both and when to use which one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在游标中获取多行时，我们使用`parseList`，但当只获取一行时，我们使用`parseSingle`或`parseOpt`。然而，`parseSingle`和`parseOpt`之间有什么区别呢？在本教程中，我们将了解两者的区别以及何时使用哪一个。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project and creating a database helper, like we did in the *Using SQLite
    database in Kotlin* recipe. You will need to read and implement the previous recipe
    to be able to follow this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。你可以通过将`anko-sqlite`依赖项添加到你的项目中并创建一个数据库助手来开始，就像我们在`*在Kotlin中使用SQLite数据库*`教程中所做的那样。你需要阅读并实现上一个教程，以便能够跟随本教程。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you have read and implemented the previous recipe, you must already have
    a `customers` table in your database. Follow the mentioned steps to understand
    the difference between `parseSingle` and `parseOpt`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读并实现了上一个教程，那么你数据库中必须已经有一个`customers`表。按照提到的步骤来了解`parseSingle`和`parseOpt`之间的区别：
- en: 'In the previous recipe, we used `parseList` to get a list of rows as objects.
    If we need to get only a single row as an object, then we need to use `parseSingle`.
    The following is the syntax of `parseSingle`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们使用`parseList`获取行列表作为对象。如果我们只需要获取一行作为对象，那么我们需要使用`parseSingle`。以下为`parseSingle`的语法：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we use it in the following way in our previous code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们以以下方式在我们的前一个代码中使用它：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are using `parseSingle` because we will only get one row in the cursor,
    but if we get zero rows from the cursor, that is, we get an empty cursor, then
    we get an exception:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`parseSingle`是因为我们将在游标中只得到一行，但如果从游标中获取零行，即我们得到一个空游标，那么我们会得到一个异常：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, what if there is a possibility of getting an empty cursor when we are
    expecting a cursor with a single row? It will always throw an exception, that
    is, when we use `parseOpt`; `parseOpt` accepts zero or one rows of cursors. Also,
    if `parseOpt` gets a null object, it handles the scenario accordingly by giving
    the value of `null` for each column. Basically, `parseOpt` is used for cursors
    that can be empty and objects that can be `null`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们期望得到一个单行游标，但有可能得到一个空游标，会发生什么？它总是会抛出异常，即当我们使用`parseOpt`时；`parseOpt`接受零行或一行游标。此外，如果`parseOpt`得到一个null对象，它会相应地处理场景，为每个列提供`null`值。基本上，`parseOpt`用于可能为空的游标和可能为`null`的对象。
- en: 'The syntax for `parseOpt` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseOpt`的语法如下：'
- en: '`parseOpt(rowParser): T?` // The `?` denotes that the object returned is nullable.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseOpt(rowParser): T?` // `?`表示返回的对象可能是可空的。'
- en: 'Here''s how we will use it in our code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在我们的代码中使用它的示例：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now even if the cursor returned is empty, we do not get an exception, and `null`
    values are printed as output.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在即使返回的游标为空，我们也不会得到异常，并且输出为`null`值。
- en: 'This is the output in case of an empty table:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表为空，则输出如下：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inserting data into database
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据插入数据库
- en: Inserting data into the database using Anko SQLite is a piece of cake. In this
    recipe, we will learn how to do that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Anko SQLite将数据插入数据库就像做蛋糕一样简单。在本教程中，我们将学习如何做到这一点。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'I''ll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project by adding the following lines to your `build.gradle` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。你可以通过在你的`build.gradle`文件中添加以下行来将`anko-sqlite`依赖项添加到你的项目中开始：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can replace `$anko_version` with the latest version of the library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`$anko_version`替换为库的最新版本。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s insert data into our database by following the mentioned steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将数据插入我们的数据库：
- en: 'Let''s start with our database helper, in which we will be creating a `Requests`
    table with the `name`, `message`, and `id` fields, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们的数据库助手开始，我们将创建一个包含`name`、`message`和`id`字段的`Requests`表，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s create an activity with a form that takes the name and message
    and stores it in the database. I am using Anko DSL layouts for the layout of the
    activity:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个活动，其中包含一个表单，用于接收姓名和消息并将其存储在数据库中。我正在使用Anko DSL布局来布局活动：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note the code in bold in the preceding code snippet. We will do all operations
    inside the `database.use {...}` block, because it is concurrency safe and also
    closes the database after execution of the block. If you have gone through the *Creating
    database tables* recipe, you will note that table creation and insertion is quite
    similar. The syntax is this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意前面代码片段中加粗的代码。我们将在`database.use {...}`块内执行所有操作，因为它具有并发安全性，并且在块执行后关闭数据库。如果你已经完成了*创建数据库表*的食谱，你会注意到表创建和插入相当相似。语法如下：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is our layout:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的布局：
- en: '![](img/2c7459ff-469b-44d1-9cc7-3a6d8bda109c.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c7459ff-469b-44d1-9cc7-3a6d8bda109c.jpeg)'
- en: On entering the data, we can check whether our name and message are being stored
    in our database or not. I am using Stetho to view the database on my device.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入数据时，我们可以检查我们的姓名和消息是否被存储在我们的数据库中。我正在使用Stetho在我的设备上查看数据库。
- en: '![](img/0a67fa84-0ab5-4579-b89f-319c062d8780.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a67fa84-0ab5-4579-b89f-319c062d8780.png)'
- en: Creating singletons in Kotlin
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kotlin中创建单例
- en: A singleton class is a class that can have only one instance/object of that
    class at a time. The concept is to restrict instantiation of objects to a certain
    number. In this recipe, we will explore singletons in Kotlin.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类是一个类，在任意时刻只能有一个该类的实例/对象。这个概念是为了限制对象的实例化数量。在本食谱中，我们将探索Kotlin中的单例。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio 3 to write code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio 3来编写代码。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create singletons in Kotlin:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在Kotlin中创建单例：
- en: 'Kotlin does not have static members or variables, so for declaring static members
    of a class, we use `companion object`. Check out this example:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin没有静态成员或变量，因此为了声明类的静态成员，我们使用`companion object`。查看以下示例：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Accessing the members and methods of `companion` object of the preceding class
    is the same as we would do for any static members or methods:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问前一个类的`companion`对象的成员和方法与访问任何静态成员或方法相同：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now what if we want a singleton class, that is, the class with only one object/instance
    at a time? Brace yourselves, this one is fun. Here''s a way to create a singleton
    class in just a few lines:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们想要一个单例类，即每次只有一个对象/实例的类？做好准备，这个很有趣。以下是在几行代码内创建单例类的方法：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, we use it just like the static members in the preceding examples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们就像在前面示例中使用静态成员一样使用它：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In Kotlin, decompiling bytecode is always a great way to know what is happening
    behind the scenes. If we decompile the bytecode of the object we created, we get
    the following code, which shows that behind the scenes, the object is just a class
    with a single instance at a time:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，反编译字节码是了解幕后发生的事情的绝佳方法。如果我们反编译我们创建的对象的字节码，我们会得到以下代码，这表明在幕后，对象只是一个每次只有一个实例的类：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using Dagger 2 with Kotlin
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin与Dagger 2
- en: Dagger 2 is the best dependency injection framework in the Android community
    and is also open source. It is backed by Google and is widely used. Dependency
    injection is considered best practice and makes your code base scalable. In this
    recipe, we will learn how to use Dagger 2 for dependency injection in Kotlin.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger 2 是Android社区中最好的依赖注入框架，也是开源的。它由Google支持，并且被广泛使用。依赖注入被认为是最佳实践，可以使你的代码库可扩展。在本食谱中，我们将学习如何使用Dagger
    2在Kotlin中进行依赖注入。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll be using Android Studio 3.0 for coding purposes. First, we need to include
    Dagger 2 in the project, by adding the following lines to the `build.gradle` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0进行编码。首先，我们需要将Dagger 2包含到项目中，通过在`build.gradle`文件中添加以下行来实现：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You need to replace `$daggerVersion` with the latest version of Dagger2.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将`$daggerVersion`替换为Dagger2的最新版本。
- en: How to do it…
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Before we move ahead, we need to understand how Dagger2 works. Dagger2 uses
    annotation to generate codes and uses it to access fields; therefore, it can't
    use private fields.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要了解Dagger2是如何工作的。Dagger2使用注解生成代码，并使用它来访问字段；因此，它不能使用私有字段。
- en: 'The following annotations are used in Dagger2:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下注解在Dagger2中使用：
- en: '`@Module` and `@Provides`: Define classes and methods that provide dependencies'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Module`和`@Provides`：定义提供依赖关系的类和方法'
- en: '`@Inject`: Requests dependencies, and can be used on a constructor, a field,
    or a method'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject`：请求依赖关系，可以在构造函数、字段或方法中使用'
- en: '`@Component`: Enables selected modules and is used for performing dependency
    injection'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Component`：启用选定的模块，并用于执行依赖注入'
- en: 'The classes annotated with `@Module` are responsible for providing objects
    that can be injected. The methods that provide those objects need to be annotated
    with `@Provides`. If the method requires another object to create a dependency
    object, they are provided in the method parameters. Dagger2 creates a dependency
    tree and checks whether the parameters can be supplied or not. Let''s take a look
    at the implementation of a module:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注有`@Module`的类负责提供可注入的对象。提供这些对象的那些方法需要注有`@Provides`。如果方法需要另一个对象来创建依赖对象，它们将在方法参数中提供。Dagger2创建一个依赖关系树并检查参数是否可以提供。让我们看看模块的实现：
- en: 'We will look at an example of a network module that will supply objects such
    as `HttpCache`, `HttpLoggingInterceptor`, GSON object, and such:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将查看一个网络模块的示例，该模块将提供诸如`HttpCache`、`HttpLoggingInterceptor`、GSON对象等对象：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we annotated every method that provides an object through dependency
    injection with the `@Provides` annotation. We have also used the `@Singleton`
    annotation, which means that a singleton object is provided by the method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们注解了每个通过依赖注入提供对象的每个方法，我们使用了`@Singleton`注解，这意味着方法提供了一个单例对象。
- en: You may notice, we've used other objects to create injectable objects, which
    we've provided as parameters. Those parameters should be available either from
    outside or from other injected objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们使用了其他对象来创建可注入对象，并将它们作为参数提供。这些参数应从外部或其他注入对象中可用。
- en: 'Now, let''s look at an example of the `Dagger` component:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Dagger`组件的示例：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The component acts as an interface that tells us from which modules (or other
    components) the dependencies are met. In the preceding example, we created a component
    that will provide us with the dependency objects from `AddActivityModule` and
    another `ApplicationComponent` component.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 组件充当一个接口，告诉我们从哪些模块（或其他组件）满足依赖关系。在上面的示例中，我们创建了一个组件，它将为我们提供来自`AddActivityModule`和另一个`ApplicationComponent`组件的依赖对象。
- en: We also defined an inject method, which takes in a parameter (`AddActivity`
    here) that tells us where the objects will be injected.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个注入方法，它接受一个参数（这里为`AddActivity`），告诉我们对象将被注入的位置。
- en: 'Once defined, we can inject it into our `AddActivity`, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义，我们就可以将其注入到我们的`AddActivity`中，如下所示：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we use our `AddActivityComponent` (now prefixed with *Dagger*)
    to inject our `AddActivity` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用我们的`AddActivityComponent`（现在以*Dagger*为前缀）来注入我们的`AddActivity`类。
- en: Also, we have marked our dependency objects using the `@Inject` annotation,
    which means objects will be injected here. We've also added the `lateinit` modifier
    to prevent us from null checks every time we access it. Adding the `@Inject` annotation
    means that you want an object there, and dagger will then look into its components
    and dependencies to provide you that object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`@Inject`注解标记了我们的依赖对象，这意味着对象将被注入到这里。我们还添加了`lateinit`修饰符，以防止我们每次访问它时都进行空检查。添加`@Inject`注解意味着你想要一个对象，然后Dagger将检查其组件和依赖关系以提供该对象。
- en: 'Apart from that module class, you can instantiate the object at constructor
    level. Let''s take a look at the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个模块类之外，你还可以在构造函数级别实例化对象。让我们看看以下示例：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, adding the `@Inject` annotation to constructor means
    that the class needs the `DataManager` object before it can be created. Dagger
    will look into its dependency tree (in its component) and create `AddActivityPresenter`,
    if present.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，将`@Inject`注解添加到构造函数中意味着在创建类之前，该类需要`DataManager`对象。Dagger将检查其依赖关系树（在其组件中）并创建`AddActivityPresenter`，如果存在的话。
- en: Using Butterknife with Kotlin
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin的Butterknife
- en: The Android world has many libraries that require annotation processing. You
    just annotate the code, and it generates all the code behind the scenes for you,
    making your life easier. Many libraries such as Butterknife and Dagger2 work in
    similar ways. In this recipe, we will learn how to use Butterknife with Kotlin.
    For those who aren't familiar with Butterknife, it's a library that binds a view
    to a field without needing the `findViewById` calls. It's a household name in
    the Android development world. In Kotlin, the Kotlin Android Extension does almost
    the same work and is bundled along with Kotlin. However, if you are migrating
    your Java code where you've used Butterknife, this recipe will help you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Android世界有许多需要注解处理的库。您只需注解代码，它就会在幕后为您生成所有代码，使您的生活更轻松。许多库，如Butterknife和Dagger2，以类似的方式工作。在本教程中，我们将学习如何使用Kotlin的Butterknife。对于那些不熟悉Butterknife的人来说，这是一个将视图绑定到字段而不需要`findViewById`调用的库。它是Android开发界的家喻户晓的名字。在Kotlin中，Kotlin
    Android Extension几乎做同样的工作，并且与Kotlin捆绑在一起。然而，如果您正在迁移使用Butterknife的Java代码，这个教程将帮助您。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0 for coding purposes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0进行编码。
- en: How to do it…
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To include Butterknife in your project, follow the given steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Butterknife包含到您的项目中，请遵循以下步骤：
- en: 'To start with, add the following lines to your `build.gradle` file; also, you
    need to add the `kotlin-kapt` plugin and replace `annotationProcessor` with `kapt`.
    `kapt` is the Java equivalent of `annotationProcessor`, so wherever you used `annotationProcessor`,
    you need to replace it with `kapt`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下行添加到您的`build.gradle`文件中；同时，您需要添加`kotlin-kapt`插件，并将`annotationProcessor`替换为`kapt`。`kapt`是`annotationProcessor`的Java等价物，因此无论您在哪里使用了`annotationProcessor`，都需要将其替换为`kapt`：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In Java, we used the Butterknife library, as shown:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中，我们使用了Butterknife库，如下所示：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In Kotlin, we can do it as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以这样做：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that we''ve used the `lateinit` modifier, which will save us from declaring
    it nullable. We can also implement click listeners, as illustrated:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经使用了`lateinit`修饰符，这将使我们免于声明它为可空。我们还可以实现点击监听器，如下所示：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more…
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's important to understand the working of annotation processors. They basically
    act as a hook for the compiler to analyze the source code for defined annotations,
    and handle them by producing compiler errors, warnings, or extra code in their
    place. This makes writing apps faster, because you just have to annotate and the
    compiler will generate all the necessary code for you behind the scenes. Dagger
    2 is a popular library that works this way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 理解注解处理器的运作方式很重要。它们基本上充当编译器的钩子，用于分析源代码中定义的注解，并通过产生编译错误、警告或在其位置生成额外代码来处理它们。这使得编写应用程序更快，因为您只需注解，编译器就会在幕后为您生成所有必要的代码。Dagger
    2是一个流行的库，它以这种方式工作。
