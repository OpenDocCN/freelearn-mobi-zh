- en: Databases and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite database in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting dependencies in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting database cursor into list of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using parseOpt for nullable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data into database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating singletons in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dagger2 with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Butterknife with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop an app, we should bear in mind those situations when the app
    won't be connected to the internet. The user might be in an elevator or there
    might not be any network coverage when they try to use the app. To provide a great
    user experience, we need to ensure that some parts our app work even when there
    isn't any network connection. To be able to do this, we need a persistent storage
    mechanism in our app. It can be achieved by either using shared preferences or
    using the database. Shared preferences can come in handy when we have small amounts
    of data such as the app's setting values. Databases are much more powerful for
    situations when we need to store structured data. In this chapter, we will learn
    how to use Android's built-in database SQLite and will also learn about dependency
    injection with Dagger2, which is considered among the best practices for developing
    a quality app.
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite database in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a relational database. Android comes with a built-in SQLite database.
    It is an open source SQL database and is widely used in Android apps. However,
    doing it in a raw manner is very time-consuming and eats up a lot of development
    and testing time. You have to work with cursors, iterate over them row by row,
    and wrap code in `try-finally`, and such. Of course, you can use libraries that
    provide ORM mapping, which makes it easier to deal with a SQLite database, but
    if the database is small, it is expensive and is generally overkill. Kotlin, with
    Anko, provides a really easy way to deal with SQLite database. So let's get to
    work and see how we can use SQLite database in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using Android Studio 3.0 for coding. First, we need to add anko-sqlite to
    our `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can replace `$anko_version` with the latest version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anko provides a wrapper around our built-in SQLite API, which helps eliminate
    a lot of boilerplate code and also adds safety mechanisms such as closing the
    database after the code execution is complete and more.
  prefs: []
  type: TYPE_NORMAL
- en: While implementing a SQLite database, the first step is to create the database
    helper class. In this case, we need the class to extend the `ManagedSQLiteOpenHelper`
    class instead of the `SQLiteOpenHelper` class, which we used to do. `ManagedSQLiteOpenHelper`
    is concurrency aware and closes the database at the end of query executions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code for a simple database helper that I am using for
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So basically, in `onCreate`, we create tables and in `onUpgrade`, we upgrade
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: I am creating a single table in my database, which is `Requests`. In the `Requests`
    table, we have the `name`, `message`, and `id` fields as primary keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide access to the database by adding it as an extension property
    to the context. This allows access to the database by any class that requires
    context. The following code adds the database as an extension property to the
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I added the preceding code to the same file as that of the database helper,
    outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here''s my code for the activity, where I have fields for a name and message
    and on pressing the Enter button, the details are stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the code in bold. So basically, we can perform operations on the database
    inside the use block. The database will be opened at the beginning of the use
    block and closed after its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is how our layout looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a522b58a-b12c-4b18-9dec-7f7953ce331d.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now try to put something in the database. Here''s a screenshot of my database,
    and the insert operation worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da4899d4-09cb-4571-a6ff-bb4207b30bcc.png)'
  prefs: []
  type: TYPE_IMG
- en: I am using Stetho ([https://github.com/facebook/stetho](https://github.com/facebook/stetho))
    to view the database in Chrome dev tools.
  prefs: []
  type: TYPE_NORMAL
- en: For the layout of the activity, I have used Anko DSL layouts. You can refer
    to [Chapter 9](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/52df376c-f81c-4fee-b607-3c954d405230.xhtml), *Anko
    Layouts*, of this book to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to add anko-sqlite dependencies to your project
    and how to use SQLite database in the first recipe, the next step is learning
    how to create database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using Android Studio 3 for coding. Ensure that you have added anko-sqlite to
    your `build.gradle` file and gone through the first recipe on how to use a SQLite
    database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating two tables: `Requests` and `customers`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Requests` table, we have the `name` and `message` fields, and we can
    directly create them in the `onCreate` method of our database helper, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the `customers` table, we will be using a better coding practice by making
    a data class and using it to define the columns of the `customers` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given here is the code for our `Customer` data class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use this data class to create our table like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how our database helper finally looks after filling in the
    code for drop tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s do a fresh install of our app and see whether the two tables have
    been formed in our database. The following is how our database screenshot looks
    (using Stetho), and our tables have successfully been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec9fe063-9d31-49f3-8124-91cf8e725368.png)'
  prefs: []
  type: TYPE_IMG
- en: Injecting dependencies in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, Dagger 2 is the most popular dependency injection framework.
    You define the dependency objects, and with the help of a Dagger component, you
    inject it where you want. In this recipe, we will see how to inject the dependencies.
    We won't be going into the details of how to work with Dagger 2 in detail; for
    that, you can refer to the *Using Dagger2 with Kotlin* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0 for this recipe. Ensure that you have its
    latest version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''ve defined all the dependency objects you need in the module class,
    you can get the component. Let''s take look at the mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To inject the object, you just need to add the `@Inject` annotation before
    the variable, then the object will be injected there. Let’s look at the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have also used the `lateinit` modifier to void null checks before using the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to do it is by constructor injection. To understand it, let’s take
    a look at the given code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have sent `AddActivityPresenter` in the `providesAddActivityPresenter`,
    but the module doesn’t provide it. This usually won’t work unless you provide
    `AddActivityPresnter` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `@Inject` annotation in the constructor, it means that the
    class needs the `DataManager` object before it can be created. Dagger2 will look
    into the dependency tree and provide you the dependency if it can.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to create a database and how to create tables, let's
    learn how to read from a database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3 to write code. You can get started by adding
    anko-sqlite dependencies to your project and creating a SQLite database with the `Requests`
    table in it by going through and implementing the *Using SQLite database in Kotlin* recipe in
    this chapter. By using the form we created in this recipe, add some data to your
    `Requests` table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take look at the given steps to understand how to read data from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a button to our existing layout from the first recipe; on clicking,
    it should retrieve all data from our `Requests` table. Check out the updated code,
    which is as follows, where I have added a button with a click listener on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I am using Anko DSL to create the layout for my activity. As we discussed in
    previous recipes, we do all database operations inside the `database.use{...}`
    block. To read data from the database, we use the `select` function. The syntax
    is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `database.use {...}` , `this` is the database instance, so we can directly
    use methods such as `select` and `insert`. The following is the data and the output
    in the database table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b46f6904-b0f4-486a-b351-e9503fcf68ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot more we can do with the query builder; listed here are the methods
    provided by Anko:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`column(String)`: used to add a column to our `select` query'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct(Boolean)`: used to add distinct to the query'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereArgs(String)`: used to specify the raw `where` string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereArgs(String, args)`: used to specify the `where` query and corresponding
    arguments'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereSimple(String, args) `: used to specify a `where` query with the `?`
    marks and corresponding arguments for `?`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderBy(String, [ASC/DESC])`  : used to specify a column for order by'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupBy(String)`: used to specify a column for group by'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit(count: Int)`: used to limit the number of rows returned by the query'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit(offset: Int, count: Int)`: used to limit the number of rows returned
    by the query after an `offset`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`having(String)`: used to specify the raw `having` expression'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`having(String, args)`: used to specify the raw `having` expression with arguments'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try another example. In this example, we will select data from a database
    using the `where` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the preceding query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the query results, we also need to parse the result. We get a
    cursor as a result from the query and using methods provided by Anko, we can easily
    parse them into regular classes. In the preceding example, we made a class named
    `Request`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The class has all the fields that we may get as columns from our query result
    cursor. The following are the methods that we can use for parsing results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`parseSingle(rowParser): T` : Parses exactly and only one row; if there''s
    more than one row in the cursor, then it throws an exception'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseOpt(rowParser): T?` : Parses zero or one row, but if there''s more than
    one row in the cursor, then it throws an exception'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parseList(rowParser): List<T>`  : Parses zero or more rows'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We used `parseList` in the preceding example. You can pass row parsers or map
    parsers, and you can also use `classParser` of the type of your custom class,
    which passes a row parser, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Converting database cursor into list of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to query data from a database table.
    We receive a cursor as result of the query. In this recipe, we will learn how
    to use `parseList` to convert the cursor into a list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project and creating a database helper like we did in the *Using SQLite
    database in Kotlin* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to convert the cursor into a list of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `Customer` class as a model for our `customers`
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will write code to create the `customers` table inside the database
    helper class. Check out the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a form to enter customers and a button that shows all customers
    in the database table using the `select` function. We will use the `parseList`
    method to get rows in the resulting cursor as a `List`. We need to pass in a row
    parser or map parser inside the `parseList` method. The easiest way of doing this
    is using `classParser` provided by Anko and using our `Customer` class constructor
    to get a row parser, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I suggest that you try this exercise on your own before moving to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is my version of the activity that also contains DSL layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The result of the query, that is, `customers`, is the list of objects that we
    can now iterate on to get individual rows as objects of the `Customer` class.
  prefs: []
  type: TYPE_NORMAL
- en: Using parseOpt for nullable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use `parseList` when we get multiple rows in our cursor, but when we get
    only one row, we use `parseSingle` or `parseOpt`. However, what is the difference
    between `parseSingle` and `parseOpt`?  In this recipe, we will understand the
    difference between both and when to use which one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project and creating a database helper, like we did in the *Using SQLite
    database in Kotlin* recipe. You will need to read and implement the previous recipe
    to be able to follow this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have read and implemented the previous recipe, you must already have
    a `customers` table in your database. Follow the mentioned steps to understand
    the difference between `parseSingle` and `parseOpt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous recipe, we used `parseList` to get a list of rows as objects.
    If we need to get only a single row as an object, then we need to use `parseSingle`.
    The following is the syntax of `parseSingle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we use it in the following way in our previous code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `parseSingle` because we will only get one row in the cursor,
    but if we get zero rows from the cursor, that is, we get an empty cursor, then
    we get an exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, what if there is a possibility of getting an empty cursor when we are
    expecting a cursor with a single row? It will always throw an exception, that
    is, when we use `parseOpt`; `parseOpt` accepts zero or one rows of cursors. Also,
    if `parseOpt` gets a null object, it handles the scenario accordingly by giving
    the value of `null` for each column. Basically, `parseOpt` is used for cursors
    that can be empty and objects that can be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for `parseOpt` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parseOpt(rowParser): T?` // The `?` denotes that the object returned is nullable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we will use it in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now even if the cursor returned is empty, we do not get an exception, and `null`
    values are printed as output.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output in case of an empty table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Inserting data into database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inserting data into the database using Anko SQLite is a piece of cake. In this
    recipe, we will learn how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll be using Android Studio 3 to write code. You can get started by adding anko-sqlite dependencies
    to your project by adding the following lines to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can replace `$anko_version` with the latest version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s insert data into our database by following the mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our database helper, in which we will be creating a `Requests`
    table with the `name`, `message`, and `id` fields, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create an activity with a form that takes the name and message
    and stores it in the database. I am using Anko DSL layouts for the layout of the
    activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the code in bold in the preceding code snippet. We will do all operations
    inside the `database.use {...}` block, because it is concurrency safe and also
    closes the database after execution of the block. If you have gone through the *Creating
    database tables* recipe, you will note that table creation and insertion is quite
    similar. The syntax is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c7459ff-469b-44d1-9cc7-3a6d8bda109c.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On entering the data, we can check whether our name and message are being stored
    in our database or not. I am using Stetho to view the database on my device.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a67fa84-0ab5-4579-b89f-319c062d8780.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating singletons in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singleton class is a class that can have only one instance/object of that
    class at a time. The concept is to restrict instantiation of objects to a certain
    number. In this recipe, we will explore singletons in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio 3 to write code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create singletons in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin does not have static members or variables, so for declaring static members
    of a class, we use `companion object`. Check out this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the members and methods of `companion` object of the preceding class
    is the same as we would do for any static members or methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what if we want a singleton class, that is, the class with only one object/instance
    at a time? Brace yourselves, this one is fun. Here''s a way to create a singleton
    class in just a few lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we use it just like the static members in the preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, decompiling bytecode is always a great way to know what is happening
    behind the scenes. If we decompile the bytecode of the object we created, we get
    the following code, which shows that behind the scenes, the object is just a class
    with a single instance at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using Dagger 2 with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dagger 2 is the best dependency injection framework in the Android community
    and is also open source. It is backed by Google and is widely used. Dependency
    injection is considered best practice and makes your code base scalable. In this
    recipe, we will learn how to use Dagger 2 for dependency injection in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using Android Studio 3.0 for coding purposes. First, we need to include
    Dagger 2 in the project, by adding the following lines to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You need to replace `$daggerVersion` with the latest version of Dagger2.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move ahead, we need to understand how Dagger2 works. Dagger2 uses
    annotation to generate codes and uses it to access fields; therefore, it can't
    use private fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following annotations are used in Dagger2:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Module` and `@Provides`: Define classes and methods that provide dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Inject`: Requests dependencies, and can be used on a constructor, a field,
    or a method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Component`: Enables selected modules and is used for performing dependency
    injection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The classes annotated with `@Module` are responsible for providing objects
    that can be injected. The methods that provide those objects need to be annotated
    with `@Provides`. If the method requires another object to create a dependency
    object, they are provided in the method parameters. Dagger2 creates a dependency
    tree and checks whether the parameters can be supplied or not. Let''s take a look
    at the implementation of a module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at an example of a network module that will supply objects such
    as `HttpCache`, `HttpLoggingInterceptor`, GSON object, and such:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we annotated every method that provides an object through dependency
    injection with the `@Provides` annotation. We have also used the `@Singleton`
    annotation, which means that a singleton object is provided by the method.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice, we've used other objects to create injectable objects, which
    we've provided as parameters. Those parameters should be available either from
    outside or from other injected objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at an example of the `Dagger` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The component acts as an interface that tells us from which modules (or other
    components) the dependencies are met. In the preceding example, we created a component
    that will provide us with the dependency objects from `AddActivityModule` and
    another `ApplicationComponent` component.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined an inject method, which takes in a parameter (`AddActivity`
    here) that tells us where the objects will be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, we can inject it into our `AddActivity`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use our `AddActivityComponent` (now prefixed with *Dagger*)
    to inject our `AddActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have marked our dependency objects using the `@Inject` annotation,
    which means objects will be injected here. We've also added the `lateinit` modifier
    to prevent us from null checks every time we access it. Adding the `@Inject` annotation
    means that you want an object there, and dagger will then look into its components
    and dependencies to provide you that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that module class, you can instantiate the object at constructor
    level. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, adding the `@Inject` annotation to constructor means
    that the class needs the `DataManager` object before it can be created. Dagger
    will look into its dependency tree (in its component) and create `AddActivityPresenter`,
    if present.
  prefs: []
  type: TYPE_NORMAL
- en: Using Butterknife with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android world has many libraries that require annotation processing. You
    just annotate the code, and it generates all the code behind the scenes for you,
    making your life easier. Many libraries such as Butterknife and Dagger2 work in
    similar ways. In this recipe, we will learn how to use Butterknife with Kotlin.
    For those who aren't familiar with Butterknife, it's a library that binds a view
    to a field without needing the `findViewById` calls. It's a household name in
    the Android development world. In Kotlin, the Kotlin Android Extension does almost
    the same work and is bundled along with Kotlin. However, if you are migrating
    your Java code where you've used Butterknife, this recipe will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0 for coding purposes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To include Butterknife in your project, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, add the following lines to your `build.gradle` file; also, you
    need to add the `kotlin-kapt` plugin and replace `annotationProcessor` with `kapt`.
    `kapt` is the Java equivalent of `annotationProcessor`, so wherever you used `annotationProcessor`,
    you need to replace it with `kapt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, we used the Butterknife library, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve used the `lateinit` modifier, which will save us from declaring
    it nullable. We can also implement click listeners, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to understand the working of annotation processors. They basically
    act as a hook for the compiler to analyze the source code for defined annotations,
    and handle them by producing compiler errors, warnings, or extra code in their
    place. This makes writing apps faster, because you just have to annotate and the
    compiler will generate all the necessary code for you behind the scenes. Dagger
    2 is a popular library that works this way.
  prefs: []
  type: TYPE_NORMAL
