<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Discovering Kernel, HAL, and Virtual Hardware</h1>
            </header>

            <article>
                
<p>Once we set up the development environment and get the source code ready to use. We can start to explore the Android system architecture in more depth. We will look at the AOSP source tree first. After that, we will study the virtual hardware platforms that we are going to use in this book. Based on our understanding of the virtual hardware, we will look at the layers related to the system customization. In this chapter, we will cover the following topics:</p>
<ul>
<li>Deep analysis of Android HAL using the goldfish lights service</li>
<li>Review the hardware specification for goldfish</li>
<li>Overview about QEMU pipe implementation in the goldfish kernel</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">What is inside the AOSP?</h1>
            </header>

            <article>
                
<p>Before we move to the details, let's take a look at the top level of the AOSP source code tree again:</p>
<div class="CDPAlignCenter CDPAlign"><img height="173" width="505" class=" image-border" src="assets/image_03_001.png"/></div>
<p>The following table gives a brief description about each folder. We will look at some of them throughout this book:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Directory</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>packages</kbd></p>
</td>
<td>
<p>Stock Android applications.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>libcore</kbd></p>
</td>
<td>
<p>Core Java library. Apache Harmony is used before Nougat. OpenJDK is used with Nougat. Some features of Java 8 are used in Nougat.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>frameworks/*</kbd></p>
</td>
<td>
<p>Android framework core components.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>frameworks/base/services</kbd></p>
</td>
<td>
<p>Android system services.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>art</kbd></p>
</td>
<td>
<p>Android runtime.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dalvik</kbd></p>
</td>
<td>
<p>Dalvik virtual machine.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>libnativehelper</kbd></p>
</td>
<td>
<p>Helper functions for use with JNI.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>system/*</kbd></p>
</td>
<td>
<p>Native services and libraries.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>system/core</kbd></p>
</td>
<td>
<p>A minimal Linux system to boot Android.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>bionic</kbd></p>
</td>
<td>
<p>C library.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>external</kbd></p>
</td>
<td>
<p>External projects imported into the AOSP. It includes both the HAL layer and system services.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hardware</kbd></p>
</td>
<td>
<p>HAL and hardware libraries.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>device</kbd></p>
</td>
<td>
<p>Device-specific files and components.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>bootable</kbd></p>
</td>
<td>
<p>Recovery and bootloader.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>abi</kbd></p>
</td>
<td>
<p>Minimal C++ runtime type information support.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>build</kbd></p>
</td>
<td>
<p>Build system and Makefiles.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sdk</kbd></p>
</td>
<td>
<p>Android SDK.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>cts</kbd></p>
</td>
<td>
<p>Compatibility test suite.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>development</kbd></p>
</td>
<td>
<p>Development tools.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ndk</kbd></p>
</td>
<td>
<p>Android NDK.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>tools</kbd></p>
</td>
<td>
<p>Various IDE tools.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>prebuilts</kbd></p>
</td>
<td>
<p>Prebuilt images and binaries.</p>
</td>
</tr>
</tbody>
</table>
<p>For a particular module or component, we may have to dig into multiple levels of subfolders to figure out what is included in it. This is especially true for the <kbd>frameworks</kbd>, <kbd>system</kbd>, and <kbd>external</kbd> folders. The subfolders in <kbd>frameworks</kbd> include Android framework layer code, but Android system services also reside in <kbd>frameworks/base/services</kbd> and we will look at them later in this session. The same is true for the contents in the <kbd>system</kbd> and <kbd>external</kbd> folders.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android emulator HAL</h1>
            </header>

            <article>
                
<p>We built the Android emulator in <span class="ChapterrefPACKT"><a href="984e0cef-7bf6-4454-bede-bb34c553be12.xhtml">Chapter 2</a>, <em>Setting Up the Development Environment</em></span>. In order to have an overview of Android emulator HAL, we can take a look at the <kbd>$OUT/system/lib/hw</kbd> folder as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="146" width="507" class=" image-border" src="assets/image_03_002.png"/></div>
<p>We can see that there is a list of shared libraries. These are the shared libraries of goldfish HAL. The source code of the preceding shared libraries can be found in the <kbd>device/generic/goldfish</kbd> folder. The following table shows the relationship between the shared library, device node, and hardware module:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Hardware</strong></p>
</td>
<td>
<p><strong>Device</strong></p>
</td>
<td>
<p><strong>Lib (HAL)</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>audio</kbd></p>
</td>
<td>
<p><kbd>/dev/eac</kbd></p>
</td>
<td>
<p><kbd>audio.primary.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>camera</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>camera.goldfish.jpeg.so</kbd><br/>
<kbd>camera.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>fingerprint</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>fingerprint.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>gps</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>gps.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>lights</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>lights.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>power</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>power.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>sensors</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>sensors.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>vibrator</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>vibrator.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>graphics</kbd></p>
</td>
<td>
<p><kbd>/dev/qemu_pipe</kbd></p>
</td>
<td>
<p><kbd>gralloc.goldfish.so</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>serial</kbd></p>
</td>
<td>
<p><kbd>/dev/ttyS[0 - 2]</kbd></p>
</td>
<td>
<p>simple device don't need a separate shared library</p>
</td>
</tr>
</tbody>
</table>
<p>As we can see from the preceding table, except for the serial port and audio, all the other hardware modules use a device node <kbd>/dev/qemu_pipe</kbd> to talk to the kernel. The QEMU pipe device provides a bridge between emulated devices and Android emulator. Since the QEMU pipe is an important device for the emulator, we will introduce it later in this chapter.</p>
<p>Usually, the HAL implementation is a shared library and it will be loaded by system service at runtime. It actually depends on the complexity of the hardware itself when it comes to deciding the actual implementation. For example, there is no separate shared library for simple hardware such as serial ports. The system service implementation of a serial port accesses the device node directly.</p>
<p>For more complicated hardware devices, such as graphics, there is a dedicated daemon SurfaceFlinger running in the background as well as multiple shared libraries associated with it.</p>
<p>In this chapter, we will analyze the HAL of device goldfish lights and use it as an example to understand the relationship between frameworks, system servers, and HAL implementation. After that, we will go through the hardware interface for goldfish devices. Finally, we will analyze the QEMU pipe implementation in the goldfish kernel.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Calling sequence</h1>
            </header>

            <article>
                
<p>We will use the lights hardware interface as an example to explain how HAL, system services, and hardware managers work together.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="437" width="410" class=" image-border" src="assets/image_03_003.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Lights HAL, system service, and hardware manager</div>
<p>As shown in the preceding figure, when an application wants to access hardware resources, it has to get an instance of the hardware manager first. For goldfish lights, the code in the application may look as follows:</p>
<pre>
LightsManager lights =  <br/>LocalServices.getService(LightsManager.class); <br/>mBacklight = lights.getLight(LightsManager.LIGHT_ID_BACKLIGHT); <br/>mBacklight.setBrightness(brightness); 
</pre>
<p>The hardware manager talks to the system service to get hardware access. Usually, the hardware manager is implemented in Java. It calls to the system service using a binder interface since the hardware manager and system service run in different process spaces. The upper layer of the system service also implements in Java. After the system service gets the request, it will call to HAL library using JNI since the HAL is implemented using C or C++ usually.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="304" width="518" class=" image-border" src="assets/image_03_004.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Calling sequence of lights service</div>
<p>The preceding figure shows the calling sequence when an application wants to change the light on the device. We will use a bottom-up approach in this section to look at the calling sequence from HAL to the application layer.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Goldfish lights HAL</h1>
            </header>

            <article>
                
<p>The goldfish lights HAL implementation can be found in the <kbd>$AOSP/device/generic/goldfish/lights</kbd> folder. To implement the HAL layer, the hardware vendor usually needs to implement the following three data structures:</p>
<pre>
struct hw_module_t; <br/>struct hw_module_methods_t; <br/>struct hw_device_t; 
</pre>
<p>All the preceding three data structures are implemented in the <kbd>lights_qemu.c</kbd> file for goldfish. In the HAL implementation, we need to define <kbd>struct hw_module_t</kbd> named <kbd>HAL_MODULE_INFO_SYM</kbd> first as follows. This registers the hardware module ID <kbd>LIGHTS_HARDWARE_MODULE_ID</kbd> in the system. After this, lights system service can get the module using the <kbd>hw_get_module</kbd> function:</p>
<pre>
/* <br/> * The emulator lights Module <br/> */ <br/>struct hw_module_t HAL_MODULE_INFO_SYM = { <br/>    .tag = HARDWARE_MODULE_TAG, <br/>    .version_major = 1, <br/>    .version_minor = 0, <br/>    .id = LIGHTS_HARDWARE_MODULE_ID, <br/>    .name = "Goldfish lights Module", <br/>    .author = "The Android Open Source Project", <br/>    .methods = &amp;lights_module_methods, <br/>}; 
</pre>
<p>You may notice that the <kbd>method</kbd> field has a pointer of <kbd>lights_module_methods</kbd> inside the preceding data structure. It is defined as follows:</p>
<pre>
static struct hw_module_methods_t lights_module_methods = { <br/>    .open =  open_lights, <br/>}; 
</pre>
<p>This defines the second HAL data structure <kbd>hw_module_methods_t</kbd>. Inside this data structure, it defines an <kbd>open_lights</kbd> method, which is the HAL function to initialize the hardware. Let's take a look at this function as follows:</p>
<pre>
/** Open a new instance of a lights device using name */ <br/>static int <br/>open_lights( const struct hw_module_t* module, char const *name, <br/>struct hw_device_t **device ) <br/>{ <br/>    void* set_light; <br/><br/>    if (0 == strcmp( LIGHT_ID_BACKLIGHT, name )) { <br/>      set_light = set_light_backlight; <br/>    } else if (0 == strcmp( LIGHT_ID_KEYBOARD, name )) { <br/>      set_light = set_light_keyboard; <br/>    } else if (0 == strcmp( LIGHT_ID_BUTTONS, name )) { <br/>      set_light = set_light_buttons; <br/>    } else if (0 == strcmp( LIGHT_ID_BATTERY, name )) { <br/>      set_light = set_light_battery; <br/>    } else if (0 == strcmp( LIGHT_ID_NOTIFICATIONS, name )) { <br/>      set_light = set_light_notifications; <br/>    } else if (0 == strcmp( LIGHT_ID_ATTENTION, name )) { <br/>       set_light = set_light_attention; <br/>    } else { <br/>        D( "%s: %s light isn't supported yet.", __FUNCTION__, name ); <br/>        return -EINVAL; <br/>    } <br/><br/>struct light_device_t *dev = <br/>    malloc( sizeof(struct light_device_t) ); <br/>    if (dev == NULL) { <br/>        return -EINVAL; <br/>    } <br/>    memset( dev, 0, sizeof(*dev) ); <br/><br/>    dev-&gt;common.tag = HARDWARE_DEVICE_TAG; <br/>    dev-&gt;common.version = 0; <br/>    dev-&gt;common.module = (struct hw_module_t*)module; <br/>    dev-&gt;common.close = (int (*)(struct hw_device_t*))close_lights; <br/>    dev-&gt;set_light = set_light; <br/><br/>    *device = (struct hw_device_t*)dev; <br/>    return 0; <br/>} 
</pre>
<p>Inside <kbd>open_lights</kbd>, it allocates the memory for the <kbd>light_device_t</kbd> data structure, which inherits the third HAL data structure, <kbd>hw_device_t</kbd>. When it initializing the data structure <kbd>light_device_t</kbd>, it registers two functions, <kbd>close_lights</kbd> and <kbd>set_light</kbd>, so the system service can call these functions to change the light or close the device. The function pointer <kbd>set_light</kbd> is set to a specific function according to the type of light.</p>
<p>Inside each <kbd>set_light_xxx</kbd> function, it talks to the kernel space through the QEMU pipe device <kbd>/dev/qemu_pipe</kbd>. For example, we can take a look at <kbd>set_light_backlight</kbd>:</p>
<pre>
static int <br/>set_light_backlight( struct light_device_t* dev, struct light_state_t const* state ) <br/>{ <br/>    /* Get Lights service. */ <br/>    intfd = qemud_channel_open( LIGHTS_SERVICE_NAME ); <br/><br/>    if (fd &lt; 0) { <br/>      ... <br/><br/>    /* send backlight command to perform the backlight setting. */ <br/>    if (qemud_channel_send( fd, buffer, -1 ) &lt; 0) { <br/>        E( "%s: could not query lcd_backlight: %s",<br/>        __FUNCTION__, strerror(errno) ); <br/>        close( fd ); <br/>        return -1; <br/>    } <br/><br/>    close( fd ); <br/>    return 0; <br/>} 
</pre>
<p>Inside the <kbd>set_light_backlight</kbd> function, it calls <kbd>qemud_channel_open</kbd> and <kbd>qemud_channel_send</kbd> to do the actual work. Both functions use the QEMU pipe device <kbd>/dev/qemu_pipe</kbd> eventually.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The system service and hardware manager</h1>
            </header>

            <article>
                
<p>To analyze how the application accesses light hardware, refer to the figure of the lights service calling sequence. In an application, what calls the <kbd>getService(LightsManager.class)</kbd> function to get an instance of <kbd>LightsManager</kbd> as follows:</p>
<pre>
LightsManager lights =  <br/>LocalServices.getService(LightsManager.class); <br/>mBacklight = lights.getLight(LightsManager.LIGHT_ID_BACKLIGHT); 
</pre>
<p>Usually the hardware manager and system service are implemented in different processes for most hardware interfaces. However, the hardware of the light is so simple, so both the system service and hardware manager are implemented in the same process.</p>
<p>The system service includes two parts: Java and JNI. The JNI implementation can be found at <kbd>frameworks/base/services/core/jni</kbd>, while the Java implementation can be found at <kbd>frameworks/base/services/core/java/com/android/server</kbd>. Both <kbd>LightsManager</kbd> and <kbd>LightsService</kbd> are implemented in <kbd>frameworks/base/services/core/java/com/android/server/lights</kbd>.</p>
<p>There are three files in this folder as follows. They implement both <kbd>LightsManager</kbd> and <kbd>LightsService</kbd>:</p>
<pre>
<strong>$ ls</strong><br/><strong>Light.java  LightsManager.java  LightsService.java</strong>  
</pre>
<p>Let's look at <kbd>LightsManager</kbd> first. We can see from the following snippet that <kbd>LightsManager</kbd> only returns an abstract class, <kbd>Light</kbd>, to the caller:</p>
<pre>
package com.android.server.lights; <br/><br/>public abstract class LightsManager { <br/>    public static final intLIGHT_ID_BACKLIGHT = 0; <br/>    public static final intLIGHT_ID_KEYBOARD = 1; <br/>    public static final intLIGHT_ID_BUTTONS = 2; <br/>    public static final intLIGHT_ID_BATTERY = 3; <br/>    public static final intLIGHT_ID_NOTIFICATIONS = 4; <br/>    public static final intLIGHT_ID_ATTENTION = 5; <br/>    public static final intLIGHT_ID_BLUETOOTH = 6; <br/>    public static final intLIGHT_ID_WIFI = 7; <br/>    public static final intLIGHT_ID_COUNT = 8; <br/><br/>    public abstract Light getLight(int id); <br/>} 
</pre>
<p>Let's follow the code to look at the abstract class <kbd>Light</kbd>. In the abstract class <kbd>Light</kbd>, it defines a list of functions that have to be implemented for <kbd>Light</kbd>. These functions are implemented in the <kbd>LightsService</kbd> class:</p>
<pre>
package com.android.server.lights; <br/><br/>public abstract class Light { <br/>    public static final intLIGHT_FLASH_NONE = 0; <br/>    public static final intLIGHT_FLASH_TIMED = 1; <br/>    public static final intLIGHT_FLASH_HARDWARE = 2; <br/><br/>    /** <br/>     * Light brightness is managed by a user setting. <br/>     */ <br/>    public static final intBRIGHTNESS_MODE_USER = 0; <br/><br/>    /** <br/>     * Light brightness is managed by a light sensor. <br/>     */ <br/>    public static final intBRIGHTNESS_MODE_SENSOR = 1; <br/><br/>    public abstract void setBrightness(int brightness); <br/>    public abstract void setBrightness(int brightness, <br/>    intbrightnessMode); <br/>    public abstract void setColor(int color); <br/>    public abstract void setFlashing(int color, int mode, intonMS, <br/>    intoffMS); <br/>    public abstract void pulse(); <br/>    public abstract void pulse(int color, intonMS); <br/>    public abstract void turnOff(); <br/>} 
</pre>
<p>In <kbd>LightsService.java</kbd> in the following snippet, it implements the list of functions defined by the <kbd>Light</kbd> class:</p>
<pre>
... <br/>private final class LightImpl extends Light { <br/><br/>        private LightImpl(int id) { <br/>            mId = id; <br/>        } <br/><br/>        @Override <br/>        public void setBrightness(int brightness) { <br/>            setBrightness(brightness, BRIGHTNESS_MODE_USER); <br/>        } <br/>... 
</pre>
<p>This set of functions in the abstract class <kbd>Light</kbd> calls a <kbd>setLightLocked</kbd> function to do the actual work. In this function, it calls a native function, <kbd>setLight_native</kbd>, to invoke the native part of <kbd>LightsService</kbd>:</p>
<pre>
private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) { <br/>     if (color != mColor || mode != mMode || onMS != mOnMS<br/>     || offMS != mOffMS) { <br/>         if (DEBUG) Slog.v(TAG, "setLight #" + mId + ": color=#" <br/>                 + Integer.toHexString(color)); <br/>         mColor = color; <br/>         mMode = mode; <br/>         mOnMS = onMS; <br/>         mOffMS = offMS; <br/>         Trace.traceBegin(Trace.TRACE_TAG_POWER, <br/>         "setLight(" + mId + ", 0x" +  <br/>         Integer.toHexString(color) + ")"); <br/>         try { <br/><strong>              setLight_native</strong>(mNativePointer, <br/>              mId, color, mode, onMS, offMS, <br/>              brightnessMode); <br/>         } finally { <br/>             Trace.traceEnd(Trace.TRACE_TAG_POWER); <br/>         } <br/>     } <br/>} 
</pre>
<p>Besides <kbd>setLight_native</kbd>, <kbd>LightService</kbd> also calls two more native functions, <kbd>init_native</kbd> and <kbd>finalize_native</kbd>. We can see this in the following code snippet. These two functions call to the HAL layer functions, as we discussed in the previous section:</p>
<pre>
public LightsService(Context context) { <br/>    super(context); <br/><br/>    mNativePointer = <strong>init_native</strong>(); <br/><br/>    for (inti = 0; i&lt;LightsManager.LIGHT_ID_COUNT; i++) { <br/>      mLights[i] = new LightImpl(i); <br/>    } <br/>} <br/><br/>... <br/><br/>@Override <br/>protected void finalize() throws Throwable { <br/><strong>    finalize_native</strong>(mNativePointer); <br/>    super.finalize(); <br/>} <br/><br/>... <br/><br/>private static native long <strong>init_native()</strong>; <br/>private static native void <strong>finalize_native</strong>(long ptr); <br/><br/>static native void <strong>setLight_native</strong>(long ptr, int light, int color, int mode, int onMS, int offMS, int brightnessMode); 
</pre>
<p>We have looked at the implementation of <kbd>LightsManager</kbd> and the Java implementation of <kbd>LightsService</kbd>. Now let's explore the JNI part of the <kbd>LightsService</kbd> implementation. The JNI part is implemented in <kbd>com_android_server_lights_LightsService.cpp</kbd>, which can be found in the <kbd>$AOSP/frameworks/base/services/core/jni</kbd> folder. We will look at how these three native functions used in <kbd>LightsService</kbd> are connected to the HAL layer:</p>
<pre>
static jlong init_native(JNIEnv* /* env */, jobject /* clazz */) <br/>{ <br/>    int err; <br/>    hw_module_t* module; <br/>    Devices* devices; <br/><br/>    devices = (Devices*)malloc(sizeof(Devices)); <br/><br/>    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID,  <br/>        (hw_module_tconst**)&amp;module); <br/>    if (err == 0) { <br/>        devices-&gt;lights[LIGHT_INDEX_BACKLIGHT] <br/>                = get_device(module, LIGHT_ID_BACKLIGHT); <br/>        devices-&gt;lights[LIGHT_INDEX_KEYBOARD] <br/>                = get_device(module, LIGHT_ID_KEYBOARD); <br/>        devices-&gt;lights[LIGHT_INDEX_BUTTONS] <br/>                = get_device(module, LIGHT_ID_BUTTONS); <br/>        devices-&gt;lights[LIGHT_INDEX_BATTERY] <br/>                = get_device(module, LIGHT_ID_BATTERY); <br/>        devices-&gt;lights[LIGHT_INDEX_NOTIFICATIONS] <br/>                = get_device(module, LIGHT_ID_NOTIFICATIONS); <br/>        devices-&gt;lights[LIGHT_INDEX_ATTENTION] <br/>                = get_device(module, LIGHT_ID_ATTENTION); <br/>        devices-&gt;lights[LIGHT_INDEX_BLUETOOTH] <br/>                = get_device(module, LIGHT_ID_BLUETOOTH); <br/>        devices-&gt;lights[LIGHT_INDEX_WIFI] <br/>                = get_device(module, LIGHT_ID_WIFI); <br/>    } else { <br/>        memset(devices, 0, sizeof(Devices)); <br/>    } <br/><br/>    return (jlong)devices; <br/>} 
</pre>
<p>In the <kbd>init_native</kbd> function, it calls the <kbd>hw_get_module</kbd> function to get the light HAL module using <kbd>LIGHTS_HARDWARE_MODULE_ID</kbd> as the hardware ID. If you look back, it is defined in the HAL. This function loads the shared library of HAL implementations. In this case, it loads <kbd>lights.goldfish.so</kbd>. After loading the shared library, it calls <kbd>get_device</kbd> to initialize all the light devices. We can see the implementation of <kbd>get_device</kbd> in the following snippet:</p>
<pre>
static light_device_t* get_device(hw_module_t* module, char const* name) <br/>{ <br/>    int err; <br/>    hw_device_t* device; <br/>    err = module-&gt;methods-&gt;open(module, name, &amp;device); <br/>    if (err == 0) { <br/>        return (light_device_t*)device; <br/>    } else { <br/>        return NULL; <br/>    } <br/>} 
</pre>
<p>In <kbd>get_device</kbd>, it invokes the <kbd>open</kbd> method and gets the instance of HAL data structure <kbd>hw_device_t</kbd>. We discussed the <kbd>open</kbd> method in the goldfish lights HAL.</p>
<p>Now let's look at another native function, <kbd>setLight_native</kbd>:</p>
<pre>
static void setLight_native(JNIEnv* /* env */, jobject /* clazz */, jlong ptr, jint light, jint colorARGB, jint flashMode, jint onMS, jint offMS, jint brightnessMode) <br/>{ <br/>    Devices* devices = (Devices*)ptr; <br/>    light_state_t state; <br/><br/>    if (light &lt; 0 || light &gt;= LIGHT_COUNT || devices-&gt;lights[light] == <br/>    NULL) { <br/>        return ; <br/>    } <br/><br/>    memset(&amp;state, 0, sizeof(light_state_t)); <br/>    state.color = colorARGB; <br/>    state.flashMode = flashMode; <br/>    state.flashOnMS = onMS; <br/>    state.flashOffMS = offMS; <br/>    state.brightnessMode = brightnessMode; <br/><br/>    { <br/>        ALOGD_IF_SLOW(50, "Excessive delay setting light"); <br/>        devices-&gt;lights[light]-&gt;<strong>set_light</strong>(devices-&gt;lights[light], <br/>        &amp;state); <br/>    } <br/>} 
</pre>
<p>In the <kbd>setLight_native</kbd> function, it gets the pointer of the data structure <kbd>Devices</kbd> first. After that, it calls the HAL function <kbd>set_light</kbd> to do the actual work.</p>
<p>Finally, let's look at the implementation of the native method, <kbd>finalize_native</kbd>:</p>
<pre>
static void finalize_native(JNIEnv* /* env */, jobject /* clazz */, jlong ptr) <br/>{ <br/>    Devices* devices = (Devices*)ptr; <br/>    if (devices == NULL) { <br/>        return; <br/>    } <br/><br/>    free(devices); <br/>} 
</pre>
<p>We can see that the <kbd>finalize_native</kbd> function just frees all resources used.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android emulator kernel and hardware</h1>
            </header>

            <article>
                
<p>We use goldfish lights as an example to perform the calling sequence analysis from an application to the goldfish HAL. Now we can look at the kernel layer and the underlying hardware. We can also take an overview from the top to the bottom again to understand how the entire system works.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="577" width="648" class=" image-border" src="assets/image_03_005.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">The goldfish architecture</div>
<p>We use the preceding figure to explain goldfish kernel and hardware in detail. As you can see, the preceding figure is similar to the architecture diagram that we saw in <span class="ChapterrefPACKT"><a href="4ddc5eff-b4d7-452c-b83c-0c3c1d40da57.xhtml">Chapter 1</a>, <em>Introduction to Android System Programming</em></span>. This architecture diagram is the general architecture diagram for Android, but the preceding figure is specific to goldfish.</p>
<p>From the diagram, we can see the parts that we are interested in the goldfish kernel and emulator hardware. From the top to the bottom, the application utilizes the Android framework to implement functionalities and access the hardware. The framework usually resides in a different process from the system service layer, so they use Binder IPC to communicate with each other. The system service talks to the <strong>HAL</strong> using <strong>JNI</strong>, since <strong>HAL</strong> usually implements in the native language. The <strong>HAL</strong> is the user space implementation of hardware control and it communicates to the device driver in the kernel space through system calls. In the case of the goldfish hardware, the device driver accesses the virtual hardware through memory I/O registers, as we will see in the following section on Android emulator hardware.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Android emulator hardware</h1>
            </header>

            <article>
                
<p>Unlike real hardware, most Android emulator hardware interfaces are emulated using QEMU, which is a popular open source emulator engine used by many open source projects. The Android development team customized QEMU and added a virtual hardware platform called goldfish. As we mentioned in <span class="ChapterrefPACKT"><a href="984e0cef-7bf6-4454-bede-bb34c553be12.xhtml">Chapter 2</a>, <em>Setting Up the Development Environment</em></span>, there are currently two versions of Android emulator available in the latest SDK. The code name for the original Android emulator is goldfish and the new one is ranchu. However, the virtual hardware code base for device emulation in QEMU is the same for both versions.</p>
<p>Detailed information about goldfish hardware interfaces can be found in the document <kbd>GOLDFISH-VIRTUAL-HARDWARE.TXT</kbd>. This document can be found in the AOSP source code at <kbd>$AOSP/platform/external/qemu/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT</kbd>.</p>
<p>For different kernel versions, the hardware interfaces may have some differences. In this book, we will look at the Intel x86-based ranchu virtual hardware, which uses Android Linux version 3.10.0. Let's look at the goldfish devices that we will discuss in this chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Goldfish platform bus</h1>
            </header>

            <article>
                
<p>In the architecture diagram for goldfish, we have a detailed diagram for the kernel and goldfish hardware. We can see that all goldfish devices are enumerated through the goldfish platform bus. The platform bus is a special device that is capable of enumerating other platform devices found on the system to the kernel. This flexibility allows us to customize which virtual devices are available when running a given emulated system configuration. The following table defines goldfish platform bus registers.</p>
<p><strong>Goldfish platform bus 32-bit I/O registers</strong>:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Offset</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Abstract</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x00</kbd></p>
</td>
<td>
<p><kbd>BUS_OP</kbd></p>
</td>
<td>
<p>R: Iterate to the next device in enumeration.</p>
<p>W: Start device enumeration.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x04</kbd></p>
</td>
<td>
<p><kbd>GET_NAME</kbd></p>
</td>
<td>
<p>W: Copy device name to kernel memory.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x08</kbd></p>
</td>
<td>
<p><kbd>NAME_LEN</kbd></p>
</td>
<td>
<p>R: Read length of current device's name.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x0c</kbd></p>
</td>
<td>
<p><kbd>ID</kbd></p>
</td>
<td>
<p>R: Read ID of the current device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x10</kbd></p>
</td>
<td>
<p><kbd>IO_BASE</kbd></p>
</td>
<td>
<p>R: Read I/O base address of the current device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x14</kbd></p>
</td>
<td>
<p><kbd>IO_SIZE</kbd></p>
</td>
<td>
<p>R: Read I/O base size of the current device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x18</kbd></p>
</td>
<td>
<p><kbd>IRQ_BASE</kbd></p>
</td>
<td>
<p>R: Read base IRQ of the current device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x1c</kbd></p>
</td>
<td>
<p><kbd>IRQ_COUNT</kbd></p>
</td>
<td>
<p>R: Read IRQ count of the current device.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x20</kbd></p>
</td>
<td>
<p><kbd>NAME_ADDR_HIGH</kbd></p>
</td>
<td>
<p># For 64-bit guest architectures only:</p>
<p>W: Write high 32-bit of kernel address of name buffer used by <kbd>GET_NAME</kbd>. Must be written to before the <kbd>GET_NAME</kbd> write.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">QEMU pipe device</h1>
            </header>

            <article>
                
<p>One of the most important emulated devices in goldfish hardware is the QEMU pipe device. This is a special device that is totally specific to QEMU, but allows guest processes to communicate directly with the emulator with extremely high performance. This is achieved by avoiding any in-kernel memory copies, relying on the fact that QEMU can access guest memory at runtime (under proper conditions controlled by the kernel). As we can see from the goldfish architecture diagram, many other hardware interfaces, such as GPS, sensors, basebands, cameras, and so on, are emulated through the QEMU pipe. The following table defines QEMU pipe device registers.</p>
<p><strong>QEMU pipe device registers</strong>:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Offset</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Abstract</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x00</kbd></p>
</td>
<td>
<p><kbd>COMMAND</kbd></p>
</td>
<td>
<p>W: Write to perform command (see the following).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x04</kbd></p>
</td>
<td>
<p><kbd>STATUS</kbd></p>
</td>
<td>
<p>R: Read status.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x08</kbd></p>
</td>
<td>
<p><kbd>CHANNEL</kbd></p>
</td>
<td>
<p>RW: Read or set current channel ID.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x0c</kbd></p>
</td>
<td>
<p><kbd>SIZE</kbd></p>
</td>
<td>
<p>RW: Read or set current buffer size.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x10</kbd></p>
</td>
<td>
<p><kbd>ADDRESS</kbd></p>
</td>
<td>
<p>RW: Read or set current buffer physical address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x14</kbd></p>
</td>
<td>
<p><kbd>WAKES</kbd></p>
</td>
<td>
<p>R: Read wake flags.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x18</kbd></p>
</td>
<td>
<p><kbd>PARAMS_ADDR_LOW</kbd></p>
</td>
<td>
<p>RW: Read/set low bytes of parameter's block address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x1c</kbd></p>
</td>
<td>
<p><kbd>PARAMS_ADDR_HIGH</kbd></p>
</td>
<td>
<p>RW: Read/set high bytes of parameter's block address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x20</kbd></p>
</td>
<td>
<p><kbd>ACCESS_PARAMS</kbd></p>
</td>
<td>
<p>W: Perform access with parameter block.</p>
</td>
</tr>
</tbody>
</table>
<p>Refer to the AOSP document <kbd>ANDROID-QEMU-PIPE.TXT</kbd> for details about the device's operations.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Goldfish audio device</h1>
            </header>

            <article>
                
<p>The goldfish audio device implements a virtual sound card with the following properties:</p>
<ul>
<li>Stereo output at fixed 44.1 kHz frequency, using signed 16-bit samples. This is mandatory.</li>
<li>Mono input at fixed 8 kHz frequency, using signed 16-bit samples. This is optional.</li>
</ul>
<p>The following table defines goldfish audio device registers:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Offset</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Abstract</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x00</kbd></p>
</td>
<td>
<p><kbd>INT_STATUS</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>0x04</kbd></p>
</td>
<td>
<p><kbd>INT_ENABLE</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>0x08</kbd></p>
</td>
<td>
<p><kbd>SET_WRITE_BUFFER_1</kbd></p>
</td>
<td>
<p>W: Set address of first kernel output buffer.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x0c</kbd></p>
</td>
<td>
<p><kbd>SET_WRITE_BUFFER_2</kbd></p>
</td>
<td>
<p>W: Set address of second kernel output buffer.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x10</kbd></p>
</td>
<td>
<p><kbd>WRITE_BUFFER_1</kbd></p>
</td>
<td>
<p>W: Send first kernel buffer samples to output.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x14</kbd></p>
</td>
<td>
<p><kbd>WRITE_BUFFER_2</kbd></p>
</td>
<td>
<p>W: Send second kernel buffer samples to output.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x18</kbd></p>
</td>
<td>
<p><kbd>READ_SUPPORTED</kbd></p>
</td>
<td>
<p>R: Reads 1 if input is supported, 0 otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x1c</kbd></p>
</td>
<td>
<p><kbd>SET_READ_BUFFER</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>0x20</kbd></p>
</td>
<td>
<p><kbd>START_READ</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>0x24</kbd></p>
</td>
<td>
<p><kbd>READ_BUFFER_AVAILABLE</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p><kbd>0x28</kbd></p>
</td>
<td>
<p><kbd>SET_WRITE_BUFFER_1_HIGH</kbd></p>
</td>
<td>
<p># For 64-bit guest CPUs:</p>
<p>W: Set high 32 bits of the first kernel output buffer address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x30</kbd></p>
</td>
<td>
<p><kbd>SET_WRITE_BUFFER_2_HIGH</kbd></p>
</td>
<td>
<p># For 64-bit guest CPUs:</p>
<p>W: Set high 32 bits of second kernel output buffer address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x34</kbd></p>
</td>
<td>
<p><kbd>SET_READ_BUFFER_HIGH</kbd></p>
</td>
<td>
<p># For 64-bit guest CPUs:</p>
<p>W: Set high 32 bits of kernel input buffer address.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Goldfish serial port</h1>
            </header>

            <article>
                
<p>Android emulator has its own implementation of a virtual serial port. It always reserves the first two virtual serial ports:</p>
<ul>
<li>The first one is used to receive kernel messages. This is done by adding the <kbd>console=ttyS0</kbd> parameter to the kernel command line.</li>
<li>The second one is used to set up the legacy <kbd>qemud</kbd> channel, used on older Android platform revisions. This is done by adding <kbd>android.qemud=ttyS1</kbd> on the kernel command line. The <kbd>qemud</kbd> channel is implemented as a Linux daemon process used as a channel between the guest and emulator. In the latest emulator version, a QEMU pipe is used instead of <kbd>qemud</kbd>.</li>
</ul>
<p>The following table defines goldfish serial port registers:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Offset</strong></p>
</td>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Abstract</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x00</kbd></p>
</td>
<td>
<p><kbd>PUT_CHAR</kbd></p>
</td>
<td>
<p>W: Write a single 8-bit value to the serial port.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x04</kbd></p>
</td>
<td>
<p><kbd>BYTES_READY</kbd></p>
</td>
<td>
<p>R: Read the number of available buffered input bytes.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x08</kbd></p>
</td>
<td>
<p><kbd>CMD</kbd></p>
</td>
<td>
<p>W: Send command (see the following).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x10</kbd></p>
</td>
<td>
<p><kbd>DATA_PTR</kbd></p>
</td>
<td>
<p>W: Write kernel buffer address.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x14</kbd></p>
</td>
<td>
<p><kbd>DATA_LEN</kbd></p>
</td>
<td>
<p>W: Write kernel buffer size.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>0x18</kbd></p>
</td>
<td>
<p><kbd>DATA_PTR_HIGH</kbd></p>
</td>
<td>
<p># For 64-bit guest CPUs only:</p>
<p>W: Write high 32 bits of kernel buffer address.</p>
</td>
</tr>
</tbody>
</table>
<p>The CMD I/O register is used to send various commands to the device, identified by the following values:</p>
<pre>
0x00 CMD_INT_DISABLE   Disable device. <br/>0x01 CMD_INT_ENABLE    Enable device. <br/>0x02 CMD_WRITE_BUFFER  Write buffer from kernel to device. <br/>0x03 CMD_READ_BUFFER   Read buffer from device to kernel. 
</pre>
<p>Each device instance uses one IRQ, raised to indicate that there is incoming/buffered data to read.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Goldfish kernel</h1>
            </header>

            <article>
                
<p>Goldfish kernel can be downloaded from the AOSP source repository. You can download and build the kernel source code using the following command:</p>
<pre>
<strong>$ git clone https://android.googlesource.com/kernel/goldfish.git <br/>$ cd goldfish <br/>$ git checkout -b android-goldfish-3.10 origin/android-goldfish-3.10 <br/>$ make i386_ranchu_defconfig <br/>$ make <br/></strong>
</pre>
<p>The following table is a list of goldfish device drivers. This is based on kernel version 3.10.0. At the moment, kernel version 3.10.0 is for ranchu and 3.4.67 is for goldfish. The following table lists some goldfish specific devices. In ranchu, Virtio devices are used as block devices to simulate EMMC. Virtio devices are paravirtualized devices in QEMU that have better performance than emulated hardware devices.</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Device</strong></p>
</td>
<td>
<p><strong>Path</strong></p>
</td>
</tr>
<tr>
<td>
<p>goldfish platform bus</p>
</td>
<td>
<p><kbd>drivers/platform/goldfish/pdev_bus.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>QEMU pipe</p>
</td>
<td>
<p><kbd>drivers/platform/goldfish/goldfish_pipe.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Frame buffer</p>
</td>
<td>
<p><kbd>drivers/video/goldfishfb.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish audio</p>
</td>
<td>
<p><kbd>drivers/staging/goldfish/goldfish_audio.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish NAND</p>
</td>
<td>
<p><kbd>drivers/staging/goldfish/goldfish_nand.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish battery</p>
</td>
<td>
<p><kbd>drivers/power/goldfish_battery.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish events</p>
</td>
<td>
<p><kbd>drivers/input/keyboard/goldfish_events.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish MMC</p>
</td>
<td>
<p><kbd>drivers/mmc/host/android-goldfish.c</kbd></p>
</td>
</tr>
<tr>
<td>
<p>goldfish serial</p>
</td>
<td>
<p><kbd>drivers/tty/goldfish.c</kbd></p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">QEMU pipe</h1>
            </header>

            <article>
                
<p>Since QEMU pipe is used as a channel to emulate many goldfish devices, we can review one of the major functions, <kbd>goldfish_pipe_read_write</kbd>, to understand data transmission between guest and host:</p>
<pre>
static ssize_t goldfish_pipe_read_write(struct file *filp, char __user *buffer, size_t bufflen, int is_write) <br/>{ <br/>... <br/>    /* Now, try to transfer the bytes in the current page */ <br/>    spin_lock_irqsave(&amp;dev-&gt;lock, irq_flags); <br/>    if (<strong>access_with_param</strong>(dev, is_write ? CMD_WRITE_BUFFER : <br/>    CMD_READ_BUFFER, xaddr, avail, pipe, &amp;status)) { <br/>      writel((u32)(u64)pipe, dev-&gt;base + PIPE_REG_CHANNEL); <br/>#ifdef CONFIG_64BIT <br/>    writel((u32)((u64)pipe &gt;&gt; 32), dev-&gt;base + PIPE_REG_CHANNEL_HIGH); <br/>#endif <br/>    writel(avail, dev-&gt;base + PIPE_REG_SIZE); <br/>    writel(xaddr, dev-&gt;base + PIPE_REG_ADDRESS); <br/>#ifdef CONFIG_64BIT <br/>    writel((u32)((u64)xaddr&gt;&gt; 32), dev-&gt;base + PIPE_REG_ADDRESS_HIGH); <br/>#endif <br/>    writel(is_write ? CMD_WRITE_BUFFER : CMD_READ_BUFFER, <br/>      dev-&gt;base + PIPE_REG_COMMAND); <br/>    status = readl(dev-&gt;base + PIPE_REG_STATUS); <br/>} <br/>    spin_unlock_irqrestore(&amp;dev-&gt;lock, irq_flags); <br/><br/>if (status &gt; 0 &amp;&amp; !is_write) <br/>    set_page_dirty(page); <br/>put_page(page); <br/>... 
</pre>
<p>As we can see from the preceding code, it invokes the <kbd>access_with_param</kbd> function first. This is the fastest way to transfer data between the guest and emulator using shared memory. With this method, the goldfish kernel allocates a piece of memory at boot time. The guest and emulator will use this shared memory to transfer parameters between them. If the <kbd>access_with_param</kbd> function fails, it will use the following sequence to transfer data through the QEMU pipe device:</p>
<pre>
write_channel(&lt;channel&gt;) <br/>write_address(&lt;buffer-address&gt;) <br/>REG_SIZE    = &lt;buffer-size&gt; <br/>REG_CMD     = CMD_WRITE_BUFFER/CMD_READ_BUFFER <br/>status = REG_STATUS 
</pre>
<p>Now let's take a look at the <kbd>access_with_param</kbd> function as follows:</p>
<pre>
/* A value that will not be set by qemu emulator */ <br/>#define INITIAL_BATCH_RESULT (0xdeadbeaf) <br/>static int access_with_param(struct goldfish_pipe_dev *dev, const int cmd, unsigned long address, unsigned long avail, struct goldfish_pipe *pipe, int *status) <br/>{ <br/>   struct access_params *aps = dev-&gt;aps; <br/><br/>   if (aps == NULL) <br/>         return -1; <br/><br/>   aps-&gt;result = INITIAL_BATCH_RESULT; <br/>   aps-&gt;channel = (unsigned long)pipe; <br/>   aps-&gt;size = avail; <br/>   aps-&gt;address = address; <br/>   aps-&gt;cmd = cmd; <br/>   writel(cmd, dev-&gt;base + PIPE_REG_ACCESS_PARAMS); <br/>   /* <br/>    * If the aps-&gt;result has not changed, that means <br/>    * that the batch command failed <br/>    */ <br/>   if (aps-&gt;result == INITIAL_BATCH_RESULT) <br/>         return -1; <br/>   *status = aps-&gt;result; <br/>   return 0; <br/>} 
</pre>
<p>The address of <kbd>aps</kbd> is the pre-allocated shared memory between the guest and emulator. All data structures that need to be used for a single operation are filled in this data structure <kbd>aps</kbd>. The command will be written to register <kbd>PIPE_REG_ACCESS_PARAMS</kbd>. The write to <kbd>PIPE_REG_ACCESS_PARAMS</kbd> will trigger the operation. QEMU will read the content of the <kbd>access_params</kbd> block, use its fields to perform the operation, and then write back the return value into <kbd>aps-&gt;result</kbd>. The difference between shared memory <kbd>aps</kbd> and the QEMU pipe device is similar to DMA and register-based device I/O. The shared memory or DMA is much more efficient in large blocks of memory access.</p>
<p>You can explore the rest of the goldfish device drivers by yourself.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we introduced the content of the AOSP source code. After that, we used goldfish lights HAL as an example to analyze the calling sequence from the application to HAL. Finally, we reviewed the Android architecture again using the Android system for the emulator. We also reviewed goldfish kernel and hardware to understand how they work together with the rest of the software stacks. In the next chapter, we will start to work on our own x86emu device and use it to explore how to extend an emulator to support additional functionalities.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>