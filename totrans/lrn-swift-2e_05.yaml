- en: Chapter 5. A Modern Paradigm – Closures and Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been programming using the paradigm called **object-oriented
    programming**, where everything in a program is represented as an object that
    can be manipulated and passed around to other objects. This is the most popular
    way to create apps because it is a very intuitive way to think about software
    and it goes well with the way Apple has designed their frameworks. However, there
    are some drawbacks to this technique. The biggest one is that the state of data
    can be very hard to track and reason about. If we have a thousand different objects
    floating around in our app, all with different information, it can be hard to
    track down where the bugs occurred and it can be hard to understand how the whole
    system fits together. Another paradigm of programming that can help with this
    problem is called **functional programming**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programming languages are designed to use only functional programming,
    but Swift is designed primarily as an object-oriented language with the ability
    to use functional programming concepts. In this chapter, we will explore how to
    implement these functional programming concepts in Swift and what they are used
    for. To do this, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming philosophy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks of functional programming in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into writing code, let's discuss the ideas and motivations behind
    functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: State and side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming makes it significantly easier to think of each component
    in isolation. This includes things such as types, functions, and methods. If we
    can wrap our minds around everything that is input into these code components
    and everything that should be returned from them, we could analyze the code easily
    to ensure that there are no bugs and it performs well. Every type is created with
    a certain number of parameters and each method and function in a program has a
    certain number of parameters and return values. Normally, we think about these
    as the only inputs and outputs, but the reality is that often there are more.
    We refer to these extra inputs and outputs as **state**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a more general sense, state is any stored information, however temporary,
    that can be changed. Let''s consider a simple `double` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a great example of a **stateless** function. No matter what else is
    happening in the entire universe of the program, this method will always return
    the same value, if it is given the same input. An input of `2` will always return
    `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a method with state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you call this method repeatedly, with the same input on the same `Ball` instance,
    you will get a different result every time. This is because there is an additional
    input in this method, which is the instance it is being called on. It is otherwise
    referred to as `self`. `self` is actually both an input and an output of this
    method, because the original value of radius affects the output and `radius` is
    changed by the end of the method. This is still not very difficult to reason about,
    as long as you keep in mind that `self` is always another input and output. However,
    you can imagine that with a more complex data structure, it can be hard to track
    every possible input and output from a piece of code. As soon as that starts to
    happen, it becomes easier for bugs to get created, because we will almost certainly
    have, unexpected inputs causing unexpected outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Side effects** are an even worse type of extra input or output. They are
    the unexpected changes to state, seemingly unrelated to the code being run. If
    we simply rename our preceding method to something a little less clear, its effect
    on the instance becomes unexpected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Based on its name, you wouldn't expect this method to change the actual value
    of `radius`. This means that if you didn't see the actual implementation, you
    would expect this method to keep returning the same value if called with the same
    amount on the same instance. Unpredictability is a terrible thing to have as a
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In its strictest form, functional programming eliminates all state and therefore
    side effects. We will never go that far in Swift, but we will often use functional
    programming techniques to reduce state and side effects to increase the predictability
    of our code, drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus imperative code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides predictability, the other effect that functional programming has on
    our code is that it becomes more **declarative**. This means that the code shows
    us how we expect information to flow through our application. This is in contrast
    to what we have been doing with object-oriented programming, which we call **imperative
    code**. This is the difference between writing a code that loops through an array
    to add only certain elements to a new array and running a filter on the array.
    The former would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a filter on the array would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if you don't understand the second example yet. This is what we
    are going to cover in the rest of this chapter. The general idea is that with
    imperative codes, we are going to issue a series of commands with the intent of
    the code as a secondary, subtler idea. To understand that we are creating a copy
    of `originalArray` with only elements greater than `3`, we have to read the code
    and mentally step through what is happening. In the second example, we are stating
    in the code itself that we are filtering the original array. Ultimately, these
    ideas exist on a spectrum and it is hard to have something be 100% declarative
    or imperative, but the principles of each are important.
  prefs: []
  type: TYPE_NORMAL
- en: So far, with our imperative code, most of it just defines what our data should
    look like and how it can be manipulated. Even with high quality abstractions,
    understanding a section of code can often involve jumping between lots of methods,
    tracing the execution. In declarative code, logic can be more centralized and
    often more easily read, based on well-named methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can also think of imperative codes as if it were as a factory where each
    person makes a car in its entirety while thinking of declarative code as if it
    were a factory with an assembly line. In order to understand what the person is
    doing in a non-assembly line factory, you have to watch the whole process unfold
    one step at a time. They will probably be pulling in all kinds of tools at different
    times and it will be hard to follow. In a factory with an assembly line, you can
    determine what is happening by looking at each step in the assembly line one at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand some of the motivations of functional programming, let's
    look at the Swift features that make it possible.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Swift, functions are considered first-class citizens, which means that they
    can be treated the same as any other type. They can be assigned to variables and
    be passed in and out of other functions. When treated this way, we call them **closures**.
    This is an extremely critical piece to write more declarative code because it
    allows us to treat functionalities like objects. Instead of thinking of functions
    as a collection of code to be executed, we can start to think about them more
    like a recipe to get something done. Just like you can give just about any recipe
    to a chef to cook, you can create types and methods that take a closure to perform
    some customizable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Closures as variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at how closures work in Swift. The simplest way to capture
    a closure in a variable is to define the function and then use its name to assign
    it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `doubleClosure` can be used just like the normal function name
    after being assigned. There is actually no difference between using `double` and
    `doubleClosure`. Note that we can now think of this closure as an object that
    will double anything passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the type of `doubleClosure` by holding the option key and click
    on the name, you will see that the type is defined as `(Int) -> Int`. The basic
    type of any closure is `(ParamterType1, ParameterType2, …) -> ReturnType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this syntax, we can also define our closure inline, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We begin and end any closure with curly brackets (`{}`). Then, we follow the
    opening curly bracket with the type for the closure, which will include input
    parameters and a return value. Finally, we separate the type definition from the
    actual implementation with the `in` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'An absence of a return type is defined as `Void` or `()`. Even though you may
    see that some programmers use parentheses, `Void` is preferred for return declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, `()` is an empty tuple meaning it holds no value and it is more
    commonly used for the input parameters, in case the closure doesn''t take any
    parameters at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So far, even though we can change our thinking about the block of code by making
    it into a closure, it is not terribly useful. To really make closures useful,
    we need to start passing them into other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Closures as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define a function to take a closure as a parameter, using the same type
    syntax we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a function that can find the first number in an array that passes
    some arbitrary test. The syntax at the end of the function declaration may be
    confusing but it should be clear if you work from the inside out. The type for
    `passingTest` is `(number: Int) -> Bool`. That is then the second parameter of
    the whole `firstInNumbers` function, which returns an `Int?`. If we want to use
    this function to find the first number greater than three, we can create a custom
    test and pass that into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are essentially passing a little bundle of functionality to the `firstInNumbers:`
    function that lets us drastically enhance what a single function can normally
    do. This is an incredibly useful technique. Looping through an array to find an
    element can be very verbose. Instead, we can use this function to find an element
    showing only the important part of the code: the test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even define our test right in a call to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even though this is more concise, it's pretty complex; hence, Swift allows us
    to cut out some of the unnecessary syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic sugar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we can make use of type inference for the type of `number`. The compiler
    knows that number needs to be `Int` based on the definition of `firstInNumbers:passingTest:`.
    It also knows that the closure has to return `Bool`. Now, we can rewrite our call,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks cleaner, but the parentheses around `number` are not required; we
    could leave those out. In addition, if we have closure as the last parameter of
    a function, we can provide the closure outside the parentheses for the function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the closing parenthesis for the function parameters moved from being
    after the closure to before it. This is looking pretty great, but we can go even
    further. For a single line closure, we don''t even have to write the `return`
    keyword because it is implied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we don''t always need to give a name to the parameters of closures.
    If you leave out the names altogether, each parameter can be referenced using
    the syntax `$<ParemterIndex>`. Just like with arrays, the index starts at `0`.
    This helps us write this call very concisely in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a long way from our original syntax. You can mix and match all of these
    different techniques to make sure that your code is as understandable as possible.
    As we have discussed before, understandability is a balance between being concise
    and clear. It is up to you in each circumstance to decide how much syntax you
    want to cut out. To me, it is not immediately clear what the closure is without
    it having a name. My preferred syntax for this is to use the parameter name in
    the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This makes it clear that the closure is a test to see which number we want to
    pull out of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a closure is and how to use one, we can discuss some of
    the core features of Swift that allow us to write a functional style code.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of functional programming in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to realize is that Swift is not a functional programming language.
    At its core, it will always be an object-oriented programming language. However,
    since functions in Swift are first-class citizens, we can use some of the core
    techniques. Swift provides some built-in methods to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method we are going to discuss is called **filter**. As the name
    suggests, this method is used to filter elements in a list. For example, we can
    filter our `numbers` array to include only even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The closure we provide to filter will be called once for each element in the
    array. It is tasked with returning `true` if the element needs to be included
    in the result and `false` otherwise. The preceding closure takes advantage of
    the implied return value and simply returns `true` if the number has a remainder
    of zero when being divided by two.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the filter does not change the `numbers` variable; it simply returns
    a filtered copy. Changing the value will modify the state, which we want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: This method provides us with a concise way to filter a list in virtually any
    way we want. It is also the beginning of building up a vocabulary of transformations,
    which we can perform on data. One could argue that all applications just transform
    data from one form to another, so this vocabulary helps us achieve the maximum
    functionality we want in any app.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift also provides a method called **reduce**. The purpose of reduce is to
    condense a list down to a single value. Reduce works by iterating over every value
    and combining it with a single value that represents all previous elements. This
    is just like mixing a bunch of ingredients in a bowl for a recipe. We will take
    one ingredient at a time and combine it in the bowl until we are left with just
    a single bowl of ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what the reduce function looks like in our code. We can
    use it to sum up the values in our number array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, reduce takes two parameters. The first parameter is a value
    with which to start combining each item in the list. The second is a closure that
    will do the combining. Similar to filter, this closure is called once for each
    element in the array. The first parameter of the closure is the value after combing
    each of the previous elements with the initial value. The second parameter is
    the next element.
  prefs: []
  type: TYPE_NORMAL
- en: So the first time the closure is called, it is called with `0` (the initial
    value) and `1` (the first element of the list); it then returns `1`. This means
    that it is then called again with `1` (the value from the last call) and `2` (the
    next element in the list) returning `3`. This will continue until it is combining
    the running sum of `10`, with the last element `5`, returning a final result of
    `15`. It becomes very simple once we break it down.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce** is another great vocabulary item to add to our skill-set. It can
    reduce any list of information into a single value by analyzing data to generate
    a document from a list of images and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can start to chain our functions together. If we want to find the
    sum of all the even numbers in our list, we can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can actually do one more thing to shorten this. Every arithmetic operation,
    including addition (`+`) is really just another function or closure. Addition
    is a function that takes two values of the same type and returns their sum. This
    means that we can simply pass the addition function as our combine closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we are getting fancy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, keep in mind that the combined value does not need to be the same type
    that is in the original list. Instead of summing the values, we could combine
    them all into one string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here I am using string interpolation to create a string that starts with the
    running value and ends with the next element.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Map** is a method to transform every element in a list to another value.
    For example, we can add one to every number in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably guess, the closure that map takes is called once for each
    element in the list. As a parameter, it takes the element and is expected to return
    the new value to be added to the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with reduce, the transformed type does not need to match. We can
    convert all of our numbers to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Map is incredibly versatile. It can be used to convert a list of data into a
    list of views to display the data, convert a list of image paths to their loaded
    images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The map method is a great choice to perform calculations on each element of
    a list, but it should be used only when it makes sense to put the result of the
    calculation back into a list. You could technically use it to iterate through
    a list and perform some other action, but in that case, a for-in loop is more
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last built-in functional method we will discuss is called **sorted**. As
    the name suggests, sorted allows you to change the order of a list. For example,
    if we want to reorder our numbers list to go from largest to smallest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The closure that is passed into sorted is called `isOrderedBefore`. This means
    that it takes two elements in the list as input and it should return `true` if
    the first element is to be ordered before the second element. We cannot rely on
    the closure to be called a certain number of times, nor the elements it will be
    called with, but it will be called until the sorting algorithm has enough knowledge
    to come up with a new order.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we return `true` any time the first argument is greater than the
    second argument. This results in larger elements always coming before smaller
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great method because sorting is a very common task and often data
    will need to be sorted in multiple ways, depending on the user's interaction.
    Using this method, you could design multiple sorting closures and change the one
    being used based on the user's interaction.
  prefs: []
  type: TYPE_NORMAL
- en: How these affect the state and nature of code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more built-in functional methods and we will learn to write our own
    in the next chapter on generics, but these are a core few to help you start thinking
    about certain problems in a functional way. So how do these methods help us avoid
    state?
  prefs: []
  type: TYPE_NORMAL
- en: These methods, along with others, can be combined in infinite ways to transform
    data and perform actions. No matter how complex the combination is, there is no
    way to interfere with each individual step. There are no side effects because
    the only inputs are the result of the preceding step and the only outputs are
    what will be passed on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that complex transformations can all be declared in a concise
    and centralized place. A reader of the code doesn't need to trace the changing
    values of many variables; they can simply look at the code and see what processes
    it will go through.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A powerful feature of Swift is the ability to make these operations lazily evaluated.
    This means that, just like a lazy person would do, a value is only calculated
    when it is absolutely necessary and at the latest point possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is important to realize the order in which these methods are executed.
    For example, what if we only want the first element of our numbers to be mapped
    to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This works well, except that we actually converted every number to a string
    to get to just the first one. That is because each step of the chain is completed
    in its entirety before the next one can be executed. To prevent this, Swift has
    a built-in method called **lazy**.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy creates a new version of a container that only pulls specific values from
    it when it is specifically requested. This means that lazy essentially allows
    each element to flow through a series of functions one at a time, as it is needed.
    You can think about it like a lazy version of a worker. If you ask someone lazy
    to look up the capital of Cameroon, they aren't going to compile a list of the
    capitals of all countries before they get the answer. They are only going to do
    the work necessary to get that specific answer. That work may involve multiple
    steps, but they would only have to do those steps for the specific countries you
    ask for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at what lazy looks like in code. You use it to convert a normal
    list into a lazy list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of calling map directly on `numbers`, we called it on the lazy
    version of `numbers`. This makes it so that every time a value is requested from
    the result, it only processes a single element out of the input array. In our
    preceding example, the `map` method will only have been performed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This even applies to looping through a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each number is converted to a string only upon the next iteration of the for-in
    loop. If we were to break out of that loop early, the rest of the values would
    not be calculated. This is a great way to save processing time, especially on
    large lists.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at what this looks like in practice. We can use some of the
    techniques we learned in this chapter to write a different and possibly better
    implementation of our party inviter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by defining the same input data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we are making the invitees list, which is just a constant
    list of names and the shows by genre dictionary variable. This is because we are
    going to be mapping our invitees list to a list of invitation text. As we do the
    mapping, we will have to pick a random genre to assign to the current invitee,
    and in order to avoid assigning the same genre more than once, we can remove the
    genre from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s write the random `genre` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating an array of just the keys of the shows by genre dictionary.
    Then, if there are no genres left, we simply return nil. Otherwise, we pick out
    a random genre, remove it from the dictionary, and return it and the show example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use that function to map the invitees to a list of invitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we try to pick a random genre. If we can't, we return an invitation saying
    that the invitee should just bring themselves. If we can, we return an invitation
    saying what genre they should bring with the example show. The one new thing to
    note here is that we are using the sequence `"\n"` in our string. This is a newline
    character and it signals that a new line should be started in the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to print out the invitations. To do that, we can print out
    the invitations as a string joined by newline characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This works pretty well but there is one problem. The first invitees we listed
    will always be assigned a genre because the order they are processed in never
    changes. To fix this, we can write a function to shuffle the invitees before we
    begin to map the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to shuffle an array, we go through three steps: First, we map the
    array to a tuple with the original element and a random number. Second, we sort
    the tuples based on those random numbers. Finally, we map the tuples back to just
    their original elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a call to this function to our sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is not necessarily better than our previous implementations,
    but it definitely has its advantages. We have taken steps towards reducing the
    state by implementing it as a series of data transformations. The big hiccup in
    that is that we are still maintaining state in the genre dictionary. We can certainly
    do more to eliminate that as well, but this gives you a good idea of how we can
    start to think about problems in a functional way. The more ways in which we can
    think about a problem, the higher our odds of coming up with the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have had to shift the way we think about code. At the very
    least, this is a great exercise so we don't get set in our programming ways. We
    have covered the philosophy behind functional programming and how it differs from
    object-oriented programming. We have looked into the specifics of closures and
    how they enable functional programming techniques in Swift. Lastly, we explored
    some of the specific functional methods that Swift has built in.
  prefs: []
  type: TYPE_NORMAL
- en: The sign of a truly great programmer is not someone who knows a lot about one
    tool, but one who knows which tool to use when. We get there by learning and practicing
    using lots of different tools and techniques without ever becoming too attached
    to a specific one.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are comfortable with the concepts of closures and functional programming,
    you are ready to move on to our next topic, generics. Generics is our first opportunity
    to make the strongly typed nature of Swift really work for us.
  prefs: []
  type: TYPE_NORMAL
