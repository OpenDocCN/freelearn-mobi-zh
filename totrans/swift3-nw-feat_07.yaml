- en: Chapter 7. Hold onto Your Chair; Advanced Type Changes Are Here!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：抓紧你的椅子；高级类型变更即将到来！
- en: Swift is a great language, and it's getting better with each release. So far,
    we've covered most of the functionality that you are likely to use in your everyday
    projects. We are going to cover a few improvements to the language that you might
    not use on a regular basis. This chapter focuses on `UnsafePointe*r*` types, `typealiases`
    *,* and floating point operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种伟大的语言，并且随着每个版本的发布而变得越来越好。到目前为止，我们已经涵盖了你在日常项目中可能使用的大多数功能。我们将介绍一些你可能不会经常使用的语言改进。本章重点介绍`UnsafePointer`类型、`typealiases`和浮点运算。
- en: Unmanaged and UnsafePointer changes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unmanaged和UnsafePointer的变更
- en: Brace yourself, because we are about to skim the surface of a few types that
    you may not have seen a lot of and whose names scream, *I'll pass on those* for
    the squeamish among you. For the most part, the naming conventions for types in
    Swift seem approachable and sane to the average developer. However, there is a
    subset of types that aren't even listed in the main sections of the Swift Programming
    language document. These are the *black sheep* types of the language. The ones
    with names such as `Unmanaged`, `UnsafeMutableRawPointer`, and `UnsafeBufferPointer`.
    These types just feel `unsafe` to use. Perhaps, the names are a big hint that
    you, as the developer, need to take some precautions when using these types. If
    you develop long enough in Swift, you will eventually come across one of these
    types. We might as well cover the changes for these types in Swift 3 so that you
    will be armed with the most current knowledge of how to use the new features when
    you need them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好，因为我们即将浏览一些你可能见得不多、名字听起来让人想回避的类型，比如“我宁愿不碰那些”这类对你们中的一些人来说可能会感到不适的类型。就Swift中类型的命名惯例而言，对于普通开发者来说似乎既友好又合理。然而，有一组类型甚至没有列在Swift编程语言文档的主要部分中。这些是语言的“黑羊”类型。它们的名称如`Unmanaged`、`UnsafeMutableRawPointer`和`UnsafeBufferPointer`等。这些类型使用起来感觉`不安全`。也许，这些名称本身就是一个大大的提示，表明作为开发者的你，在使用这些类型时需要采取一些预防措施。如果你在Swift中开发的时间足够长，你最终会遇到这些类型之一。我们不妨先了解一下Swift
    3中这些类型的变更，这样当你需要使用新特性时，你就能掌握最新的知识。
- en: Changing Unmanaged to use UnsafePointer [SE-0017]
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Unmanaged转换为使用UnsafePointer [SE-0017]
- en: '`Unmanaged` is a type in Swift that allows you to work with an `unmanaged`
    object reference, meaning you are responsible for the object''s memory and for
    keeping it alive. An `UnsafePointer` is a type that represents a raw pointer to
    data of type pointer. You are fully responsible for managing memory with this
    type. Both types are useful when dealing with C APIs. C functions that accept
    types such as `void * or const void *` are extremely common but can present issues
    in Swift.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unmanaged`是Swift中的一种类型，允许你与一个`未管理的`对象引用一起工作，这意味着你负责对象的内存，并保持其存活。`UnsafePointer`是一种表示指针类型数据的原始指针的类型。你完全负责使用此类型管理内存。这两种类型在处理C
    API时都很有用。接受`void *`或`const void *`等类型的C函数非常常见，但在Swift中可能会出现一些问题。'
- en: When a C API passes a `void *` or `const void *` type (or others that aren't
    easily coerced into a Foundation type) to Swift, the type is converted to an `UnsafePointer`.
    This is our first step, but not our final destination in terms of getting a type
    that we can use efficiently in Swift. We ultimately want an `Unmanaged` type because
    this type provides a type-safe wrapper around our object, even though it does
    not participate in **Automatic Reference Counting** (**ARC**). With an `Unmanaged`
    type, the developer can manually make memory decisions. In Swift 2, there was
    no direct conversion to allow you to go from `UnsafePointer` to `Unmanaged` type.
    You had to convert to a **bridge type** first and then convert to your preferred
    type at **UnsafePointer** | **COpaquePointer** | **Unmanaged.**
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当C API传递`void *`或`const void *`类型（或其他不易转换为Foundation类型的类型）到Swift时，该类型会被转换为`UnsafePointer`。这是我们第一步，但不是我们最终的目的地，因为我们想要的是一个可以在Swift中高效使用的类型。我们最终想要的是一个`Unmanaged`类型，因为这个类型为我们提供的对象提供了一个类型安全的包装，即使它不参与**自动引用计数（ARC**）。使用`Unmanaged`类型，开发者可以手动做出内存决策。在Swift
    2中，没有直接的转换允许你从`UnsafePointer`转换为`Unmanaged`类型。你必须先转换为一个**桥接类型**，然后再转换为你想要的类型，即**UnsafePointer**
    | **COpaquePointer** | **Unmanaged**。
- en: 'You accomplished the conversions using one of the following methods on the
    `Unmanaged` type:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用以下方法之一在`Unmanaged`类型上完成转换：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift 2:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2中：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Swift 3, we can now convert directly between `Unmanaged` and `UnsafePointer`.
    The `fromOpaque` and `toOpaque` methods replace `COpaquePointer` with `UnsafeRawPointer`
    and `UnsafeMutableRawPointer` types. We essentially streamlined our code by eliminating
    the middleman.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中，我们现在可以直接在 `Unmanaged` 和 `UnsafePointer` 之间进行转换。`fromOpaque` 和 `toOpaque`
    方法用 `UnsafeRawPointer` 和 `UnsafeMutableRawPointer` 类型替换了 `COpaquePointer`。我们通过消除中间人简化了我们的代码。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Swift 3:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md)
    阅读提案。
- en: Making UnsafePointer explicit using Optional [SE-0055]
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可选类型明确 `UnsafePointer` [SE-0055]
- en: Unlike in Objective-C, where you can mark pointers as `nullable` or `nonnull`,
    Swift does not have a way to determine if a pointer is null. Therefore, when you
    obtain a reference to an `UnsafePointer<T>`, you could be holding a pointer to
    null. This is an issue because an `UnsafePointer` (and similar types) are essentially
    referencing C pointers. If the developer's code is not expecting or accounting
    for null values, then the program could crash. This is particularly troubling
    in Swift due to the fact that every non-trivial operation you could perform using
    an `UnsafePointer` relies on a valid underlying pointer that is not null.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 不同，在 Objective-C 中你可以将指针标记为 `可空` 或 `非空`，Swift 没有确定指针是否为空的方法。因此，当你获得一个
    `UnsafePointer<T>` 的引用时，你可能会持有指向空的指针。这是一个问题，因为 `UnsafePointer`（以及类似类型）本质上是在引用
    C 指针。如果开发者的代码没有期望或考虑到空值，那么程序可能会崩溃。这在 Swift 中尤其令人担忧，因为使用 `UnsafePointer` 可以执行的所有非平凡操作都依赖于一个有效的、非空的底层指针。
- en: 'Fortunately, we don''t have to deal with this in Swift for built-in types,
    classes, and structures, because we have optionals. As we know, `optionals` let
    us deal with situations in which our type may or may not contain a value. New
    in Swift 3, we can apply `optionals` to `UnsafePointer` types. When you know for
    sure that your pointer can''t be null, you use the regular form: `UnsafePointer<T>`.
    When you want to represent a `nullable` version, you use the optional syntax (`UnsafePointer<T>?`).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Swift 中，对于内置类型、类和结构体，我们不需要处理这个问题，因为我们有可选类型。众所周知，`可选类型` 允许我们处理类型可能包含或不包含值的情况。Swift
    3 新增了将 `可选类型` 应用于 `UnsafePointer` 类型的功能。当你确信你的指针不能为空时，你使用常规形式：`UnsafePointer<T>`。当你想要表示一个
    `可空` 版本时，你使用可选语法（`UnsafePointer<T>?`）。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md](https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md](https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md)
    阅读提案。
- en: Adding UnsafeRawPointer [SE-0107]
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `UnsafeRawPointer` [SE-0107]
- en: Swift added the `UnsafePointer` type to interoperate with C APIs and to facilitate
    building high performance data structures (think low-level graphics programming
    or heavy math-based modeling). In this respect, `UnsafePointer` is an important
    addition to Swift. Unfortunately, the implementation of `UnsafePointer` allows
    the developer to bypass the safety measures put in place to ensure type safe memory
    access. It's possible to use `UnsafePointer` types to violate compiler logic.
    The violation would normally cause a compilation error. However, the compiler
    has a built-in exception for the `UnsafePointer` type and allows the compilation
    to proceed. In many cases, running a program that uses the typed memory access
    to reference a memory location of a different type will cause that program to
    crash. Swift 3 introduces `UnsafeRawPointer` to deal with un-typed memory. Let's
    use an example to illustrate type memory access abuse.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 添加了 `UnsafePointer` 类型，以便与 C API 进行交互并简化高性能数据结构的构建（例如，低级图形编程或基于数学的建模）。在这方面，`UnsafePointer`
    是 Swift 中的一个重要补充。不幸的是，`UnsafePointer` 的实现允许开发者绕过为确保类型安全的内存访问而设置的防护措施。可以使用 `UnsafePointer`
    类型来违反编译器逻辑。违反通常会导致编译错误。然而，编译器为 `UnsafePointer` 类型内置了一个异常，允许编译过程继续进行。在许多情况下，运行使用类型化内存访问来引用不同类型内存位置的程序会导致程序崩溃。Swift
    3 引入了 `UnsafeRawPointer` 来处理无类型内存。让我们用一个例子来说明类型内存访问的滥用。
- en: 'In Swift 2:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our type memory access example, we create an `UnsafeMutablePointer<CFString>`
    to reference a typed block of memory. Then, we change the value in the first block
    to a new `CFString`, testing our pointer. Everything is fine so far. Next, we
    create an `UnsafePointer<Int>` from the existing memory location. Note that we
    bound our type to an *Int* versus the `CFString` we used in the original pointer.
    If we use this *Int* pointer, our program could crash. Even though the compiler
    finds this code to be suspicious, it allows compilation because we are using `UnsafePointer`
    types, which are on the compiler's exception list for certain types of operations.
    To correct the problem in our example, we need to use a type that can access memory
    without needing to know the type. `UnsafeRawPointer` and `UnsafeMutableRawPointer`
    were introduced in Swift 3 to do this very thing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类型内存访问示例中，我们创建了一个`UnsafeMutablePointer<CFString>`来引用一个类型化的内存块。然后，我们将第一个块中的值更改为一个新的`CFString`，测试我们的指针。到目前为止一切正常。接下来，我们从一个现有的内存位置创建了一个`UnsafePointer<Int>`。请注意，我们将类型绑定到了*Int*，而不是原始指针中使用的`CFString`。如果我们使用这个*Int*指针，我们的程序可能会崩溃。即使编译器认为这段代码可疑，它也允许编译，因为我们正在使用`UnsafePointer`类型，这些类型在编译器的异常列表中对于某些类型的操作是允许的。为了纠正我们示例中的问题，我们需要使用一个不需要知道类型的类型来访问内存。`UnsafeRawPointer`和`UnsafeMutableRawPointer`在Swift
    3中被引入，就是为了做这件事。
- en: '**Takeaways:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：**'
- en: '*Raw* types allow un-typed access to memory; *Typed* versions access memory
    using their types'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始*类型允许对内存进行无类型访问；*类型化*版本使用它们的类型访问内存'
- en: '*Raw* access essentially allows C type `memcopy` operations, while *Typed*
    access follows type aliasing rules'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原始*访问基本上允许C类型的`memcopy`操作，而*类型化*访问遵循类型别名规则'
- en: C types are now imported as `UnsafeMutableRawPointer` and `UnsafeRawPointer`
    when the type isn't clear (for example, `const void *` or `void *`) and are imported
    as `UnsafePointer<T>` and `UnsafeMutablePointer<T>` when their type can be determined
    (for example, `const T*`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类型不明确时（例如，`const void *`或`void *`），C类型现在被导入为`UnsafeMutableRawPointer`和`UnsafeRawPointer`，而当它们的类型可以确定时（例如，`const
    T*`），则导入为`UnsafePointer<T>`和`UnsafeMutablePointer<T>`。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read one proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md)阅读另一份提案。
- en: Type aliases and protocol changes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名和协议更改
- en: Type aliases are named types that fill in for existing types in Swift. Once
    defined, you can use these types anywhere in your code. Swift 3 now supports type
    aliases based on generics. In addition, type aliases are now supported for protocols
    and protocol extensions. Speaking of protocols, Swift 3 made a change to protocol
    use that makes things simpler and paves the way for expected future changes to
    this feature. Let's add the new changes more closely and work through some examples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名是命名类型，用于在Swift中替换现有类型。一旦定义，您就可以在代码的任何地方使用这些类型。Swift 3现在支持基于泛型的类型别名。此外，现在也支持协议和协议扩展的类型别名。谈到协议，Swift
    3对协议的使用进行了更改，这使得事情变得更简单，并为该功能的预期未来更改铺平了道路。让我们更详细地添加新更改，并通过一些示例来探讨。
- en: Generic type aliases [SE-0048]
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型别名 [SE-0048]
- en: 'Generic type aliases are a new addition for Swift 3\. As a reminder, a type
    alias is a way to declare a named alias for an existing type in the language.
    After you create your named alias, you can use the aliased type in your code just
    as you would any other type. Generic type aliases allow you to add type parameters
    that can be used in defining a generic type. Let''s consider a few examples to
    show the new possibilities you have with creating type aliases in Swift 3:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型别名是Swift 3的新增功能。提醒一下，类型别名是在语言中为现有类型声明一个命名别名的途径。创建您的命名别名后，您可以在代码中使用这些别名，就像使用任何其他类型一样。泛型类型别名允许您添加可以在定义泛型类型时使用的类型参数。让我们考虑几个示例，以展示在Swift
    3中创建类型别名的新可能性：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read another proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md](https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md](https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md)阅读另一份提案。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md](https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md](https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md)
    阅读这个提议。
- en: In prior versions of Swift, you needed to use the `protocol<...>` syntax when
    you were defining a type that adhered to multiple protocols. In Swift 3, you now
    use *&* between each protocol that your type adopts. This is merely syntactical
    sugar today, but will serve as the base for defining more generic types in future
    additions of Swift.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 的早期版本中，当你定义一个遵循多个协议的类型时，你需要使用 `protocol<...>` 语法。在 Swift 3 中，你现在在每个你类型采用的协议之间使用
    `&`。这仅仅是语法糖，但将成为在 Swift 未来版本中定义更多泛型类型的基础。
- en: 'In Swift 2:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Swift 3:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To better convey the intent of a compound type built from individual protocols,
    the Swift team now prefers using *&* to a comma for defining multiple protocols
    on a type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地传达由多个协议构建的复合类型的意图，Swift 团队现在更倾向于使用 `&` 而不是逗号来定义类型上的多个协议。
- en: Type aliases in protocols and protocol extensions [SE-0092]
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议和协议扩展中的类型别名 [SE-0092]
- en: Swift 2.2 introduced the **associatedtype** keyword to handle associated types
    in protocols. This change removed the confusion around using the *typealias* keyword
    because it is now only tasked with defining types. An additional benefit of adding
    the *associatedtype* keyword is that it allows us to make type aliases in protocols
    and protocol extensions that are based on the associated types. Looking at the
    *Sequence* protocol from the standard library, we can see that *Iterator* is defined
    as an associated type that inherits the *IteratorProtocol*. With Swift 3, I can
    now add a type alias named *Element* that indirectly references an associated
    type on the *IteratorProtocol* to make my syntax cleaner. Further, I can use any
    of the type aliases I create in my protocol with my protocol extensions as well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'Swift 2.2 引入了 **associatedtype** 关键字来处理协议中的关联类型。这个变化消除了使用 *typealias* 关键字时的混淆，因为它现在只负责定义类型。添加
    *associatedtype* 关键字的另一个好处是，它允许我们在协议和协议扩展中使用基于关联类型的类型别名。查看标准库中的 *Sequence* 协议，我们可以看到
    *Iterator* 被定义为继承自 *IteratorProtocol* 的关联类型。使用 Swift 3，我现在可以添加一个名为 *Element* 的类型别名，它间接引用了
    *IteratorProtocol* 上的关联类型，从而使我的语法更简洁。此外，我还可以在我的协议扩展中使用我创建的任何类型别名。 '
- en: 'In Swift 3:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding *Sequence* protocol, I can use my type alias `Element` in the
    `map()` function. In previous versions of Swift, you would have had to use `Iterator.Element`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 *Sequence* 协议中，我可以在 `map()` 函数中使用我的类型别名 `Element`。在 Swift 的早期版本中，你将不得不使用
    `Iterator.Element`。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md)
    阅读这个提议。
- en: Floating point changes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型变更
- en: Floating-point types are used to hold fractional numbers. The main floating-point
    types in the standard library are `Float` and `Double`. The Swift team created
    a `FloatingPoint` protocol to hold common math operations, making it easier for
    you to create functions that support all of the floating-point types available.
    In this section, we will cover additions to the `FloatingPoint` protocol and rounding
    functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型用于存储分数数字。标准库中的主要浮点类型是 `Float` 和 `Double`。Swift 团队创建了一个 `FloatingPoint` 协议来存储常见的数学操作，这使得你更容易创建支持所有浮点类型的函数。在本节中，我们将介绍对
    `FloatingPoint` 协议和舍入函数的扩展。
- en: Enhanced Floating point protocols [SE-0067]
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的浮点协议 [SE-0067]
- en: The current `FloatingPoint` protocol doesn't provide a full set of features
    to really conform to an IEEE 754 [https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008](https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008)
    type. The changes to the `FloatingPoint` protocol are meant to expand coverage
    of the operations that most would expect to be included. A second protocol `BinaryFloatingPoint`
    (conforms to `FloatingPoint`) has also been added to Swift and will be useful
    for generic programming.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 `FloatingPoint` 协议并没有提供一套完整的特性来真正符合 IEEE 754 [https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008](https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008)
    类型。对 `FloatingPoint` 协议的更改旨在扩展大多数预期应包含的操作的范围。Swift 还添加了一个名为 `BinaryFloatingPoint`
    的第二个协议（符合 `FloatingPoint`），它对于泛型编程将非常有用。
- en: The `FloatingPoint` protocol now contains most of the IEEE 754 basic operations.
    The `BinaryFloatingPoint` protocol additionally conforms to `FloatLiteralConvertible`.
    You can perform normal arithmetic and comparison operations using the `FloatingPoint`
    protocol and more complex operations that work best using floating-point types
    that have a fixed radix 2 using the `BinaryFloatingPoint` protocol.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `FloatingPoint` 协议包含了 IEEE 754 的基本操作的大部分。`BinaryFloatingPoint` 协议额外符合 `FloatLiteralConvertible`。你可以使用
    `FloatingPoint` 协议执行正常的算术和比较操作，以及使用 `BinaryFloatingPoint` 协议执行更适合使用具有固定基数 2 的浮点类型的更复杂操作。
- en: There are many new operations defined on the `FloatingPoint` and `BinaryFloatingPoint`
    protocols, and I'll leave exploring them to you as a future exercise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FloatingPoint` 和 `BinaryFloatingPoint` 协议上定义了许多新的操作，我将把它们留给你作为未来的练习。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md)
    阅读该提案。
- en: New rounding functions on the FloatingPoint protocol [SE-0113]
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FloatingPoint 协议上的新舍入函数 [SE-0113]
- en: The Swift standard library does not have built-in methods to implement rounding
    functions such as `floor()` or `ceil()`. When you need those methods, you have
    to import `Darwin` or `Glibc` to access the versions implemented using C. In Swift
    3, the Swift team added new rounding methods on the `FloatingPoint` protocol.
    Rounding and/or converting floating-point types to integers are operations the
    protocol should handle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 标准库没有内置方法来实现舍入函数，如 `floor()` 或 `ceil()`。当你需要这些方法时，你必须导入 `Darwin` 或 `Glibc`
    来访问使用 C 实现的版本。在 Swift 3 中，Swift 团队为 `FloatingPoint` 协议添加了新的舍入方法。舍入以及/或将浮点类型转换为整数的操作是协议应该处理的操作。
- en: 'The changes to the `FloatingPoint` protocol consist of adding the `FloatingPointRoundingRule`
    enumeration and two rounding methods, `round()` and `rounded()`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatingPoint` 协议的更改包括添加了 `FloatingPointRoundingRule` 枚举和两个舍入方法，`round()`
    和 `rounded()`：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the new native implementation of the rounding methods, you will be able
    to replicate behavior that you get with `ceil` and `floor`, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的本地化实现的舍入方法，你将能够复制使用 `ceil` 和 `floor` 等方法得到的行为：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md](https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md](https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md)
    阅读该提案。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered changes to `Unmanaged`, `UnsafePointer`, and similar types used when
    working with C APIs. You learned about Swift 2's compiler quirk when using these
    types and how things have improved in Swift 3\. Next, we covered type alias changes,
    their use with protocols, and protocol extensions. Finally, we explored changes
    to the FloatingPoint protocol. In the next chapter, we cover new additions to
    the Foundation framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了在使用 C APIs 时使用的 `Unmanaged`、`UnsafePointer` 和类似类型的更改。你了解了在使用这些类型时 Swift
    2 的编译器怪癖以及 Swift 3 中这些改进。接下来，我们讨论了类型别名更改、它们与协议的使用以及协议扩展。最后，我们探讨了 FloatingPoint
    协议的更改。在下一章中，我们将介绍 Foundation 框架的新增功能。
