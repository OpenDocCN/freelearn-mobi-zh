- en: Chapter 7. Hold onto Your Chair; Advanced Type Changes Are Here!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a great language, and it's getting better with each release. So far,
    we've covered most of the functionality that you are likely to use in your everyday
    projects. We are going to cover a few improvements to the language that you might
    not use on a regular basis. This chapter focuses on `UnsafePointe*r*` types, `typealiases`
    *,* and floating point operations.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged and UnsafePointer changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Brace yourself, because we are about to skim the surface of a few types that
    you may not have seen a lot of and whose names scream, *I'll pass on those* for
    the squeamish among you. For the most part, the naming conventions for types in
    Swift seem approachable and sane to the average developer. However, there is a
    subset of types that aren't even listed in the main sections of the Swift Programming
    language document. These are the *black sheep* types of the language. The ones
    with names such as `Unmanaged`, `UnsafeMutableRawPointer`, and `UnsafeBufferPointer`.
    These types just feel `unsafe` to use. Perhaps, the names are a big hint that
    you, as the developer, need to take some precautions when using these types. If
    you develop long enough in Swift, you will eventually come across one of these
    types. We might as well cover the changes for these types in Swift 3 so that you
    will be armed with the most current knowledge of how to use the new features when
    you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Unmanaged to use UnsafePointer [SE-0017]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Unmanaged` is a type in Swift that allows you to work with an `unmanaged`
    object reference, meaning you are responsible for the object''s memory and for
    keeping it alive. An `UnsafePointer` is a type that represents a raw pointer to
    data of type pointer. You are fully responsible for managing memory with this
    type. Both types are useful when dealing with C APIs. C functions that accept
    types such as `void * or const void *` are extremely common but can present issues
    in Swift.'
  prefs: []
  type: TYPE_NORMAL
- en: When a C API passes a `void *` or `const void *` type (or others that aren't
    easily coerced into a Foundation type) to Swift, the type is converted to an `UnsafePointer`.
    This is our first step, but not our final destination in terms of getting a type
    that we can use efficiently in Swift. We ultimately want an `Unmanaged` type because
    this type provides a type-safe wrapper around our object, even though it does
    not participate in **Automatic Reference Counting** (**ARC**). With an `Unmanaged`
    type, the developer can manually make memory decisions. In Swift 2, there was
    no direct conversion to allow you to go from `UnsafePointer` to `Unmanaged` type.
    You had to convert to a **bridge type** first and then convert to your preferred
    type at **UnsafePointer** | **COpaquePointer** | **Unmanaged.**
  prefs: []
  type: TYPE_NORMAL
- en: 'You accomplished the conversions using one of the following methods on the
    `Unmanaged` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Swift 3, we can now convert directly between `Unmanaged` and `UnsafePointer`.
    The `fromOpaque` and `toOpaque` methods replace `COpaquePointer` with `UnsafeRawPointer`
    and `UnsafeMutableRawPointer` types. We essentially streamlined our code by eliminating
    the middleman.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md).
  prefs: []
  type: TYPE_NORMAL
- en: Making UnsafePointer explicit using Optional [SE-0055]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike in Objective-C, where you can mark pointers as `nullable` or `nonnull`,
    Swift does not have a way to determine if a pointer is null. Therefore, when you
    obtain a reference to an `UnsafePointer<T>`, you could be holding a pointer to
    null. This is an issue because an `UnsafePointer` (and similar types) are essentially
    referencing C pointers. If the developer's code is not expecting or accounting
    for null values, then the program could crash. This is particularly troubling
    in Swift due to the fact that every non-trivial operation you could perform using
    an `UnsafePointer` relies on a valid underlying pointer that is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we don''t have to deal with this in Swift for built-in types,
    classes, and structures, because we have optionals. As we know, `optionals` let
    us deal with situations in which our type may or may not contain a value. New
    in Swift 3, we can apply `optionals` to `UnsafePointer` types. When you know for
    sure that your pointer can''t be null, you use the regular form: `UnsafePointer<T>`.
    When you want to represent a `nullable` version, you use the optional syntax (`UnsafePointer<T>?`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md](https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md).
  prefs: []
  type: TYPE_NORMAL
- en: Adding UnsafeRawPointer [SE-0107]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift added the `UnsafePointer` type to interoperate with C APIs and to facilitate
    building high performance data structures (think low-level graphics programming
    or heavy math-based modeling). In this respect, `UnsafePointer` is an important
    addition to Swift. Unfortunately, the implementation of `UnsafePointer` allows
    the developer to bypass the safety measures put in place to ensure type safe memory
    access. It's possible to use `UnsafePointer` types to violate compiler logic.
    The violation would normally cause a compilation error. However, the compiler
    has a built-in exception for the `UnsafePointer` type and allows the compilation
    to proceed. In many cases, running a program that uses the typed memory access
    to reference a memory location of a different type will cause that program to
    crash. Swift 3 introduces `UnsafeRawPointer` to deal with un-typed memory. Let's
    use an example to illustrate type memory access abuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our type memory access example, we create an `UnsafeMutablePointer<CFString>`
    to reference a typed block of memory. Then, we change the value in the first block
    to a new `CFString`, testing our pointer. Everything is fine so far. Next, we
    create an `UnsafePointer<Int>` from the existing memory location. Note that we
    bound our type to an *Int* versus the `CFString` we used in the original pointer.
    If we use this *Int* pointer, our program could crash. Even though the compiler
    finds this code to be suspicious, it allows compilation because we are using `UnsafePointer`
    types, which are on the compiler's exception list for certain types of operations.
    To correct the problem in our example, we need to use a type that can access memory
    without needing to know the type. `UnsafeRawPointer` and `UnsafeMutableRawPointer`
    were introduced in Swift 3 to do this very thing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaways:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Raw* types allow un-typed access to memory; *Typed* versions access memory
    using their types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Raw* access essentially allows C type `memcopy` operations, while *Typed*
    access follows type aliasing rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C types are now imported as `UnsafeMutableRawPointer` and `UnsafeRawPointer`
    when the type isn't clear (for example, `const void *` or `void *`) and are imported
    as `UnsafePointer<T>` and `UnsafeMutablePointer<T>` when their type can be determined
    (for example, `const T*`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read one proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md](https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md).
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases and protocol changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type aliases are named types that fill in for existing types in Swift. Once
    defined, you can use these types anywhere in your code. Swift 3 now supports type
    aliases based on generics. In addition, type aliases are now supported for protocols
    and protocol extensions. Speaking of protocols, Swift 3 made a change to protocol
    use that makes things simpler and paves the way for expected future changes to
    this feature. Let's add the new changes more closely and work through some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Generic type aliases [SE-0048]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generic type aliases are a new addition for Swift 3\. As a reminder, a type
    alias is a way to declare a named alias for an existing type in the language.
    After you create your named alias, you can use the aliased type in your code just
    as you would any other type. Generic type aliases allow you to add type parameters
    that can be used in defining a generic type. Let''s consider a few examples to
    show the new possibilities you have with creating type aliases in Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read another proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md](https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md](https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md).
  prefs: []
  type: TYPE_NORMAL
- en: In prior versions of Swift, you needed to use the `protocol<...>` syntax when
    you were defining a type that adhered to multiple protocols. In Swift 3, you now
    use *&* between each protocol that your type adopts. This is merely syntactical
    sugar today, but will serve as the base for defining more generic types in future
    additions of Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To better convey the intent of a compound type built from individual protocols,
    the Swift team now prefers using *&* to a comma for defining multiple protocols
    on a type.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases in protocols and protocol extensions [SE-0092]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift 2.2 introduced the **associatedtype** keyword to handle associated types
    in protocols. This change removed the confusion around using the *typealias* keyword
    because it is now only tasked with defining types. An additional benefit of adding
    the *associatedtype* keyword is that it allows us to make type aliases in protocols
    and protocol extensions that are based on the associated types. Looking at the
    *Sequence* protocol from the standard library, we can see that *Iterator* is defined
    as an associated type that inherits the *IteratorProtocol*. With Swift 3, I can
    now add a type alias named *Element* that indirectly references an associated
    type on the *IteratorProtocol* to make my syntax cleaner. Further, I can use any
    of the type aliases I create in my protocol with my protocol extensions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding *Sequence* protocol, I can use my type alias `Element` in the
    `map()` function. In previous versions of Swift, you would have had to use `Iterator.Element`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md).
  prefs: []
  type: TYPE_NORMAL
- en: Floating point changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Floating-point types are used to hold fractional numbers. The main floating-point
    types in the standard library are `Float` and `Double`. The Swift team created
    a `FloatingPoint` protocol to hold common math operations, making it easier for
    you to create functions that support all of the floating-point types available.
    In this section, we will cover additions to the `FloatingPoint` protocol and rounding
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Floating point protocols [SE-0067]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current `FloatingPoint` protocol doesn't provide a full set of features
    to really conform to an IEEE 754 [https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008](https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008)
    type. The changes to the `FloatingPoint` protocol are meant to expand coverage
    of the operations that most would expect to be included. A second protocol `BinaryFloatingPoint`
    (conforms to `FloatingPoint`) has also been added to Swift and will be useful
    for generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: The `FloatingPoint` protocol now contains most of the IEEE 754 basic operations.
    The `BinaryFloatingPoint` protocol additionally conforms to `FloatLiteralConvertible`.
    You can perform normal arithmetic and comparison operations using the `FloatingPoint`
    protocol and more complex operations that work best using floating-point types
    that have a fixed radix 2 using the `BinaryFloatingPoint` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There are many new operations defined on the `FloatingPoint` and `BinaryFloatingPoint`
    protocols, and I'll leave exploring them to you as a future exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md](https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md).
  prefs: []
  type: TYPE_NORMAL
- en: New rounding functions on the FloatingPoint protocol [SE-0113]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Swift standard library does not have built-in methods to implement rounding
    functions such as `floor()` or `ceil()`. When you need those methods, you have
    to import `Darwin` or `Glibc` to access the versions implemented using C. In Swift
    3, the Swift team added new rounding methods on the `FloatingPoint` protocol.
    Rounding and/or converting floating-point types to integers are operations the
    protocol should handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes to the `FloatingPoint` protocol consist of adding the `FloatingPointRoundingRule`
    enumeration and two rounding methods, `round()` and `rounded()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new native implementation of the rounding methods, you will be able
    to replicate behavior that you get with `ceil` and `floor`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md](https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered changes to `Unmanaged`, `UnsafePointer`, and similar types used when
    working with C APIs. You learned about Swift 2's compiler quirk when using these
    types and how things have improved in Swift 3\. Next, we covered type alias changes,
    their use with protocols, and protocol extensions. Finally, we explored changes
    to the FloatingPoint protocol. In the next chapter, we cover new additions to
    the Foundation framework.
  prefs: []
  type: TYPE_NORMAL
