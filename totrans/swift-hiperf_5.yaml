- en: Chapter 5. Choosing the Correct Data Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered Swift-specific features that make Swift
    fast. It is no less important to choose the correct data structure for a specific
    use case. In this chapter, we will talk about different data structures, their
    differences, and when to choose one instead of the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Swift standard library collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array, set, and dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up with Accelerate and Surge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every programming language has built-in primitive data types, such as integer,
    double, character, string, and Boolean. The Swift programing language has some
    more complex types, such as enumeration, optionals, and tuples. By composing primitive
    types, we can build more complex data types. To compose them, we use structures
    and classes.
  prefs: []
  type: TYPE_NORMAL
- en: A data structure is a way of organizing data in a specific way so that it can
    be used efficiently for a specific task, for example, searching, checking for
    existence, and a quick update of values.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a new type and choosing the correct type for it, either a value or
    a reference, is an important task, which we covered previously in [Chapter 2](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "Chapter 2. Making a Good Application Architecture in Swift"), *Making a Good
    Application Architecture in Swift*. There is a bigger impact on performance when
    we work with many instances of the same type when we put them into a collection.
    Choosing the correct collection for a particular task is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Swift has some powerful building collections; we should take a look at them
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Swift standard library collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will very often be using different collections to store and process data
    in your applications. Swift has three different built-in collection types: arrays,
    dictionaries, and sets.'
  prefs: []
  type: TYPE_NORMAL
- en: The Swift standard library also has many functions for working with these collections,
    such as sort, find, filter, map, and many others. These functions have very efficient
    implementations, and you should use them instead of making your own. First, let's
    take a look at the different collections.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array is an ordered collection of values that provides access to its elements
    by indexes. It is a very simple and well-known collection. You would use an array
    in these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple element storage (often add/remove from the end)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements need to be ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random access to elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrays are usually implemented as a continuous block of memory in which you
    store values. Because memory blocks are usually located next to each other, access
    to elements can usually be transformed into simple pointer arithmetic: *third
    element = array start position + (2 * element size)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are perfectly fit for storing data for UITableView. Items need to be
    ordered. We need to know the number of items, get an item by its index, and be
    able to edit a collection. You would use an array when you need to store two or
    more objects of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are a very simple and flexible collection. But because of this, they
    are often overused in situations where we should use a set, or maybe a dictionary
    or some other custom collection.
  prefs: []
  type: TYPE_NORMAL
- en: Fast operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays have great performance for some operations with a constant complexity
    O(1), which doesn''t increase with the size of the array. You can use them freely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing elements**: To access the elements, use these operations, `array[i]`,
    `array.first`, and `array.last`. The approximate time is 81 nanoseconds, or 0.000000081
    seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appending an element**: To append an element, use this operation `array.append(i)`.
    The approximate time is 100 nanoseconds or 0,0000001 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inserting and removing elements at both the beginning and a random place is
    also a very fast operation, but it has O(n) complexity. It increases with the
    size of the array, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Array size | Time in seconds |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 to 50_000 | 0.00001 |'
  prefs: []
  type: TYPE_TB
- en: '| 500_000 | 0.00019 |'
  prefs: []
  type: TYPE_TB
- en: '| 5_000_000 | 0.0043 |'
  prefs: []
  type: TYPE_TB
- en: '| 50_000_000 | 0.040 |'
  prefs: []
  type: TYPE_TB
- en: '| 500_000_000 | 0.32 |'
  prefs: []
  type: TYPE_TB
- en: Slower operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some other operations on arrays increase very fast with increasing size of arrays.
    You should be careful while using such methods.
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finding elements has O(n) complexity. The more the elements in the array, the
    more the time it will take to find out whether an element exists. To find out
    whether an element is present in the array, it has to iterate over every element
    and compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the search is not a primary operation that you perform on the collection
    and the size of the array is, for example, 500_000_000 elements, the search would
    take 0.5 seconds. If you have to perform searches very often and it's critical
    to do so very fast, use a set for search operations, or sort an array and use
    a more effective search algorithm, such as binary search.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sorting has even bigger complexity than searching for an element; it has O(n
    * n) complexity. Sorting needs to iterate over an array to find the correct place
    for one element, and repeat it for every element. The `sort` standard library
    function has a very efficient implementation, and you should use it. It uses different
    sorting algorithms depending on the array size. Because sorting is expensive,
    you should cache the sorted result and reuse it if needed. Sorting an array of
    500_000_000 `int` elements takes about 67 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is an unordered collection that stores unique objects. Sets are used for
    checking for the membership.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a set is implemented as a hash table. Elements in a set have to conform
    to **hashable** and **equatable** protocols.
  prefs: []
  type: TYPE_NORMAL
- en: When you add an element to a set or search for an element, it uses a hash function
    of an element to find an index for that element in the storage. Because of this,
    many operations on a Set are very fast, and it has O(1) complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sets](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are great for checking whether an object exists in the collection. Also,
    they are great for getting the difference between two collections, for example,
    finding what objects were added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets have two important limitations. They are not ordered and can''t contain
    duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But, a set turns these limitations into features. Because of this and because
    it uses a hash table to store its elements, it achieves incredible performance
    for some operations with a constant complexity of O(1) that doesn''t increase
    with the size of the set. The following are the operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lookup: `contains`, `IndexOf`, and `subscript`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete: `remove` and `removeAtIndex`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All of these operations take less than 6 microseconds, which is 0.000006 sec,
    even for a set with 50_000_000 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to do a heavy search for elements, use Set. You can have both
    an array to store data and a Set for search operations. This will use twice as
    much memory, but the search will be instant.
  prefs: []
  type: TYPE_NORMAL
- en: Set operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can perform fundamental set operations on two different sets, such as combining,
    extracting, and getting common values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Set operations](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These operations are also very fast, but they have O(n) or O(log n) complexity,
    and with increased size, the time required to process the data increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The performance of these operations is quite impressive, as you can see in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Set size | Union | Subtract | Intersect | ExclusiveOr |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 100 x 100 | 0.000015 | 0.000012 | 0.000013 | 0.00001 |'
  prefs: []
  type: TYPE_TB
- en: '| 500_000 x 500_000 | 0.11 | 0.072 | 0.055 | 0.13 |'
  prefs: []
  type: TYPE_TB
- en: 'If we take a look at the declarations of these methods, we see that they accept,
    not a Set, but `SequenceType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use these set methods with any `SequenceType`. Let''s try to use an
    array instead of a set and see whether there will be any difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Set size x array size | Union | Subtract | Intersect | ExclusiveOr |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 100 x 100 | 0.000013 | 0.0000045 | 0.000026 | 0.000032 |'
  prefs: []
  type: TYPE_TB
- en: '| 500_000 x 500_000 | 0.10 | 0.058 | 0.13 | 0.18 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, `intersect` and `exclusiveOr` perform better with a set. Although
    the difference is so small that it wouldn't have big impact on the overall application
    performance, it is still an important observation that you should remember.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at one more method in set—`isSubsetOf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It also has the `SequenceType` parameter, so it''s possible to use both sets
    and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The results are very interesting. With the set size equal to 5_000_000, `isSubsetOf`
    takes 4 minutes with an array argument, and less than 1 second with a set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `isSubsetOf` method, it is always preferable to use a set as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '| Size | isSubsetOf (array) | isSubsetOf (set) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 50_000 | 0.11 sec | 0.0045 sec |'
  prefs: []
  type: TYPE_TB
- en: '| 5_000_000 | 237.2 sec | 0.46 sec |'
  prefs: []
  type: TYPE_TB
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary is an unordered collection that stores unique key-value pairs.
    Dictionaries are useful for quick object lookups by key
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries also use a hash table to store their keys and values. Because of
    this, a dictionary has similar performance characteristics as a set. Dictionaries
    are very useful when you need to connect two objects and perform instant searches
    and lookups for them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dictionaries](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The dictionary collection is a very simple type. It doesn''t have many methods
    of its own. The main functionality is to query a value for a key, update it, and
    delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using a dictionary would result in a big performance win in a situation where
    you have two arrays and you want to find a connection between them.
  prefs: []
  type: TYPE_NORMAL
- en: Collection memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every collection has very similar performance optimization when you instance
    an instance of it. There are three different ways of creating an instance of a
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Empty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create an empty collection. All arrays, sets, and dictionaries have
    an empty `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reserve capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other way is to instance an instance of a collection and reserve a required
    memory capacity. All collections have dynamic size, and they allocate more memory
    when needed. When you know how many elements you are going to store in the collection,
    it is useful to allocate exactly the required amount of memory upfront:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array has one more way of instantiating. You can create an array with default
    values set for all the elements in that array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Size | Method | Array | Size set | Dictionary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 500 |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Empty | 5.2e-06 | 2.4e-05 | 2.4e-05 |'
  prefs: []
  type: TYPE_TB
- en: '|   | Capacity | 8.8e-07 | 1.6e-06 | 4.7e-06 |'
  prefs: []
  type: TYPE_TB
- en: '|   | Default values | 4.8e-07 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 50_000_000 |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Empty | 1.29 | 11.7 | 12.9 |'
  prefs: []
  type: TYPE_TB
- en: '|   | Capacity | 1.13 | 9.4 | 10.9 |'
  prefs: []
  type: TYPE_TB
- en: '|   | Default values | 1.043 |   |   |'
  prefs: []
  type: TYPE_TB
- en: As you can see from the results, it is always better to reserve some capacity
    for collections when you know the size, even for small sizes.
  prefs: []
  type: TYPE_NORMAL
- en: For arrays, using default values is the fastest way, but you have to remember
    that the array is filled in with default values and you have to either handle
    them or replace them with real values.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can see that creating an array is an incredibly fast operation, even
    with big sizes. That's one of the advantages of arrays over other collections.
  prefs: []
  type: TYPE_NORMAL
- en: The CollectionType protocol methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the collections mentioned earlier—array, set and, dictionary—implement
    a `CollectionType` protocol. Because of this, they are interchangeable. You can
    use any of them in places where a `CollectionType` method is required. An example
    is a function with a `CollectionType` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Protocol extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other incredibly useful feature is protocol extensions. With protocol extensions,
    we can add implementations of methods and properties directly to the protocol.
    All types that conform to that protocol are able to use those methods for free.
    Let''s add our own property to a `CollectionType` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The types that conform to that protocol can provide their own implementation
    for that method. In such a case, this implementation will be used for that type
    instead of the one defined in the protocol extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CollectionType` protocol uses this functionality very heavily, and there
    are many methods and properties that are available for a `CollectionType`, for
    example, `isEmpty`, `first`, `dropFirst(n: Int)`, `map`, `indexOf`, and many more.
    Let''s take a look at `isEmpty` and `dropFirst(n: Int)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's inspect these methods. Hold down *command* and click on the `isEmpty`
    property to jump to its declaration. An array uses a `CollectionType` version
    of `isEmpty`, but set and dictionary provide their own implementations for the
    `isEmpty` property. Set and dictionary do this because the way in which they store
    their elements is different, and they can provide a better and more performance
    implementation of the `isEmpty` property. The types usually use their own implementation
    instead of using the protocol's default implementation if they can do it better.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about protocol extensions from the *The Swift Programming
    Language* book at [https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html),
    in the *Protocols* section.
  prefs: []
  type: TYPE_NORMAL
- en: Accelerate and Surge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both iOS and OS X SDK have a very powerful framework that provides high-performance
    functions for working with matrices, vectors, signals, image processing, and math
    operations. It is called the Accelerate framework. The Accelerate framework is
    quite big, so we will take a look at only one part that is related to working
    with collections; it is the vDSP part. You can find out more about it at [https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html](https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s implement the very basic mapping, calculating, and sum operations
    using the Swift standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very clear and readable and doesn''t need any comments. Let''s
    try to do the same using Accelerate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code gets more complex than in the previous version. The
    vDSP library works with vectors and matrices. For the `vDSP_vsaddD` function call,
    we pass an input array. The second parameter gives the distance between the elements
    in the array. Because the elements in the array are next to each other, we use
    `1`. The third is our second parameter, and the fourth and fifth are resulting
    arrays similar to the first and second parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Accelerate code is more complex, but it has better performance. Let''s
    compare it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The results are very interesting for big arrays with 500_000_000 elements. The
    `map` function takes `5.1` seconds and `vDSP_vsaddD` takes `0.6` seconds. It runs
    almost 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: Yes! Accelerate has way better performance, but the source code gets very complicated.
    However, there is a solution to it. We could make a nice API wrapper to work with
    the Accelerate framework. Fortunately, this has already been done. There is a
    very nice open source Swift framework called **Surge** . You can download it from
    GitHub at [https://github.com/mattt/Surge](https://github.com/mattt/Surge).
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have downloaded it, add the Surge framework project to your project.
    Add it as a linked framework, and then you can use it. Now, by using Surge, the
    code looks very nice and has great performance. Here is an example of calculating
    the sum of all elements using Surge. It''s even nicer than using a reduce method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Other collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered three main Swift standard library collections. There are also
    other not-so-well-known and often-used helper collections, such as `ArraySlice`,
    `MapCollection`, `CollectionOfOne`, `ContiguousArray`, `EmptyCollection`, and
    `FilterCollection`. If you want to know more about them, just press *command*
    and click on any type. You will see the content of the Swift standard library.
    Then, just explore it!
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement your own collections, if needed. The Swift generic allows
    you to make very abstract collections that can be used with any type. For example,
    it could be the Stack, or a Linked List, a Binary Tree or any other collection
    that fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the importance of choosing the correct data type.
    We covered the Swift standard library collections with their features and limitations.
    You learned which collection fits better for which use case. Also, we showed the
    performance characteristics when working with those collections and performing
    different operations. Moreover, we gave a tip on how to improve performance and
    memory allocation for collections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create an application architecture that
    contributes to achieving high performance.
  prefs: []
  type: TYPE_NORMAL
