- en: Chapter 5. Choosing the Correct Data Structure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。选择正确的数据结构
- en: In the previous chapter, we covered Swift-specific features that make Swift
    fast. It is no less important to choose the correct data structure for a specific
    use case. In this chapter, we will talk about different data structures, their
    differences, and when to choose one instead of the other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了使Swift运行快速的Swift特定功能。为特定用例选择正确的数据结构同样重要。在本章中，我们将讨论不同的数据结构、它们的区别以及何时选择一个而不是另一个。
- en: 'In this chapter, we will cover these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of data structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构概述
- en: The Swift standard library collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift标准库集合
- en: Array, set, and dictionary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组、集合和字典
- en: Speeding up with Accelerate and Surge
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Accelerate和Surge加速
- en: An overview of data structures
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构概述
- en: Every programming language has built-in primitive data types, such as integer,
    double, character, string, and Boolean. The Swift programing language has some
    more complex types, such as enumeration, optionals, and tuples. By composing primitive
    types, we can build more complex data types. To compose them, we use structures
    and classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有内置的原始数据类型，例如整数、双精度浮点数、字符、字符串和布尔值。Swift编程语言还有一些更复杂的数据类型，例如枚举、可选和元组。通过组合原始类型，我们可以构建更复杂的数据类型。要组合它们，我们使用结构和类。
- en: A data structure is a way of organizing data in a specific way so that it can
    be used efficiently for a specific task, for example, searching, checking for
    existence, and a quick update of values.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是以特定方式组织数据的一种方式，以便它可以高效地用于特定任务，例如搜索、检查是否存在以及快速更新值。
- en: Collection types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: Creating a new type and choosing the correct type for it, either a value or
    a reference, is an important task, which we covered previously in [Chapter 2](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "Chapter 2. Making a Good Application Architecture in Swift"), *Making a Good
    Application Architecture in Swift*. There is a bigger impact on performance when
    we work with many instances of the same type when we put them into a collection.
    Choosing the correct collection for a particular task is very important.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类型并为其选择正确的类型，无论是值类型还是引用类型，是一项重要的任务，我们之前在[第2章](part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0
    "第2章。在Swift中构建良好的应用程序架构")中已经讨论过，即*在Swift中构建良好的应用程序架构*。当我们将相同类型的多个实例放入集合中时，对性能的影响更大。为特定任务选择正确的集合非常重要。
- en: Swift has some powerful building collections; we should take a look at them
    first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有一些强大的构建集合；我们首先应该看看它们。
- en: Swift standard library collections
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift标准库集合
- en: 'You will very often be using different collections to store and process data
    in your applications. Swift has three different built-in collection types: arrays,
    dictionaries, and sets.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你经常会使用不同的集合来存储和处理数据。Swift 有三种不同的内置集合类型：数组、字典和集合。
- en: The Swift standard library also has many functions for working with these collections,
    such as sort, find, filter, map, and many others. These functions have very efficient
    implementations, and you should use them instead of making your own. First, let's
    take a look at the different collections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Swift标准库还提供了许多用于处理这些集合的函数，例如排序、查找、过滤、映射等。这些函数具有非常高效的实现，你应该使用它们而不是自己实现。首先，让我们看看不同的集合。
- en: Arrays
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is an ordered collection of values that provides access to its elements
    by indexes. It is a very simple and well-known collection. You would use an array
    in these situations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是有序值集合，通过索引提供对其元素的访问。这是一个非常简单且广为人知的集合。你会在这些情况下使用数组：
- en: Simple element storage (often add/remove from the end)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单元素存储（通常从末尾添加/删除）
- en: Elements need to be ordered
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素需要有序
- en: Random access to elements
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问元素
- en: 'Arrays are usually implemented as a continuous block of memory in which you
    store values. Because memory blocks are usually located next to each other, access
    to elements can usually be transformed into simple pointer arithmetic: *third
    element = array start position + (2 * element size)*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组通常实现为一个连续的内存块，在其中存储值。因为内存块通常位于彼此旁边，所以对元素的访问通常可以转换为简单的指针算术：*第三个元素 = 数组起始位置
    + (2 * 元素大小)*。
- en: '![Arrays](img/00021.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![数组](img/00021.jpeg)'
- en: Using arrays
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组
- en: Arrays are perfectly fit for storing data for UITableView. Items need to be
    ordered. We need to know the number of items, get an item by its index, and be
    able to edit a collection. You would use an array when you need to store two or
    more objects of the same type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数组非常适合存储用于UITableView的数据。项目需要排序。我们需要知道项目数量，通过索引获取项目，并且能够编辑集合。当你需要存储两个或更多相同类型的对象时，你会使用数组。
- en: Arrays are a very simple and flexible collection. But because of this, they
    are often overused in situations where we should use a set, or maybe a dictionary
    or some other custom collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个非常简单且灵活的集合。但由于这一点，它们在应该使用集合、字典或其他自定义集合的情况下经常被过度使用。
- en: Fast operations
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快速操作
- en: 'Arrays have great performance for some operations with a constant complexity
    O(1), which doesn''t increase with the size of the array. You can use them freely:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对于某些操作具有非常高的性能，这些操作的复杂度为常数 O(1)，不会随着数组大小的增加而增加。你可以自由地使用它们：
- en: '**Accessing elements**: To access the elements, use these operations, `array[i]`,
    `array.first`, and `array.last`. The approximate time is 81 nanoseconds, or 0.000000081
    seconds.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问元素**：要访问元素，请使用这些操作，`array[i]`、`array.first` 和 `array.last`。大约需要 81 纳秒，或
    0.000000081 秒。'
- en: '**Appending an element**: To append an element, use this operation `array.append(i)`.
    The approximate time is 100 nanoseconds or 0,0000001 seconds.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加元素**：要添加元素，请使用此操作 `array.append(i)`。大约需要 100 纳秒或 0.0000001 秒。'
- en: 'Inserting and removing elements at both the beginning and a random place is
    also a very fast operation, but it has O(n) complexity. It increases with the
    size of the array, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组的开始位置和随机位置插入和删除元素也是一个非常快的操作，但它具有 O(n) 的复杂度。它随着数组大小的增加而增加，如下所示：
- en: '| Array size | Time in seconds |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 数组大小 | 时间（秒） |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 50_000 | 0.00001 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 0 to 50_000 | 0.00001 |'
- en: '| 500_000 | 0.00019 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 500_000 | 0.00019 |'
- en: '| 5_000_000 | 0.0043 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 5_000_000 | 0.0043 |'
- en: '| 50_000_000 | 0.040 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 50_000_000 | 0.040 |'
- en: '| 500_000_000 | 0.32 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 500_000_000 | 0.32 |'
- en: Slower operations
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 较慢的操作
- en: Some other operations on arrays increase very fast with increasing size of arrays.
    You should be careful while using such methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数组上的一些其他操作随着数组大小的增加而急剧增加。使用此类方法时请小心。
- en: Search
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Finding elements has O(n) complexity. The more the elements in the array, the
    more the time it will take to find out whether an element exists. To find out
    whether an element is present in the array, it has to iterate over every element
    and compare them:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查找元素具有 O(n) 的复杂度。数组中的元素越多，查找元素是否存在所需的时间就越长。为了确定元素是否存在于数组中，它必须遍历每个元素并比较它们：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the search is not a primary operation that you perform on the collection
    and the size of the array is, for example, 500_000_000 elements, the search would
    take 0.5 seconds. If you have to perform searches very often and it's critical
    to do so very fast, use a set for search operations, or sort an array and use
    a more effective search algorithm, such as binary search.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索不是你在集合上执行的主要操作，并且数组的大小，例如，为 500_000_000 个元素，搜索将需要 0.5 秒。如果你必须非常频繁地执行搜索，并且这样做非常关键，请使用集合进行搜索操作，或者对数组进行排序并使用更有效的搜索算法，例如二分搜索。
- en: Sort
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序
- en: Sorting has even bigger complexity than searching for an element; it has O(n
    * n) complexity. Sorting needs to iterate over an array to find the correct place
    for one element, and repeat it for every element. The `sort` standard library
    function has a very efficient implementation, and you should use it. It uses different
    sorting algorithms depending on the array size. Because sorting is expensive,
    you should cache the sorted result and reuse it if needed. Sorting an array of
    500_000_000 `int` elements takes about 67 seconds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的复杂度甚至比搜索元素还要大；它具有 O(n * n) 的复杂度。排序需要遍历数组以找到某个元素的正确位置，并对其中的每个元素重复此操作。`sort`
    标准库函数有一个非常高效的实现，你应该使用它。它根据数组大小使用不同的排序算法。因为排序很昂贵，你应该缓存排序结果并在需要时重用它。对包含 500_000_000
    个 `int` 元素的数组进行排序大约需要 67 秒。
- en: Sets
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: A set is an unordered collection that stores unique objects. Sets are used for
    checking for the membership.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个无序的集合，用于存储唯一的对象。集合用于检查成员资格。
- en: Usually, a set is implemented as a hash table. Elements in a set have to conform
    to **hashable** and **equatable** protocols.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，集合被实现为哈希表。集合中的元素必须符合**可哈希**和**可比较**协议。
- en: When you add an element to a set or search for an element, it uses a hash function
    of an element to find an index for that element in the storage. Because of this,
    many operations on a Set are very fast, and it has O(1) complexity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向集合添加元素或搜索元素时，它使用元素的哈希函数来找到该元素在存储中的索引。正因为如此，集合上的许多操作都非常快，并且具有 O(1) 的复杂度。
- en: '![Sets](img/00022.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![集合](img/00022.jpeg)'
- en: Using sets
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合
- en: Sets are great for checking whether an object exists in the collection. Also,
    they are great for getting the difference between two collections, for example,
    finding what objects were added or removed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 集合非常适合检查对象是否存在于集合中。此外，它们非常适合获取两个集合之间的差异，例如，找出添加或删除的对象。
- en: 'Sets have two important limitations. They are not ordered and can''t contain
    duplicates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有两个重要的限制。它们是无序的，并且不能包含重复项：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But, a set turns these limitations into features. Because of this and because
    it uses a hash table to store its elements, it achieves incredible performance
    for some operations with a constant complexity of O(1) that doesn''t increase
    with the size of the set. The following are the operations:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，集合将这些限制转化为特性。正因为如此，并且因为它使用哈希表来存储其元素，所以在某些操作中实现了令人难以置信的性能，这些操作的复杂度为 O(1)，并且不会随着集合大小的增加而增加。以下是一些操作：
- en: 'Insert:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lookup: `contains`, `IndexOf`, and `subscript`:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找：`contains`、`IndexOf` 和 `subscript`：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Delete: `remove` and `removeAtIndex`:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除：`remove` 和 `removeAtIndex`：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of these operations take less than 6 microseconds, which is 0.000006 sec,
    even for a set with 50_000_000 elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都不到 6 微秒，即 0.000006 秒，即使是包含 50_000_000 个元素的集合。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are going to do a heavy search for elements, use Set. You can have both
    an array to store data and a Set for search operations. This will use twice as
    much memory, but the search will be instant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算进行元素的密集搜索，请使用集合。你可以同时使用数组来存储数据，以及集合来进行搜索操作。这将使用两倍多的内存，但搜索将瞬间完成。
- en: Set operations
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合操作
- en: You can perform fundamental set operations on two different sets, such as combining,
    extracting, and getting common values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对两个不同的集合执行基本集合操作，例如合并、提取和获取公共值。
- en: '![Set operations](img/00023.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![集合操作](img/00023.jpeg)'
- en: 'These operations are also very fast, but they have O(n) or O(log n) complexity,
    and with increased size, the time required to process the data increases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作也非常快，但它们的复杂度为 O(n) 或 O(log n)，并且随着大小的增加，处理数据所需的时间也会增加：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The performance of these operations is quite impressive, as you can see in
    the following table:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的性能相当令人印象深刻，如下表所示：
- en: '| Set size | Union | Subtract | Intersect | ExclusiveOr |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 集合大小 | 并集 | 差集 | 交集 | 异或 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 100 x 100 | 0.000015 | 0.000012 | 0.000013 | 0.00001 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 100 x 100 | 0.000015 | 0.000012 | 0.000013 | 0.00001 |'
- en: '| 500_000 x 500_000 | 0.11 | 0.072 | 0.055 | 0.13 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 500_000 x 500_000 | 0.11 | 0.072 | 0.055 | 0.13 |'
- en: 'If we take a look at the declarations of these methods, we see that they accept,
    not a Set, but `SequenceType`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这些方法的声明，我们会看到它们接受的不是集合，而是 `SequenceType`：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can use these set methods with any `SequenceType`. Let''s try to use an
    array instead of a set and see whether there will be any difference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些集合方法与任何 `SequenceType`。让我们尝试使用数组而不是集合，看看是否会有任何区别：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Set size x array size | Union | Subtract | Intersect | ExclusiveOr |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 集合大小 x 数组大小 | 并集 | 差集 | 交集 | 异或 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 100 x 100 | 0.000013 | 0.0000045 | 0.000026 | 0.000032 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 100 x 100 | 0.000013 | 0.0000045 | 0.000026 | 0.000032 |'
- en: '| 500_000 x 500_000 | 0.10 | 0.058 | 0.13 | 0.18 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 500_000 x 500_000 | 0.10 | 0.058 | 0.13 | 0.18 |'
- en: As you can see, `intersect` and `exclusiveOr` perform better with a set. Although
    the difference is so small that it wouldn't have big impact on the overall application
    performance, it is still an important observation that you should remember.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`intersect` 和 `exclusiveOr` 在集合上表现更好。尽管差异很小，不会对整体应用性能产生重大影响，但这仍然是一个您应该记住的重要观察。
- en: 'Let''s take a look at one more method in set—`isSubsetOf`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看集合中的一种更多方法——`isSubsetOf`：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It also has the `SequenceType` parameter, so it''s possible to use both sets
    and arrays:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它也具有 `SequenceType` 参数，因此可以使用集合和数组：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The results are very interesting. With the set size equal to 5_000_000, `isSubsetOf`
    takes 4 minutes with an array argument, and less than 1 second with a set.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常有趣。当集合大小等于 5_000_000 时，使用数组参数的 `isSubsetOf` 需要 4 分钟，而使用集合则不到 1 秒。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the `isSubsetOf` method, it is always preferable to use a set as an argument.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `isSubsetOf` 方法，始终首选使用集合作为参数。
- en: '| Size | isSubsetOf (array) | isSubsetOf (set) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | isSubsetOf (数组) | isSubsetOf (集合) |'
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 50_000 | 0.11 sec | 0.0045 sec |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 50_000 | 0.11 秒 | 0.0045 秒 |'
- en: '| 5_000_000 | 237.2 sec | 0.46 sec |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 5_000_000 | 237.2 秒 | 0.46 秒 |'
- en: Dictionaries
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: A dictionary is an unordered collection that stores unique key-value pairs.
    Dictionaries are useful for quick object lookups by key
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一个无序集合，用于存储唯一的键值对。当需要通过键快速查找对象时，字典非常有用
- en: Dictionaries also use a hash table to store their keys and values. Because of
    this, a dictionary has similar performance characteristics as a set. Dictionaries
    are very useful when you need to connect two objects and perform instant searches
    and lookups for them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也使用哈希表来存储它们的键和值。因此，字典具有与集合相似的性能特征。当需要连接两个对象并对其进行即时搜索和查找时，字典非常有用。
- en: '![Dictionaries](img/00024.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![字典](img/00024.jpeg)'
- en: 'The dictionary collection is a very simple type. It doesn''t have many methods
    of its own. The main functionality is to query a value for a key, update it, and
    delete it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字典集合是一个非常简单的类型。它没有很多自己的方法。主要功能是查询键的值、更新它和删除它：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using a dictionary would result in a big performance win in a situation where
    you have two arrays and you want to find a connection between them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有两个数组并且想要找到它们之间联系的情况下，使用字典将导致性能的大幅提升。
- en: Collection memory allocation
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合内存分配
- en: Every collection has very similar performance optimization when you instance
    an instance of it. There are three different ways of creating an instance of a
    collection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合在实例化其实例时都有非常相似的性能优化。创建集合实例有三种不同的方式。
- en: Empty
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空的
- en: 'You can create an empty collection. All arrays, sets, and dictionaries have
    an empty `init` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个空集合。所有数组、集合和字典都有一个空的 `init` 方法：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reserve capacity
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预留容量
- en: 'The other way is to instance an instance of a collection and reserve a required
    memory capacity. All collections have dynamic size, and they allocate more memory
    when needed. When you know how many elements you are going to store in the collection,
    it is useful to allocate exactly the required amount of memory upfront:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是实例化一个集合并预留所需的内存容量。所有集合都具有动态大小，并在需要时分配更多内存。当你知道你将在集合中存储多少元素时，预先分配所需的确切数量的内存是有用的：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Default values
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值
- en: 'An array has one more way of instantiating. You can create an array with default
    values set for all the elements in that array:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还有一个实例化的方式。你可以创建一个数组，其中所有元素的默认值都已设置：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the results in seconds:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是秒数的结果：
- en: '| Size | Method | Array | Size set | Dictionary |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 方法 | 数组 | 集合大小 | 字典 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 500 |   |   |   |   |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 500 |   |   |   |   |'
- en: '|   | Empty | 5.2e-06 | 2.4e-05 | 2.4e-05 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|   | 空的 | 5.2e-06 | 2.4e-05 | 2.4e-05 |'
- en: '|   | Capacity | 8.8e-07 | 1.6e-06 | 4.7e-06 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|   | 容量 | 8.8e-07 | 1.6e-06 | 4.7e-06 |'
- en: '|   | Default values | 4.8e-07 |   |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|   | 默认值 | 4.8e-07 |   |   |'
- en: '| 50_000_000 |   |   |   |   |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 50_000_000 |   |   |   |   |'
- en: '|   | Empty | 1.29 | 11.7 | 12.9 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|   | 空的 | 1.29 | 11.7 | 12.9 |'
- en: '|   | Capacity | 1.13 | 9.4 | 10.9 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   | 容量 | 1.13 | 9.4 | 10.9 |'
- en: '|   | Default values | 1.043 |   |   |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|   | 默认值 | 1.043 |   |   |'
- en: As you can see from the results, it is always better to reserve some capacity
    for collections when you know the size, even for small sizes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如从结果中可以看出，当你知道集合的大小，即使是很小的尺寸，为集合预留一些容量总是更好的。
- en: For arrays, using default values is the fastest way, but you have to remember
    that the array is filled in with default values and you have to either handle
    them or replace them with real values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，使用默认值是最快的方式，但你要记住数组是用默认值填充的，你必须处理它们或者用真实值替换它们。
- en: Also, you can see that creating an array is an incredibly fast operation, even
    with big sizes. That's one of the advantages of arrays over other collections.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以看到创建一个数组是一个非常快速的操作，即使是大尺寸的数组也是如此。这是数组相对于其他集合的优势之一。
- en: The CollectionType protocol methods
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CollectionType 协议方法
- en: 'All the collections mentioned earlier—array, set and, dictionary—implement
    a `CollectionType` protocol. Because of this, they are interchangeable. You can
    use any of them in places where a `CollectionType` method is required. An example
    is a function with a `CollectionType` parameter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所提到的所有集合——数组、集合和字典——都实现了 `CollectionType` 协议。正因为如此，它们可以互换使用。你可以在需要 `CollectionType`
    方法的地方使用任何一个。一个例子是具有 `CollectionType` 参数的函数：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Protocol extensions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议扩展
- en: 'The other incredibly useful feature is protocol extensions. With protocol extensions,
    we can add implementations of methods and properties directly to the protocol.
    All types that conform to that protocol are able to use those methods for free.
    Let''s add our own property to a `CollectionType` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是协议扩展。使用协议扩展，我们可以在协议中直接添加方法和属性的实现。所有符合该协议的类型都可以免费使用这些方法。让我们向一个`CollectionType`方法添加我们自己的属性：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The types that conform to that protocol can provide their own implementation
    for that method. In such a case, this implementation will be used for that type
    instead of the one defined in the protocol extension:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 符合该协议的类型可以为该方法提供自己的实现。在这种情况下，将使用该类型的实现而不是协议扩展中定义的实现：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `CollectionType` protocol uses this functionality very heavily, and there
    are many methods and properties that are available for a `CollectionType`, for
    example, `isEmpty`, `first`, `dropFirst(n: Int)`, `map`, `indexOf`, and many more.
    Let''s take a look at `isEmpty` and `dropFirst(n: Int)`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionType` 协议非常依赖这个功能，并且有许多方法和属性可用于 `CollectionType`，例如 `isEmpty`、`first`、`dropFirst(n:
    Int)`、`map`、`indexOf` 以及更多。让我们看看 `isEmpty` 和 `dropFirst(n: Int)`：'
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's inspect these methods. Hold down *command* and click on the `isEmpty`
    property to jump to its declaration. An array uses a `CollectionType` version
    of `isEmpty`, but set and dictionary provide their own implementations for the
    `isEmpty` property. Set and dictionary do this because the way in which they store
    their elements is different, and they can provide a better and more performance
    implementation of the `isEmpty` property. The types usually use their own implementation
    instead of using the protocol's default implementation if they can do it better.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些方法。按住 *command* 键并点击 `isEmpty` 属性以跳转到其声明。数组使用 `CollectionType` 版本的 `isEmpty`，但集合和字典为
    `isEmpty` 属性提供了自己的实现。集合和字典之所以这样做，是因为它们存储元素的方式不同，并且它们可以提供更好、更高效的 `isEmpty` 属性实现。如果类型能够做得更好，它们通常会使用自己的实现而不是使用协议的默认实现。
- en: You can read more about protocol extensions from the *The Swift Programming
    Language* book at [https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html),
    in the *Protocols* section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *The Swift Programming Language* 书籍的 *Protocols* 部分了解更多关于协议扩展的信息，链接为 [https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html)。
- en: Accelerate and Surge
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速和激增
- en: Both iOS and OS X SDK have a very powerful framework that provides high-performance
    functions for working with matrices, vectors, signals, image processing, and math
    operations. It is called the Accelerate framework. The Accelerate framework is
    quite big, so we will take a look at only one part that is related to working
    with collections; it is the vDSP part. You can find out more about it at [https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html](https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 OS X SDK 都有一个非常强大的框架，它提供了用于处理矩阵、向量、信号、图像处理和数学运算的高性能函数。这个框架被称为 Accelerate
    框架。Accelerate 框架相当庞大，所以我们将只查看与处理集合相关的一部分；它是 vDSP 部分。你可以在 [https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html](https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html)
    上了解更多信息。
- en: 'First, let''s implement the very basic mapping, calculating, and sum operations
    using the Swift standard library:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 Swift 标准库实现非常基本的映射、计算和求和操作：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code is very clear and readable and doesn''t need any comments. Let''s
    try to do the same using Accelerate:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常清晰易读，不需要任何注释。让我们尝试使用 Accelerate 来实现同样的功能：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the code gets more complex than in the previous version. The
    vDSP library works with vectors and matrices. For the `vDSP_vsaddD` function call,
    we pass an input array. The second parameter gives the distance between the elements
    in the array. Because the elements in the array are next to each other, we use
    `1`. The third is our second parameter, and the fourth and fifth are resulting
    arrays similar to the first and second parameters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码比上一个版本更复杂。vDSP 库与向量和矩阵一起工作。对于 `vDSP_vsaddD` 函数调用，我们传递一个输入数组。第二个参数给出数组中元素之间的距离。因为数组中的元素是相邻的，所以我们使用
    `1`。第三个是我们的第二个参数，第四和第五个是类似于第一个和第二个参数的结果数组。
- en: 'So, the Accelerate code is more complex, but it has better performance. Let''s
    compare it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Accelerate 代码更复杂，但性能更好。让我们来比较一下：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The results are very interesting for big arrays with 500_000_000 elements. The
    `map` function takes `5.1` seconds and `vDSP_vsaddD` takes `0.6` seconds. It runs
    almost 10 times faster.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有 500_000_000 个元素的较大数组，结果非常有趣。`map` 函数需要 `5.1` 秒，而 `vDSP_vsaddD` 需要 `0.6`
    秒。它几乎快了 10 倍。
- en: Yes! Accelerate has way better performance, but the source code gets very complicated.
    However, there is a solution to it. We could make a nice API wrapper to work with
    the Accelerate framework. Fortunately, this has already been done. There is a
    very nice open source Swift framework called **Surge** . You can download it from
    GitHub at [https://github.com/mattt/Surge](https://github.com/mattt/Surge).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！Accelerate 的性能要好得多，但源代码变得非常复杂。然而，有一个解决方案。我们可以创建一个漂亮的 API 包装器来与 Accelerate
    框架一起工作。幸运的是，这已经完成了。有一个非常棒的名为 **Surge** 的开源 Swift 框架。您可以从 GitHub [https://github.com/mattt/Surge](https://github.com/mattt/Surge)
    下载它。
- en: 'After you have downloaded it, add the Surge framework project to your project.
    Add it as a linked framework, and then you can use it. Now, by using Surge, the
    code looks very nice and has great performance. Here is an example of calculating
    the sum of all elements using Surge. It''s even nicer than using a reduce method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，将 Surge 框架项目添加到您的项目中。将其作为链接框架添加，然后您就可以使用它了。现在，通过使用 Surge，代码看起来非常漂亮，并且性能出色。以下是一个使用
    Surge 计算所有元素总和的示例。它甚至比使用 reduce 方法更优雅：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other collections
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他集合
- en: We have covered three main Swift standard library collections. There are also
    other not-so-well-known and often-used helper collections, such as `ArraySlice`,
    `MapCollection`, `CollectionOfOne`, `ContiguousArray`, `EmptyCollection`, and
    `FilterCollection`. If you want to know more about them, just press *command*
    and click on any type. You will see the content of the Swift standard library.
    Then, just explore it!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了三个主要的 Swift 标准库集合。还有一些不太为人所知但经常使用的辅助集合，例如 `ArraySlice`、`MapCollection`、`CollectionOfOne`、`ContiguousArray`、`EmptyCollection`
    和 `FilterCollection`。如果您想了解更多关于它们的信息，只需按 *command* 键并点击任何类型。您将看到 Swift 标准库的内容。然后，只需探索它！
- en: You can also implement your own collections, if needed. The Swift generic allows
    you to make very abstract collections that can be used with any type. For example,
    it could be the Stack, or a Linked List, a Binary Tree or any other collection
    that fits your needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您也可以实现自己的集合。Swift 泛型允许您创建非常抽象的集合，可以与任何类型一起使用。例如，它可以是栈、链表、二叉树或任何满足您需求的集合。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the importance of choosing the correct data type.
    We covered the Swift standard library collections with their features and limitations.
    You learned which collection fits better for which use case. Also, we showed the
    performance characteristics when working with those collections and performing
    different operations. Moreover, we gave a tip on how to improve performance and
    memory allocation for collections.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了选择正确数据类型的重要性。我们介绍了具有其功能和限制的 Swift 标准库集合。您学习了哪个集合更适合哪种用例。此外，我们还展示了使用这些集合执行不同操作时的性能特征。此外，我们还提供了一些建议，以改善集合的性能和内存分配。
- en: In the next chapter, we will see how to create an application architecture that
    contributes to achieving high performance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何创建一个有助于实现高性能的应用程序架构。
