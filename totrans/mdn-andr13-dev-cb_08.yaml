- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Paging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android development, the Paging library helps developers load and display
    data pages from a larger dataset from local storage or over a network. This can
    be a common case if your application loads considerable amounts of data for people
    to read. For instance, a good example is Twitter; you might notice the data refreshes
    due to the many tweets that people send daily.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, in **Modern Android Development** (**MAD**), Android developers might
    want to implement the Paging library in their applications to help them with such
    instances when loading data. In this chapter, you will learn how to utilize the
    Paging library in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Jetpack Paging library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing present and loading states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing your custom pagination in Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and displaying paged data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to transform data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating to Paging 3 and understanding the benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for your Paging Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight).
    You will also need to get an API key for [https://newsapi.org/](https://newsapi.org/).
    `NewsApi` is a worldwide API for news.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Jetpack Paging library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Paging library comes with incredible features for developers. If your codebase
    is established and extensive, there are other custom ways that developers have
    created to help them load data efficiently. One notable advantage of Paging is
    its in-memory caching for your page’s data, which ensures your application uses
    the system resources efficiently while working with the already paged data.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, it offers support for Kotlin coroutine flows and LiveData and has
    built-in deduplication, which ensures your application uses network bandwidth
    and resources efficiently, which can help save battery. Finally, the Paging library
    offers support for error handling, including when refreshing and retrying your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will need to create a new project; if you need to reference
    a previous recipe for creating a new project, you can visit [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android* *Development Skills*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create a new empty Compose project and call it `PagingJetpackExample`.
    In our example project, we will use the free `NewsApi` to display the news to
    our users. To get started, check out this link at [https://newsapi.org/docs/get-started](https://newsapi.org/docs/get-started).
    Also, ensure you get your API for the project, as it is a requirement for this
    recipe. Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and add the following required dependencies. In addition, since
    we will be doing a network call, we need to add a library to handle this. As for
    the correct versioning, check out the *Technical requirements* section for the
    code and the correct version. We will provide `2.x.x` so you can check compatibility
    if you are upgrading or already have `Retrofit` in your project and Coil which
    is a fast, lightweight, and flexible image loading library. It is designed to
    simplify the process of loading images from various sources (such as network,
    local storage, or content providers) and displaying them in ImageView or other
    image-related UI components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the project syncs and is ready, go ahead and remove the `Greeting` composable
    function that comes with the project. You should have just your theme, and your
    surface should be empty. In addition, for the **user interface** (**UI**) portion
    of this recipe, you can get the entire code from the *Technical* *requirements*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, when using an API, developers tend to forget to add the `Android.permission.INTERNET`
    permission on the manifest, so let’s do that now before we forget it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a package and call it `data`; we will add our model and service
    files to this package. In addition, ensure you go through the News API **Documentation**
    section to understand how the API works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us now create our `NewsArticleResponse` data class, which we will implement
    in our `NewsApiService` interface. Our API call type is `@GET()`, which means
    exactly “to get.” A more detailed explanation of `GET` is provided in the *How
    it works* section. Our call seeks to return a call object containing the data
    in the form of the `NewsArticleResponse` data class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another class called `NewsArticlePagingSource()`; our class will use
    `NewsApiService` as the input parameter. When exposing any large datasets through
    APIs, we need to provide a mechanism to paginate the list of resources. To implement
    it, we need to pass the type of the Paging key and the type of data to load, which
    in our case is `NewsArticle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let us go ahead and override `getRefreshKey()` provided by the `PagingSource`
    and `load()` suspend functions. We will discuss the `load()` and `PagingSource`
    suspend functions in detail in the *Loading and displaying paged* *data* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our repository; a repository is a class that isolates the
    data sources, such as a web service or a Room database, from the rest of the app.
    Since we do not have a Room database, we will work with the web service data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use Hilt for Dependency Injection in our project and build the required
    modules that will be supplied. For this section, you can reference the steps in[*Chapter
    3*](B18827_03.xhtml#_idTextAnchor137), *Handling the UI State in Jetpack Compose
    and Using Hilt*, on how to add Hilt to your project and also how to create the
    required modules. In addition, you can access the entire code through the *Technical
    requirements* section if you get stuck:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, after we have implemented our `PagingSource`, we can go ahead and create
    a `Pager` which typically refers to a `ViewPager` in our ViewModel and specify
    our page size. This can range based on the project’s needs or preferences. Furthermore,
    when using Paging 3.0, we don’t need to individually handle or convert any data
    to survive the screen configuration changes because this is done for us automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can simply cache our API result using `cachedIn(viewModelScope)`. In addition,
    to notify of any change to the `PagingData`, you can handle the loading state
    using a `CombinedLoadState` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you run the application, you should see a display like *Figure
    8**.1*, showing the author’s name, image, and content. We also wrap the content
    since this example is just for learning purposes; you can take it as a challenge
    to improve the UI and display more details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 8.1 – The news article being loaded using the Paging 3 \uFEFFlibrary](img/Figure_8.1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The news article being loaded using the Paging 3 library
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android development, a retrofit request typically refers to a network request
    made using the Retrofit library, a popular HTTP client library for Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common types of Retrofit requests and their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This request is used to retrieve data from a server. It is the most
    common type of request used in Android apps and is often used to retrieve data
    to populate a UI element such as a list or a grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This request is used to submit data to a server. It is commonly used
    to create new resources on the server, such as a new user account or a new post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This request is used to update an existing resource on the server. It
    is commonly used to update a user’s account information or to modify an existing
    post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This request is used to delete a resource on the server. It is commonly
    used to delete a user account or to remove a post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This request partially updates an existing resource on the server.
    It is commonly used when only a small portion of the resource needs to be updated
    rather than updating the entire resource with a `PUT` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making Retrofit requests, developers typically define an interface that
    describes the endpoint and the request parameters. Retrofit then generates a client
    implementation for that interface, which can be used to make the actual network
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: By using Retrofit, developers can abstract away many of the low-level details
    of network requests, making it easier and more efficient to communicate with a
    server from an Android app. For examples about Retrofit, check out the following
    link [https://square.github.io/retrofit/](https://square.github.io/retrofit/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Paging library ensures it adheres to the recommended Android architecture
    patterns. Furthermore, its components are the `Repository`, `ViewModel`, and `UI`
    layers. The following diagram shows how Paging components operate at each layer
    and how they work together in unison to load and display your paged data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Paging library architecture](img/Figure_8.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Paging library architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Paging Source` component is the main component in the `Repository` layer,
    as seen in *Figure 8**.2*. The object usually declares a source for each piece
    of data and also handles how to retry data from that source. If you noticed, that
    is precisely what we did in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We create our Retrofit `builder()` object that contains our base URL of the
    API, which we defined in the `Constant` class, `const val BASE_URL = "https://newsapi.org/v2/"`,
    and we use the `Gson` converter to convert our JSON API response. We then declare
    the `apiService` variable that we will use to connect the Retrofit `builder()`
    object with our interface and complete our retrofit module.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended for anyone using the Paging Library to migrate to Paging 3
    due to its improvements and because some functionalities are hard to handle using
    Paging 2.
  prefs: []
  type: TYPE_NORMAL
- en: Managing present and loading states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Paging library offers the loading state information to users through its
    load state object, which can have different forms based on its current loading
    state. For example, if you have an active load, then the state will be `LoadState.Loading`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an error state, then the state will be a `LoadState.Error`; and
    finally, there might be no active load operation, and this state is called the
    `LoadState.NotLoading.` In this recipe, we will explore the different states and
    get to understand them; the example demonstrated here can also be found at the
    following link: [https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state).
    In this example, we assume your project uses legacy code, which utilizes XML for
    the view system.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with this recipe, you need to have completed the code in the
    previous recipe. You can also skip this if it is not required in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will not create a new project in this recipe but rather a step-by-step look
    at how we can access the loading state with a listener or present the loading
    state with an adapter. Follow along with these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to access the state, pass this information to your UI. You can
    easily use the `loadedStateFlow` stream of the `addLoadStateListener` function
    provided by `PagingDataAdapter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our example, we will not look into the `addLoadStateListener` function since
    this is used with an adapter class, and with the new Jetpack Compose, this is
    barely performed since there is more of a push to use the Jetpack Compose UI-based
    applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Filtering the load state steam might make sense based on your application’s
    specific event. This ensures that your app UI is updated at the correct time to
    avoid issues. Hence, using coroutines, we wait until our refresh load state is
    updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When getting updates from `loadStateFlow` and `addLoadStateListener()`, these
    are guaranteed to be synchronous, and they update the UI as needed. This simply
    means in the Paging 3 library for Android, `LoadState.Error` is a state that indicates
    an error has occurred while loading data from a `PagingSource`.
  prefs: []
  type: TYPE_NORMAL
- en: In Paging 3 library for Android, `LoadState.NotLoading` is a state that indicates
    that the `PagingDataAdapter` is not currently loading any data and that all available
    data has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: When a `PagingDataAdapter` is first created, it starts in the `LoadState.NotLoading`
    state. This means that no data has been loaded yet, and the adapter is waiting
    for the first load to occur.
  prefs: []
  type: TYPE_NORMAL
- en: After the first load, the adapter may transition to a different load state depending
    on the current state of the data loading process. However, once all available
    data has been loaded, the adapter will transition back to the `LoadState.NotLoading`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadState.NotLoading` can be used to inform the UI that the data-loading process
    is complete and that no further data will be loaded unless the user initiates
    a refresh or other action.'
  prefs: []
  type: TYPE_NORMAL
- en: To handle this state, you can register a listener for changes to the `LoadState`
    in the `PagingDataAdapter` and update the UI accordingly. For example, you could
    display a message to the user indicating that all data has been loaded or disable
    any “load more” buttons or gestures.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can learn more about the state and how to better handle Paging by following
    this link: [https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your custom pagination in Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Paging library has incredible features for developers, but sometimes you
    encounter challenges and are forced to create custom pagination. At the beginning
    of the chapter, we talked about complex code bases having or creating pagination.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look into how we can achieve this with a simple list
    example and how you can use this example to create custom pagination in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will need to create a new project and call it `CustomPagingExample`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example project, we will try to create a student profile card and use
    custom pagination to load the profiles in Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, let us go ahead and add the `lifecycle-ViewModel` dependency
    since we will need it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go ahead and create a new package and call it `data`. In our `data` package,
    we will add the items we will display on our card. For now, we will just display
    the student’s `name, school,` `and major`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our `data` class, we will go ahead and build our repository,
    and since, in our example, we are not using an API, we will use our remote data
    source, and we can try to load, say, 50 to 100 profiles. Then, inside `data`,
    add another class and call it `StudentRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created our repository let us go ahead and create our custom
    pagination. We will do this by creating a new interface and calling it `StudentPaginator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `StudentPaginator` is an interface, we must create a class to implement
    the two functions we just created. Now, let us go ahead and create `StudentPaginatorImpl`
    and implement our interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you will need to work on what you need to handle in the `StudentPaginator`
    implementation class. For instance, in our constructor, we will need to create
    a key to listen to the `load`, `request`, `error`, `success`, and `next key`,
    and then finally, on the `reset()` function, be able to reset our pagination.
    You can view the complete code in the *Technical requirements* section. You might
    also notice it looks similar to the Paging Source in the first recipe of this
    chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go ahead and create a new package and call it `uistate`. Inside `uistate`,
    we will create a new data class and call it `UIState` to help us handle the UI
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s go ahead and finalize our `ViewModel` `init` in Kotlin is the block
    that we use for our initialization. We also create `val ourPaginator` that we
    declare to the `StudentPaginatorImpl` class and handle the inputs with the data
    we need for our UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in our `MainActivity` class, we now load the student profile on our
    card and display it on the screen, as shown in *Figure 8**.3*. A tremendous additional
    exercise to try out is to use Dependency Injection on the sample project to enhance
    your Android skills. You can utilize [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, for adding Dependency
    Injection and also to try writing tests for the `ViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The data loaded on a lazy column](img/Figure_8.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The data loaded on a lazy column
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8**.4* you will see a progress loading symbol when you scroll down
    to **Student 4** and so on, which can be great when you have huge loads of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Our data being loaded](img/Figure_8.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Our data being loaded
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might experience issues once you get a list, and it might be tough to notify
    single items. However, you can easily make your pagination; in our project, we
    simulate a remote data source but remember that you can use any API for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our primary focus is the `StudentPaginatorImpl` class – you will notice we
    pass in a key, a `loadUpdated` value, and a request which is a suspend function
    that returns a result from our `Student` type; we also pass the `nextkey`, which
    tells us where we are. Then, in case of an error, we have the throwable error
    and a `suspend` value, `success`, which gives us the `success` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: So when we override our function from the `loadNextStudent()` interface, we
    first check our current state request and return our initial value as `false`,
    but we update it after our status check. We also ensure that we reset the key
    by setting the `currentKey` to the `nextKey`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy if you ever need to customize an item in your `LazyColumn`,
    ensuring you have great lists.
  prefs: []
  type: TYPE_NORMAL
- en: The `loadStudentProfile()` function has a `viewModelScope.launch {...}`. A ViewModel
    scope is defined for each ViewModel in our application. In addition, any coroutine
    launched in this scope is auto-canceled if the ViewModel is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what a ViewModel is. To help refresh your knowledge,
    you can look into [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling the
    UI State in Jetpack Compose and* *Using Hilt*.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and displaying paged data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are essential steps to consider when loading and displaying paged data.
    In addition, the Paging library provides tremendous advantages for loading and
    displaying large, paged datasets. A few steps you must have in mind is ensuring
    you first define a data source, your Paging Source set up streams if needed, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how loading and displaying paged data works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to have completed the *Implementing the Jetpack Paging library* recipe
    to be able to follow along with the explanation of this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed in our first recipe that we override `load()`, a method
    that we use to indicate how we retrieve the paged data from our corresponding
    data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start refreshing at page `1` if `val page = params.key ?: 1` is undefined
    when we override `getRefreshKey()`; we try to find the page key of the closest
    page to the anchor position from either our previous key or the next key. We also
    need to ensure we handle cases where we might have some `null` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the Paging library, you can specify the position of the first item
    to be displayed on the screen using the `anchorPosition` parameter. In addition,
    `anchorPosition` is an optional parameter that you can pass to the `PagingItems`
    composable function, which is used to display paged data. The `anchorPosition`
    parameter is used to specify the position of the first item to be displayed on
    the screen when the composable is first rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoadParams` object carries the information about the load operation to
    be performed. In addition, it knows about the key to be loaded and the number
    of items to be displayed on the UI. Furthermore, to better understand how the
    `load()` function receives the key for each specific load and updates it, review
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – How load() uses and updates the key](img/Figure_8.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – How load() uses and updates the key
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to transform data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing any code dealing with Paging, you need to understand how you can
    transform the data stream as you load it to your users. For instance, you may
    need to filter a list of items or even convert the items to a different type before
    you can feed the UI with the data.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, ensuring you apply transformation directly to the stream data lets you
    keep your repository and UI logic separated cleanly. In this recipe, we will try
    to understand how we can transform data streams.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along, you must be familiar with the primary usage of the Paging library;
    hence make sure you have read the previous recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look into how we can apply the essential transformation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert and filter the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle separators in the UI and convert the UI model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recipe is helpful to you if you are already using Paging in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to place the transformation inside a `map{PagingData ->}`. A
    map in Kotlin applies the given lambda function to each element and returns a
    list of the lambda results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, when we want to convert the data or filter, once we have access to
    our `PagingData` object, we can use `map()` again on each item separately in the
    paged list. A typical use case is when you want to map a database or network layer
    object onto an object that might be used in the UI layer specifically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to place the filter operation inside the map because the filter
    applies to the `PagingData` object. Then once the data is filtered out from our
    `PagingData`, the new instance is paged to the UI layer and displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, when handling separators in the UI or converting the UI model, the
    most significant steps are ensuring that you do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the UI models to accommodate your separator items.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform the data dynamically and add the separators between presenting and
    loading the data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the UI to handle the separator items better.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PagingData` is encapsulated in a reactive stream; what this means is that
    before loading the data and displaying it to the users, you can incrementally
    apply the transform to the data. Transforming data streams can be crucial when
    you have a complex application, and handling this situation in advance might help
    ensure your application scales better and help minimize the complexity of your
    data growth.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is fair to acknowledge that this recipe cannot cover all the information
    you need to know about transforming the data stream. That said, if you encounter
    an issue and want to learn more, you can always reference the following link to
    learn more about how you can handle separators in the UI and more: [https://developer.android.com/topic/libraries/architecture/paging/v3-transform](https://developer.android.com/topic/libraries/architecture/paging/v3-transform).'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to Paging 3 and understanding the benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be using the old Paging version, in this case, Paging 2 or 1, and
    you might be required to migrate to utilize the benefits Paging 3 offers. Paging
    3 offers enhanced functionality and ensures it addresses the most common challenges
    people experience using Paging 2.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look into how you can migrate to the latest recommended
    Paging library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your application is already using Paging 3, then you can skip this recipe;
    this step-by-step migration guide is intended for users currently using the older
    versions of the Paging library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrating from old versions of the Paging library might seem complex due to
    the fact that each application is unique, and complexities might vary. In our
    example, however, we will touch on a low-level kind of migration since our example
    application does not need any migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform migration from old Paging libraries, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to replace the refresh keys, and this is because we need
    to define how refreshing resumes from the middle of loading data. We will do this
    by first implementing `getRefreshKey()`, which maps the correct initial key using
    `PagingState.anchorPosition` as the recent index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to ensure we replace the positional data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using the old Paging library, the paged data uses `DataSource.map()`,
    `mapByPage`, `Factory.map()`, and `Factory.mapByPage`. In Paging 3, however, all
    these are applied as operators to `PagingData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, to ensure you migrate from `PageList`, which is in Paging 2, you will
    need to migrate to `PagingData`. The most notable change is that `PagedList.Config`
    is not `PagingConfig`. In addition, the `Pager()` exposes an observable `Flow<PagingData>`
    with its flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure your migration is complete and successful, you must make sure you
    migrate all the significant components from Paging 2\. This includes the `DataSource`
    classes, `PagedList`, and `PagedListAdapter` if your application uses it. Furthermore,
    some Paging 3 components work well with other versions, which simply means it
    is backward compatible.
  prefs: []
  type: TYPE_NORMAL
- en: The most notable change to `PagingSource` in Paging 3 is that it combines all
    the loading functions into one, now called `load()` in `PagingSource`. This ensures
    there is no redundancy in the code because the loading logic is often identical
    to the old API. In addition, the loading function parameters in Paging 3 now use
    the `LoadParams` sealed class, which has subclasses for each load type.
  prefs: []
  type: TYPE_NORMAL
- en: In `PagedList`, which is used in Paging 2, when you migrate, you might use `PagingData`
    and `Pager`. When you start to use `PagingData` from Paging 3, you should ensure
    that the configuration is moved from the old `PagedList.Config` to `PagingConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for your Paging Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests for your implementations is crucial. We will write unit tests
    for our `PagingSource` implementation in this recipe to test our logic. Some tests
    that might be worth writing are checking when news Paging load failure happens.
  prefs: []
  type: TYPE_NORMAL
- en: We can also test the success state and more. You can follow the pattern to write
    tests for your project or use case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow this recipe step by step, you need to have followed the *Implementing
    the Jetpack Paging library* recipe, and you need to use the `PagingJetpackExample`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `PagingJetpackExample` and follow along with this project to add unit
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following testing libraries to your `build.gradle` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After adding the dependencies, create a new package and call it `data` in your
    `test` package in the project structure. You can reference the *Understanding
    the Android project structure* recipe in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android Development Skills*, if you need help finding
    the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test class and call it `NewsArticlePagingSourceTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class, let’s go ahead and add `Mock` to mock our `ApiService` interface
    and create a `lateinit var newsApiService` that we will initialize at our `@``Before`
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s go ahead and create our `@Before` so we can run our `CoroutineDispatchers`,
    which is used by all standard builders such as async, and launch to our `@Before`
    step too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test we will need to write is to check when a failure happens. Hence
    let’s go ahead and set up our test. A `403` response is a forbidden status code
    indicating the server understood your request but did not authorize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To continue our test, we will need to use `Mockito.doThrow(error)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, finally, we trigger `PagingSource.LoadResult.Error` and pass in the type,
    then assert:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add two more additional tests and then add `tearDown` to clean up the
    coroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use `Mock` in unit tests, and the general idea is based on the notion that
    the objects under tests might have dependencies on other complex objects. Based
    on this, it is much easier to isolate the behavior of the object we want by mocking
    the object, which ensures it has the same behavior as our real object and makes
    testing easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `lateinit var newsPagingSource: NewsArticlePagingSource` is used for late
    initialization, and we initialize it on our `@``Before` function.'
  prefs: []
  type: TYPE_NORMAL
