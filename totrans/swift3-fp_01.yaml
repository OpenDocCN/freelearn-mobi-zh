- en: Chapter 1. Getting Started with Functional Programming in Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：Swift 中函数式编程入门
- en: 'In this chapter, we will be introduced to functional programming paradigms,
    such as immutability, stateless programming, pure, first-class, and higher-order
    functions. This chapter will give an introduction to the Swift programming language
    and functional programming paradigms in Swift. The following topics will be covered
    along with examples:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍函数式编程范式，例如不可变性、无状态编程、纯函数、一等函数和高阶函数。本章将介绍 Swift 编程语言和 Swift 中的函数式编程范式。以下主题将涵盖，并附带示例：
- en: Why functional programming matters?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么函数式编程很重要？
- en: What is functional programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Swift language basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 语言基础
- en: Immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: First-class, higher-order, and pure functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一等、高阶和纯函数
- en: Optionals and pattern matching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选值和模式匹配
- en: Closures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Type aliasing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Why functional programming matters?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么函数式编程很重要？
- en: Software solutions are becoming complex and it is necessary to structure them
    very well for future maintenance and extension. Software engineers try to modularize
    software to smaller pieces and abstract away complexities in different pieces
    and layers. Dividing the code into smaller pieces makes it possible to tackle
    each problem individually. This approach improves collaboration because different
    engineers can take responsibility for different pieces. Also, they can work on
    specific parts of software without being concerned about the other parts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件解决方案正变得越来越复杂，为了未来的维护和扩展，有必要对它们进行很好的结构化。软件工程师试图将软件模块化成更小的部分，并在不同的部分和层中抽象出复杂性。将代码分成更小的部分使得可以单独处理每个问题。这种方法提高了协作性，因为不同的工程师可以负责不同的部分。此外，他们可以在不关心其他部分的情况下专注于软件的特定部分。
- en: Dividing software into smaller pieces is not the biggest challenge in most of
    the projects and programming languages. For instance, in **object-oriented programming**
    (**OOP**), software is divided into smaller pieces such as packages, classes,
    interfaces, and methods. Engineers tend to divide the software into these building
    blocks by domains, logic, and layers. Classes are recipes to create instances
    and objects. As the name suggests, the most important building blocks in OOP are
    objects. Engineers deal with objects and the role and responsibility for them
    should be clear and understandable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件划分为更小的部分并不是大多数项目和编程语言中的最大挑战。例如，在**面向对象编程**（**OOP**）中，软件被划分为更小的部分，如包、类、接口和方法。工程师倾向于通过领域、逻辑和层来划分软件为这些构建块。类是创建实例和对象的配方。正如其名所示，面向对象编程中最重要的构建块是对象。工程师处理对象，它们的作用和责任应该是清晰和可理解的。
- en: In OOP, connecting the building blocks to each other is not as easy as dividing
    them. Connection between different objects may propose strong coupling between
    them. Coupling is the biggest source of complexity in OOP. A change in a module
    or class could force change in all coupled modules and classes. Also, a particular
    module or class might be harder to reuse and test because of coupled modules or
    classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，将构建块连接起来并不像将它们分开那样容易。不同对象之间的连接可能会导致它们之间产生强烈的耦合。耦合是面向对象编程中复杂性的最大来源。模块或类中的任何变化都可能迫使所有耦合的模块和类发生变化。此外，由于耦合的模块或类，特定的模块或类可能更难重用和测试。
- en: Software engineers try to loosen coupling by structuring the software well and
    applying different principles and design patterns. For instance, **single responsibility,
    open-closed, Liskov substitution, interface segregation and dependency inversion**
    (**SOLID**) principles when applied together properly tend to make software easy
    to maintain and extend.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师试图通过合理地构建软件结构和应用不同的原则和设计模式来放松耦合。例如，当正确应用时，**单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则**（**SOLID**）通常会使软件易于维护和扩展。
- en: Even though it is possible to decrease the coupling and simplify software structures,
    managing the memory, referencing to instances, and testing different objects remains
    difficult because, in OOP, objects are open to change and mutation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有可能减少耦合并简化软件结构，但管理内存、引用实例和测试不同对象仍然很困难，因为在面向对象编程（OOP）中，对象是开放的，容易发生变化和突变。
- en: In functional programming, pure functions are the most important building blocks.
    Pure functions do not rely on data outside of themselves and they do not change
    data that exists outside of them. Pure functions are easy to test because they
    will always provide the same results.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，纯函数是最重要的构建块。纯函数不依赖于自身之外的数据，并且它们不会改变自身之外存在的数据。纯函数易于测试，因为它们总是会提供相同的结果。
- en: Pure functions can be executed on different threads or cores without any mechanisms
    to handle multithreading and multiprocessing. This is a very important benefit
    of functional programming over OOP as multicore programming mechanisms are very
    complex to handle in OOP. Also, programming for multicore computers is becoming
    more important day by day because hardware engineers have finally hit the speed
    limit of light. Computer clocks will not be getting faster in the near future
    so, in order to have more cycles per second, hardware engineers are adding more
    processors to chips. There seems no end to how many processors we will have in
    our computers. A higher number of processors to be used for a program means a
    more complex multithreading and multicore mechanism to handle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可以在不同的线程或核心上执行，而不需要任何处理多线程和多进程的机制。这是函数式编程相对于OOP的一个重要优势，因为在OOP中处理多核编程机制非常复杂。此外，为多核计算机编程正变得越来越重要，因为硬件工程师最终达到了光速的限制。计算机时钟在不久的将来不会更快，因此，为了每秒有更多的周期，硬件工程师正在将更多的处理器添加到芯片上。我们似乎没有尽头，不知道我们的计算机中会有多少处理器。一个程序要使用的处理器数量越多，处理多线程和多核机制的复杂性就越大。
- en: Functional programming eliminates the need for a complex multicore programming
    mechanism, and as pure functions are not dependent on any instances or data outside
    of themselves, it is easy to change them without changing other parts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程消除了对复杂的多核编程机制的需求，并且由于纯函数不依赖于任何实例或自身之外的数据，因此很容易在不改变其他部分的情况下更改它们。
- en: What is functional programming?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: We know functional programming matters, but what is it really? There is a lot
    of hype related to functional programming and there are a lot of definitions about
    it, but simply it is a style of programming that models computations as the evaluation
    of expressions. Functional programming is a declarative programming style, as
    opposed to OOP that is categorized as imperative programming.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道函数式编程很重要，但它到底是什么？与函数式编程相关的炒作很多，关于它的定义也有很多，但简单来说，它是一种将计算建模为表达式的评估的编程风格。函数式编程是一种声明式编程风格，与被归类为命令式编程的面向对象编程（OOP）相对。
- en: Theoretically, functional programming employs the concepts of category theory,
    which is a branch of mathematics. It is not necessary to know the category theory
    to be able to program functionally but studying it will help us grasp some of
    the more advanced concepts such as *functors*, *applicative functors*, and *monads*.
    We will get into category theory and its relationship with functional programming
    later, so for now we are not going to talk math and we will scratch the surface
    of functional programming pragmatically.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，函数式编程采用了范畴论的概念，范畴论是数学的一个分支。了解范畴论对于能够以函数式编程并不必要，但学习它将帮助我们掌握一些更高级的概念，例如*函子*、*应用函子*和*单子*。我们将在后面的章节中深入探讨范畴论及其与函数式编程的关系，所以现在我们不会谈论数学，而是从实用主义的角度来探讨函数式编程。
- en: 'Let''s start with an example to understand the differences between functional
    programming and OOP styles. The following example gives two different approaches
    to array element multiplication:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始，了解函数式编程和OOP风格之间的差异。以下示例给出了两种不同的数组元素乘法方法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the imperative example, we give a command to go through each item in the
    array, multiply each item by `3`, and add it to a new array. In the declarative
    example, we declare how numbers should be mapped. We will have more examples of
    declarative programming in upcoming chapters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式示例中，我们给出一个命令遍历数组中的每个元素，将每个元素乘以`3`，并将其添加到新的数组中。在声明式示例中，我们声明了数字应该如何映射。我们将在接下来的章节中提供更多关于声明式编程的示例。
- en: In functional programming, functions are the fundamental building blocks. In
    OOP, programs are composed of classes and statements, which change the state of
    classes when executed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，函数是基本的构建块。在面向对象编程（OOP）中，程序由类和语句组成，当执行时，这些语句会改变类的状态。
- en: Functional programming avoids using mutable states. Avoiding mutable states
    makes it easier to test, read, and understand the code although it is not easy
    to avoid mutable states in some cases such as file and database operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程避免使用可变状态。避免可变状态使得代码更容易测试、阅读和理解，尽管在某些情况下（如文件和数据库操作）避免可变状态并不容易。
- en: Functional programming requires functions to be first-class. First-class functions
    are treated like any other values and can be passed to other functions or returned
    as a result of a function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程要求函数是一等公民。一等函数被当作任何其他值一样对待，可以被传递给其他函数或作为函数的结果返回。
- en: Functions can be formed as higher-order functions that take other functions
    as their arguments. Higher-order functions are used to refactor code and reduce
    the amount of repetition. Higher-order functions can be used to implement **domain-specific
    languages** (**DSL**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以形成高阶函数，它们接受其他函数作为参数。高阶函数用于重构代码和减少重复。高阶函数可以用来实现**领域特定语言**（**DSL**）。
- en: Functions are pure so they do not depend on any data outside of themselves and
    do not change any data outside of themselves. Pure functions provide the same
    result each time that they are executed. This property of pure functions is called
    **referential transparency** and makes it possible to conduct *equational reasoning*
    on the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是纯函数，它们不依赖于自身之外的数据，也不改变自身之外的数据。纯函数每次执行都会提供相同的结果。纯函数的这个特性被称为**引用透明性**，使得在代码上可以进行**等式推理**。
- en: 'In functional programming, expressions can be evaluated lazily. For instance,
    in the following code example, only the first element in the array is evaluated:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，表达式可以懒加载。例如，在下面的代码示例中，只有数组中的第一个元素被评估：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `lazy` keyword is used to get a lazy version of the collection in this example
    so only the first item in the array is multiplied by `3` and the rest of the items
    are not mapped.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，使用`lazy`关键字来获取集合的懒加载版本，因此只有数组中的第一个元素被乘以`3`，其余元素不会被映射。
- en: The Swift programming language
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift编程语言
- en: Swift is an open source hybrid language developed by Apple that combines OOP
    and protocol-oriented programming with functional programming paradigms. Swift
    can be used along with Objective-C to develop macOS, iOS, tvOS, and watchOS applications.
    Swift can also be used on Ubuntu Linux to develop web applications. This book
    explains Swift 3.0 Preview 1 and utilizes Xcode 8.0 beta. Source code at GitHub
    repository will be updated frequently to catch up with Swift changes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是由Apple开发的开源混合语言，它结合了面向对象编程和协议导向编程，以及函数式编程范式。Swift可以与Objective-C一起用于开发macOS、iOS、tvOS和watchOS应用程序。Swift也可以在Ubuntu
    Linux上用于开发Web应用程序。本书解释了Swift 3.0 Preview 1，并使用Xcode 8.0 beta。GitHub仓库中的源代码将频繁更新，以跟上Swift的变化。
- en: Swift features
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift特性
- en: Swift has borrowed many concepts from other programming languages such as Scala,
    Haskell, C#, Rust, and Objective-C and has the following features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Swift借鉴了许多其他编程语言的概念，如Scala、Haskell、C#、Rust和Objective-C，并具有以下特性。
- en: Modern syntax
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代语法
- en: Swift has a modern syntax that eliminates the verbosity of programming languages
    such as Objective-C. For instance, the following code example shows an Objective-C
    class with a property and method. Objective-C classes are defined in two separate
    files (interface and implementation). The `VerboseClass.h` file defines an interface
    as a subclass of the `NSObject` class. It defines a property, `ourArray`, and
    a method, `aMethod`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Swift拥有现代语法，消除了像Objective-C这样的编程语言的冗余。例如，以下代码示例展示了具有属性和方法的Objective-C类。Objective-C类在两个独立的文件中定义（接口和实现）。`VerboseClass.h`文件定义了一个接口，作为`NSObject`类的子类。它定义了一个属性`ourArray`和一个方法`aMethod`。
- en: 'The implementation file imports the header class and provides an implementation
    for `aMethod`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件导入头文件类，并为`aMethod`提供实现：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A similar functionality in Swift can be achieved as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，可以通过以下方式实现类似的功能：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As seen from this example, Swift eliminates a lot of unnecessary syntax and
    keeps code very clean and readable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，Swift消除了许多不必要的语法，使代码非常简洁易读。
- en: Type safety and type inference
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型安全和类型推断
- en: 'Swift is a type safe language unlike languages such as Ruby and JavaScript.
    As opposed to type variant collections in Objective-C, Swift provides type safe
    collections. Swift automatically deducts types by the type inference mechanism,
    a mechanism that is present in languages such as C# and C++ 11\. For instance,
    `constString` in the following example is inferred as `String` during the compile
    time and it is not necessary to annotate the type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种类型安全的语言，与 Ruby 和 JavaScript 等语言不同。与 Objective-C 中的类型可变集合相反，Swift 提供了类型安全的集合。Swift
    通过类型推断机制自动推导类型，这种机制存在于 C# 和 C++ 11 等语言中。例如，在以下示例中，`constString` 在编译时被推断为 `String`，因此不需要注释类型：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Immutability
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: Swift makes it easy to define immutable values—in other words, constants—and
    empowers functional programming as immutability is one of the key concepts in
    functional programming. Once constants are initialized, they cannot be altered.
    Although it is possible to achieve immutability in languages such as Java, it
    is not as easy as Swift. To define any immutable type in Swift, the `let` keyword
    can be used no matter if it is a custom type, collection type, or a `Struct` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 使得定义不可变值（即常量）变得容易，从而增强了函数式编程，因为不可变性是函数式编程中的关键概念之一。一旦常量被初始化，它们就不能被更改。虽然在
    Java 等语言中也可以实现不可变性，但并不像 Swift 那样容易。要在 Swift 中定义任何不可变类型，可以使用 `let` 关键字，无论它是自定义类型、集合类型还是
    `Struct` 类型。
- en: Stateless programming
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态编程
- en: Swift provides very powerful structures and enumerations that are passed by
    values and can be stateless; therefore, they are very efficient. Stateless programming
    simplifies the concurrency and multithreading.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了非常强大的结构和枚举，它们通过值传递，并且可以是无状态的；因此，它们非常高效。无状态编程简化了并发和多线程。
- en: First-class functions
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一等函数
- en: Functions are first-class types in Swift as they are in languages such as Ruby,
    JavaScript, and Go so they can be stored, passed, and returned. First-class functions
    empower functional programming style in Swift.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在 Swift 中是一等类型，就像 Ruby、JavaScript 和 Go 等语言一样，因此它们可以被存储、传递和返回。一等函数使 Swift 能够实现函数式编程风格。
- en: Higher-order functions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Higher-order functions can receive other functions as their parameters. Swift
    provides higher-order functions such as `map`, `filter`, and `reduce`. Also, in
    Swift, we can develop our own higher-order functions and DSLs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数可以将其他函数作为其参数。Swift 提供了 `map`、`filter` 和 `reduce` 等高阶函数。此外，在 Swift 中，我们还可以开发自己的高阶函数和
    DSL。
- en: Pattern matching
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching is the ability to destructure values and match different switch
    cases based on correct value matches. Pattern matching capabilities are existent
    in languages such as Scala, Erlang, and Haskell. Swift provides powerful switch-cases
    and if-cases with `where` clauses as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是解构值并根据正确的值匹配来匹配不同的情况的能力。模式匹配能力存在于 Scala、Erlang 和 Haskell 等语言中。Swift 提供了带有
    `where` 子句的强大 switch-cases 和 if-cases。
- en: Generics
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: Swift provides generics that make it possible to write code that is not specific
    to a type and can be utilized for different types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了泛型，这使得编写不特定于类型的代码成为可能，并且可以用于不同类型。
- en: Closures
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are blocks of code that can be passed around. Closures capture the
    constants and variables of the context in which they are defined. Swift provides
    closures with a simpler syntax compared to Objective-C blocks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是代码块，可以被传递。闭包捕获它们定义的上下文中的常量和变量。与 Objective-C 中的块相比，Swift 提供了更简单的语法。
- en: Subscripts
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下标
- en: Swift provides subscripts that are shortcuts to access members of collections,
    lists, sequences, or custom types. Subscripts can be used to set and get values
    by an index without needing separate methods for the setting and getting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了下标，这些下标是访问集合、列表、序列或自定义类型成员的快捷方式。下标可以用来通过索引设置和获取值，而无需为设置和获取分别使用单独的方法。
- en: Optional chaining
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选链
- en: Swift provides optional types that can have some or none values. Swift also
    provides optional chaining to use optionals safely and efficiently. Optional chaining
    empowers us to query and call properties, methods, and subscripts on optional
    types that may be `nil`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了可选类型，它可以有某些或没有值。Swift 还提供了可选链，以安全有效地使用可选类型。可选链使我们能够查询和调用可能为 `nil` 的可选类型的属性、方法和下标。
- en: Extensions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展
- en: Swift provides extensions that are similar to categories in Objective-C. Extensions
    add new functionality to an existing class, structure, enumeration, or protocol
    type even if it is closed source.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了类似于 Objective-C 中的分类的扩展（Extensions）。扩展可以向现有的类、结构体、枚举或协议类型添加新功能，即使它是封闭源代码的。
- en: Objective-C and Swift bridging headers
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Objective-C 和 Swift 桥接头
- en: Bridging headers empower us to mix Swift with Objective-C in our projects. This
    functionality makes it possible to use our previously written Objective-C code
    in Swift projects and vice versa.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接头（Bridging headers）使我们能够在项目中混合使用 Swift 和 Objective-C。这种功能使得我们能够在 Swift 项目中使用之前编写的
    Objective-C 代码，反之亦然。
- en: Automatic Reference Counting
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动引用计数（Automatic Reference Counting，ARC）
- en: Swift handles memory management through **Automatic Reference Counting** (**ARC**),
    like Objective-C and unlike languages such as Java and C# that utilize garbage
    collection. ARC is used to initialize and deinitialize resources, thereby releasing
    memory allocations of the class instances when they are no longer required. ARC
    tracks retains and releases in the code instances to manage the memory resources
    effectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 通过 **自动引用计数**（**ARC**）处理内存管理，类似于 Objective-C，而不像 Java 和 C# 等使用垃圾回收的语言。ARC
    用于初始化和解除初始化资源，从而在不再需要时释放类实例的内存分配。ARC 跟踪代码实例中的保留和释放，以有效地管理内存资源。
- en: REPL and Playground
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REPL 和游乐场
- en: Xcode provides the **Read Eval Print Loop** (**REPL**) command-line environment
    to experiment with the Swift programming language without the need to write a
    program. Also, Swift provides playgrounds that enable us to test Swift code snippets
    quickly and see the results in real time via a visual interface. Playgrounds will
    be used extensively in this book. Also, most of code examples from all the chapters
    can be experimented on Swift Playgrounds App ([https://developer.apple.com/swift/playgrounds/](https://developer.apple.com/swift/playgrounds/))
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了 **读取-评估-打印循环**（**REPL**）命令行环境，用于在无需编写程序的情况下实验 Swift 编程语言。此外，Swift
    还提供了游乐场（Playgrounds），使我们能够快速测试 Swift 代码片段，并通过可视化界面实时查看结果。本书中将广泛使用游乐场。此外，大多数章节中的代码示例都可以在
    Swift Playgrounds App 中进行实验（[https://developer.apple.com/swift/playgrounds/](https://developer.apple.com/swift/playgrounds/)）。
- en: Language basics
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言基础
- en: This section will provide a brief introduction to the basics of Swift programming
    language. Topics in the upcoming subsections of this chapter will be explained
    in detail in the later chapters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要介绍 Swift 编程语言的基础知识。本章后续小节中的主题将在后面的章节中详细解释。
- en: Type safety and type inference
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型安全和类型推断
- en: Swift is a type safe language. This means that we cannot change the type of
    a constant, variable, or expression once we define it. Also, the type safe nature
    of Swift empowers us to find type mismatches during compile time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种类型安全的语言。这意味着一旦我们定义了常量、变量或表达式，就不能更改其类型。此外，Swift 的类型安全特性使我们能够在编译时找到类型不匹配。
- en: 'Swift provides type inference. Swift infers the type of a variable, constant,
    or expression automatically so we do not need to specify the types while defining
    them. Let''s examine the following expressions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了类型推断。Swift 会自动推断变量、常量或表达式的类型，因此我们不需要在定义时指定类型。让我们检查以下表达式：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In these expressions, Swift infers `pi` as `Double`, `primeNumber` as `Int`,
    and `name` as `String`. In case we need special types such as `Int64`, we will
    need to annotate the type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些表达式中，Swift 推断 `pi` 为 `Double` 类型，`primeNumber` 为 `Int` 类型，以及 `name` 为 `String`
    类型。如果我们需要特殊类型如 `Int64`，我们需要对类型进行注解。
- en: Type annotation
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'In Swift, it is possible to annotate types, in other words, explicitly specify
    the type of a variable or expression. Let''s see the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们可以注解类型，换句话说，明确指定变量或表达式的类型。让我们看看以下示例：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we define a constant (`pi`) annotated as `Double`, a tuple
    named `piAndPhi` annotated as `(Double, Double)`, and a parameter of `ourFunction`
    as `Int`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个注解为 `Double` 的常量（`pi`），一个名为 `piAndPhi` 的元组注解为 `(Double, Double)`，以及
    `ourFunction` 函数的参数注解为 `Int`。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code** The code bundle for the book is also hosted
    on GitHub at [https://github.com/PacktPublishing/Swift-3-Functional-Programming](https://github.com/PacktPublishing/Swift-3-Functional-Programming).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**本书的代码包也托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/Swift-3-Functional-Programming](https://github.com/PacktPublishing/Swift-3-Functional-Programming)。我们还有其他丰富的图书和视频的代码包，可在
    [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/) 找到。查看它们吧！'
- en: Type aliases
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'Type aliases define an alternative name for an existing type. We define type
    aliases with the `typealias` keyword. Type aliases are useful when we want to
    refer to an existing type by a name that is contextually more appropriate, such
    as when working with data of a specific size from an external source. For instance,
    in the following example, we provide an alias for an unsigned 32-bit integer that
    can be used later in our code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名定义了现有类型的替代名称。我们使用 `typealias` 关键字定义类型别名。类型别名在需要通过更合适的上下文名称引用现有类型时很有用，例如在处理来自外部源的具体大小数据时。例如，在以下示例中，我们为无符号
    32 位整数提供了一个别名，该别名可以在我们稍后的代码中使用：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `typealias` definitions can be used to simplify the closure and function
    definitions as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`typealias` 定义可以用作简化闭包和函数定义。'
- en: Immutability
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'Swift makes it possible to define variables as mutable and immutable. The `let`
    keyword is used for immutable declarations and the `var` keyword is used for mutable
    declarations. Any variable that is declared with the `let` keyword will not be
    open to change. In the following examples, we define `aMutableString` with the `var`
    keyword so that we will be able to alter it later on; in contrast, we will not
    be able to alter `aConstString` that is defined with the `let` keyword:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 使得定义可变和不可变变量成为可能。`let` 关键字用于不可变声明，而 `var` 关键字用于可变声明。任何使用 `let` 关键字声明的变量将不会开放进行更改。在以下示例中，我们使用
    `var` 关键字定义 `aMutableString` 以便我们稍后能够修改它；相比之下，我们无法修改使用 `let` 关键字定义的 `aConstString`：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In functional programming, it is recommended to define properties as constants
    or immutables with `let` as much as possible. Immutable variables are easier to
    track and less error-prone. In some cases, such as *CoreData* programming, *SDK*
    requires mutable properties; however, in these cases it is recommended to use
    mutable variables.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，建议尽可能使用 `let` 将属性定义为常量或不可变。不可变变量更容易跟踪且错误更少。在某些情况下，例如 *CoreData* 编程，*SDK*
    要求可变属性；然而，在这些情况下，建议使用可变变量。
- en: Tuples
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Swift provides tuples so that they can be used to group multiple values into
    a single compound value. Let''s consider the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供元组，以便可以将多个值组合成一个单一的复合值。让我们考虑以下示例：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tuples can be used as return types in functions to implement multireturn functions
    as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以用作函数的返回类型，以实现多返回值函数。
- en: Optionals
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选类型
- en: 'Swift provides optionals so they can be used in situations where a value may
    be absent. An optional will have some or none values. The `?` symbol is used to
    define a variable as optional. Let''s consider the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供可选类型，以便在可能不存在值的情况下使用。可选类型将具有一些或没有值。`?` 符号用于将变量定义为可选。让我们考虑以下示例：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `!` symbol can be used to forcefully unwrap the value from an optional.
    For instance, the following example forcefully unwraps the `optionalString` variable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`!` 符号可以用来强制展开可选类型中的值。例如，以下示例强制展开 `optionalString` 变量：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Force-unwrapping the optionals may cause errors if the optional does not have
    a value so it is not recommended to use this approach as it is very hard to be
    sure if we are going to have values in optionals in different circumstances. The
    better approach would be to use the optional binding technique to find out whether
    an optional contains a value. Let''s consider the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 强制展开可选类型可能会导致错误，如果可选类型没有值，因此不建议使用这种方法，因为它很难确保在不同情况下可选类型中是否有值。更好的方法是使用可选绑定技术来找出可选类型是否包含值。让我们考虑以下示例：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Basic operators
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本运算符
- en: 'Swift provides the following basic operations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供以下基本操作：
- en: The `=` operator for assignments like so many different programming languages.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与许多不同的编程语言一样，`=` 运算符用于赋值。
- en: The `+` operator for addition, `-` for subtraction, `*` for multiplication, `/`
    for division, and `%` for remainders. These operators are functions that can be
    passed to other functions.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法运算符 `+` 用于加法，减法运算符 `-` 用于减法，乘法运算符 `*` 用于乘法，除法运算符 `/` 用于除法，取余运算符 `%` 用于求余。这些运算符是函数，可以被传递给其他函数。
- en: The `-i` operator for unary minus, `+i` for unary plus operations.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元减法运算符 `-i`，一元加法运算符 `+i`。
- en: The `+=`, `-=`, and `*=` operators for compound assignments.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合赋值运算符 `+=`、`-=` 和 `*=`。
- en: The `a == b` operator for equality, `a != b` for inequality, and `a > b`, `a
    < b`, and `a <= b` for greatness comparison.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于运算符 `a == b`，不等式运算符 `a != b`，以及大于比较 `a > b`、小于比较 `a < b` 和小于等于比较 `a <= b`。
- en: 'The ternary conditional operator, `question ? answer1: answer2`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元条件运算符，`question ? answer1: answer2`。'
- en: Nil coalescing `a ?? b` unwraps optional `a` if it has a value and returns a
    default value `b` if `a` is `nil`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式展开 `a ?? b` 如果可选 `a` 有值，则展开可选 `a` 并返回默认值 `b`；如果 `a` 是 `nil`。
- en: 'Range operators:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围运算符：
- en: Closed range (`a...b`) includes the values `a` and `b`
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭区间 (`a...b`) 包含值 `a` 和 `b`
- en: Half-open range (`a..<b`) includes `a` but does not include `b`
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半开区间 (`a..<b`) 包含 `a` 但不包含 `b`
- en: 'Logical operators:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符：
- en: The `!a` operator is NOT a
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!a` 运算符不是 NOT a'
- en: The `a && b` operator is logical AND
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a && b` 运算符是逻辑与'
- en: The `a || b` operator is logical OR
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a || b` 运算符是逻辑或'
- en: Strings and characters
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串和字符
- en: In Swift, `String` is an ordered collection of characters. `String` is a structure
    and not a class. Structures are value types in Swift; therefore, any `String`
    is a value type and passed by values, not by references.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`String` 是字符的有序集合。`String` 是一个结构体，而不是类。结构体是 Swift 中的值类型；因此，任何 `String`
    都是值类型，通过值传递，而不是通过引用传递。
- en: Immutability
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不可变性
- en: Strings can be defined with `let` for immutability. Strings defined with `var`
    will be mutable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以使用 `let` 定义为不可变。使用 `var` 定义的字符串将是可变的。
- en: String literals
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: '`String` literals can be used to create an instance of `String`. In the following
    coding example, we define and initialize `aVegetable` with the `String` literal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 字面量可用于创建 `String` 实例。在以下编码示例中，我们使用 `String` 字面量定义并初始化 `aVegetable`：'
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Empty Strings
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空字符串
- en: 'Empty `Strings` can be initialized as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串可以按以下方式初始化：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These two strings are both empty and equivalent to each other. To find out
    whether a `String` is empty, the `isEmpty` property can be used as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字符串都是空的，彼此等价。要确定一个 `String` 是否为空，可以使用 `isEmpty` 属性如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Concatenating strings and characters
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接字符串和字符
- en: 'Strings and characters can be concatenated as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和字符可以按以下方式连接：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: String interpolation
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'String interpolation is a way to construct a new `String` value from a mix
    of constants, variables, literals, and expressions by including their values inside
    a `String` literal. Let''s consider the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值是一种通过在字符串字面量中包含它们的值来构造新的 `String` 值的方法，这些值可以是常量、变量、字面量和表达式。以下是一个示例：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: String comparison
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串比较
- en: Strings can be compared with `==` for equality and `!=` for inequality.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以使用 `==` 进行相等比较，使用 `!=` 进行不等比较。
- en: The `hasPrefix` and `hasSuffix` methods can be used for prefix and suffix equality
    checking.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasPrefix` 和 `hasSuffix` 方法可用于前缀和后缀相等性检查。'
- en: Collections
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: Swift provides typed collections such as arrays, dictionaries, and sets. In
    Swift, unlike Objective-C, all elements in a collection will have the same type
    and we will not be able to change the type of a collection after defining it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了诸如数组、字典和集合等类型化的集合。在 Swift 中，与 Objective-C 不同，集合中的所有元素都将具有相同的类型，并且我们无法在定义后更改集合的类型。
- en: 'We can define collections as immutables with `let` and mutables with `var`,
    as shown in the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `let` 定义不可变集合，使用 `var` 定义可变集合，如下例所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for-in` loops can be used to iterate over the items in collections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in` 循环可用于遍历集合中的项。'
- en: Control flows
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流程
- en: Swift provides different control flows that are explained in the following subsections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了不同的控制流程，以下小节将进行解释。
- en: for loops
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for 循环
- en: 'Swift provides `for` and `for-in` loops. We can use the `for-in` loop to iterate
    over items in a collection, a sequence of numbers such as ranges, or characters
    in a string expression. The following example presents a `for-in` loop to iterate
    through all items in an `Int` array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了 `for` 和 `for-in` 循环。我们可以使用 `for-in` 循环遍历集合中的项、数字序列（如范围）或字符串表达式中的字符。以下示例展示了如何使用
    `for-in` 循环遍历 `Int` 数组中的所有项：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is to iterate over dictionaries:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何遍历字典：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use `for` loops with a condition and an incrementer/decrementer. The
    following example presents a `for` loop example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有条件和增量/减量器的`for`循环。以下示例展示了`for`循环的示例：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As C style for loops with incrementers/decrementers are removed from Swift
    3.0, it is recommended to use `for-in` loops with ranges instead, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从Swift 3.0开始移除了具有增量器/减量器的C风格`for`循环，建议使用以下方式的`for-in`循环来代替，如下所示：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: while loops
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while loops
- en: 'Swift provides `while` and `repeat-while` loops. A `while` or `repeat-while`
    loop performs a set of expressions until a condition becomes false. Let''s consider
    the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了`while`和`repeat-while`循环。一个`while`或`repeat-while`循环会执行一系列表达式，直到条件变为假。让我们考虑以下示例：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `while` loop evaluates its condition at the beginning of each iteration.
    The `repeat-while` loop evaluates its condition at the end of each iteration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在每个迭代的开始时评估其条件。`repeat-while`循环在每个迭代的结束时评估其条件。'
- en: stride
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: stride
- en: 'The `stride` functions enable us to iterate through ranges with a step other
    than one. There are two `stride` functions: the `stride to` function, which iterates
    over exclusive ranges, and `stride through`, which iterates over inclusive ranges.
    Let''s consider the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`stride`函数使我们能够以非一为步长遍历范围。有两个`stride`函数：`stride to`函数，它遍历排他性范围，以及`stride through`函数，它遍历包含性范围。让我们考虑以下示例：'
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: if
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if
- en: 'Swift provides `if` to define conditional statements. It executes a set of
    statements only if the condition statement is `true`. For instance, in the following
    example, the `print` statement will be executed because `anEmptyString` is empty:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了`if`来定义条件语句。只有当条件语句为`true`时，才会执行一组语句。例如，在以下示例中，由于`anEmptyString`为空，将执行`print`语句：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: switch
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: switch
- en: 'Swift provides the `switch` statement to compare a value against different
    matching patterns. The related statement will be executed once the pattern is
    matched. Unlike most other C-based programming languages, Swift does not need
    a `break` statement for each `case` and supports any value types. Switch statements
    can be used for range matching and `where` clauses in `switch` statements can
    be used to check for additional conditions. The following example presents a simple `switch`
    statement with an additional conditional checking:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了`switch`语句来比较一个值与不同的匹配模式。一旦匹配到模式，将执行相关的语句。与大多数其他基于C的编程语言不同，Swift不需要在每个`case`中都有`break`语句，并支持任何值类型。`switch`语句可用于范围匹配，并且`switch`语句中的`where`子句可以用来检查额外的条件。以下示例展示了带有附加条件检查的简单`switch`语句：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: guard
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: guard
- en: 'A `guard` statement can be used for early exits. We can use a `guard` statement
    to require that a condition must be `true` in order for the code after the `guard`
    statement to be executed. The following example presents the `guard` statement
    usage:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'A `guard` statement can be used for early exits. We can use a `guard` statement
    to require that a condition must be `true` in order for the code after the `guard`
    statement to be executed. The following example presents the `guard` statement
    usage:'
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the `greet` function requires a value for a person's `name`.
    Therefore, it checks whether it is present with the `guard` statement, otherwise
    it will return and not continue to execute.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`greet`函数需要一个表示人的`name`的值。因此，它使用`guard`语句检查其是否存在，否则它将返回并继续执行。
- en: Functions
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are self-contained blocks of code that perform a specific task.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是执行特定任务的独立代码块。
- en: 'In Swift, function are first-class citizens, meaning that they can be stored,
    passed, and returned. Functions can be curried and defined as higher-order functions
    that take other functions as their arguments. Functions in Swift can have multiple
    input parameters and multiple returns using tuples. Let''s see the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，函数是一等公民，这意味着它们可以被存储、传递和返回。函数可以被柯里化，并定义为接受其他函数作为其参数的高阶函数。Swift中的函数可以使用元组具有多个输入参数和多个返回值。让我们看看以下示例：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Functions can have variadic parameters. Let''s consider the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有可变参数。让我们考虑以下示例：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Prior to Swift 3.0, functions could have mutable and immutable parameters.
    Let''s consider the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 3.0之前，函数可以有可变和不可变参数。让我们考虑以下示例：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mutable parameters are not favorable in Swift functional programming and are removed
    from Swift 3.0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数在Swift函数式编程中不受欢迎，并且从Swift 3.0开始被移除。
- en: 'Functions can have `inout` parameters. Let''s consider the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有`inout`参数。让我们考虑以下示例：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `inout` parameters are not favorable in functional Swift as they mutate
    states and make functions impure.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式 Swift 中，`inout` 参数并不受欢迎，因为它们会改变状态并使函数变得不纯。
- en: 'In Swift, we can define nested functions. The following example presents a
    function named `add` nested inside another function. Nested functions can access
    the data in scope of their parent function. In this example, the `add` function
    has access to the `y` variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们可以定义嵌套函数。以下示例展示了一个名为 `add` 的函数嵌套在另一个函数内部。嵌套函数可以访问其父函数的作用域内的数据。在这个例子中，`add`
    函数可以访问 `y` 变量：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In Swift, functions can return other functions. In the following example, the
    `makeIncrementer` function returns a function that receives an `Int` value and
    returns an `Int` value (`Int -> Int`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，函数可以返回其他函数。在以下示例中，`makeIncrementer` 函数返回一个函数，该函数接收一个 `Int` 值并返回一个
    `Int` 值 (`Int -> Int`)：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Closures
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures are self-contained blocks of code that provide a specific functionality
    and can be stored, passed around, and used in the code. Closures are equivalent
    of blocks in C and Objective-C. Closures can capture and store references to any
    constants and variables from the context in which they are defined. Nested functions
    are special cases of closures. Closures are reference types that can be stored
    as variables, constants, and type aliases. They can be passed to and returned
    from functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是包含特定功能的自包含代码块，可以被存储、传递并在代码中使用。闭包在 C 和 Objective-C 中相当于块。闭包可以捕获并存储它们定义的上下文中任何常量和变量的引用。嵌套函数是闭包的特殊情况。闭包是引用类型，可以作为变量、常量和类型别名存储。它们可以被传递给函数并从函数返回。
- en: 'The following examples present different declarations of closures in Swift
    from the website, http://goshdarnclosuresyntax.com:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了来自网站 http://goshdarnclosuresyntax.com 的 Swift 中不同闭包声明的示例：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Map, filter, and reduce
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射、过滤和缩减
- en: Swift provides `map`, `filter`, and `reduce` functions that are higher-order
    functions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了 `map`、`filter` 和 `reduce` 函数，它们是高阶函数。
- en: Map
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射
- en: 'The `map` function solves the problem of transforming the elements of an array
    using a function. Let''s consider the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数解决了使用函数转换数组元素的问题。让我们考虑以下示例：'
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Filter
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The `filter` function takes a function that, given an element in the array,
    returns `Bool` indicating whether the element should be included in the resulting
    array. Let''s consider the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数接受一个函数，该函数给定数组中的一个元素，返回 `Bool` 值，指示该元素是否应该包含在结果数组中。让我们考虑以下示例：'
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reduce
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩减
- en: 'The `reduce` function reduces an array to a single value. It takes two parameters:
    a starting value and a function, which takes a running total and an element of
    the arrays as parameters and returns a new running total. Let''s consider the
    following example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数将数组缩减为一个单一值。它接受两个参数：一个起始值和一个函数，该函数接受一个运行总和以及数组中的一个元素作为参数，并返回一个新的运行总和。让我们考虑以下示例：'
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Enumerations
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: 'In Swift, an enumeration defines a common type for related values and enables
    us to work with those values in a type-safe way. Values provided for each enumeration
    member can be a `String`, `Character`, `Int`, or any floating-point type. Enumerations
    can store associated values of any given type, and the value types can be different
    for each member of the enumeration if needed. Enumeration members can come prepopulated
    with default values (called raw values), which are all of the same type. Let''s
    consider the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，枚举定义了一个相关值的公共类型，并使我们能够以类型安全的方式处理这些值。为每个枚举成员提供的值可以是 `String`、`Character`、`Int`
    或任何浮点类型。枚举可以存储任何给定类型的关联值，如果需要，枚举的每个成员的值类型可以不同。枚举成员可以预先填充默认值（称为原始值），它们都是同一类型。让我们考虑以下示例：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Enumeration values can be matched with a `switch` statement, which can be seen
    in the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举值可以用 `switch` 语句进行匹配，这在以下示例中可以看到：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Enumerations in Swift are actually algebraic data types created by combining
    other types. Let''s consider the following example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的枚举实际上是通过对其他类型进行组合创建的代数数据类型。让我们考虑以下示例：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MLSTeam` and `NHLTeam` enumerations each have six potential values. If
    we combine them, we will have two new types. A `Team` enumeration can be either `NHLTeam`
    or `MLSTeam` so it has 12 potential values—that is, the sum of the `NHLTeam` and `MLSTeam`
    potential values. Therefore, `Team`, an enumeration, is a sum type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`MLSTeam`和`NHLTeam`枚举各有六个潜在值。如果我们将它们结合起来，我们将有两个新的类型。一个`Team`枚举可以是`NHLTeam`或`MLSTeam`，因此它有12个潜在值——即`NHLTeam`和`MLSTeam`潜在值的总和。因此，枚举`Team`是一个和类型。'
- en: To have a `HockeyAndSoccerTeams` structure, we need to choose one value for `NHLTeam`
    and one for `MLSTeam` so that it has 36 potential values—that is, the product
    of the `NHLTeam` and `MLSTeam` values. Therefore, `HockeyAndSoccerTeams` is a
    product type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个`HockeyAndSoccerTeams`结构体，我们需要为`NHLTeam`和`MLSTeam`选择一个值，这样它就有36个潜在值——即`NHLTeam`和`MLSTeam`值的乘积。因此，`HockeyAndSoccerTeams`是一个乘积类型。
- en: 'In Swift, an enumeration''s option can have multiple values. If it happens
    to be the only option, then this enumeration becomes a product type. The following
    example presents an enumeration as a product type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，枚举的选项可以有多个值。如果它恰好是唯一选项，那么这个枚举就变成了乘积类型。以下示例展示了枚举作为乘积类型：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we can create sum or product types in Swift, we can say that Swift has first-class
    support for algebraic data types.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在Swift中创建和或乘积类型，我们可以说Swift对代数数据类型有第一级支持。
- en: Generics
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Generic code enables us to write flexible and reusable functions and types
    that can work with any type, subject to requirements that we define. For instance,
    the following function that uses `inout` parameters to swap two values can only
    be used with `Int` values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型代码使我们能够编写灵活且可重用的函数和类型，它们可以与任何类型一起工作，前提是我们定义了要求。例如，以下使用`inout`参数来交换两个值的函数只能与`Int`值一起使用：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make this function work with any type, generics can be used, as shown in
    the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此函数与任何类型一起工作，可以使用泛型，如下例所示：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Classes and structures
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类与结构体
- en: 'Classes and structures are general-purpose, flexible constructs that become
    the building blocks of a program''s code. They have the following features:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体是通用、灵活的构造，成为程序代码的构建块。它们具有以下特性：
- en: Properties can be defined to store values
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义属性来存储值
- en: Methods can be defined to provide functionality
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义方法来提供功能
- en: Subscripts can be defined to provide access to their values using subscript
    syntax
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义下标以使用下标语法访问它们的值
- en: Initializers can be defined to set up their functionality beyond a default implementation
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以定义初始化器来设置其功能，超出默认实现
- en: They can conform to protocols to provide standard functionality of certain kinds
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以遵守协议以提供某些类型的标准功能
- en: Classes versus structures
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类与结构体
- en: 'This section compares classes and structures:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本节比较类和结构体：
- en: Inheritance enables one class to inherit the characteristics of another
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承使一个类能够继承另一个类的特性
- en: Type casting enables us to check and interpret the type of a class instance
    at runtime
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换使我们能够在运行时检查和解释类实例的类型
- en: Deinitializers enable an instance of a class to free any resources it has assigned
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构器使类的实例能够释放它所分配的任何资源
- en: Reference counting allows more than one reference to a class instance
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数允许对类实例有多个引用
- en: Structures are value types so they are always copied when they are passed around
    in code
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体是值类型，因此在代码中传递时总是被复制
- en: Structures do not use reference counting
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不使用引用计数
- en: Classes are reference types
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是引用类型
- en: Choosing between classes and structures
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择类与结构体
- en: 'We consider creating a structure when one or more of the following conditions
    apply:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下条件之一适用时，我们考虑创建结构体：
- en: The structure's primary purpose is to encapsulate a few relatively simple data
    values
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的主要目的是封装几个相对简单的数据值
- en: It is reasonable to expect that the encapsulated values will be copied rather
    than referenced when we assign or pass around an instance of the structure
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以合理地预期，当我们分配或传递结构体的实例时，封装的值将被复制而不是被引用
- en: Any properties stored by the structure are themselves value types, which would
    also be expected to be copied rather than referenced
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体存储的任何属性本身也是值类型，这也会期望被复制而不是引用
- en: The structure does not need to inherit properties or behavior from another existing
    type
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不需要从另一个现有类型继承属性或行为
- en: 'Example of good candidates for structures include the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的良好候选者示例包括以下内容：
- en: The size of a geometric shape
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何形状的大小
- en: A point in a 3D coordinate system
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D 坐标系统中的一个点
- en: Identity operators
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 身份运算符
- en: 'As classes are reference types, it is possible for multiple constants and variables
    to refer to the same single instance of class behind the scenes. To find out if
    two constants or variables refer to the same instance of a class exactly, Swift
    provides the following identity operators:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类是引用类型，多个常量和变量可能在实际中指向同一个类的单个实例。为了确定两个常量或变量是否精确地指向同一个类的实例，Swift 提供了以下身份运算符：
- en: Identical to (`===`)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等同于 (`===`)
- en: Not identical to (`!==`)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不等同于 (`!==`)
- en: Properties
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: Properties associate values with a particular class, structure, or enumeration.
    Swift enables us to set subproperties of a structure property directly without
    needing to set the entire object property to a new value. All structures have
    an automatically generated memberwise initializer, which can be used to initialize
    the member properties of new structure instances. This is not true for class instances.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 属性将值与特定的类、结构或枚举相关联。Swift 允许我们直接设置结构属性的字段属性，而无需将整个对象属性设置为新的值。所有结构都有自动生成的成员初始化器，可以用来初始化新结构实例的成员属性。这并不适用于类实例。
- en: Property observers
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性观察者
- en: 'Property observers are used to respond to change in a property''s value. Property
    observers are called every time a property''s value is set, even if the new value
    is the same as the property''s current value. We have the option to define either
    or both of the following observers on a property:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 属性观察者用于响应属性值的更改。每当属性的值被设置时，即使新值与属性的当前值相同，属性观察者都会被调用。我们可以在属性上定义以下观察者之一或两个：
- en: The `willSet` observer is called just before the value is stored
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willSet` 观察者在值存储之前被调用'
- en: The `didSet` observer is called immediately after the new value is stored
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didSet` 观察者在新值存储后立即被调用'
- en: The `willSet` and `didSet` observers are not called when a property is set in
    an initializer before delegation takes place.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器中设置属性之前，`willSet` 和 `didSet` 观察者不会被调用。
- en: Methods
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are functions that are associated with a particular type. Instance methods
    are functions that are called on an instance of a particular type. Type methods
    are functions that are called on the type itself.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与特定类型相关联的函数。实例方法是调用特定类型实例的函数。类型方法是调用类型本身的函数。
- en: 'The following example presents a class containing a type method that is named
    as `someTypeMethod()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个包含名为 `someTypeMethod()` 的类型方法的类：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can call this method as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此方法称为如下：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Subscripts
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下标
- en: 'Subscripts are shortcuts to access the member elements of a collection, list,
    sequence, or any custom type that implements subscripts. Let''s consider the following
    example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下标是访问集合、列表、序列或任何实现下标的自定义类型的成员元素的快捷方式。让我们考虑以下示例：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Inheritance
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: 'A class can inherit methods, properties, and other characteristics from another
    class:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以从另一个类继承方法、属性和其他特性：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Swift classes do not inherit from a universal base class. Classes that we define
    without specifying a superclass automatically become base classes for us to build
    on. To override a characteristic that would otherwise be inherited, we prefix
    our overriding definition with the `override` keyword. An overridden method, property,
    or subscript can call the superclass version by calling `super`. To prevent overrides,
    the `final` keyword can be used.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 类不继承自通用基类。我们定义的未指定超类的类自动成为我们构建的基础类。要覆盖继承的特性，我们使用 `override` 关键字作为覆盖定义的前缀。被覆盖的方法、属性或下标可以通过调用
    `super` 来调用超类版本。要防止覆盖，可以使用 `final` 关键字。
- en: Initialization
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The process of preparing an instance of a class, structure, or enumeration
    for use is called initialization. Classes and structures must set all of their
    stored properties to an appropriate initial value by the time an instance of that
    class or structure is created. Stored properties cannot be left in an intermediate
    state. We can modify the value of a constant property at any point during initialization
    as long as it is set to a definite value by the time initialization finishes.
    Swift provides a default initializer for any structure or base class that provides
    default values for all of its properties and does not provide at least one initializer
    itself. Let''s consider the following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个类、结构体或枚举的实例以供使用的过程称为初始化。类和结构体必须在创建该类或结构体的实例时将所有存储属性设置为适当的初始值。存储属性不能处于中间状态。我们可以在初始化过程中修改常量属性的值，只要在初始化完成时将其设置为确定的值。Swift为任何结构体或基类提供默认初始化器，如果它为所有属性提供默认值并且没有提供至少一个初始化器。让我们考虑以下示例：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `struct` types automatically receive a memberwise initializer if we do not
    define any of our own custom initializers, even if the struct's stored properties
    do not have default values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有定义任何自定义初始化器，`struct` 类型会自动接收一个成员初始化器，即使结构体的存储属性没有默认值。
- en: 'Swift defines two kinds of initializers for class types:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Swift为类类型定义了两种初始化器：
- en: '**Designated initializers**: Methods that are able to fully initialize the
    object'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定初始化器**：能够完全初始化对象的方法'
- en: '**Convenience initializers**: Methods that rely on other methods to complete
    initialization'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便利初始化器**：依赖于其他方法来完成初始化的方法'
- en: Deinitialization
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构
- en: A deinitializer is called immediately before a class instance is deallocated.
    Swift automatically deallocates instances when they are no longer needed in order
    to free up resources (ARC).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解构器在类实例被释放之前立即调用。Swift在实例不再需要时自动释放实例，以释放资源（ARC）。
- en: Automatic Reference Counting
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动引用计数
- en: Reference counting only applies to instances of classes. Structures and enumerations
    are value types, not reference types, and are not stored and passed by reference.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数仅适用于类的实例。结构体和枚举是值类型，不是引用类型，它们不是通过引用存储和传递的。
- en: 'Weak references can be used to resolve strong reference cycles and can be defined
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用可以用来解决强引用循环，可以定义为如下：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: An unowned reference does not keep a strong reference hold on the instance it
    refers to. Unlike a weak reference, however, an unowned reference is always defined
    as a non-optional type. A closure capture list can be used to resolve closure
    strong reference cycles.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非拥有引用不会对其引用的实例保持强引用。然而，与弱引用不同的是，非拥有引用始终定义为非可选类型。可以使用闭包捕获列表来解决闭包强引用循环。
- en: A capture in a closure can be defined as an unowned reference when the closure
    and the instance that it captures will always refer to each other and be deallocated
    at the same time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包和它捕获的实例将始终相互引用并在同一时间被释放时，可以在闭包中定义一个非拥有引用。
- en: 'A capture as a weak reference can be defined when the capture''s reference
    may become `nil` at some point in the future. Weak references are always of an
    optional type. Let''s consider the following example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获的引用可能在未来的某个时刻变为`nil`时，可以定义一个作为弱引用的捕获。弱引用始终为可选类型。让我们考虑以下示例：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Optionals and optional chaining
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选值和可选链
- en: 'Optionals are Swift types that can have some or none values. Optional chaining
    is a process to query and call properties, methods, and subscripts on an optional
    that might currently be `nil`. Optional chaining in Swift is similar to messaging `nil`
    in Objective-C, but in a way that works for any type and can be checked for success
    or failure. Let''s consider the following example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可选值是Swift类型，可以具有一些或没有值。可选链是一个查询和调用可能当前为`nil`的可选值的属性、方法和子脚本的进程。Swift中的可选链类似于Objective-C中的`nil`消息，但以一种适用于任何类型并且可以检查成功或失败的方式。让我们考虑以下示例：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example, we were able to access `numberOfRooms`, which was a property
    of an optional type (`Residence`), using optional chaining.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们能够通过可选链访问`numberOfRooms`，这是可选类型（`Residence`）的一个属性。
- en: Error handling
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: Swift provides support to throw, catch, propagate, and manipulate recoverable
    errors at runtime.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Swift在运行时提供支持抛出、捕获、传播和处理可恢复错误的机制。
- en: 'Value types should conform to the `ErrorType` protocol to be represented as
    errors. The following example presents some 4xx and 5xx HTTP errors as `enum`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型应该符合 `ErrorType` 协议才能表示为错误。以下示例展示了某些 4xx 和 5xx HTTP 错误作为 `enum`：
- en: '[PRE52]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We will be able to throw errors using the `throw` keyword and mark functions
    that can throw errors with the `throws` keyword.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用 `throw` 关键字抛出错误，并使用 `throws` 关键字标记可以抛出错误的函数。
- en: 'We can use a `do-catch` statement to handle errors by running a block of code.
    The following example presents JSON parsing error handling in a `do-catch` statement:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `do-catch` 语句通过运行代码块来处理错误。以下示例展示了在 `do-catch` 语句中处理 JSON 解析错误：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can use a `defer` statement to execute a set of statements just before code
    execution leaves the current code block, regardless of how the execution leaves
    the current block of code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `defer` 语句在代码执行离开当前代码块之前执行一系列语句，无论执行如何离开当前代码块。
- en: Type casting
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'Type casting is a way to check the type of an instance and/or to deal with
    that instance as if it is a different superclass or subclass from somewhere else
    in its class hierarchy. There are two types of operators to check and cast types:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是一种检查实例类型的方式，并且/或者将实例作为它类层次结构中其他地方的不同超类或子类来处理。有两种类型的运算符用于检查和转换类型：
- en: 'Type check operator (`is`): This checks whether an instance is of a definite
    subclass type.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查运算符（`is`）：这检查一个实例是否为确定的子类类型。
- en: 'Type cast operator (`as` and `as?`): A constant or variable of a definite class
    type may refer to an instance of a subclass under the hood. If this is the case,
    we can try to downcast it to the subclass type with `as`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换运算符（`as` 和 `as?`）：一个确定类类型的常量或变量可能在底层引用一个子类的实例。如果情况如此，我们可以尝试使用 `as` 将其向下转换为子类类型。
- en: Any and AnyObject
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Any 和 AnyObject
- en: 'Swift provides two special type aliases to work with non-specific types:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了两个特殊的类型别名来处理非特定类型：
- en: '`AnyObject` can represent an instance of any class type'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyObject` 可以表示任何类类型的实例'
- en: '`Any` can represent an instance of any type, including structs, enumerations,
    and function types'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any` 可以表示任何类型的实例，包括结构体、枚举和函数类型'
- en: 'The `Any` and `AnyObject` type aliases must be used only when we explicitly
    require the behavior and capabilities that they provide. Being precise about the
    types we expect to work with in our code is a better approach than using the `Any`
    and `AnyObject` types as they can represent any type and pose dynamism instead
    of safety. Let''s consider the following example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 和 `AnyObject` 类型别名必须仅在我们明确需要它们提供的行为和能力时使用。在我们的代码中明确指定我们期望与之一起工作的类型比使用
    `Any` 和 `AnyObject` 类型更好，因为它们可以表示任何类型，并提供了动态性而不是安全性。让我们考虑以下示例：'
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Nested types
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: Enumerations are often created to support a specific class or structure's functionality.
    Likewise, it can be convenient to declare utility classes and structures purely
    to use within the context of a complex type.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举通常被创建来支持特定类或结构的功能。同样，在复杂类型的上下文中声明仅用于该上下文的实用类和结构体可能也很方便。
- en: 'Swift enables us to declare nested types whereby we nest supporting enumerations,
    classes, and structures within the definition of the type that they support. The
    following example, borrowed from *The Swift Programming Language (Swift 3.0)*
    by *Apple Inc.,* presents nested types:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许我们声明嵌套类型，即在它们支持的类型定义中嵌套支持枚举、类和结构体。以下示例，借鉴自 *《Swift编程语言（Swift 3.0）》*，由
    *苹果公司* 提供，展示了嵌套类型：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Extensions
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展
- en: Extensions add new functionality to an existing class, structure, or enumeration
    type. This includes the ability to extend types for which we do not have access
    to the original source code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展可以向现有的类、结构体或枚举类型添加新功能。这包括扩展我们无法访问原始源代码的类型的能力。
- en: 'Extensions in Swift enable us to perform the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的扩展使我们能够执行以下操作：
- en: Define instance methods and type methods
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实例方法和类型方法
- en: Provide new initializers
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供新的初始化器
- en: Define and use new nested types
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用新的嵌套类型
- en: Define subscripts
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义下标
- en: Add computed properties and computed static properties
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计算属性和计算静态属性
- en: Make an existing type conform to a new protocol
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使现有类型符合新的协议
- en: Extensions enable us to add new functionality to a type but we will not be able
    to override the existing functionality.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展使我们能够向类型添加新功能，但我们无法覆盖现有功能。
- en: 'In the following example, we extend `AType` by making it conform to two protocols:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过使 `AType` 符合两个协议来扩展它：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following example presents an extension to `Double` by adding computed
    properties:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了通过添加计算属性对 `Double` 的扩展：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Protocols
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: A `protocol` defines signatures or types of methods, properties, and other requirements
    that fit to a specific task or piece of functionality. The protocol doesn't actually
    implement any functionality. It only describes what an implementation will look
    like. A class, structure, or enumeration that provides an actual implementation
    of requirements can adopt the protocol. Protocols use the same syntax as normal
    methods but are not allowed to specify default values for method parameters. The
    `is` operator can be used to check whether an instance conforms to a protocol.
    We can check for protocol conformance only if our protocol is marked with `@objc`
    for classes. The `as` operator can be used to cast to a specific protocol.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `protocol` 定义了适合特定任务或功能的方法、属性和其他要求签名或类型。协议实际上并没有实现任何功能。它只描述了实现将看起来像什么。一个提供实际要求实现的类、结构体或枚举可以采用协议。协议使用与正常方法相同的语法，但不允许为方法参数指定默认值。`is`
    操作符可以用来检查一个实例是否遵从协议。只有当我们的协议为类标记了 `@objc` 时，我们才能检查协议遵从性。`as` 操作符可以用来转换到特定的协议。
- en: Protocols as types
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议作为类型
- en: 'Any protocol that we define will become a fully-fledged type to use in our
    code. We can use a protocol as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的任何协议都将成为我们代码中使用的完整类型。我们可以如下使用协议：
- en: A parameter type or return type in a function, method, or initializer
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、方法或初始化器中的参数类型或返回类型
- en: The type of a constant, variable, or property
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量、变量或属性的类型
- en: The type of items in an array, dictionary, or other container
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组、字典或其他容器中项的类型
- en: 'Let''s see the following example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE58]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Protocol extensions
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议扩展
- en: 'Protocol extensions allow us to define behavior on protocols rather than in
    each type''s individual conformance or global function. By creating an extension
    on a protocol, all conforming types automatically gain this method implementation
    without any additional modification. We can specify constraints that conforming
    types must satisfy before the methods and properties of the extensions are available
    when we define a protocol extension. For instance, we can extend our `ExampleProtocol`
    to provide default functionality as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 协议扩展允许我们在协议上定义行为，而不是在每个类型的单独遵从或全局函数中定义。通过在协议上创建扩展，所有遵从的类型自动获得此方法实现，而无需任何额外修改。当我们定义协议扩展时，我们可以指定遵从类型必须满足的约束，以便在扩展的方法和属性可用时。例如，我们可以扩展我们的
    `ExampleProtocol` 以提供默认功能，如下所示：
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Access control
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制
- en: 'Access control restricts access to parts of our code from code in other source
    files and modules:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制限制了来自其他源文件和模块的代码对我们代码的访问：
- en: '**Public**: This enables entities to be used within any source file from their
    defining module and also in a source file from another module that imports the
    defining module'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**: 这使得实体可以在定义它们的模块中的任何源文件中使用，也可以在导入定义模块的另一个模块的源文件中使用'
- en: '**Internal**: This enables entities to be used within any source file from
    their defining module, but not in any source file outside of this module'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**: 这使得实体可以在定义它们的模块中的任何源文件中使用，但不能在模块外部的任何源文件中使用'
- en: '**Private**: This restricts the use of an entity to its own defining source
    file'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**: 这限制了实体只能在其定义的源文件中使用'
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter started by explaining why functional programming matters, and then
    it introduced key paradigms in functional programming. Furthermore, it introduced
    the basics of the Swift programming language with code examples. At this point,
    we should have a broad view of functional programming concepts and the Swift programming
    language. All the topics in this chapter will be covered in detail in upcoming
    chapters.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先解释了函数式编程的重要性，然后介绍了函数式编程中的关键范式。此外，它还通过代码示例介绍了 Swift 编程语言的基础。到目前为止，我们应该对函数式编程概念和
    Swift 编程语言有一个广泛的了解。本章的所有主题将在接下来的章节中详细讲解。
- en: We will begin to dive deeper into these topics by functions as they are the
    most essential building blocks in functional programming. Therefore, the following
    chapter will explain functions and give examples for pure, first-class, higher-order,
    and nested functions. Also, it will explain slightly more advanced topics such
    as memoization, function currying, and composition.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过函数来深入探讨这些主题，因为它们是函数式编程中最基本的构建块。因此，接下来的章节将解释函数，并给出纯函数、一等函数、高阶函数和嵌套函数的示例。此外，它还将解释一些稍微高级的话题，例如记忆化、函数柯里化和组合。
