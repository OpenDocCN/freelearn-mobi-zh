- en: Chapter 1. Getting Started with Functional Programming in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be introduced to functional programming paradigms,
    such as immutability, stateless programming, pure, first-class, and higher-order
    functions. This chapter will give an introduction to the Swift programming language
    and functional programming paradigms in Swift. The following topics will be covered
    along with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Why functional programming matters?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift language basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class, higher-order, and pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionals and pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type aliasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why functional programming matters?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software solutions are becoming complex and it is necessary to structure them
    very well for future maintenance and extension. Software engineers try to modularize
    software to smaller pieces and abstract away complexities in different pieces
    and layers. Dividing the code into smaller pieces makes it possible to tackle
    each problem individually. This approach improves collaboration because different
    engineers can take responsibility for different pieces. Also, they can work on
    specific parts of software without being concerned about the other parts.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing software into smaller pieces is not the biggest challenge in most of
    the projects and programming languages. For instance, in **object-oriented programming**
    (**OOP**), software is divided into smaller pieces such as packages, classes,
    interfaces, and methods. Engineers tend to divide the software into these building
    blocks by domains, logic, and layers. Classes are recipes to create instances
    and objects. As the name suggests, the most important building blocks in OOP are
    objects. Engineers deal with objects and the role and responsibility for them
    should be clear and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: In OOP, connecting the building blocks to each other is not as easy as dividing
    them. Connection between different objects may propose strong coupling between
    them. Coupling is the biggest source of complexity in OOP. A change in a module
    or class could force change in all coupled modules and classes. Also, a particular
    module or class might be harder to reuse and test because of coupled modules or
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers try to loosen coupling by structuring the software well and
    applying different principles and design patterns. For instance, **single responsibility,
    open-closed, Liskov substitution, interface segregation and dependency inversion**
    (**SOLID**) principles when applied together properly tend to make software easy
    to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it is possible to decrease the coupling and simplify software structures,
    managing the memory, referencing to instances, and testing different objects remains
    difficult because, in OOP, objects are open to change and mutation.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, pure functions are the most important building blocks.
    Pure functions do not rely on data outside of themselves and they do not change
    data that exists outside of them. Pure functions are easy to test because they
    will always provide the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions can be executed on different threads or cores without any mechanisms
    to handle multithreading and multiprocessing. This is a very important benefit
    of functional programming over OOP as multicore programming mechanisms are very
    complex to handle in OOP. Also, programming for multicore computers is becoming
    more important day by day because hardware engineers have finally hit the speed
    limit of light. Computer clocks will not be getting faster in the near future
    so, in order to have more cycles per second, hardware engineers are adding more
    processors to chips. There seems no end to how many processors we will have in
    our computers. A higher number of processors to be used for a program means a
    more complex multithreading and multicore mechanism to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming eliminates the need for a complex multicore programming
    mechanism, and as pure functions are not dependent on any instances or data outside
    of themselves, it is easy to change them without changing other parts.
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know functional programming matters, but what is it really? There is a lot
    of hype related to functional programming and there are a lot of definitions about
    it, but simply it is a style of programming that models computations as the evaluation
    of expressions. Functional programming is a declarative programming style, as
    opposed to OOP that is categorized as imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, functional programming employs the concepts of category theory,
    which is a branch of mathematics. It is not necessary to know the category theory
    to be able to program functionally but studying it will help us grasp some of
    the more advanced concepts such as *functors*, *applicative functors*, and *monads*.
    We will get into category theory and its relationship with functional programming
    later, so for now we are not going to talk math and we will scratch the surface
    of functional programming pragmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example to understand the differences between functional
    programming and OOP styles. The following example gives two different approaches
    to array element multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the imperative example, we give a command to go through each item in the
    array, multiply each item by `3`, and add it to a new array. In the declarative
    example, we declare how numbers should be mapped. We will have more examples of
    declarative programming in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, functions are the fundamental building blocks. In
    OOP, programs are composed of classes and statements, which change the state of
    classes when executed.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming avoids using mutable states. Avoiding mutable states
    makes it easier to test, read, and understand the code although it is not easy
    to avoid mutable states in some cases such as file and database operations.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming requires functions to be first-class. First-class functions
    are treated like any other values and can be passed to other functions or returned
    as a result of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can be formed as higher-order functions that take other functions
    as their arguments. Higher-order functions are used to refactor code and reduce
    the amount of repetition. Higher-order functions can be used to implement **domain-specific
    languages** (**DSL**).
  prefs: []
  type: TYPE_NORMAL
- en: Functions are pure so they do not depend on any data outside of themselves and
    do not change any data outside of themselves. Pure functions provide the same
    result each time that they are executed. This property of pure functions is called
    **referential transparency** and makes it possible to conduct *equational reasoning*
    on the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In functional programming, expressions can be evaluated lazily. For instance,
    in the following code example, only the first element in the array is evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy` keyword is used to get a lazy version of the collection in this example
    so only the first item in the array is multiplied by `3` and the rest of the items
    are not mapped.
  prefs: []
  type: TYPE_NORMAL
- en: The Swift programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is an open source hybrid language developed by Apple that combines OOP
    and protocol-oriented programming with functional programming paradigms. Swift
    can be used along with Objective-C to develop macOS, iOS, tvOS, and watchOS applications.
    Swift can also be used on Ubuntu Linux to develop web applications. This book
    explains Swift 3.0 Preview 1 and utilizes Xcode 8.0 beta. Source code at GitHub
    repository will be updated frequently to catch up with Swift changes.
  prefs: []
  type: TYPE_NORMAL
- en: Swift features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift has borrowed many concepts from other programming languages such as Scala,
    Haskell, C#, Rust, and Objective-C and has the following features.
  prefs: []
  type: TYPE_NORMAL
- en: Modern syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift has a modern syntax that eliminates the verbosity of programming languages
    such as Objective-C. For instance, the following code example shows an Objective-C
    class with a property and method. Objective-C classes are defined in two separate
    files (interface and implementation). The `VerboseClass.h` file defines an interface
    as a subclass of the `NSObject` class. It defines a property, `ourArray`, and
    a method, `aMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation file imports the header class and provides an implementation
    for `aMethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar functionality in Swift can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As seen from this example, Swift eliminates a lot of unnecessary syntax and
    keeps code very clean and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety and type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift is a type safe language unlike languages such as Ruby and JavaScript.
    As opposed to type variant collections in Objective-C, Swift provides type safe
    collections. Swift automatically deducts types by the type inference mechanism,
    a mechanism that is present in languages such as C# and C++ 11\. For instance,
    `constString` in the following example is inferred as `String` during the compile
    time and it is not necessary to annotate the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift makes it easy to define immutable values—in other words, constants—and
    empowers functional programming as immutability is one of the key concepts in
    functional programming. Once constants are initialized, they cannot be altered.
    Although it is possible to achieve immutability in languages such as Java, it
    is not as easy as Swift. To define any immutable type in Swift, the `let` keyword
    can be used no matter if it is a custom type, collection type, or a `Struct` type.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides very powerful structures and enumerations that are passed by
    values and can be stateless; therefore, they are very efficient. Stateless programming
    simplifies the concurrency and multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are first-class types in Swift as they are in languages such as Ruby,
    JavaScript, and Go so they can be stored, passed, and returned. First-class functions
    empower functional programming style in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Higher-order functions can receive other functions as their parameters. Swift
    provides higher-order functions such as `map`, `filter`, and `reduce`. Also, in
    Swift, we can develop our own higher-order functions and DSLs.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pattern matching is the ability to destructure values and match different switch
    cases based on correct value matches. Pattern matching capabilities are existent
    in languages such as Scala, Erlang, and Haskell. Swift provides powerful switch-cases
    and if-cases with `where` clauses as well.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides generics that make it possible to write code that is not specific
    to a type and can be utilized for different types.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closures are blocks of code that can be passed around. Closures capture the
    constants and variables of the context in which they are defined. Swift provides
    closures with a simpler syntax compared to Objective-C blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Subscripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides subscripts that are shortcuts to access members of collections,
    lists, sequences, or custom types. Subscripts can be used to set and get values
    by an index without needing separate methods for the setting and getting.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides optional types that can have some or none values. Swift also
    provides optional chaining to use optionals safely and efficiently. Optional chaining
    empowers us to query and call properties, methods, and subscripts on optional
    types that may be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides extensions that are similar to categories in Objective-C. Extensions
    add new functionality to an existing class, structure, enumeration, or protocol
    type even if it is closed source.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C and Swift bridging headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bridging headers empower us to mix Swift with Objective-C in our projects. This
    functionality makes it possible to use our previously written Objective-C code
    in Swift projects and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Reference Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift handles memory management through **Automatic Reference Counting** (**ARC**),
    like Objective-C and unlike languages such as Java and C# that utilize garbage
    collection. ARC is used to initialize and deinitialize resources, thereby releasing
    memory allocations of the class instances when they are no longer required. ARC
    tracks retains and releases in the code instances to manage the memory resources
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: REPL and Playground
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xcode provides the **Read Eval Print Loop** (**REPL**) command-line environment
    to experiment with the Swift programming language without the need to write a
    program. Also, Swift provides playgrounds that enable us to test Swift code snippets
    quickly and see the results in real time via a visual interface. Playgrounds will
    be used extensively in this book. Also, most of code examples from all the chapters
    can be experimented on Swift Playgrounds App ([https://developer.apple.com/swift/playgrounds/](https://developer.apple.com/swift/playgrounds/))
  prefs: []
  type: TYPE_NORMAL
- en: Language basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will provide a brief introduction to the basics of Swift programming
    language. Topics in the upcoming subsections of this chapter will be explained
    in detail in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety and type inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift is a type safe language. This means that we cannot change the type of
    a constant, variable, or expression once we define it. Also, the type safe nature
    of Swift empowers us to find type mismatches during compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides type inference. Swift infers the type of a variable, constant,
    or expression automatically so we do not need to specify the types while defining
    them. Let''s examine the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In these expressions, Swift infers `pi` as `Double`, `primeNumber` as `Int`,
    and `name` as `String`. In case we need special types such as `Int64`, we will
    need to annotate the type.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift, it is possible to annotate types, in other words, explicitly specify
    the type of a variable or expression. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a constant (`pi`) annotated as `Double`, a tuple
    named `piAndPhi` annotated as `(Double, Double)`, and a parameter of `ourFunction`
    as `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code** The code bundle for the book is also hosted
    on GitHub at [https://github.com/PacktPublishing/Swift-3-Functional-Programming](https://github.com/PacktPublishing/Swift-3-Functional-Programming).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type aliases define an alternative name for an existing type. We define type
    aliases with the `typealias` keyword. Type aliases are useful when we want to
    refer to an existing type by a name that is contextually more appropriate, such
    as when working with data of a specific size from an external source. For instance,
    in the following example, we provide an alias for an unsigned 32-bit integer that
    can be used later in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `typealias` definitions can be used to simplify the closure and function
    definitions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift makes it possible to define variables as mutable and immutable. The `let`
    keyword is used for immutable declarations and the `var` keyword is used for mutable
    declarations. Any variable that is declared with the `let` keyword will not be
    open to change. In the following examples, we define `aMutableString` with the `var`
    keyword so that we will be able to alter it later on; in contrast, we will not
    be able to alter `aConstString` that is defined with the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In functional programming, it is recommended to define properties as constants
    or immutables with `let` as much as possible. Immutable variables are easier to
    track and less error-prone. In some cases, such as *CoreData* programming, *SDK*
    requires mutable properties; however, in these cases it is recommended to use
    mutable variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift provides tuples so that they can be used to group multiple values into
    a single compound value. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tuples can be used as return types in functions to implement multireturn functions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift provides optionals so they can be used in situations where a value may
    be absent. An optional will have some or none values. The `?` symbol is used to
    define a variable as optional. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `!` symbol can be used to forcefully unwrap the value from an optional.
    For instance, the following example forcefully unwraps the `optionalString` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Force-unwrapping the optionals may cause errors if the optional does not have
    a value so it is not recommended to use this approach as it is very hard to be
    sure if we are going to have values in optionals in different circumstances. The
    better approach would be to use the optional binding technique to find out whether
    an optional contains a value. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Basic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift provides the following basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `=` operator for assignments like so many different programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` operator for addition, `-` for subtraction, `*` for multiplication, `/`
    for division, and `%` for remainders. These operators are functions that can be
    passed to other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-i` operator for unary minus, `+i` for unary plus operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+=`, `-=`, and `*=` operators for compound assignments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `a == b` operator for equality, `a != b` for inequality, and `a > b`, `a
    < b`, and `a <= b` for greatness comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ternary conditional operator, `question ? answer1: answer2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nil coalescing `a ?? b` unwraps optional `a` if it has a value and returns a
    default value `b` if `a` is `nil`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Range operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closed range (`a...b`) includes the values `a` and `b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Half-open range (`a..<b`) includes `a` but does not include `b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `!a` operator is NOT a
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `a && b` operator is logical AND
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `a || b` operator is logical OR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings and characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, `String` is an ordered collection of characters. `String` is a structure
    and not a class. Structures are value types in Swift; therefore, any `String`
    is a value type and passed by values, not by references.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Strings can be defined with `let` for immutability. Strings defined with `var`
    will be mutable.
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`String` literals can be used to create an instance of `String`. In the following
    coding example, we define and initialize `aVegetable` with the `String` literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Empty Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Empty `Strings` can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These two strings are both empty and equivalent to each other. To find out
    whether a `String` is empty, the `isEmpty` property can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating strings and characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Strings and characters can be concatenated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: String interpolation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'String interpolation is a way to construct a new `String` value from a mix
    of constants, variables, literals, and expressions by including their values inside
    a `String` literal. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: String comparison
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Strings can be compared with `==` for equality and `!=` for inequality.
  prefs: []
  type: TYPE_NORMAL
- en: The `hasPrefix` and `hasSuffix` methods can be used for prefix and suffix equality
    checking.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides typed collections such as arrays, dictionaries, and sets. In
    Swift, unlike Objective-C, all elements in a collection will have the same type
    and we will not be able to change the type of a collection after defining it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define collections as immutables with `let` and mutables with `var`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `for-in` loops can be used to iterate over the items in collections.
  prefs: []
  type: TYPE_NORMAL
- en: Control flows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides different control flows that are explained in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Swift provides `for` and `for-in` loops. We can use the `for-in` loop to iterate
    over items in a collection, a sequence of numbers such as ranges, or characters
    in a string expression. The following example presents a `for-in` loop to iterate
    through all items in an `Int` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is to iterate over dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `for` loops with a condition and an incrementer/decrementer. The
    following example presents a `for` loop example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As C style for loops with incrementers/decrementers are removed from Swift
    3.0, it is recommended to use `for-in` loops with ranges instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: while loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Swift provides `while` and `repeat-while` loops. A `while` or `repeat-while`
    loop performs a set of expressions until a condition becomes false. Let''s consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop evaluates its condition at the beginning of each iteration.
    The `repeat-while` loop evaluates its condition at the end of each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: stride
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `stride` functions enable us to iterate through ranges with a step other
    than one. There are two `stride` functions: the `stride to` function, which iterates
    over exclusive ranges, and `stride through`, which iterates over inclusive ranges.
    Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: if
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Swift provides `if` to define conditional statements. It executes a set of
    statements only if the condition statement is `true`. For instance, in the following
    example, the `print` statement will be executed because `anEmptyString` is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: switch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Swift provides the `switch` statement to compare a value against different
    matching patterns. The related statement will be executed once the pattern is
    matched. Unlike most other C-based programming languages, Swift does not need
    a `break` statement for each `case` and supports any value types. Switch statements
    can be used for range matching and `where` clauses in `switch` statements can
    be used to check for additional conditions. The following example presents a simple `switch`
    statement with an additional conditional checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: guard
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `guard` statement can be used for early exits. We can use a `guard` statement
    to require that a condition must be `true` in order for the code after the `guard`
    statement to be executed. The following example presents the `guard` statement
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `greet` function requires a value for a person's `name`.
    Therefore, it checks whether it is present with the `guard` statement, otherwise
    it will return and not continue to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are self-contained blocks of code that perform a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, function are first-class citizens, meaning that they can be stored,
    passed, and returned. Functions can be curried and defined as higher-order functions
    that take other functions as their arguments. Functions in Swift can have multiple
    input parameters and multiple returns using tuples. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can have variadic parameters. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to Swift 3.0, functions could have mutable and immutable parameters.
    Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Mutable parameters are not favorable in Swift functional programming and are removed
    from Swift 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can have `inout` parameters. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `inout` parameters are not favorable in functional Swift as they mutate
    states and make functions impure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, we can define nested functions. The following example presents a
    function named `add` nested inside another function. Nested functions can access
    the data in scope of their parent function. In this example, the `add` function
    has access to the `y` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, functions can return other functions. In the following example, the
    `makeIncrementer` function returns a function that receives an `Int` value and
    returns an `Int` value (`Int -> Int`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Closures are self-contained blocks of code that provide a specific functionality
    and can be stored, passed around, and used in the code. Closures are equivalent
    of blocks in C and Objective-C. Closures can capture and store references to any
    constants and variables from the context in which they are defined. Nested functions
    are special cases of closures. Closures are reference types that can be stored
    as variables, constants, and type aliases. They can be passed to and returned
    from functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples present different declarations of closures in Swift
    from the website, http://goshdarnclosuresyntax.com:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Map, filter, and reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides `map`, `filter`, and `reduce` functions that are higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `map` function solves the problem of transforming the elements of an array
    using a function. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Filter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `filter` function takes a function that, given an element in the array,
    returns `Bool` indicating whether the element should be included in the resulting
    array. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reduce
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `reduce` function reduces an array to a single value. It takes two parameters:
    a starting value and a function, which takes a running total and an element of
    the arrays as parameters and returns a new running total. Let''s consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Enumerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift, an enumeration defines a common type for related values and enables
    us to work with those values in a type-safe way. Values provided for each enumeration
    member can be a `String`, `Character`, `Int`, or any floating-point type. Enumerations
    can store associated values of any given type, and the value types can be different
    for each member of the enumeration if needed. Enumeration members can come prepopulated
    with default values (called raw values), which are all of the same type. Let''s
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumeration values can be matched with a `switch` statement, which can be seen
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumerations in Swift are actually algebraic data types created by combining
    other types. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `MLSTeam` and `NHLTeam` enumerations each have six potential values. If
    we combine them, we will have two new types. A `Team` enumeration can be either `NHLTeam`
    or `MLSTeam` so it has 12 potential values—that is, the sum of the `NHLTeam` and `MLSTeam`
    potential values. Therefore, `Team`, an enumeration, is a sum type.
  prefs: []
  type: TYPE_NORMAL
- en: To have a `HockeyAndSoccerTeams` structure, we need to choose one value for `NHLTeam`
    and one for `MLSTeam` so that it has 36 potential values—that is, the product
    of the `NHLTeam` and `MLSTeam` values. Therefore, `HockeyAndSoccerTeams` is a
    product type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, an enumeration''s option can have multiple values. If it happens
    to be the only option, then this enumeration becomes a product type. The following
    example presents an enumeration as a product type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we can create sum or product types in Swift, we can say that Swift has first-class
    support for algebraic data types.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generic code enables us to write flexible and reusable functions and types
    that can work with any type, subject to requirements that we define. For instance,
    the following function that uses `inout` parameters to swap two values can only
    be used with `Int` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this function work with any type, generics can be used, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Classes and structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Classes and structures are general-purpose, flexible constructs that become
    the building blocks of a program''s code. They have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Properties can be defined to store values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can be defined to provide functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscripts can be defined to provide access to their values using subscript
    syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializers can be defined to set up their functionality beyond a default implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can conform to protocols to provide standard functionality of certain kinds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes versus structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This section compares classes and structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance enables one class to inherit the characteristics of another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type casting enables us to check and interpret the type of a class instance
    at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deinitializers enable an instance of a class to free any resources it has assigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference counting allows more than one reference to a class instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures are value types so they are always copied when they are passed around
    in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structures do not use reference counting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between classes and structures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We consider creating a structure when one or more of the following conditions
    apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure's primary purpose is to encapsulate a few relatively simple data
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is reasonable to expect that the encapsulated values will be copied rather
    than referenced when we assign or pass around an instance of the structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any properties stored by the structure are themselves value types, which would
    also be expected to be copied rather than referenced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The structure does not need to inherit properties or behavior from another existing
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of good candidates for structures include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of a geometric shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A point in a 3D coordinate system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As classes are reference types, it is possible for multiple constants and variables
    to refer to the same single instance of class behind the scenes. To find out if
    two constants or variables refer to the same instance of a class exactly, Swift
    provides the following identity operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Identical to (`===`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not identical to (`!==`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties associate values with a particular class, structure, or enumeration.
    Swift enables us to set subproperties of a structure property directly without
    needing to set the entire object property to a new value. All structures have
    an automatically generated memberwise initializer, which can be used to initialize
    the member properties of new structure instances. This is not true for class instances.
  prefs: []
  type: TYPE_NORMAL
- en: Property observers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Property observers are used to respond to change in a property''s value. Property
    observers are called every time a property''s value is set, even if the new value
    is the same as the property''s current value. We have the option to define either
    or both of the following observers on a property:'
  prefs: []
  type: TYPE_NORMAL
- en: The `willSet` observer is called just before the value is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `didSet` observer is called immediately after the new value is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `willSet` and `didSet` observers are not called when a property is set in
    an initializer before delegation takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods are functions that are associated with a particular type. Instance methods
    are functions that are called on an instance of a particular type. Type methods
    are functions that are called on the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example presents a class containing a type method that is named
    as `someTypeMethod()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Subscripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subscripts are shortcuts to access the member elements of a collection, list,
    sequence, or any custom type that implements subscripts. Let''s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class can inherit methods, properties, and other characteristics from another
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Swift classes do not inherit from a universal base class. Classes that we define
    without specifying a superclass automatically become base classes for us to build
    on. To override a characteristic that would otherwise be inherited, we prefix
    our overriding definition with the `override` keyword. An overridden method, property,
    or subscript can call the superclass version by calling `super`. To prevent overrides,
    the `final` keyword can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of preparing an instance of a class, structure, or enumeration
    for use is called initialization. Classes and structures must set all of their
    stored properties to an appropriate initial value by the time an instance of that
    class or structure is created. Stored properties cannot be left in an intermediate
    state. We can modify the value of a constant property at any point during initialization
    as long as it is set to a definite value by the time initialization finishes.
    Swift provides a default initializer for any structure or base class that provides
    default values for all of its properties and does not provide at least one initializer
    itself. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `struct` types automatically receive a memberwise initializer if we do not
    define any of our own custom initializers, even if the struct's stored properties
    do not have default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift defines two kinds of initializers for class types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Designated initializers**: Methods that are able to fully initialize the
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convenience initializers**: Methods that rely on other methods to complete
    initialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deinitialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A deinitializer is called immediately before a class instance is deallocated.
    Swift automatically deallocates instances when they are no longer needed in order
    to free up resources (ARC).
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Reference Counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reference counting only applies to instances of classes. Structures and enumerations
    are value types, not reference types, and are not stored and passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weak references can be used to resolve strong reference cycles and can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: An unowned reference does not keep a strong reference hold on the instance it
    refers to. Unlike a weak reference, however, an unowned reference is always defined
    as a non-optional type. A closure capture list can be used to resolve closure
    strong reference cycles.
  prefs: []
  type: TYPE_NORMAL
- en: A capture in a closure can be defined as an unowned reference when the closure
    and the instance that it captures will always refer to each other and be deallocated
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A capture as a weak reference can be defined when the capture''s reference
    may become `nil` at some point in the future. Weak references are always of an
    optional type. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Optionals and optional chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Optionals are Swift types that can have some or none values. Optional chaining
    is a process to query and call properties, methods, and subscripts on an optional
    that might currently be `nil`. Optional chaining in Swift is similar to messaging `nil`
    in Objective-C, but in a way that works for any type and can be checked for success
    or failure. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we were able to access `numberOfRooms`, which was a property
    of an optional type (`Residence`), using optional chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift provides support to throw, catch, propagate, and manipulate recoverable
    errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types should conform to the `ErrorType` protocol to be represented as
    errors. The following example presents some 4xx and 5xx HTTP errors as `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We will be able to throw errors using the `throw` keyword and mark functions
    that can throw errors with the `throws` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a `do-catch` statement to handle errors by running a block of code.
    The following example presents JSON parsing error handling in a `do-catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can use a `defer` statement to execute a set of statements just before code
    execution leaves the current code block, regardless of how the execution leaves
    the current block of code.
  prefs: []
  type: TYPE_NORMAL
- en: Type casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type casting is a way to check the type of an instance and/or to deal with
    that instance as if it is a different superclass or subclass from somewhere else
    in its class hierarchy. There are two types of operators to check and cast types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type check operator (`is`): This checks whether an instance is of a definite
    subclass type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type cast operator (`as` and `as?`): A constant or variable of a definite class
    type may refer to an instance of a subclass under the hood. If this is the case,
    we can try to downcast it to the subclass type with `as`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any and AnyObject
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Swift provides two special type aliases to work with non-specific types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnyObject` can represent an instance of any class type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any` can represent an instance of any type, including structs, enumerations,
    and function types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Any` and `AnyObject` type aliases must be used only when we explicitly
    require the behavior and capabilities that they provide. Being precise about the
    types we expect to work with in our code is a better approach than using the `Any`
    and `AnyObject` types as they can represent any type and pose dynamism instead
    of safety. Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Nested types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerations are often created to support a specific class or structure's functionality.
    Likewise, it can be convenient to declare utility classes and structures purely
    to use within the context of a complex type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift enables us to declare nested types whereby we nest supporting enumerations,
    classes, and structures within the definition of the type that they support. The
    following example, borrowed from *The Swift Programming Language (Swift 3.0)*
    by *Apple Inc.,* presents nested types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extensions add new functionality to an existing class, structure, or enumeration
    type. This includes the ability to extend types for which we do not have access
    to the original source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extensions in Swift enable us to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define instance methods and type methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide new initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define and use new nested types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define subscripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add computed properties and computed static properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an existing type conform to a new protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions enable us to add new functionality to a type but we will not be able
    to override the existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we extend `AType` by making it conform to two protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example presents an extension to `Double` by adding computed
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `protocol` defines signatures or types of methods, properties, and other requirements
    that fit to a specific task or piece of functionality. The protocol doesn't actually
    implement any functionality. It only describes what an implementation will look
    like. A class, structure, or enumeration that provides an actual implementation
    of requirements can adopt the protocol. Protocols use the same syntax as normal
    methods but are not allowed to specify default values for method parameters. The
    `is` operator can be used to check whether an instance conforms to a protocol.
    We can check for protocol conformance only if our protocol is marked with `@objc`
    for classes. The `as` operator can be used to cast to a specific protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols as types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any protocol that we define will become a fully-fledged type to use in our
    code. We can use a protocol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A parameter type or return type in a function, method, or initializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of a constant, variable, or property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of items in an array, dictionary, or other container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Protocol extensions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Protocol extensions allow us to define behavior on protocols rather than in
    each type''s individual conformance or global function. By creating an extension
    on a protocol, all conforming types automatically gain this method implementation
    without any additional modification. We can specify constraints that conforming
    types must satisfy before the methods and properties of the extensions are available
    when we define a protocol extension. For instance, we can extend our `ExampleProtocol`
    to provide default functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Access control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Access control restricts access to parts of our code from code in other source
    files and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: This enables entities to be used within any source file from their
    defining module and also in a source file from another module that imports the
    defining module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: This enables entities to be used within any source file from
    their defining module, but not in any source file outside of this module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This restricts the use of an entity to its own defining source
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by explaining why functional programming matters, and then
    it introduced key paradigms in functional programming. Furthermore, it introduced
    the basics of the Swift programming language with code examples. At this point,
    we should have a broad view of functional programming concepts and the Swift programming
    language. All the topics in this chapter will be covered in detail in upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin to dive deeper into these topics by functions as they are the
    most essential building blocks in functional programming. Therefore, the following
    chapter will explain functions and give examples for pure, first-class, higher-order,
    and nested functions. Also, it will explain slightly more advanced topics such
    as memoization, function currying, and composition.
  prefs: []
  type: TYPE_NORMAL
