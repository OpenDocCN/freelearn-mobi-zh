<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Choosing the Correct Data Structure" id="1ENBI1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Choosing the Correct Data Structure</h1></div></div></div><p class="calibre8">In the previous chapter, we covered Swift-specific features that make Swift fast. It is no less important to choose the correct data structure for a specific use case. In this chapter, we will talk about different data structures, their differences, and when to choose one instead of the other.</p><p class="calibre8">In this chapter, we will cover these topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An overview of data structures </li><li class="listitem">The Swift standard library collections</li><li class="listitem">Array, set, and dictionary</li><li class="listitem">Speeding up with Accelerate and Surge</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Choosing the Correct Data Structure" id="1ENBI1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="An overview of data structures"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec43" class="calibre1"/>An overview of data structures</h1></div></div></div><p class="calibre8">Every programming language has <a id="id315" class="calibre1"/>built-in primitive data types, such as integer, double, character, string, and Boolean. The Swift programing language has some more complex types, such as enumeration, optionals, and tuples. By composing primitive types, we can build more complex data types. To compose them, we use structures and classes.</p><p class="calibre8">A data structure is a way of organizing data in a specific way so that it can be used efficiently for a specific task, for example, searching, checking for existence, and a quick update of values.</p></div></div>
<div class="book" title="Collection types" id="1FLS41-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec44" class="calibre1"/>Collection types</h1></div></div></div><p class="calibre8">Creating a new type and choosing<a id="id316" class="calibre1"/> the correct type for it, either a value or a reference, is an important task, which we covered previously in <a class="calibre1" title="Chapter 2. Making a Good Application Architecture in Swift" href="part0020_split_000.html#J2B81-f05765b7b5914043830034430c83d0a0">Chapter 2</a>, <span class="strong"><em class="calibre10">Making a Good Application Architecture in Swift</em></span>. There is a bigger impact on performance when we work with many instances of the same type when we put them into a collection. Choosing the correct collection for a particular task is very important.</p><p class="calibre8">Swift has some powerful building <a id="id317" class="calibre1"/>collections; we should take a look at them first.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Swift standard library collections"><div class="book" id="1GKCM2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec45" class="calibre1"/>Swift standard library collections</h1></div></div></div><p class="calibre8">You will very often be using different collections to store and process data in your applications. Swift has three different built-in collection types: arrays, dictionaries, and sets.</p><p class="calibre8">The Swift <a id="id318" class="calibre1"/>standard library also has many functions for working with these collections, such as sort, find, filter, map, and many others. These functions have very efficient implementations, and you should use them instead of making your own. First, let's take a look at the different collections.</p></div>

<div class="book" title="Swift standard library collections">
<div class="book" title="Arrays"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec52" class="calibre1"/>Arrays</h2></div></div></div><p class="calibre8">An array is<a id="id319" class="calibre1"/> an ordered <a id="id320" class="calibre1"/>collection of values that provides access to its elements by indexes. It is a very simple and well-known collection. You would use an array in these situations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Simple element storage (often add/remove from the end)</li><li class="listitem">Elements need to be ordered</li><li class="listitem">Random access to elements</li></ul></div><p class="calibre8">Arrays are usually implemented as a continuous block of memory in which you store values. Because memory blocks are usually located next to each other, access to elements can usually be transformed into simple pointer arithmetic: <span class="strong"><em class="calibre10">third element = array start position + (2 * element size)</em></span>.</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Arrays" class="calibre11"/></div><p class="calibre12"> </p><div class="book" title="Using arrays"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec35" class="calibre1"/>Using arrays</h3></div></div></div><p class="calibre8">Arrays are <a id="id321" class="calibre1"/>perfectly fit for storing data for UITableView. Items need to be ordered. We need to know the number of items, get an item by its index, and be able to edit a collection. You would use an array when you need to store two or more objects of the same type.</p><p class="calibre8">Arrays are a <a id="id322" class="calibre1"/>very simple and flexible collection. But because of this, they are often overused in situations where we should use a set, or maybe a dictionary or some other custom collection.</p><div class="book" title="Fast operations"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch05lvl4sec06" class="calibre1"/>Fast operations</h4></div></div></div><p class="calibre8">Arrays have great performance for<a id="id323" class="calibre1"/> some operations with a constant complexity O(1), which doesn't increase with the size of the array. You can use them freely:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Accessing elements</strong></span>: To access <a id="id324" class="calibre1"/>the elements, use these operations, <code class="literal">array[i]</code>, <code class="literal">array.first</code>, and <code class="literal">array.last</code>. The approximate time is 81 nanoseconds, or 0.000000081 seconds.</li><li class="listitem"><span class="strong"><strong class="calibre9">Appending an element</strong></span>: To <a id="id325" class="calibre1"/>append an element, use this operation <code class="literal">array.append(i)</code>. The approximate time is 100 nanoseconds or 0,0000001 seconds.</li></ul></div><p class="calibre8">Inserting and removing elements at both the beginning and a random place is also a very fast operation, but it has O(n) complexity. It increases with the size of the array, as shown here:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Array size</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Time in seconds</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">0 to 50_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.00001</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">500_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.00019</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">5_000_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.0043</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">50_000_000 </p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.040</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">500_000_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.32</p>
</td></tr></tbody></table></div></div><div class="book" title="Slower operations"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch05lvl4sec07" class="calibre1"/>Slower operations</h4></div></div></div><p class="calibre8">Some other operations on arrays<a id="id326" class="calibre1"/> increase very fast with increasing size of arrays. You should be careful while using such methods.</p></div><div class="book" title="Search"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch05lvl4sec08" class="calibre1"/>Search</h4></div></div></div><p class="calibre8">Finding elements has O(n) complexity. The more the <a id="id327" class="calibre1"/>elements in the array, the more the time it will take to find out whether an element exists. To find out whether an element is present in the array, it has to iterate over every element and compare them:</p><div class="informalexample"><pre class="programlisting">let array: [Int]
let index = array.indexOf(3445)</pre></div><p class="calibre8">If the search is not a primary operation that you perform on the collection and the size of the array is, for example, 500_000_000 elements, the search would take 0.5 seconds. If you have to perform searches very often and it's critical to do so very fast, use a set for search operations, or sort an array and use a more effective search algorithm, such as binary search.</p></div><div class="book" title="Sort"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch05lvl4sec09" class="calibre1"/>Sort</h4></div></div></div><p class="calibre8">Sorting has even bigger <a id="id328" class="calibre1"/>complexity than searching for an element; it has O(n * n) complexity. Sorting needs to iterate over an array to find the correct place for one element, and repeat it for every element. The <code class="literal">sort</code> standard library function has a very efficient implementation, and you should use it. It uses different sorting algorithms depending on the array size. Because sorting is expensive, you should cache the sorted result and reuse it if needed. Sorting an array of 500_000_000 <code class="literal">int</code> elements takes about 67 seconds.</p></div></div></div></div>

<div class="book" title="Swift standard library collections">
<div class="book" title="Sets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec53" class="calibre1"/>Sets</h2></div></div></div><p class="calibre8">A set is an<a id="id329" class="calibre1"/> unordered<a id="id330" class="calibre1"/> collection that stores unique objects. Sets are used for checking for the membership.</p><p class="calibre8">Usually, a set is implemented as a hash table. Elements in a set have to conform to <a id="id331" class="calibre1"/>
<span class="strong"><strong class="calibre9">hashable</strong></span> and <a id="id332" class="calibre1"/>
<span class="strong"><strong class="calibre9">equatable</strong></span> protocols.</p><p class="calibre8">When you add an element to a set or search for an element, it uses a hash function of an element to find an index for that element in the storage. Because of this, many operations on a Set are very fast, and it has O(1) complexity.</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="Sets" class="calibre11"/></div><p class="calibre12"> </p><div class="book" title="Using sets"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec36" class="calibre1"/>Using sets</h3></div></div></div><p class="calibre8">Sets are<a id="id333" class="calibre1"/> great for checking whether an object exists in the collection. Also, they are great for getting the difference between two collections, for example, finding what objects were added or removed.</p><p class="calibre8">Sets have two important limitations. They are not ordered and can't contain duplicates:</p><div class="informalexample"><pre class="programlisting">var numbers: Set = [1, 1, 2, 3, 3, 4]
// {2, 3, 1, 4}</pre></div><p class="calibre8">But, a set turns these limitations into features. Because of this and because it uses a hash table to store its elements, it achieves incredible performance for some operations with a constant complexity of O(1) that doesn't increase with the size of the set. The following are the operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Insert:<div class="informalexample"><pre class="programlisting">numbers.insert(10)</pre></div></li><li class="listitem">Lookup: <code class="literal">contains</code>, <code class="literal">IndexOf</code>, and <code class="literal">subscript</code>:<div class="informalexample"><pre class="programlisting">let number = numbers.contains(10)
let foundIndex =  numbers.indexOf(101)
let start: SetIndex = numbers.startIndex
let first = numbers[start]</pre></div></li><li class="listitem">Delete: <code class="literal">remove</code> and <code class="literal">removeAtIndex</code>:<div class="informalexample"><pre class="programlisting">let number = numbers.remove(27)
let number = numbers.removeAtIndex(numbers.startIndex)</pre></div></li></ul></div><p class="calibre8">All of these operations take less than 6 microseconds, which is 0.000006 sec, even for a set with 50_000_000 elements.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre8">If you are going to do a heavy search for elements, use Set. You can have both an array to store data and a Set for search operations. This will use twice as much memory, but the search will be instant.</p></div><div class="book" title="Set operations"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch05lvl4sec10" class="calibre1"/>Set operations</h4></div></div></div><p class="calibre8">You can perform fundamental set operations<a id="id334" class="calibre1"/> on two different sets, such as combining, extracting, and getting common values.</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Set operations" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">These operations are also very fast, but <a id="id335" class="calibre1"/>they have O(n) or O(log n) complexity, and with increased size, the time required to process the data increases:</p><div class="informalexample"><pre class="programlisting">let set = makeRandomSet(size)
let otherSet = makeRandomSet(set.count)

set.union(otherSet)
set.subtract(otherSet)
set.intersect(otherSet)
set.exclusiveOr(otherSet)</pre></div><p class="calibre8">The performance of these operations is quite impressive, as you can see in the following table:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Set size</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Union</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Subtract</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Intersect</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">ExclusiveOr</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">100 x 100</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000015</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000012</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000013</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.00001</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">500_000 x 500_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.11</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.072</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.055</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.13</p>
</td></tr></tbody></table></div><p class="calibre8">If we take a look at the declarations of these methods, we see that they accept, not a Set, but <code class="literal">SequenceType</code>:</p><div class="informalexample"><pre class="programlisting">func union&lt;S : SequenceType where Element == Element&gt;(sequence: S) -&gt; Set&lt;Element&gt;</pre></div><p class="calibre8">We can use these set <a id="id336" class="calibre1"/>methods with any <code class="literal">SequenceType</code>. Let's try to use an array instead of a set and see whether there will be any difference:</p><div class="informalexample"><pre class="programlisting">let set = makeRandomSet(size)
let otherSequence = makeRandomArray(set.count)

set.union(otherSequence)
...</pre></div><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Set size x array size</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Union</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Subtract</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Intersect</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">ExclusiveOr</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">100 x 100</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000013</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.0000045</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000026</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.000032</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">500_000 x 500_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.10</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.058</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.13</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.18</p>
</td></tr></tbody></table></div><p class="calibre8">As you can see, <code class="literal">intersect</code> and <code class="literal">exclusiveOr</code> perform better with a set. Although the difference is so small that it wouldn't have big impact on the overall application performance, it is still an important observation that you should remember.</p><p class="calibre8">Let's take a look at one more method in set—<code class="literal">isSubsetOf</code>:</p><div class="informalexample"><pre class="programlisting">func isSubsetOf&lt;S : SequenceType where Element == Element&gt;(sequence: S) -&gt; Bool</pre></div><p class="calibre8">It also has the <code class="literal">SequenceType </code>parameter, so it's possible to use both sets and arrays:</p><div class="informalexample"><pre class="programlisting">let set = makeRandomSet()

var otherSequence = Array(set)
otherSequence.append(random())
set.isSubsetOf(otherSequence)

var otherSet = set
otherSet.insert(random())
set.isSubsetOf(otherSequence)</pre></div><p class="calibre8">The results are very interesting. With the set size equal to 5_000_000, <code class="literal">isSubsetOf</code> takes 4 minutes with an array argument, and less than 1 second with a set.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre8">For the <code class="literal">isSubsetOf</code> method, it is always preferable to use a set as an argument.</p></div><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Size</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">isSubsetOf (array)</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">isSubsetOf (set)</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">50_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.11 sec</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.0045 sec</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">5_000_000</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">237.2 sec</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.46 sec</p>
</td></tr></tbody></table></div></div></div></div></div>

<div class="book" title="Swift standard library collections">
<div class="book" title="Dictionaries"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec54" class="calibre1"/>Dictionaries</h2></div></div></div><p class="calibre8">A dictionary<a id="id337" class="calibre1"/> is an unordered collection that stores unique key-value pairs. Dictionaries are useful for quick object lookups by key</p><p class="calibre8">Dictionaries also use<a id="id338" class="calibre1"/> a hash table to store their keys and values. Because of this, a dictionary has similar performance characteristics as a set. Dictionaries are very useful when you need to connect two objects and perform instant searches and lookups for them.</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Dictionaries" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The dictionary collection is a very simple type. It doesn't have many methods of its own. The main functionality is to query a value for a key, update it, and delete it:</p><div class="informalexample"><pre class="programlisting">var capital = ["Germany" : "Berlin", "France"  : "Paris"]

capital["Norway"] = "Oslo"
capital.removeValueForKey("France")
capital["France"] = nil

if let index = capital.indexForKey("Spain") {
  print("found Spain at: \(index)")
}
capital.values</pre></div><p class="calibre8">Using a dictionary would result in a big performance win in a situation where you have two arrays and you want to find a connection between them.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Collection memory allocation" id="1HIT81-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec46" class="calibre1"/>Collection memory allocation</h1></div></div></div><p class="calibre8">Every collection has very similar<a id="id339" class="calibre1"/> performance optimization when you instance an instance of it. There are three different ways of creating an instance of a collection.</p></div>

<div class="book" title="Collection memory allocation" id="1HIT81-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Empty"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec55" class="calibre1"/>Empty</h2></div></div></div><p class="calibre8">You can create an empty<a id="id340" class="calibre1"/> collection. All arrays, sets, and dictionaries have an empty <code class="literal">init</code> method:</p><div class="informalexample"><pre class="programlisting">let array = [Int]()
let set = Set&lt;Int&gt;()
let dic = [String : Int]()</pre></div></div></div>

<div class="book" title="Collection memory allocation" id="1HIT81-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Reserve capacity"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec56" class="calibre1"/>Reserve capacity</h2></div></div></div><p class="calibre8">The other way is to instance<a id="id341" class="calibre1"/> an instance of a collection and reserve a required memory capacity. All collections have dynamic size, and they allocate more memory when needed. When you know how many elements you are going to store in the collection, it is useful to allocate exactly the required amount of memory upfront:</p><div class="informalexample"><pre class="programlisting">var array = [Int]()
array.reserveCapacity(500_000)

var set = Set&lt;Int&gt;(minimumCapacity: 500_000)
var dic = [String : Int](minimumCapacity: 500_000)</pre></div></div></div>

<div class="book" title="Collection memory allocation" id="1HIT81-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Default values"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec57" class="calibre1"/>Default values</h2></div></div></div><p class="calibre8">An array has one more way<a id="id342" class="calibre1"/> of instantiating. You can create an array with default values set for all the elements in that array:</p><div class="informalexample"><pre class="programlisting">var array = [Int](count: 500_000, repeatedValue: 0)
array[i] = 10</pre></div><p class="calibre8">Here are the results in seconds:</p><div class="informalexample"><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Size</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Method</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Array </p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Size set</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Dictionary</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">500</p>
</td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Empty</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">5.2e-06</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">2.4e-05</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">2.4e-05</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Capacity</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">8.8e-07</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">1.6e-06</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">4.7e-06</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Default values</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">4.8e-07</p>
</td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">50_000_000</p>
</td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Empty</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">1.29</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">11.7</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">12.9</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Capacity</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">1.13</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">9.4</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">10.9</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22">
<p class="calibre20">Default values</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">1.043</p>
</td><td valign="top" class="calibre22"> </td><td valign="top" class="calibre22"> </td></tr></tbody></table></div><p class="calibre8">As you can see from the results, it is always better to reserve some capacity for collections when you know the size, even for small sizes.</p><p class="calibre8">For arrays, using default values is the fastest way, but you have to remember that the array is filled in with default values and you have to either handle them or replace them with real values.</p><p class="calibre8">Also, you can see that <a id="id343" class="calibre1"/>creating an array is an incredibly fast operation, even with big sizes. That's one of the advantages of arrays over other collections.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The CollectionType protocol methods" id="1IHDQ1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec47" class="calibre1"/>The CollectionType protocol methods</h1></div></div></div><p class="calibre8">All the collections <a id="id344" class="calibre1"/>mentioned earlier—array, set and, dictionary—implement a <code class="literal">CollectionType</code> protocol.  Because of this, they are interchangeable. You can use any of them in places where a <code class="literal">CollectionType</code> method is required. An example is a function with a <code class="literal">CollectionType</code> parameter:</p><div class="informalexample"><pre class="programlisting">func useCollection&lt;T: CollectionType&gt;(x: T) {
  print("collection has \(x.count) elements")
}

let array = [1, 2, 3]
let set: Set = [2, 2, 3, 4, 5]
let dic = ["A" : 1, "B" : 2]

useCollection(array)
useCollection(set)
useCollection(dic)</pre></div></div>

<div class="book" title="The CollectionType protocol methods" id="1IHDQ1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Protocol extensions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec58" class="calibre1"/>Protocol extensions</h2></div></div></div><p class="calibre8">The other incredibly useful feature is <a id="id345" class="calibre1"/>protocol extensions. With protocol extensions, we can add implementations of methods and properties directly to the protocol. All types that conform to that protocol are able to use those methods for free. Let's add our own property to a <code class="literal">CollectionType</code> method:</p><div class="informalexample"><pre class="programlisting">extension CollectionType {
  var middle: Self.Index.Distance {
    return count / 2
  }
}

array.middle
set.middle
dic.middle</pre></div><p class="calibre8">The types that conform to that protocol can provide their own implementation for that method. In such a case, this implementation will be used for that type instead of the one defined in the protocol extension:</p><div class="informalexample"><pre class="programlisting">extension Dictionary {
  var middle: Dictionary.Index.Distance {
    print("Dictionary middle")
    return count / 2 + 100 // :( wrong middle index 
  }
}
dic.middle // 101 :)</pre></div><p class="calibre8">The <code class="literal">CollectionType</code> protocol uses this functionality very heavily, and there are many methods and properties that are available for a <code class="literal">CollectionType</code>, for example, <code class="literal">isEmpty</code>,<code class="literal"> first</code>,<code class="literal"> dropFirst(n: Int)</code>,<code class="literal"> map</code>, <code class="literal">indexOf</code>, and  many more. Let's take a look at <code class="literal">isEmpty</code> and <code class="literal">dropFirst(n: Int)</code>:</p><div class="informalexample"><pre class="programlisting">array.isEmpty
set.isEmpty
dic.isEmpty

array.dropFirst(1)
set.dropFirst(1)
dic.dropFirst(1)</pre></div><p class="calibre8">Let's inspect these methods. Hold<a id="id346" class="calibre1"/> down <span class="strong"><em class="calibre10">command</em></span> and click on the <code class="literal">isEmpty</code> property to jump to its declaration. An array uses a <code class="literal">CollectionType</code> version of<code class="literal"> isEmpty</code>, but set and dictionary provide their own implementations for the <code class="literal">isEmpty</code> property. Set and dictionary do this because the way in which they store their elements is different, and they can provide a better and more performance implementation of the <code class="literal">isEmpty</code> property. The types usually use their own implementation instead of using the protocol's default implementation if they can do it better.</p><p class="calibre8">You can read more about protocol extensions<a id="id347" class="calibre1"/> from the <span class="strong"><em class="calibre10">The Swift Programming Language</em></span> book at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html</a>, in the <span class="strong"><em class="calibre10">Protocols</em></span> section.</p></div></div>
<div class="book" title="Accelerate and Surge" id="1JFUC1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec48" class="calibre1"/>Accelerate and Surge</h1></div></div></div><p class="calibre8">Both iOS and OS X SDK have a very powerful framework that provides high-performance functions for working with matrices, vectors, signals, image processing, and math operations. It is called the Accelerate framework. The <a id="id348" class="calibre1"/>Accelerate framework is quite big, so we will take a look at only one part that is related to working with collections; it is the vDSP part. You can find out more about it at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html">https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/vDSPRef/index.html</a>.</p><p class="calibre8">First, let's implement the<a id="id349" class="calibre1"/> very basic mapping, calculating, and sum operations using the Swift standard library:</p><div class="informalexample"><pre class="programlisting">let array = [1.0, 2.0]
let result = array.map { $0 + 3.0 }
result // [4.0, 5.0]

let sum = array.reduce(0, combine: +)
sum // 3</pre></div><p class="calibre8">This code is very clear and readable and doesn't need any comments. Let's try to do the same using Accelerate:</p><div class="informalexample"><pre class="programlisting">let array = [1.0, 2.0]
var result = [Double](count: array.count, repeatedValue: 0.0)

var add = 3.0
vDSP_vsaddD(array, 1, &amp;add, &amp;result, 1, vDSP_Length(array.count))
result // [4.0, 5.0]

var sum = 0.0
vDSP_sveD(array, 1, &amp;sum, vDSP_Length(array.count))
sum // 3</pre></div><p class="calibre8">As you can see, the code gets more complex than in the previous version. The vDSP library works with vectors and matrices. For the <code class="literal">vDSP_vsaddD </code>function call, we pass an input array. The second parameter gives the distance between the elements in the array. Because the elements in the array are next to each other, we use <code class="literal">1</code>. The third is our second parameter, and the fourth and fifth are resulting arrays similar to the first and second parameters.</p><p class="calibre8">So, the Accelerate code is more complex, but it has better performance. Let's compare it:</p><div class="informalexample"><pre class="programlisting">let array = makeRandomDoubleArray(size)
var result = [Double]()

measure("map") {
  result = array.map { $0 + 3.0 }
}

// vDSP Version
let array = makeRandomDoubleArray(size)
var result = [Double](count : array.count, repeatedValue : 0.0)
var add = 3.0

measure("vDSP_vsaddD") {
  vDSP_vsaddD(array, 1, &amp;add, &amp;result, 1, vDSP_Length(array.count))
}</pre></div><p class="calibre8">The results are very interesting for big arrays with 500_000_000 elements. The <code class="literal">map</code> function takes <code class="literal">5.1</code> seconds and <code class="literal">vDSP_vsaddD</code> takes <code class="literal">0.6</code> seconds. It runs almost 10 times faster.</p><p class="calibre8">Yes! Accelerate has <a id="id350" class="calibre1"/>way better performance, but the source code gets very complicated. However, there is a solution to it. We could make a nice API wrapper to work with the Accelerate framework. Fortunately, this has already been done. There is a very nice open source Swift framework called <span class="strong"><strong class="calibre9">Surge</strong></span>
<a id="id351" class="calibre1"/>. You can download it from GitHub at <a class="calibre1" href="https://github.com/mattt/Surge">https://github.com/mattt/Surge</a>.</p><p class="calibre8">After you have downloaded it, add the Surge framework project to your project. Add it as a linked framework, and then you can use it. Now, by using Surge, the code looks very nice and has great performance. Here is an example of calculating the sum of all elements using Surge. It's even nicer than using a reduce method:</p><div class="informalexample"><pre class="programlisting">import Surge
let numbers = makeRandomDoubleArray(size)
let sum = Surge.sum(numbers)</pre></div></div>
<div class="book" title="Other collections" id="1KEEU1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec49" class="calibre1"/>Other collections</h1></div></div></div><p class="calibre8">We have covered<a id="id352" class="calibre1"/> three main Swift standard library collections. There are also other not-so-well-known and often-used helper collections, such as <code class="literal">ArraySlice</code>, <code class="literal">MapCollection</code>, <code class="literal">CollectionOfOne</code>, <code class="literal">ContiguousArray</code>, <code class="literal">EmptyCollection</code>, and <code class="literal">FilterCollection</code>. If you want to know more about them, just press <span class="strong"><em class="calibre10">command</em></span> and click on any type. You will see the content of the Swift standard library. Then, just explore it!</p><p class="calibre8">You can also implement your own collections, if needed. The Swift generic allows you to make very abstract collections that can be used with any type. For example, it could be the Stack, or a Linked List, a Binary Tree or any other collection that fits your needs.</p></div>
<div class="book" title="Summary" id="1LCVG1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec50" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered the importance of choosing the correct data type. We covered the Swift standard library collections with their features and limitations. You learned which collection fits better for which use case. Also, we showed the performance characteristics when working with those collections and performing different operations. Moreover, we gave a tip on how to improve performance and memory allocation for collections.</p><p class="calibre8">In the next chapter, we will see how to create an application architecture that contributes to achieving high performance.</p></div></body></html>