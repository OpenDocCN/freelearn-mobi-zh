- en: '*Chapter 11*: Easy Navigation with Coordinators'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用协调器轻松导航'
- en: An iOS app is usually a collection of single screens somehow connected to each
    other. Inexperienced developers often present a view controller from another view
    controller, because this is easy to implement and it is often shown that way in
    tutorials and demo code. But, for apps that need to be maintained over a long
    period of time, we need a pattern that is easier to understand and easier to change.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个iOS应用通常是一组以某种方式相互连接的单个屏幕。不经验丰富的开发者通常会从一个视图控制器中展示一个视图控制器，因为这很容易实现，并且在教程和演示代码中通常也是这样展示的。但是，对于需要长期维护的应用，我们需要一个更容易理解和更改的模式。
- en: The **coordinator pattern** is very easy to implement and still manages to decouple
    the navigation between views of the app from the presentation of the information.
    In the coordinator pattern, a structure called a coordinator is responsible for
    navigating between views. View controllers tell the coordinator that the user
    interacted with the app and the coordinator decides which view controller should
    become responsible for the screen next.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**协调器模式**非常容易实现，同时还能将应用视图之间的导航与信息展示解耦。在协调器模式中，一个称为协调器的结构负责在视图之间导航。视图控制器告诉协调器用户与应用进行了交互，协调器决定哪个视图控制器应该负责下一个屏幕。'
- en: As a bonus, the coordinator pattern makes testing navigation code simpler and
    more robust, and as a result, this pattern is a good fit for **test-driven development**
    (**TDD**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，协调器模式使测试导航代码更加简单和健壮，因此，这种模式非常适合**测试驱动开发**（**TDD**）。
- en: The app we are building in this book is a small app with only three screens.
    The navigation between those three screens can be bundled into one coordinator.
    In more complicated apps, you would usually use more than one coordinator. To
    learn more about the coordinator pattern, there are plenty of blog posts on the
    internet about that topic. You don't need to know anything about that pattern
    to follow the code in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中构建的应用是一个只有三个屏幕的小应用。这三个屏幕之间的导航可以捆绑到一个协调器中。在更复杂的应用中，你通常会使用多个协调器。要了解更多关于协调器模式的信息，互联网上有大量关于该主题的博客文章。你不需要了解任何关于该模式的知识，就可以跟随本章中的代码。
- en: In this chapter, you will learn how to test and implement the navigation between
    the different views of an app using the coordinator pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用协调器模式测试和实现应用不同视图之间的导航。
- en: 'The chapter is structured as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结构如下：
- en: Testing the app's setup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用的设置
- en: Navigating to the details
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到详细信息
- en: Navigating to a modal view
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到模态视图
- en: Adding missing parts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缺失的部分
- en: Let's start by refactoring the app's setup with the coordinator pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用协调器模式重构应用设置开始。
- en: Technical requirement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter can be found here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在以下位置找到：[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11)。
- en: Testing the app's setup
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用的设置
- en: 'When our app starts, a coordinator should be instantiated and started. This
    should result in the presentation of the initial view of our app. Follow these
    steps to refactor the setup from using a storyboard to using a coordinator:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用启动时，应该实例化并启动一个协调器。这应该导致我们应用初始视图的展示。按照以下步骤从使用故事板重构设置到使用协调器：
- en: Before we can refactor the setup of the app, we need a test that tells us when
    we break something. Select the `AppSetupTests`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以重构应用设置之前，我们需要一个测试来告诉我们何时破坏了某些东西。选择`AppSetupTests`。
- en: 'Replace the content of the new class with the following:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类的内容替换为以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this test, we get the `rootViewController` property of the first window of
    our app and we check whether it is of the `ToDoItemsListViewController` type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们获取我们应用第一个窗口的`rootViewController`属性，并检查它是否为`ToDoItemsListViewController`类型。
- en: Run the tests to confirm that all tests pass right now. This test passes because
    the storyboard is set up in a way that the app starts with an instance of the
    `ToDoItemsListViewController` class.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在都通过。这个测试通过是因为故事板被设置为应用以`ToDoItemsListViewController`类的实例启动。
- en: Go to `Main.storyboard` and uncheck the checkbox for `ToDoItemsListViewController`
    scene in the attribute inspector.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Main.storyboard`，并在属性检查器中取消勾选`ToDoItemsListViewController`场景的复选框。
- en: '![Figure 11.1 – Removing the initial view controller setting from the storyboard'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 从故事板中移除初始视图控制器设置](img/Figure_11.01_B18127.jpg)'
- en: '](img/Figure_11.01_B18127.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – Removing the initial view controller setting from the storyboard](img/Figure_11.01_B18127.jpg)'
- en: Figure 11.1 – Removing the initial view controller setting from the storyboard
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 从故事板中移除初始视图控制器设置
- en: Switch to the `ToDoItemsListViewController`. With this change, we can instantiate
    this view controller in the code using this ID.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`ToDoItemsListViewController`。通过这个更改，我们可以在代码中使用此ID实例化这个视图控制器。
- en: 'Run the tests to confirm that now the last test we added fails. Oh, there is
    another test that fails. In `ToDoItemsListViewControllerTests`, all tests fail,
    because the setup in `setUpWithError` throws an error. Let''s fix this error before
    we move on with the setup of our app. `ToDoItemsListViewController` isn''t the
    initial view controller of the storyboard anymore. This means we need to load
    it using its ID. Replace `setUpWithError()` with the following implementation:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确认现在我们添加的最后一个测试失败了。哦，还有一个测试也失败了。在`ToDoItemsListViewControllerTests`中，所有测试都失败了，因为在`setUpWithError`中的设置抛出了一个错误。在我们继续设置应用之前，让我们先修复这个错误。`ToDoItemsListViewController`不再是故事板中的初始视图控制器。这意味着我们需要使用其ID来加载它。将`setUpWithError()`替换为以下实现：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run all tests again. Now, only our app setup test fails. Good. Let's move on
    to the implementation.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行所有测试。现在，只有我们的应用设置测试失败了。很好。让我们继续到实现部分。
- en: 'Select the `AppCoordinator.swift`. Replace the content of the new file with
    the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`AppCoordinator.swift`。用以下代码替换新文件的内容：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code defines the `Coordinator` protocol. This is how I implement the coordinator
    pattern. In blogs and books of other developers, you might find other implementations.
    Don't worry, they only differ in their details. When you have worked a bit with
    the coordinator pattern, you might develop your own implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了`Coordinator`协议。这就是我实现协调器模式的方式。在其他开发者的博客和书籍中，你可能会找到其他实现。不用担心，它们只是在细节上有所不同。当你对协调器模式有了一些了解后，你可能会开发出自己的实现。
- en: This implementation of the protocol tells us that a coordinator has a `start`
    method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议的实现告诉我们，协调器有一个`start`方法。
- en: 'Add the following implementation of our `AppCoordinator` in the same file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中添加我们`AppCoordinator`的以下实现：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the initializer of `AppCoordinator`, we store the window that was passed
    in as a parameter, and we set up the view of the initial view controller. In the
    `start` method, we set the `rootViewController` property of the window.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppCoordinator`的初始化器中，我们存储了作为参数传递的窗口，并设置了初始视图控制器的视图。在`start`方法中，我们设置了窗口的`rootViewController`属性。
- en: 'Go to `SceneDelegate` and add the following property:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`SceneDelegate`并添加以下属性：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, replace the `scene(_:willConnectTo:options:)` method with this code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`scene(_:willConnectTo:options:)`方法替换为以下代码：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, we first set up an instance of the `UIWindow` class. Next, we
    instantiate the `AppCoordinator` instance and call its `start` method. Finally,
    we call `makeKeyAndVisible` on the window to tell `UIKit` that this window should
    be presented on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先设置了一个`UIWindow`类的实例。接下来，我们实例化了`AppCoordinator`实例并调用了它的`start`方法。最后，我们在窗口上调用`makeKeyAndVisible`来告诉`UIKit`这个窗口应该显示在屏幕上。
- en: Run all tests to confirm that our refactoring was successful.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试以确认我们的重构是成功的。
- en: Now, the app works as it did before. When the app starts, an instance of `ToDoItemsListViewController`
    is created and shown. But, this is not as it should work in the final app. The
    list of to-do items needs to be presented on a `UINavigationController` instance
    to be able to navigate to the details of a to-do item later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用的工作方式与之前相同。当应用启动时，会创建并显示一个`ToDoItemsListViewController`实例。但是，这并不是最终应用应该工作的方式。待办事项列表需要在`UINavigationController`实例上显示，以便以后能够导航到待办事项的详细信息。
- en: 'Follow these steps to make this change:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行此更改：
- en: 'Replace the `test_application_shouldSetupRoot()` test method with the following
    implementation:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`test_application_shouldSetupRoot()`测试方法替换为以下实现：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the tests to see this test now failing in the line before the `XCTAssert`
    call.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以查看现在在`XCTAssert`调用之前的行中这个测试失败了。
- en: 'To make this test pass again, we first need a property for the navigation controller
    in the `AppCoordinator` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让这个测试再次通过，我们首先需要在`AppCoordinator`类中为导航控制器添加一个属性：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we set up the navigation controller in the `init` method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`init`方法中设置导航控制器：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added the navigation controller as a parameter with a default value
    to the `init` call. This will come in handy later when we add tests for the navigation
    to the details of a to-do item.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将导航控制器作为具有默认值的参数添加到`init`调用中。这将在我们添加导航到待办事项详细信息的测试时派上用场。
- en: 'Now, we can change the `start` method to add the instance of `ToDoItemsListViewController`
    to the navigation stack of the navigation controller:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将`ToDoItemsListViewController`的实例添加到导航控制器的导航堆栈中，以更改`start`方法：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the tests to confirm that all tests are now passing again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在都再次通过。
- en: 'We are not done yet with setting up the list view controller. Remember, the
    list view controller communicates interactions by the user to a delegate object
    conforming to the `ToDoItemsListViewControllerProtocol` protocol we defined in
    [*Chapter 7*](B18127_07_ePub.xhtml#_idTextAnchor177), *Building a Table View Controller
    for the To-Do Items*. Follow these steps to implement this part of the setup:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成设置列表视图控制器。记住，列表视图控制器通过用户与遵循我们在[*第7章*](B18127_07_ePub.xhtml#_idTextAnchor177)中定义的`ToDoItemsListViewControllerProtocol`协议的代理对象进行交互，*构建待办事项的表视图控制器*。按照以下步骤实现这一部分的设置：
- en: Select the `AppCoordinatorTests`. Remove the two template test methods and add
    the `@testable import ToDo` import statement.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`AppCoordinatorTests`。删除两个模板测试方法，并添加`@testable import ToDo`导入语句。
- en: 'Now, we will make the `AppCoordinator` class conform to the `ToDoItemsListViewControllerProtocol`
    protocol. Add the following code to `AppCoordinator.swift`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使`AppCoordinator`类遵循`ToDoItemsListViewControllerProtocol`协议。将以下代码添加到`AppCoordinator.swift`中：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This implementation does nothing yet. We will implement this method in the next
    section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现目前什么也不做。我们将在下一节中实现此方法。
- en: To write a test for assigning the delegate property of the list view controller,
    we need to access the list view controller in the `test` method. The view controller
    property of the `AppCoordinator` class is private. This means we cannot access
    it in the test. We could change the access level of the view controller property.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为分配列表视图控制器代理属性编写测试，我们需要在`test`方法中访问列表视图控制器。`AppCoordinator`类的视图控制器属性是私有的。这意味着我们无法在测试中访问它。我们可以更改视图控制器属性的访问级别。
- en: But for educational reasons, we will do something else. We will pass a navigation
    controller mock into the `init` method of the `AppCoordinator` class and get the
    initial view controller from that.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但出于教育目的，我们将做些其他事情。我们将一个导航控制器模拟传递给`AppCoordinator`类的`init`方法，并从该模拟中获取初始视图控制器。
- en: 'Add a new Swift class to the `NavigationControllerMock`. Replace the contents
    of that new file with the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`NavigationControllerMock`添加一个新的Swift类。用以下代码替换新文件的内容：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This subclass of the `UINavigationController` class stores the last pushed view
    controller for later inspection, and then calls the implementation of the `super`
    class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`UINavigationController`类的子类存储了最后推入的视图控制器以供后续检查，然后调用`super`类的实现。
- en: 'Now, we can use this class in the `AppCoordinator` tests. Add the following
    properties to `AppCoordinatorTests`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`AppCoordinator`测试中使用这个类。将以下属性添加到`AppCoordinatorTests`中：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Replace the `setUpWithError` method with the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`setUpWithError`方法替换为以下代码：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, we create a dummy window and an instance of `NavigationControllerMock`,
    and use both to initialize an instance of `AppCoordinator`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个模拟窗口和一个`NavigationControllerMock`实例，并使用这两个实例初始化一个`AppCoordinator`实例。
- en: 'What we set up for the tests, we have to clean up when the tests are finished.
    Replace the `tearDownWithError` method with the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于测试所设置的内容，测试完成后必须清理。将`tearDownWithError`方法替换为以下代码：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this preparation, we can add a test to confirm that the `start` method
    assigns the instance of `AppCoordinator` to the delegate of the list view controller:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备就绪后，我们可以添加一个测试来确认`start`方法将`AppCoordinator`的实例分配给列表视图控制器的代理：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this test, we call the `start` method of the `AppCoordinator` instance and
    then assert that `sut` is assigned to the delegate property of the list view controller.
    We use here the `XCTAssertIdentical(_:_:)` assert function. As `AppCoordinator`
    is a class, we can check in the test whether the delegate is identical to `sut`.
    This assert function compares the pointer address of the two items, and the test
    passes when both references are the same. This does not work with value types
    because they are copied when assigned (or rather when changed).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们调用`AppCoordinator`实例的`start`方法，然后断言`sut`被分配到列表视图控制器的代理属性。我们在这里使用`XCTAssertIdentical(_:_:)`断言函数。由于`AppCoordinator`是一个类，我们可以在测试中检查代理是否与`sut`相同。这个断言函数比较两个项目的指针地址，当两个引用相同时测试通过。这不适用于值类型，因为它们在分配（或更确切地说，在更改时）时被复制。
- en: Run the tests to confirm that this new test fails.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'To make this test pass, add the following code to the end of the `start` method
    in `AppCoordinator`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，请将以下代码添加到`AppCoordinator`中的`start`方法末尾：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the tests to confirm that this addition makes the test pass.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个添加使测试通过。
- en: '`ToDoItemsListViewController` shows the to-do items it gets from an instance
    of `ToDoItemStore`. We need to provide the list view controller with an item store
    when it is set up. Follow these steps to add the item store to the list view controller:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDoItemsListViewController`显示从`ToDoItemStore`实例获取的待办事项。我们需要在设置时向列表视图控制器提供一个项目存储。按照以下步骤将项目存储添加到列表视图控制器：'
- en: 'Add the following test to `AppCoordinatorTests`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`AppCoordinatorTests`：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this test, we assert that the `toDoItemStore` property of the list view controller
    is not nil. Run the tests to confirm that this test fails.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们断言列表视图控制器的`toDoItemStore`属性不为空。运行测试以确认这个测试失败。
- en: 'Let''s make this test pass. Add the following property to `AppCoordinator`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个测试通过。将以下属性添加到`AppCoordinator`：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Assign this property in the `init` method with a new instance:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中分配这个属性一个新的实例：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, assign this property to the property of the list view controller within
    the `if let` statement of the `start` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`start`方法的`if let`语句中将这个属性分配给列表视图控制器的属性：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the tests to confirm that all tests now pass.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在通过。
- en: The setup of the coordinator and the initial view controller is now complete.
    We can move on to implementing the interaction of the list view controller with
    the app coordinator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 协调器和初始视图控制器的设置现在已完成。我们可以继续实现列表视图控制器与应用程序协调器的交互。
- en: When the user taps a table view cell with a to-do item, the app should navigate
    to the details of that item. In the following section, we will implement this
    feature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击带有待办事项的表格视图单元格时，应用应该导航到该事项的详细信息。在以下部分，我们将实现这个功能。
- en: Navigating to the details
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到详细信息
- en: 'We will implement the navigation within the app using the `AppCoordinator`
    class. Follow these steps to implement navigation to the details of to-do items:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用中使用`AppCoordinator`类实现导航。按照以下步骤实现导航到待办事项的详细信息：
- en: 'Add the following test method to `AppCoordinatorTests`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`AppCoordinatorTests`：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this test, we execute the `delegate` method and assert that an instance of
    `ToDoItemDetailsViewController` is pushed to the navigation stack, and that its
    `toDoItem` is the item we used in the `delegate` method call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们执行`delegate`方法并断言`ToDoItemDetailsViewController`的实例被推送到导航堆栈中，并且它的`toDoItem`是我们用于`delegate`方法调用中的项目。
- en: Run the tests to confirm that this new test fails.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'Replace the implementation of `selectToDoItem(_:item:)` with this implementation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下实现替换`selectToDoItem(_:item:)`的实现：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we instantiate an instance of `ToDoItemDetailsViewController`
    from the storyboard and set it up with the to-do item passed into the method.
    Then we push the new view controller onto the navigation stack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从Storyboard中实例化一个`ToDoItemDetailsViewController`实例，并使用传递给方法的项目进行设置。然后我们将新的视图控制器推送到导航堆栈。
- en: Run the tests to confirm that all tests now pass again.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在再次通过。
- en: 'The details view controller needs a reference to `toDoItemStore` because the
    user can change the status of the item to `done` in the details view. Add the
    following test to `AppCoordinatorTests`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详细视图控制器需要一个对`toDoItemStore`的引用，因为用户可以在详细视图中更改事项的状态为`完成`。将以下测试添加到`AppCoordinatorTests`：
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This test looks like the previous one. We only changed the assert function call
    to check whether the `toDoItemStore` property is identical to the `sut` property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试看起来和上一个一样。我们只是将断言函数调用更改为检查 `toDoItemStore` 属性是否与 `sut` 属性相同。
- en: Run the tests to see this test failing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看这个测试失败。
- en: 'To make this test pass, assign the `toDoItemStore` property below the line
    we assigned the `toDoItem` property:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，在分配 `toDoItem` 属性的下一行分配 `toDoItemStore` 属性：
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the tests to confirm that all tests pass.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试通过。
- en: When the user selects a cell with a to-do item, our app now shows the details
    of that item on the screen. There is one feature missing. The app needs to allow
    the input of new to-do items. We will implement the presentation of the input
    view from the list view in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个带有待办事项的单元格时，我们的应用现在会在屏幕上显示该事项的详细信息。还有一个功能缺失。应用需要允许输入新的待办事项。我们将在下一节中实现从列表视图到输入视图的展示。
- en: Navigating to a modal view
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到模态视图
- en: Normally, testing the presentation of a modal view controller is quite complicated.
    If you search how to do that on the internet, you will find that the common solutions
    work by swizzling the `present(_:animated:completion:)` method defined in the
    `UIViewController` class. Swizzling is quite complicated, and I will not show
    in this book how this is done.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试模态视图控制器的展示相当复杂。如果你在网上搜索如何做，你会找到常见的解决方案是通过重写 `UIViewController` 类中定义的 `present(_:animated:completion:)`
    方法。重写相当复杂，我不会在这本书中展示如何进行。
- en: But, because we are using the coordinator pattern for the navigation in our
    app, we can test the presentation without the need to swizzle any method. Still,
    you should look up how to swizzle methods because sometimes you don't have the
    option to use the coordinator pattern; for example, when there is already all
    the navigation code implemented and you are not allowed to change it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，因为我们正在使用协调器模式进行我们的应用导航，所以我们可以测试展示，而无需对任何方法进行重写。尽管如此，你应该查找如何重写方法，因为有时你无法使用协调器模式；例如，当已经实现了所有导航代码，并且不允许你更改它时。
- en: 'Follow these steps to implement the presentation of the input view when the
    user chooses to add a new to-do item:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现当用户选择添加新待办事项时输入视图的展示：
- en: 'The app needs a button in the user interface that the user can tap to add a
    to-do item. When the user taps that button, the list view controller should tell
    its delegate about it. Add the following method definition to `ToDoItemsListViewControllerProtocol`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用需要在用户界面中添加一个按钮，用户可以点击以添加待办事项。当用户点击该按钮时，列表视图控制器应该通知其代理。向 `ToDoItemsListViewControllerProtocol`
    添加以下方法定义：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make the compiler happy, add the following empty method implementation to
    `AppCoordinator`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让编译器满意，向 `AppCoordinator` 添加以下空方法实现：
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have another class that conforms to the `ToDoItemsListViewControllerProtocol`
    protocol. Add the following code to the end of the `ToDoItemsListViewControllerProtocolMock`
    class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个符合 `ToDoItemsListViewControllerProtocol` 协议的类。将以下代码添加到 `ToDoItemsListViewControllerProtocolMock`
    类的末尾：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The mock object counts the number of calls of the `addToDoItem(_:)` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象计算 `addToDoItem(_:)` 方法的调用次数。
- en: 'Next, we need a view controller mock that catches the last presented view controller.
    Select the `ViewControllerMock.swift`. Replace its content with the following
    code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个视图控制器模拟，它可以捕获最后展示的视图控制器。选择 `ViewControllerMock.swift` 文件。用以下代码替换其内容：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This mock stores the presented view controller in a property for later inspection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟将展示的视图控制器存储在一个属性中，以便稍后检查。
- en: 'Now, we can write the test. Import `SwiftUI` to `AppCoordinatorTests.swift`
    and add the following test method to `AppCoordinatorTests`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编写测试了。将 `SwiftUI` 导入到 `AppCoordinatorTests.swift` 文件中，并在 `AppCoordinatorTests`
    中添加以下测试方法：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This test calls `addToDoItem(_:)` and asserts that the `sut` variable is assigned
    as the delegate of the presented instance of `ToDoItemInputView`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试调用 `addToDoItem(_:)` 并断言 `sut` 变量被分配为展示的 `ToDoItemInputView` 实例的代理。
- en: Run the tests to confirm that this new test fails.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'To make this test pass, import `SwiftUI` into `AppCoordinator.swift` and replace
    the implementation of `addToDoItem(_:)` with the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，将 `SwiftUI` 导入到 `AppCoordinator.swift` 文件中，并用以下代码替换 `addToDoItem(_:)`
    的实现：
- en: '[PRE30]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Xcode shows an error; we will fix this error in the next step. This code instantiates
    an instance of `UIHostingController` with a root view of `ToDoItemInputView`.
    This is how we can present a `SwiftUI` view from a `UIKit` environment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode显示了一个错误；我们将在下一步修复此错误。此代码使用`ToDoItemInputView`作为根视图实例化一个`UIHostingController`。这就是我们从`UIKit`环境呈现`SwiftUI`视图的方法。
- en: 'To make this code compile, add the following extension to `AppCoordinator.swift`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此代码编译，请将以下扩展添加到`AppCoordinator.swift`：
- en: '[PRE31]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the tests to confirm that all tests now pass.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在都通过。
- en: One part of this feature is finished. Next, we need to implement the other part
    in the `ToDoItemsListViewController` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的其中一部分已完成。接下来，我们需要在`ToDoItemsListViewController`类中实现其他部分。
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`ToDoItemsListViewControllerTests`：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this test, we get the right bar button item of the `sut` variable and call
    its action on its target. This should result in a call to the `addToDoItem(_:)`
    method of the delegate.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，我们获取`sut`变量的正确工具栏按钮项并调用其目标上的操作。这应该导致调用代理的`addToDoItem(_:)`方法。
- en: Run the tests and confirm that this new test fails.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并确认此新测试失败。
- en: 'Add the following code to the end of `viewDidLoad()` of `ToDoItemsListViewController`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ToDoItemsListViewController`的`viewDidLoad()`末尾：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this code, we add a bar button to the navigation item of the `ToDoItemsListViewController`
    instance. This results in a bar button that is added to the navigation bar of
    the navigation controller that hosts `ToDoItemsListViewController`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们在`ToDoItemsListViewController`实例的导航项中添加了一个工具栏按钮。这导致添加到托管`ToDoItemsListViewController`的导航控制器导航栏中的工具栏按钮。
- en: 'Now, add the following method to `ToDoItemsListViewController`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下方法添加到`ToDoItemsListViewController`：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For now, we let the implementation of this method empty because we want to see
    the test fail in the assert function call. Run the tests and confirm that the
    test we added last now fails in the assert call.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们让此方法的实现为空，因为我们想看到在断言函数调用中测试失败。运行测试并确认我们最后添加的测试在断言调用中失败。
- en: 'To make the test pass, add the missing code in `add(_:)`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，请在`add(_:)`中添加缺失的代码：
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the tests to confirm that all tests now pass.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在都通过。
- en: We already know that `ToDoItemInputView` calls its delegate when the user selects
    the `add(_:)` method of `ToDoItemStore`. Take the following steps to implement
    this feature.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道`ToDoItemInputView`在用户选择`ToDoItemStore`的`add(_:)`方法时会调用其代理。采取以下步骤来实现此功能。
- en: 'Add the following test to `AppCoordinatorTests`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`AppCoordinatorTests`：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This test asserts that, after calling `addToDoItem(with:coordinate:)`, now `itemPublisher`
    of the `toDoItemStore` property publishes the change to the stored items.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试断言，在调用`addToDoItem(with:coordinate:)`之后，现在`toDoItemStore`属性的`itemPublisher`发布了存储项的变化。
- en: As we are adding a to-do item to the item store, we need to replace `doToItemStore`
    in `AppCoordinator` with a test store. Otherwise, the test could fail because
    of items added to the store in other tests or while we test the app on the simulator.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在向项目存储添加待办事项，我们需要将`AppCoordinator`中的`doToItemStore`替换为测试存储。否则，由于其他测试或我们在模拟器上测试应用程序时添加到存储中的项，测试可能会失败。
- en: 'Replace the `init` method of the `AppCoordinator` class with the following
    implementation:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AppCoordinator`类的`init`方法替换为以下实现：
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we have added the `toDoItemStore` parameter to the method and we use that
    parameter to set the `toDoItemStore` property used in the `AppCoordinator` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将`toDoItemStore`参数添加到方法中，并使用该参数设置`AppCoordinator`类中使用的`toDoItemStore`属性。
- en: 'So, we can use a test store when setting up `sut` in `setUpWithError`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们可以在`setUpWithError`中设置`sut`时使用测试存储。
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To delete the item store when the test is finished, add the following code
    to the end of `tearDownWithError` of `AppCoordinatorTests`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在测试完成后删除项目存储，请将以下代码添加到`AppCoordinatorTests`的`tearDownWithError`末尾：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code should look familiar, as we already used it in `ToDoItemStoreTests`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码看起来很熟悉，因为我们已经在`ToDoItemStoreTests`中使用过它。
- en: Run the tests to confirm that the new test fails.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认新的测试失败。
- en: 'Make the test pass with the following implementation of `addToDoItem(with:coordinate:)`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`addToDoItem(with:coordinate:)`的实现使测试通过：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we added an internal parameter name of `item` for the first parameter
    of that method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为该方法的第一个参数添加了一个内部参数名`item`。
- en: In this code, we create an instance of `ToDoItem` from the `ToDoItemData` structure.
    Then, we call the `add(_:)` method of `toDoItemStore`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从`ToDoItemData`结构创建了一个`ToDoItem`实例。然后，我们调用`toDoItemStore`的`add(_:)`方法。
- en: Run the tests to confirm that this change makes all tests pass again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个更改使所有测试再次通过。
- en: For now, we are done with the implementation. Let's make the app work in the
    simulator and see whether we missed something.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了实现。让我们在模拟器中运行应用，看看我们是否遗漏了什么。
- en: Adding missing parts
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缺失的部分
- en: First, let's run the app for the first time to see where we are.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们运行这个应用第一次，看看我们现在在哪里。
- en: The app starts with a blank screen with just one plus (**+**) button in the
    upper-right corner.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用从只有一个加号（**+**）按钮的空白屏幕开始，位于右上角。
- en: '![Figure 11.2 – The initial view of our app'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.2 – 我们应用的初始视图](img/Figure_11.02_B18127.jpg)'
- en: '](img/Figure_11.02_B18127.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.02 – 表格视图的约束](img/Figure_11.02_B18127.jpg)'
- en: Figure 11.2 – The initial view of our app
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 我们应用的初始视图
- en: So, there is work to do here. But, let's move on and tap the plus (**+**) button.
    We are presented with the input view. We can add data for the item and tap the
    **Save** button.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一些工作要做。但是，让我们继续并点击加号（**+**）按钮。我们看到了输入视图。我们可以为项目添加数据并点击**保存**按钮。
- en: '![Figure 11.3 – The input view of our app'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.3 – 我们应用的输入视图](img/Figure_11.03_B18127.jpg)'
- en: '](img/Figure_11.03_B18127.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.03 – 表格视图的约束](img/Figure_11.03_B18127.jpg)'
- en: Figure 11.3 – The input view of our app
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 我们应用的输入视图
- en: But, when we tap the **Save** button, nothing happens. Dismiss the view by swiping
    down, and see whether the item was added. Something changed. There is a blank
    table view cell visible in the middle of the screen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们点击**保存**按钮时，没有任何反应。通过向下滑动来关闭视图，看看项目是否已添加。有些东西改变了。屏幕中间出现了一个空白表格视图单元格。
- en: '![Figure 11.4 – A blank table view cell. Where is the to-do item?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.4 – 一个空白表格视图单元格。待办事项在哪里？](img/Figure_11.04_B18127.jpg)'
- en: '](img/Figure_11.04_B18127.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.04 – 表格视图的约束](img/Figure_11.04_B18127.jpg)'
- en: Figure 11.4 – A blank table view cell. Where is the to-do item?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 一个空白表格视图单元格。待办事项在哪里？
- en: When you tap the blank table view cell, the detail view is pushed onto the screen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击空白表格视图单元格时，详细视图会被推送到屏幕上。
- en: '![Figure 11.5 – The details of the to-do item. But, where is the due date?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.5 – 待办事项项的详细信息。但是，截止日期在哪里？](img/Figure_11.05_B18127.jpg)'
- en: '](img/Figure_11.05_B18127.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.05 – 表格视图的约束](img/Figure_11.05_B18127.jpg)'
- en: Figure 11.5 – The details of the to-do item. But, where is the due date?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 待办事项项的详细信息。但是，截止日期在哪里？
- en: Okay, we have some work to do. Let's go back to Xcode and fix some problems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有一些工作要做。让我们回到Xcode并修复一些问题。
- en: Making the cells visible
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使单元格可见
- en: The table view doesn't show the information of the to-do items. The reason is,
    we didn't add constraints to the views when we added the labels. This was on purpose
    because I believe you should not write unit tests to test the position and size
    of interface elements. UI tests of snapshot tests are a better tool for these
    kinds of tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图没有显示待办事项的信息。原因是，我们在添加标签时没有为视图添加约束。这是故意的，因为我相信你不应该编写单元测试来测试界面元素的定位和大小。UI快照测试是这些类型测试的更好工具。
- en: 'Follow these steps to fix the layout of the cells and the table view:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤修复单元格和表格视图的布局：
- en: Open `Main.storyboard` in `0` and click **Add 4 Constraints**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0`中打开`Main.storyboard`并点击**添加4个约束**。
- en: '![Figure 11.6 – The constraints for the table view'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.6 – 表格视图的约束](img/Figure_11.06_B18127.jpg)'
- en: '](img/Figure_11.06_B18127.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.06 – 表格视图的约束](img/Figure_11.06_B18127.jpg)'
- en: Figure 11.6 – The constraints for the table view
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 表格视图的约束
- en: 'Next, go to `ToDoItemCell`, and replace the `init` method with the following
    implementation:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到`ToDoItemCell`，并用以下实现替换`init`方法：
- en: '[PRE41]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use `UIStackView` instances to lay out the elements. Run the tests to confirm
    that we didn't break anything. Then, run the app again on the simulator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`UIStackView`实例来布局元素。运行测试以确认我们没有破坏任何东西。然后，在模拟器上再次运行应用。
- en: It looks better, but the due date is still missing in the table view cell. The
    reason is that we didn't set up the `dateFormatter` instance currently. We found
    a bug. Whenever we find a bug, we should try to write a test that fails because
    of that bug. Then, we should make the test pass by fixing the bug.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来更好，但表格视图单元格中仍然缺少截止日期。原因是我们没有设置当前的`dateFormatter`实例。我们找到了一个错误。每次我们找到错误时，我们都应该尝试编写一个因为该错误而失败的测试。然后，我们应该通过修复错误来使测试通过。
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`ToDoItemsListViewControllerTests`：
- en: '[PRE42]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the `XCTAssertNotEqual` assert function does the opposite of the `XCTAssertEqual`
    function. It passes when the two values are not equal.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to see this test failing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass and the bug disappear, add these lines to `viewDidLoad`
    below the `super.viewDidLoad()` line:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run the tests to confirm that this makes the test green. Then, run the app on
    the simulator. Woohoo! We fixed our first bug with the help of TDD. This is a
    milestone. We are now sure that this bug won't come back as long as this test
    is run regularly.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to fix the bug that the input view is not dismissed when the user
    taps the **Save** button.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Dismissing the input view
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, we have a bug. Let''s see whether we can write a test for that bug.
    Follow these steps to fix the bug:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation controller mock should register if `dismiss(animated:completion:)`
    got called. This way, we can make sure that it is called when a new item is added.
    Add the following code to `NavigationControllerMock`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code counts the times `dismiss(animated:completion:)` got called.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `AppCoordinatorTests`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the tests to see this test failing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of `addToDoItem(with:coordinate:)`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the tests to confirm that this code makes all tests pass again. Then, run
    the app and add a new to-do item.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We fixed another bug using TDD.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's fix the bug in the details that the due date isn't shown.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Making the due date visible in the details
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason that the date is not shown in the details is the same as for the
    table view cell. The date formatter isn't set up correctly. You already know how
    to write a test for this. Write the test and make sure that the test fails.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass and, therefore, fix the bug, you can use this definition
    of the `dateFormatter` property:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This should make your test pass.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app again, and play around with it. You might realize some more bugs.
    Here is what I found:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps the **Done** button in the details, the app should pop back
    to the list of to-do items.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The section headers are missing in the table view. The done items are correctly
    moved to the second section, but it's not visible in the user interface that there
    are several sections.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user marks the first item done, the order in the table view changes.
    If the user then selects the first item in the table view, the details for the
    other item are shown.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cell stays selected even after the user came back from the details.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debug console shows a warning that the table view was told to lay out the
    cells when it is not visible.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We sure found some more bugs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will fix only the third and the fifth bug in this
    list. The other bugs are left as an exercise for you. If you get stuck, have a
    look at the code for this chapter on GitHub.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the wrong item being selected
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, let''s try to write a test for this bug before we try to fix it. Follow
    these steps to fix that bug:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在我们尝试修复这个错误之前，让我们尝试编写一个测试。按照以下步骤修复这个错误：
- en: 'The problem is that we set up the sections when we create the snapshot for
    the diffable data source, but we ignore the section when the user selects a table
    view row. We can change the `test_didSelectCellAt_shouldCallDelegate` method to
    check for this error. Replace the implementation of that test method with the
    following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于我们在为可差分数据源创建快照时设置了部分，但在用户选择表格视图行时忽略了部分。我们可以将`test_didSelectCellAt_shouldCallDelegate`方法更改为检查这个错误。将那个测试方法的实现替换为以下代码：
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We change the test to use two items, one done item and one item that is not
    done yet.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试更改为使用两个项目，一个是已完成的项目，另一个是尚未完成的项目。
- en: Run the tests to see this test failing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看这个测试失败。
- en: 'To make the test pass and thus fix the bug, replace the implementation of `tableView(_:didSelectRowAt:)`
    with the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过并修复错误，将`tableView(_:didSelectRowAt:)`的实现替换为以下代码：
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this implementation, we respect the two sections and choose the item to be
    shown accordingly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们尊重两个部分，并相应地选择要显示的项目。
- en: Run all tests to confirm that all tests now pass.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认现在所有测试都通过。
- en: And, with this last bug fixed, we are done with the first simple version of
    our little app that we created using TDD.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，随着最后一个错误的修复，我们完成了使用TDD创建的我们的小应用的第一简单版本。
- en: Fixing the layout of the table view
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复表格视图的布局
- en: 'The problem here is that we use the `Combine` framework to update the table
    view. When the user taps the `doToItemStore` updates its items and tells the table
    view about it. This results in an update of the table view when it is not visible
    on the screen. This is easy to fix and we don''t even need a test for this. Add
    the following code to `ToDoItemsListViewController`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们使用`Combine`框架来更新表格视图。当用户点击`doToItemStore`时，它会更新项目并通知表格视图。这导致表格视图在屏幕不可见时更新。这很容易修复，我们甚至不需要为这个错误编写测试。将以下代码添加到`ToDoItemsListViewController`中：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When the view with the table view disappears, we unsubscribe from `itemsPublisher`.
    When the view appears on the screen, we subscribe again. Run the app again in
    the simulator and have a look at the console to see whether the message is gone.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当带有表格视图的视图消失时，我们取消订阅`itemsPublisher`。当视图出现在屏幕上时，我们再次订阅。在模拟器中再次运行应用，查看控制台以查看消息是否已消失。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we have implemented the navigation between the different
    views of our app. We have learned how to test pushing view controllers onto a
    navigation stack and how we can test whether a view got presented modally.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一章中，我们实现了应用中不同视图之间的导航。我们学习了如何测试将视图控制器推入导航堆栈，以及如何测试一个视图是否以模态方式呈现。
- en: With navigation implemented, we started the app on the simulator and found and
    fixed bugs. We figured out that TDD even helps when fixing bugs. By writing first
    a failing test for that bug and then making the test pass, we ensured that this
    bug won't hurt us in the future of our app.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现导航后，我们在模拟器上启动了应用，找到了并修复了错误。我们发现TDD甚至有助于修复错误。通过首先编写一个针对该错误的失败测试，然后使测试通过，我们确保这个错误不会在未来影响我们的应用。
- en: With the skills you gained in this chapter, you will be able to implement and
    test the navigation of an app using the coordinator pattern. And, you are now
    able to write tests for bugs and fix the bug by making the test pass.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章获得的知识，你将能够使用协调器模式实现和测试应用的导航。现在，你也能够编写测试来查找错误，并通过使测试通过来修复错误。
- en: Congratulations, you reached the end of this book! My hope is that this book
    is the beginning of your journey to becoming a test-driven developer. You learned
    how to test `Combine` code and write tests for view controllers and views, table
    views, and even SwiftUI code. I believe this is a good foundation for your next
    steps. Try to add tests to your existing projects and talk to your colleagues
    about the advantages and disadvantages of unit tests and TDD. Find your own testing
    style.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你到达了这本书的结尾！我希望这本书是你成为测试驱动开发者的旅程的开始。你学习了如何测试`Combine`代码，并为视图控制器、视图、表格视图甚至SwiftUI代码编写测试。我相信这是你下一步的好基础。尝试给你的现有项目添加测试，并与你的同事讨论单元测试和TDD的优缺点。找到你自己的测试风格。
- en: Most importantly, have fun!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，享受乐趣！
- en: Exercises
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Fix the bugs you found while testing the app on the simulator.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复在模拟器上测试应用时发现的错误。
- en: Add the feature that the user can check to-do items in the list of all to-do
    items.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个功能，让用户可以在所有待办事项列表中勾选待办事项。
- en: Write a review for this book on Amazon.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在亚马逊上为这本书写一篇评论。
