- en: '*Chapter 11*: Easy Navigation with Coordinators'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An iOS app is usually a collection of single screens somehow connected to each
    other. Inexperienced developers often present a view controller from another view
    controller, because this is easy to implement and it is often shown that way in
    tutorials and demo code. But, for apps that need to be maintained over a long
    period of time, we need a pattern that is easier to understand and easier to change.
  prefs: []
  type: TYPE_NORMAL
- en: The **coordinator pattern** is very easy to implement and still manages to decouple
    the navigation between views of the app from the presentation of the information.
    In the coordinator pattern, a structure called a coordinator is responsible for
    navigating between views. View controllers tell the coordinator that the user
    interacted with the app and the coordinator decides which view controller should
    become responsible for the screen next.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, the coordinator pattern makes testing navigation code simpler and
    more robust, and as a result, this pattern is a good fit for **test-driven development**
    (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: The app we are building in this book is a small app with only three screens.
    The navigation between those three screens can be bundled into one coordinator.
    In more complicated apps, you would usually use more than one coordinator. To
    learn more about the coordinator pattern, there are plenty of blog posts on the
    internet about that topic. You don't need to know anything about that pattern
    to follow the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to test and implement the navigation between
    the different views of an app using the coordinator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the app's setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to the details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to a modal view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding missing parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by refactoring the app's setup with the coordinator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the app's setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When our app starts, a coordinator should be instantiated and started. This
    should result in the presentation of the initial view of our app. Follow these
    steps to refactor the setup from using a storyboard to using a coordinator:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can refactor the setup of the app, we need a test that tells us when
    we break something. Select the `AppSetupTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content of the new class with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we get the `rootViewController` property of the first window of
    our app and we check whether it is of the `ToDoItemsListViewController` type.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that all tests pass right now. This test passes because
    the storyboard is set up in a way that the app starts with an instance of the
    `ToDoItemsListViewController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Main.storyboard` and uncheck the checkbox for `ToDoItemsListViewController`
    scene in the attribute inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Removing the initial view controller setting from the storyboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.01_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Removing the initial view controller setting from the storyboard
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the `ToDoItemsListViewController`. With this change, we can instantiate
    this view controller in the code using this ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the tests to confirm that now the last test we added fails. Oh, there is
    another test that fails. In `ToDoItemsListViewControllerTests`, all tests fail,
    because the setup in `setUpWithError` throws an error. Let''s fix this error before
    we move on with the setup of our app. `ToDoItemsListViewController` isn''t the
    initial view controller of the storyboard anymore. This means we need to load
    it using its ID. Replace `setUpWithError()` with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all tests again. Now, only our app setup test fails. Good. Let's move on
    to the implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `AppCoordinator.swift`. Replace the content of the new file with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code defines the `Coordinator` protocol. This is how I implement the coordinator
    pattern. In blogs and books of other developers, you might find other implementations.
    Don't worry, they only differ in their details. When you have worked a bit with
    the coordinator pattern, you might develop your own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation of the protocol tells us that a coordinator has a `start`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following implementation of our `AppCoordinator` in the same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the initializer of `AppCoordinator`, we store the window that was passed
    in as a parameter, and we set up the view of the initial view controller. In the
    `start` method, we set the `rootViewController` property of the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `SceneDelegate` and add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, replace the `scene(_:willConnectTo:options:)` method with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we first set up an instance of the `UIWindow` class. Next, we
    instantiate the `AppCoordinator` instance and call its `start` method. Finally,
    we call `makeKeyAndVisible` on the window to tell `UIKit` that this window should
    be presented on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests to confirm that our refactoring was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the app works as it did before. When the app starts, an instance of `ToDoItemsListViewController`
    is created and shown. But, this is not as it should work in the final app. The
    list of to-do items needs to be presented on a `UINavigationController` instance
    to be able to navigate to the details of a to-do item later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `test_application_shouldSetupRoot()` test method with the following
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to see this test now failing in the line before the `XCTAssert`
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make this test pass again, we first need a property for the navigation controller
    in the `AppCoordinator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up the navigation controller in the `init` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have added the navigation controller as a parameter with a default value
    to the `init` call. This will come in handy later when we add tests for the navigation
    to the details of a to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can change the `start` method to add the instance of `ToDoItemsListViewController`
    to the navigation stack of the navigation controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests are now passing again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not done yet with setting up the list view controller. Remember, the
    list view controller communicates interactions by the user to a delegate object
    conforming to the `ToDoItemsListViewControllerProtocol` protocol we defined in
    [*Chapter 7*](B18127_07_ePub.xhtml#_idTextAnchor177), *Building a Table View Controller
    for the To-Do Items*. Follow these steps to implement this part of the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `AppCoordinatorTests`. Remove the two template test methods and add
    the `@testable import ToDo` import statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will make the `AppCoordinator` class conform to the `ToDoItemsListViewControllerProtocol`
    protocol. Add the following code to `AppCoordinator.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This implementation does nothing yet. We will implement this method in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: To write a test for assigning the delegate property of the list view controller,
    we need to access the list view controller in the `test` method. The view controller
    property of the `AppCoordinator` class is private. This means we cannot access
    it in the test. We could change the access level of the view controller property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But for educational reasons, we will do something else. We will pass a navigation
    controller mock into the `init` method of the `AppCoordinator` class and get the
    initial view controller from that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new Swift class to the `NavigationControllerMock`. Replace the contents
    of that new file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This subclass of the `UINavigationController` class stores the last pushed view
    controller for later inspection, and then calls the implementation of the `super`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use this class in the `AppCoordinator` tests. Add the following
    properties to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `setUpWithError` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we create a dummy window and an instance of `NavigationControllerMock`,
    and use both to initialize an instance of `AppCoordinator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we set up for the tests, we have to clean up when the tests are finished.
    Replace the `tearDownWithError` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this preparation, we can add a test to confirm that the `start` method
    assigns the instance of `AppCoordinator` to the delegate of the list view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we call the `start` method of the `AppCoordinator` instance and
    then assert that `sut` is assigned to the delegate property of the list view controller.
    We use here the `XCTAssertIdentical(_:_:)` assert function. As `AppCoordinator`
    is a class, we can check in the test whether the delegate is identical to `sut`.
    This assert function compares the pointer address of the two items, and the test
    passes when both references are the same. This does not work with value types
    because they are copied when assigned (or rather when changed).
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, add the following code to the end of the `start` method
    in `AppCoordinator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this addition makes the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: '`ToDoItemsListViewController` shows the to-do items it gets from an instance
    of `ToDoItemStore`. We need to provide the list view controller with an item store
    when it is set up. Follow these steps to add the item store to the list view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we assert that the `toDoItemStore` property of the list view controller
    is not nil. Run the tests to confirm that this test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this test pass. Add the following property to `AppCoordinator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign this property in the `init` method with a new instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, assign this property to the property of the list view controller within
    the `if let` statement of the `start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: The setup of the coordinator and the initial view controller is now complete.
    We can move on to implementing the interaction of the list view controller with
    the app coordinator.
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps a table view cell with a to-do item, the app should navigate
    to the details of that item. In the following section, we will implement this
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to the details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the navigation within the app using the `AppCoordinator`
    class. Follow these steps to implement navigation to the details of to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we execute the `delegate` method and assert that an instance of
    `ToDoItemDetailsViewController` is pushed to the navigation stack, and that its
    `toDoItem` is the item we used in the `delegate` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the implementation of `selectToDoItem(_:item:)` with this implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we instantiate an instance of `ToDoItemDetailsViewController`
    from the storyboard and set it up with the to-do item passed into the method.
    Then we push the new view controller onto the navigation stack.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that all tests now pass again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The details view controller needs a reference to `toDoItemStore` because the
    user can change the status of the item to `done` in the details view. Add the
    following test to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test looks like the previous one. We only changed the assert function call
    to check whether the `toDoItemStore` property is identical to the `sut` property.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to see this test failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, assign the `toDoItemStore` property below the line
    we assigned the `toDoItem` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: When the user selects a cell with a to-do item, our app now shows the details
    of that item on the screen. There is one feature missing. The app needs to allow
    the input of new to-do items. We will implement the presentation of the input
    view from the list view in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to a modal view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, testing the presentation of a modal view controller is quite complicated.
    If you search how to do that on the internet, you will find that the common solutions
    work by swizzling the `present(_:animated:completion:)` method defined in the
    `UIViewController` class. Swizzling is quite complicated, and I will not show
    in this book how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: But, because we are using the coordinator pattern for the navigation in our
    app, we can test the presentation without the need to swizzle any method. Still,
    you should look up how to swizzle methods because sometimes you don't have the
    option to use the coordinator pattern; for example, when there is already all
    the navigation code implemented and you are not allowed to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the presentation of the input view when the
    user chooses to add a new to-do item:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The app needs a button in the user interface that the user can tap to add a
    to-do item. When the user taps that button, the list view controller should tell
    its delegate about it. Add the following method definition to `ToDoItemsListViewControllerProtocol`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the compiler happy, add the following empty method implementation to
    `AppCoordinator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have another class that conforms to the `ToDoItemsListViewControllerProtocol`
    protocol. Add the following code to the end of the `ToDoItemsListViewControllerProtocolMock`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The mock object counts the number of calls of the `addToDoItem(_:)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a view controller mock that catches the last presented view controller.
    Select the `ViewControllerMock.swift`. Replace its content with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This mock stores the presented view controller in a property for later inspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the test. Import `SwiftUI` to `AppCoordinatorTests.swift`
    and add the following test method to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test calls `addToDoItem(_:)` and asserts that the `sut` variable is assigned
    as the delegate of the presented instance of `ToDoItemInputView`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, import `SwiftUI` into `AppCoordinator.swift` and replace
    the implementation of `addToDoItem(_:)` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode shows an error; we will fix this error in the next step. This code instantiates
    an instance of `UIHostingController` with a root view of `ToDoItemInputView`.
    This is how we can present a `SwiftUI` view from a `UIKit` environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this code compile, add the following extension to `AppCoordinator.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: One part of this feature is finished. Next, we need to implement the other part
    in the `ToDoItemsListViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we get the right bar button item of the `sut` variable and call
    its action on its target. This should result in a call to the `addToDoItem(_:)`
    method of the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests and confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of `viewDidLoad()` of `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, we add a bar button to the navigation item of the `ToDoItemsListViewController`
    instance. This results in a bar button that is added to the navigation bar of
    the navigation controller that hosts `ToDoItemsListViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following method to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we let the implementation of this method empty because we want to see
    the test fail in the assert function call. Run the tests and confirm that the
    test we added last now fails in the assert call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, add the missing code in `add(_:)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that `ToDoItemInputView` calls its delegate when the user selects
    the `add(_:)` method of `ToDoItemStore`. Take the following steps to implement
    this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test asserts that, after calling `addToDoItem(with:coordinate:)`, now `itemPublisher`
    of the `toDoItemStore` property publishes the change to the stored items.
  prefs: []
  type: TYPE_NORMAL
- en: As we are adding a to-do item to the item store, we need to replace `doToItemStore`
    in `AppCoordinator` with a test store. Otherwise, the test could fail because
    of items added to the store in other tests or while we test the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `init` method of the `AppCoordinator` class with the following
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have added the `toDoItemStore` parameter to the method and we use that
    parameter to set the `toDoItemStore` property used in the `AppCoordinator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can use a test store when setting up `sut` in `setUpWithError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To delete the item store when the test is finished, add the following code
    to the end of `tearDownWithError` of `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code should look familiar, as we already used it in `ToDoItemStoreTests`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that the new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the test pass with the following implementation of `addToDoItem(with:coordinate:)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we added an internal parameter name of `item` for the first parameter
    of that method.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we create an instance of `ToDoItem` from the `ToDoItemData` structure.
    Then, we call the `add(_:)` method of `toDoItemStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this change makes all tests pass again.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are done with the implementation. Let's make the app work in the
    simulator and see whether we missed something.
  prefs: []
  type: TYPE_NORMAL
- en: Adding missing parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's run the app for the first time to see where we are.
  prefs: []
  type: TYPE_NORMAL
- en: The app starts with a blank screen with just one plus (**+**) button in the
    upper-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The initial view of our app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – The initial view of our app
  prefs: []
  type: TYPE_NORMAL
- en: So, there is work to do here. But, let's move on and tap the plus (**+**) button.
    We are presented with the input view. We can add data for the item and tap the
    **Save** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The input view of our app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.03_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – The input view of our app
  prefs: []
  type: TYPE_NORMAL
- en: But, when we tap the **Save** button, nothing happens. Dismiss the view by swiping
    down, and see whether the item was added. Something changed. There is a blank
    table view cell visible in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – A blank table view cell. Where is the to-do item?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.04_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – A blank table view cell. Where is the to-do item?
  prefs: []
  type: TYPE_NORMAL
- en: When you tap the blank table view cell, the detail view is pushed onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The details of the to-do item. But, where is the due date?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.05_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – The details of the to-do item. But, where is the due date?
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have some work to do. Let's go back to Xcode and fix some problems.
  prefs: []
  type: TYPE_NORMAL
- en: Making the cells visible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table view doesn't show the information of the to-do items. The reason is,
    we didn't add constraints to the views when we added the labels. This was on purpose
    because I believe you should not write unit tests to test the position and size
    of interface elements. UI tests of snapshot tests are a better tool for these
    kinds of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to fix the layout of the cells and the table view:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Main.storyboard` in `0` and click **Add 4 Constraints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The constraints for the table view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.06_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – The constraints for the table view
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to `ToDoItemCell`, and replace the `init` method with the following
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `UIStackView` instances to lay out the elements. Run the tests to confirm
    that we didn't break anything. Then, run the app again on the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: It looks better, but the due date is still missing in the table view cell. The
    reason is that we didn't set up the `dateFormatter` instance currently. We found
    a bug. Whenever we find a bug, we should try to write a test that fails because
    of that bug. Then, we should make the test pass by fixing the bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `XCTAssertNotEqual` assert function does the opposite of the `XCTAssertEqual`
    function. It passes when the two values are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to see this test failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass and the bug disappear, add these lines to `viewDidLoad`
    below the `super.viewDidLoad()` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this makes the test green. Then, run the app on
    the simulator. Woohoo! We fixed our first bug with the help of TDD. This is a
    milestone. We are now sure that this bug won't come back as long as this test
    is run regularly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to fix the bug that the input view is not dismissed when the user
    taps the **Save** button.
  prefs: []
  type: TYPE_NORMAL
- en: Dismissing the input view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, we have a bug. Let''s see whether we can write a test for that bug.
    Follow these steps to fix the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation controller mock should register if `dismiss(animated:completion:)`
    got called. This way, we can make sure that it is called when a new item is added.
    Add the following code to `NavigationControllerMock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code counts the times `dismiss(animated:completion:)` got called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `AppCoordinatorTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to see this test failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of `addToDoItem(with:coordinate:)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this code makes all tests pass again. Then, run
    the app and add a new to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: We fixed another bug using TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's fix the bug in the details that the due date isn't shown.
  prefs: []
  type: TYPE_NORMAL
- en: Making the due date visible in the details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason that the date is not shown in the details is the same as for the
    table view cell. The date formatter isn't set up correctly. You already know how
    to write a test for this. Write the test and make sure that the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass and, therefore, fix the bug, you can use this definition
    of the `dateFormatter` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This should make your test pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app again, and play around with it. You might realize some more bugs.
    Here is what I found:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps the **Done** button in the details, the app should pop back
    to the list of to-do items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The section headers are missing in the table view. The done items are correctly
    moved to the second section, but it's not visible in the user interface that there
    are several sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user marks the first item done, the order in the table view changes.
    If the user then selects the first item in the table view, the details for the
    other item are shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cell stays selected even after the user came back from the details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debug console shows a warning that the table view was told to lay out the
    cells when it is not visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We sure found some more bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will fix only the third and the fifth bug in this
    list. The other bugs are left as an exercise for you. If you get stuck, have a
    look at the code for this chapter on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the wrong item being selected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, let''s try to write a test for this bug before we try to fix it. Follow
    these steps to fix that bug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we set up the sections when we create the snapshot for
    the diffable data source, but we ignore the section when the user selects a table
    view row. We can change the `test_didSelectCellAt_shouldCallDelegate` method to
    check for this error. Replace the implementation of that test method with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We change the test to use two items, one done item and one item that is not
    done yet.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to see this test failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass and thus fix the bug, replace the implementation of `tableView(_:didSelectRowAt:)`
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this implementation, we respect the two sections and choose the item to be
    shown accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests to confirm that all tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: And, with this last bug fixed, we are done with the first simple version of
    our little app that we created using TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the layout of the table view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem here is that we use the `Combine` framework to update the table
    view. When the user taps the `doToItemStore` updates its items and tells the table
    view about it. This results in an update of the table view when it is not visible
    on the screen. This is easy to fix and we don''t even need a test for this. Add
    the following code to `ToDoItemsListViewController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When the view with the table view disappears, we unsubscribe from `itemsPublisher`.
    When the view appears on the screen, we subscribe again. Run the app again in
    the simulator and have a look at the console to see whether the message is gone.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we have implemented the navigation between the different
    views of our app. We have learned how to test pushing view controllers onto a
    navigation stack and how we can test whether a view got presented modally.
  prefs: []
  type: TYPE_NORMAL
- en: With navigation implemented, we started the app on the simulator and found and
    fixed bugs. We figured out that TDD even helps when fixing bugs. By writing first
    a failing test for that bug and then making the test pass, we ensured that this
    bug won't hurt us in the future of our app.
  prefs: []
  type: TYPE_NORMAL
- en: With the skills you gained in this chapter, you will be able to implement and
    test the navigation of an app using the coordinator pattern. And, you are now
    able to write tests for bugs and fix the bug by making the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you reached the end of this book! My hope is that this book
    is the beginning of your journey to becoming a test-driven developer. You learned
    how to test `Combine` code and write tests for view controllers and views, table
    views, and even SwiftUI code. I believe this is a good foundation for your next
    steps. Try to add tests to your existing projects and talk to your colleagues
    about the advantages and disadvantages of unit tests and TDD. Find your own testing
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fix the bugs you found while testing the app on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the feature that the user can check to-do items in the list of all to-do
    items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a review for this book on Amazon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
