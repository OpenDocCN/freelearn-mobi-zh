- en: Chapter 7. AI and Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing AI waypoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing projectiles at moving targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI line of sight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI flocking using Boids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* pathfinding on a grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* pathfinding in a Box2D world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* pathfinding on a TMX tilemap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* pathfinding in a side-scroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a Lua script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically loading Lua scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Lua for dialogue trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All games that simulate intelligent behavior use a form of **Artificial Intelligence**
    (AI). Different techniques are used to simulate behavior for different gameplay
    requirements. In this chapter, we will implement a few of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Processing AI waypoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic AI processes involves moving an AI actor around in a physical
    environment. To do this, we will create a **queue** of **waypoints**. Each waypoint
    represents the next position we want our actor to move to.
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing AI waypoints](img/4002_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Waypoint processing involves moving the actor toward the next waypoint at every
    step. If the actor stops making progress toward the next point, that point is
    dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '`GameWaypoint:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameWaypoint` class consists of a number of variables including, most importantly,
    the waypoint's position as well as how fast the actor should move toward that
    point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Processing waypoints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of `GameWaypoint` objects are stored in the `GameActor` class. The `processWaypoints`
    method is called in every frame. This moves the actor toward the next waypoint.
    The pseudocode for this process is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using this basic logic, we move the actor toward each subsequent waypoint in
    2D space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ObjectCallback:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional functionality is included to allow for method callbacks before and
    after the actor reaches specific waypoints. These use the `ObjectCallback` class
    that simply calls a method on an existing class using the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to combine logic and AI character movement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating random polygons using the Convex Hull algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To populate our physical world with randomly generated polygons, we use the
    Monotone Chain Convex Hull algorithm to generate our polygon vertices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method takes in a set of randomly generated points and returns an array
    of vertices that surround these points. Although we have a fairly simple reason
    for using this, the algorithm has a number of other applications ranging from
    simple AI to advanced computer vision. More information about this algorithm can
    be found here: [http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Firing projectiles at moving targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For AI actors to interact with their environment realistically, they must make
    calculations that human players make naturally. One common interaction involves
    firing a projectile at a moving target.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firing projectiles at moving targets](img/4002_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we create three enemy actors that fire projectiles at the player.
    Each projectile is fired with the speed and direction to hit the player even when
    it's moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating intercept trajectory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are given the actor and enemy positions and velocities as well as how
    fast we can fire the projectile, we can then calculate the ''intercept angle''
    by creating a distance over time equation for both the player and the projectile.
    We then use the **quadratic formula** to find the time when these lines intersect.
    The formula is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get our a, b, and c variables we do the following, where `tx` and `ty` are
    position vector components and `tvx` and `tvy` are velocity vector components:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then use our `GameHelper` quadratic formula method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The quadratic method returns a `Vector3D` object to conveniently store two
    float primitives inside an `NSObject`. If the object is nil, the formula''s discriminant
    was `<= 0.0f`. Otherwise we take the smallest non-zero solution. We use this to
    finally calculate the firing solution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The projectile can be fired in this direction with the originally specified
    speed. If the moving target stays on course, the projectile will collide with
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Box2D filtering using Boolean algebra:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like in Chapter 4, Physics, here we use category bits and mask bits to prevent
    certain physical object types from colliding. In this recipe, we expand our use
    of this technique by using the ''everything bit'' `(0xFFFF)` as well as some more
    advanced Boolean logic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This keeps missiles from colliding with the enemy that fired them as well as
    from each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AI line of sight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Human beings employ five distinct senses to interact with the environment. One
    of these, vision, is its own branch of Computer Science entitled **Computer Vision**.
    In this example, we implement basic vision testing in a Box2D environment using
    a **Ray Cast** to see if there is another object in-between the player and an
    enemy AI actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![AI line of sight](img/4002_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a line can be drawn between an enemy actor and the player without going
    through level geometry, then we consider the player to be visible to the enemy
    and the enemy then begins to follow the player.
  prefs: []
  type: TYPE_NORMAL
- en: Using `RayCastClosest:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the following method to perform a ray test against our Box2D world:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The class `RayCastClosestCallback` wraps the class `b2RayCastCallback`. When
    we call the `RayCast` method and pass in an instance of this class, we are then
    able to tell whether or not our ray touched a Box2D fixture. It also maintains
    a pointer to the first fixture it touches. This is the closest fixture to our
    source point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Filtering out the first fixture found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because ray casts most often involve casting from inside one fixture to another,
    the first fixture found is filtered out.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RayCast.h:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `RayCast.h` file also contains the classes `RayCastAnyCallback` and `RayCastMultipleCallback`.
    The any class finds any fixture along the ray while the `multiple` class maintains
    a list of fixtures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many uses for ray casts. One simple example is a cover mechanic. When
    an enemy feels vulnerable, it can find the nearest fixture that the player can't
    see through. Another use involves using the **normal** point returned by the ray
    cast. This is the exact point of collision with the specified fixture. This can
    be used to create laser weapons or instant bullet impacts.
  prefs: []
  type: TYPE_NORMAL
- en: AI flocking using Boids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By placing many more enemies in a game we begin to require some group-based
    AI. A popular algorithm used in both video games and films is the **Boids** algorithm.
    It simulates **flocking** behavior. In this recipe, we will create a large number
    of enemies who flock together and chase the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![AI flocking using Boids](img/4002_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boids algorithm uses a few simple concepts to create realistic actor flocking.
    It uses three rules that act on each actor's velocity in each frame. These adjust
    their behavior to maintain flocking without overpowering other forces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boids rule 1—keeping** the flock together:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep the flock of actors together we first get the center of mass of the
    flock by averaging all actor positions. We then adjust actor velocity to move
    each actor 1 percent toward the center of the flock.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Boids rule 2—give** the actors some personal space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep the flock from clumping together too much, we inspect each actor. If
    there are other actors within a certain threshold of space, then we move this
    actor that distance away from the other actor. When this is applied across all
    actors, a nice equilibrium arises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Boids rule 3—match** all actor velocities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, all actors should move together at roughly the same pace. In rule 1,
    we averaged all actor positions. In this rule we average all velocities then add
    a fraction (1/30) of that velocity to each actor. This ensures the uniform movement
    speed of all the actors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Moving the actors toward the player:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moving the enemy actors toward the player involves finding a normalized vector
    in the direction of the player and then adding that vector with a certain magnitude
    to the actor''s linear velocity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also limit the velocity of each actor so they don''t go careening off in
    a direction too quickly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When all these methods are combined, we get a realistic flocking effect that
    works for a swarm of birds, bees, or even zombies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A* pathfinding on a grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic video game problem is that of pathfinding. Intelligent actors are
    often required to navigate around obstacles during gameplay. The **A* search algorithm**
    (also known as **A Star)** is commonly used to solve pathfinding by efficiently
    traversing a constructed node graph. In this recipe, we will demonstrate grid-based
    A* pathfinding.
  prefs: []
  type: TYPE_NORMAL
- en: '![A* pathfinding on a grid](img/4002_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The A* algorithm uses a heuristic to perform a best-first search over a node
    graph. First, we must create this node graph.
  prefs: []
  type: TYPE_NORMAL
- en: '`AStarNode:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node graph consists of a collection of nodes, each representing a real world
    position. This is encapsulated within the `AStarNode` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Storing the nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this recipe, we store our nodes in a nested 2D `NSArray` structure. This
    is not required by the A* algorithm, but, merely a convention used to store the
    nodes. With this structure, we can quickly identify the closest `AStarNode` to
    a point. We can also link the nodes to each other in a simple, logical way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Connecting the nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes are connected to each other by having each one maintain a list of its
    neighboring nodes. In this grid setup, each node links to eight other nodes in
    eight different directions. To remove diagonal movement, nodes would only be connected
    in four directions instead of eight.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating ''walls'':'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, darker colored 'walls' represent non-navigable areas. These
    nodes are simply set to `active = NO`. When the A* algorithm is run, they are
    skipped over.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AStarPathNode:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data structure used to find and store the optimal path is a linked list
    of `AStarPathNode` objects. This class stores a node, the previous node, and a
    total estimated cost to the goal from this node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finding the path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once our nodes are created and linked up, we call the following method to find
    a path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This performs a **greedy best-first** search for the best path. The greedy
    heuristic used is the simple absolute "as the crow flies" distance to the goal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on assumptions relating to the construction of the node graph and
    how it relates to movement costs, other heuristics can be used. For example, a
    slight improvement might be to use the diagonal distance to the goal across the
    nodes instead of the absolute 2D space distance. If we disabled diagonal movement,
    then we would want to use the Manhattan heuristic to estimate movement cost on
    a grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AStarNode` class contains a `costModifier` variable. This can be used to
    increase the relative cost to this specific node. A node with an increased movement
    cost could represent rough terrain like mud or shallow water. Other AI concepts
    could also be mixed into the pathfinding algorithm. For example, a specific area
    or group of nodes could be considered more dangerous than others. AI actors would
    then have to weigh speed versus danger when determining a path.
  prefs: []
  type: TYPE_NORMAL
- en: A* pathfinding in a Box2D world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real fun of the A* algorithm comes from applying it to more complex scenarios.
    In this recipe, we will apply the grid-based technique of the last recipe to a
    Box2D world filled with randomly generated polygons.
  prefs: []
  type: TYPE_NORMAL
- en: '![A* pathfinding in a Box2D world](img/4002_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in the last recipe, we first create a 2D nested `NSArray` container
    for our `AStarNode` objects. After linking all the nodes together, we need to
    adjust the graph to accurately reflect the 2D geometry in the Box2D world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Culling neighbor nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To properly represent 2D world geometry we need to cull edges of the node graph
    that lead into these static fixtures. To do this, we first find all nodes that
    are located inside a shape. This involves using the following method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return whether or not that point exists within the shape. If so,
    we cut off all connections to this node. In addition to this, we also do ray cast
    tests for each neighbor connection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Four tests are performed for each connection. We do this to approximate the
    actor's circular shape. If this ray cast hits a fixture, we remove the connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique works well for a small level. However, generating a node graph
    for a large level can possibly be a very time consuming process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speeding up load times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To decrease map load times, neighbor culling should be done by the level editor
    and the neighbor connections should be stored in the map file along with the nodes
    and the geometry. We do this at run time within our application to give you an
    idea of the process without having to create a Cocos2d level editor that implements
    this technique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A* pathfinding on a TMX tilemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've skipped ahead to [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and
    Ports"), *Tips, Tools, and Ports*, you'll see a recipe showing how to use the
    Tiled application with the TMX tilemap toolset. In this recipe, we create a 2.5D
    adventure game. To see our grid based pathfinding technique in action, we overload
    the [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and Ports"), *Tips, Tools,
    and Ports* recipe entitled *Creating levels using Tiled*.
  prefs: []
  type: TYPE_NORMAL
- en: '![A* pathfinding on a TMX tilemap](img/4002_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we can see our algorithm come to life with some nice animated
    AI character movement. We simply replace `nodeSpace` with `tileMap.tileSize.width/height`
    and replace `gridSizeX/Y` with `tileMap.mapSize.width/height`. Our character can
    now move around the forest and other obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: A* pathfinding in a side-scroller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The A* algorithm is a generic node-graph traversal routine which can be applied
    to many abstract problems. In a 2D side-scroller, space is traversed in a complex,
    non-linear fashion. Actors are expected to run across platforms and jump from
    platform to platform. With some extra math, we can tailor our A* technique to
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![A* pathfinding in a side-scroller](img/4002_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code listed as follows is heavily edited for the sake of brevity. Please
    refer to the project *RecipeCollection03* for full working code of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must create our node graph. In a top-down 2D environment, we simply
    use a grid and then cull out any colliding edges. In a side-scrolling environment,
    we need to think differently. Actors in such an environment must stand on top
    of the level geometry at all times. In addition to this, they have two different
    ways of traversing through the level: **running** and **jumping**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running across a platform:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow an actor to run across a platform, we need to create a string of A*
    nodes on top of each platform. Starting at one of these nodes, the actor can easily
    move to the other nodes on that same body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Jumping from platform to platform:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reach another platform, the actor must jump there. This adds more complexity.
    We need to perform the calculations required to launch the actor safely to the
    other platform. We also need to check for geometry in the actor's jump trajectory
    and adjust the angle of the jump as necessary. Before we can implement this functionality,
    we need to encapsulate it in a new set of classes we create as sub-classes of
    our current ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSAStarNode:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SSAStarNode` contains references to a b2Body object as well as a `SSGameActor`
    object. The body object represents the body the actor is resting on when at this
    node. A reference to the actor is maintained because actor information such as
    size, jumping speed, and running speed are required to make some of the aformentioned
    calculations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSGameWaypoint:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our new waypoint class contains a `moveType` enumeration that specifies whether
    or not the actor should RUN or JUMP to the waypoint's location. It also contains
    a `launchVector` that specifies the impulse vector required if a jump is to be
    performed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSGameActor:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new actor class has a `maxSpeed` variable that determines both how fast
    the actor can run and how high the actor can jump. This class also encapsulates
    our newly modified `processWaypoints` method as well as a few others:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `runToWaypoint` method simply sets the actor's velocity to make it run left
    or right. The `jumpToWaypoint` method launches the actor using the waypoint's
    `launchVector`. The `canJumpFrom` method determines whether or not a jump is possible
    to a certain point. This involves testing multiple jump angles against the geometry
    of the Box2D world. Each jump parabola is broken up into 10 straight-line sections
    that are ray tested against map geometry. This approximates collision detection
    well enough for our purposes. Finally, the getLaunchVector method, which is employed
    by the `canJumpFrom` method, determines the `launchVector` for the actor given
    a location to land on and given a Y jump height relative to the X jump width.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSAStarPathNode:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class is similar to `AStarPathNode`. It contains a `SSGameWaypoint` pointer
    for convenience. In the updated `findPathFrom` method, we create this waypoint
    and set its `launchVector`. This ensures that `launchVector` is only calculated
    at load time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SSNeighborNode:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As now we have two methods of moving from one node to another, we need a more
    complex way of storing graph edge information. Instead of simply storing a pointer
    to a neighboring node, this class encapsulates that node along with a `moveType,
    cost,` and `launchVector`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating our node graph—run nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First we must create our key nodes. These are like keyframes in an animation.
    They are located slightly above each vertex on the top side of every platform.
    We then add nodes in-between these nodes. Finally, these "run nodes" are linked
    together with the moveType variable set to `MOVE_TYPE_RUN`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating our node graph—jump nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the run nodes are set over each platform, we create jump nodes. This involves
    searching the immediate area around each node, determining whether or not the
    actor can jump from that node to a found node, and then finally creating the neighbor
    link. We create these links one at a time as jumping up to reach a node is very
    different from jumping down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tweaking side-scrolling pathfinding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique required a lot of tweaking to get working properly. For example,
    the X and Y distance thresholds, used to determine whether or not a waypoint has
    been reached, vary greatly. Another tweak involves the fact that, if a waypoint
    is blocked, the entire set of waypoints must be discarded. Perhaps another revision
    could salvage the second half of the path of nodes by prepending a new path to
    the missed node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running a Lua script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many commercial games make use of a **scripting language** to isolate and abstract
    their **game logic**. The most popular of these is **Lua**. In this recipe, we
    will integrate Lua into our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a Lua script](img/4002_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lua can be added to your project in a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Highlight your project in the Navigator. At the bottom of your window in the
    middle, click **Add Target:**![How to do it...](img/4002_07_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the target "Lua". This will create a new folder inside your project folder
    next to your main target's similarly named folder. It should also create a new
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Lua source from [http://www.lua.org](http://www.lua.org) and copy
    it to this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Lua** group and select **Add Files to "Your**![How to do it...](img/4002_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `src` directory and add all the files located there except for
    `lua.c, luac.c, Makefile`, and `print.c`. Also, be sure to uncheck **Copy items
    into destination groups folder** and select only **Lua** under the **Add to Targets**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you should be able to build the Lua target with no errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle pane, click your project's main target. Expand **Link Binary With
    Libraries**. Click the **+** symbol at the bottom-left and add the **libLua.a**
    library to the list:![How to do it...](img/4002_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collapse this and expand **Target Dependencies**. Add the target **Lua** as
    a dependency of this target:![How to do it...](img/4002_07_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it. Lua is now integrated. Clean and build your project to make sure
    it was integrated properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This and subsequent recipes use Robert Grzesek's `mcLua` API to facilitate the
    loading and execution of Lua scripts. It also allows for concurrent execution
    of multiple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mcLuaManager` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mcLuaManager` class is the top-level class that manages all running scripts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is in charge of running the scripts as well as their creation and destruction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Loading and starting a script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loading a Lua script is a fairly straightforward process:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the file is loaded, we make a call to the `mcLuaManager` class''s `Update`
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This starts the loaded scripts off and running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Static function libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the Lua script, global methods can be called according to function libraries
    assigned to object identifiers. The mcLua API assigns a few functions to the script
    object by default. These include `waitSeconds, waitFrames`, and `pause`. They
    can be called inside the Lua script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we also create a callback method named `appendMessage` and
    assign it to an object named `scene`. To do this, we first create a static C function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the recipe is loaded, we create a Lua script library linker array and
    load it into memory using the `LuaOpenLibrary` provided by the `mcLua` API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is loaded, we can call that function from the Lua script itself:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if the script is paused (from inside or outside the script itself)
    it can be resumed (only from outside the script):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Together this library lets your Lua script interact with your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dynamically loading Lua scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of the power of a scripting language like Lua, is that scripts can be loaded
    and re-loaded at **run-time**. This means you can test your game logic without
    having to re-compile your Objective-C++ code. In this recipe, we will load a remote
    script from a local **web server**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamically loading Lua scripts](img/4002_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to load a remote script is to use a local web server. This
    way we can bypass `NSBundle` and the somewhat restricted iOS filesystem. Mac OSX
    ships with a built-in Apache HTTP webserver. It can be enabled and configured
    by going to **System Preferences** | **Internet and Wireless** | **Sharing** |
    **Web Sharing:**
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a remote script:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of reading our script off the filesystem, we load it over HTTP using
    `NSURL`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Editing the file on your local web server and hitting the re-load button simply
    loads the script again. This is a simple but effective way to rapidly develop
    and test game logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reachability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we use Apple's Reachability library to help us determine whether
    or not we can access the script over the network. Without this tool our `stringWithContentsOfURL`
    method would throw errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Lua for dialogue trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lua lets the programmer write against a generic **interface** and worry about
    the **implementation** later. This separation between game logic, and the nuts
    and bolts of presenting the audio/visual elements of the game, is an important
    part of any game engine. In this recipe, we will use Lua to create a small story-based
    adventure game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Lua for dialogue trees](img/4002_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we create a number of callback functions to process animation,
    dialog, and logic. Some of these, like option prompts, wait for user response
    before the script is resumed. Other functions, like `ldtLogic`, have a return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing and returning variables using Lua:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lua''s variable passing mechanism is fairly simple. Functions are passed a
    lua_State pointer. Data can then be retrieved off of the stack pointed to by this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lua supports multiple return variables at one time. To return a variable from
    one of our callback functions, we must first push the variable onto the stack:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then specify the number of variables we are returning as an integer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All basic C types can be passed and returned using Lua.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Local Lua functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside of our script file we use a number of local Lua functions. Everything
    is encapsulated in a function except for the initial `start()` function call.
    Local functions also support returning multiple
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
