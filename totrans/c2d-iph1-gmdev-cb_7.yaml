- en: Chapter 7. AI and Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。AI和逻辑
- en: 'In this chapter, we will cover the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Processing AI waypoints
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理AI路标
- en: Firing projectiles at moving targets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向移动目标发射弹丸
- en: AI line of sight
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI视线
- en: AI flocking using Boids
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boids进行AI群集
- en: A* pathfinding on a grid
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格上进行A*路径查找
- en: A* pathfinding in a Box2D world
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Box2D世界中进行A*路径查找
- en: A* pathfinding on a TMX tilemap
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TMX瓦片地图上进行A*路径查找
- en: A* pathfinding in a side-scroller
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在横版滚动游戏中进行A*路径查找
- en: Running a Lua script
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Lua脚本
- en: Dynamically loading Lua scripts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载Lua脚本
- en: Using Lua for dialogue trees
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lua进行对话树
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: All games that simulate intelligent behavior use a form of **Artificial Intelligence**
    (AI). Different techniques are used to simulate behavior for different gameplay
    requirements. In this chapter, we will implement a few of these techniques.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模拟智能行为的游戏都使用一种形式的**人工智能**（AI）。根据不同的游戏玩法需求，使用不同的技术来模拟行为。在本章中，我们将实现其中的一些技术。
- en: Processing AI waypoints
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理AI路标
- en: One of the most basic AI processes involves moving an AI actor around in a physical
    environment. To do this, we will create a **queue** of **waypoints**. Each waypoint
    represents the next position we want our actor to move to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的AI过程之一涉及在物理环境中移动AI演员。为此，我们将创建一个**队列**的**路标**。每个路标代表我们希望演员移动到的下一个位置。
- en: '![Processing AI waypoints](img/4002_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![处理AI路标](img/4002_07_01.jpg)'
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection03*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Waypoint processing involves moving the actor toward the next waypoint at every
    step. If the actor stops making progress toward the next point, that point is
    dropped.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 路标处理涉及在每一步将演员移动到下一个路标。如果演员停止向下一个点前进，则该点将被丢弃。
- en: '`GameWaypoint:`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameWaypoint：`'
- en: The `GameWaypoint` class consists of a number of variables including, most importantly,
    the waypoint's position as well as how fast the actor should move toward that
    point.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameWaypoint`类包含多个变量，其中最重要的是路标的位置以及演员应该以多快的速度移动到该点。'
- en: 'Processing waypoints:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理路标：
- en: 'A list of `GameWaypoint` objects are stored in the `GameActor` class. The `processWaypoints`
    method is called in every frame. This moves the actor toward the next waypoint.
    The pseudocode for this process is as follows:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameActor`类中存储了一个`GameWaypoint`对象列表。在每一帧中都会调用`processWaypoints`方法。这会将演员移动到下一个路标。此过程的伪代码如下：'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using this basic logic, we move the actor toward each subsequent waypoint in
    2D space.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种基本逻辑，我们在2D空间中将演员移动到每个后续路标。
- en: '`ObjectCallback:`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectCallback：`'
- en: 'Additional functionality is included to allow for method callbacks before and
    after the actor reaches specific waypoints. These use the `ObjectCallback` class
    that simply calls a method on an existing class using the following line:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含了额外的功能，允许在演员到达特定路标前后进行方法回调。这些使用`ObjectCallback`类，该类简单地使用以下行在现有类上调用方法：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows us to combine logic and AI character movement.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使我们能够结合逻辑和AI角色移动。
- en: 'Creating random polygons using the Convex Hull algorithm:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凸包算法创建随机多边形：
- en: 'To populate our physical world with randomly generated polygons, we use the
    Monotone Chain Convex Hull algorithm to generate our polygon vertices:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了用随机生成的多边形填充我们的物理世界，我们使用单调链凸包算法生成我们的多边形顶点：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method takes in a set of randomly generated points and returns an array
    of vertices that surround these points. Although we have a fairly simple reason
    for using this, the algorithm has a number of other applications ranging from
    simple AI to advanced computer vision. More information about this algorithm can
    be found here: [http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法接受一组随机生成的点，并返回围绕这些点的顶点数组。尽管我们使用这个算法的原因相当简单，但该算法还有许多其他应用，从简单的AI到高级计算机视觉。有关此算法的更多信息，请参阅此处：[http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain)。
- en: Firing projectiles at moving targets
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向移动目标发射弹丸
- en: For AI actors to interact with their environment realistically, they must make
    calculations that human players make naturally. One common interaction involves
    firing a projectile at a moving target.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使人工智能演员能够与环境进行真实交互，它们必须进行人类玩家自然做出的计算。一种常见的交互涉及向移动目标发射投射物。
- en: '![Firing projectiles at moving targets](img/4002_07_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![向移动目标发射投射物](img/4002_07_02.jpg)'
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection03*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we create three enemy actors that fire projectiles at the player.
    Each projectile is fired with the speed and direction to hit the player even when
    it's moving.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了三个向玩家发射投射物的敌对演员。每个投射物都以足够的速度和方向发射，即使玩家在移动也能击中玩家。
- en: 'Calculating intercept trajectory:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算拦截轨迹：
- en: 'If we are given the actor and enemy positions and velocities as well as how
    fast we can fire the projectile, we can then calculate the ''intercept angle''
    by creating a distance over time equation for both the player and the projectile.
    We then use the **quadratic formula** to find the time when these lines intersect.
    The formula is as follows:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们给出了演员和敌人的位置、速度以及我们可以发射投射物的速度，我们可以通过为玩家和投射物创建一个距离随时间变化的方程来计算'拦截角度'。然后我们使用**二次方程**来找到这些线相交的时间。公式如下：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get our a, b, and c variables we do the following, where `tx` and `ty` are
    position vector components and `tvx` and `tvy` are velocity vector components:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了得到a、b和c变量，我们进行以下操作，其中`tx`和`ty`是位置向量的分量，`tvx`和`tvy`是速度向量的分量：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then use our `GameHelper` quadratic formula method:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们使用我们的`GameHelper`二次方程法：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The quadratic method returns a `Vector3D` object to conveniently store two
    float primitives inside an `NSObject`. If the object is nil, the formula''s discriminant
    was `<= 0.0f`. Otherwise we take the smallest non-zero solution. We use this to
    finally calculate the firing solution:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二次方法返回一个`Vector3D`对象，以便在`NSObject`内部方便地存储两个浮点原语。如果对象为nil，则公式的判别式为`<= 0.0f`。否则，我们取最小的非零解。我们使用这个来最终计算发射解决方案：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The projectile can be fired in this direction with the originally specified
    speed. If the moving target stays on course, the projectile will collide with
    it.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 投射物可以以最初指定的速度向这个方向发射。如果移动目标保持航向，投射物将与之相撞。
- en: 'Box2D filtering using Boolean algebra:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔代数进行Box2D过滤：
- en: 'Like in Chapter 4, Physics, here we use category bits and mask bits to prevent
    certain physical object types from colliding. In this recipe, we expand our use
    of this technique by using the ''everything bit'' `(0xFFFF)` as well as some more
    advanced Boolean logic:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像在第4章“物理”中一样，这里我们使用类别位和掩码位来防止某些物理对象类型相撞。在这个菜谱中，我们通过使用'一切位'（0xFFFF）以及一些更高级的布尔逻辑来扩展我们对这种技术的使用：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This keeps missiles from colliding with the enemy that fired them as well as
    from each other.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以防止导弹与发射它们的敌人相撞，以及彼此相撞。
- en: AI line of sight
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工智能视线
- en: Human beings employ five distinct senses to interact with the environment. One
    of these, vision, is its own branch of Computer Science entitled **Computer Vision**.
    In this example, we implement basic vision testing in a Box2D environment using
    a **Ray Cast** to see if there is another object in-between the player and an
    enemy AI actor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 人类使用五种不同的感官与环境互动。其中之一，视觉，是计算机科学的一个分支，称为**计算机视觉**。在这个例子中，我们使用**射线投射**在Box2D环境中实现基本的视觉测试，以查看玩家和敌对人工智能演员之间是否有其他对象。
- en: '![AI line of sight](img/4002_07_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![人工智能视线](img/4002_07_03.jpg)'
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection03*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a line can be drawn between an enemy actor and the player without going
    through level geometry, then we consider the player to be visible to the enemy
    and the enemy then begins to follow the player.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当可以在敌对演员和玩家之间画一条直线而不穿过关卡几何时，我们认为玩家对敌人来说是可见的，然后敌人开始跟随玩家。
- en: Using `RayCastClosest:`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RayCastClosest：`
- en: 'We use the following method to perform a ray test against our Box2D world:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用以下方法对Box2D世界执行射线测试：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class `RayCastClosestCallback` wraps the class `b2RayCastCallback`. When
    we call the `RayCast` method and pass in an instance of this class, we are then
    able to tell whether or not our ray touched a Box2D fixture. It also maintains
    a pointer to the first fixture it touches. This is the closest fixture to our
    source point.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类 `RayCastClosestCallback` 封装了类 `b2RayCastCallback`。当我们调用 `RayCast` 方法并传入这个类的实例时，我们就能判断我们的射线是否触碰到一个
    Box2D 几何体。它还维护了一个指向它首次接触到的几何体的指针。这是离我们的源点最近的几何体。
- en: 'Filtering out the first fixture found:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤掉第一个找到的几何体：
- en: Because ray casts most often involve casting from inside one fixture to another,
    the first fixture found is filtered out.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于射线投射通常涉及从一个几何体向另一个几何体投射，所以第一个找到的几何体会被过滤掉。
- en: '`RayCast.h:`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RayCast.h:`'
- en: Our `RayCast.h` file also contains the classes `RayCastAnyCallback` and `RayCastMultipleCallback`.
    The any class finds any fixture along the ray while the `multiple` class maintains
    a list of fixtures.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `RayCast.h` 文件还包含类 `RayCastAnyCallback` 和 `RayCastMultipleCallback`。`any`
    类在射线上找到任何几何体，而 `multiple` 类维护一个几何体列表。
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many uses for ray casts. One simple example is a cover mechanic. When
    an enemy feels vulnerable, it can find the nearest fixture that the player can't
    see through. Another use involves using the **normal** point returned by the ray
    cast. This is the exact point of collision with the specified fixture. This can
    be used to create laser weapons or instant bullet impacts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 射线投射有许多用途。一个简单的例子是掩体机制。当敌人感到脆弱时，它可以找到玩家无法看穿的最近的几何体。另一个用途涉及到使用射线投射返回的 **法线**
    点。这是与指定几何体碰撞的确切点。这可以用来创建激光武器或瞬间子弹冲击。
- en: AI flocking using Boids
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boids 的 AI 鸟群
- en: By placing many more enemies in a game we begin to require some group-based
    AI. A popular algorithm used in both video games and films is the **Boids** algorithm.
    It simulates **flocking** behavior. In this recipe, we will create a large number
    of enemies who flock together and chase the player.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在游戏中放置更多的敌人，我们开始需要一些基于群体的 AI。在视频游戏和电影中广泛使用的一个流行算法是 **Boids** 算法。它模拟 **鸟群**
    行为。在这个菜谱中，我们将创建大量聚集在一起并追逐玩家的敌人。
- en: '![AI flocking using Boids](img/4002_07_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Boids 的 AI 鸟群](img/4002_07_04.jpg)'
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Boids algorithm uses a few simple concepts to create realistic actor flocking.
    It uses three rules that act on each actor's velocity in each frame. These adjust
    their behavior to maintain flocking without overpowering other forces.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 算法使用一些简单概念来创建逼真的角色鸟群。它使用三个规则，在每个帧上作用于每个角色的速度。这些规则调整它们的行为，以保持鸟群而不过度影响其他力量。
- en: '**Boids rule 1—keeping** the flock together:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Boids 规则 1—保持** 鸟群在一起：'
- en: To keep the flock of actors together we first get the center of mass of the
    flock by averaging all actor positions. We then adjust actor velocity to move
    each actor 1 percent toward the center of the flock.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使角色鸟群保持在一起，我们首先通过平均所有角色的位置来获取鸟群的重心。然后我们调整角色的速度，使每个角色向鸟群中心移动 1%。
- en: '**Boids rule 2—give** the actors some personal space:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Boids 规则 2—给予** 角色一些个人空间：'
- en: To keep the flock from clumping together too much, we inspect each actor. If
    there are other actors within a certain threshold of space, then we move this
    actor that distance away from the other actor. When this is applied across all
    actors, a nice equilibrium arises.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了防止鸟群过于聚集，我们检查每个角色。如果某个角色在某个空间阈值内还有其他角色，那么我们就将这个角色移动到离其他角色这个距离。当这个操作应用于所有角色时，就会达到一个良好的平衡。
- en: '**Boids rule 3—match** all actor velocities:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Boids 规则 3—匹配** 所有角色的速度：'
- en: Finally, all actors should move together at roughly the same pace. In rule 1,
    we averaged all actor positions. In this rule we average all velocities then add
    a fraction (1/30) of that velocity to each actor. This ensures the uniform movement
    speed of all the actors.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，所有角色应该以大致相同的速度一起移动。在规则 1 中，我们平均了所有角色的位置。在这个规则中，我们平均了所有角色的速度，然后给每个角色加上该速度的分数（1/30）。这确保了所有角色的均匀移动速度。
- en: 'Moving the actors toward the player:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角色移动到玩家身边：
- en: 'Moving the enemy actors toward the player involves finding a normalized vector
    in the direction of the player and then adding that vector with a certain magnitude
    to the actor''s linear velocity:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将敌人角色移动到玩家身边涉及找到指向玩家的归一化向量，然后将该向量与一定大小的向量相加到角色的线性速度上：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also limit the velocity of each actor so they don''t go careening off in
    a direction too quickly:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还限制了每个角色的速度，以防止它们快速冲向一个方向：
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When all these methods are combined, we get a realistic flocking effect that
    works for a swarm of birds, bees, or even zombies.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当所有这些方法结合在一起时，我们得到一个逼真的群聚效果，适用于鸟群、蜜蜂，甚至僵尸。
- en: A* pathfinding on a grid
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格上的 A* 寻路
- en: A classic video game problem is that of pathfinding. Intelligent actors are
    often required to navigate around obstacles during gameplay. The **A* search algorithm**
    (also known as **A Star)** is commonly used to solve pathfinding by efficiently
    traversing a constructed node graph. In this recipe, we will demonstrate grid-based
    A* pathfinding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典视频游戏问题就是寻路问题。在游戏过程中，智能角色通常需要绕过障碍物进行导航。**A* 搜索算法**（也称为**A 星**）通常用于通过有效地遍历构建的节点图来解决寻路问题。在这个菜谱中，我们将演示基于网格的
    A* 寻路。
- en: '![A* pathfinding on a grid](img/4002_07_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![网格上的 A* 寻路](img/4002_07_05.jpg)'
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The A* algorithm uses a heuristic to perform a best-first search over a node
    graph. First, we must create this node graph.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法使用启发式方法在节点图上执行最佳优先搜索。首先，我们必须创建这个节点图。
- en: '`AStarNode:`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AStarNode:`'
- en: The node graph consists of a collection of nodes, each representing a real world
    position. This is encapsulated within the `AStarNode` class.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 节点图由一组节点组成，每个节点代表一个现实世界的位置。这被封装在 `AStarNode` 类中。
- en: 'Storing the nodes:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储节点：
- en: For this recipe, we store our nodes in a nested 2D `NSArray` structure. This
    is not required by the A* algorithm, but, merely a convention used to store the
    nodes. With this structure, we can quickly identify the closest `AStarNode` to
    a point. We can also link the nodes to each other in a simple, logical way.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将我们的节点存储在一个嵌套的 2D `NSArray` 结构中。这不是 A* 算法所必需的，而仅仅是一个用于存储节点的约定。有了这个结构，我们可以快速识别到点的最近
    `AStarNode`。我们还可以以简单、逻辑的方式将节点相互连接。
- en: 'Connecting the nodes:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接节点：
- en: Nodes are connected to each other by having each one maintain a list of its
    neighboring nodes. In this grid setup, each node links to eight other nodes in
    eight different directions. To remove diagonal movement, nodes would only be connected
    in four directions instead of eight.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过每个节点维护其相邻节点列表的方式将节点相互连接。在这个网格设置中，每个节点以八个不同方向链接到八个其他节点。为了移除对角线移动，节点将只在四个方向上连接而不是八个。
- en: 'Creating ''walls'':'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“墙壁”：
- en: In this recipe, darker colored 'walls' represent non-navigable areas. These
    nodes are simply set to `active = NO`. When the A* algorithm is run, they are
    skipped over.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，较暗色的“墙壁”代表不可导航的区域。这些节点简单地设置为 `active = NO`。当运行 A* 算法时，它们会被跳过。
- en: '`AStarPathNode:`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AStarPathNode:`'
- en: The data structure used to find and store the optimal path is a linked list
    of `AStarPathNode` objects. This class stores a node, the previous node, and a
    total estimated cost to the goal from this node.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于查找和存储最佳路径的数据结构是一个由 `AStarPathNode` 对象组成的链表。此类存储一个节点、前一个节点以及从该节点到目标的总估计成本。
- en: 'Finding the path:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找路径：
- en: 'Once our nodes are created and linked up, we call the following method to find
    a path:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们的节点创建并连接起来，我们就调用以下方法来寻找路径：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This performs a **greedy best-first** search for the best path. The greedy
    heuristic used is the simple absolute "as the crow flies" distance to the goal:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这执行了对最佳路径的贪婪最佳优先搜索。使用的贪婪启发式是简单的“鸟飞”距离到目标的绝对值：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Depending on assumptions relating to the construction of the node graph and
    how it relates to movement costs, other heuristics can be used. For example, a
    slight improvement might be to use the diagonal distance to the goal across the
    nodes instead of the absolute 2D space distance. If we disabled diagonal movement,
    then we would want to use the Manhattan heuristic to estimate movement cost on
    a grid.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据与节点图构建相关的假设以及它与移动成本的关系，可以使用其他启发式方法。例如，一个小的改进可能是使用节点到目标的斜边距离而不是绝对 2D 空间距离。如果我们禁用对角线移动，那么我们就会想使用曼哈顿启发式方法来估计网格上的移动成本。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `AStarNode` class contains a `costModifier` variable. This can be used to
    increase the relative cost to this specific node. A node with an increased movement
    cost could represent rough terrain like mud or shallow water. Other AI concepts
    could also be mixed into the pathfinding algorithm. For example, a specific area
    or group of nodes could be considered more dangerous than others. AI actors would
    then have to weigh speed versus danger when determining a path.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`AStarNode`类包含一个`costModifier`变量。这可以用来增加对这个特定节点的相对成本。一个增加移动成本的节点可以代表像泥地或浅水这样的崎岖地形。其他AI概念也可以混合到路径查找算法中。例如，一个特定的区域或节点组可能比其他区域或节点组更危险。AI演员在确定路径时必须权衡速度与危险。'
- en: A* pathfinding in a Box2D world
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Box2D世界中进行A*路径查找
- en: The real fun of the A* algorithm comes from applying it to more complex scenarios.
    In this recipe, we will apply the grid-based technique of the last recipe to a
    Box2D world filled with randomly generated polygons.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法的真正乐趣在于将其应用于更复杂的场景。在这个菜谱中，我们将将上一个菜谱的基于网格的技术应用于充满随机生成多边形的Box2D世界。
- en: '![A* pathfinding in a Box2D world](img/4002_07_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![在Box2D世界中的A*路径查找](img/4002_07_06.jpg)'
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like in the last recipe, we first create a 2D nested `NSArray` container
    for our `AStarNode` objects. After linking all the nodes together, we need to
    adjust the graph to accurately reflect the 2D geometry in the Box2D world.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个菜谱中一样，我们首先为我们的`AStarNode`对象创建一个2D嵌套`NSArray`容器。在将所有节点连接起来之后，我们需要调整图，以准确反映Box2D世界中的2D几何形状。
- en: 'Culling neighbor nodes:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除相邻节点：
- en: 'To properly represent 2D world geometry we need to cull edges of the node graph
    that lead into these static fixtures. To do this, we first find all nodes that
    are located inside a shape. This involves using the following method:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了正确表示2D世界几何形状，我们需要删除指向这些静态固定装置的节点图的边缘。为此，我们首先找到所有位于形状内部的节点。这涉及到使用以下方法：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will return whether or not that point exists within the shape. If so,
    we cut off all connections to this node. In addition to this, we also do ray cast
    tests for each neighbor connection:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将返回该点是否位于形状内。如果是，我们切断与此节点的所有连接。除了这个之外，我们还对每个相邻连接进行射线投射测试：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Four tests are performed for each connection. We do this to approximate the
    actor's circular shape. If this ray cast hits a fixture, we remove the connection.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接都会进行四次测试。我们这样做是为了近似演员的圆形形状。如果这个射线投射击中了一个固定装置，我们会移除这个连接。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This technique works well for a small level. However, generating a node graph
    for a large level can possibly be a very time consuming process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在小型关卡中效果很好。然而，为大型关卡生成节点图可能是一个非常耗时的过程。
- en: 'Speeding up load times:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加快加载时间：
- en: To decrease map load times, neighbor culling should be done by the level editor
    and the neighbor connections should be stored in the map file along with the nodes
    and the geometry. We do this at run time within our application to give you an
    idea of the process without having to create a Cocos2d level editor that implements
    this technique.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了减少地图加载时间，相邻节点的删除应由关卡编辑器完成，并且相邻连接应与节点和几何形状一起存储在地图文件中。我们在应用程序的运行时这样做，以给你一个过程的概念，而不必创建一个实现此技术的Cocos2d关卡编辑器。
- en: A* pathfinding on a TMX tilemap
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TMX瓦片地图上的A*路径查找
- en: If you've skipped ahead to [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and
    Ports"), *Tips, Tools, and Ports*, you'll see a recipe showing how to use the
    Tiled application with the TMX tilemap toolset. In this recipe, we create a 2.5D
    adventure game. To see our grid based pathfinding technique in action, we overload
    the [Chapter 8](ch08.html "Chapter 8. Tips, Tools, and Ports"), *Tips, Tools,
    and Ports* recipe entitled *Creating levels using Tiled*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跳到了[第8章](ch08.html "第8章。技巧、工具和端口")，*技巧、工具和端口*，你会看到一个菜谱，展示如何使用Tiled应用程序与TMX瓦片工具集。在这个菜谱中，我们创建了一个2.5D冒险游戏。为了看到我们的基于网格的路径查找技术在行动中的效果，我们重载了[第8章](ch08.html
    "第8章。技巧、工具和端口")，*技巧、工具和端口*的菜谱，名为*使用Tiled创建关卡*。
- en: '![A* pathfinding on a TMX tilemap](img/4002_07_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![在TMX瓦片地图上的A*路径查找](img/4002_07_07.jpg)'
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we can see our algorithm come to life with some nice animated
    AI character movement. We simply replace `nodeSpace` with `tileMap.tileSize.width/height`
    and replace `gridSizeX/Y` with `tileMap.mapSize.width/height`. Our character can
    now move around the forest and other obstacles.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以看到我们的算法通过一些漂亮的动画AI角色动作变得生动起来。我们只需将`nodeSpace`替换为`tileMap.tileSize.width/height`，并将`gridSizeX/Y`替换为`tileMap.mapSize.width/height`。现在我们的角色可以在森林和其他障碍物周围移动。
- en: A* pathfinding in a side-scroller
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在横版游戏中进行A*路径查找
- en: The A* algorithm is a generic node-graph traversal routine which can be applied
    to many abstract problems. In a 2D side-scroller, space is traversed in a complex,
    non-linear fashion. Actors are expected to run across platforms and jump from
    platform to platform. With some extra math, we can tailor our A* technique to
    this problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法是一种通用的节点图遍历程序，可以应用于许多抽象问题。在2D横版游戏中，空间以复杂、非线性的方式遍历。期望演员在平台上奔跑并从平台跳到平台。通过一些额外的数学计算，我们可以将我们的A*技术定制为解决这个问题。
- en: '![A* pathfinding in a side-scroller](img/4002_07_08.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![横版游戏中的A*路径查找](img/4002_07_08.jpg)'
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code listed as follows is heavily edited for the sake of brevity. Please
    refer to the project *RecipeCollection03* for full working code of this recipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码为了简洁而进行了大量编辑。请参考项目*RecipeCollection03*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we must create our node graph. In a top-down 2D environment, we simply
    use a grid and then cull out any colliding edges. In a side-scrolling environment,
    we need to think differently. Actors in such an environment must stand on top
    of the level geometry at all times. In addition to this, they have two different
    ways of traversing through the level: **running** and **jumping**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建我们的节点图。在俯视的2D环境中，我们只需使用网格，然后剔除任何碰撞的边。在横版环境中，我们需要有不同的思考方式。在这样的环境中，演员必须始终站在关卡几何形状的顶部。除此之外，他们还有两种不同的方式穿越关卡：**奔跑**和**跳跃**。
- en: 'Running across a platform:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在平台上奔跑：
- en: To allow an actor to run across a platform, we need to create a string of A*
    nodes on top of each platform. Starting at one of these nodes, the actor can easily
    move to the other nodes on that same body.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让演员能够在平台上奔跑，我们需要在每个平台上创建一串A*节点。从这些节点中的一个开始，演员可以轻松地移动到同一身体上的其他节点。
- en: 'Jumping from platform to platform:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从平台跳到平台：
- en: To reach another platform, the actor must jump there. This adds more complexity.
    We need to perform the calculations required to launch the actor safely to the
    other platform. We also need to check for geometry in the actor's jump trajectory
    and adjust the angle of the jump as necessary. Before we can implement this functionality,
    we need to encapsulate it in a new set of classes we create as sub-classes of
    our current ones.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要到达另一个平台，演员必须跳到那里。这增加了复杂性。我们需要执行将演员安全地发射到另一个平台所需的计算。我们还需要检查演员跳跃轨迹中的几何形状，并根据需要调整跳跃的角度。在我们可以实现这个功能之前，我们需要将其封装在我们创建的新类中，这些新类是我们当前类的子类。
- en: '`SSAStarNode:`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSAStarNode:`'
- en: The `SSAStarNode` contains references to a b2Body object as well as a `SSGameActor`
    object. The body object represents the body the actor is resting on when at this
    node. A reference to the actor is maintained because actor information such as
    size, jumping speed, and running speed are required to make some of the aformentioned
    calculations.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SSAStarNode`包含对b2Body对象的引用以及`SSGameActor`对象。当演员在这个节点上休息时，身体对象代表演员所在的身体。由于需要演员的大小、跳跃速度和奔跑速度等信息来执行一些上述计算，因此保留了演员的引用。'
- en: '`SSGameWaypoint:`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSGameWaypoint:`'
- en: Our new waypoint class contains a `moveType` enumeration that specifies whether
    or not the actor should RUN or JUMP to the waypoint's location. It also contains
    a `launchVector` that specifies the impulse vector required if a jump is to be
    performed.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的新航点类包含一个`moveType`枚举，用于指定演员是否应该向航点的位置**奔跑**或**跳跃**。它还包含一个`launchVector`，用于指定如果需要跳跃，所需的冲量向量。
- en: '`SSGameActor:`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSGameActor:`'
- en: 'The new actor class has a `maxSpeed` variable that determines both how fast
    the actor can run and how high the actor can jump. This class also encapsulates
    our newly modified `processWaypoints` method as well as a few others:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的演员类有一个`maxSpeed`变量，它决定了演员可以跑多快以及可以跳多高。此类还封装了我们新修改的`processWaypoints`方法以及其他几个方法：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `runToWaypoint` method simply sets the actor's velocity to make it run left
    or right. The `jumpToWaypoint` method launches the actor using the waypoint's
    `launchVector`. The `canJumpFrom` method determines whether or not a jump is possible
    to a certain point. This involves testing multiple jump angles against the geometry
    of the Box2D world. Each jump parabola is broken up into 10 straight-line sections
    that are ray tested against map geometry. This approximates collision detection
    well enough for our purposes. Finally, the getLaunchVector method, which is employed
    by the `canJumpFrom` method, determines the `launchVector` for the actor given
    a location to land on and given a Y jump height relative to the X jump width.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`runToWaypoint`方法简单地设置演员的速度，使其向左或向右跑。`jumpToWaypoint`方法使用航点的`launchVector`发射演员。`canJumpFrom`方法确定是否可以跳到某个特定点。这涉及到对Box2D世界的几何形状进行多次跳跃角度测试。每个跳跃抛物线被分成10个直线段，这些直线段被射向地图几何形状进行测试。这足以满足我们的碰撞检测需求。最后，`getLaunchVector`方法，它被`canJumpFrom`方法使用，根据着陆点和相对于X跳跃宽度的Y跳跃高度确定演员的`launchVector`。'
- en: '`SSAStarPathNode:`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSAStarPathNode:`'
- en: This class is similar to `AStarPathNode`. It contains a `SSGameWaypoint` pointer
    for convenience. In the updated `findPathFrom` method, we create this waypoint
    and set its `launchVector`. This ensures that `launchVector` is only calculated
    at load time.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类与`AStarPathNode`类似。它包含一个`SSGameWaypoint`指针以方便使用。在更新的`findPathFrom`方法中，我们创建这个航点并设置其`launchVector`。这确保了`launchVector`只在加载时计算。
- en: '`SSNeighborNode:`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSNeighborNode:`'
- en: As now we have two methods of moving from one node to another, we need a more
    complex way of storing graph edge information. Instead of simply storing a pointer
    to a neighboring node, this class encapsulates that node along with a `moveType,
    cost,` and `launchVector`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们现在有两种从节点到节点移动的方法，我们需要一种更复杂的方式来存储图边信息。而不是简单地存储指向相邻节点的指针，这个类封装了该节点以及`moveType`、`cost`和`launchVector`。
- en: 'Creating our node graph—run nodes:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的节点图—运行节点：
- en: First we must create our key nodes. These are like keyframes in an animation.
    They are located slightly above each vertex on the top side of every platform.
    We then add nodes in-between these nodes. Finally, these "run nodes" are linked
    together with the moveType variable set to `MOVE_TYPE_RUN`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们必须创建我们的关键节点。这些就像动画中的关键帧。它们位于每个平台顶部的每个顶点略微上方。然后我们在这些节点之间添加节点。最后，这些“运行节点”通过设置`moveType`变量为`MOVE_TYPE_RUN`相互连接。
- en: 'Creating our node graph—jump nodes:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的节点图—跳跃节点：
- en: Once the run nodes are set over each platform, we create jump nodes. This involves
    searching the immediate area around each node, determining whether or not the
    actor can jump from that node to a found node, and then finally creating the neighbor
    link. We create these links one at a time as jumping up to reach a node is very
    different from jumping down.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦在每个平台上设置了运行节点，我们就创建跳跃节点。这涉及到在每个节点周围搜索，确定演员是否可以从该节点跳到找到的节点，然后最终创建相邻链接。我们逐个创建这些链接，因为向上跳跃到达节点与向下跳跃非常不同。
- en: 'Tweaking side-scrolling pathfinding:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整侧滚路径查找：
- en: This technique required a lot of tweaking to get working properly. For example,
    the X and Y distance thresholds, used to determine whether or not a waypoint has
    been reached, vary greatly. Another tweak involves the fact that, if a waypoint
    is blocked, the entire set of waypoints must be discarded. Perhaps another revision
    could salvage the second half of the path of nodes by prepending a new path to
    the missed node.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术需要大量调整才能正常工作。例如，用于确定是否到达航点的X和Y距离阈值差异很大。另一个调整涉及到，如果航点被阻挡，整个航点集必须被丢弃。也许另一个版本可以通过在错过节点前添加新路径来挽救节点路径的第二部分。
- en: Running a Lua script
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Lua脚本
- en: Many commercial games make use of a **scripting language** to isolate and abstract
    their **game logic**. The most popular of these is **Lua**. In this recipe, we
    will integrate Lua into our project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业游戏都使用一种**脚本语言**来隔离和抽象它们的**游戏逻辑**。其中最受欢迎的是**Lua**。在本教程中，我们将Lua集成到我们的项目中。
- en: '![Running a Lua script](img/4002_07_09.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![运行Lua脚本](img/4002_07_09.jpg)'
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection03*以获取此教程的完整工作代码。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Lua can be added to your project in a few simple steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过几个简单的步骤将Lua添加到您的项目中：
- en: Highlight your project in the Navigator. At the bottom of your window in the
    middle, click **Add Target:**![How to do it...](img/4002_07_10.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航器中突出显示你的项目。在窗口中间的底部，点击 **Add Target:**![如何操作...](img/4002_07_10.jpg)
- en: Name the target "Lua". This will create a new folder inside your project folder
    next to your main target's similarly named folder. It should also create a new
    group.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标命名为 "Lua"。这将在你的项目文件夹中创建一个新文件夹，紧挨着你的主要目标文件夹。它还应创建一个新的组。
- en: Download the Lua source from [http://www.lua.org](http://www.lua.org) and copy
    it to this folder.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://www.lua.org](http://www.lua.org) 下载 Lua 源代码并将其复制到该文件夹。
- en: Right-click the **Lua** group and select **Add Files to "Your**![How to do it...](img/4002_07_11.jpg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 **Lua** 组并选择 **Add Files to "Your**![如何操作...](img/4002_07_11.jpg)
- en: Navigate to the `src` directory and add all the files located there except for
    `lua.c, luac.c, Makefile`, and `print.c`. Also, be sure to uncheck **Copy items
    into destination groups folder** and select only **Lua** under the **Add to Targets**
    section.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `src` 目录并添加该目录下所有文件，除了 `lua.c, luac.c, Makefile` 和 `print.c`。同时，确保取消选中 **Copy
    items into destination groups folder** 并在 **Add to Targets** 部分只选择 **Lua**。
- en: At this point, you should be able to build the Lua target with no errors.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够无错误地构建 Lua 目标。
- en: In the middle pane, click your project's main target. Expand **Link Binary With
    Libraries**. Click the **+** symbol at the bottom-left and add the **libLua.a**
    library to the list:![How to do it...](img/4002_07_12.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间面板中，点击你的项目的主要目标。展开 **Link Binary With Libraries**。点击左下角的 **+** 符号并将 **libLua.a**
    库添加到列表中：![如何操作...](img/4002_07_12.jpg)
- en: Collapse this and expand **Target Dependencies**. Add the target **Lua** as
    a dependency of this target:![How to do it...](img/4002_07_13.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收起此内容并展开 **Target Dependencies**。将目标 **Lua** 添加为此目标的依赖项：![如何操作...](img/4002_07_13.jpg)
- en: That's it. Lua is now integrated. Clean and build your project to make sure
    it was integrated properly.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。Lua 现已集成。清理并构建你的项目以确保其正确集成。
- en: 'Execute the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This and subsequent recipes use Robert Grzesek's `mcLua` API to facilitate the
    loading and execution of Lua scripts. It also allows for concurrent execution
    of multiple scripts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些和随后的食谱使用 Robert Grzesek 的 `mcLua` API 来简化 Lua 脚本的加载和执行。它还允许多个脚本的并发执行。
- en: 'The `mcLuaManager` class:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mcLuaManager` 类：'
- en: 'The `mcLuaManager` class is the top-level class that manages all running scripts:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mcLuaManager` 类是管理所有运行脚本的顶级类：'
- en: '[PRE25]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is in charge of running the scripts as well as their creation and destruction.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它负责运行脚本以及它们的创建和销毁。
- en: 'Loading and starting a script:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载并启动脚本：
- en: 'Loading a Lua script is a fairly straightforward process:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加载 Lua 脚本是一个相当直接的过程：
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the file is loaded, we make a call to the `mcLuaManager` class''s `Update`
    method:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦文件加载，我们调用 `mcLuaManager` 类的 `Update` 方法：
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This starts the loaded scripts off and running.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将启动已加载的脚本并运行。
- en: 'Static function libraries:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态函数库：
- en: 'Inside the Lua script, global methods can be called according to function libraries
    assigned to object identifiers. The mcLua API assigns a few functions to the script
    object by default. These include `waitSeconds, waitFrames`, and `pause`. They
    can be called inside the Lua script:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Lua 脚本中，可以根据分配给对象标识符的函数库调用全局方法。mcLua API 默认将一些函数分配给脚本对象。这些包括 `waitSeconds,
    waitFrames` 和 `pause`。它们可以在 Lua 脚本内部调用：
- en: '[PRE28]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we also create a callback method named `appendMessage` and
    assign it to an object named `scene`. To do this, we first create a static C function:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还创建了一个名为 `appendMessage` 的回调方法并将其分配给名为 `scene` 的对象。为此，我们首先创建一个静态 C
    函数：
- en: '[PRE29]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the recipe is loaded, we create a Lua script library linker array and
    load it into memory using the `LuaOpenLibrary` provided by the `mcLua` API:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当食谱加载时，我们创建一个 Lua 脚本库链接器数组并将其使用 `mcLua` API 提供的 `LuaOpenLibrary` 加载到内存中：
- en: '[PRE30]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once this is loaded, we can call that function from the Lua script itself:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦加载，我们就可以从 Lua 脚本本身调用该函数：
- en: '[PRE31]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, if the script is paused (from inside or outside the script itself)
    it can be resumed (only from outside the script):'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果脚本被暂停（从脚本内部或外部）它可以从外部脚本恢复：
- en: '[PRE32]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Together this library lets your Lua script interact with your application.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一起，这个库允许你的 Lua 脚本与你的应用程序交互。
- en: Dynamically loading Lua scripts
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载 Lua 脚本
- en: Part of the power of a scripting language like Lua, is that scripts can be loaded
    and re-loaded at **run-time**. This means you can test your game logic without
    having to re-compile your Objective-C++ code. In this recipe, we will load a remote
    script from a local **web server**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 Lua 这样的脚本语言的强大之处在于，脚本可以在 **运行时** 加载和重新加载。这意味着您可以在不重新编译 Objective-C++ 代码的情况下测试您的游戏逻辑。在这个菜谱中，我们将从本地
    **Web 服务器** 加载远程脚本。
- en: '![Dynamically loading Lua scripts](img/4002_07_14.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![动态加载 Lua 脚本](img/4002_07_14.jpg)'
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The simplest way to load a remote script is to use a local web server. This
    way we can bypass `NSBundle` and the somewhat restricted iOS filesystem. Mac OSX
    ships with a built-in Apache HTTP webserver. It can be enabled and configured
    by going to **System Preferences** | **Internet and Wireless** | **Sharing** |
    **Web Sharing:**
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 加载远程脚本最简单的方法是使用本地 Web 服务器。这样我们就可以绕过 `NSBundle` 和相对受限的 iOS 文件系统。Mac OSX 预装了内置的
    Apache HTTP Web 服务器。可以通过转到 **系统偏好设置** | **互联网和无线** | **共享** | **Web 共享**：来启用和配置它。
- en: 'Loading a remote script:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载远程脚本：
- en: 'Instead of reading our script off the filesystem, we load it over HTTP using
    `NSURL`:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不是从文件系统中读取我们的脚本，而是使用 `NSURL` 通过 HTTP 加载它：
- en: '[PRE34]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Editing the file on your local web server and hitting the re-load button simply
    loads the script again. This is a simple but effective way to rapidly develop
    and test game logic.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在您的本地 Web 服务器上编辑文件并点击重新加载按钮只是重新加载脚本。这是一种简单但有效的方法，可以快速开发和测试游戏逻辑。
- en: 'Reachability:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reachability：
- en: In this example, we use Apple's Reachability library to help us determine whether
    or not we can access the script over the network. Without this tool our `stringWithContentsOfURL`
    method would throw errors.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用苹果的 Reachability 库来帮助我们确定是否可以通过网络访问脚本。没有这个工具，我们的 `stringWithContentsOfURL`
    方法会抛出错误。
- en: Using Lua for dialogue trees
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lua 创建对话树
- en: Lua lets the programmer write against a generic **interface** and worry about
    the **implementation** later. This separation between game logic, and the nuts
    and bolts of presenting the audio/visual elements of the game, is an important
    part of any game engine. In this recipe, we will use Lua to create a small story-based
    adventure game.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 允许程序员编写针对通用 **接口** 的代码，并稍后关注 **实现**。这种将游戏逻辑与游戏音频/视觉元素展示的细节分开，是任何游戏引擎的重要部分。在这个菜谱中，我们将使用
    Lua 创建一个小型的基于故事的游戏。
- en: '![Using Lua for dialogue trees](img/4002_07_15.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Lua 创建对话树](img/4002_07_15.jpg)'
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection03* for full working code of this
    recipe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection03* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For this recipe, we create a number of callback functions to process animation,
    dialog, and logic. Some of these, like option prompts, wait for user response
    before the script is resumed. Other functions, like `ldtLogic`, have a return
    value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们创建了一些回调函数来处理动画、对话框和逻辑。其中一些，如选项提示，在脚本恢复之前等待用户响应。其他函数，如 `ldtLogic`，有返回值。
- en: 'Passing and returning variables using Lua:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lua 传递和返回变量：
- en: 'Lua''s variable passing mechanism is fairly simple. Functions are passed a
    lua_State pointer. Data can then be retrieved off of the stack pointed to by this:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Lua 的变量传递机制相当简单。函数传递一个 lua_State 指针。然后可以从这个指针指向的堆栈中检索数据：
- en: '[PRE36]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lua supports multiple return variables at one time. To return a variable from
    one of our callback functions, we must first push the variable onto the stack:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Lua 支持同时返回多个变量。要从我们的回调函数中返回一个变量，我们必须首先将变量推入堆栈：
- en: '[PRE37]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then specify the number of variables we are returning as an integer:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们指定要返回的变量数量作为一个整数：
- en: '[PRE38]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All basic C types can be passed and returned using Lua.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有基本的 C 类型都可以使用 Lua 传递和返回。
- en: 'Local Lua functions:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地 Lua 函数：
- en: Inside of our script file we use a number of local Lua functions. Everything
    is encapsulated in a function except for the initial `start()` function call.
    Local functions also support returning multiple
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的脚本文件中，我们使用了多个本地 Lua 函数。除了最初的 `start()` 函数调用外，所有内容都被封装在函数中。本地函数也支持返回多个
