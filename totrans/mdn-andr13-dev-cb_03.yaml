- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling the UI State in Jetpack Compose and Using Hilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Android applications display the state to users, which helps inform users
    on what the outcome is and when. The **state** in an Android application is any
    value that changes over time, and a good example is a toast that shows a message
    when there is an error. In this chapter, readers will learn how to handle the
    UI state better with the new Jetpack library.
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say with great power comes great responsibility, and managing
    the state of any Composable component requires a distinct approach compared to
    using the older way of building Android views, or as many might call it, the imperative
    way. This means Jetpack’s library, Compose, is entirely different from XML layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the UI state in the XML **View System** is very straightforward. The
    process entails setting the properties of the views to reflect the current state
    – that is, showing or hiding the views accordingly. For instance, when loading
    data from an API, you can hide the loading view, show the content view, and populate
    it with the desired views.
  prefs: []
  type: TYPE_NORMAL
- en: In Compose, however, it is impossible to change a Composable component once
    the application has drawn it. You can, however, change the values passed to each
    Composable by changing the state each Composable receives. Hence, learning about
    managing the state better when building robust Android applications will be handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing **Dependency Injection** (**DI**) with Jetpack Hilt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `ViewModel` classes and understanding the state in Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Compose in existing an XML layout-based project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and handling recomposition in Jetpack Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing UI tests for your Compose views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for your `ViewModel` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DI with Jetpack Hilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, DI is vital. Some people use it, and some prefer
    not to use it for their own reasons. However, DI is the practice of designing
    objects in a manner where they receive instances of the object from other pieces
    of code instead of constructing them internally.
  prefs: []
  type: TYPE_NORMAL
- en: If you know of the SOLID principles, you know their primary goal is to make
    software design easier to maintain, read, test, and build upon. In addition, DI
    helps us follow some of the SOLID principles. The dependency inversion principle
    allows the code base to be easily expanded and extended with new functionalities
    and improves reusability. In Modern Android Development, DI is essential, and
    we will implement it in our application in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of libraries that you can use in Android for DI, such
    as Koin, Dagger, and Hilt; Hilt harnesses the power of Dagger and benefits from
    compile-time correctness, good runtime performance, Android studio support, and
    scalability. For this recipe, we will use Hilt, which provides containers for
    every Android class in our project and automatically manages their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in previous recipes, we will use the project we have used in previous
    recipes to add DI.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hilt uses Java features; make sure your project is in the `app/build.gradle`,
    and you have the following compile options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is already added automatically, but make sure you check that you have
    it just in case. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must add the `Hilt-android-gradle-plugin` plugin into our project’s
    root file, `build.gradle(Project:SampleLogin)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in our `app/build.gradle` file, add these dependencies, and sync the
    project. It should run without any issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s go ahead and add the `Application` class. All apps that use Hilt
    must have an `Application` class annotated with `@HiltAndroidApp`, and we need
    to call the `Application` class that we create in `Manifest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `Manifest` folder, let’s add `LoginApp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the setup done, we need to start working with Hilt by adding
    the required annotations to our class. In `MainActivity.kt`, we need to add the
    `@``AndroidEntryPoint` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s go ahead and display what we did by running the `./gradlew :app:dependencies`
    command, and we will see something similar to *Figure 3**.1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Dagger Hilt dependency tree](img/Figure_3.4_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Dagger Hilt dependency tree
  prefs: []
  type: TYPE_NORMAL
- en: You can also view the dependency in Android Studio. That is by clicking on the
    **Gradle** tab on the right-hand side and selecting **expand:yourmodule** | **Tasks**
    | **android**. Then, finally, double-click on **androidDependencies** to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, compile and run the project; it should run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@HiltAndroidApp` triggers Hilt’s code generation, including a base class for
    our application, which acts as the application-level dependency container. The
    `@AndroidEntryPoint` annotation adds a DI container to the Android class annotated
    with it. When using Hilt, the generated Hilt component is attached to the Application
    object’s life cycle and provides its dependencies. Hilt currently supports the
    following Android classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` annotated as `@HiltViewModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application` annotated as `@HiltAndroidApp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Activity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fragment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BroadcastReceiver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use other necessary annotations in Hilt later, for instance, the `@Module`
    annotation, `@InstallIn`, and `@Provides`. The `@Module` annotation means the
    class in which you can add binding for types that cannot be injected in the constructor.
    `@InstallIn` indicates which Hilt-generated DI container (or singleton component)
    has to be available in the code module binding.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `@Provides` binds a type that cannot be constructor injected. Its return
    type is the binding type, it can take dependency parameters, and every time you
    need an instance, the function body is executed if the type is not scoped.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ViewModel classes and understanding the state in Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, a `ViewModel` is a class responsible for consciously managing the
    UI-related data life cycle. There is also a lot of debate in the community about
    whether developers should use `ViewModel` in Compose or not. However, Manuel Vivo,
    a senior Android developer relations engineer at Google, says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“I’d include them if their benefits apply to your app. No need to use them
    if you handle all configuration changes yourself and don’t use Navigation Compose.
    Otherwise, use ViewModels not to reinvent* *the wheel.”*'
  prefs: []
  type: TYPE_NORMAL
- en: '*“On the other hand, the debate as to why one should not use ViewModels is
    based on the argument that in pure Compose, since Compose handles configuration
    changes, having your Composable functions reference the ViewModel* *is unnecessary.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also refer to this tweet by Jim Sproch: [https://twitter.com/JimSproch/status/1397169679647444993](https://twitter.com/JimSproch/status/1397169679647444993).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more info about the benefits of using the ViewModel here: [https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth](https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth).'
  prefs: []
  type: TYPE_NORMAL
- en: This means using `ViewModel` to handle the state in your application will be
    a question of personal choice with Jetpack Compose. The currently recommended
    architecture pattern in Android is **Model-View-View-Model** (**MVVM**), and many
    applications use it.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose uses a unidirectional data flow design pattern; this means the
    data or state only streams down while the events stream up. Hence, a clear understanding
    of how we can utilize the unidirectional pattern to make our code more readable,
    maintainable, and testable as much as possible using the `ViewModel` class will
    be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, `ViewModel` is suitable for providing your application with access
    to business logic, preparing the data for presentation on the screen, and making
    your code testable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will work with a pre-built skeleton `SampleLogin` project,
    which you can download from the *Technical requirements* section. We will use
    Hilt in this recipe since the project uses Hilt, but we will explain Hilt in a
    next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now create a `ViewModel` class and modify most of the code in the
    `LoginContent` Kotlin file:'
  prefs: []
  type: TYPE_NORMAL
- en: To keep our classes and files well organized, let’s go ahead and first create
    a package to hold our UI and view models. Navigate to the main `Package` folder,
    right-click to open a prompt, then go down to **Package**, and a dialog with a
    package name will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – How to create a package](img/Figure_3.1_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – How to create a package
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the package `Login`; inside `LoginContent` file and add the new class,
    `LoginViewModel`, there. Go ahead and create a `ViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created a `LoginViewModel` class, we need to add a DI annotation
    of `HiltViewModel` and ensure we extend the `ViewModel` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `ViewModel` constructor, we will need to add `stateHandle: SavedStateHandle`,
    which will help us maintain and retrieve objects to and from the saved state.
    These values persist even after the system kills the process and remain available
    through the same object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we build our `ViewModel`, let’s go ahead and create a data class, `AuthenticationState()`.
    This class will come in handy during our testing since we need to be able to test
    most of our validation cases. A `View` state class, plus having a single source
    of truth, has many advantages and is one of the principles of **Model-View-Intent**
    (**MVI**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s go ahead and create a helper class, `MutableSavedState<T>()`, which
    will take in `savedStateHandle`, a key, and a default value. This class acts as
    a `MutableStateFlow()` but saves the data and value and retrieves it upon the
    application’s death with the help of `SavedStateHandle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s go ahead and create callbacks that will be invoked when a user enters
    their username and password in our `LoginViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and do the same for password and password toggle visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to create a `combineFlows` helper class. You can combine more
    than two flows in Kotlin; a coroutine `flow` is a type that emits multiple values
    sequentially, as opposed to the `suspend` function, which returns a single value.
    More details on how to combine flows can be found at `combine(flow1`, `flow2`,
    `flow3`, `flow4) {t1, t2, t3, t4 ->` `resultMapper}.stateIn(scope)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read more here – [https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows](https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go ahead and create our helper class for using coroutines and call
    it `SampleLoginDispatchers()`; it will help us in testing our code and ensuring
    our code is easily readable. In addition, we use coroutine dispatchers that help
    determine what thread the corresponding coroutine should use for execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SharedFlow` represents a read-only state with a single updatable data value,
    which emits any updates to its collectors. On the other hand, a state flow is
    a hot flow because its active instance exists independently of the presence of
    collectors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SharingStarted` coroutine flow operator in Android is used to share the
    execution of a flow among multiple collectors. It is commonly used to create a
    “hot” flow, which means that the flow starts emitting data as soon as it is created,
    and the data is shared among all the active collectors of the flow. These can
    be back-to-back emissions of the same command and have no effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are four types of dispatchers. In our example, we will only use three.
    In addition, you can inject a single dispatcher and achieve the same result without
    the class; hence, this can be preference-based. See how it works for the four
    types of dispatchers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have created our helper class, we must provide the dispatcher via
    DI. We have an entire recipe dedicated to Hilt, so we will look at the concepts
    and what the annotations mean in the Hilt recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new package and call the package `di`. In this package, create a new
    object and call it `AppModule`; we will provide our dispatcher to the `ViewModel`
    constructor via the dependency graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now need to go to `LoginContent` and modify the code – that is, by
    adding callbacks that will correspond to our `ViewModel`, and whenever we have
    a view – for example, `UserNameField()` – we will use the callback. See the sample
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in our `LoginContentScreen` Composable function, we will pass our `LoginViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in `MainActivity`, we can now go ahead and call `LoginContentScreen`,
    pass in our `ViewModel`, and also specify what action we want when the user clicks
    `onRegister`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the entire code, please ensure you check out the link in the *Technical*
    *requirements* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.3 – Error state display when we enter\uFEFF a special character\
    \ !](img/Figure_3.2_B18827.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Error state display when we enter a special character !
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jetpack Compose uses a unidirectional data flow design pattern. This means the
    data or state only streams down while the events stream up, as shown in *Figure
    3**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A unidirectional data flow](img/Figure_3.3_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A unidirectional data flow
  prefs: []
  type: TYPE_NORMAL
- en: That is to say, Composable functions receive the state and then display it on
    the screen. On the other hand, an event can cause the state to need to be updated
    and come from either a Composable or any other part of your application. Furthermore,
    whatever handles the state, in our case, `ViewModel`, receives the event and adjusts
    the state for us.
  prefs: []
  type: TYPE_NORMAL
- en: We also use coroutines, which are nothing but lightweight threads, and they
    help us handle synchronous and asynchronous programming easily. Furthermore, coroutines
    allow execution to be suspended and resumed later. The main advantages are that
    they are lightweight, have built-in cancellation support, have lower chances of
    memory leaks, and the Jetpack libraries provide coroutine support.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of dispatchers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Main` dispatcher executes in the main thread, which is usually used when your
    application needs to perform some UI operations within a coroutine. This is because
    the UI can only be changed from the main thread. Another name for the main thread
    is the UI thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IO` dispatcher starts the coroutine in the I/O thread; I/O simply means input
    and output in programming. This is also used to perform all data work, such as
    networking, reading, or writing from the database. You can simply say fetching
    data from the I/O operation is done in the I/O thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default` dispatcher starts in the default state. Your application can utilize
    this if you plan on doing complex long-running calculations, which can block the
    UI/main thread and make your UI freeze or cause an `GlobalScope`, and you can
    use it by simply calling `GlobalScope.launch{...}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unconfined`, as the name suggests, is a dispatcher not confined to any specific
    thread. This executes the dispatcher to perform its work in a current call frame
    and lets the coroutine resume whatever threads that are used by the corresponding
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot was covered in this chapter, and it is fair to acknowledge that just
    this simple recipe cannot explain `ViewModel` in its entirety. To find out more,
    see the following link: [https://developer.android.com/topic/libraries/architecture/viewmodel](https://developer.android.com/topic/libraries/architecture/viewmodel).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Compose in an existing XML layout-based project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Compose is a new UI framework, many code bases still rely heavily on XML
    layouts. However, many companies are opting to build new screens using Compose,
    and this is achievable by utilizing existing XML layouts and adding unique views
    using `ComposeView` XML tags. This recipe will look into adding a Compose view
    to an XML layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we can create a new project or opt to use an existing project
    that does not heavily rely on Compose. We will try to display `GreetingDialog`
    and use an XML layout to show how we can use the `ComposeView` tag in XML layouts.
    If you already have a project, you do not need to set this up; you can skip to
    *step 4* in the preceding *How to do* *it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let us go ahead and explore how we can utilize existing XML layouts with
    Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new project or using a preexisting one; if you create
    a new activity that is not Compose, you can use `EmptyActivity`, and give it any
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you already have a project set up, you can skip this step. If you opt to
    create a new project, you will have `MainActivity`, and since this is the old
    way of creating views, you will notice an XML layout in the `resource` folder
    with a TextView that has `Hello world`. We can go ahead and remove that since
    we will not use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you already have a project ready, you can launch `GreetingDialog` on any
    screen you want. Also, if you opt to create a button instead of a dialog, that
    is fine, too since the idea is to showcase how we can use XML tags in Jetpack
    Compose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let us go ahead and add an XML tag inside `activity_main.xml` and give
    our Compose view an `id` value. The first time you add `ComposeView`, you will
    see an error message if you still need to add the dependency. Go ahead and click
    **Add dependency on android.compose.ui:ui** and the project will sync as shown
    in *Figure 3**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A Compose view in XML](img/Figure_3.5_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A Compose view in XML
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have synced your project, the error will disappear, and you should
    be able to use this view in `MainActivity`, or where you want to use `ComposeView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also add `viewBinding` to our `build.gradle(Module:app)` so that we can
    easily access our view in `MainActivity`. Also, if you already have `viewBinding`
    set up, you can skip this part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have synced the project, we can go ahead and, in `MainActivity`, access
    `ComposeView` through binding. Furthermore, it will have a `setContent{}` method
    where you can set all your Composables and wrap it into your Theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `GreetingAlertDialog()` will have an `AlertDialog()` Composable, a title,
    and text, which will provide our message as a simple text element. The title will
    say `Hello` since this is a greeting, and the message will be `Hello, and thank
    you for being part of the Android community`. You can customize this to fit your
    needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To create Compose components, you will need to add the Compose Material Design
    dependency to your gradle app. Depending on what your application supports, you
    can utilize Compose Material 3 components, which is the next evolution of Material
    Design and comes with updated theming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can easily customize features such as dynamic color and more. We look into
    Material 3 in [*Chapter 11*](B18827_11.xhtml#_idTextAnchor619), *GUI Alerts –
    What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern Android Development*.
    Hence, for now, since the application that I am using has not migrated to Material
    3, I will use this import – `implementation "androidx.Compose.material:material:1.x.x"`.
    Here, you can use any import that fits your need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also create a custom view that extends from `AbstractComposeView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, when you run your application, you should have a dialog that has a
    title and text; *Figure 3**.6* shows a dialog from an already pre-existing project,
    so this will definitely vary based on what steps you took:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Dialog Compose view in XML](img/Figure_3.6_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Dialog Compose view in XML
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we inflate the XML layout, which we define in our layout `resource` folder.
    Then, using binding, we got `ComposeView` using the created XML ID, set a Compose
    strategy that works best for our host view, and called `setContent` to use Compose.
    In your activity, to be able to create any Compose-based screen, you have to ensure
    that you call the `setContent{}` method and pass whatever Composable function
    you have created.
  prefs: []
  type: TYPE_NORMAL
- en: To further explore the `setContent` method, it is written as an extension function
    of `ComponentActivity`, and it expects a Composable function as the last parameter.
    There is also a better way to demonstrate how `setContent{}` works to integrate
    a Composable tree into your Android application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – This happens when you call setContent{}](img/Figure_3.7_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – This happens when you call setContent{}
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewCompositionStrategy` helps determines when to dispose of the composition;
    hence, Compose UI views such as `ComposeView` and the `AbstractComposeView` use
    `ViewCompositonStrategy`, which helps define this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more by following this link to learn more about the interoperability
    APIs: [https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy](https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and handling recomposition in Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jetpack Compose is still very new, and many companies are starting to use it.
    Furthermore, Google has done a great job by giving developers significant documentation
    to help them embrace this new UI toolkit. However, despite all the documentation,
    one concept needs to be clarified. And that is recomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Fair enough, all new software has its ups and downs, and as many people start
    using it, more people start giving feedback – hence, the need for more improvement.
    Recomposition, in Compose, involves calling your Composable again when the input
    changes. Or you can think of it when the composition structure and relation change.
  prefs: []
  type: TYPE_NORMAL
- en: Unless its parameters change, we want to avoid a Composable function being re-invoked
    in most use cases. So, in this recipe, we look into how recomposition happens
    and how you can debug and solve any recomposition in your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since our view system is simple, we will be checking whether we have any recomposition
    in our `Login` project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at a simple example and how recomposition will occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our given example, the `Text` function will recompose when `name` changes
    and not when `gender` changes. In addition, the `gender:String` input value will
    recompose only when `gender` changes.
  prefs: []
  type: TYPE_NORMAL
- en: You can also launch and utilize `LoginContent` and see whether we have any recomposition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Layout Inspector](img/Figure_3.8_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Layout Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch **Layout Inspector**, you need to ensure you have your emulator
    hooked to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Linking the inspector](img/Figure_3.9_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Linking the inspector
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and expand the `SampleLoginTheme` entry point, and you will notice
    our current view system is not complex. As you can see, **Layout Inspector** does
    not show any recomposition counts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is to say, if our application had any recomposition counts, they would
    show up in **Layout Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The component tree](img/Figure_3.10_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The component tree
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as you have seen, our application does not have any recomposition happening,
    but it is always beneficial to check your application to know what might be causing
    the recomposition and fix it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Using side-effects might lead to users of your application experiencing strange
    and unpredictable behavior in your app. In addition, a side-effect is any change
    that is visible to the rest of your application. For instance, writing to a property
    of a shared object, updating an observable in `ViewModel`, and updating shared
    preferences are all dangerous side effects.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For adaptability, Compose skips `lambda` calls or any child function that does
    not have any changes to its input. This better handling of resources makes sense
    since, in Compose, animations and other UI elements can trigger recomposition
    in every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go in depth and use a diagram to showcase how the Jetpack composition
    life cycle works. In short, the life cycle of a Composable function is defined
    by three significant events:'
  prefs: []
  type: TYPE_NORMAL
- en: Being composed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting recomposed or not getting recomposed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No longer being composed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The composition life cycle of a Composable](img/Figure_3.11_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The composition life cycle of a Composable
  prefs: []
  type: TYPE_NORMAL
- en: To fathom how Compose works, it’s good to know what constitutes the Compose
    architectural layer. A high-level overview of the Jetpack Compose architectural
    layer includes **Material**, **Foundation**, **UI**, and **Runtime** aspects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers](img/Figure_3.12_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers
  prefs: []
  type: TYPE_NORMAL
- en: In **Material**, this module implements the Material Design system for the Compose
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it provides a theming system, styled components, and more. `Row`,
    `Column`, and more. The **UI** layer is made of multiple modules that implement
    the fundamentals of the UI toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Compose team is launching Jetpack Compose Composition Tracing, the first
    alpha that will help developers trace their composition easily; you can read more
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535](https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.android.com/jetpack/compose/lifecycle](https://developer.android.com/jetpack/compose/lifecycle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing UI tests for your Compose views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is essential to test your code when developing Android applications, especially
    if your applications have many users. Furthermore, when you write tests for your
    code, you basically verify the functions, behavior, correctness, and versatility
    of the Android application. The most popular UI testing tools in Android are Espresso,
    UI Automator, Calabash, and Detox.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, however, we will use Espresso. The most notable advantages of
    Espresso are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has highly stable test cycles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports JUnit 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is made purely for Android UI testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is suitable for writing black-box tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports testing activities outside the application as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have completed previous recipes to follow along with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the other recipes in this chapter, we will use the new project we created
    in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014), *Getting Started with Modern
    Android* *Development Skills*:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and navigate into the `androidTest` package in our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by creating a new class in the `androidTest` package and call it `LoginContentTest.kt`.
    In Jetpack Compose, testing is made more accessible, and we need to have unique
    tags for our views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, for this step, let’s go back to our main package (`com.name.SampleLogin`)
    and create a new package and call it `util`. Inside `util`, let’s create a new
    class and call it `TestTags`, which will be an object. Here, we will have another
    object, name it `LoginContent`, and create constant values that we can call in
    our view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created the test tags, let’s go back to our `LoginContent`
    and add them to all views in the `Modifier()` so that when we test, it is easier
    to identify the view using the test tag we have added. See the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside our `LoginCotentTest` class, let’s now go ahead and set up our testing
    environment. We will need to create `@get:Rule`, which annotates fields that reference
    rules or methods that return a rule. Under the rule, let’s create `ComposeRuleTest`
    and initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to help us set up the content. We should call this
    function in our `Test` annotated function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s go ahead and add our first test. For the tests we will write,
    we will verify that the views are displayed on the screen as we expect them to
    be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SIGN_IN_BUTTON` and `USERNAME_FIELD` are imported from the test tags that
    we have created and are already used by only one view, the sign-in button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and run the tests, and a dialog will pop up showing the running process;
    if successful, the tests will pass. In our case, the tests should pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_3.13_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – A screenshot showing passing tests
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For these tests, you will not need to add any dependencies; everything we need
    is already available for our use.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use `createAndroidComposeRule<>()` when accessing an activity. Testing and
    ensuring your applications display the expected outcome is essential. This is
    why Android Studio uses the emulator to help developers test their code to ensure
    their application functions as it would on standard devices.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Android phones come with a developers’ option ready for developers
    to use, making it even easier for the different number of devices that Android
    supports and helping reproduce bugs that are hard to find in emulators.
  prefs: []
  type: TYPE_NORMAL
- en: When we test our Compose code, we improve our app’s quality by catching errors
    early on in the development process. In this chapter, we touched on creating more
    views to demonstrate how Jetpack Compose works; furthermore, our test cases need
    to address user action since we did not implement any.
  prefs: []
  type: TYPE_NORMAL
- en: In a different setting, we can write more crucial tests to confirm the intended
    action, and we will do this in later chapters. Furthermore, Compose provides testing
    APIs to find elements, verify their attributes, and perform user actions. Moreover,
    they also include advanced features such as time manipulation, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly calling the `@Test` annotation is very important when writing tests
    since this annotation tells JUnit that the function to which it is attached is
    to run as a `Test` function. In addition, UI tests in Compose use `.onNodeWithTag`.
  prefs: []
  type: TYPE_NORMAL
- en: A UI portion or element can mean anything from a single Composable to a full
    screen. If you try to access the wrong node, the semantics tree, which is generated
    alongside the UI hierarchy, will complain.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other testing tools as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Espresso Test Recorder** provides developers with a faster, interactive way
    to test their app’s everyday user input behavior and visual elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Crawler** undoubtedly uses a more hands-off approach to help you test
    user actions without needing to maintain or write any code. With this tool, you
    can easily configure your inputs, such as entering your username and password
    credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monkey** is a command-line device that also stress-tests your app by sending
    a random flow of user validation/input or tap actions into the device or emulator
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about testing and semantics in Compose, read the following: [https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for your ViewModels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike **Model-View-Controller** (**MVC**) and **Model-View-Presenter** (**MVP**),
    MVVM is the favored design pattern in Modern Android Development because of its
    unidirectional data and dependency flow. Furthermore, it becomes more accessible
    to unit test, as you will see in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our previous recipe, *Implementing ViewModel and understanding the
    state in Compose*, to test our logic and state changes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will write unit tests to verify our authentication state
    changes since that is what we have implemented so far:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `LoginViewModelTest` class in the `test` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Created unit test](img/Figure_3.14_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Created unit test
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `cashapp/turbine` testing library for coroutine flows to test
    the flow we have created. Hence, you will need to include the processing code
    snippet in `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have created the class, go ahead and set up `@Before`, which will
    run before each test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we utilized `SampleLoginDispatchers.createTestDispatchers`.
    For `UnconfinedTestDispatcher`, you must include the testing dependencies and
    import, `import kotlinx.coroutines.test.UnconfinedTestDispatcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have our setup ready let us go ahead and create our test, verifying
    the authentication state changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside our `Test` function, we will now need to access the `loginViewModel`
    functions and pass fake values to the parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, go ahead and run the test, and it should pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Unit test passing](img/Figure_3.15_B18827.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Unit test passing
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, the most notable advantage of MVVM is being able to write
    code you can quickly test. In addition, architecture in Android is all about selecting
    the trade-offs. Each architecture has its pros and cons; based on your company’s
    needs, you might work with a different one.
  prefs: []
  type: TYPE_NORMAL
- en: We create `lateint var loginViewModel` to set up a class for testing, and this
    is because the logic to be tested is in `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: We use `UnconfinedDispatcher`, which creates an instance of an `Unconfined`
    dispatcher. That means the tasks it executes are not confined to any particular
    thread and form an event loop. It is different in that it skips delays, as all
    `TestDispatcher` instances do. And by default, `runTest()` provides `StandardTestDispatcher`,
    which does not execute child coroutines immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `Truth` for our assertation to help us make more readable code, and
    the significant advantages of `Truth` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It aligns the actual values to the left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives us more detailed failure messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers richer operations to help with testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also other alternatives, such as Mockito, Mockk, and more, but in
    this section, we have used `Truth`. We have also used a library by Cashapp that
    helps us test coroutine flows. You can learn more about the `turbine` library
    here: [https://github.com/cashapp/turbine](https://github.com/cashapp/turbine).'
  prefs: []
  type: TYPE_NORMAL
