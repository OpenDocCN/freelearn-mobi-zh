- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Handling the UI State in Jetpack Compose and Using Hilt
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 和使用 Hilt 中处理 UI 状态
- en: All Android applications display the state to users, which helps inform users
    on what the outcome is and when. The **state** in an Android application is any
    value that changes over time, and a good example is a toast that shows a message
    when there is an error. In this chapter, readers will learn how to handle the
    UI state better with the new Jetpack library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Android 应用程序都向用户显示状态，这有助于通知用户结果是什么以及何时发生。Android 应用程序中的 **状态**是任何随时间变化的价值，一个很好的例子是在出现错误时显示消息的
    toast。在本章中，读者将学习如何使用新的 Jetpack 库更好地处理 UI 状态。
- en: It is fair to say with great power comes great responsibility, and managing
    the state of any Composable component requires a distinct approach compared to
    using the older way of building Android views, or as many might call it, the imperative
    way. This means Jetpack’s library, Compose, is entirely different from XML layouts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句老话说，权力越大，责任越大，管理任何可组合组件的状态需要与使用较旧的构建 Android 视图的方式（或许多人称之为命令式方式）截然不同的方法。这意味着
    Jetpack 的库 Compose 完全不同于 XML 布局。
- en: Handling the UI state in the XML **View System** is very straightforward. The
    process entails setting the properties of the views to reflect the current state
    – that is, showing or hiding the views accordingly. For instance, when loading
    data from an API, you can hide the loading view, show the content view, and populate
    it with the desired views.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML **视图系统**中处理 UI 状态非常简单。这个过程包括设置视图的属性以反映当前状态——也就是说，根据需要显示或隐藏视图。例如，当从 API
    加载数据时，你可以隐藏加载视图，显示内容视图，并用所需的视图填充它。
- en: In Compose, however, it is impossible to change a Composable component once
    the application has drawn it. You can, however, change the values passed to each
    Composable by changing the state each Composable receives. Hence, learning about
    managing the state better when building robust Android applications will be handy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Compose 中，一旦应用程序绘制了可组合组件，就无法更改该组件。但是，你可以通过更改每个可组合组件接收到的状态来更改传递给每个可组合组件的值。因此，在学习如何更好地管理构建健壮的
    Android 应用程序的状态时，这将非常有用。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Implementing **Dependency Injection** (**DI**) with Jetpack Hilt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jetpack Hilt 实现 **依赖注入**（**DI**）
- en: Implementing `ViewModel` classes and understanding the state in Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `ViewModel` 类并在 Compose 中理解状态
- en: Implementing Compose in existing an XML layout-based project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有的基于 XML 布局的项目中实现 Compose
- en: Understanding and handling recomposition in Jetpack Compose
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和处理 Jetpack Compose 中的重组
- en: Writing UI tests for your Compose views
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的 Compose 视图编写 UI 测试
- en: Writing tests for your `ViewModel` classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的 `ViewModel` 类编写测试
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_three)找到。
- en: Implementing DI with Jetpack Hilt
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jetpack Hilt 实现依赖注入
- en: In object-oriented programming, DI is vital. Some people use it, and some prefer
    not to use it for their own reasons. However, DI is the practice of designing
    objects in a manner where they receive instances of the object from other pieces
    of code instead of constructing them internally.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，依赖注入至关重要。有些人使用它，有些人出于自己的原因而选择不使用它。然而，依赖注入是一种设计对象的方式，其中它们从其他代码片段接收对象实例，而不是内部构建它们。
- en: If you know of the SOLID principles, you know their primary goal is to make
    software design easier to maintain, read, test, and build upon. In addition, DI
    helps us follow some of the SOLID principles. The dependency inversion principle
    allows the code base to be easily expanded and extended with new functionalities
    and improves reusability. In Modern Android Development, DI is essential, and
    we will implement it in our application in this recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解 SOLID 原则，你知道它们的主要目标是使软件设计更容易维护、阅读、测试和构建。此外，依赖注入帮助我们遵循一些 SOLID 原则。依赖倒置原则允许代码库容易地通过添加新的功能进行扩展和扩展，并提高了可重用性。在现代
    Android 开发中，依赖注入是必不可少的，我们将在本食谱中实现它。
- en: There are different types of libraries that you can use in Android for DI, such
    as Koin, Dagger, and Hilt; Hilt harnesses the power of Dagger and benefits from
    compile-time correctness, good runtime performance, Android studio support, and
    scalability. For this recipe, we will use Hilt, which provides containers for
    every Android class in our project and automatically manages their life cycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，你可以使用不同类型的库来进行依赖注入，例如 Koin、Dagger 和 Hilt；Hilt 利用 Dagger 的力量，并从编译时正确性、良好的运行时性能、Android
    Studio 支持以及可扩展性中受益。对于这个菜谱，我们将使用 Hilt，它为我们的项目中每个 Android 类提供容器，并自动管理它们的生命周期。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just like in previous recipes, we will use the project we have used in previous
    recipes to add DI.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的菜谱中一样，我们将使用之前菜谱中使用的项目来添加依赖注入。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Hilt uses Java features; make sure your project is in the `app/build.gradle`,
    and you have the following compile options:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Hilt 使用 Java 特性；确保你的项目在 `app/build.gradle` 中，并且你有以下编译选项：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is already added automatically, but make sure you check that you have
    it just in case. Let''s get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经自动添加了，但请确保你检查一下，以防万一。让我们开始吧：
- en: 'First, we must add the `Hilt-android-gradle-plugin` plugin into our project’s
    root file, `build.gradle(Project:SampleLogin)`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须将 `Hilt-android-gradle-plugin` 插件添加到我们项目的根文件 `build.gradle(Project:SampleLogin)`
    中：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in our `app/build.gradle` file, add these dependencies, and sync the
    project. It should run without any issues:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的 `app/build.gradle` 文件中添加以下依赖项，并同步项目。它应该没有问题地运行：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s go ahead and add the `Application` class. All apps that use Hilt
    must have an `Application` class annotated with `@HiltAndroidApp`, and we need
    to call the `Application` class that we create in `Manifest`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加 `Application` 类。所有使用 Hilt 的应用程序都必须有一个被 `@HiltAndroidApp` 注解的 `Application`
    类，并且我们需要调用在 `Manifest` 中创建的 `Application` 类：
- en: '[PRE14]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our `Manifest` folder, let’s add `LoginApp`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Manifest` 文件夹中，让我们添加 `LoginApp`：
- en: '[PRE16]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the setup done, we need to start working with Hilt by adding
    the required annotations to our class. In `MainActivity.kt`, we need to add the
    `@``AndroidEntryPoint` annotation:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，我们需要通过给我们的类添加所需的注解来开始使用 Hilt。在 `MainActivity.kt` 中，我们需要添加 `@AndroidEntryPoint`
    注解：
- en: '[PRE19]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s go ahead and display what we did by running the `./gradlew :app:dependencies`
    command, and we will see something similar to *Figure 3**.1*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 `./gradlew :app:dependencies` 命令，看看我们做了什么，我们会看到类似于 *图 3**.1* 的内容。
- en: '![Figure 3.1 – Dagger Hilt dependency tree](img/Figure_3.4_B18827.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Dagger Hilt 依赖关系树](img/Figure_3.4_B18827.jpg)'
- en: Figure 3.1 – Dagger Hilt dependency tree
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Dagger Hilt 依赖关系树
- en: You can also view the dependency in Android Studio. That is by clicking on the
    **Gradle** tab on the right-hand side and selecting **expand:yourmodule** | **Tasks**
    | **android**. Then, finally, double-click on **androidDependencies** to run it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Android Studio 中查看依赖关系。这需要点击右侧的 **Gradle** 选项卡，然后选择 **展开:yourmodule**
    | **Tasks** | **android**。然后，最后，双击 **androidDependencies** 来运行它。
- en: Finally, compile and run the project; it should run successfully.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编译并运行项目；它应该能够成功运行。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`@HiltAndroidApp` triggers Hilt’s code generation, including a base class for
    our application, which acts as the application-level dependency container. The
    `@AndroidEntryPoint` annotation adds a DI container to the Android class annotated
    with it. When using Hilt, the generated Hilt component is attached to the Application
    object’s life cycle and provides its dependencies. Hilt currently supports the
    following Android classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`@HiltAndroidApp` 触发 Hilt 的代码生成，包括我们的应用程序的基础类，它充当应用程序级别的依赖项容器。`@AndroidEntryPoint`
    注解向被注解的 Android 类添加 DI 容器。当使用 Hilt 时，生成的 Hilt 组件附加到 Application 对象的生命周期，并提供其依赖项。Hilt
    目前支持以下 Android 类：'
- en: '`ViewModel` annotated as `@HiltViewModel`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被注解为 `@HiltViewModel` 的 `ViewModel`
- en: '`Application` annotated as `@HiltAndroidApp`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被注解为 `@HiltAndroidApp` 的 `Application`
- en: '`Activity`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`'
- en: '`Fragment`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fragment`'
- en: '`View`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`'
- en: '`Service`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`'
- en: '`BroadcastReceiver`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BroadcastReceiver`'
- en: We will use other necessary annotations in Hilt later, for instance, the `@Module`
    annotation, `@InstallIn`, and `@Provides`. The `@Module` annotation means the
    class in which you can add binding for types that cannot be injected in the constructor.
    `@InstallIn` indicates which Hilt-generated DI container (or singleton component)
    has to be available in the code module binding.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Hilt 中稍后使用其他必要的注解，例如 `@Module` 注解、`@InstallIn` 和 `@Provides`。`@Module`
    注解意味着你可以添加绑定类型的类，这些类型不能在构造函数中注入。`@InstallIn` 指示哪个 Hilt 生成的 DI 容器（或单例组件）必须在代码模块绑定中可用。
- en: Finally, `@Provides` binds a type that cannot be constructor injected. Its return
    type is the binding type, it can take dependency parameters, and every time you
    need an instance, the function body is executed if the type is not scoped.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`@Provides` 将一个不能通过构造函数注入的类型绑定。它的返回类型是绑定类型，它可以接受依赖参数，并且每次需要实例时，如果类型没有被作用域限制，函数体就会执行。
- en: Implementing ViewModel classes and understanding the state in Compose
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 ViewModel 类和了解 Compose 中的状态
- en: 'In Android, a `ViewModel` is a class responsible for consciously managing the
    UI-related data life cycle. There is also a lot of debate in the community about
    whether developers should use `ViewModel` in Compose or not. However, Manuel Vivo,
    a senior Android developer relations engineer at Google, says:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`ViewModel` 是一个负责有意识地管理与 UI 相关的数据生命周期的类。社区中也有许多关于开发人员是否应该在 Compose
    中使用 `ViewModel` 的争论。然而，谷歌的高级 Android 开发者关系工程师 Manuel Vivo 表示：
- en: '*“I’d include them if their benefits apply to your app. No need to use them
    if you handle all configuration changes yourself and don’t use Navigation Compose.
    Otherwise, use ViewModels not to reinvent* *the wheel.”*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*“如果它们的优点适用于您的应用程序，我会包括它们。如果您自己处理所有配置更改并且不使用 Navigation Compose，则无需使用它们。否则，使用
    ViewModels 而不是重新发明轮子。”*'
- en: '*“On the other hand, the debate as to why one should not use ViewModels is
    based on the argument that in pure Compose, since Compose handles configuration
    changes, having your Composable functions reference the ViewModel* *is unnecessary.”*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*“另一方面，关于为什么不应该使用 ViewModels 的争论基于这样一个论点：在纯 Compose 中，由于 Compose 处理配置更改，您的
    Composable 函数引用 ViewModel 是不必要的。”*'
- en: 'You can also refer to this tweet by Jim Sproch: [https://twitter.com/JimSproch/status/1397169679647444993](https://twitter.com/JimSproch/status/1397169679647444993).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以参考 Jim Sproch 的这条推文：[https://twitter.com/JimSproch/status/1397169679647444993](https://twitter.com/JimSproch/status/1397169679647444993)。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more info about the benefits of using the ViewModel here: [https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth](https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到有关使用 ViewModel 的好处更多信息：[https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth](https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth)。
- en: This means using `ViewModel` to handle the state in your application will be
    a question of personal choice with Jetpack Compose. The currently recommended
    architecture pattern in Android is **Model-View-View-Model** (**MVVM**), and many
    applications use it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 Jetpack Compose 中，使用 `ViewModel` 来处理应用程序的状态将是一个个人选择的问题。目前 Android 推荐的架构模式是
    **模型-视图-视图-模型**（**MVVM**），许多应用程序都在使用它。
- en: Jetpack Compose uses a unidirectional data flow design pattern; this means the
    data or state only streams down while the events stream up. Hence, a clear understanding
    of how we can utilize the unidirectional pattern to make our code more readable,
    maintainable, and testable as much as possible using the `ViewModel` class will
    be helpful.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 使用单向数据流设计模式；这意味着数据或状态只向下流动，而事件向上流动。因此，清楚地了解我们如何利用单向模式，尽可能多地使用
    `ViewModel` 类使我们的代码更易于阅读、维护和测试，将是有帮助的。
- en: In addition, `ViewModel` is suitable for providing your application with access
    to business logic, preparing the data for presentation on the screen, and making
    your code testable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ViewModel` 适用于为您的应用程序提供访问业务逻辑、准备屏幕上展示的数据以及使您的代码可测试的能力。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will work with a pre-built skeleton `SampleLogin` project,
    which you can download from the *Technical requirements* section. We will use
    Hilt in this recipe since the project uses Hilt, but we will explain Hilt in a
    next recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个预构建的骨架 `SampleLogin` 项目，您可以从 *技术要求* 部分下载它。我们将在这个菜谱中使用 Hilt，因为项目使用了
    Hilt，但我们将在一个后续菜谱中解释 Hilt。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'You will now create a `ViewModel` class and modify most of the code in the
    `LoginContent` Kotlin file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将创建一个 `ViewModel` 类并修改 `LoginContent` Kotlin 文件中的大部分代码：
- en: To keep our classes and files well organized, let’s go ahead and first create
    a package to hold our UI and view models. Navigate to the main `Package` folder,
    right-click to open a prompt, then go down to **Package**, and a dialog with a
    package name will appear.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的类和文件保持良好的组织结构，让我们首先创建一个包来存放我们的 UI 和视图模型。导航到主 `Package` 文件夹，右键单击以打开提示，然后向下到
    **Package**，将出现一个带有包名的对话框。
- en: '![Figure 3.2 – How to create a package](img/Figure_3.1_B18827.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 如何创建一个包](img/Figure_3.1_B18827.jpg)'
- en: Figure 3.2 – How to create a package
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 如何创建一个包
- en: 'Name the package `Login`; inside `LoginContent` file and add the new class,
    `LoginViewModel`, there. Go ahead and create a `ViewModel` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包命名为`Login`；在`LoginContent`文件中添加新的类，`LoginViewModel`。接下来创建一个`ViewModel`类：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have created a `LoginViewModel` class, we need to add a DI annotation
    of `HiltViewModel` and ensure we extend the `ViewModel` class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`LoginViewModel`类，我们需要添加`HiltViewModel`的DI注解并确保我们扩展了`ViewModel`类：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our `ViewModel` constructor, we will need to add `stateHandle: SavedStateHandle`,
    which will help us maintain and retrieve objects to and from the saved state.
    These values persist even after the system kills the process and remain available
    through the same object:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在我们的`ViewModel`构造函数中，我们需要添加`stateHandle: SavedStateHandle`，这将帮助我们维护和从保存的状态中检索对象。这些值即使在系统杀死进程后仍然持续存在，并且可以通过相同的对象保持可用：'
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we build our `ViewModel`, let’s go ahead and create a data class, `AuthenticationState()`.
    This class will come in handy during our testing since we need to be able to test
    most of our validation cases. A `View` state class, plus having a single source
    of truth, has many advantages and is one of the principles of **Model-View-Intent**
    (**MVI**):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们构建`ViewModel`之前，让我们继续创建一个数据类，`AuthenticationState()`。这个类在我们的测试中非常有用，因为我们需要能够测试大多数验证案例。一个`View`状态类，加上拥有单一事实来源，有许多优点，并且是**模型-视图-意图**（**MVI**）的原则之一：
- en: '[PRE30]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s go ahead and create a helper class, `MutableSavedState<T>()`, which
    will take in `savedStateHandle`, a key, and a default value. This class acts as
    a `MutableStateFlow()` but saves the data and value and retrieves it upon the
    application’s death with the help of `SavedStateHandle`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建一个辅助类，`MutableSavedState<T>()`，它将接受`savedStateHandle`、一个键和一个默认值。这个类充当`MutableStateFlow()`，但保存数据和值，并在应用程序死亡时通过`SavedStateHandle`检索它们：
- en: '[PRE40]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let’s go ahead and create callbacks that will be invoked when a user enters
    their username and password in our `LoginViewModel`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建当用户在我们的`LoginViewModel`中输入用户名和密码时将被调用的回调：
- en: '[PRE47]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Go ahead and do the same for password and password toggle visibility.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对密码和密码切换可见性执行相同的操作。
- en: 'Now, we need to create a `combineFlows` helper class. You can combine more
    than two flows in Kotlin; a coroutine `flow` is a type that emits multiple values
    sequentially, as opposed to the `suspend` function, which returns a single value.
    More details on how to combine flows can be found at `combine(flow1`, `flow2`,
    `flow3`, `flow4) {t1, t2, t3, t4 ->` `resultMapper}.stateIn(scope)`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个`combineFlows`辅助类。在Kotlin中，你可以组合超过两个流程；协程`flow`是一种按顺序发出多个值的类型，与返回单个值的`suspend`函数相反。有关如何组合流程的更多详细信息，请参阅`combine(flow1,
    flow2, flow3, flow4) {t1, t2, t3, t4 -> resultMapper}.stateIn(scope)`：
- en: '[PRE55]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Read more here – [https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows](https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅此处 – [https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows](https://stackoverflow.com/questions/67939183/kotlin-combine-more-than-2-flows)：
- en: '[PRE76]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let’s go ahead and create our helper class for using coroutines and call
    it `SampleLoginDispatchers()`; it will help us in testing our code and ensuring
    our code is easily readable. In addition, we use coroutine dispatchers that help
    determine what thread the corresponding coroutine should use for execution:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们的协程辅助类，命名为`SampleLoginDispatchers()`；它将帮助我们测试代码并确保我们的代码易于阅读。此外，我们使用协程调度器，这些调度器有助于确定相应的协程应该使用哪个线程进行执行：
- en: '[PRE77]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`SharedFlow` represents a read-only state with a single updatable data value,
    which emits any updates to its collectors. On the other hand, a state flow is
    a hot flow because its active instance exists independently of the presence of
    collectors.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedFlow`表示一个只读状态，具有单个可更新的数据值，它向其收集器发出任何更新。另一方面，状态流程是一个热流程，因为它的活动实例的存在独立于收集器的存在。'
- en: 'The `SharingStarted` coroutine flow operator in Android is used to share the
    execution of a flow among multiple collectors. It is commonly used to create a
    “hot” flow, which means that the flow starts emitting data as soon as it is created,
    and the data is shared among all the active collectors of the flow. These can
    be back-to-back emissions of the same command and have no effect:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android中的`SharingStarted`协程流程操作符用于在多个收集器之间共享流程的执行。它通常用于创建一个“热”流程，这意味着流程一旦创建就开始发出数据，并且数据被所有活跃的流程收集器共享。这些可以是连续的相同命令的发射，并且没有任何效果：
- en: '[PRE81]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There are four types of dispatchers. In our example, we will only use three.
    In addition, you can inject a single dispatcher and achieve the same result without
    the class; hence, this can be preference-based. See how it works for the four
    types of dispatchers:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有四种类型的分发器。在我们的例子中，我们只会使用三种。此外，你可以注入单个分发器，而不需要类，因此这可以基于个人偏好。看看四种类型分发器是如何工作的：
- en: '[PRE89]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Now that we have created our helper class, we must provide the dispatcher via
    DI. We have an entire recipe dedicated to Hilt, so we will look at the concepts
    and what the annotations mean in the Hilt recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的辅助类，我们必须通过依赖注入（DI）提供分发器。我们有一个专门针对 Hilt 的整个食谱，所以我们将探讨其中的概念以及注解在 Hilt
    食谱中的含义。
- en: 'Create a new package and call the package `di`. In this package, create a new
    object and call it `AppModule`; we will provide our dispatcher to the `ViewModel`
    constructor via the dependency graph:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包，并将其命名为 `di`。在这个包中，创建一个新的对象，并将其命名为 `AppModule`；我们将通过依赖图将我们的分发器提供给 `ViewModel`
    构造函数：
- en: '[PRE105]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We will now need to go to `LoginContent` and modify the code – that is, by
    adding callbacks that will correspond to our `ViewModel`, and whenever we have
    a view – for example, `UserNameField()` – we will use the callback. See the sample
    code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要前往 `LoginContent` 并修改代码——也就是说，通过添加与我们的 `ViewModel` 对应的回调，并且每当我们有视图——例如，`UserNameField()`——我们将使用回调。请参阅示例代码：
- en: '[PRE118]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now, in our `LoginContentScreen` Composable function, we will pass our `LoginViewModel`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的 `LoginContentScreen` 组合函数中，我们将传递我们的 `LoginViewModel`：
- en: '[PRE149]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Finally, in `MainActivity`, we can now go ahead and call `LoginContentScreen`,
    pass in our `ViewModel`, and also specify what action we want when the user clicks
    `onRegister`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `MainActivity` 中，我们现在可以继续调用 `LoginContentScreen`，传入我们的 `ViewModel`，并指定当用户点击
    `onRegister` 时我们想要执行的操作：
- en: '[PRE168]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: For the entire code, please ensure you check out the link in the *Technical*
    *requirements* section.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于整个代码，请确保查看 *技术要求* 部分的链接。
- en: "![Figure 3.3 – Error state display when we enter\uFEFF a special character\
    \ !](img/Figure_3.2_B18827.jpg)"
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 输入特殊字符 ! 时显示的错误状态](img/Figure_3.2_B18827.jpg)'
- en: Figure 3.3 – Error state display when we enter a special character !
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 输入特殊字符 ! 时显示的错误状态
- en: How it works…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Jetpack Compose uses a unidirectional data flow design pattern. This means the
    data or state only streams down while the events stream up, as shown in *Figure
    3**.4*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 使用单向数据流设计模式。这意味着数据或状态只向下流动，而事件向上流动，如图 *图 3**.4* 所示。
- en: '![Figure 3.4 – A unidirectional data flow](img/Figure_3.3_B18827.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 单向数据流](img/Figure_3.3_B18827.jpg)'
- en: Figure 3.4 – A unidirectional data flow
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 单向数据流
- en: That is to say, Composable functions receive the state and then display it on
    the screen. On the other hand, an event can cause the state to need to be updated
    and come from either a Composable or any other part of your application. Furthermore,
    whatever handles the state, in our case, `ViewModel`, receives the event and adjusts
    the state for us.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，组合函数接收状态并在屏幕上显示它。另一方面，事件可以导致状态需要更新，这些事件可以来自组合函数或应用程序的任何其他部分。此外，无论谁处理状态，在我们的例子中是
    `ViewModel`，都会接收事件并为我们调整状态。
- en: We also use coroutines, which are nothing but lightweight threads, and they
    help us handle synchronous and asynchronous programming easily. Furthermore, coroutines
    allow execution to be suspended and resumed later. The main advantages are that
    they are lightweight, have built-in cancellation support, have lower chances of
    memory leaks, and the Jetpack libraries provide coroutine support.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用协程，它们不过是轻量级的线程，它们帮助我们轻松处理同步和异步编程。此外，协程允许执行被挂起并在稍后恢复。主要优点是它们轻量级、内置取消支持、内存泄漏的可能性较低，并且
    Jetpack 库提供了协程支持。
- en: 'There are four types of dispatchers:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的分发器：
- en: '`Main` dispatcher executes in the main thread, which is usually used when your
    application needs to perform some UI operations within a coroutine. This is because
    the UI can only be changed from the main thread. Another name for the main thread
    is the UI thread.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main` 分发器在主线程中执行，这通常用于当你的应用程序需要在协程中执行一些 UI 操作时。这是因为 UI 只能从主线程更改。主线程的另一个名称是
    UI 线程。'
- en: '`IO` dispatcher starts the coroutine in the I/O thread; I/O simply means input
    and output in programming. This is also used to perform all data work, such as
    networking, reading, or writing from the database. You can simply say fetching
    data from the I/O operation is done in the I/O thread.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO`分发器在I/O线程中启动协程；在编程中，I/O简单意味着输入和输出。这也用于执行所有数据工作，例如网络、从数据库读取或写入。你可以简单地说，从I/O操作中获取数据是在I/O线程中完成的。'
- en: '`Default` dispatcher starts in the default state. Your application can utilize
    this if you plan on doing complex long-running calculations, which can block the
    UI/main thread and make your UI freeze or cause an `GlobalScope`, and you can
    use it by simply calling `GlobalScope.launch{...}`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`分发器从默认状态开始。如果你的应用程序计划进行复杂的长运行计算，这可能会阻塞UI/main线程并使你的UI冻结或导致`GlobalScope`，你可以通过简单地调用`GlobalScope.launch{...}`来使用它。'
- en: '`Unconfined`, as the name suggests, is a dispatcher not confined to any specific
    thread. This executes the dispatcher to perform its work in a current call frame
    and lets the coroutine resume whatever threads that are used by the corresponding
    function.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如其名所示，`Unconfined`是一个不受任何特定线程限制的分发器。这会将分发器执行到当前调用帧中，并允许协程恢复相应函数使用的任何线程。
- en: See also…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见…
- en: 'A lot was covered in this chapter, and it is fair to acknowledge that just
    this simple recipe cannot explain `ViewModel` in its entirety. To find out more,
    see the following link: [https://developer.android.com/topic/libraries/architecture/viewmodel](https://developer.android.com/topic/libraries/architecture/viewmodel).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容，承认仅仅这个简单的菜谱无法完全解释`ViewModel`是公平的。要了解更多信息，请参阅以下链接：[https://developer.android.com/topic/libraries/architecture/viewmodel](https://developer.android.com/topic/libraries/architecture/viewmodel)。
- en: Implementing Compose in an existing XML layout-based project
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基于现有XML布局的项目中实现Compose
- en: Since Compose is a new UI framework, many code bases still rely heavily on XML
    layouts. However, many companies are opting to build new screens using Compose,
    and this is achievable by utilizing existing XML layouts and adding unique views
    using `ComposeView` XML tags. This recipe will look into adding a Compose view
    to an XML layout.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Compose是一个新的UI框架，许多代码库仍然严重依赖于XML布局。然而，许多公司正在选择使用Compose构建新的屏幕，这是通过利用现有的XML布局并添加使用`ComposeView`
    XML标签的独特视图来实现的。这个菜谱将探讨如何将Compose视图添加到XML布局中。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we can create a new project or opt to use an existing project
    that does not heavily rely on Compose. We will try to display `GreetingDialog`
    and use an XML layout to show how we can use the `ComposeView` tag in XML layouts.
    If you already have a project, you do not need to set this up; you can skip to
    *step 4* in the preceding *How to do* *it…* section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以创建一个新的项目，或者选择使用一个不严重依赖Compose的现有项目。我们将尝试显示`GreetingDialog`并使用XML布局来展示我们如何在XML布局中使用`ComposeView`标签。如果你已经有了一个项目，你不需要设置这个；你可以跳到前面*如何做*
    *它…*部分中的*步骤 4*。
- en: How to do it…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now let us go ahead and explore how we can utilize existing XML layouts with
    Compose:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索如何利用现有的XML布局与Compose结合使用：
- en: Let’s start by creating a new project or using a preexisting one; if you create
    a new activity that is not Compose, you can use `EmptyActivity`, and give it any
    name.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的项目或使用一个现有的项目；如果你创建了一个不是Compose的新活动，你可以使用`EmptyActivity`，并给它任何名字。
- en: If you already have a project set up, you can skip this step. If you opt to
    create a new project, you will have `MainActivity`, and since this is the old
    way of creating views, you will notice an XML layout in the `resource` folder
    with a TextView that has `Hello world`. We can go ahead and remove that since
    we will not use it.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经设置了一个项目，你可以跳过这一步。如果你选择创建一个新的项目，你将会有`MainActivity`，由于这是创建视图的老方法，你会在`resource`文件夹中注意到一个包含`Hello
    world`的TextView的XML布局。我们可以继续删除它，因为我们不会使用它。
- en: If you already have a project ready, you can launch `GreetingDialog` on any
    screen you want. Also, if you opt to create a button instead of a dialog, that
    is fine, too since the idea is to showcase how we can use XML tags in Jetpack
    Compose.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经有一个准备好的项目，你可以在任何你想要的屏幕上启动`GreetingDialog`。此外，如果你选择创建一个按钮而不是对话框，这也是可以的，因为目的是展示我们如何使用Jetpack
    Compose中的XML标签。
- en: Now, let us go ahead and add an XML tag inside `activity_main.xml` and give
    our Compose view an `id` value. The first time you add `ComposeView`, you will
    see an error message if you still need to add the dependency. Go ahead and click
    **Add dependency on android.compose.ui:ui** and the project will sync as shown
    in *Figure 3**.5*.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续在`activity_main.xml`中添加一个XML标签，并给我们的Compose视图一个`id`值。第一次添加`ComposeView`时，如果你还需要添加依赖项，你会看到一个错误消息。继续点击**在android.compose.ui:ui上添加依赖项**，项目将同步，如图*图3**.5*所示。
- en: '![Figure 3.5 – A Compose view in XML](img/Figure_3.5_B18827.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – XML中的Compose视图](img/Figure_3.5_B18827.jpg)'
- en: Figure 3.5 – A Compose view in XML
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – XML中的Compose视图
- en: 'Once you have synced your project, the error will disappear, and you should
    be able to use this view in `MainActivity`, or where you want to use `ComposeView`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你同步了你的项目，错误就会消失，你应该能够在`MainActivity`或你想使用`ComposeView`的地方使用这个视图：
- en: '[PRE169]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Let’s also add `viewBinding` to our `build.gradle(Module:app)` so that we can
    easily access our view in `MainActivity`. Also, if you already have `viewBinding`
    set up, you can skip this part:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也在`build.gradle(Module:app)`中添加`viewBinding`，这样我们就可以在`MainActivity`中轻松访问我们的视图。如果你已经设置了`viewBinding`，你可以跳过这部分：
- en: '[PRE173]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Once we have synced the project, we can go ahead and, in `MainActivity`, access
    `ComposeView` through binding. Furthermore, it will have a `setContent{}` method
    where you can set all your Composables and wrap it into your Theme:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们同步了项目，我们就可以在`MainActivity`中通过绑定访问`ComposeView`。此外，它将有一个`setContent{}`方法，你可以设置所有你的可组合元素并将其包裹在主题中：
- en: '[PRE176]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Our `GreetingAlertDialog()` will have an `AlertDialog()` Composable, a title,
    and text, which will provide our message as a simple text element. The title will
    say `Hello` since this is a greeting, and the message will be `Hello, and thank
    you for being part of the Android community`. You can customize this to fit your
    needs:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`GreetingAlertDialog()`将包含一个`AlertDialog()`可组合元素、一个标题和文本，它将我们的消息作为一个简单的文本元素提供。标题将说`Hello`，因为这是一个问候，消息将是`Hello，感谢您成为Android社区的一员`。你可以根据需要自定义它：
- en: '[PRE190]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: To create Compose components, you will need to add the Compose Material Design
    dependency to your gradle app. Depending on what your application supports, you
    can utilize Compose Material 3 components, which is the next evolution of Material
    Design and comes with updated theming.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Compose组件，你需要在你的gradle app中添加Compose Material Design依赖项。根据你的应用程序支持的情况，你可以利用Compose
    Material 3组件，这是Material Design的下一个进化版本，并带有更新的主题。
- en: You can easily customize features such as dynamic color and more. We look into
    Material 3 in [*Chapter 11*](B18827_11.xhtml#_idTextAnchor619), *GUI Alerts –
    What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern Android Development*.
    Hence, for now, since the application that I am using has not migrated to Material
    3, I will use this import – `implementation "androidx.Compose.material:material:1.x.x"`.
    Here, you can use any import that fits your need.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以轻松地自定义动态颜色等功能。我们将在[*第11章*](B18827_11.xhtml#_idTextAnchor619)中探讨Material 3，*GUI
    Alerts – What’s New in Menus, Dialog, Toast, Snackbars, and More in Modern Android
    Development*。因此，目前，由于我使用的应用程序尚未迁移到Material 3，我将使用这个导入 – `implementation "androidx.Compose.material:material:1.x.x"`。在这里，你可以使用任何适合你需要的导入。
- en: 'You can also create a custom view that extends from `AbstractComposeView`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以创建一个继承自`AbstractComposeView`的自定义视图：
- en: '[PRE207]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Finally, when you run your application, you should have a dialog that has a
    title and text; *Figure 3**.6* shows a dialog from an already pre-existing project,
    so this will definitely vary based on what steps you took:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你运行你的应用程序时，你应该有一个包含标题和文本的对话框；*图3**.6*显示了一个来自已存在的项目的对话框，所以这肯定会根据你采取的步骤而有所不同：
- en: '![Figure 3.6 – Dialog Compose view in XML](img/Figure_3.6_B18827.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – XML中的对话框Compose视图](img/Figure_3.6_B18827.jpg)'
- en: Figure 3.6 – Dialog Compose view in XML
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – XML中的对话框Compose视图
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we inflate the XML layout, which we define in our layout `resource` folder.
    Then, using binding, we got `ComposeView` using the created XML ID, set a Compose
    strategy that works best for our host view, and called `setContent` to use Compose.
    In your activity, to be able to create any Compose-based screen, you have to ensure
    that you call the `setContent{}` method and pass whatever Composable function
    you have created.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们膨胀了在布局`资源`文件夹中定义的XML布局。然后，使用绑定，我们通过创建的XML ID获取`ComposeView`，设置最适合我们宿主视图的Compose策略，并调用`setContent`来使用Compose。在你的活动中，为了能够创建任何基于Compose的屏幕，你必须确保调用`setContent{}`方法并传递你创建的任何可组合函数。
- en: To further explore the `setContent` method, it is written as an extension function
    of `ComponentActivity`, and it expects a Composable function as the last parameter.
    There is also a better way to demonstrate how `setContent{}` works to integrate
    a Composable tree into your Android application.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索 `setContent` 方法，它被写成 `ComponentActivity` 的扩展函数，并期望一个 Composable 函数作为最后一个参数。还有更好的方法来展示
    `setContent{}` 的工作原理，以便将 Composable 树集成到你的 Android 应用程序中。
- en: '![Figure 3.7 – This happens when you call setContent{}](img/Figure_3.7_B18827.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 当你调用 setContent{} 时发生的情况](img/Figure_3.7_B18827.jpg)'
- en: Figure 3.7 – This happens when you call setContent{}
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 当你调用 setContent{} 时发生的情况
- en: '`ViewCompositionStrategy` helps determines when to dispose of the composition;
    hence, Compose UI views such as `ComposeView` and the `AbstractComposeView` use
    `ViewCompositonStrategy`, which helps define this behavior.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewCompositionStrategy` 帮助确定何时销毁组合；因此，Compose UI 视图如 `ComposeView` 和 `AbstractComposeView`
    使用 `ViewCompositonStrategy`，这有助于定义此行为。'
- en: 'You can learn more by following this link to learn more about the interoperability
    APIs: [https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy](https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解更多关于互操作 API 的信息：[https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy](https://developer.android.com/jetpack/compose/interop/interop-apis#composition-strategy)。
- en: Understanding and handling recomposition in Jetpack Compose
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和处理 Jetpack Compose 中的重组
- en: Jetpack Compose is still very new, and many companies are starting to use it.
    Furthermore, Google has done a great job by giving developers significant documentation
    to help them embrace this new UI toolkit. However, despite all the documentation,
    one concept needs to be clarified. And that is recomposition.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 仍然非常新，许多公司开始使用它。此外，谷歌通过为开发者提供大量文档来帮助他们接受这个新的 UI 工具包，做得非常出色。然而，尽管有所有这些文档，仍有一个概念需要澄清。那就是重组。
- en: Fair enough, all new software has its ups and downs, and as many people start
    using it, more people start giving feedback – hence, the need for more improvement.
    Recomposition, in Compose, involves calling your Composable again when the input
    changes. Or you can think of it when the composition structure and relation change.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，所有新的软件都有其优点和缺点，随着越来越多的人开始使用它，更多的人开始提供反馈——因此，需要更多的改进。在 Compose 中，重组涉及在输入变化时再次调用你的
    Composable。或者你可以将其视为组合结构和关系发生变化时。
- en: Unless its parameters change, we want to avoid a Composable function being re-invoked
    in most use cases. So, in this recipe, we look into how recomposition happens
    and how you can debug and solve any recomposition in your application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除非其参数发生变化，我们希望在大多数用例中避免重新调用可组合函数。因此，在这个菜谱中，我们探讨重组是如何发生的，以及你如何在应用程序中调试和解决任何重组问题。
- en: How to do it…
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Since our view system is simple, we will be checking whether we have any recomposition
    in our `Login` project:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视图系统很简单，我们将检查在我们的 `Login` 项目中是否有任何重组：
- en: 'We can look at a simple example and how recomposition will occur:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看看一个简单的例子以及重组是如何发生的：
- en: '[PRE217]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: In our given example, the `Text` function will recompose when `name` changes
    and not when `gender` changes. In addition, the `gender:String` input value will
    recompose only when `gender` changes.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，当 `name` 发生变化时，`Text` 函数将重新组合，而不是当 `gender` 发生变化时。此外，只有当 `gender` 发生变化时，`gender:String`
    输入值才会重新组合。
- en: You can also launch and utilize `LoginContent` and see whether we have any recomposition.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以启动并使用 `LoginContent` 来查看我们是否有任何重组。
- en: '![Figure 3.8 – Layout Inspector](img/Figure_3.8_B18827.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 布局检查器](img/Figure_3.8_B18827.jpg)'
- en: Figure 3.8 – Layout Inspector
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 布局检查器
- en: Once you launch **Layout Inspector**, you need to ensure you have your emulator
    hooked to it.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你启动 **布局检查器**，你需要确保你的模拟器已连接到它。
- en: '![Figure 3.9 – Linking the inspector](img/Figure_3.9_B18827.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 连接检查器](img/Figure_3.9_B18827.jpg)'
- en: Figure 3.9 – Linking the inspector
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 连接检查器
- en: Go ahead and expand the `SampleLoginTheme` entry point, and you will notice
    our current view system is not complex. As you can see, **Layout Inspector** does
    not show any recomposition counts.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往并展开 `SampleLoginTheme` 入口，你会注意到我们的当前视图系统并不复杂。正如你所见，**布局检查器**没有显示任何重组计数。
- en: That is to say, if our application had any recomposition counts, they would
    show up in **Layout Inspector**.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们的应用程序有任何重组计数，它们将显示在 **布局检查器** 中。
- en: '![Figure 3.10 – The component tree](img/Figure_3.10_B18827.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 组件树](img/Figure_3.10_B18827.jpg)'
- en: Figure 3.10 – The component tree
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 组件树
- en: Finally, as you have seen, our application does not have any recomposition happening,
    but it is always beneficial to check your application to know what might be causing
    the recomposition and fix it.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，正如你所看到的，我们的应用程序没有发生任何重新组合，但检查你的应用程序以了解可能引起重新组合的原因并修复它总是有益的。
- en: Important note
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Using side-effects might lead to users of your application experiencing strange
    and unpredictable behavior in your app. In addition, a side-effect is any change
    that is visible to the rest of your application. For instance, writing to a property
    of a shared object, updating an observable in `ViewModel`, and updating shared
    preferences are all dangerous side effects.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用副作用可能会导致你的应用程序的用户在应用程序中遇到奇怪且不可预测的行为。此外，副作用是指对应用程序其余部分可见的任何更改。例如，向共享对象的属性写入、在`ViewModel`中更新可观察对象以及更新共享首选项都是危险的副作用。
- en: How it works…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: For adaptability, Compose skips `lambda` calls or any child function that does
    not have any changes to its input. This better handling of resources makes sense
    since, in Compose, animations and other UI elements can trigger recomposition
    in every frame.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应性，Compose会跳过`lambda`调用或任何没有对其输入进行更改的子函数。这种更好的资源处理方式是有意义的，因为在Compose中，动画和其他UI元素可以在每一帧中触发重新组合。
- en: 'We can go in depth and use a diagram to showcase how the Jetpack composition
    life cycle works. In short, the life cycle of a Composable function is defined
    by three significant events:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以深入探讨并使用图表来展示Jetpack组合生命周期的运作方式。简而言之，可组合函数的生命周期由三个重要事件定义：
- en: Being composed
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被组合
- en: Getting recomposed or not getting recomposed
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否重新组合或不会重新组合
- en: No longer being composed
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再被组合
- en: '![Figure 3.11 – The composition life cycle of a Composable](img/Figure_3.11_B18827.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 可组合的组成生命周期](img/Figure_3.11_B18827.jpg)'
- en: Figure 3.11 – The composition life cycle of a Composable
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 可组合的组成生命周期
- en: To fathom how Compose works, it’s good to know what constitutes the Compose
    architectural layer. A high-level overview of the Jetpack Compose architectural
    layer includes **Material**, **Foundation**, **UI**, and **Runtime** aspects.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Compose的工作原理，了解构成Compose架构层的元素是有益的。Jetpack Compose架构层的高级概述包括**Material**、**Foundation**、**UI**和**Runtime**方面。
- en: '![Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers](img/Figure_3.12_B18827.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 显示Jetpack Compose架构层的图解](img/Figure_3.12_B18827.jpg)'
- en: Figure 3.12 – A diagram showing Jetpack Compose Architectural Layers
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 显示Jetpack Compose架构层的图解
- en: In **Material**, this module implements the Material Design system for the Compose
    UI.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Material**中，此模块实现了Compose UI的Material Design系统。
- en: Furthermore, it provides a theming system, styled components, and more. `Row`,
    `Column`, and more. The **UI** layer is made of multiple modules that implement
    the fundamentals of the UI toolkit.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它提供了一个主题系统、样式化组件以及更多。`Row`、`Column`等。**UI**层由多个模块组成，这些模块实现了UI工具包的基本原理。
- en: See also
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The Compose team is launching Jetpack Compose Composition Tracing, the first
    alpha that will help developers trace their composition easily; you can read more
    here:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Compose团队正在推出Jetpack Compose Composition Tracing，这是第一个alpha版本，将帮助开发者轻松追踪他们的组合；你可以在这里了解更多信息：
- en: '[https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535](https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535](https://medium.com/androiddevelopers/jetpack-Compose-composition-tracing-9ec2b3aea535)'
- en: '[https://developer.android.com/jetpack/compose/lifecycle](https://developer.android.com/jetpack/compose/lifecycle)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/jetpack/compose/lifecycle](https://developer.android.com/jetpack/compose/lifecycle)'
- en: Writing UI tests for your Compose views
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的Compose视图编写UI测试
- en: It is essential to test your code when developing Android applications, especially
    if your applications have many users. Furthermore, when you write tests for your
    code, you basically verify the functions, behavior, correctness, and versatility
    of the Android application. The most popular UI testing tools in Android are Espresso,
    UI Automator, Calabash, and Detox.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Android应用程序时，测试你的代码是至关重要的，尤其是如果你的应用程序拥有许多用户。此外，当你为你的代码编写测试时，你基本上是在验证Android应用程序的功能、行为、正确性和多功能性。Android中最受欢迎的UI测试工具是Espresso、UI
    Automator、Calabash和Detox。
- en: 'In this book, however, we will use Espresso. The most notable advantages of
    Espresso are as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这本书中，我们将使用Espresso。Espresso最显著的优点如下：
- en: It is easy to set up
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起来很容易
- en: It has highly stable test cycles
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有高度稳定的测试周期
- en: It supports JUnit 4
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持JUnit 4
- en: It is made purely for Android UI testing
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它专为Android UI测试制作
- en: It is suitable for writing black-box tests
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适合编写黑盒测试
- en: It supports testing activities outside the application as well
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还支持测试应用程序之外的活动
- en: Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have completed previous recipes to follow along with this one.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完成之前的食谱才能跟随这个食谱。
- en: How to do it…
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'As with the other recipes in this chapter, we will use the new project we created
    in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014), *Getting Started with Modern
    Android* *Development Skills*:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章中的其他食谱一样，我们将使用我们在[*第1章*](B18827_01.xhtml#_idTextAnchor014)“现代Android开发技能入门”中创建的新项目：
- en: Let’s go ahead and navigate into the `androidTest` package in our project folder.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续导航到我们的项目文件夹中的`androidTest`包。
- en: Start by creating a new class in the `androidTest` package and call it `LoginContentTest.kt`.
    In Jetpack Compose, testing is made more accessible, and we need to have unique
    tags for our views.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`androidTest`包中创建一个新类，命名为`LoginContentTest.kt`。在Jetpack Compose中，测试变得更加容易，我们需要为我们的视图提供唯一的标签。
- en: 'So, for this step, let’s go back to our main package (`com.name.SampleLogin`)
    and create a new package and call it `util`. Inside `util`, let’s create a new
    class and call it `TestTags`, which will be an object. Here, we will have another
    object, name it `LoginContent`, and create constant values that we can call in
    our view:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，对于这一步，让我们回到我们的主包（`com.name.SampleLogin`）并创建一个新的包，命名为`util`。在`util`内部，让我们创建一个新的类，命名为`TestTags`，它将是一个对象。在这里，我们将有另一个对象，命名为`LoginContent`，并创建我们可以调用在视图中的常量值：
- en: '[PRE227]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Now that we have created the test tags, let’s go back to our `LoginContent`
    and add them to all views in the `Modifier()` so that when we test, it is easier
    to identify the view using the test tag we have added. See the following code
    snippet:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了测试标签，让我们回到我们的`LoginContent`并添加它们到`Modifier()`中的所有视图中，这样在测试时，使用我们添加的测试标签来识别视图会更容易。请看以下代码片段：
- en: '[PRE236]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Inside our `LoginCotentTest` class, let’s now go ahead and set up our testing
    environment. We will need to create `@get:Rule`, which annotates fields that reference
    rules or methods that return a rule. Under the rule, let’s create `ComposeRuleTest`
    and initialize it:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`LoginContentTest`类内部，现在让我们继续设置我们的测试环境。我们需要创建`@get:Rule`，它注解引用规则或返回规则的字段。在规则下，让我们创建`ComposeRuleTest`并初始化它：
- en: '[PRE242]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Add the following function to help us set up the content. We should call this
    function in our `Test` annotated function:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数以帮助我们设置内容。我们应该在我们的`Test`注解函数中调用此函数：
- en: '[PRE244]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Finally, let’s go ahead and add our first test. For the tests we will write,
    we will verify that the views are displayed on the screen as we expect them to
    be:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们继续添加我们的第一个测试。对于我们将要编写的测试，我们将验证视图是否以我们预期的样子显示在屏幕上：
- en: '[PRE251]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '`SIGN_IN_BUTTON` and `USERNAME_FIELD` are imported from the test tags that
    we have created and are already used by only one view, the sign-in button.'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SIGN_IN_BUTTON`和`USERNAME_FIELD`是从我们创建的测试标签导入的，并且目前只被一个视图（登录按钮）使用。'
- en: Go ahead and run the tests, and a dialog will pop up showing the running process;
    if successful, the tests will pass. In our case, the tests should pass.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始运行测试，将弹出一个对话框显示运行过程；如果成功，测试将通过。在我们的情况下，测试应该通过。
- en: '![](img/Figure_3.13_B18827.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.13_B18827.jpg)'
- en: Figure 3.13 – A screenshot showing passing tests
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 显示通过测试的截图
- en: Important note
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For these tests, you will not need to add any dependencies; everything we need
    is already available for our use.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些测试，你不需要添加任何依赖项；我们所需的一切都已经为我们准备好了。
- en: How it works…
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We use `createAndroidComposeRule<>()` when accessing an activity. Testing and
    ensuring your applications display the expected outcome is essential. This is
    why Android Studio uses the emulator to help developers test their code to ensure
    their application functions as it would on standard devices.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问活动时，我们使用`createAndroidComposeRule<>()`。测试并确保你的应用程序显示预期的结果是非常重要的。这就是为什么Android
    Studio使用模拟器来帮助开发者测试他们的代码，以确保他们的应用程序在标准设备上运行。
- en: Furthermore, Android phones come with a developers’ option ready for developers
    to use, making it even easier for the different number of devices that Android
    supports and helping reproduce bugs that are hard to find in emulators.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android手机自带开发者选项，方便开发者使用，这使得Android支持的不同设备数量更多，并有助于在模拟器中重现难以发现的bug。
- en: When we test our Compose code, we improve our app’s quality by catching errors
    early on in the development process. In this chapter, we touched on creating more
    views to demonstrate how Jetpack Compose works; furthermore, our test cases need
    to address user action since we did not implement any.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试我们的 Compose 代码时，通过在开发过程的早期阶段捕捉错误来提高我们应用的质量。在本章中，我们讨论了创建更多视图来展示 Jetpack
    Compose 的工作方式；此外，我们的测试用例需要处理用户操作，因为我们尚未实现。
- en: In a different setting, we can write more crucial tests to confirm the intended
    action, and we will do this in later chapters. Furthermore, Compose provides testing
    APIs to find elements, verify their attributes, and perform user actions. Moreover,
    they also include advanced features such as time manipulation, among others.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的环境中，我们可以编写更关键的测试来确认预期的操作，我们将在后面的章节中这样做。此外，Compose 提供了用于查找元素、验证它们的属性和执行用户操作的测试
    API。此外，它们还包括时间操作等高级功能。
- en: Explicitly calling the `@Test` annotation is very important when writing tests
    since this annotation tells JUnit that the function to which it is attached is
    to run as a `Test` function. In addition, UI tests in Compose use `.onNodeWithTag`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时显式调用 `@Test` 注解非常重要，因为这个注解告诉 JUnit，附加到其上的函数将作为一个 `Test` 函数运行。此外，Compose
    中的 UI 测试使用 `.onNodeWithTag`。
- en: A UI portion or element can mean anything from a single Composable to a full
    screen. If you try to access the wrong node, the semantics tree, which is generated
    alongside the UI hierarchy, will complain.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: UI 部分或元素可以是从单个 Composable 到全屏的任何内容。如果您尝试访问错误的节点，与 UI 层级一起生成的语义树将会抱怨。
- en: There’s more…
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are other testing tools as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他测试工具，如下所示：
- en: '**Espresso Test Recorder** provides developers with a faster, interactive way
    to test their app’s everyday user input behavior and visual elements.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Espresso Test Recorder** 为开发者提供了一种更快、更直观的方式来测试他们应用中日常的用户输入行为和视觉元素。'
- en: '**App Crawler** undoubtedly uses a more hands-off approach to help you test
    user actions without needing to maintain or write any code. With this tool, you
    can easily configure your inputs, such as entering your username and password
    credentials.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**App Crawler** 无疑采用了一种更加不干预的方法来帮助您测试用户操作，而无需维护或编写任何代码。使用这个工具，您可以轻松配置输入，例如输入您的用户名和密码凭据。'
- en: '**Monkey** is a command-line device that also stress-tests your app by sending
    a random flow of user validation/input or tap actions into the device or emulator
    instance.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Monkey** 是一个命令行设备，它通过向设备或模拟器实例发送随机的用户验证/输入或点击操作来对您的应用进行压力测试。'
- en: 'To learn more about testing and semantics in Compose, read the following: [https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics).'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于测试和 Compose 中的语义的信息，请阅读以下内容：[https://developer.android.com/jetpack/compose/semantics](https://developer.android.com/jetpack/compose/semantics)。
- en: Writing tests for your ViewModels
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的 ViewModels 编写测试
- en: Unlike **Model-View-Controller** (**MVC**) and **Model-View-Presenter** (**MVP**),
    MVVM is the favored design pattern in Modern Android Development because of its
    unidirectional data and dependency flow. Furthermore, it becomes more accessible
    to unit test, as you will see in this recipe.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **模型-视图-控制器** (**MVC**) 和 **模型-视图-呈现器** (**MVP**) 不同，MVVM 由于其单向数据和依赖关系流，在现代
    Android 开发中是首选的设计模式。此外，它使得单元测试变得更加容易，正如您将在本配方中看到的那样。
- en: Getting ready
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use our previous recipe, *Implementing ViewModel and understanding the
    state in Compose*, to test our logic and state changes.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们之前的配方，*在 Compose 中实现 ViewModel 并理解状态*，来测试我们的逻辑和状态变化。
- en: How to do it…
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will write unit tests to verify our authentication state
    changes since that is what we have implemented so far:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写单元测试来验证我们的身份验证状态变化，因为这是我们迄今为止实现的内容：
- en: 'Start by creating a `LoginViewModelTest` class in the `test` package:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 `test` 包中创建一个 `LoginViewModelTest` 类：
- en: '![Figure 3.14 – Created unit test](img/Figure_3.14_B18827.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 创建的单元测试](img/Figure_3.14_B18827.jpg)'
- en: Figure 3.14 – Created unit test
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 创建的单元测试
- en: 'We will use the `cashapp/turbine` testing library for coroutine flows to test
    the flow we have created. Hence, you will need to include the processing code
    snippet in `build.gradle`:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `cashapp/turbine` 测试库来测试协程流程，以测试我们创建的流程。因此，您需要在 `build.gradle` 中包含处理代码片段：
- en: '[PRE263]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Once you have created the class, go ahead and set up `@Before`, which will
    run before each test:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了类，就可以设置 `@Before`，它将在每个测试之前运行：
- en: '[PRE269]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: As you can see, we utilized `SampleLoginDispatchers.createTestDispatchers`.
    For `UnconfinedTestDispatcher`, you must include the testing dependencies and
    import, `import kotlinx.coroutines.test.UnconfinedTestDispatcher`.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了 `SampleLoginDispatchers.createTestDispatchers`。对于 `UnconfinedTestDispatcher`，您必须包含测试依赖项并导入，`import
    kotlinx.coroutines.test.UnconfinedTestDispatcher`。
- en: 'Now that we have our setup ready let us go ahead and create our test, verifying
    the authentication state changes:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了设置，让我们继续创建我们的测试，验证认证状态的变化：
- en: '[PRE281]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Inside our `Test` function, we will now need to access the `loginViewModel`
    functions and pass fake values to the parameters:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Test` 函数中，我们现在需要访问 `loginViewModel` 函数并将假值传递给参数：
- en: '[PRE283]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Finally, go ahead and run the test, and it should pass.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行测试，它应该通过。
- en: '![Figure 3.15 – Unit test passing](img/Figure_3.15_B18827.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 单元测试通过](img/Figure_3.15_B18827.jpg)'
- en: Figure 3.15 – Unit test passing
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 单元测试通过
- en: How it works…
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As mentioned before, the most notable advantage of MVVM is being able to write
    code you can quickly test. In addition, architecture in Android is all about selecting
    the trade-offs. Each architecture has its pros and cons; based on your company’s
    needs, you might work with a different one.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，MVVM 最显著的优势是能够编写可以快速测试的代码。此外，Android 的架构全部关于选择权衡。每种架构都有其优缺点；根据您公司的需求，您可能需要使用不同的架构。
- en: We create `lateint var loginViewModel` to set up a class for testing, and this
    is because the logic to be tested is in `ViewModel`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建 `lateint var loginViewModel` 来设置一个用于测试的类，这是因为要测试的逻辑在 `ViewModel` 中。
- en: We use `UnconfinedDispatcher`, which creates an instance of an `Unconfined`
    dispatcher. That means the tasks it executes are not confined to any particular
    thread and form an event loop. It is different in that it skips delays, as all
    `TestDispatcher` instances do. And by default, `runTest()` provides `StandardTestDispatcher`,
    which does not execute child coroutines immediately.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `UnconfinedDispatcher`，它创建了一个 `Unconfined` 分发器的实例。这意味着它执行的任务不受任何特定线程的限制，形成一个事件循环。它与所有
    `TestDispatcher` 实例不同之处在于它跳过了延迟。默认情况下，`runTest()` 提供了 `StandardTestDispatcher`，它不会立即执行子协程。
- en: 'We use `Truth` for our assertation to help us make more readable code, and
    the significant advantages of `Truth` are as follows:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Truth` 进行断言，以帮助我们编写更易读的代码，`Truth` 的显著优势如下：
- en: It aligns the actual values to the left
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将实际值对齐到左侧
- en: It gives us more detailed failure messages
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为我们提供了更详细的错误信息
- en: It offers richer operations to help with testing
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了更丰富的操作来帮助进行测试
- en: 'There are also other alternatives, such as Mockito, Mockk, and more, but in
    this section, we have used `Truth`. We have also used a library by Cashapp that
    helps us test coroutine flows. You can learn more about the `turbine` library
    here: [https://github.com/cashapp/turbine](https://github.com/cashapp/turbine).'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他替代方案，例如 Mockito、Mockk 等，但在这个部分，我们使用了 `Truth`。我们还使用了 Cashapp 的一个库，它帮助我们测试协程流程。您可以在[https://github.com/cashapp/turbine](https://github.com/cashapp/turbine)了解更多关于
    `turbine` 库的信息。
