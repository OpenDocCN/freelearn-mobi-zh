- en: Enabling VirtualBox-Specific Hardware Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用VirtualBox特定硬件接口
- en: 'In the last chapter, we did a deep analysis of Android Gralloc HAL modules.
    We analyzed the default Gralloc module and the hardware GPU emulation Gralloc
    HAL for the Android emulator. We don''t have time to walk through the boot up
    process related to the graphics system yet. In this chapter, we will walk through
    the boot up process of the graphics system and explore the VirtualBox-specific
    hardware drivers. At the end of this chapter, we will have a relatively complete
    system on VirtualBox. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对Android Gralloc HAL模块进行了深入分析。我们分析了默认的Gralloc模块和Android模拟器的硬件GPU仿真Gralloc
    HAL。我们还没有时间走完与图形系统相关的启动过程。在本章中，我们将走完图形系统的启动过程，并探索VirtualBox特定的硬件驱动程序。在本章结束时，我们将在VirtualBox上拥有一个相对完整的系统。本章我们将涵盖以下主题：
- en: OpenGL ES and graphics hardware initialization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES和图形硬件初始化
- en: Integration of VirtualBox Guest Additions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox Guest Additions的集成
- en: OpenGL ES and graphics hardware initialization
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES和图形硬件初始化
- en: 'In Android systems, the initialization of the graphics system is done by SurfaceFlinger.
    Besides the Gralloc HAL that we discussed in [Chapter 10](900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml),
    *Enabling Graphics*, another important part of graphics system initialization
    is the loading of OpenGL ES libraries. In our VirtualBox implementation, we use
    most of the HAL modules from Android-x86\. The graphics system support includes
    the following components:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统中，图形系统的初始化是由SurfaceFlinger完成的。除了我们在第10章中讨论的Gralloc HAL之外，*启用图形*是图形系统初始化的另一个重要部分，即加载OpenGL
    ES库。在我们的VirtualBox实现中，我们使用了Android-x86的大部分HAL模块。图形系统支持包括以下组件：
- en: Gralloc HAL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gralloc HAL
- en: Mesa lib for OpenGL ES
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesa库用于OpenGL ES
- en: uvesafb framebuffer driver or VirtualBox video driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uvesafb帧缓冲区驱动程序或VirtualBox视频驱动程序
- en: We have discussed Gralloc HAL in the last chapter. We will explore the loading
    of the OpenGL ES library and uvesafb framebuffer driver in this chapter. We will
    use the default uvesafb framebuffer driver in the introduction of graphics system
    initialization. We will also introduce how to use the native graphic driver from
    VirtualBox when we talk about the integration of VirtualBox Guest Additions later
    in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上章中讨论了Gralloc HAL。在本章中，我们将探讨OpenGL ES库和uvesafb帧缓冲区驱动程序的加载。在介绍图形系统初始化时，我们将使用默认的uvesafb帧缓冲区驱动程序。在后面讨论VirtualBox
    Guest Additions的集成时，我们还将介绍如何从VirtualBox中使用本地图形驱动程序。
- en: Loading OpenGL ES libraries
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载OpenGL ES库
- en: '**OpenGL ES** stands for **Open GL Embedded System**, which is a subset of
    OpenGL from Khronos. EGL is an interface between OpenGL ES and the underlying
    native platform. The API of EGL is supposed to be platform-agnostic, but the implementation
    of the EGL API is not.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL ES**代表**OpenGL嵌入式系统**，它是Khronos的OpenGL的一个子集。EGL是OpenGL ES和底层本地平台之间的接口。EGL的API应该是平台无关的，但EGL
    API的实现不是。'
- en: 'The implementation of OpenGL ES in Android includes the Java API and native
    implementation. These two parts can be found at:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android中OpenGL ES的实现包括Java API和本地实现。这两部分可以在以下位置找到：
- en: 'Java API: `$AOSP/frameworks/base/opengl`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API：`$AOSP/frameworks/base/opengl`
- en: 'OpenGL ES native: `$AOSP/frameworks/native/opengl`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES本地：`$AOSP/frameworks/native/opengl`
- en: These two parts of the OpenGL implementation depend on a vendor implementation
    to provide the full function of the OpenGL ES API. During the system start-up,
    the system will search for paths `/system/lib/egl` or `/vendor/lib/egl` to find
    the vendor OpenGL libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分OpenGL实现依赖于供应商实现来提供OpenGL ES API的完整功能。在系统启动过程中，系统将搜索`/system/lib/egl`或`/vendor/lib/egl`路径以找到供应商的OpenGL库。
- en: The OpenGL ES vendor libraries should follow the following naming conventions.
    If the vendor library is a single library, it should use the name as `libGLES_*.so`.
    In our case, the OpenGL ES library for VirtualBox is `libGLES_mesa.so`, which
    is provided as a single library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES供应商库应遵循以下命名约定。如果供应商库是一个单独的库，它应使用`libGLES_*.so`的名称。在我们的例子中，VirtualBox的OpenGL
    ES库是`libGLES_mesa.so`，它作为一个单独的库提供。
- en: 'If the vendor libraries are provided as separate libraries, they must be something
    like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果供应商库作为单独的库提供，它们必须类似于以下内容：
- en: '`/system/lib/egl/libEGL_*.so`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libEGL_*.so`'
- en: '`/system/lib/egl/libGLESv1_CM_*.so`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libGLESv1_CM_*.so`'
- en: '`/system/lib/egl/libGLESv2_*.so`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libGLESv2_*.so`'
- en: 'This is the case for the Android emulator hardware emulation libraries. We
    can find the following ones for the Android emulator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于 Android 模拟器的硬件仿真库。我们可以找到以下 Android 模拟器的库：
- en: '`/system/lib/egl/libEGL_emulation.so`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libEGL_emulation.so`'
- en: '`/system/lib/egl/libGLESv1_CM_emulation.so`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libGLESv1_CM_emulation.so`'
- en: '`/system/lib/egl/libGLESv2_emulation.so`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system/lib/egl/libGLESv2_emulation.so`'
- en: The vendor libraries are loaded during the `SurfaceFlinger` initialization.
    Before we go to the details about the start up process, let's have a look at the
    message from the debug log first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商库在 `SurfaceFlinger` 初始化期间加载。在我们深入探讨启动过程之前，让我们先看看调试日志中的消息。
- en: 'I removed the timestamp from the following log so that we can have a better
    format:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从下面的日志中移除了时间戳，以便我们有一个更好的格式：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, when the main thread of `SurfaceFlinger` is ready to run, it
    loads the `/system/lib/egl/libGLES_mesa.so` library during the x86vbox device
    boot up. After that, it loads and initializes the `gralloc.default.so` Gralloc
    module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当 `SurfaceFlinger` 的主线程准备运行时，它会在 x86vbox 设备启动期间加载 `/system/lib/egl/libGLES_mesa.so`
    库。之后，它加载并初始化 `gralloc.default.so` Gralloc 模块：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, `SurfaceFlinger` initializes the EGL library as the preceding log message.
    The EGL version in our environment is 1.4:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`SurfaceFlinger` 初始化 EGL 库，正如前面的日志消息所示。我们环境中的 EGL 版本是 1.4：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After EGL initialization, the OpenGL ES library is initialized, as we can see
    from the preceding log message. We can see that OpenGL ES 3.0 is supported by
    the Mesa library. The rendering engine is a software implementation using Gallium
    with `llvmpipe`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EGL 初始化之后，OpenGL ES 库被初始化，正如我们从前面的日志消息中可以看到的。我们可以看到 Mesa 库支持 OpenGL ES 3.0。渲染引擎是一个使用
    Gallium 和 `llvmpipe` 的软件实现。
- en: 'Each graphics hardware vendor usually has their own implementation of OpenGL.
    Mesa is an open source implementation of OpenGL. Mesa has multiple backends for
    OpenGL support. It can support both hardware and software implementation according
    to the hardware GPU. If you don''t have a hardware GPU, Mesa has three CPU-based
    implementations: swrast, softpipe, and llvmpipe. The one that we used in x86vbox
    is llvmpipe. There are two architectures for Mesa driver implementation. Gallium
    is the new architecture for the Mesa driver implementation.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形硬件供应商通常都有自己的 OpenGL 实现。Mesa 是 OpenGL 的开源实现。Mesa 为 OpenGL 提供了多个后端支持。它可以根据硬件
    GPU 支持硬件和软件实现。如果您没有硬件 GPU，Mesa 有三个基于 CPU 的实现：swrast、softpipe 和 llvmpipe。我们在 x86vbox
    中使用的是 llvmpipe。Mesa 驱动实现有两种架构。Gallium 是 Mesa 驱动实现的新架构。
- en: Analyzing the loading process
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析加载过程
- en: After we have a general introduction about OpenGL ES implementation in x86vbox
    (reuse from Android-x86), we will analyze the source code to have another level
    of understanding. Since the detail implementation of graphics systems and OpenGL
    ES is huge, we won't be able to cover them in a chapter. We will focus on the
    loading process of graphics systems and the OpenGL ES library in our analysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 x86vbox 中 OpenGL ES 实现进行一般介绍（重用自 Android-x86）之后，我们将分析源代码，以获得更深入的理解。由于图形系统和
    OpenGL ES 的详细实现非常庞大，我们无法在一个章节中涵盖它们。在我们的分析中，我们将专注于图形系统的加载过程和 OpenGL ES 库。
- en: 'Again, you may feel frustrated while we walk through the source code. The best
    way to help with this is to open your source code editor while you read this chapter.
    If you don''t have AOSP source code at hand, you can always refer to the following
    website:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当我们遍历源代码时，您可能会感到沮丧。帮助您最好的方法是，在阅读本章内容的同时打开您的源代码编辑器。如果您手头没有 AOSP 源代码，您始终可以参考以下网站：
- en: '[http://xref.opersys.com/](http://xref.opersys.com/)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://xref.opersys.com/](http://xref.opersys.com/)'
- en: You can just search for the function name that we discuss in this chapter to
    locate the source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需搜索本章中讨论的函数名，即可定位源代码。
- en: 'From the preceding debug log, we will start from the point where we see the
    first debug message related to the graphics system and `SurfaceFlinger`, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的调试日志中，我们将从看到第一个与图形系统和 `SurfaceFlinger` 相关的调试信息的位置开始，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first message is printed by the constructor of `SurfaceFlinger` and the
    second message is printed out from the `init` method of `SurfaceFlinger`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条信息是由 `SurfaceFlinger` 的构造函数打印的，第二条信息是从 `SurfaceFlinger` 的 `init` 方法打印出来的。
- en: 'The source code of `SurfaceFlinger` can be found at: `$AOSP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceFlinger` 的源代码可以在以下位置找到：`$AOSP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp`。'
- en: 'We will start our analysis from **SurfaceFlinger:init**, according to the flow
    shown in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**SurfaceFlinger:init**开始分析，根据以下图中所示的流程：
- en: '![](img/image_11_001.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_001.png)'
- en: Loading of OpenGL ES libraries
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES库的加载
- en: 'In `SurfaceFlinger:init`, as shown in the following code snippet, it calls
    the EGL function `eglGetDisplay` first. After that, it tries to create a hardware
    composer instance. With the instances of display `mEGLDisplay` and hardware composer
    `mHwc`, it creates a rendering engine using the underlying OpenGL ES implementation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SurfaceFlinger:init`中，如以下代码片段所示，它首先调用EGL函数`eglGetDisplay`。之后，它尝试创建一个硬件合成器实例。使用显示实例`mEGLDisplay`和硬件合成器`mHwc`，它使用底层的OpenGL
    ES实现创建了一个渲染引擎：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s analyze the EGL function `eglGetDisplay` first. The `eglGetDisplay`
    function is implemented in the `frameworks/native/opengl/libs/EGL/eglApi.cpp`
    file, as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先分析EGL函数`eglGetDisplay`。`eglGetDisplay`函数在`frameworks/native/opengl/libs/EGL/eglApi.cpp`文件中实现，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `eglGetDisplay`, it checks the index of display to be initialized first.
    In the current Android code, the `EGL_DEFAULT_DISPLAY` parameter is zero and the
    definition of `NUM_DISPLAYS` is 1\. This means it can only support one display
    in the current Android implementation. What does this mean here? For example,
    if you have a laptop, you can connect it to a projector. In this case, you can
    have two displays at the same time. Some new computers can even connect to three
    displays at the same time nowadays. After checking the number of displays, it
    calls the `egl_init_drivers` function to load the OpenGL ES libraries:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eglGetDisplay`函数中，它首先检查要初始化的显示索引。在当前的Android代码中，`EGL_DEFAULT_DISPLAY`参数为0，`NUM_DISPLAYS`的定义为1。这意味着当前Android实现只能支持一个显示。这里是什么意思呢？例如，如果你有一台笔记本电脑，你可以将其连接到投影仪。在这种情况下，你可以同时拥有两个显示。现在一些新电脑甚至可以同时连接三个显示。在检查显示数量后，它调用`egl_init_drivers`函数来加载OpenGL
    ES库：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `egl_init_drivers` function acquires a mutex and calls to another function,
    `egl_init_drivers_locked`, to load the OpenGL ES libraries. In the `egl_init_drivers_locked`
    function, it gets an instance of a `Loader` class, which is defined using the
    **singleton pattern**. After that, it initializes the global variable `gEGLImpl`,
    which is defined as the data structure `egl_connection_t`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`egl_init_drivers`函数获取一个互斥锁并调用另一个函数`egl_init_drivers_locked`来加载OpenGL ES库。在`egl_init_drivers_locked`函数中，它获取一个`Loader`类的实例，该类使用**单例模式**定义。之后，它初始化全局变量`gEGLImpl`，该变量定义为`egl_connection_t`数据结构：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `egl_connection_t` data structure, it defines the following fields:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`egl_connection_t`数据结构中，它定义了以下字段：
- en: '`dso`: This is a pointer that points to a `driver_t` data structure defined
    inside the `Loader` class. This `driver_t` data structure stores the handle of
    OpenGL ES libraries after they are loaded by the `Loader` class.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dso`: 这是一个指向`driver_t`数据结构的指针，该数据结构在`Loader`类内部定义。这个`driver_t`数据结构存储了`Loader`类加载后的OpenGL
    ES库的句柄。'
- en: '`hooks`: This is an array of the pointers of the `gl_hooks_t` data structure.
    The `gl_hooks_t` data structure is used to define all the function pointers of
    the OpenGL ES API. After the OpenGL ES libraries are loaded, the OpenGL ES functions
    inside the libraries will be initialized and assigned to the `hooks` field. There
    are two OpenGL ES versions that are defined in `enum { GLESv1_INDEX , GLESv2_INDEX
    }`. The `hooks[GLESv1_INDEX]` is used to store OpenGL ES version 1 APIs and it
    points to the `gHooks[GLESv1_INDEX]` global variable. The same is for `GLESv2_INDEX`.
    The list of OpenGL ES APIs can be found in the following file: `$AOSP/frameworks/native/opengl/libs/entries.in`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hooks`: 这是一个指向`gl_hooks_t`数据结构指针的数组。`gl_hooks_t`数据结构用于定义OpenGL ES API的所有函数指针。在OpenGL
    ES库加载后，库中的OpenGL ES函数将被初始化并分配给`hooks`字段。在`enum { GLESv1_INDEX , GLESv2_INDEX }`中定义了两个OpenGL
    ES版本。`hooks[GLESv1_INDEX]`用于存储OpenGL ES 1 API，并指向全局变量`gHooks[GLESv1_INDEX]`。对于`GLESv2_INDEX`也是同样的情况。OpenGL
    ES API的列表可以在以下文件中找到：`$AOSP/frameworks/native/opengl/libs/entries.in`'
- en: '`major` and `minor`: These two are used to store the EGL version.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`major`和`minor`: 这两个用于存储EGL版本。'
- en: '`egl`: This is defined as `egl_t`, which is used to store the EGL APIs. The
    list of EGL APIs can be found in the following file: `$AOSP/frameworks/native/opengl/libs/EGL/egl_entries.in`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`egl`: 这被定义为`egl_t`，用于存储EGL API。EGL API的列表可以在以下文件中找到：`$AOSP/frameworks/native/opengl/libs/EGL/egl_entries.in`'
- en: '`libEgl`, `libGles1`, and `libGles2`: These are the handles of OpenGL ES wrapper
    libraries. We will see the initialization of these libraries in a moment.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libEgl`、`libGles1`和`libGles2`：这些都是OpenGL ES包装库的句柄。我们稍后将看到这些库的初始化。'
- en: 'After the `cnx` data structure is initialized, it calls the `loader.open` function
    to load the libraries. Let''s look at the `loader.open` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cnx`数据结构初始化后，它调用`loader.open`函数来加载库。让我们看看`loader.open`函数：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `Loader::open`, it tries to load a single OpenGL ES library first. If it
    fails, it tries to load the separated libraries one by one. If the libraries are
    loaded successfully, it stores the handles to the `driver_t` data structure. We
    explained about `driver_t` previously when we talked about the `dso` field in
    the `egl_connection_t` data structure. The actual loading process is done in the
    `load_driver` function and we will look at it soon. After the OpenGL ES libraries
    are loaded, it also tries to load the wrapper libraries using the `load_wrapper`
    function. The `load_wrapper` function just calls the `dlopen` system call and
    returns the handle so we don't need to investigate it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Loader::open`中，它首先尝试加载单个OpenGL ES库。如果失败，它将逐个尝试加载分离的库。如果库加载成功，它将把句柄存储到`driver_t`数据结构中。我们之前在讨论`egl_connection_t`数据结构中的`dso`字段时解释了`driver_t`。实际的加载过程是在`load_driver`函数中完成的，我们很快就会看到它。在OpenGL
    ES库加载后，它还尝试使用`load_wrapper`函数加载包装库。`load_wrapper`函数只是调用`dlopen`系统调用并返回句柄，所以我们不需要调查它。
- en: Loading the driver
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载驱动程序
- en: 'Let''s analyze the `load_driver` function, which is the one that finds and
    loads the OpenGL ES user space driver:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`load_driver`函数，这是找到和加载OpenGL ES用户空间驱动程序的函数：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `load_driver` function, it defines a `MatchFile` inner class. It uses
    the `MatchFile::find` method to find the path of the libraries. The `load_driver`
    function has three parameters: `kind`, `cnx`, and `mask`. According to the kind
    of libraries, the parameter kind could be `GLES`, `EGL`, `GLESv1_CM`, or `GLESv2`.
    Once it gets the absolute path of a library, it calls the `dlopen` system function
    to open the shared library. The `mask` parameter is a bit map of the `kind` parameter.
    Using the `mask` parameter, it can initialize the `cnx` parameter according to
    the kind of library. As we mentioned before, the `cnx` parameter, which is an
    instance of `egl_connection_t`, has an `egl` field to store all the EGL function
    pointers. It has another field, `hooks[GLESv1_INDEX]/ hooks[GLESv2_INDEX]`, to
    store all OpenGL ES functions.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`load_driver`函数中，它定义了一个`MatchFile`内部类。它使用`MatchFile::find`方法来查找库的路径。`load_driver`函数有三个参数：`kind`、`cnx`和`mask`。根据库的类型，参数`kind`可以是`GLES`、`EGL`、`GLESv1_CM`或`GLESv2`。一旦它获取到库的绝对路径，它就调用`dlopen`系统函数来打开共享库。`mask`参数是`kind`参数的位图。使用`mask`参数，它可以根据库的类型初始化`cnx`参数。正如我们之前提到的，`cnx`参数，它是一个`egl_connection_t`实例，有一个`egl`字段来存储所有EGL函数指针。它还有一个字段，`hooks[GLESv1_INDEX]/hooks[GLESv2_INDEX]`，用于存储所有OpenGL
    ES函数。
- en: If the library type is EGL, it gets the address of the `eglGetProcAddress` function
    by first calling the `dlsym` system function. After that, it will loop through
    all the function names defined in the `egl_names` global variable to find out
    the addresses and store them in `cnx->egl`. During the process, it tries to get
    the address using the `dlsym` system function first. If the call to `dlsym` fails,
    it will try it again using the `eglGetProcAddress` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库类型是EGL，它首先通过调用`dlsym`系统函数来获取`eglGetProcAddress`函数的地址。之后，它将遍历在`egl_names`全局变量中定义的所有函数名称，以找出地址并将它们存储在`cnx->egl`中。在这个过程中，它首先尝试使用`dlsym`系统函数获取地址。如果`dlsym`调用失败，它将再次尝试使用`eglGetProcAddress`函数。
- en: If the library type is either `GLESv1_CM` or `GLESv2`, it calls another function,
    `init_api`, to initialize all OpenGL ES function pointers. In the `init_api` function,
    it will loop through all the function names defined in the `gl_names` global variable
    to find out the addresses and store them in `cnx->hooks[egl_connection_t::GLESv?_INDEX]->gl`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库类型是`GLESv1_CM`或`GLESv2`，它将调用另一个函数`init_api`来初始化所有OpenGL ES函数指针。在`init_api`函数中，它将遍历在`gl_names`全局变量中定义的所有函数名称，以找出地址并将它们存储在`cnx->hooks[egl_connection_t::GLESv?_INDEX]->gl`中。
- en: Now we have done all the initialization of the OpenGL ES user space drivers
    and we can use the `egl_connection_t` data structure to access all OpenGL ES vendor
    APIs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了OpenGL ES用户空间驱动程序的初始化，我们可以使用`egl_connection_t`数据结构来访问所有OpenGL ES供应商API。
- en: Creating the rendering engine
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建渲染引擎
- en: 'After the OpenGL ES vendor libraries are loaded, `SurfaceFlinger:init` will
    create the rendering engine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载OpenGL ES供应商库之后，`SurfaceFlinger:init`将创建渲染引擎：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside `RenderEngine::create`, it will call `RenderEngine::chooseEglConfig`,
    which will print out the debug message for EGL:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderEngine::create`内部，它将调用`RenderEngine::chooseEglConfig`，这将打印出EGL的调试信息：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the end of `RenderEngine::create`, it will print out the OpenGL ES initialization
    information as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderEngine::create`的末尾，它将打印出以下OpenGL ES初始化信息：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The uvesafb framebuffer driver
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uvesafb帧缓冲区驱动程序
- en: Th framebuffer driver is the third component that we need to support the graphics
    system for x86vbox. Since you may run VirtualBox on different Intel devices, they
    may use different graphics hardware, such as Nvidia, AMD, or Intel. To get the
    best performance in a virtualization environment, you may want to explore various
    GPU virtualization technologies, such as GPU passthrough, GPU sharing, GPU software
    emulation, and so on. To have a simple solution, we use the default solution from
    Android-x86, which is the uvesafb framebuffer driver.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区驱动程序是我们需要支持的x86vbox图形系统的第三个组件。由于您可能在不同的英特尔设备上运行VirtualBox，它们可能使用不同的图形硬件，例如Nvidia、AMD或英特尔。为了在虚拟化环境中获得最佳性能，您可能想探索各种GPU虚拟化技术，如GPU直通、GPU共享、GPU软件仿真等。为了有一个简单的解决方案，我们使用了Android-x86的默认解决方案，即uvesafb帧缓冲区驱动程序。
- en: What is uvesafb?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是uvesafb？
- en: The uvesafb is a user space VESA framebuffer driver that works with VESA 2.0-compliant
    graphic cards. VESA BIOS extensions provide the primary functionality of VESA
    standard through the BIOS interface. On Linux, uvesafb needs a user space daemon
    called `v86d` as a backend for kernel drivers that need to execute x86 BIOS code.
    Since BIOS code can only be executed in a controlled environment, the code executed
    by `v86d` can be run either in a fully software-emulated environment or a virtualized
    environment supported by the CPU. The `v86d` has been ported to Android by the
    Android-x86 project. It can be found at `$AOSP/external/v86d`. Since the `v86d`
    project needs additional system calls such as `ioperm` and `iopl`, the Android-x86
    project changed the bionic library to support these system calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: uvesafb是一个与VESA 2.0兼容的图形卡一起工作的用户空间VESA帧缓冲区驱动程序。VESA BIOS扩展通过BIOS接口提供了VESA标准的主要功能。在Linux上，uvesafb需要一个名为`v86d`的用户空间守护进程作为需要执行x86
    BIOS代码的内核驱动程序的后端。由于BIOS代码只能在受控环境中执行，因此`v86d`执行的代码可以在完全软件模拟的环境或由CPU支持的虚拟化环境中运行。Android-x86项目已经将`v86d`移植到Android。它可以在`$AOSP/external/v86d`找到。由于`v86d`项目需要额外的系统调用，如`ioperm`和`iopl`，Android-x86项目将bionic库更改为支持这些系统调用。
- en: 'You can refer to the following kernel document to find out more about uvesafb:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下内核文档以了解更多关于uvesafb的信息：
- en: '[https://www.kernel.org/doc/Documentation/fb/uvesafb.txt](https://www.kernel.org/doc/Documentation/fb/uvesafb.txt)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kernel.org/doc/Documentation/fb/uvesafb.txt](https://www.kernel.org/doc/Documentation/fb/uvesafb.txt)'
- en: Testing the uvesafb framebuffer driver
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试uvesafb帧缓冲区驱动程序
- en: Before we try to understand how uvesafb is loaded in our environment, we can
    test it using two framebuffer testing tools, `fbset` and `fbtest`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试了解uvesafb在我们环境中是如何加载之前，我们可以使用两个帧缓冲区测试工具`fbset`和`fbtest`来测试它。
- en: As we know, we can boot to a debug console using two stages boot of Android-x86
    from [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml), *Booting Up x86vbox
    Using PXE/NFS*. We can test uvesafb in the debug console with `fbset` and `fbtest`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，我们可以使用Android-x86的二级引导从[第9章](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml)，“使用PXE/NFS引导x86vbox”进行两阶段引导进入调试控制台。我们可以在调试控制台中用`fbset`和`fbtest`测试uvesafb。
- en: '`fbset` is a system tool to show or change the settings of the framebuffer
    device. You can refer to the help page of Linux commands to find out how to use
    `fbset`. In our environment, we use `busybox` in the first stage boot and we use
    `toybox` or `toolbox` in the Android environment. `fbset` is supported by `busybox`,
    so we can use it in the first stage or the second stage boot through `busybox`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbset`是一个显示或更改帧缓冲区设备设置的系统工具。您可以通过查看Linux命令的帮助页面来了解如何使用`fbset`。在我们的环境中，我们在第一阶段引导中使用`busybox`，在Android环境中使用`toybox`或`toolbox`。由于`fbset`由`busybox`支持，因此我们可以通过`busybox`在第一阶段或第二阶段引导中使用它。'
- en: '`fbtest` is a framebuffer test program that can be found at [https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git](https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`fbtest`是一个帧缓冲区测试程序，可以在[https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git](https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git)找到。'
- en: 'I cloned it from the kernel Git repository and ported it to the Android environment.
    The source code for Android can be found at GitHub via the following link:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我从内核Git仓库克隆了它，并将其移植到Android环境中。Android的源代码可以通过以下链接在GitHub上找到：
- en: '[https://github.com/shugaoye/fbtest](https://github.com/shugaoye/fbtest)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/shugaoye/fbtest](https://github.com/shugaoye/fbtest)'
- en: 'To build `fbtest`, we can get it from GitHub and build it in the AOSP build
    environment:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建`fbtest`，我们可以从GitHub获取它，并在AOSP构建环境中构建：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we set up the AOSP build environment, we can check out and build the
    `fbtest` source code using the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置好AOSP构建环境后，我们可以使用以下命令检出并构建`fbtest`源代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be aware that I changed the Makefile and that it depends on the AOSP environment
    variable `$OUT`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经修改了Makefile，并且它依赖于AOSP环境变量`$OUT`，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we look at the preceding `fbtest/Rules.make` Makefile, we use the `$OUT`
    environment variable to find the right AOSP build environment. After that, we
    can use prebuilt toolchains and the `bionic` library to build `fbtest`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前面的`fbtest/Rules.make` Makefile，我们使用`$OUT`环境变量来找到正确的AOSP构建环境。之后，我们可以使用预构建的工具链和`bionic`库来构建`fbtest`。
- en: After we build `fbtest`, we can copy it to the `$OUT/system/bin` folder so that
    we can use it in the test environment later. As we remember from [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml),
    *Booting Up x86vbox Using PXE/NFS*, we can boot to a debug console in the first
    stage boot using PXE/NFS. In this case, we can change and test `fbtest` without
    rebooting the x86vbox, since we can access the build result through NFS from x86vbox.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建`fbtest`后，我们可以将其复制到`$OUT/system/bin`文件夹，这样我们就可以在测试环境中稍后使用它。正如我们从[第9章](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml)，“使用PXE/NFS引导x86vbox”中记得的那样，我们可以使用PXE/NFS在第一阶段引导时引导到调试控制台。在这种情况下，我们可以更改并测试`fbtest`而不需要重新引导x86vbox，因为我们可以从x86vbox通过NFS访问构建结果。
- en: 'Let''s boot x86vbox to the debug console in the first stage boot and perform
    the tests. As we recall, we have a minimal embedded Linux environment in the debug
    console of the first stage boot. We have a built-in `busybox` available in this
    environment. Before we test the framebuffer device, we must load the `uvesafb`
    module manually, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第一阶段引导时引导x86vbox到调试控制台，并执行测试。正如我们回忆的那样，我们在第一阶段引导的调试控制台中有一个最小嵌入式Linux环境。在这个环境中我们有内置的`busybox`。在我们测试帧缓冲设备之前，我们必须手动加载`uvesafb`模块，如下面的截图所示：
- en: '![](img/image_11_002.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_002.png)'
- en: 'We use the following command to load the `uvesafb` module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令加载`uvesafb`模块：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the debug output, we can see that the underlying graphic hardware is `Oracle
    VM VirtualBox VBE Adapter`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试输出中，我们可以看到底层图形硬件是`Oracle VM VirtualBox VBE Adapter`。
- en: 'After the `uvesafb` module is loaded, we can find the `/dev/fb0` device. We
    can use `fbset` to change the settings of the framebuffer device. For example,
    we can switch to different supported resolutions as we want. Let''s just run the
    `fbset` command and see what happens. If we run `fbset` without any parameters,
    we can see the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载`uvesafb`模块后，我们可以找到`/dev/fb0`设备。我们可以使用`fbset`来更改帧缓冲设备设置。例如，我们可以根据需要切换到不同的支持分辨率。让我们运行`fbset`命令看看会发生什么。如果我们不带任何参数运行`fbset`，我们可以看到以下输出：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `fbset` is run without any parameters, it just prints out the current settings
    of the framebuffer device. As we can see from the output, if we load `uvesafb`
    without any parameters, the default resolution is 640 x 480 in 16-bit colors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不带任何参数运行`fbset`，它只会打印出帧缓冲设备的当前设置。正如我们从输出中可以看到的，如果我们不带任何参数加载`uvesafb`，默认分辨率为640
    x 480，16位颜色。
- en: 'We can try to change the resolution with the name of the resolution as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用分辨率的名称尝试更改分辨率，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We got an error message that tells us that the resolution is not defined in
    the `/etc/fb.modes` file. We need to create this file to change resolutions. We
    can add the following resolutions in `/etc/fb.modes` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个错误信息，告诉我们分辨率在`/etc/fb.modes`文件中未定义。我们需要创建此文件来更改分辨率。我们可以在`/etc/fb.modes`中添加以下分辨率，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can test the resolution change. If we run the following command, we
    can change to a higher resolution with true color:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试分辨率更改。如果我们运行以下命令，我们可以切换到具有真彩色的更高分辨率：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After we load the framebuffer driver and test the configuration changes, we
    can test the framebuffer by drawing something on the screen. Using the `fbtest`
    command that we built in this section, we can run a set of framebuffer test cases.
    First, let''s find out how many test cases `fbtest` can run:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加载帧缓冲驱动程序并测试配置更改后，我们可以通过在屏幕上绘制一些东西来测试帧缓冲。使用我们在本节中构建的 `fbtest` 命令，我们可以运行一系列帧缓冲测试用例。首先，让我们找出
    `fbtest` 可以运行多少个测试用例：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run `fbtest` with the `-l` option, it prints out the list of test cases
    available. We can see that we have 12 test cases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `fbtest` 中使用 `-l` 选项，它将打印出可用的测试用例列表。我们可以看到我们有 12 个测试用例：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As an example, we can run test case 002 and we will see the following screen.
    Feel free to test any of the preceding test cases yourself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以运行测试用例 002，我们将看到以下屏幕。您可以自由地测试任何前面的测试用例。
- en: '![](img/image_11_003.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![初始化 uvesafb 在 x86vbox](img/image_11_003.png)'
- en: Initializing uvesafb in x86vbox
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 x86vbox 中初始化 uvesafb
- en: 'The initialization of `uvesafb` in x86vbox is done in the start up script `init.sh`.
    If we recall the discussion on HAL initialization in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml),
    *Creating Your Own Device on VirtualBox*, we can see the following code in `init.sh`.
    We discussed the initialization of graphics HAL in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml),
    *Creating Your Own Device on VirtualBox* briefly, and we can look into the details
    now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86vbox 中初始化 `uvesafb` 是在启动脚本 `init.sh` 中完成的。如果我们回顾第 8 章[创建您的虚拟机设备](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)中关于
    HAL 初始化的讨论，我们可以看到 `init.sh` 中的以下代码。我们在第 8 章[创建您的虚拟机设备](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml)中简要讨论了图形
    HAL 的初始化，现在我们可以深入了解细节：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our current setup, let''s see what the content of `/proc/fb` is. We can
    check this from either the debug console or the adb console. Before a framebuffer
    device is initialized, the content of `/proc/fb` is empty. In our case, it is
    empty, since there is no framebuffer device available until the `init.sh` script
    is executed. If the output is empty, the `init.sh` script will call the `init_uvesafb`
    function to initialize `uvesafb`. After the framebuffer device is initialized,
    we can see the content of `/proc/fb` as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设置中，让我们看看 `/proc/fb` 的内容。我们可以从调试控制台或 adb 控制台来检查这一点。在帧缓冲设备初始化之前，`/proc/fb`
    的内容是空的。在我们的情况下，它是空的，因为没有帧缓冲设备可用，直到执行 `init.sh` 脚本。如果输出为空，`init.sh` 脚本将调用 `init_uvesafb`
    函数来初始化 `uvesafb`。在帧缓冲设备初始化后，我们可以看到 `/proc/fb` 的内容如下：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is a framebuffer device available before `init.sh` is called, `init_hal_gralloc`
    will set the `ro.hardware.gralloc` system property for DRM drivers. For the devices
    that `init_hal_gralloc` cannot handle, it will do nothing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用 `init.sh` 之前有帧缓冲设备可用，`init_hal_gralloc` 将为 DRM 驱动程序设置 `ro.hardware.gralloc`
    系统属性。对于 `init_hal_gralloc` 无法处理的设备，它将不执行任何操作。
- en: 'In `init_uvesafb`, the actual command to load `uvesafb` can be extended to
    the following one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init_uvesafb` 中，加载 `uvesafb` 的实际命令可以扩展到以下之一：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The options of `uvesafb` are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`uvesafb` 的选项有：'
- en: '`mtrr:n`: Set up memory type range registers for the framebuffer, where `n`
    can be:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtrr:n`: 为帧缓冲设置内存类型范围寄存器，其中 `n` 可以是：'
- en: '`0`: Disabled (equivalent to the `nomtrr` option)'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`: 禁用（相当于 `nomtrr` 选项）'
- en: '`3`: Write-combining (default)'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`: 写合并（默认）'
- en: The memory type range registers are a set of processor supplementary capabilities
    control registers in Intel processors. Write-combining allows bus write transfers
    to be combined into a larger transfer before bursting them over the bus. This
    can help to improve the graphics performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 内存类型范围寄存器是英特尔处理器中一组处理器补充功能控制寄存器。写合并允许将总线写传输组合成更大的传输，然后再在总线上爆发。这可以帮助提高图形性能。
- en: '`redraw`: Scroll by redrawing the affected part of the screen.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redraw`: 通过重新绘制受影响的屏幕部分来滚动。'
- en: '`mode_option`: Set the resolution to a supported one.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode_option`: 设置分辨率到一个支持的值。'
- en: 'After `uvesafb` is loaded, we can find all the supported resolutions using
    the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 `uvesafb` 之后，我们可以使用以下命令找到所有支持的分辨率：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Integrating VirtualBox Guest Additions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 VirtualBox Guest Additions
- en: Up to now, we can boot x86vbox to Android. What we can do further is integrate
    VirtualBox Guest Additions to x86vbox.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以启动 x86vbox 到 Android。我们可以进一步做的是将 VirtualBox Guest Additions 集成到 x86vbox
    中。
- en: VirtualBox is a virtualization environment. We can install a guest operating
    system as it is in VirtualBox. However, there are some limitations to working
    in this way. To run a guest operating system in a host environment, you may expect
    more things than just hardware virtualization. For example, you may find the mouse
    cursor to behave badly when you move between the host and guest system. You may
    want to share data between the hosts and guests easily, such as shared clipboard,
    shared folder, and so on. To meet these requirements, the host and guest need
    to know each other and have a way to talk to each other. In VirtualBox architecture,
    there is a component called **Host-Guest Communication Manager** (**HGCM**). On
    the host side, VirtualBox implements a service called HGCM service that can serve
    the requests from the guest. On the guest side, there are a few kernel drivers
    from VirtualBox that can be used to communicate to the host.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 是一个虚拟化环境。我们可以在 VirtualBox 中安装一个虚拟操作系统，就像它真的存在一样。然而，以这种方式工作有一些限制。在主机环境中运行虚拟操作系统时，你可能期望的不仅仅是硬件虚拟化。例如，当你在不同主机和虚拟系统之间移动鼠标光标时，你可能发现鼠标光标表现不佳。你可能希望轻松地在主机和虚拟机之间共享数据，例如共享剪贴板、共享文件夹等。为了满足这些需求，主机和虚拟机需要相互了解并有一种相互交流的方式。在
    VirtualBox 架构中，有一个称为 **主机-虚拟机通信管理器**（**HGCM**）的组件。在主机端，VirtualBox 实现了一个名为 HGCM
    服务的功能，可以响应虚拟机的请求。在虚拟机端，有几个来自 VirtualBox 的内核驱动程序，可以用来与主机通信。
- en: The additional features that VirtualBox provides for the host and guest integration
    are usually included in a package called **VirtualBox Extension Pack**. In the
    VirtualBox Extension Pack, it includes the necessary files for both the host side
    and the guest side. The VirtualBox Extension Pack can be download at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 为主机和虚拟机集成提供的附加功能通常包含在一个名为 **VirtualBox 扩展包**（**VirtualBox Extension
    Pack**）的包中。在 VirtualBox 扩展包中，它包括主机端和虚拟机端所需的所有文件。VirtualBox 扩展包可以从 [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    下载。
- en: 'For the guest side, there are binary tools and source code for device drivers,
    which are included in a separate distribution package called VirtualBox Guest
    Additions. There are separate VirtualBox Guest Additions for Windows, Linux, and
    OS X. There are no Guest Additions for Android. However, since Android uses the
    Linux kernel, we can build the kernel drivers for Android using the source code
    for Linux. After we install the VirtualBox Extension Pack, we can find an image
    file `VBoxGuestAdditions.iso`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于虚拟机端，有一个包含设备驱动程序二进制工具和源代码的单独分发包，称为 VirtualBox 虚拟机增强功能。有针对 Windows、Linux 和
    OS X 的单独 VirtualBox 虚拟机增强功能。没有针对 Android 的虚拟机增强功能。然而，由于 Android 使用 Linux 内核，我们可以使用
    Linux 的源代码构建 Android 的内核驱动程序。安装 VirtualBox 扩展包后，我们可以找到一个名为 `VBoxGuestAdditions.iso`
    的镜像文件，如下所示：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can extract this image file and can find the following files inside VirtualBox
    Guest Additions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提取这个镜像文件，并在 VirtualBox 虚拟机增强功能中找到以下文件：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two compressed files: `VBoxGuestAdditions-amd64.tar.bz2` and `VBoxGuestAdditions-x86.tar.bz2`.
    As we can see its content from the following screenshot, this is a list of folders
    and files of the Guest Additions for Intel x86 Linux guest:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个压缩文件：`VBoxGuestAdditions-amd64.tar.bz2` 和 `VBoxGuestAdditions-x86.tar.bz2`。如以下截图所示，这是为
    Intel x86 Linux 虚拟机提供的虚拟机增强功能的文件夹和文件列表：
- en: '![](img/image_11_004.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_004.png)'
- en: VirtualBox Guest Additions
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 虚拟机增强功能
- en: 'There are source codes for three drivers available in the Guest Additions:
    `vboxguest`, `vboxsf`, and `vboxvideo`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机增强功能中有三个驱动程序的源代码可用：`vboxguest`、`vboxsf` 和 `vboxvideo`：
- en: '`vboxguest`: This module provides the basic services in the guest operating
    system to communicate to the host.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vboxguest`: 这个模块为虚拟操作系统提供与主机通信的基本服务。'
- en: '`vboxsf`: This module is a kernel driver to provide the capability to share
    files between host and guest.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vboxsf`: 这个模块是一个内核驱动程序，用于在主机和虚拟机之间共享文件的能力。'
- en: '`vboxvideo`: This module is a video driver for the guest. With this driver,
    we can use graphics hardware acceleration through the host.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vboxvideo`: 这个模块是针对虚拟机的视频驱动程序。通过这个驱动程序，我们可以通过主机使用图形硬件加速。'
- en: We will build and integrate these three drivers to x86vbox.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建并将这三个驱动程序集成到 x86vbox 中。
- en: Building VirtualBox Guest Additions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 VirtualBox 虚拟机增强功能
- en: 'The only dependency of the drivers in Guest Additions is the kernel source
    code. It is very easy to build the drivers for Android. To build the Guest Additions,
    you can get the source code from your VirtualBox installation, or you can get
    a version from my GitHub as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Guest Additions 中的驱动程序的唯一依赖项是内核源代码。为 Android 构建驱动程序非常简单。要构建 Guest Additions，你可以从你的
    VirtualBox 安装中获取源代码，或者你可以从我的 GitHub 上获取一个版本，如下所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After we have built the drivers successfully, we can find the driver modules
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们成功构建驱动程序后，我们可以按照以下方式找到驱动模块：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can store the kernel modules in a `vbox` folder under our `x86vbox` device
    folder, so we can copy them to the filesystem in the build process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的 `x86vbox` 设备文件夹下的 `vbox` 文件夹中存储内核模块，因此我们可以在构建过程中将它们复制到文件系统中：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After we have the loadable modules of Guest Additions, we can add them to our
    x86vbox device Makefile `x86vbox.mk`, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得 Guest Additions 的可加载模块后，我们可以将它们添加到我们的 x86vbox 设备 Makefile `x86vbox.mk`
    中，如下所示：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These three modules will be copied to the `/system/vendor/vbox` folder in the
    system image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块将被复制到系统镜像中的 `/system/vendor/vbox` 文件夹。
- en: Integrating vboxsf
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 vboxsf
- en: With the loadable module `vboxsf.ko`, we have the capability to exchange files
    between the host and the guest at the runtime of the Android system. To create
    a shared folder between the host and guest, we need to load the `vboxsf.ko` module
    first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可加载模块 `vboxsf.ko`，我们能够在 Android 系统运行时在主机和虚拟机之间交换文件。要创建主机和虚拟机之间的共享文件夹，我们需要首先加载
    `vboxsf.ko` 模块。
- en: 'To use `vboxsf.ko`, we need a tool called `mount.vboxsf`, which can be used
    to mount a shared folder on the host filesystem to the Android filesystem. This
    `mount.vboxsf` tool is part of the utilities provided by VirtualBox Guest Additions.
    We put it under our x86vbox device folder as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `vboxsf.ko`，我们需要一个名为 `mount.vboxsf` 的工具，它可以用来将主机文件系统上的共享文件夹挂载到 Android 文件系统。这个
    `mount.vboxsf` 工具是 VirtualBox Guest Additions 提供的实用工具之一。我们将其放在我们的 x86vbox 设备文件夹中，如下所示：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It includes a C file and a header file. We created the following Android Makefile
    to build it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个 C 文件和一个头文件。我们创建了以下 Android Makefile 来构建它：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To include it in the system image, we also need to add it to the `x86vbox.mk`
    Makefile as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其包含在系统镜像中，我们还需要将其添加到 `x86vbox.mk` Makefile 中，如下所示：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to load `vboxsf.ko` during the system boot up, we need to add the
    loading of `vboxsf.ko` to the start up script in `initrd.img`. If we recall from
    [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging the Boot Up
    Process Using a Customized Ramdisk*, we discussed the init script in the `initrd.img`.
    The shell script function `load_modules` is called to load most of the device
    drivers in the first stage boot up. We can change this script to load VirtualBox
    device drivers as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在系统启动时加载 `vboxsf.ko`，我们需要将 `vboxsf.ko` 的加载添加到 `initrd.img` 中的启动脚本。如果我们回想一下
    [第 6 章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)，*使用自定义 Ramdisk 调试启动过程*，我们讨论了
    `initrd.img` 中的 init 脚本。shell 脚本函数 `load_modules` 被调用以在第一阶段启动时加载大部分设备驱动程序。我们可以更改此脚本以加载
    VirtualBox 设备驱动程序，如下所示：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We defined a `VBOX_GUEST_ADDITIONS` kernel parameter, which can be used to enable
    the loading of VirtualBox-specific device drivers. If this kernel parameter is
    defined, we will load both loadable modules, `vboxguest.ko` and `vboxsf.ko`. Another
    kernel parameter, `SDCARD`, is also defined so that we can mount the shared folder
    to be an external SD card storage. The `SDCARD` kernel parameter is used by the
    shell script function `mount_sdcard` as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `VBOX_GUEST_ADDITIONS` 内核参数，它可以用来启用加载 VirtualBox 特定设备驱动程序。如果定义了这个内核参数，我们将加载两个可加载模块，`vboxguest.ko`
    和 `vboxsf.ko`。另一个内核参数 `SDCARD` 也被定义，这样我们就可以将共享文件夹挂载为外部 SD 卡存储。`SDCARD` 内核参数被 shell
    脚本函数 `mount_sdcard` 使用。
- en: 'To define these two kernel parameters on the kernel command line, we need to
    change the PXE boot script at `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default` as
    follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在内核命令行上定义这两个内核参数，我们需要更改 `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default` 下的 PXE
    启动脚本，如下所示：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Pay attention to the two variables `SDCARD` and `VBOX_GUEST_ADDITIONS`. They
    are the two new kernel parameters that we added to support the loading of VirtualBox
    device drivers. To mount the shared folder, we add the following command in the
    script:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个变量 `SDCARD` 和 `VBOX_GUEST_ADDITIONS`。它们是我们添加的两个新内核参数，用于支持加载 VirtualBox 设备驱动程序。为了挂载共享文件夹，我们在脚本中添加以下命令：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first parameter to `mount.vboxsf` is the shared folder that we defined
    in the VirtualBox settings, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount.vboxsf`的第一个参数是我们定义在VirtualBox设置中的共享文件夹，如下面的截图所示：'
- en: '![](img/image_11_005.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_11_005.png)'
- en: With all the changes related to the shared folder, we can have a method that
    can be used to share data between the host and the guest very easily.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有与共享文件夹相关的更改，我们可以有一个可以用来在主机和客户机之间轻松共享数据的方法。
- en: Integrating vboxvideo
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成vboxvideo
- en: In the VirtualBox Guest Additions, there is another device driver that can be
    used in Android, which is `vboxvideo.ko`. This is a device driver for video hardware.
    It provides a much more powerful video driver compared to the uvesafb that we
    just discussed in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在VirtualBox的Guest Additions中，还有一个可以在Android上使用的设备驱动程序，即`vboxvideo.ko`。这是一个视频硬件的设备驱动程序。与本章中刚刚讨论的uvesafb相比，它提供了一个功能更强大的视频驱动程序。
- en: The uvesafb is a standard framebuffer driver based on VESA 2.0 standard and
    it does not support hardware acceleration on VirtualBox. The `vboxvideo.ko` is
    a DRM/DRI-based video driver with hardware acceleration support.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: uvesafb是基于VESA 2.0标准的标准帧缓冲驱动程序，它不支持在VirtualBox上的硬件加速。`vboxvideo.ko`是一个支持硬件加速的基于DRM/DRI的视频驱动程序。
- en: '**Direct Rendering Infrastructure** (**DRI**) is a new architecture of the
    X Window system on the Linux platform to allow *X* clients to talk to the graphics
    hardware directly. **Direct Rendering Manager** (**DRM**) is the kernel side of
    the DRI architecture.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接渲染基础设施**（**DRI**）是Linux平台上X Window系统的新架构，允许*X*客户端直接与图形硬件通信。**直接渲染管理器**（**DRM**）是DRI架构的内核部分。'
- en: 'The Android-x86 project is the first open source project that brought Mesa/DRM
    to the Android platform. This is an open source OpenGL ES implementation for the
    supported graphics hardware. With the following components, we should be able
    to support hardware acceleration for OpenGL ES on Android:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Android-x86项目是第一个将Mesa/DRM引入Android平台的开源项目。这是一个针对支持的图形硬件的开源OpenGL ES实现。通过以下组件，我们应该能够支持Android上的OpenGL
    ES的硬件加速：
- en: '`external_libdrm`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external_libdrm`'
- en: '`external_mesa`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external_mesa`'
- en: '`external_drm_gralloc`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external_drm_gralloc`'
- en: We have the DRM driver with `vboxvideo` on VirtualBox, but the related implementation
    still needs to add to `external_mesa` and `external_drm_gralloc` to support OpenGL
    ES using the host GPU.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在VirtualBox上已经有了`vboxvideo`的DRM驱动程序，但相关的实现仍需要添加到`external_mesa`和`external_drm_gralloc`中，以支持使用主机GPU的OpenGL
    ES。
- en: Without the VirtualBox-specific implementation in `external_mesa` and `external_drm_gralloc`,
    we can only use the same software-based implementation in Mesa for OpenGL ES and
    the default Gralloc module, `gralloc.default.so`. This is why most VirtualBox-based
    emulator solutions such as Genymotion, Andy, or AMI DuOS are still using hardware
    GPU emulation, which is similar to the one we discussed in the *Overview of hardware
    GLES emulation* section in [Chapter 10](900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml),
    *Enabling Graphics*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`external_mesa`和`external_drm_gralloc`中没有针对VirtualBox的特定实现，我们只能使用Mesa的相同基于软件的实现来支持OpenGL
    ES和默认的Gralloc模块`gralloc.default.so`。这就是为什么大多数基于VirtualBox的模拟器解决方案，如Genymotion、Andy或AMI
    DuOS，仍然在使用硬件GPU模拟，这与我们在第10章“启用图形”部分中讨论的*硬件GLES模拟概述*中的类似。
- en: 'To load `vboxvideo.ko`, we need to add these additional three lines in `load_modules`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`vboxvideo.ko`，我们需要在`load_modules`中添加以下这三行：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ttm` and `drm_kms_helper` kernel modules are two kernel modules needed
    by `vboxvideo.ko`. We also use a `VBOX_VIDEO_DRIVER` kernel parameter to configure
    the loading of `vboxvideo.ko`. With this kernel parameter, we can switch between
    the uvesafb framebuffer and the VirtualBox framebuffer. After the system boot
    up, we can see the following log message. We can see that `vboxvideo` is loaded
    successfully:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttm`和`drm_kms_helper`内核模块是`vboxvideo.ko`所需的两个内核模块。我们还使用`VBOX_VIDEO_DRIVER`内核参数来配置`vboxvideo.ko`的加载。使用这个内核参数，我们可以在uvesafb帧缓冲和VirtualBox帧缓冲之间切换。系统启动后，我们可以看到以下日志消息。我们可以看到`vboxvideo`已成功加载：'
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the log message, we can see that a `vboxdrmfb` framebuffer device is created
    by `vboxvideo`. We can check the framebuffer settings using `fbset` as we did
    before. We can see that the hardware acceleration is set to true for `vboxdrmfb`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志消息中，我们可以看到`vboxvideo`创建了一个`vboxdrmfb`帧缓冲设备。我们可以使用`fbset`来检查帧缓冲设置，就像我们之前做的那样。我们可以看到，对于`vboxdrmfb`，硬件加速被设置为true：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also check the output from `/proc/fb`. Since the output is `0 vboxdrmfb`,
    the `init_hal_gralloc` shell function in `init.sh` won''t load `uvesafb`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检查 `/proc/fb` 的输出。由于输出是 `0 vboxdrmfb`，`init.sh` 中的 `init_hal_gralloc` 脚本函数不会加载
    `uvesafb`：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this setup, we can launch x86vbox using the `vboxvideo` driver instead
    of `uvesafb`. As I mentioned, there is still a lot of work that needs to be done
    before we can fully utilize all the potential capabilities from `vboxvideo`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以使用 `vboxvideo` 驱动程序而不是 `uvesafb` 来启动 x86vbox。正如我提到的，在我们能够充分利用 `vboxvideo`
    的所有潜在功能之前，还有很多工作要做。
- en: Building and testing images with VirtualBox Guest Additions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VirtualBox Guest Additions 构建和测试镜像
- en: 'To build and test the image in this chapter, we can use the `repo` tool to
    retrieve the source code in this chapter as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和测试本章中的镜像，我们可以使用 `repo` 工具检索本章中的源代码，如下所示：
- en: 'We can get the source code from GitHub and AOSP using the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从 GitHub 和 AOSP 获取源代码：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After we get the source code for this chapter, we can set the environment and
    build the system as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取本章的源代码后，我们可以设置环境和构建系统，如下所示：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To build `initrd.img`, we can run the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `initrd.img`，我们可以运行以下命令：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the start up process of graphics systems. This includes
    the OpenGL ES libraries, Gralloc module, and device driver. We discussed the Gralloc
    module in the last chapter. In this chapter, we analyzed another two components,
    OpenGL ES libraries and the framebuffer driver. With all this knowledge in mind,
    we integrated the drivers from VirtualBox Guest Additions to the x86vbox device.
    In the next chapter, we will start to work on another project to explore how recovery
    works in Android systems.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了图形系统的启动过程。这包括 OpenGL ES 库、Gralloc 模块和设备驱动程序。我们在上一章中讨论了 Gralloc 模块。在本章中，我们分析了另外两个组件，即
    OpenGL ES 库和帧缓冲区驱动程序。在掌握所有这些知识的基础上，我们将来自 VirtualBox Guest Additions 的驱动程序集成到了
    x86vbox 设备中。在下一章中，我们将开始另一个项目，以探索 Android 系统中恢复功能的工作原理。
