- en: Enabling VirtualBox-Specific Hardware Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we did a deep analysis of Android Gralloc HAL modules.
    We analyzed the default Gralloc module and the hardware GPU emulation Gralloc
    HAL for the Android emulator. We don''t have time to walk through the boot up
    process related to the graphics system yet. In this chapter, we will walk through
    the boot up process of the graphics system and explore the VirtualBox-specific
    hardware drivers. At the end of this chapter, we will have a relatively complete
    system on VirtualBox. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES and graphics hardware initialization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of VirtualBox Guest Additions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES and graphics hardware initialization
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android systems, the initialization of the graphics system is done by SurfaceFlinger.
    Besides the Gralloc HAL that we discussed in [Chapter 10](900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml),
    *Enabling Graphics*, another important part of graphics system initialization
    is the loading of OpenGL ES libraries. In our VirtualBox implementation, we use
    most of the HAL modules from Android-x86\. The graphics system support includes
    the following components:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Gralloc HAL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesa lib for OpenGL ES
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uvesafb framebuffer driver or VirtualBox video driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have discussed Gralloc HAL in the last chapter. We will explore the loading
    of the OpenGL ES library and uvesafb framebuffer driver in this chapter. We will
    use the default uvesafb framebuffer driver in the introduction of graphics system
    initialization. We will also introduce how to use the native graphic driver from
    VirtualBox when we talk about the integration of VirtualBox Guest Additions later
    in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Loading OpenGL ES libraries
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OpenGL ES** stands for **Open GL Embedded System**, which is a subset of
    OpenGL from Khronos. EGL is an interface between OpenGL ES and the underlying
    native platform. The API of EGL is supposed to be platform-agnostic, but the implementation
    of the EGL API is not.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of OpenGL ES in Android includes the Java API and native
    implementation. These two parts can be found at:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Java API: `$AOSP/frameworks/base/opengl`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenGL ES native: `$AOSP/frameworks/native/opengl`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two parts of the OpenGL implementation depend on a vendor implementation
    to provide the full function of the OpenGL ES API. During the system start-up,
    the system will search for paths `/system/lib/egl` or `/vendor/lib/egl` to find
    the vendor OpenGL libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The OpenGL ES vendor libraries should follow the following naming conventions.
    If the vendor library is a single library, it should use the name as `libGLES_*.so`.
    In our case, the OpenGL ES library for VirtualBox is `libGLES_mesa.so`, which
    is provided as a single library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'If the vendor libraries are provided as separate libraries, they must be something
    like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libEGL_*.so`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libGLESv1_CM_*.so`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libGLESv2_*.so`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the case for the Android emulator hardware emulation libraries. We
    can find the following ones for the Android emulator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libEGL_emulation.so`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libGLESv1_CM_emulation.so`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/system/lib/egl/libGLESv2_emulation.so`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vendor libraries are loaded during the `SurfaceFlinger` initialization.
    Before we go to the details about the start up process, let's have a look at the
    message from the debug log first.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'I removed the timestamp from the following log so that we can have a better
    format:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, when the main thread of `SurfaceFlinger` is ready to run, it
    loads the `/system/lib/egl/libGLES_mesa.so` library during the x86vbox device
    boot up. After that, it loads and initializes the `gralloc.default.so` Gralloc
    module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, `SurfaceFlinger` initializes the EGL library as the preceding log message.
    The EGL version in our environment is 1.4:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After EGL initialization, the OpenGL ES library is initialized, as we can see
    from the preceding log message. We can see that OpenGL ES 3.0 is supported by
    the Mesa library. The rendering engine is a software implementation using Gallium
    with `llvmpipe`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Each graphics hardware vendor usually has their own implementation of OpenGL.
    Mesa is an open source implementation of OpenGL. Mesa has multiple backends for
    OpenGL support. It can support both hardware and software implementation according
    to the hardware GPU. If you don''t have a hardware GPU, Mesa has three CPU-based
    implementations: swrast, softpipe, and llvmpipe. The one that we used in x86vbox
    is llvmpipe. There are two architectures for Mesa driver implementation. Gallium
    is the new architecture for the Mesa driver implementation.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the loading process
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have a general introduction about OpenGL ES implementation in x86vbox
    (reuse from Android-x86), we will analyze the source code to have another level
    of understanding. Since the detail implementation of graphics systems and OpenGL
    ES is huge, we won't be able to cover them in a chapter. We will focus on the
    loading process of graphics systems and the OpenGL ES library in our analysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you may feel frustrated while we walk through the source code. The best
    way to help with this is to open your source code editor while you read this chapter.
    If you don''t have AOSP source code at hand, you can always refer to the following
    website:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[http://xref.opersys.com/](http://xref.opersys.com/)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: You can just search for the function name that we discuss in this chapter to
    locate the source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding debug log, we will start from the point where we see the
    first debug message related to the graphics system and `SurfaceFlinger`, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first message is printed by the constructor of `SurfaceFlinger` and the
    second message is printed out from the `init` method of `SurfaceFlinger`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of `SurfaceFlinger` can be found at: `$AOSP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our analysis from **SurfaceFlinger:init**, according to the flow
    shown in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_001.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Loading of OpenGL ES libraries
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SurfaceFlinger:init`, as shown in the following code snippet, it calls
    the EGL function `eglGetDisplay` first. After that, it tries to create a hardware
    composer instance. With the instances of display `mEGLDisplay` and hardware composer
    `mHwc`, it creates a rendering engine using the underlying OpenGL ES implementation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s analyze the EGL function `eglGetDisplay` first. The `eglGetDisplay`
    function is implemented in the `frameworks/native/opengl/libs/EGL/eglApi.cpp`
    file, as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `eglGetDisplay`, it checks the index of display to be initialized first.
    In the current Android code, the `EGL_DEFAULT_DISPLAY` parameter is zero and the
    definition of `NUM_DISPLAYS` is 1\. This means it can only support one display
    in the current Android implementation. What does this mean here? For example,
    if you have a laptop, you can connect it to a projector. In this case, you can
    have two displays at the same time. Some new computers can even connect to three
    displays at the same time nowadays. After checking the number of displays, it
    calls the `egl_init_drivers` function to load the OpenGL ES libraries:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `egl_init_drivers` function acquires a mutex and calls to another function,
    `egl_init_drivers_locked`, to load the OpenGL ES libraries. In the `egl_init_drivers_locked`
    function, it gets an instance of a `Loader` class, which is defined using the
    **singleton pattern**. After that, it initializes the global variable `gEGLImpl`,
    which is defined as the data structure `egl_connection_t`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `egl_connection_t` data structure, it defines the following fields:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`dso`: This is a pointer that points to a `driver_t` data structure defined
    inside the `Loader` class. This `driver_t` data structure stores the handle of
    OpenGL ES libraries after they are loaded by the `Loader` class.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hooks`: This is an array of the pointers of the `gl_hooks_t` data structure.
    The `gl_hooks_t` data structure is used to define all the function pointers of
    the OpenGL ES API. After the OpenGL ES libraries are loaded, the OpenGL ES functions
    inside the libraries will be initialized and assigned to the `hooks` field. There
    are two OpenGL ES versions that are defined in `enum { GLESv1_INDEX , GLESv2_INDEX
    }`. The `hooks[GLESv1_INDEX]` is used to store OpenGL ES version 1 APIs and it
    points to the `gHooks[GLESv1_INDEX]` global variable. The same is for `GLESv2_INDEX`.
    The list of OpenGL ES APIs can be found in the following file: `$AOSP/frameworks/native/opengl/libs/entries.in`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`major` and `minor`: These two are used to store the EGL version.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`egl`: This is defined as `egl_t`, which is used to store the EGL APIs. The
    list of EGL APIs can be found in the following file: `$AOSP/frameworks/native/opengl/libs/EGL/egl_entries.in`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libEgl`, `libGles1`, and `libGles2`: These are the handles of OpenGL ES wrapper
    libraries. We will see the initialization of these libraries in a moment.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the `cnx` data structure is initialized, it calls the `loader.open` function
    to load the libraries. Let''s look at the `loader.open` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `Loader::open`, it tries to load a single OpenGL ES library first. If it
    fails, it tries to load the separated libraries one by one. If the libraries are
    loaded successfully, it stores the handles to the `driver_t` data structure. We
    explained about `driver_t` previously when we talked about the `dso` field in
    the `egl_connection_t` data structure. The actual loading process is done in the
    `load_driver` function and we will look at it soon. After the OpenGL ES libraries
    are loaded, it also tries to load the wrapper libraries using the `load_wrapper`
    function. The `load_wrapper` function just calls the `dlopen` system call and
    returns the handle so we don't need to investigate it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Loading the driver
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s analyze the `load_driver` function, which is the one that finds and
    loads the OpenGL ES user space driver:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `load_driver` function, it defines a `MatchFile` inner class. It uses
    the `MatchFile::find` method to find the path of the libraries. The `load_driver`
    function has three parameters: `kind`, `cnx`, and `mask`. According to the kind
    of libraries, the parameter kind could be `GLES`, `EGL`, `GLESv1_CM`, or `GLESv2`.
    Once it gets the absolute path of a library, it calls the `dlopen` system function
    to open the shared library. The `mask` parameter is a bit map of the `kind` parameter.
    Using the `mask` parameter, it can initialize the `cnx` parameter according to
    the kind of library. As we mentioned before, the `cnx` parameter, which is an
    instance of `egl_connection_t`, has an `egl` field to store all the EGL function
    pointers. It has another field, `hooks[GLESv1_INDEX]/ hooks[GLESv2_INDEX]`, to
    store all OpenGL ES functions.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If the library type is EGL, it gets the address of the `eglGetProcAddress` function
    by first calling the `dlsym` system function. After that, it will loop through
    all the function names defined in the `egl_names` global variable to find out
    the addresses and store them in `cnx->egl`. During the process, it tries to get
    the address using the `dlsym` system function first. If the call to `dlsym` fails,
    it will try it again using the `eglGetProcAddress` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If the library type is either `GLESv1_CM` or `GLESv2`, it calls another function,
    `init_api`, to initialize all OpenGL ES function pointers. In the `init_api` function,
    it will loop through all the function names defined in the `gl_names` global variable
    to find out the addresses and store them in `cnx->hooks[egl_connection_t::GLESv?_INDEX]->gl`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Now we have done all the initialization of the OpenGL ES user space drivers
    and we can use the `egl_connection_t` data structure to access all OpenGL ES vendor
    APIs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Creating the rendering engine
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the OpenGL ES vendor libraries are loaded, `SurfaceFlinger:init` will
    create the rendering engine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside `RenderEngine::create`, it will call `RenderEngine::chooseEglConfig`,
    which will print out the debug message for EGL:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the end of `RenderEngine::create`, it will print out the OpenGL ES initialization
    information as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The uvesafb framebuffer driver
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Th framebuffer driver is the third component that we need to support the graphics
    system for x86vbox. Since you may run VirtualBox on different Intel devices, they
    may use different graphics hardware, such as Nvidia, AMD, or Intel. To get the
    best performance in a virtualization environment, you may want to explore various
    GPU virtualization technologies, such as GPU passthrough, GPU sharing, GPU software
    emulation, and so on. To have a simple solution, we use the default solution from
    Android-x86, which is the uvesafb framebuffer driver.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: What is uvesafb?
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The uvesafb is a user space VESA framebuffer driver that works with VESA 2.0-compliant
    graphic cards. VESA BIOS extensions provide the primary functionality of VESA
    standard through the BIOS interface. On Linux, uvesafb needs a user space daemon
    called `v86d` as a backend for kernel drivers that need to execute x86 BIOS code.
    Since BIOS code can only be executed in a controlled environment, the code executed
    by `v86d` can be run either in a fully software-emulated environment or a virtualized
    environment supported by the CPU. The `v86d` has been ported to Android by the
    Android-x86 project. It can be found at `$AOSP/external/v86d`. Since the `v86d`
    project needs additional system calls such as `ioperm` and `iopl`, the Android-x86
    project changed the bionic library to support these system calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refer to the following kernel document to find out more about uvesafb:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.kernel.org/doc/Documentation/fb/uvesafb.txt](https://www.kernel.org/doc/Documentation/fb/uvesafb.txt)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Testing the uvesafb framebuffer driver
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we try to understand how uvesafb is loaded in our environment, we can
    test it using two framebuffer testing tools, `fbset` and `fbtest`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: As we know, we can boot to a debug console using two stages boot of Android-x86
    from [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml), *Booting Up x86vbox
    Using PXE/NFS*. We can test uvesafb in the debug console with `fbset` and `fbtest`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`fbset` is a system tool to show or change the settings of the framebuffer
    device. You can refer to the help page of Linux commands to find out how to use
    `fbset`. In our environment, we use `busybox` in the first stage boot and we use
    `toybox` or `toolbox` in the Android environment. `fbset` is supported by `busybox`,
    so we can use it in the first stage or the second stage boot through `busybox`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '`fbtest` is a framebuffer test program that can be found at [https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git](https://git.kernel.org/pub/scm/linux/kernel/git/geert/fbtest.git).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'I cloned it from the kernel Git repository and ported it to the Android environment.
    The source code for Android can be found at GitHub via the following link:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/shugaoye/fbtest](https://github.com/shugaoye/fbtest)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To build `fbtest`, we can get it from GitHub and build it in the AOSP build
    environment:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we set up the AOSP build environment, we can check out and build the
    `fbtest` source code using the following commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be aware that I changed the Makefile and that it depends on the AOSP environment
    variable `$OUT`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we look at the preceding `fbtest/Rules.make` Makefile, we use the `$OUT`
    environment variable to find the right AOSP build environment. After that, we
    can use prebuilt toolchains and the `bionic` library to build `fbtest`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: After we build `fbtest`, we can copy it to the `$OUT/system/bin` folder so that
    we can use it in the test environment later. As we remember from [Chapter 9](c8d10155-cc8e-4b8c-a5e0-f359520c894a.xhtml),
    *Booting Up x86vbox Using PXE/NFS*, we can boot to a debug console in the first
    stage boot using PXE/NFS. In this case, we can change and test `fbtest` without
    rebooting the x86vbox, since we can access the build result through NFS from x86vbox.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s boot x86vbox to the debug console in the first stage boot and perform
    the tests. As we recall, we have a minimal embedded Linux environment in the debug
    console of the first stage boot. We have a built-in `busybox` available in this
    environment. Before we test the framebuffer device, we must load the `uvesafb`
    module manually, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_002.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'We use the following command to load the `uvesafb` module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the debug output, we can see that the underlying graphic hardware is `Oracle
    VM VirtualBox VBE Adapter`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `uvesafb` module is loaded, we can find the `/dev/fb0` device. We
    can use `fbset` to change the settings of the framebuffer device. For example,
    we can switch to different supported resolutions as we want. Let''s just run the
    `fbset` command and see what happens. If we run `fbset` without any parameters,
    we can see the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `fbset` is run without any parameters, it just prints out the current settings
    of the framebuffer device. As we can see from the output, if we load `uvesafb`
    without any parameters, the default resolution is 640 x 480 in 16-bit colors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to change the resolution with the name of the resolution as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We got an error message that tells us that the resolution is not defined in
    the `/etc/fb.modes` file. We need to create this file to change resolutions. We
    can add the following resolutions in `/etc/fb.modes` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can test the resolution change. If we run the following command, we
    can change to a higher resolution with true color:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After we load the framebuffer driver and test the configuration changes, we
    can test the framebuffer by drawing something on the screen. Using the `fbtest`
    command that we built in this section, we can run a set of framebuffer test cases.
    First, let''s find out how many test cases `fbtest` can run:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run `fbtest` with the `-l` option, it prints out the list of test cases
    available. We can see that we have 12 test cases:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As an example, we can run test case 002 and we will see the following screen.
    Feel free to test any of the preceding test cases yourself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_003.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Initializing uvesafb in x86vbox
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The initialization of `uvesafb` in x86vbox is done in the start up script `init.sh`.
    If we recall the discussion on HAL initialization in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml),
    *Creating Your Own Device on VirtualBox*, we can see the following code in `init.sh`.
    We discussed the initialization of graphics HAL in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml),
    *Creating Your Own Device on VirtualBox* briefly, and we can look into the details
    now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our current setup, let''s see what the content of `/proc/fb` is. We can
    check this from either the debug console or the adb console. Before a framebuffer
    device is initialized, the content of `/proc/fb` is empty. In our case, it is
    empty, since there is no framebuffer device available until the `init.sh` script
    is executed. If the output is empty, the `init.sh` script will call the `init_uvesafb`
    function to initialize `uvesafb`. After the framebuffer device is initialized,
    we can see the content of `/proc/fb` as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is a framebuffer device available before `init.sh` is called, `init_hal_gralloc`
    will set the `ro.hardware.gralloc` system property for DRM drivers. For the devices
    that `init_hal_gralloc` cannot handle, it will do nothing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'In `init_uvesafb`, the actual command to load `uvesafb` can be extended to
    the following one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The options of `uvesafb` are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`mtrr:n`: Set up memory type range registers for the framebuffer, where `n`
    can be:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: Disabled (equivalent to the `nomtrr` option)'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: Write-combining (default)'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory type range registers are a set of processor supplementary capabilities
    control registers in Intel processors. Write-combining allows bus write transfers
    to be combined into a larger transfer before bursting them over the bus. This
    can help to improve the graphics performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`redraw`: Scroll by redrawing the affected part of the screen.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode_option`: Set the resolution to a supported one.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After `uvesafb` is loaded, we can find all the supported resolutions using
    the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Integrating VirtualBox Guest Additions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we can boot x86vbox to Android. What we can do further is integrate
    VirtualBox Guest Additions to x86vbox.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox is a virtualization environment. We can install a guest operating
    system as it is in VirtualBox. However, there are some limitations to working
    in this way. To run a guest operating system in a host environment, you may expect
    more things than just hardware virtualization. For example, you may find the mouse
    cursor to behave badly when you move between the host and guest system. You may
    want to share data between the hosts and guests easily, such as shared clipboard,
    shared folder, and so on. To meet these requirements, the host and guest need
    to know each other and have a way to talk to each other. In VirtualBox architecture,
    there is a component called **Host-Guest Communication Manager** (**HGCM**). On
    the host side, VirtualBox implements a service called HGCM service that can serve
    the requests from the guest. On the guest side, there are a few kernel drivers
    from VirtualBox that can be used to communicate to the host.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The additional features that VirtualBox provides for the host and guest integration
    are usually included in a package called **VirtualBox Extension Pack**. In the
    VirtualBox Extension Pack, it includes the necessary files for both the host side
    and the guest side. The VirtualBox Extension Pack can be download at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'For the guest side, there are binary tools and source code for device drivers,
    which are included in a separate distribution package called VirtualBox Guest
    Additions. There are separate VirtualBox Guest Additions for Windows, Linux, and
    OS X. There are no Guest Additions for Android. However, since Android uses the
    Linux kernel, we can build the kernel drivers for Android using the source code
    for Linux. After we install the VirtualBox Extension Pack, we can find an image
    file `VBoxGuestAdditions.iso`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can extract this image file and can find the following files inside VirtualBox
    Guest Additions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two compressed files: `VBoxGuestAdditions-amd64.tar.bz2` and `VBoxGuestAdditions-x86.tar.bz2`.
    As we can see its content from the following screenshot, this is a list of folders
    and files of the Guest Additions for Intel x86 Linux guest:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_004.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: VirtualBox Guest Additions
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'There are source codes for three drivers available in the Guest Additions:
    `vboxguest`, `vboxsf`, and `vboxvideo`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`vboxguest`: This module provides the basic services in the guest operating
    system to communicate to the host.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vboxsf`: This module is a kernel driver to provide the capability to share
    files between host and guest.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vboxvideo`: This module is a video driver for the guest. With this driver,
    we can use graphics hardware acceleration through the host.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build and integrate these three drivers to x86vbox.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Building VirtualBox Guest Additions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only dependency of the drivers in Guest Additions is the kernel source
    code. It is very easy to build the drivers for Android. To build the Guest Additions,
    you can get the source code from your VirtualBox installation, or you can get
    a version from my GitHub as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After we have built the drivers successfully, we can find the driver modules
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can store the kernel modules in a `vbox` folder under our `x86vbox` device
    folder, so we can copy them to the filesystem in the build process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After we have the loadable modules of Guest Additions, we can add them to our
    x86vbox device Makefile `x86vbox.mk`, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These three modules will be copied to the `/system/vendor/vbox` folder in the
    system image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Integrating vboxsf
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the loadable module `vboxsf.ko`, we have the capability to exchange files
    between the host and the guest at the runtime of the Android system. To create
    a shared folder between the host and guest, we need to load the `vboxsf.ko` module
    first.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `vboxsf.ko`, we need a tool called `mount.vboxsf`, which can be used
    to mount a shared folder on the host filesystem to the Android filesystem. This
    `mount.vboxsf` tool is part of the utilities provided by VirtualBox Guest Additions.
    We put it under our x86vbox device folder as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It includes a C file and a header file. We created the following Android Makefile
    to build it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To include it in the system image, we also need to add it to the `x86vbox.mk`
    Makefile as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In order to load `vboxsf.ko` during the system boot up, we need to add the
    loading of `vboxsf.ko` to the start up script in `initrd.img`. If we recall from
    [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml), *Debugging the Boot Up
    Process Using a Customized Ramdisk*, we discussed the init script in the `initrd.img`.
    The shell script function `load_modules` is called to load most of the device
    drivers in the first stage boot up. We can change this script to load VirtualBox
    device drivers as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We defined a `VBOX_GUEST_ADDITIONS` kernel parameter, which can be used to enable
    the loading of VirtualBox-specific device drivers. If this kernel parameter is
    defined, we will load both loadable modules, `vboxguest.ko` and `vboxsf.ko`. Another
    kernel parameter, `SDCARD`, is also defined so that we can mount the shared folder
    to be an external SD card storage. The `SDCARD` kernel parameter is used by the
    shell script function `mount_sdcard` as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To define these two kernel parameters on the kernel command line, we need to
    change the PXE boot script at `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default` as
    follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Pay attention to the two variables `SDCARD` and `VBOX_GUEST_ADDITIONS`. They
    are the two new kernel parameters that we added to support the loading of VirtualBox
    device drivers. To mount the shared folder, we add the following command in the
    script:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first parameter to `mount.vboxsf` is the shared folder that we defined
    in the VirtualBox settings, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_11_005.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: With all the changes related to the shared folder, we can have a method that
    can be used to share data between the host and the guest very easily.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Integrating vboxvideo
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the VirtualBox Guest Additions, there is another device driver that can be
    used in Android, which is `vboxvideo.ko`. This is a device driver for video hardware.
    It provides a much more powerful video driver compared to the uvesafb that we
    just discussed in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The uvesafb is a standard framebuffer driver based on VESA 2.0 standard and
    it does not support hardware acceleration on VirtualBox. The `vboxvideo.ko` is
    a DRM/DRI-based video driver with hardware acceleration support.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct Rendering Infrastructure** (**DRI**) is a new architecture of the
    X Window system on the Linux platform to allow *X* clients to talk to the graphics
    hardware directly. **Direct Rendering Manager** (**DRM**) is the kernel side of
    the DRI architecture.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android-x86 project is the first open source project that brought Mesa/DRM
    to the Android platform. This is an open source OpenGL ES implementation for the
    supported graphics hardware. With the following components, we should be able
    to support hardware acceleration for OpenGL ES on Android:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`external_libdrm`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external_mesa`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external_drm_gralloc`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the DRM driver with `vboxvideo` on VirtualBox, but the related implementation
    still needs to add to `external_mesa` and `external_drm_gralloc` to support OpenGL
    ES using the host GPU.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Without the VirtualBox-specific implementation in `external_mesa` and `external_drm_gralloc`,
    we can only use the same software-based implementation in Mesa for OpenGL ES and
    the default Gralloc module, `gralloc.default.so`. This is why most VirtualBox-based
    emulator solutions such as Genymotion, Andy, or AMI DuOS are still using hardware
    GPU emulation, which is similar to the one we discussed in the *Overview of hardware
    GLES emulation* section in [Chapter 10](900f7c1a-7db8-4172-899a-8e9a167372ce.xhtml),
    *Enabling Graphics*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'To load `vboxvideo.ko`, we need to add these additional three lines in `load_modules`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ttm` and `drm_kms_helper` kernel modules are two kernel modules needed
    by `vboxvideo.ko`. We also use a `VBOX_VIDEO_DRIVER` kernel parameter to configure
    the loading of `vboxvideo.ko`. With this kernel parameter, we can switch between
    the uvesafb framebuffer and the VirtualBox framebuffer. After the system boot
    up, we can see the following log message. We can see that `vboxvideo` is loaded
    successfully:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the log message, we can see that a `vboxdrmfb` framebuffer device is created
    by `vboxvideo`. We can check the framebuffer settings using `fbset` as we did
    before. We can see that the hardware acceleration is set to true for `vboxdrmfb`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also check the output from `/proc/fb`. Since the output is `0 vboxdrmfb`,
    the `init_hal_gralloc` shell function in `init.sh` won''t load `uvesafb`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检查 `/proc/fb` 的输出。由于输出是 `0 vboxdrmfb`，`init.sh` 中的 `init_hal_gralloc` 脚本函数不会加载
    `uvesafb`：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this setup, we can launch x86vbox using the `vboxvideo` driver instead
    of `uvesafb`. As I mentioned, there is still a lot of work that needs to be done
    before we can fully utilize all the potential capabilities from `vboxvideo`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以使用 `vboxvideo` 驱动程序而不是 `uvesafb` 来启动 x86vbox。正如我提到的，在我们能够充分利用 `vboxvideo`
    的所有潜在功能之前，还有很多工作要做。
- en: Building and testing images with VirtualBox Guest Additions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VirtualBox Guest Additions 构建和测试镜像
- en: 'To build and test the image in this chapter, we can use the `repo` tool to
    retrieve the source code in this chapter as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和测试本章中的镜像，我们可以使用 `repo` 工具检索本章中的源代码，如下所示：
- en: 'We can get the source code from GitHub and AOSP using the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从 GitHub 和 AOSP 获取源代码：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After we get the source code for this chapter, we can set the environment and
    build the system as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取本章的源代码后，我们可以设置环境和构建系统，如下所示：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To build `initrd.img`, we can run the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `initrd.img`，我们可以运行以下命令：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the start up process of graphics systems. This includes
    the OpenGL ES libraries, Gralloc module, and device driver. We discussed the Gralloc
    module in the last chapter. In this chapter, we analyzed another two components,
    OpenGL ES libraries and the framebuffer driver. With all this knowledge in mind,
    we integrated the drivers from VirtualBox Guest Additions to the x86vbox device.
    In the next chapter, we will start to work on another project to explore how recovery
    works in Android systems.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了图形系统的启动过程。这包括 OpenGL ES 库、Gralloc 模块和设备驱动程序。我们在上一章中讨论了 Gralloc 模块。在本章中，我们分析了另外两个组件，即
    OpenGL ES 库和帧缓冲区驱动程序。在掌握所有这些知识的基础上，我们将来自 VirtualBox Guest Additions 的驱动程序集成到了
    x86vbox 设备中。在下一章中，我们将开始另一个项目，以探索 Android 系统中恢复功能的工作原理。
