- en: Chapter 6. Physics Simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to physics simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating physics engine with games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding real-world simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0036_split_000.html#page "Chapter 5. Adding Music to iOS
    Games and an Introduction to iCloud"), *Adding Music to iOS Games and an Introduction
    to iCloud* we learned various ways to add music to our games along with iCloud
    integration. Now in this chapter, our major focus will be on adding reality to
    the games by introducing physics simulation. SpriteKit has a seamlessly bundled
    physics engine and in this chapter we will be exploring and working to add physics
    to our games. Basically, the SpriteKit has been divided into the following two
    major components:'
  prefs: []
  type: TYPE_NORMAL
- en: The graphical interface that you see on the screen including UI interface, animations,
    sound effects, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is the physical physics world, which determines the interaction and
    behaviors of game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to physics simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all like games that have realistic effects and actions. In this chapter we
    will learn about the ways to make our games more realistic. Have you ever wondered
    how to provide realistic effect to game objects? It is physics that provides a
    realistic effect to the games and their characters. In this chapter, we will learn
    how to use physics in our games.
  prefs: []
  type: TYPE_NORMAL
- en: While developing the game using SpriteKit, you will need to change the world
    of your game frequently. The world is the main object in the game that holds all
    the other game objects and physics simulations. We can also update the gravity
    of the gaming world according to our need. The default world gravity is 9.8, which
    is also the earth's gravity, World gravity makes all bodies fall down to the ground
    as soon as they are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'More about SpriteKit can be explored using the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first task is to create the world and then add bodies to it, which can interact
    according to the principles of physics. You can create game objects in the form
    of sprites and associate physics bodies to them. You can also set various properties
    of the object to specify its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn about the basic components that are used to develop
    games. We will also learn how to set game configurations, including the world
    settings such as gravity and boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial step is to apply the gravity to the scene. Every scene has a physics
    world associated with it. We can update the gravity of the physics world in our
    scene using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Currently we have set the gravity of the scene to 0, which means the bodies
    will be in a state of free fall. They will not experience any force due to gravity
    in the world.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In several games we also need to set a boundary to the games. Usually, the
    bounds of the view can serve as the bounds for our physics world. The following
    code will help us to set up the boundary for our game, which will be as per the
    bounds of our game scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first line of code we are initializing a `SKPhysicsBody` object. This
    object is used to add the physics simulation to any `SKSpriteNode`. We have created
    the `gameBorderBody` as a rectangle with the dimensions equal to the current scene
    frame.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we assign that physics object to the `physicsBody` of our current scene
    (every `SKSpriteNode` object has the `physicsBody` property through which we can
    associate physics bodies to any node).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this we update the `physicsBody.friction`. This line of code updates the
    friction property of our world. The friction property defines the friction value
    of one physics body with another physics body. Here we have set this to `0`, in
    order to make the objects move freely, without slowing down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Every game object is inherited from the `SKSpriteNode` class, which allows
    the physics body to hold on to the node. Let us take an example and create a game
    object using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are already familiar with the first few lines of code wherein we are creating
    the sprite reference and then adding it to the scene. Now in the next line of
    code, we are associating a physics body with that sprite. We are initializing
    the circular physics body with radius and associating it with the sprite object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we can update various other properties of the physics body such as friction,
    restitution, linear damping, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The physics body properties also allow you to apply force. To apply force you
    need to provide the direction where you want to apply force.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code we are applying force in the bottom-right corner of the world. To
    provide the direction coordinates we have used `CGVectorMake`, which accepts the
    vector coordinates of the physics world.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also apply impulse instead of force. Impulse can be defined as a force
    that acts for a specific interval of time and is equal to the change in linear
    momentum produced over that interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While creating games, we frequently use static objects. To create a rectangular
    static object we can use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So all the code is the same except one special property, which is dynamic. By
    default this property is set to `YES`, which means that all the physics bodies
    will be dynamic by default and can be converted to static after setting this Boolean
    to `NO`. Static bodies do not react to any force or impulse. Simply put, dynamic
    physics bodies can move while the static physics bodies cannot .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integrating physics engine with games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this section onwards, we will develop a mini game that will have a dynamic
    moving body and a static body. The basic concept of the game will be to create
    an infinite bouncing ball with a moving paddle that will be used to give direction
    to the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To develop a mini game using the physics engine, start by creating a new project.
    Open Xcode and go to **File** | **New** | **Project** and then navigate to **iOS**
    | **Application** | **SpriteKit Game**. In the pop-up screen, provide the **Product
    Name** as `PhysicsSimulation`, navigate to **Devices** | **iPhone** and click
    on **Next** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Next** and save the project on your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is saved, you should be able to see something similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the project settings page, just uncheck the **Portrait** from **Device**
    **Orientation** section as we are supporting only landscape mode for this game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphics and games cannot be separated for long; you will also need some graphics
    for this game. Download the graphics folder, drag it and import it into the project.
    Make sure that the **Copy items into destination group''s folder (if needed)**
    is checked and then click on **Finish** button. It should be something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now your project template is ready for a physics-based mini game. We need to
    update the game template project to get started with code game logic. Take the
    following steps to integrate the basic physics object in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `GameScene.m` .This class creates a scene that will be plugged
    into the games. Remove all code from this class and just add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `initWithSize` method creates an blank scene of the specified size. The
    code written inside the `init` function allows you to add the background image
    at the center of the screen in your game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now when you compile and run the code, you will observe that the background
    image is not placed correctly on the scene. To resolve this, open `GameViewController.m`.
    Remove all code from this file and add the following function;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To ensure that the view hierarchy is properly laid out, we have implemented
    the `viewWillLayoutSubviews` method. It does not work perfectly in `viewDidLayoutSubviews`
    method because the size of the scene is not known at that time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now compile and run the app. You should be able to see the background image
    correctly. It will look something similar to the following screenshot:![How to
    do it...](img/00099.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So now that we have the background image in place, let us add gravity to the
    world. Open `GameScene.m` and add the following line of code at the end of the
    `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line of code will set the gravity of the world to 0, which means there
    will be no gravity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now as we have removed the gravity to make the object fall freely, it''s important
    to create a boundary around the world, which will hold all the objects of the
    world and prevent them to go off the screen. Add the following line of code to
    add the invisible boundary around the screen to hold the physics objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the first line, we are are creating an edge-based physics boundary object,
    with a screen size frame. This type of a physics body does not have any mass or
    volume and also remains unaffected by force and impulses. Then we associate the
    object with the physics body of the scene. In the last line we set the friction
    of the body to 0, for a seamless interaction between objects and the boundary
    surface. The final file should look something like the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/00100.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now we have our surface ready to hold the physics world objects. Let us create
    a new physics world object using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have created the sprite and then we have added it to the scene. Then
    in the later steps we associate the circular physics body with the sprite object.
    Finally, we alter the properties of that physics body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now compile and run the application; you should be able to see the circular
    ball on the screen as shown in screenshot below:![How to do it...](img/00101.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The circular ball is added to the screen, but it does nothing. So it''s time
    to add some action in the code. Add the following line of code at the end of the
    `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will apply the force on the physics body, which in turn will move the associated
    ball sprite as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now compile and run the project. You should be able to see the ball moving and
    then collide with the boundary and bounce back, as there is no friction between
    the boundary and the ball. So now we have the infinite bouncing ball in the game.![How
    to do it...](img/00102.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several properties used while creating physics bodies to define their
    behavior in the physics world. The following is a detailed description of the
    properties used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restitution property** defines the bounciness of an object. Setting the restitution
    to `1.0f`, means that the ball collision will be perfectly elastic with any object.
    This means that the ball will bounce back with a force equal to the impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Damping** **property** allows the simulation of fluid or air friction.
    This is accomplished by reducing the linear velocity of the body. In our case,
    we do not want the ball to slow down while moving and hence we have set the restitution
    to `0.``0f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read about all these properties in detail at Apple''s developer documentation:
    [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding real-world simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will be adding some real simulation in the game. We will add more physics
    bodies and make them interact with each other. This will help us to understand
    the physics interaction between various physics objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have the infinite bouncing ball in place. To add more fun to the game,
    let us add some more elements to the it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will add the static block to the game. To accomplish this, add the
    following line of code at the end of the `initWithSize` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First we create the block sprite. After that we associate a physics body to
    it and change the various parameters of the physics body object as well. The most
    important thing to note here is `block.physicsBody.dynamic = NO`. By default all
    the physics bodies are dynamic; so to create static bodies, we just need to set
    the `physicsBody.dynamic` Boolean to `NO`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After adding the code, the final file should look something similar to the following
    screenshot:![How to do it...](img/00103.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now compile and run the code. You should be able to see the block on the screen
    with a static body. Observe closely that when the ball collides with the block,
    it bounces back and you can play with it endlessly.![How to do it...](img/00104.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s time to add some more action to make the game exciting. Now we will make
    the block paddle move based on touch. The following functions will help us to
    accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These methods provide the callback when you touch the screen and also provide
    the list of the objects which were touched. There are three callbacks for touch
    begin, touch move and touch end action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now add the following code just before the `@implementation` line in `GameScene.m`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have thus created a property to hold the user's state of touch on the paddle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we will implement `touchesBegan:withEvent` function in our `GameScene.m`
    file. Add the following function just next to the `init` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will listen for the touch begin event and use it to find the body
    at the location where the user taps on the scene. In the next line, we get the
    physics body at the touch location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now compile and run the code. When you touch on the paddle, you should be able
    to see the logs demonstrating the touch working on the paddle.![How to do it...](img/00105.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let us go ahead and implement `touchesMoved:withEvent` and add the following
    function just next to `touchesBegan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Initially, check if the paddle is tapped. If yes, then update the paddle position
    based on the user's touch location. While repositioning, we just need to make
    sure that the position *y* of the paddle does not change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally add the following function after `touchedMoved` in the `GameScene.m`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just turn the `isPaddleTapped` flag off in the touch end function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now compile and run the game. You should be able to move the paddle block to
    hit the ball and keep it moving. You should tap on the paddle to move it to the
    left and right sides of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
