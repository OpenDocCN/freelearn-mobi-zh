- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Value Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most traditional object-oriented programming languages, we create classes
    (which are reference types) as blueprints for our objects. In Swift, unlike other
    object-oriented languages, structures have much of the same functionality as classes,
    however, they are value types. Apple has said that we should prefer value types,
    such as structures, to reference types, but what are the differences between a
    reference type and a value type?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between value types and reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why recursive data types cannot be created as a value type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement copy-on-write in your custom type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to conform to the `Equatable` protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in *Chapter 8*, *Classes, Structures, and Protocols*, we have the
    ability to create our custom types as either a reference type (or class) or a
    value type (or structure). Let's review the differences between these two types
    because it is important to understand these differences when determining what
    type to use for our custom types.
  prefs: []
  type: TYPE_NORMAL
- en: Value types and reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structures are value types; when we pass instances of a structure in our application,
    we pass a copy of the structure and not the original structure. Classes are reference
    types; therefore, when we pass an instance of a class within our application,
    a reference to the original instance is passed. It is very important to understand
    this difference. We will discuss a very high-level view here but will provide
    additional details in *Chapter 18*, *Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass structures within our application, we are passing copies of the
    structures and not the original structures. This means that the function gets
    its own copy of the structure, which it can change as needed without affecting
    the original instance of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass an instance of a class within our application, we are passing a
    reference to the original instance of the class, therefore, any changes made to
    the instance of the class will persist.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the difference between value types and reference types, let''s
    examine a real-world object: a book. If we have a friend who wants to read *Mastering
    Swift 5.3, Sixth Edition*, we could either buy them their own copy or share ours.'
  prefs: []
  type: TYPE_NORMAL
- en: If we bought our friend their own copy of the book, then any notes they made
    in the book would remain in their copy of the book and would not be reflected
    in our copy. This is how passing by value works with structures and variables.
    Any changes that are made to the structure or variable within the function are
    not reflected back to the original instance of the structure or variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we share our copy of the book, then any notes that were made in the book
    will stay in the book when it is returned to us. This is how passing by reference
    works. Any changes that are made to the instance of the class remain when the
    function exits.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass an instance of a value type, we are actually passing a copy of
    the instance. You may be wondering about the performance of large value types
    when they are passed from one part of our code to another. For structures that
    have the possibility of becoming very large, we can use copy-on-write.
  prefs: []
  type: TYPE_NORMAL
- en: The explanation in the previous paragraphs is pretty straightforward; however,
    it is a very important concept that we must understand. In this section, we are
    going to examine the differences between value types and reference types so that
    we know when to use each type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating two types; one is going to be a structure (or value
    type) and the other is going to be a class (or reference type). We will be using
    these types in this section to demonstrate the differences between value types
    and reference types. The first type that we will examine is named `MyValueType`.
    We will implement `MyValueType` using a structure, which means that it is a value
    type, as its name suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MyValueType`, we define three properties. Two of the properties are of
    the `String` type (`name` and `assignment`) and one is of the `Integer` type (`grade`).
    Now, let''s take a look at how we can implement this as a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `MyReferenceType` type defines the same three properties as in the `MyValueType`
    type, however, we need to define an initializer in the `MyReferenceType` type
    that we did not need to define in the `MyValueType` type. The reason for this
    is that structures provide us with a default initializer that will initialize
    all the properties that need to be initialized if we do not provide a default
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can use each of these types. The following code
    shows how we can create instances of each of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this code, instances of structures are created in exactly
    the same way as the instances of classes. Being able to use the same format to
    create instances of structures and classes is good because it makes our lives
    easier; however, we do need to bear in mind that value types behave in a different
    manner to reference types. Let''s explore this; the first thing we need to do
    is create two functions that will change the grades for the instances of the two
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each of these functions takes an instance of one of our types and an extra credit
    amount. Within the function, we will add the extra credit amount to the grade.
    If we try to use this code we will receive an error in the `extraCreditValueType()`
    function telling us that the left side of the mutable operation is not mutable.
    The reason for this is that a value type parameter, by default, is immutable because
    the function is receiving an immutable copy of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using a value type like this protects us from making accidental changes to the
    instances; this is because the instances are scoped to the function or type in
    which they are created. Value types also protect us from having multiple references
    to the same instance. Therefore, they are, by default, thread (concurrency) safe
    because each thread will have its own version of the value type. If we absolutely
    need to change an instance of a value type outside of its scope, we could use
    an `inout` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We define an `inout` parameter by placing the `inout` keyword at the start of
    the parameter's definition. An `inout` parameter has a value that is passed into
    the function. This value is then modified by the function and is passed back out
    of the function to replace the original value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore how we can use an `inout` parameter. We will begin by creating
    a function that is designed to retrieve the grade for an assignment from a data
    store. However, to simplify our example, we will simply generate a random score.
    The following code demonstrates how we can write this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can use value types with the `inout` keyword to
    create a version of the previous example that will work correctly. The first thing
    we need to do is modify the `getGradesForAssignment()` function to use an instance
    of `MyValueType` that it can modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is designed to retrieve the grade for the assignment that is
    defined in the `MyValueType` instance and is then passed into the function. Once
    the grade is retrieved, we will use it to set the grade property of the `MyValueType`
    instance. We will also print the grade out to the console so that we can see what
    grade it is. Now let''s explore how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we created a `mathGrades` array that will store the grades
    for our assignment and a `students` array that will contain the names of the students
    that we wish to retrieve the grades for. We then created an instance of the `MyValueType`
    structure that contains the name for the assignment. We will use this instance
    to request the grades from the `getGradeForAssignment()` function. Notice that
    when we pass in the `mathAssignment` instance, we prefix the name of the instance
    with the `&` symbol. This lets us know that we are passing the reference to the
    original instance and not a copy. Now that everything is defined, we will loop
    through the list of students to retrieve the grades. The output of this code will
    look similar to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output from this code is what we expected to see, where each instance in
    the `mathGrades` array represents the correct grade. The reason this code works
    correctly is that we are passing a reference from the `mathAssignment` instance
    to the `getGradeForAssignment()` function, and not a copy.
  prefs: []
  type: TYPE_NORMAL
- en: There are some things we cannot do with value types that we can do with reference
    (or class) types. The first thing that we will look at is the recursive data type.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive data types for reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recursive data type is a type that contains values of the same type as a property
    for the type. Recursive data types are used when we want to define dynamic data
    structures, such as lists and trees. The size of these dynamic data structures
    can grow or shrink depending on our runtime requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linked lists are perfect examples of a dynamic data structure that we can implement
    using a recursive data type. A linked list is a group of nodes that are linked
    together and where, in its simplest form, each node maintains a link to the next
    node in the list. *Figure 17.1* shows how a very basic linked list works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: A basic linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the list contains a value or data, and it also contains the link
    to the next node in the list. If one of the nodes in the list loses the reference
    to the next node, then the remainder of the list will be lost because each node
    is only aware of the next node. Some linked lists maintain a link to both the
    previous nodes and the following nodes to allow us to move both forward and backward
    through the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we can create a linked list using a reference
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `LinkedListReferenceType` class, we have two properties. The first property
    is named `value` and it contains the data for this instance. The second property
    is named `next`, which points to the next item in the linked list. If the `next`
    property is `nil`, then this instance will be the last node in the list. If we
    try to implement this linked list as a value type, the code will be similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add this code to a playground, we receive the following error: `Recursive`
    `value type LinkedListValueType is not allowed`. This tells us that Swift does
    not allow recursive value types. However, we can implement them as a reference
    type, which we discussed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, recursive value types are a really bad idea because of
    how value types function. Let's examine this for a minute, because it will really
    stress the difference between value types and reference types. It will also help
    you to understand *why* we need reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we are able to create the `LinkedListValueType` structure without
    any errors. Now let''s create three nodes for our list, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will link these nodes together using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the problem with this code? If not, think about how a value type
    is passed. In the first line, `one.next = two`, we are not actually setting the
    `next` property to the original `two` instance; in fact, we are actually setting
    it to a copy of the `two` instance, because by implementing the `LinkedListValueType`
    as a value type, we are passing the value and not the actual instance. This means
    that in the next line, `two.next = three`, we are setting the next property of
    the original `two` instance to the `three` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this change is not reflected back in the copy that was made for the
    next property of the `one` instance. Sounds a little confusing? Let''s clear it
    up a little by looking at a diagram that shows the state of our three `LinkedListValueType`
    instances if we were able to run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B16683_17_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: A linked list structure example'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the diagram, the next property of the `one` instance is
    pointing to a copy of the `two` instance whose next property is still `nil`. The
    next property of the original `two` instance, however, is pointing to the `three`
    instance. This means that, if we try to go through the list by starting at the
    `one` instance, we will not reach the `three` instance because the copy of the
    `two` instance will still have a `next` property that is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we can only do with reference (or class) types is class inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance for reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-oriented programming, inheritance refers to one class (known as a
    **sub** or **child** **class**) being derived from another class (known as a **super**
    or **parent** **class**). The subclass will inherit methods, properties, and other
    characteristics from the superclass. With inheritance, we can also create a class
    hierarchy where we can have multiple layers of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can create a class hierarchy with classes in Swift.
    We will start off by creating a base class named `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Animal` class, we defined one property (`numberOfLegs`) and three methods
    (`sleeps()`, `walking()`, and `speaking()`). Now, any class that is a subclass
    of the `Animal` class will also have these properties and methods. Let''s examine
    how this works by creating two classes that are subclasses of the `Animal` class.
    These two classes will be named `Biped` (an animal with two legs) and `Quadruped`
    (an animal with four legs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these two classes inherit all the properties and methods from the `Animal`
    class, all we need to do is create an initializer that sets the `numberOfLegs`
    property to the correct number of legs. Now, let''s add another layer of inheritance
    by creating a `Dog` class that will be a subclass of the `Quadruped` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `Dog` class, we inherit from the `Quadruped` class, which, in turn, inherits
    from the `Animal` class. Therefore, the `Dog` class will have all the properties,
    methods, and characteristics of both the `Animal` and `Quadruped` classes. If
    the `Quadruped` class overrides anything from the `Animal` class, then the `Dog`
    class will inherit the version from the `Quadruped` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create very complex class hierarchies in this manner; for example, *Figure
    17.3* expands on the class hierarchy that we just created to add several other
    animal classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close up of a piece of paper  Description automatically generated](img/B16683_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Animal class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: Class hierarchies can get very complex. However, as you just saw, they can eliminate
    a lot of duplicate code because our subclasses inherit methods, properties, and
    other characteristics from their superclasses. Therefore, we do not need to recreate
    them in all of the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest drawback of a class hierarchy is the complexity. When we have a
    complex hierarchy (as shown in the preceding diagram), it is easy to make a change
    and not realize how it is going to affect all of the subclasses. If you consider
    the `Dog` and `Cat` classes, for example, we may want to add a `furColor` property
    to our `Quadruped` class so that we can set the color of the animal's fur. However,
    horses do not have fur; they have hair. So, before we can make any changes to
    a class in our hierarchy, we need to understand how it will affect all the subclasses
    in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, it is best to avoid using complex class hierarchies (as shown in this
    example), and instead use a protocol-oriented design, unless, of course, there
    are specific reasons to use them. Now that we have a good understanding of reference
    and value types, let's explore dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned how to use inheritance with classes in order
    to inherit and override the functionality defined in a superclass. You may be
    wondering how and when the appropriate implementation is chosen. The process of
    choosing which implementation to call is performed at runtime and is known as
    **dynamic dispatch**.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key points to understand from the last paragraph is that the implementation
    is chosen at runtime. What this means is that a certain amount of runtime overhead
    is associated with using class inheritance, as shown in the *Inheritance for reference
    types* section. For most applications, this overhead is not a concern; however,
    for performance-sensitive applications such as games, this overhead can be costly.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways that we can reduce the overhead associated with dynamic dispatch
    is to use the `final` keyword. The `final` keyword puts a restriction on the class,
    method, or function to indicate that it cannot be overridden, in the case of a
    method or function, or subclasses, in the case of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `final` keyword, you put it prior to the class, method, or function
    declaration, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *Inheritance for reference types* section, we defined a `class` hierarchy
    that started with the `Animal` superclass. If we want to restrict subclasses from
    overriding the `walking()` method and the `numberOfLegs` property, we can change
    the `Animal` implementation, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This change allows the application, at runtime, to make a direct call to the
    `walking()` method rather than an indirect call that gives the application a slight
    performance increase. If you must use a class hierarchy, it is good practice to
    use the `final` keyword wherever possible; however, it is better to use a protocol-oriented
    design, with value types, to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at something that can help with the performance of
    our custom value types: copy-on-write.'
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-write
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, when we pass an instance of a value type, such as a structure, a new
    copy of the instance is created. This means that if we have a large data structure
    that contains 100,000 elements, then every time we pass that instance, we will
    have to copy all 100,000 elements. This can have a detrimental impact on the performance
    of our applications, especially if we pass the instance to numerous functions.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, Apple has implemented the copy-on-write feature for all
    the data structures (such as `Array`, `Dictionary`, and `Set`) in the Swift standard
    library. With copy-on-write, Swift does not make a second copy of the data structure
    until a change is made to that data structure. Therefore, if we pass an array
    of 50,000 elements to another part of our code, and that code does not make any
    changes to the array, we will avoid the runtime overhead of copying all the elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful feature and can greatly increase the performance of our
    applications. However, our custom value types do not automatically get this feature
    by default. In this section, we will explore how we can use reference types and
    value types together to implement the copy-on-write feature for our custom value
    types. To do this, we will create a very basic queue type that will demonstrate
    how you can add copy-on-write functionality to your custom value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by creating a backend storage type called `BackendQueue`
    and will implement it as a reference type. The following code gives our `BackendQueue`
    type the basic functionality of a queue type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `BackendQueue` type is a generic type that uses an array to store the data.
    This type contains three methods, which enables us to add items to the queue,
    retrieve an item from the queue, and return the number of items in the queue.
    We use the `fileprivate` access level to prevent the use of this type outside
    of the defining source file, because it should only be used to implement the copy-on-write
    feature for our main queue type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add a couple of extra items to the `BackendQueue` type so that
    we can use it to implement the copy-on-write feature for the main queue type.
    The first thing that we will add is a public default initializer and a private
    initializer that can be used to create a new instance of the `BackendQueue` type;
    the following code shows the two initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The public initializer will be used to create an instance of the `BackendQueue`
    type without any items in the queue. The private initializer will be used internally
    to create a copy of itself that contains any items that are currently in the queue.
    Now we will need to create a method that will use the private initializer to create
    a copy of itself when required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It could be very easy to make the private initializer public and then let the
    main queue type call that initializer to create the copy; however, it is good
    practice to keep the logic needed to create the new copy within the type itself.
    The reason why you should do this is that if you need to make changes to the type,
    that may affect how the type is copied. Instead, the logic that you need to change
    the type is embedded within the type itself and is easy to find. Additionally,
    if you use the `BackendQueue` type as the backend storage for multiple types,
    you will only need to make the changes to the copy logic in one place if it changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final code for the `BackendQueue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create our `Queue` type, which will use the `BackendQueue` type
    to implement the copy-on-write feature. The following code adds the basic queue
    functionality to our `Queue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Queue` type is implemented as a value type. This type has one private property
    of the `BackendQueue` type, which will be used to store the data. This type contains
    three methods to add items to the queue, retrieve an item from the queue, and
    return the number of items in the queue. Now let's explore how we can add the
    copy-on-write feature to the `Queue` type.
  prefs: []
  type: TYPE_NORMAL
- en: Swift has a global function named `isKnownUniquelyReferenced()`. This function
    will return `true` if there is only one reference to an instance of a reference
    type, or `false` if there is more than one reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by adding a function to check whether there is a unique reference
    to the `internalQueue` instance. This will be a private function named `checkUniquelyReferencedInternalQueue`.
    The following code shows how we can implement this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we check to see whether there are multiple references to the
    `internalQueue` instances. If there are multiple references, then we know that
    we have multiple copies of the `Queue` instance and, therefore, we can create
    a new copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Queue` type itself is a value type; therefore, when we pass an instance
    of the `Queue` type within our code, the code that we pass the instance to receives
    a new copy of that instance. The `BackendQueue` type, which the `Queue` type is
    using, is a reference type. Therefore, when a copy is made of a `Queue` instance,
    then that new copy receives a reference to the original `Queue`''s `BackendQueue`
    instance and not a new copy. This means that each instance of the `Queue` type
    has a reference to the same `internalQueue` instance. Consider the following code
    as an example; both `queue1` and `queue2` have references to the same `internalQueue`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Queue` type, we know that both the `addItem()` and `getItem()` methods
    change the `internalQueue` instance. Therefore, before we make these changes,
    we will want to call the `checkUniquelyReferencedInternalQueue()` method to create
    a new copy of the `internalQueue` instance. These two methods will now have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this code, when either the `addItem()` or `getItem()` methods are called
    – which will change the data in the `internalQueue instance` – we use the `checkUniquelyReferencedInternalQueue()`
    method to create a new instance of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one additional method to the `Queue` type, which will allow us to
    see whether there is a unique reference to the `internalQueue` instance or not.
    Here is the code for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full code listing for the `Queue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s examine how the copy-on-write functionality works with the `Queue`
    type. We will start off by creating a new instance of the `Queue` type, adding
    an item to the queue, and then checking whether we have a unique reference to
    the `internalQueue` instance. The following code demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add the item to the queue, the following message will be printed to
    the console. This tells us that within the `checkUniquelyReferencedInternalQueue()`
    method, it was determined that there was only one reference to the `internalQueue`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify this by printing the results of the `uniquelyReference()` method
    to the console. Now let''s make a copy of the `queue3` instance by passing it
    to a new variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check whether we have a unique reference to the `internalQueue`
    instances of either the `queue3` or `queue4` instance. The following code will
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will print two `false` messages to the console, letting us know that
    neither instance has a unique reference to their `internalQueue` instances. Now
    let''s add an item to either one of the queues. The following code will add another
    item to the `queue3` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add the item to the queue, we will see the following message printed
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This message tells us that when we add the new item to the queue, a new copy
    of the `internalQueue` instance is created. In order to verify this, we can print
    the results of the `uniquelyReferenced()` methods to the console again. If you
    do check this, you will see two `true` messages printed to the console this time
    rather than two `false` methods. We can now add additional items to the queues
    and we will see that we are not creating new instances of the `internalQueue`
    instance because each instance of the `Queue` type now has its own copy.
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning on creating your own data structure that may contain a large
    number of items, it is recommended that you implement it with the copy-on-write
    feature as described here.
  prefs: []
  type: TYPE_NORMAL
- en: If you are comparing your custom types, it is also recommended that you implement
    the `Equatable` protocol within these custom types. This will enable you to compare
    two instances of the type using the equal-to (`==`) and not-equal-to (`!=`) operators.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Equatable protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how we can conform to the `Equatable` protocol
    using extensions. When a type conforms to the `Equatable` protocol, we can use
    the equal-to (`==`) operator to compare for equality and the not-equal-to (`!=`)
    operator to compare for inequality.
  prefs: []
  type: TYPE_NORMAL
- en: If you will be comparing instances of a custom type, then it is a good idea
    to have that type conform to the `Equatable` protocol because it makes comparing
    instances very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by creating the type that we will compare. We will name this
    type `Place`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `Place` type, we have three properties that represent the ID of the place
    and the latitude and longitude coordinates for its location. If there are two
    instances of the `Place` type that have the same ID and coordinates, then they
    will be considered the same place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Equatable` protocol, we can create a global function; however,
    that is not the recommended solution for protocol-oriented programming. We could
    also add a static function to the `Place` type itself, but sometimes it is better
    to pull the functionality needed to conform to a protocol out of the implementation
    itself. The following code will make the `Place` type conform to the `Equatable`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compare the instances of the `Place` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will print `false` because `Fenway Park` and `Wrigley Field` are two different
    baseball stadiums.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we said that it may be better to pull the functionality
    needed to conform to a protocol out of the implementation itself. Well, think
    about some of the larger types that you have created in the past. Personally speaking,
    I have seen types that had several hundred lines of code and conformed to numerous
    protocols. By pulling the code that is needed to conform to a protocol out of
    the type's implementation and putting it in its own extension, we are making our
    code much easier to read and maintain in the future because the implementation
    code is isolated in its own extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Swift 5.2, if all of the properties conform to the `Equatable`
    protocol and you want to compare all of the properties, as shown in the previous
    examples, we actually do not need to implement the `==` function. All we really
    need to do is to implement the code as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, Swift will add all of the boilerplate code to make the
    `Place` structure conform to the `Equatable` protocol for us; however, it is good
    to know how to implement this ourselves if all of the properties do not conform
    to the `Equatable` protocol or we do not want to compare all of the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the differences between value types and reference
    types. We also looked at how to implement copy-on-write and the `Equatable` protocol
    with our custom types. We can implement the copy-on-write feature with value types
    that become very large. We can implement the `Equatable` protocol for any custom
    type, including reference types, when we need to compare two instances.
  prefs: []
  type: TYPE_NORMAL
- en: While Swift takes care of managing the memory for us, it is still a good idea
    to understand how this memory management works so that we can avoid the pitfalls
    that may cause it to fail. In the next chapter, we will look at how memory management
    in Swift works and demonstrate how it can fail.
  prefs: []
  type: TYPE_NORMAL
