<html><head></head><body>
<div id="_idContainer063" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-142" class="calibre5"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1"> Starting a Video Streaming App and Adding Authentication</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Having mastered how to create engaging social apps such as WhatsApp and Instagram, it’s now time to dive into the world of video streaming services. </span><span class="kobospan" id="kobo.3.2">This chapter marks the beginning of our third project: a Netflix-like app. </span><span class="kobospan" id="kobo.3.3">Let’s call it Packtflix. </span><span class="kobospan" id="kobo.3.4">Here, we will explore a different aspect of Android development, focusing on multimedia content delivery and user authentication, while continuing to build captivating </span><span><span class="kobospan" id="kobo.4.1">user interfaces.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">Our journey will begin by laying the groundwork for our streaming app. </span><span class="kobospan" id="kobo.5.2">We’ll start from scratch, setting up a new project and introducing you to the app’s structure </span><span><span class="kobospan" id="kobo.6.1">and modules.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">Following the setup, we’ll dive into one of the most critical aspects of any app: authenticating your users. </span><span class="kobospan" id="kobo.7.2">In today’s digital age, security and privacy are more relevant than ever, so you’ll learn how to implement robust authentication mechanisms using OAuth2. </span><span class="kobospan" id="kobo.7.3">This will ensure that your app’s users can securely access their accounts and </span><span><span class="kobospan" id="kobo.8.1">personal preferences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">Once our users can log in, we’ll focus on presenting them with a rich selection of movies. </span><span class="kobospan" id="kobo.9.2">We’ll employ Jetpack Compose to create dynamic and responsive lists, showcasing the </span><span><span class="kobospan" id="kobo.10.1">available content.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.11.1">Finally, we’ll delve into the details. </span><span class="kobospan" id="kobo.11.2">Each movie or series in your app deserves its spotlight, and you’ll create detailed screens for them using Jetpack Compose. </span><span class="kobospan" id="kobo.11.3">This will provide users with all the information they need to decide what to </span><span><span class="kobospan" id="kobo.12.1">watch next.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.13.1">So, this chapter will cover the </span><span><span class="kobospan" id="kobo.14.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.15.1">Creating the app’s structure </span><span><span class="kobospan" id="kobo.16.1">and modules</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.17.1">Building the </span><span><span class="kobospan" id="kobo.18.1">login screen</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.19.1">Authenticating the </span><span><span class="kobospan" id="kobo.20.1">app’s users</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.21.1">Creating your </span><span><span class="kobospan" id="kobo.22.1">movie list</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.23.1">Making the movie and series </span><span><span class="kobospan" id="kobo.24.1">detail screen</span></span></li>
</ul>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.25.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">As in the previous chapter, you will need to have installed Android Studio (or another editor of </span><span><span class="kobospan" id="kobo.27.1">your preference).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">We are going to start a new project in this chapter, so it is not necessary to download the changes made in the </span><span><span class="kobospan" id="kobo.29.1">previous chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">You will find the complete code that we are going to build throughout this chapter in this </span><span><span class="kobospan" id="kobo.31.1">repository: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7</span></span></a><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-144" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1">Creating the app’s structure and modules</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">In this section, we’ll lay</span><a id="_idIndexMarker763" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.36.1"> the foundation for our Packtflix app by organizing it into feature modules. </span><span class="kobospan" id="kobo.36.2">As we have seen before, by dividing the app into modules such as login, list, and playback, we can work on one feature at a time without affecting the others and speed up the build process for larger projects. </span><span class="kobospan" id="kobo.36.3">Additionally, we’ll set up a version catalog for our dependencies as we did before to streamline the management of libraries such as Jetpack Compose, Dagger Hilt, </span><span><span class="kobospan" id="kobo.37.1">and Kotlin.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">Let’s start creating the project. </span><span class="kobospan" id="kobo.38.2">In Android Studio, select </span><strong class="bold"><span class="kobospan" id="kobo.39.1">File</span></strong><span class="kobospan" id="kobo.40.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.41.1">New</span></strong><span class="kobospan" id="kobo.42.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.43.1">New Project…</span></strong><span class="kobospan" id="kobo.44.1">, and choose </span><strong class="bold"><span class="kobospan" id="kobo.45.1">Empty Compose Activity</span></strong><span class="kobospan" id="kobo.46.1">. </span><span class="kobospan" id="kobo.46.2">Then, in the </span><strong class="bold"><span class="kobospan" id="kobo.47.1">New Project</span></strong><span class="kobospan" id="kobo.48.1"> panel, fill out </span><strong class="bold"><span class="kobospan" id="kobo.49.1">Name</span></strong><span class="kobospan" id="kobo.50.1">, </span><strong class="bold"><span class="kobospan" id="kobo.51.1">Package name</span></strong><span class="kobospan" id="kobo.52.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.53.1">Save location</span></strong><span class="kobospan" id="kobo.54.1">. </span><span class="kobospan" id="kobo.54.2">For the </span><strong class="bold"><span class="kobospan" id="kobo.55.1">Minimum SKD</span></strong><span class="kobospan" id="kobo.56.1"> option, we will choose </span><strong class="bold"><span class="kobospan" id="kobo.57.1">API 29</span></strong><span class="kobospan" id="kobo.58.1"> again as it guarantees the best percentage of compatibility at the time </span><span><span class="kobospan" id="kobo.59.1">of writing.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer056">
<span class="kobospan" id="kobo.60.1"><img alt="Figure 7.1: New project configuration for Packtflix" src="image/B19443_07_001.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.61.1">Figure 7.1: New project configuration for Packtflix</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.62.1">The options in </span><span><em class="italic"><span class="kobospan" id="kobo.63.1">Figure 7</span></em></span><em class="italic"><span class="kobospan" id="kobo.64.1">.1</span></em><span class="kobospan" id="kobo.65.1"> are the ones we will see using Android Studio Iguana (version 2023.2.1), though it may have variations depending on the version. </span><span class="kobospan" id="kobo.65.2">For example, in other previous </span><a id="_idIndexMarker764" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.66.1">versions of Android Studio, we could also select whether we were going to use the version catalog for </span><span><span class="kobospan" id="kobo.67.1">our dependencies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.68.1">Now, the version catalog is created by default, so we will already get a </span><strong class="source-inline"><span class="kobospan" id="kobo.69.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.70.1"> file in our project with the </span><span><span class="kobospan" id="kobo.71.1">following content:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.72.1">
[versions]
agp = "8.3.0-alpha18"
kotlin = "1.9.0"
coreKtx = "1.12.0"
junit = "4.13.2"
junitVersion = "1.1.5"
espressoCore = "3.5.1"
lifecycleRuntimeKtx = "2.7.0"
activityCompose = "1.8.2"
composeBom = "2023.08.00"
[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
[plugins]
androidApplication = { id = "com.android.application", version.ref = "agp" }
jetbrainsKotlinAndroid = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.73.1">This code adds the basic dependencies to the version catalog to build an app with Kotlin, Android, and </span><span><span class="kobospan" id="kobo.74.1">Jetpack </span></span><span><a id="_idIndexMarker765" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.75.1">Compose.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.76.1">The next step will be to create the modules needed. </span><span class="kobospan" id="kobo.76.2">Here, we will create three </span><span><span class="kobospan" id="kobo.77.1">feature modules:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.78.1">:feature:login</span></strong><span class="kobospan" id="kobo.79.1">: We will use this module to include the </span><span><span class="kobospan" id="kobo.80.1">login feature</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">:feature:list</span></strong><span class="kobospan" id="kobo.82.1">: In this module, we will include the list screen as well as the </span><span><span class="kobospan" id="kobo.83.1">detail screen</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.84.1">:feature:playback</span></strong><span class="kobospan" id="kobo.85.1">: In this module, we will host all the </span><span><span class="kobospan" id="kobo.86.1">playback functionality</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">We will also create the following </span><span><span class="kobospan" id="kobo.88.1">common modules:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.89.1">:app</span></strong><span class="kobospan" id="kobo.90.1">: This module will contain the entry point for </span><span><span class="kobospan" id="kobo.91.1">our application</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.92.1">:common</span></strong><span class="kobospan" id="kobo.93.1">: This module will contain common functionality needed in more than </span><span><span class="kobospan" id="kobo.94.1">one module</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">To create these modules, use the </span><strong class="bold"><span class="kobospan" id="kobo.96.1">File</span></strong><span class="kobospan" id="kobo.97.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.98.1">New</span></strong><span class="kobospan" id="kobo.99.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.100.1">New Module…</span></strong><span class="kobospan" id="kobo.101.1"> option, as we have done in the previous projects. </span><span class="kobospan" id="kobo.101.2">The final project structure should look </span><span><span class="kobospan" id="kobo.102.1">like this:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer057">
<span class="kobospan" id="kobo.103.1"><img alt="Figure 7.2: Project module structure" src="image/B19443_07_002.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.104.1">Figure 7.2: Project module structure</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.105.1">Now that we have </span><a id="_idIndexMarker766" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.106.1">created our module structure, it is time to set up the dependency </span><span><span class="kobospan" id="kobo.107.1">injection framework.</span></span></p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.108.1">Setting up the dependency injection framework</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">As we saw in the </span><a id="_idIndexMarker767" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.110.1">previous </span><a id="_idIndexMarker768" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.111.1">chapters, the need for scalability, performance optimization, and testability has made the use of a dependency injection framework practically a must in Android. </span><span class="kobospan" id="kobo.111.2">In this case, we will use Hilt again (to learn more about it, please refer to </span><a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.112.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.113.1"> where we did a complete review of the framework and exposed its </span><span><span class="kobospan" id="kobo.114.1">main advantages).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.115.1">Let’s start adding the dependency to our version catalog. </span><span class="kobospan" id="kobo.115.2">Open our </span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.117.1"> file and add the Hilt dependencies in the </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">versions</span></strong><span class="kobospan" id="kobo.119.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">libraries</span></strong><span class="kobospan" id="kobo.121.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.122.1">plugins</span></strong><span class="kobospan" id="kobo.123.1"> blocks, </span><span><span class="kobospan" id="kobo.124.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.125.1">
[versions]
// ...
</span><span class="kobospan1" id="kobo.125.2">hiltVersion = "2.50"
[libraries]
// ...
</span><span class="kobospan1" id="kobo.125.3">androidxHilt = { module = "com.google.dagger:hilt-android", name = "hilt", version.ref = "hiltVersion" }
hiltCompiler = { module = "com.google.dagger:hilt-android-compiler", name = "hilt-compiler", version.ref = "hiltVersion" }
[plugins]
// ...
</span><span class="kobospan1" id="kobo.125.4">hilt = { id = "com.google.dagger.hilt.android", version.ref = "hiltVersion" }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.126.1">Then, we will add the plugin to the </span><span><span class="kobospan" id="kobo.127.1">project-level </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">build.gradle.kts</span></strong></span><span><span class="kobospan" id="kobo.129.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.130.1">
plugins {
    ...
</span><span class="kobospan1" id="kobo.130.2">    alias(libs.plugins.hilt) apply false
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.131.1">Next, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">build.gradle.kts</span></strong><span class="kobospan" id="kobo.133.1"> file of every module, we will have to apply the plugin and</span><a id="_idIndexMarker769" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.134.1"> add </span><a id="_idIndexMarker770" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.135.1">the </span><span><span class="kobospan" id="kobo.136.1">Hilt dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.137.1">
plugins {
//...
</span><span class="kobospan1" id="kobo.137.2">    alias(libs.plugins.hilt)
}
dependencies {
//...
</span><span class="kobospan1" id="kobo.137.3">    implementation(libs.androidxHilt)
    kapt(libs.hiltCompiler)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.138.1">Now, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">:app</span></strong><span class="kobospan" id="kobo.140.1"> module, we can create the </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">PacktflixApp</span></strong><span class="kobospan" id="kobo.142.1"> class, which will be the entry point for the </span><span><span class="kobospan" id="kobo.143.1">Hilt configuration:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.144.1">
@HiltAndroidApp
class PacktflixApp: Application() {
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.145.1">With this annotation, we are enabling Hilt to generate the necessary components under the hood that will be used for dependency injection throughout </span><span><span class="kobospan" id="kobo.146.1">our application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.147.1">Finally, we should include </span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">PacktflixApp</span></strong><span class="kobospan" id="kobo.149.1"> in </span><strong class="source-inline"><span class="kobospan" id="kobo.150.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.151.1">, so that our app uses it</span><a id="_idIndexMarker771" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.152.1"> instead</span><a id="_idIndexMarker772" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.153.1"> of the default </span><span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">Application</span></strong></span><span><span class="kobospan" id="kobo.155.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.156.1">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android =
"http://schemas.android.com/apk/res/android"
    xmlns:tools = "http://schemas.android.com/tools"&gt;
    &lt;application
        android:name = ".PacktflixApp"
        ...&gt;
....
</span><span class="kobospan1" id="kobo.156.2">    &lt;/application&gt;
&lt;/manifest&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.157.1">Now, we are all set to start building our new project. </span><span class="kobospan" id="kobo.157.2">The first step will be to build the login screen as we </span><a id="_idIndexMarker773" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.158.1">want our users to </span><a id="_idIndexMarker774" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.159.1">authenticate themselves using their credentials. </span><span class="kobospan" id="kobo.159.2">Let’s start working </span><span><span class="kobospan" id="kobo.160.1">on it!</span></span></p>
<h1 id="_idParaDest-146" class="calibre5"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.161.1">Building the login screen</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.162.1">To build the</span><a id="_idIndexMarker775" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.163.1"> login screen, we will start creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.164.1">LoginScreen</span></strong><span class="kobospan" id="kobo.165.1"> composable </span><a id="_idIndexMarker776" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1">with Jetpack Compose. </span><span class="kobospan" id="kobo.166.2">We will have to include the app’s logo, fields to introduce the email and password, and a </span><strong class="bold"><span class="kobospan" id="kobo.167.1">Login</span></strong><span class="kobospan" id="kobo.168.1"> button. </span><span class="kobospan" id="kobo.168.2">We can also include a text to show whether there are any errors when the user tries to </span><span><span class="kobospan" id="kobo.169.1">log in.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.170.1">This login screen is going to have four states (</span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">Idle</span></strong><span class="kobospan" id="kobo.172.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">Loading</span></strong><span class="kobospan" id="kobo.174.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">Success</span></strong><span class="kobospan" id="kobo.176.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">Error</span></strong><span class="kobospan" id="kobo.178.1">), so let’s start modeling the </span><span><span class="kobospan" id="kobo.179.1">overall </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.180.1">ViewState</span></strong></span><span><span class="kobospan" id="kobo.181.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.182.1">
sealed class LoginState {
    object Idle : LoginState()
    object Loading : LoginState()
    object Success : LoginState()
    data class Error(val message: String?) : LoginState()
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.183.1">Now, let’s </span><a id="_idIndexMarker777" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.184.1">create </span><a id="_idIndexMarker778" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1">the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">LoginScreen</span></strong></span><span><span class="kobospan" id="kobo.187.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.188.1">
@Composable
fun LoginScreen() {
    val loginViewModel: LoginViewModel = hiltViewModel()
    val loginState =
        loginViewModel.loginState.collectAsState().value
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var errorMessage by remember { mutableStateOf("") }
//...
</span><span class="kobospan1" id="kobo.188.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.189.1">We start the composable function by obtaining </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">LoginViewModel</span></strong><span class="kobospan" id="kobo.191.1">, accessed via </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">hiltViewModel()</span></strong><span class="kobospan" id="kobo.193.1">. </span><span class="kobospan" id="kobo.193.2">This </span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">ViewModel</span></strong><span class="kobospan" id="kobo.195.1"> component manages the login logic and exposes the current login state through a </span><strong class="source-inline"><span class="kobospan" id="kobo.196.1">StateFlow</span></strong><span class="kobospan" id="kobo.197.1"> stream. </span><span class="kobospan" id="kobo.197.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.198.1">collectAsState().value</span></strong><span class="kobospan" id="kobo.199.1"> call converts the asynchronous stream of login states into a composable-friendly state that triggers recompositions when the login </span><span><span class="kobospan" id="kobo.200.1">state changes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.201.1">The function uses </span><strong class="source-inline"><span class="kobospan" id="kobo.202.1">remember { mutableStateOf("") }</span></strong><span class="kobospan" id="kobo.203.1"> to maintain the state of user inputs for email and password within the composable’s lifecycle. </span><span class="kobospan" id="kobo.203.2">This state is mutable and reactive, meaning any changes to the input fields (handled by </span><strong class="source-inline"><span class="kobospan" id="kobo.204.1">onValueChange</span></strong><span class="kobospan" id="kobo.205.1">) automatically update the corresponding variables and thus </span><span><span class="kobospan" id="kobo.206.1">the UI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.207.1">Let’s continue now with the next part of the composable, which will include the name of the app, the </span><a id="_idIndexMarker779" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.208.1">fields for </span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">email</span></strong><span class="kobospan" id="kobo.210.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.211.1">password</span></strong><span class="kobospan" id="kobo.212.1">, and</span><a id="_idIndexMarker780" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.213.1"> the </span><span><strong class="bold"><span class="kobospan" id="kobo.214.1">Login</span></strong></span><span><span class="kobospan" id="kobo.215.1"> button:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.216.1">
Surface(color = Color.Black, modifier =
Modifier.fillMaxSize()) {
        Column(
            horizontalAlignment =
                Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier
                .padding(16.dp)
        ) {
            if (loginState is LoginState.Error) {
                Text(
                    text = loginState.message ?:
                        "Unknown error",
                    color = Color.Red,
                    modifier = Modifier
                        .padding(bottom = 16.dp)
                )
            }
            Text(
                text = "PACKTFLIX",
                color = Color.Red,
                fontSize = 36.sp,
                modifier = Modifier.padding(bottom = 32.dp)
            )
            OutlinedTextField(
                value = email,
                onValueChange = { email = it },
                label = { Text("Email") },
                colors = OutlinedTextFieldDefaults.colors(
                    focusedContainerColor =
                        Color.Transparent,
                    focusedTextColor = Color.White,
                    focusedBorderColor = Color.Gray,
                    unfocusedBorderColor = Color.Gray
                ),
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Password") },
                visualTransformation =
                    PasswordVisualTransformation(),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedTextColor = Color.White,
                    focusedContainerColor =
                        Color.Transparent,
                    focusedBorderColor = Color.Gray,
                    unfocusedBorderColor = Color.Gray
                ),
                keyboardActions = KeyboardActions(
                    onDone = { loginViewModel.login(
                        email, password) }
                ),
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(24.dp))
            Button(
                onClick = { loginViewModel.login(email,
                    password) },
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.Gray)
            ) {
                Text("Sign In", color = Color.White)
            }
            Spacer(modifier = Modifier.height(24.dp))
            if (loginState is LoginState.Loading) {
                CircularProgressIndicator()
            }
        }
    }
    LaunchedEffect(loginState) {
        when (loginState) {
            is LoginState.Success -&gt; {
                // Navigate to next screen or show success
                   message
            }
            is LoginState.Error -&gt; {
                errorMessage = loginState.message ?:
                    "An error occurred"
            }
            else -&gt; Unit // Handle other states if
                            necessary
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.217.1">The UI dynamically adjusts based on the current login state. </span><span class="kobospan" id="kobo.217.2">For example, if the login state is </span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">LoginState.Error</span></strong><span class="kobospan" id="kobo.219.1">, the function renders a </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">Text</span></strong><span class="kobospan" id="kobo.221.1"> composable to display the error message. </span><span class="kobospan" id="kobo.221.2">This conditional rendering is crucial for providing feedback to the user, such as </span><a id="_idIndexMarker781" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.222.1">indicating a </span><a id="_idIndexMarker782" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.223.1">login failure or showing a loading indicator (</span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">CircularProgressIndicator</span></strong><span class="kobospan" id="kobo.225.1">) when the login process is underway. </span><span class="kobospan" id="kobo.225.2">This approach to UI development is declarative, with the UI’s structure and content directly mapping to the </span><span><span class="kobospan" id="kobo.226.1">application’s state.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.227.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">OutlinedTextField</span></strong><span class="kobospan" id="kobo.229.1"> composables for </span><strong class="source-inline"><span class="kobospan" id="kobo.230.1">email</span></strong><span class="kobospan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">password</span></strong><span class="kobospan" id="kobo.233.1"> capture user inputs, which are then used to initiate the login process (</span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">loginViewModel.login(email, password)</span></strong><span class="kobospan" id="kobo.235.1">) when the user clicks the </span><strong class="bold"><span class="kobospan" id="kobo.236.1">Sign In</span></strong><span class="kobospan" id="kobo.237.1"> button or completes the </span><strong class="source-inline"><span class="kobospan" id="kobo.238.1">password</span></strong><span class="kobospan" id="kobo.239.1"> field (via </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">KeyboardActions</span></strong><span class="kobospan" id="kobo.241.1">). </span><span class="kobospan" id="kobo.241.2">This demonstrates how to handle user actions and input in a composable, triggering </span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">ViewModel</span></strong><span class="kobospan" id="kobo.243.1"> actions that ultimately lead to </span><span><span class="kobospan" id="kobo.244.1">state changes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">Finally, the </span><strong class="source-inline"><span class="kobospan" id="kobo.246.1">LaunchedEffect</span></strong><span class="kobospan" id="kobo.247.1"> block listens for changes in the login state to perform side effects, such as navigation upon successful login or updating the error message state. </span><span class="kobospan" id="kobo.247.2">This pattern separates side effects from the UI logic, ensuring that effects such as navigation or showing toasts only occur in response to state changes, not as a direct result of </span><span><span class="kobospan" id="kobo.248.1">user actions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.249.1">Now, let’s start working </span><span><span class="kobospan" id="kobo.250.1">on </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">LoginViewModel</span></strong></span><span><span class="kobospan" id="kobo.252.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.253.1">
@HiltViewModel
class LoginViewModel @Inject constructor(
    private val loginUseCase: DoLoginUseCase
) : ViewModel() {
    private val _loginState =
        MutableStateFlow&lt;LoginState&gt;(LoginState.Idle)
    val loginState: StateFlow&lt;LoginState&gt; = _loginState
    fun login(email: String, password: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            val result = loginUseCase.doLogin(email,
                password)
            _loginState.value = when {
                result.isFailure -&gt; LoginState.Error(
                    result.exceptionOrNull()?.message)
                else -&gt; LoginState.Success
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.254.1">Here, we start with the </span><a id="_idIndexMarker783" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.255.1">dependency injection stuff: the use of </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">@HiltViewModel</span></strong><span class="kobospan" id="kobo.257.1"> indicates that Hilt will be responsible for the instantiation and provision of </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">LoginViewModel</span></strong><span class="kobospan" id="kobo.259.1">. </span><span class="kobospan" id="kobo.259.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">@Inject</span></strong><span class="kobospan" id="kobo.261.1"> constructor signifies that Hilt will inject the necessary dependencies into this </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">ViewModel</span></strong><span class="kobospan" id="kobo.263.1"> instance, in this case, an implementation of a use case called </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">DoLoginUseCase</span></strong><span class="kobospan" id="kobo.265.1"> (we will implement this use </span><span><span class="kobospan" id="kobo.266.1">case later).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.267.1"> The </span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">ViewModel</span></strong><span class="kobospan" id="kobo.269.1"> instance manages the login state using </span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">MutableStateFlow&lt;LoginState&gt;</span></strong><span class="kobospan" id="kobo.271.1">. </span><span class="kobospan" id="kobo.271.2">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">_loginState</span></strong><span class="kobospan" id="kobo.273.1"> is a private, mutable state flow that holds the current state of the login process, which can be one of </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">Idle</span></strong><span class="kobospan" id="kobo.275.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">Loading</span></strong><span class="kobospan" id="kobo.277.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">Success</span></strong><span class="kobospan" id="kobo.279.1">, or </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">Error</span></strong><span class="kobospan" id="kobo.281.1">. </span><span class="kobospan" id="kobo.281.2">The immutable </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">loginState</span></strong><span class="kobospan" id="kobo.283.1"> property exposes this state to the UI layer as a read-only </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">StateFlow</span></strong><span class="kobospan" id="kobo.285.1">, ensuring that state updates are safely and efficiently communicated to </span><span><span class="kobospan" id="kobo.286.1">the UI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.287.1">The login function embodies the core functionality of this </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">ViewModel</span></strong><span class="kobospan" id="kobo.289.1"> class. </span><span class="kobospan" id="kobo.289.2">It initiates the login process by setting </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">_loginState</span></strong><span class="kobospan" id="kobo.291.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">Loading</span></strong><span class="kobospan" id="kobo.293.1">, indicating that the login operation has started. </span><span class="kobospan" id="kobo.293.2">It then proceeds to call the </span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">doLogin</span></strong><span class="kobospan" id="kobo.295.1"> method on the provided </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">loginUseCase</span></strong><span class="kobospan" id="kobo.297.1"> with the user’s email </span><span><span class="kobospan" id="kobo.298.1">and password.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.299.1">After attempting to log in, the function evaluates the result. </span><span class="kobospan" id="kobo.299.2">If the login attempt fails (</span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">result.isFailure</span></strong><span class="kobospan" id="kobo.301.1">), </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">_loginState</span></strong><span class="kobospan" id="kobo.303.1"> is updated to </span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">Error</span></strong><span class="kobospan" id="kobo.305.1"> with the exception message, providing feedback on why the login failed. </span><span class="kobospan" id="kobo.305.2">If the login succeeds, </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">_loginState</span></strong><span class="kobospan" id="kobo.307.1"> is set to </span><strong class="source-inline"><span class="kobospan" id="kobo.308.1">Success</span></strong><span class="kobospan" id="kobo.309.1">, indicating a successful login process. </span><span class="kobospan" id="kobo.309.2">This conditional handling ensures that the UI can react appropriately to different outcomes of the </span><span><span class="kobospan" id="kobo.310.1">login process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.311.1"> The login </span><a id="_idIndexMarker784" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.312.1">process is</span><a id="_idIndexMarker785" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.313.1"> launched within </span><strong class="source-inline"><span class="kobospan" id="kobo.314.1">viewModelScope</span></strong><span class="kobospan" id="kobo.315.1">, a coroutine scope tied to the </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">ViewModel</span></strong><span class="kobospan" id="kobo.317.1"> lifecycle. </span><span class="kobospan" id="kobo.317.2">This ensures that any ongoing login operation is automatically canceled if the </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">ViewModel</span></strong><span class="kobospan" id="kobo.319.1"> instance is cleared (typically, when the associated UI component is destroyed), preventing memory leaks and </span><span><span class="kobospan" id="kobo.320.1">unnecessary work.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.321.1">With that, we have our login screen ready. </span><span class="kobospan" id="kobo.321.2">The last step is to set up the Hilt modules and set the content of </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">MainActivity</span></strong><span class="kobospan" id="kobo.323.1"> to show the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">LoginScreen</span></strong></span><span><span class="kobospan" id="kobo.325.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.326.1">
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            PacktflixTheme {
                LoginScreen()
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.327.1">If we now execute </span><a id="_idIndexMarker786" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.328.1">the app, we should see the </span><span><span class="kobospan" id="kobo.329.1">following screen:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer058">
<span class="kobospan" id="kobo.330.1"><img alt="Figure 7.3: Packtflix login screen" src="image/B19443_07_003.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.331.1">Figure 7.3: Packtflix login screen</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.332.1">Now that we have </span><a id="_idIndexMarker787" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.333.1">finished our UI, the next step will be to</span><a id="_idIndexMarker788" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.334.1"> authenticate the users. </span><span class="kobospan" id="kobo.334.2">Let’s learn how to </span><span><span class="kobospan" id="kobo.335.1">do it.</span></span></p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.336.1">Authenticating the app’s users</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.337.1">In mobile applications, authentication </span><a id="_idIndexMarker789" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.338.1">plays a critical role in protecting user data and personal information from unauthorized access. </span><span class="kobospan" id="kobo.338.2">As mobile devices often serve as personal gateways to a wide array of services and store a significant amount of sensitive data, ensuring that this data is securely managed and accessed is more important than ever. </span><span class="kobospan" id="kobo.338.3">One of the preferred methods for authenticating users </span><span><span class="kobospan" id="kobo.339.1">is OAuth2.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.340.1">OAuth2</span></strong><span class="kobospan" id="kobo.341.1"> is an authorization</span><a id="_idIndexMarker790" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.342.1"> framework that allows third-party services to exchange web resources on behalf of a user. </span><span class="kobospan" id="kobo.342.2">It enables users to grant websites or applications access to their information on other websites without giving them their passwords. </span><span class="kobospan" id="kobo.342.3">This is particularly useful for providing functionalities such as logging in with Google, Facebook, or other social </span><span><span class="kobospan" id="kobo.343.1">media accounts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.344.1">The following is a list of OAuth2’s most </span><span><span class="kobospan" id="kobo.345.1">important features:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.346.1">Security</span></strong><span class="kobospan" id="kobo.347.1">: It allows </span><a id="_idIndexMarker791" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.348.1">the user to authorize an application to access their resources on a different server without sharing their credentials, typically by using access tokens granted through a process involving user consent and secure </span><span><span class="kobospan" id="kobo.349.1">token exchanges.</span></span><p class="calibre3"><span class="kobospan" id="kobo.350.1">An OAuth </span><strong class="bold"><span class="kobospan" id="kobo.351.1">token</span></strong><span class="kobospan" id="kobo.352.1"> is a credential that represents the authorization granted to the application, allowing it to access specific resources on behalf of the user. </span><span class="kobospan" id="kobo.352.2">These tokens can come in various formats, such as opaque tokens or </span><strong class="bold"><span class="kobospan" id="kobo.353.1">JSON Web Tokens</span></strong><span class="kobospan" id="kobo.354.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.355.1">JWTs</span></strong><span class="kobospan" id="kobo.356.1">). </span><span class="kobospan" id="kobo.356.2">Opaque </span><a id="_idIndexMarker792" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.357.1">tokens are simple strings without any specific structure, while JWTs are structured tokens that consist of three parts – a header, a payload, and a signature – all encoded </span><span><span class="kobospan" id="kobo.358.1">in Base64.</span></span></p></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.359.1">Scalability</span></strong><span class="kobospan" id="kobo.360.1">: It allows for the delegation of user authentication to the service that hosts the user account, by offloading the technical complexities of secure authentication and infrastructure scalability to dedicated services. </span><span class="kobospan" id="kobo.360.2">These services are usually managed by specific teams in charge of the complex and resource-intensive tasks of securing and scaling </span><span><span class="kobospan" id="kobo.361.1">authentication processes.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.362.1">Flexibility</span></strong><span class="kobospan" id="kobo.363.1">: It supports multiple flows (based on grant types, which will determine the flow the authentication process has to follow) for different types of clients, including mobile apps, websites, and </span><span><span class="kobospan" id="kobo.364.1">server-side applications.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.365.1">User Experience</span></strong><span class="kobospan" id="kobo.366.1">: It enables a smoother login experience for users, as users can use existing accounts</span><a id="_idIndexMarker793" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.367.1"> to sign in to new services without creating </span><span><span class="kobospan" id="kobo.368.1">new credentials.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.369.1">In essence, OAuth2 provides a secure and efficient way to implement authentication in mobile applications. </span><span class="kobospan" id="kobo.369.2">It leverages existing user accounts, which simplifies the login process for users, and </span><a id="_idIndexMarker794" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.370.1">offloads the complexity of managing user credentials and sessions to a third-party service, enhancing both security and </span><span><span class="kobospan" id="kobo.371.1">user experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.372.1">Let’s add this feature to our app, starting by adding the models that </span><span><span class="kobospan" id="kobo.373.1">are needed.</span></span></p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.374.1">Creating the user model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.375.1">First, we will define </span><a id="_idIndexMarker795" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.376.1">a simple user model that will hold the user information we will receive upon </span><span><span class="kobospan" id="kobo.377.1">successful authentication:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.378.1">
data class User(
    val id: String,
    val name: String,
    val email: String,
    // Add other fields as necessary
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.379.1">In this code, we are defining the basic fields needed to hold the user information (depending on the requirements of your app, these fields will </span><span><span class="kobospan" id="kobo.380.1">be different).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.381.1">Then, to build the login request that we are going to send to the backend to obtain the authentication token, we will need another data class to hold </span><span><span class="kobospan" id="kobo.382.1">the credentials:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.383.1">
data class LoginRequest(val email: String, val password:
String)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.384.1">Here, we are including the </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">email</span></strong><span class="kobospan" id="kobo.386.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.387.1">password</span></strong><span class="kobospan" id="kobo.388.1"> fields, which will be mandatory to be able to log </span><span><span class="kobospan" id="kobo.389.1">users in.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.390.1">Once this request reaches the backend, if the credentials are correct, the backend will return an authorization token, which our app will store in a secure place and will use to authenticate the following API calls to the backend. </span><span class="kobospan" id="kobo.390.2">We will need another model to hold this </span><span><span class="kobospan" id="kobo.391.1">token </span></span><span><a id="_idIndexMarker796" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.392.1">information:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.393.1">
data class AuthToken(val token: String)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.394.1">Now, let’s set Retrofit to get this </span><span><span class="kobospan" id="kobo.395.1">authorization token.</span></span></p>
<h2 id="_idParaDest-149" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.396.1">Using Retrofit to get the authorization token</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.397.1">To obtain the </span><a id="_idIndexMarker797" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.398.1">authorization </span><a id="_idIndexMarker798" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.399.1">token, we need</span><a id="_idIndexMarker799" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.400.1"> our app to request it when the user provides their credentials. </span><span class="kobospan" id="kobo.400.2">In order to send this request to the backend, we are going to use Retrofit. </span><span class="kobospan" id="kobo.400.3">We already used Retrofit in </span><a href="B19443_04_split_000.xhtml#_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.401.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.402.1">, so let’s skip the introductions and start with the setup of an interface that Retrofit will use to make the </span><span><span class="kobospan" id="kobo.403.1">HTTP requests:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.404.1">
interface AuthService {
    @POST("auth/login")
    suspend fun login(@Body loginRequest: LoginRequest):
        Response&lt;AuthToken&gt;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.405.1">This code defines an interface called </span><strong class="source-inline"><span class="kobospan" id="kobo.406.1">AuthService</span></strong><span class="kobospan" id="kobo.407.1"> with a unique login function. </span><span class="kobospan" id="kobo.407.2">We will pass a </span><strong class="source-inline"><span class="kobospan" id="kobo.408.1">LoginRequest</span></strong><span class="kobospan" id="kobo.409.1"> object with the data needed for the request and then will obtain an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">AuthToken</span></strong></span><span><span class="kobospan" id="kobo.411.1"> response.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.412.1">Let’s build those models. </span><span class="kobospan" id="kobo.412.2">First, we’ll build the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">LoginRequest</span></strong></span><span><span class="kobospan" id="kobo.414.1"> model:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.415.1">
data class LoginRequest(val email: String, val password:
String)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.416.1">In this model, we will send the user’s credentials – their email and password – to </span><span><span class="kobospan" id="kobo.417.1">the backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">Then, if the login has been successful, the backend should answer with a response including an authorization token. </span><span class="kobospan" id="kobo.418.2">We will structure this response </span><span><span class="kobospan" id="kobo.419.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.420.1">
data class AuthToken(val token: String)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.421.1">This </span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">AuthToken</span></strong><span class="kobospan" id="kobo.423.1"> model will include the aforementioned authorization token. </span><span class="kobospan" id="kobo.423.2">Note that, usually, these tokens have a time window and so have to be renewed before they have expired. </span><span class="kobospan" id="kobo.423.3">For simplicity, we are going to assume this token will </span><span><span class="kobospan" id="kobo.424.1">not expire.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">Now, let’s create</span><a id="_idIndexMarker800" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.426.1"> our remote</span><a id="_idIndexMarker801" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.427.1"> data source to retrieve </span><a id="_idIndexMarker802" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1">the </span><span><span class="kobospan" id="kobo.429.1">authorization token:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.430.1">
class LoginRemoteDataSource(
    private val authService: AuthService
) {
    suspend fun login(email: String, password: String):
    Result&lt;String&gt; {
        return authService.login(
            LoginRequest(
                email = email,
                password = password
            )
        ).run {
            val token = this.body()?.token
            if (this.isSuccessful &amp;&amp; token != null) {
                Result.success(token)
            } else {
                Result.failure(getError(this))
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.431.1">Here, we define the </span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">LoginRemoteDataSource</span></strong><span class="kobospan" id="kobo.433.1"> class, which will act as a data source layer for handling login functionality by interacting with the remote authentication service. </span><span class="kobospan" id="kobo.433.2">This class will have a single dependency, </span><strong class="source-inline"><span class="kobospan" id="kobo.434.1">authService</span></strong><span class="kobospan" id="kobo.435.1">, which is an interface (presumably Retrofit or a similar networking library) responsible for making network requests related to authentication. </span><span class="kobospan" id="kobo.435.2">The primary function within this class, </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">login</span></strong><span class="kobospan" id="kobo.437.1">, is a suspended function that takes two parameters, </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">email</span></strong><span class="kobospan" id="kobo.439.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">password</span></strong><span class="kobospan" id="kobo.441.1">, which are used to construct a </span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">LoginRequest</span></strong><span class="kobospan" id="kobo.443.1"> object. </span><span class="kobospan" id="kobo.443.2">This object is then passed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">authService.login</span></strong><span class="kobospan" id="kobo.445.1"> method, initiating a network request to log the </span><span><span class="kobospan" id="kobo.446.1">user in.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.447.1">Upon receiving the response from </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">authService.login</span></strong><span class="kobospan" id="kobo.449.1">, the </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">run</span></strong><span class="kobospan" id="kobo.451.1"> block is executed to handle the response. </span><span class="kobospan" id="kobo.451.2">Inside this block, the response is checked to determine whether the request was successful (</span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">isSuccessful</span></strong><span class="kobospan" id="kobo.453.1">) and whether the response body contains a non-</span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">null</span></strong><span class="kobospan" id="kobo.455.1"> token. </span><span class="kobospan" id="kobo.455.2">If both conditions are met, </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">Result.success(token)</span></strong><span class="kobospan" id="kobo.457.1"> is returned, encapsulating the token in a successful result. </span><span class="kobospan" id="kobo.457.2">This indicates that the login was successful and provides the caller with the token. </span><span class="kobospan" id="kobo.457.3">Conversely, if either condition is not satisfied – meaning the request failed or the token was null – a failure result is returned by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">Result.failure(getError(this))</span></strong><span class="kobospan" id="kobo.459.1">. </span><span class="kobospan" id="kobo.459.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">getError</span></strong><span class="kobospan" id="kobo.461.1"> function will analyze the </span><strong class="source-inline"><span class="kobospan" id="kobo.462.1">Response&lt;AuthToken&gt;</span></strong><span class="kobospan" id="kobo.463.1"> object to determine the nature of the failure and </span><a id="_idIndexMarker803" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.464.1">return</span><a id="_idIndexMarker804" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.465.1"> an </span><a id="_idIndexMarker805" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.466.1">appropriate </span><strong class="source-inline"><span class="kobospan" id="kobo.467.1">Throwable</span></strong><span class="kobospan" id="kobo.468.1"> object that describes </span><span><span class="kobospan" id="kobo.469.1">the error.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.470.1">At this point, let’s build the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">getError()</span></strong></span><span><span class="kobospan" id="kobo.472.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.473.1">
    private fun getError(response: Response&lt;AuthToken&gt;):
    Throwable {
        return when (response.code()) {
            401 -&gt; LoginException.AuthenticationException(
                "Invalid email or password.")
            403 -&gt; LoginException.AccessDeniedException(
                "Access denied.")
            404 -&gt; LoginException.NotFoundException(
                "Login endpoint not found.")
            in 500..599 -&gt; LoginException.ServerException(
                "Server error: ${response.message()}.")
            else -&gt; LoginException.HttpException(
                response.code(),
                "HTTP error: ${response.code()}
                    ${response.message()}."
</span><span class="kobospan1" id="kobo.473.2">            )
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.474.1">In this </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">getError</span></strong><span class="kobospan" id="kobo.476.1"> function, we map the possible values of the status code from the response to different errors. </span><span class="kobospan" id="kobo.476.2">If we wanted to, we could later process those errors and show messages to the </span><span><span class="kobospan" id="kobo.477.1">user accordingly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">Let’s also define those errors, in which we will map the server response. </span><span class="kobospan" id="kobo.478.2">We will define them as part of a </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">LoginException</span></strong><span class="kobospan" id="kobo.480.1"> sealed class, which is a special type of class in Kotlin that restricts the inheritance hierarchy to a specific set of subclasses, providing exhaustive </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">when</span></strong><span class="kobospan" id="kobo.482.1"> expressions</span><a id="_idIndexMarker806" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.483.1"> and </span><a id="_idIndexMarker807" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.484.1">ensuring that every possible type </span><a id="_idIndexMarker808" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.485.1">of error </span><span><span class="kobospan" id="kobo.486.1">is handled:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.487.1">
sealed class LoginException(loginErrorMessage: String, val
code: Int? </span><span class="kobospan1" id="kobo.487.2">= null) : Exception(loginErrorMessage) {
    class AuthenticationException(message: String) :
        LoginException(message)
    class AccessDeniedException(message: String) :
        LoginException(message)
    class NotFoundException(message: String) :
        LoginException(message)
    class ServerException(message: String) :
        LoginException(message)
    class HttpException(code: Int, message: String) :
        LoginException(message, code)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.488.1">Now that we have our </span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">LoginRemoteDataSource</span></strong><span class="kobospan" id="kobo.490.1"> component, it is time to define how to</span><a id="_idIndexMarker809" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.491.1"> store</span><a id="_idIndexMarker810" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.492.1">the</span></span><span><a id="_idIndexMarker811" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.493.1"> token.</span></span></p>
<h2 id="_idParaDest-150" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.494.1">Using DataStore to store the token</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">Introduced by Google, </span><strong class="bold"><span class="kobospan" id="kobo.496.1">DataStore</span></strong><span class="kobospan" id="kobo.497.1"> is a data storage solution that provides an efficient, secure, and </span><a id="_idIndexMarker812" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.498.1">asynchronous</span><a id="_idIndexMarker813" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.499.1"> way of persisting small pieces of data. </span><span class="kobospan" id="kobo.499.2">It uses Kotlin coroutines and flow streams to store data asynchronously, ensuring UI thread safety and </span><span><span class="kobospan" id="kobo.500.1">smoother performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.501.1">DataStore comes with several features that make it a preferable data storage option in </span><span><span class="kobospan" id="kobo.502.1">Android applications:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.503.1">Asynchronous by default</span></strong><span class="kobospan" id="kobo.504.1">: DataStore </span><a id="_idIndexMarker814" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.505.1">operations are performed asynchronously using Kotlin coroutines, preventing blocking the main thread and improving </span><span><span class="kobospan" id="kobo.506.1">app performance.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.507.1">Safe and consistent</span></strong><span class="kobospan" id="kobo.508.1">: With built-in transactional data APIs, DataStore ensures data consistency and integrity, even if an app process is killed during a </span><span><span class="kobospan" id="kobo.509.1">write operation.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.510.1">Type safety</span></strong><span class="kobospan" id="kobo.511.1">: DataStore offers two implementations: Preferences DataStore, which stores and retrieves key-value pairs, and Proto DataStore, which allows for storing type-safe objects using </span><span><span class="kobospan" id="kobo.512.1">Protocol Buffers.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.513.1">Security</span></strong><span class="kobospan" id="kobo.514.1">: DataStore can be integrated with encryption mechanisms to securely store sensitive information. </span><span class="kobospan" id="kobo.514.2">DataStore can be combined with encryption libraries such as Tink to encrypt the data before saving, making it a more secure option for handling</span><a id="_idIndexMarker815" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.515.1"> user credentials, tokens, and other </span><span><span class="kobospan" id="kobo.516.1">sensitive information.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">Why will we use DataStore and not Room (which we used previously for our WhatsPackt messenger project)? </span><span class="kobospan" id="kobo.517.2">While both are robust data persistence libraries, they serve different purposes and have distinct </span><span><span class="kobospan" id="kobo.518.1">use cases:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.519.1">Use case suitability</span></strong><span class="kobospan" id="kobo.520.1">: DataStore</span><a id="_idIndexMarker816" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.521.1"> is designed for storing small collections of data, such as settings, preferences, or application state. </span><span class="kobospan" id="kobo.521.2">It excels in handling lightweight tasks where the data structure is simple. </span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">RoomDatabase</span></strong><span class="kobospan" id="kobo.523.1"> is a SQLite abstraction that significantly reduces the amount of boilerplate code needed to use SQLite. </span><span class="kobospan" id="kobo.523.2">It’s intended for more complex data storage requirements, such as storing large datasets, relational data, or when we need to perform </span><span><span class="kobospan" id="kobo.524.1">complex queries.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.525.1">Performance and complexity</span></strong><span class="kobospan" id="kobo.526.1">: DataStore provides a simpler API for data storage with minimal setup, making it ideal for straightforward tasks. </span><span class="kobospan" id="kobo.526.2">Its performance is optimized for small datasets and simple data structures. </span><strong class="source-inline1"><span class="kobospan" id="kobo.527.1">RoomDatabase</span></strong><span class="kobospan" id="kobo.528.1">, being a database, is more suited for complex queries and large datasets. </span><span class="kobospan" id="kobo.528.2">It involves more setup and is heavier than DataStore but offers more features and capabilities for comprehensive </span><span><span class="kobospan" id="kobo.529.1">data management.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.530.1">Data security</span></strong><span class="kobospan" id="kobo.531.1">: DataStore, especially with Proto DataStore, can easily be integrated with encryption mechanisms to store data securely, making it a more secure option for sensitive information. </span><strong class="source-inline1"><span class="kobospan" id="kobo.532.1">RoomDatabase</span></strong><span class="kobospan" id="kobo.533.1"> supports SQLite encryption, but integrating encryption requires additional setup and possibly </span><span><span class="kobospan" id="kobo.534.1">third-party libraries.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">As we just need to</span><a id="_idIndexMarker817" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.536.1"> store a small </span><a id="_idIndexMarker818" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.537.1">value (the token) and given its security features, DataStore is the </span><span><span class="kobospan" id="kobo.538.1">best option.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.539.1">So, to start using it, first, we need to set up the DataStore dependency and its version in our </span><span><span class="kobospan" id="kobo.540.1">version catalog:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.541.1">
[versions]
datastore = "1.0.0"
[libraries]
datastore = { module = "androidx.datastore:datastore-
preferences", version.ref = "datastore" }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.542.1">Then, need to add it to our modules’ </span><span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">gradle.build.kts</span></strong></span><span><span class="kobospan" id="kobo.544.1"> files:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.545.1">
dependencies {
 ...
</span><span class="kobospan1" id="kobo.545.2">    implementation(libs.datastore)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.546.1">With this code, we are only adding it to the modules where we would need to use the dependency – initially, this will just be in the </span><strong class="source-inline"><span class="kobospan" id="kobo.547.1">:feature:login</span></strong> <span><span class="kobospan" id="kobo.548.1">module.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.549.1">Now, we can start using the DataStore library. </span><span class="kobospan" id="kobo.549.2">We are going to build a </span><strong class="source-inline"><span class="kobospan" id="kobo.550.1">LoginLocalDataSource</span></strong><span class="kobospan" id="kobo.551.1"> component, which will be responsible for storing and retrieving the</span><a id="_idIndexMarker819" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.552.1"> token in and</span><a id="_idIndexMarker820" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.553.1"> from </span><span><span class="kobospan" id="kobo.554.1">the DataStore:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.555.1">
val Context.dataStore by preferencesDataStore(name = "user_preferences")
class LoginLocalDataSource(private val context: Context) {
    companion object {
        val TOKEN_KEY = stringPreferencesKey("auth_token")
    }
    suspend fun saveAuthToken(token: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[TOKEN_KEY] = token
        }
    }
    suspend fun getAuthToken(): Result&lt;String&gt; {
        val preferences = context.dataStore.data.first()
        val token = preferences[TOKEN_KEY]
        return if (token != null) {
            Result.success(token)
        } else {
            Result.failure(TokenNotFoundError())
        }
    }
}
class TokenNotFoundError : Throwable("Auth token not
found")</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.556.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">LoginLocalDataSource</span></strong><span class="kobospan" id="kobo.558.1">, first, we leverage Kotlin’s property delegation feature to initialize the DataStore. </span><span class="kobospan" id="kobo.558.2">By defining </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">val Context.dataStore</span></strong><span class="kobospan" id="kobo.560.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">preferencesDataStore(name: "user_preferences")</span></strong><span class="kobospan" id="kobo.562.1">, we ensure a single instance of the DataStore is lazily initialized and tied to the application’s context. </span><span class="kobospan" id="kobo.562.2">This method optimizes resource use and simplifies subsequent </span><span><span class="kobospan" id="kobo.563.1">data operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.564.1">Within </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">LoginLocalDataSource</span></strong><span class="kobospan" id="kobo.566.1">, we define a companion object to hold </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">TOKEN_KEY</span></strong><span class="kobospan" id="kobo.568.1">, a key used to store and retrieve the authentication token from the DataStore. </span><span class="kobospan" id="kobo.568.2">This key is defined using </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">stringPreferencesKey("auth_token")</span></strong><span class="kobospan" id="kobo.570.1">, indicating the data type we intend to store – in this case, a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">String</span></strong></span><span><span class="kobospan" id="kobo.572.1"> type.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.573.1">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.574.1">saveAuthToken</span></strong><span class="kobospan" id="kobo.575.1"> function, we perform a write operation on the DataStore by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.576.1">edit</span></strong><span class="kobospan" id="kobo.577.1"> and passing a lambda that assigns the provided token to </span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">TOKEN_KEY</span></strong><span class="kobospan" id="kobo.579.1">. </span><span class="kobospan" id="kobo.579.2">This operation is atomic and thread-safe, ensuring the integrity of </span><span><span class="kobospan" id="kobo.580.1">our data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">To retrieve</span><a id="_idIndexMarker821" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.582.1"> the</span><a id="_idIndexMarker822" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1"> authentication token, </span><strong class="source-inline"><span class="kobospan" id="kobo.584.1">getAuthToken</span></strong><span class="kobospan" id="kobo.585.1"> also employs suspending semantics to facilitate asynchronous execution. </span><span class="kobospan" id="kobo.585.2">It accesses the DataStore’s data as a flow, immediately fetching the first emitted value with </span><strong class="source-inline"><span class="kobospan" id="kobo.586.1">.data.first()</span></strong><span class="kobospan" id="kobo.587.1">. </span><span class="kobospan" id="kobo.587.2">This operation suspends the coroutine, effectively making the data retrieval feel synchronous while maintaining the benefits of asynchronous execution. </span><span class="kobospan" id="kobo.587.3">The function then checks whether the token exists and returns it wrapped in </span><strong class="source-inline"><span class="kobospan" id="kobo.588.1">Result&lt;String&gt;</span></strong><span class="kobospan" id="kobo.589.1">, providing a straightforward way to handle success and failure. </span><span class="kobospan" id="kobo.589.2">In the absence of a token, it returns </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">Result.failure</span></strong><span class="kobospan" id="kobo.591.1"> with a custom </span><strong class="source-inline"><span class="kobospan" id="kobo.592.1">TokenNotFoundError</span></strong><span class="kobospan" id="kobo.593.1">, offering precise </span><span><span class="kobospan" id="kobo.594.1">error handling.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.595.1">Now, it is time to implement </span><strong class="source-inline"><span class="kobospan" id="kobo.596.1">LoginRepository</span></strong><span class="kobospan" id="kobo.597.1">, which is responsible for coordinating between the remote and local data sources. </span><span class="kobospan" id="kobo.597.2">We will build it, as always, by creating an interface in the domain layer and the implementation in the data layer. </span><span class="kobospan" id="kobo.597.3">This is because the domain shouldn’t have any explicit dependency from the data layer, to respect the clean architecture. </span><span class="kobospan" id="kobo.597.4">So, we define the interface </span><span><span class="kobospan" id="kobo.598.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.599.1">
interface LoginRepository {
    suspend fun getToken(): Result&lt;String&gt;
    suspend fun loginWithCredentials(email: String,
        password: String): Result&lt;Unit&gt;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.600.1">Here, the interface will have two functions: one to obtain the token so it can be used elsewhere (for example, for the backend requests to authenticate the user once it has been obtained) </span><a id="_idIndexMarker823" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.601.1">and another</span><a id="_idIndexMarker824" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.602.1"> to perform the login and store the newly obtained </span><span><span class="kobospan" id="kobo.603.1">authentication token.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">Now, let’s implement </span><span><span class="kobospan" id="kobo.605.1">the repository:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.606.1">
class LoginRepositoryImpl(
    private val localDataSource: LoginLocalDataSource,
    private val remoteDataSource: LoginRemoteDataSource
): LoginRepository {
    override suspend fun getToken(): Result&lt;String&gt; {
        return localDataSource.getAuthToken()
    }
    override suspend fun loginWithCredentials(email:
    String, password: String): Result&lt;Unit&gt; {
        return remoteDataSource.login(email, password)
            .fold(
                onSuccess = {
                    localDataSource.saveAuthToken(it)
                    Result.success(Unit)
                },
                onFailure = {
                    Result.failure(it)
                }
            )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.607.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">LoginRepositoryImpl</span></strong><span class="kobospan" id="kobo.609.1"> class serves as an implementation of the </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">LoginRepository</span></strong><span class="kobospan" id="kobo.611.1"> interface, acting as a mediator between the application’s data sources and its use cases or view models. </span><span class="kobospan" id="kobo.611.2">This class abstracts the details of data retrieval and storage, providing a cohesive API for authentication processes. </span><span class="kobospan" id="kobo.611.3">It relies on two primary data sources: </span><strong class="source-inline"><span class="kobospan" id="kobo.612.1">localDataSource</span></strong><span class="kobospan" id="kobo.613.1"> for local data storage and retrieval, and </span><strong class="source-inline"><span class="kobospan" id="kobo.614.1">remoteDataSource</span></strong><span class="kobospan" id="kobo.615.1"> for handling network requests related to </span><span><span class="kobospan" id="kobo.616.1">user authentication.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.617.1">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.618.1">getToken</span></strong><span class="kobospan" id="kobo.619.1"> function, the repository directly delegates the call to </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">localDataSource.getAuthToken()</span></strong><span class="kobospan" id="kobo.621.1">, which fetches the authentication token from local storage. </span><span class="kobospan" id="kobo.621.2">This method returns a </span><strong class="source-inline"><span class="kobospan" id="kobo.622.1">Result&lt;String&gt;</span></strong><span class="kobospan" id="kobo.623.1"> object,  encapsulating the outcome</span><a id="_idIndexMarker825" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.624.1"> of the</span><a id="_idIndexMarker826" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.625.1"> operation in a type-safe manner. </span><span class="kobospan" id="kobo.625.2">The token retrieval is critical for checking the user’s authentication status or for subsequent authenticated API calls that require </span><span><span class="kobospan" id="kobo.626.1">a token.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.627.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.628.1">loginWithCredentials</span></strong><span class="kobospan" id="kobo.629.1"> function implements the process of authenticating a user with their email and password. </span><span class="kobospan" id="kobo.629.2">It first attempts to log in through the </span><strong class="source-inline"><span class="kobospan" id="kobo.630.1">remoteDataSource.login(email, password)</span></strong><span class="kobospan" id="kobo.631.1"> method. </span><span class="kobospan" id="kobo.631.2">Upon a successful login, indicated by the </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">onSuccess</span></strong><span class="kobospan" id="kobo.633.1"> branch of the fold, it saves the received authorization token using </span><strong class="source-inline"><span class="kobospan" id="kobo.634.1">localDataSource.saveAuthToken(it)</span></strong><span class="kobospan" id="kobo.635.1"> and then signals the completion of the login process with </span><strong class="source-inline"><span class="kobospan" id="kobo.636.1">Result.success(Unit)</span></strong><span class="kobospan" id="kobo.637.1">. </span><span class="kobospan" id="kobo.637.2">Conversely, if the remote login attempt fails (</span><strong class="source-inline"><span class="kobospan" id="kobo.638.1">onFailure</span></strong><span class="kobospan" id="kobo.639.1">), it propagates the failure as </span><strong class="source-inline"><span class="kobospan" id="kobo.640.1">Result.failure(it)</span></strong><span class="kobospan" id="kobo.641.1">, allowing the calling code to handle the error appropriately. </span><span class="kobospan" id="kobo.641.2">This design effectively separates concerns between local and remote data handling, ensuring that the repository remains the single source of truth for all authentication-related data flows within </span><span><span class="kobospan" id="kobo.642.1">the application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.643.1">Now, we can build a </span><a id="_idIndexMarker827" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.644.1">use case to perform the login, consuming this </span><span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">LoginRepository</span></strong></span><span><span class="kobospan" id="kobo.646.1"> component:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.647.1">
interface DoLoginUseCase {
    suspend fun doLogin(email: String, password: String):
        Result&lt;Unit&gt;
}
class DoLogin(
    private val loginRepository: LoginRepository
) : DoLoginUseCase {
    override suspend fun doLogin(email: String, password:
    String): Result&lt;Unit&gt; {
        return loginRepository.loginWithCredentials(email,
            password)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.648.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.649.1">DoLogin</span></strong><span class="kobospan" id="kobo.650.1"> class implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.651.1">DoLoginUseCase</span></strong><span class="kobospan" id="kobo.652.1"> interface, encapsulating the logic required to authenticate a user by their email and password. </span><span class="kobospan" id="kobo.652.2">By delegating the authentication process to </span><strong class="source-inline"><span class="kobospan" id="kobo.653.1">loginRepository</span></strong><span class="kobospan" id="kobo.654.1">, it invokes </span><strong class="source-inline"><span class="kobospan" id="kobo.655.1">loginRepository.loginWithCredentials(email, password)</span></strong><span class="kobospan" id="kobo.656.1"> to perform the actual login operation. </span><span class="kobospan" id="kobo.656.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">DoLogin</span></strong><span class="kobospan" id="kobo.658.1"> use case simplifies the process of user authentication into a single method call, ensuring that the details of how the login is performed are encapsulated within the repository, thereby promoting the separation of concerns and</span><a id="_idIndexMarker828" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.659.1"> making the</span><a id="_idIndexMarker829" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.660.1"> code easier to maintain </span><span><span class="kobospan" id="kobo.661.1">and test.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.662.1">Now, we are all set to use the login functionality. </span><span class="kobospan" id="kobo.662.2">Next, let’s use those tokens to validate the </span><span><span class="kobospan" id="kobo.663.1">app requests.</span></span></p>
<h2 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.664.1">Sending the authorization token in requests</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.665.1">To finish the </span><a id="_idIndexMarker830" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.666.1">users authentication:authorization token, sending in requests” authentication </span><a id="_idIndexMarker831" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.667.1">tasks, there is still one thing we have to do. </span><span class="kobospan" id="kobo.667.2">The reason we were obtaining this authentication token was to be used in the requests the app is going to send to the backend, so it will guarantee the authenticity of the user that has generated the request. </span><span class="kobospan" id="kobo.667.3">To include the token in every request, we are going to take advantage of </span><span><span class="kobospan" id="kobo.668.1">Retrofit interceptors.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.669.1">A Retrofit </span><strong class="bold"><span class="kobospan" id="kobo.670.1">interceptor</span></strong><span class="kobospan" id="kobo.671.1"> is a</span><a id="_idIndexMarker832" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.672.1"> powerful mechanism provided by OkHttp (the underlying HTTP client used by Retrofit) that allows you to intercept and manipulate the request and response chain. </span><span class="kobospan" id="kobo.672.2">Interceptors can modify requests and responses or perform actions such as logging, adding headers, handling authentication, and much more, before the request is sent to the server or after the response is received by </span><span><span class="kobospan" id="kobo.673.1">the client.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.674.1">Interceptors can be broadly categorized into </span><span><span class="kobospan" id="kobo.675.1">two types:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.676.1">Application interceptors</span></strong><span class="kobospan" id="kobo.677.1">: These </span><a id="_idIndexMarker833" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.678.1">interceptors are called once for any single call to the server. </span><span class="kobospan" id="kobo.678.2">They don’t need to worry about network specifics such as retries and redirects. </span><span class="kobospan" id="kobo.678.3">Application interceptors are perfect for tasks such as adding a common header to all requests, logging the request and response body for debugging purposes, or managing </span><span><span class="kobospan" id="kobo.679.1">application-level caching.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.680.1">Network interceptors</span></strong><span class="kobospan" id="kobo.681.1">: These interceptors can monitor the data at the network level. </span><span class="kobospan" id="kobo.681.2">They can observe and manipulate requests and responses that come from and go</span><a id="_idIndexMarker834" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.682.1"> to the server, including any retries and redirects that occur as part of the network </span><span><span class="kobospan" id="kobo.683.1">call process.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.684.1">To add an authentication token to all outgoing requests, we will choose an application interceptor. </span><span class="kobospan" id="kobo.684.2">We will choose an application interceptor in this scenario because they are designed to operate at the application layer, directly modifying requests before they are sent out and processing responses once they are received. </span><span class="kobospan" id="kobo.684.3">This makes them well suited for tasks such as adding</span><a id="_idIndexMarker835" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.685.1"> headers that should be included in every request to the server, such as </span><span><span class="kobospan" id="kobo.686.1">authentication tokens.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.687.1">So, let’s write </span><span><span class="kobospan" id="kobo.688.1">our interceptor:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.689.1">
class AuthInterceptor(private val loginRepository:
LoginRepository) : Interceptor {
    override fun intercept(chain: Interceptor.Chain):
    Response {
        val originalRequest = chain.request()
        val token = runBlocking {
            loginRepository.getToken().getOrNull() }
        val requestWithToken = originalRequest.newBuilder()
            .apply {
                if (token != null) {
                    header("Authorization",
                        "Bearer $token")
                }
            }
            .build()
        return chain.proceed(requestWithToken)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.690.1">This class plays a critical role in enriching outgoing HTTP requests with authentication details. </span><span class="kobospan" id="kobo.690.2">It achieves this by integrating with </span><strong class="source-inline"><span class="kobospan" id="kobo.691.1">LoginRepository</span></strong><span class="kobospan" id="kobo.692.1">, from which it retrieves the current user’s authorization token. </span><span class="kobospan" id="kobo.692.2">Upon intercepting a request, the interceptor fetches the</span><a id="_idIndexMarker836" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.693.1">users authentication:authorization token, sending in requests”  token </span><a id="_idIndexMarker837" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.694.1">synchronously using </span><strong class="source-inline"><span class="kobospan" id="kobo.695.1">runBlocking</span></strong><span class="kobospan" id="kobo.696.1"> (a mechanism that allows for the seamless integration of coroutine-based asynchronous token retrieval into the synchronous flow expected </span><span><span class="kobospan" id="kobo.697.1">by interceptors).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.698.1">If a token is present, it’s appended to the request as an </span><strong class="source-inline"><span class="kobospan" id="kobo.699.1">Authorization</span></strong><span class="kobospan" id="kobo.700.1"> header, adhering to the widely accepted bearer token format (the bearer token format is a security scheme where a client sends a token in the header of the requests to authenticate access, prefixed with the word </span><strong class="source-inline"><span class="kobospan" id="kobo.701.1">Bearer</span></strong><span class="kobospan" id="kobo.702.1"> followed by a space and the token itself), thereby ensuring that the request carries the necessary credentials for authentication by </span><span><span class="kobospan" id="kobo.703.1">the server.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.704.1">Using </span><strong class="source-inline"><span class="kobospan" id="kobo.705.1">runBlocking</span></strong><span class="kobospan" id="kobo.706.1"> within the interceptor is a pragmatic approach to accommodate the synchronous nature of the </span><strong class="source-inline"><span class="kobospan" id="kobo.707.1">intercept()</span></strong><span class="kobospan" id="kobo.708.1"> method, allowing for the immediate availability of the token. </span><span class="kobospan" id="kobo.708.2">However, it’s crucial to ensure that the token retrieval operation is efficient and non-blocking to avoid performance bottlenecks – ideally, by fetching the token from a local cache </span><span><span class="kobospan" id="kobo.709.1">or storage.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.710.1">Finally, at the end of the function, we return </span><strong class="source-inline"><span class="kobospan" id="kobo.711.1">chain.proceed(requestwithToken)</span></strong><span class="kobospan" id="kobo.712.1">, which will allow Retrofit to continue processing the request, including the interceptor changes (in this case, adding the </span><span><span class="kobospan" id="kobo.713.1">authentication header).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.714.1">Now, we should include </span><strong class="source-inline"><span class="kobospan" id="kobo.715.1">AuthInterceptor</span></strong><span class="kobospan" id="kobo.716.1"> as an </span><a id="_idIndexMarker838" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.717.1">interceptor when we are building the </span><span><span class="kobospan" id="kobo.718.1">Retrofit</span></span><span><span class="kobospan" id="kobo.719.1"> client:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.720.1">
    @Provides
    @Singleton
    fun provideRetrofit(
        moshi: Moshi,
        authInterceptor: AuthInterceptor
    ): Retrofit {
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .build()
        return Retrofit.Builder()
            .baseUrl("https://your.api.url/") // Replace
                                                 with your
                                                 actual
                                                 base URL
            .addConverterFactory(
                MoshiConverterFactory.create(moshi))
            .client(okHttpClient)
            .build()
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.721.1">Here, we can see how we can integrate the interceptor we’ve created into our network layer setup, specifically within a </span><span><span class="kobospan" id="kobo.722.1">Retrofit configuration.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.723.1">Within the function, an </span><strong class="source-inline"><span class="kobospan" id="kobo.724.1">OkHttpClient</span></strong><span class="kobospan" id="kobo.725.1"> instance is created and configured to include the </span><strong class="source-inline"><span class="kobospan" id="kobo.726.1">authInterceptor</span></strong><span class="kobospan" id="kobo.727.1"> instance via the </span><strong class="source-inline"><span class="kobospan" id="kobo.728.1">addInterceptor</span></strong><span class="kobospan" id="kobo.729.1"> method. </span><span class="kobospan" id="kobo.729.2">This setup ensures that every HTTP request made by this client will first pass through the </span><strong class="source-inline"><span class="kobospan" id="kobo.730.1">authInterceptor</span></strong><span class="kobospan" id="kobo.731.1">, allowing it to modify the request as needed before it is </span><span><span class="kobospan" id="kobo.732.1">sent out.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.733.1">Following the configuration of the </span><strong class="source-inline"><span class="kobospan" id="kobo.734.1">OkHttpClient</span></strong><span class="kobospan" id="kobo.735.1"> instance, the Retrofit instance is built. </span><span class="kobospan" id="kobo.735.2">The configured </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">OkHttpClient</span></strong><span class="kobospan" id="kobo.737.1"> instance is set as the client for Retrofit, linking the HTTP client, with its interceptor, to the Retrofit instance. </span><span class="kobospan" id="kobo.737.2">Now, all the requests using this Retrofit instance will include the authentication token in the header, if </span><span><span class="kobospan" id="kobo.738.1">it exists.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.739.1">After that, we</span><a id="_idIndexMarker839" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.740.1">users authentication:authorization token, sending in requests”  handled</span><a id="_idIndexMarker840" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.741.1"> the app authentication, from obtaining the token and storing it to providing this token in every request. </span><span class="kobospan" id="kobo.741.2">Now, it’s time to build the main screen: the list of movies </span><span><span class="kobospan" id="kobo.742.1">and series.</span></span></p>
<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.743.1">Creating your movie list</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.744.1">One of the goals of </span><a id="_idIndexMarker841" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.745.1">our Packtflix app is for users to have the freedom to</span><a id="_idIndexMarker842" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.746.1"> explore and enjoy an extensive range of movies (or TV series), ensuring they stay engaged with our app. </span><span class="kobospan" id="kobo.746.2">To achieve this, we must present our movie catalog in the most appealing manner possible. </span><span class="kobospan" id="kobo.746.3">For that reason, in this section, we will focus on building a movie (or series!) </span><span><span class="kobospan" id="kobo.747.1">catalog screen.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.748.1">To start building the classical main screen of our streaming app, we first need to create the models we will use to represent </span><span><span class="kobospan" id="kobo.749.1">the information.</span></span></p>
<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.750.1">Building the models</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.751.1">Start by</span><a id="_idIndexMarker843" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.752.1"> building</span><a id="_idIndexMarker844" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.753.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.754.1">Movie</span></strong></span><span><span class="kobospan" id="kobo.755.1"> model:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.756.1">
data class Movie(
    val id: Int,
    val title: String,
    val imageUrl: String,
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.757.1">This is the model that will represent a movie – it includes the movie identification (</span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">id</span></strong><span class="kobospan" id="kobo.759.1">), its title, and a URL to an image of </span><span><span class="kobospan" id="kobo.760.1">the movie.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.761.1">Generally, movies in a streaming app are arranged by genres, so let’s create a </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">Genre</span></strong> <span><span class="kobospan" id="kobo.763.1">model too:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.764.1">
data class Genre(
    val name: String,
    val movies: List&lt;Movie&gt;
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.765.1">Here we defined the name of the genre (needed to render it on the screen) and a list of the movies included in </span><span><span class="kobospan" id="kobo.766.1">that genre.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.767.1">Finally, we need a </span><strong class="source-inline"><span class="kobospan" id="kobo.768.1">MoviesViewState</span></strong><span class="kobospan" id="kobo.769.1"> class to represent the movie list </span><span><span class="kobospan" id="kobo.770.1">screen state:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.771.1">
data class MoviesViewState(
    val genres: List&lt;Genre&gt;
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.772.1">In this </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">MoviesViewState</span></strong><span class="kobospan" id="kobo.774.1"> class,  we are including just one property, </span><strong class="source-inline"><span class="kobospan" id="kobo.775.1">genres</span></strong><span class="kobospan" id="kobo.776.1">, which will store the list of genres we want to show in the list of our </span><span><span class="kobospan" id="kobo.777.1">streaming app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.778.1">Now, we are </span><a id="_idIndexMarker845" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.779.1">ready to start creating</span><a id="_idIndexMarker846" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.780.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">MoviesScreen</span></strong></span><span><span class="kobospan" id="kobo.782.1"> composable.</span></span></p>
<h2 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.783.1">Building the MoviesScreen composable</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.784.1">To build </span><a id="_idIndexMarker847" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.785.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.786.1">MoviesScreen</span></strong><span class="kobospan" id="kobo.787.1"> composable, enter</span><a id="_idIndexMarker848" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.788.1"> the </span><span><span class="kobospan" id="kobo.789.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.790.1">
@Composable
fun MoviesScreen(moviesViewState: MoviesViewState =
sampleMoviesScreen()) {
    Scaffold(
        containerColor = Color.Black,
        topBar = { PacktflixTopBar() },
        bottomBar = { PacktflixBottomBar() }
    ) { innerPadding -&gt;
        GenreList(
            genres = moviesViewState.genres,
            modifier = Modifier.padding(innerPadding)
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.791.1">As we can see, we have created our </span><strong class="source-inline"><span class="kobospan" id="kobo.792.1">MoviesScreen</span></strong><span class="kobospan" id="kobo.793.1"> composable and a </span><strong class="source-inline"><span class="kobospan" id="kobo.794.1">Scaffold</span></strong><span class="kobospan" id="kobo.795.1"> inside of it. </span><span class="kobospan" id="kobo.795.2">As a </span><strong class="source-inline"><span class="kobospan" id="kobo.796.1">topBar</span></strong><span class="kobospan" id="kobo.797.1"> component of the </span><strong class="source-inline"><span class="kobospan" id="kobo.798.1">Scaffold</span></strong><span class="kobospan" id="kobo.799.1">, we are including a new composable called </span><strong class="source-inline"><span class="kobospan" id="kobo.800.1">PackflixTopBar</span></strong><span class="kobospan" id="kobo.801.1">, then as a </span><strong class="source-inline"><span class="kobospan" id="kobo.802.1">bottomBar</span></strong><span class="kobospan" id="kobo.803.1"> component, we are including another new composable called </span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">PacktflixBottomBar</span></strong><span class="kobospan" id="kobo.805.1">. </span><span class="kobospan" id="kobo.805.2">Finally, in the content of the Scaffold, we are showing a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.806.1">GenreList</span></strong></span><span><span class="kobospan" id="kobo.807.1"> composable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">Now, let’s build these </span><a id="_idIndexMarker849" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.809.1">three </span><a id="_idIndexMarker850" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.810.1">composables: </span><strong class="source-inline"><span class="kobospan" id="kobo.811.1">PacktflixTopBar</span></strong><span class="kobospan" id="kobo.812.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.813.1">PacktflixBottomBar</span></strong><span class="kobospan" id="kobo.814.1">, </span><span><span class="kobospan" id="kobo.815.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.816.1">GenreList</span></strong></span><span><span class="kobospan" id="kobo.817.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.818.1">PacktflixTopBar</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.819.1">Here is </span><a id="_idIndexMarker851" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.820.1">how</span><a id="_idIndexMarker852" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.821.1"> we create the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.822.1">PacktflixTopBar</span></strong></span><span><span class="kobospan" id="kobo.823.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.824.1">
@Composable
fun PacktflixTopBar() {
    TopAppBar(
        title = {
            Text(
                text = "PACKTFLIX",
                color = Color.Red,
                fontSize = 48.sp,
                modifier = Modifier.padding(bottom = 32.dp)
            )
        },
        actions = {
            IconButton(onClick =
            { /* Handle profile action */ }) {
                Icon(
                    painter = painterResource(id =
                        R.drawable.ic_profile),
                    contentDescription = "Profile"
                )
            }
            IconButton(onClick = { /* Handle more action */ }) {
                Icon(
                    painter = painterResource(id =
                        R.drawable.ic_more),
                    contentDescription = "More"
                )
            }
        },
    )
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.825.1">Inside </span><strong class="source-inline"><span class="kobospan" id="kobo.826.1">TopAppBar</span></strong><span class="kobospan" id="kobo.827.1">, there’s a title that displays the text </span><strong class="bold"><span class="kobospan" id="kobo.828.1">PACKTFLIX</span></strong><span class="kobospan" id="kobo.829.1"> on the screen – the text will be colored in red, with a large font size and some padding to create </span><span><span class="kobospan" id="kobo.830.1">some space.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.831.1">Additionally, </span><strong class="source-inline"><span class="kobospan" id="kobo.832.1">TopAppBar</span></strong><span class="kobospan" id="kobo.833.1"> includes two icons on the right side: the first icon is for a </span><strong class="bold"><span class="kobospan" id="kobo.834.1">Profile</span></strong><span class="kobospan" id="kobo.835.1"> button – when you tap on it, it’s meant to handle a user profile-related task, although the actual</span><a id="_idIndexMarker853" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.836.1"> function to do this </span><a id="_idIndexMarker854" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.837.1">hasn’t been implemented yet. </span><span class="kobospan" id="kobo.837.2">The second icon is for a </span><strong class="bold"><span class="kobospan" id="kobo.838.1">More</span></strong><span class="kobospan" id="kobo.839.1"> button – this is also set up to handle additional actions when clicked, but the specifics of these actions are not defined in this snippet. </span><span class="kobospan" id="kobo.839.2">Each icon button has been created with an </span><strong class="source-inline"><span class="kobospan" id="kobo.840.1">IconButton</span></strong><span class="kobospan" id="kobo.841.1"> composable that contains an icon, and each icon gets its image from a </span><span><span class="kobospan" id="kobo.842.1">resource file.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.843.1">This is how </span><strong class="source-inline"><span class="kobospan" id="kobo.844.1">TopAppBar</span></strong> <span><span class="kobospan" id="kobo.845.1">will look:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer059">
<span class="kobospan" id="kobo.846.1"><img alt="Figure 7.4: Top bar in MoviesScreen" src="image/B19443_07_004.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.847.1">Figure 7.4: Top bar in MoviesScreen</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.848.1">Let’s continue with the </span><span><span class="kobospan" id="kobo.849.1">bottom bar.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.850.1">PacktflixBottomBar</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.851.1">Now, let’s </span><a id="_idIndexMarker855" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.852.1">build</span><a id="_idIndexMarker856" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.853.1"> the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.854.1">PacktflixBottomBar</span></strong></span><span><span class="kobospan" id="kobo.855.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.856.1">
@Composable
fun PacktflixBottomBar() {
    NavigationBar (
        containerColor = Color.Black,
        contentColor = Color.White,
    ) {
        NavigationBarItem(
            icon = { Icon(Icons.Filled.Home,
                contentDescription = "Home") },
            selected = false,
            onClick = { /* Handle Home navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.Search,
                contentDescription = "Search") },
            selected = false,
            onClick = { /* Handle Search navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.ArrowDropDown,
                contentDescription = "Downloads") },
            selected = false,
            onClick = { /* Handle Downloads navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.MoreVert,
                contentDescription = "More") },
            selected = false,
            onClick = { /* Handle More navigation */ }
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.857.1">This navigation bar sports a sleek black background with icons illuminated in white, offering a stark and stylish contrast. </span><span class="kobospan" id="kobo.857.2">We’re also introducing four navigation items, each symbolized by a distinct icon. </span><span class="kobospan" id="kobo.857.3">We’ve opted for icons from the Material Icons collection, assigning specific and intuitive symbols to signify </span><strong class="bold"><span class="kobospan" id="kobo.858.1">Home</span></strong><span class="kobospan" id="kobo.859.1">, </span><strong class="bold"><span class="kobospan" id="kobo.860.1">Search</span></strong><span class="kobospan" id="kobo.861.1">, </span><strong class="bold"><span class="kobospan" id="kobo.862.1">Downloads</span></strong><span class="kobospan" id="kobo.863.1">, and </span><span><strong class="bold"><span class="kobospan" id="kobo.864.1">More</span></strong></span><span><span class="kobospan" id="kobo.865.1"> functionalities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.866.1">For each navigation item within </span><strong class="source-inline"><span class="kobospan" id="kobo.867.1">NavigationBarItem</span></strong><span class="kobospan" id="kobo.868.1">, we have set up an icon along with an </span><strong class="source-inline"><span class="kobospan" id="kobo.869.1">onClick</span></strong><span class="kobospan" id="kobo.870.1"> listener. </span><span class="kobospan" id="kobo.870.2">Initially, all these items are not selected (</span><strong class="source-inline"><span class="kobospan" id="kobo.871.1">selected = false</span></strong><span class="kobospan" id="kobo.872.1">) to indicate that their selection state will be managed dynamically through user interactions </span><a id="_idIndexMarker857" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.873.1">or</span><a id="_idIndexMarker858" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.874.1"> specific logic to be implemented in the future. </span><span class="kobospan" id="kobo.874.2">The implementation of these sections is beyond the scope of </span><span><span class="kobospan" id="kobo.875.1">this book.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.876.1">We are also pairing each icon with </span><strong class="source-inline"><span class="kobospan" id="kobo.877.1">contentDescription</span></strong><span class="kobospan" id="kobo.878.1">. </span><span class="kobospan" id="kobo.878.2">This approach enhances app accessibility by offering screen readers a concise explanation of each </span><span><span class="kobospan" id="kobo.879.1">button’s function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.880.1">Once it is finished, this is how </span><strong class="source-inline"><span class="kobospan" id="kobo.881.1">PacktflixBottomBar</span></strong> <span><span class="kobospan" id="kobo.882.1">will look:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer060">
<span class="kobospan" id="kobo.883.1"><img alt="Figure 7.5: Bottom bar in MoviesScreen" src="image/B19443_07_005.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.884.1">Figure 7.5: Bottom bar in MoviesScreen</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.885.1">Now, let’s continue with the next step and complete this screen by implementing the list </span><span><span class="kobospan" id="kobo.886.1">of movies.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.887.1">GenreList</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.888.1">Now, let’s start </span><a id="_idIndexMarker859" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.889.1">building the </span><strong class="source-inline"><span class="kobospan" id="kobo.890.1">GenreList</span></strong><span class="kobospan" id="kobo.891.1"> composable. </span><span class="kobospan" id="kobo.891.2">Generally, the</span><a id="_idIndexMarker860" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.892.1"> content of a movie screen in a streaming app is composed of a list of genres, where each one contains a list of movies. </span><span class="kobospan" id="kobo.892.2">Let’s use the </span><strong class="source-inline"><span class="kobospan" id="kobo.893.1">Genre</span></strong><span class="kobospan" id="kobo.894.1"> model we defined previously and create this list of lists. </span><span class="kobospan" id="kobo.894.2">We will start creating a vertical list composed of rows where every row will show the content of every </span><span><strong class="source-inline"><span class="kobospan" id="kobo.895.1">Genre</span></strong></span><span><span class="kobospan" id="kobo.896.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.897.1">
@Composable
fun GenreList(genres: List&lt;Genre&gt;, modifier: Modifier =
Modifier) {
    LazyColumn(modifier = modifier) {
        items(genres.size) { index -&gt;
            GenreRow(genre = genres[index])
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.898.1">To efficiently display the </span><strong class="source-inline"><span class="kobospan" id="kobo.899.1">GenreList</span></strong><span class="kobospan" id="kobo.900.1"> composable, we employed </span><strong class="source-inline"><span class="kobospan" id="kobo.901.1">LazyColumn</span></strong><span class="kobospan" id="kobo.902.1">, chosen for its ability to render items lazily – this means it only draws the items visible on the screen, enhancing performance, especially for </span><span><span class="kobospan" id="kobo.903.1">long lists.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.904.1">Inside </span><strong class="source-inline"><span class="kobospan" id="kobo.905.1">LazyColumn</span></strong><span class="kobospan" id="kobo.906.1">, we iterate over the genre list. </span><span class="kobospan" id="kobo.906.2">For each genre, we call items, specifying the size of our genre list to determine the number of items it should prepare </span><span><span class="kobospan" id="kobo.907.1">to display.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.908.1">Then, for every item (or genre, in our context), we invoke </span><strong class="source-inline"><span class="kobospan" id="kobo.909.1">GenreRow</span></strong><span class="kobospan" id="kobo.910.1">, a custom composable function that we will define in a moment. </span><span class="kobospan" id="kobo.910.2">This function is responsible for rendering a single row in our list, which represents a genre. </span><span class="kobospan" id="kobo.910.3">We pass each genre to </span><strong class="source-inline"><span class="kobospan" id="kobo.911.1">GenreRow</span></strong><span class="kobospan" id="kobo.912.1"> by indexing it into our genres list </span><span><span class="kobospan" id="kobo.913.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.914.1">genres[index]</span></strong></span><span><span class="kobospan" id="kobo.915.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.916.1">Now, let’s build the </span><strong class="source-inline"><span class="kobospan" id="kobo.917.1">GenreRow</span></strong><span class="kobospan" id="kobo.918.1"> composable that we </span><span><span class="kobospan" id="kobo.919.1">just mentioned:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.920.1">
@Composable
fun GenreRow(genre: Genre) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(text = genre.name, style =
            MaterialTheme.typography.headlineSmall)
        LazyRow {
            items(genre.movies.size) { index -&gt;
                MovieCard(movie = genre.movies[index])
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.921.1">We start with a vertical container, </span><strong class="source-inline"><span class="kobospan" id="kobo.922.1">Column</span></strong><span class="kobospan" id="kobo.923.1">, that stretches across the full width of the screen. </span><span class="kobospan" id="kobo.923.2">At the top of this container, we place the genre’s name in large, readable text. </span><span class="kobospan" id="kobo.923.3">This makes it clear to the user which genre they’re </span><span><span class="kobospan" id="kobo.924.1">looking at.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.925.1">Right below the genre’s name, we set up a horizontal scroll area, </span><strong class="source-inline"><span class="kobospan" id="kobo.926.1">LazyRow</span></strong><span class="kobospan" id="kobo.927.1">, filled with movie cards. </span><span class="kobospan" id="kobo.927.2">Each card represents a movie in the genre, and users can scroll through </span><span><span class="kobospan" id="kobo.928.1">them horizontally.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.929.1">For each movie in</span><a id="_idIndexMarker861" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.930.1"> the genre, we will </span><a id="_idIndexMarker862" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.931.1">create a </span><strong class="source-inline"><span class="kobospan" id="kobo.932.1">MovieCard</span></strong><span class="kobospan" id="kobo.933.1"> composable that will show the movie thumbnail image and </span><span><span class="kobospan" id="kobo.934.1">the name:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.935.1">
@Composable
fun MovieCard(movie: Movie) {
    Card(
        modifier = Modifier
            .padding(8.dp)
            .size(120.dp, 180.dp)
    ) {
        Image(
            painter = rememberAsyncImagePainter(model =
                movie.imageUrl),
            contentDescription = movie.title,
            contentScale = ContentScale.Crop
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.936.1">We start by using a </span><strong class="source-inline"><span class="kobospan" id="kobo.937.1">Card</span></strong><span class="kobospan" id="kobo.938.1"> composable that provides a Material Design card layout. </span><span class="kobospan" id="kobo.938.2">This card is given specific dimensions and padding to ensure that it looks neat and uniform across the app. </span><span class="kobospan" id="kobo.938.3">Specifically, we set each card to be </span><strong class="source-inline"><span class="kobospan" id="kobo.939.1">120dp</span></strong><span class="kobospan" id="kobo.940.1"> wide and </span><strong class="source-inline"><span class="kobospan" id="kobo.941.1">180dp</span></strong><span class="kobospan" id="kobo.942.1"> tall, with an </span><strong class="source-inline"><span class="kobospan" id="kobo.943.1">8dp</span></strong><span class="kobospan" id="kobo.944.1"> padding around it. </span><span class="kobospan" id="kobo.944.2">This size is ideal for displaying movie posters without taking up too much screen space or looking </span><span><span class="kobospan" id="kobo.945.1">too cramped.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.946.1">Inside the card, we place an </span><strong class="source-inline"><span class="kobospan" id="kobo.947.1">Image</span></strong><span class="kobospan" id="kobo.948.1"> composable to show the movie’s poster. </span><span class="kobospan" id="kobo.948.2">To load the image (the movie’s poster in this case) from a URL, we use </span><strong class="source-inline"><span class="kobospan" id="kobo.949.1">rememberAsyncImagePainter</span></strong><span class="kobospan" id="kobo.950.1">, a handy function that handles asynchronous image loading and caching. </span><span class="kobospan" id="kobo.950.2">This means our app can fetch movie posters from the internet efficiently and display them as they become available, without blocking the </span><span><span class="kobospan" id="kobo.951.1">UI thread.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.952.1">The image is set to crop to fit the card’s dimensions, ensuring that the most visually important part</span><a id="_idIndexMarker863" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.953.1"> of the poster remains visible, even if </span><a id="_idIndexMarker864" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.954.1">the original image’s aspect ratio doesn’t exactly match the card’s dimensions. </span><span class="kobospan" id="kobo.954.2">This cropping also maintains a consistent appearance across all </span><span><span class="kobospan" id="kobo.955.1">movie cards.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.956.1">Finally, we include </span><strong class="source-inline"><span class="kobospan" id="kobo.957.1">contentDescription</span></strong><span class="kobospan" id="kobo.958.1"> for the image, using the movie’s title, to make our list as accessible </span><span><span class="kobospan" id="kobo.959.1">as possible.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.960.1">With this component, we have finished our movie screen (or series screen – you just have to change the title and the content!). </span><span class="kobospan" id="kobo.960.2">We can now test it using the </span><strong class="source-inline"><span class="kobospan" id="kobo.961.1">@Preview</span></strong><span class="kobospan" id="kobo.962.1"> annotation and providing a list </span><span><span class="kobospan" id="kobo.963.1">of genres:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.964.1">
@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    MoviesScreenUI(moviesViewState = sampleMoviesScreen())
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.965.1">Here, we are using the preview feature of Jetpack Compose to see what our list will look like. </span><span class="kobospan" id="kobo.965.2">We would need to create some sample content, and that’s what the </span><strong class="source-inline"><span class="kobospan" id="kobo.966.1">sampleMoviesScreen()</span></strong><span class="kobospan" id="kobo.967.1"> function </span><a id="_idIndexMarker865" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.968.1">will do for</span><a id="_idIndexMarker866" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.969.1"> us. </span><span class="kobospan" id="kobo.969.2">For example, we could create this fake list </span><span><span class="kobospan" id="kobo.970.1">of movies:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.971.1">
fun sampleMoviesScreen(): MoviesViewState {
    return MoviesViewState(
        genres = listOf(
            Genre(
                name = "Comedy",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "The Hangover",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/b/b9/Hangoverposter09.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Superbad",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/8/8b/Superbad_Poster.png"
                    ),
                    Movie(
                        id = 3,
                        title = "Step Brothers",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/d/d9/StepbrothersMP08.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "Anchorman",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/6/64/Movie_poster_Anchorman_The_Legend_of_Ron_Burgundy.jpg"
                    )
                )
            ),
            Genre(
                name = "Mystery",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "Se7en",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/6/68/Seven_%28movie%29_poster.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Zodiac",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/3/3a/Zodiac2007Poster.jpg"
                    ),
                    Movie(
                        id = 3,
                        title = "Gone Girl",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/0/05/Gone_Girl_Poster.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "Shutter Island",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/7/76/Shutterislandposter.jpg"
                    )
                )
            ),
            Genre(
                name = "Documentary",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "March of the Penguins",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/1/19/March_of_the_penguins_poster.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Bowling for Columbine",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/e/e7/Bowling_for_columbine.jpg"
                    ),
                    Movie(
                        id = 3,
                        title = "Blackfish",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/b/bd/BLACKFISH_Film_Poster.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "An Inconvenient Truth",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/1/19/An_Inconvenient_Truth_Film_Poster.jpg"
                    )
                )
            )
        )</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.972.1">Here, we are</span><a id="_idIndexMarker867" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.973.1"> creating fake data to make the </span><a id="_idIndexMarker868" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.974.1">testing of </span><strong class="source-inline"><span class="kobospan" id="kobo.975.1">MoviesScreen</span></strong><span class="kobospan" id="kobo.976.1"> easier. </span><span class="kobospan" id="kobo.976.2">Note that the URLs provided are not the actual image URLs, so you would have to replace them for actual </span><span><span class="kobospan" id="kobo.977.1">movie posters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.978.1">Once finished, our list screen should look </span><span><span class="kobospan" id="kobo.979.1">like this:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer061">
<span class="kobospan" id="kobo.980.1"><img alt="Figure 7.6: Movies list screen" src="image/B19443_07_006.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.981.1">Figure 7.6: Movies list screen</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.982.1">Now that we have</span><a id="_idIndexMarker869" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.983.1"> our list of genres and </span><a id="_idIndexMarker870" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.984.1">movies, let’s build the movie (or series) </span><span><span class="kobospan" id="kobo.985.1">details page.</span></span></p>
<h1 id="_idParaDest-155" class="calibre5"><a id="_idTextAnchor156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.986.1">Making the movie and series detail screen</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.987.1">In this section, we will create</span><a id="_idIndexMarker871" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.988.1"> the detail screen, which is the screen that will be shown when the user clicks a movie or series from the list. </span><span class="kobospan" id="kobo.988.2">This screen will include information such as the plot summary, cast, year of release, and </span><span><span class="kobospan" id="kobo.989.1">so on.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.990.1">Before building</span><a id="_idIndexMarker872" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.991.1"> the necessary composables, we need to think about the models we need. </span><span class="kobospan" id="kobo.991.2">Let’s start </span><span><span class="kobospan" id="kobo.992.1">creating them.</span></span></p>
<h2 id="_idParaDest-156" class="calibre7"><a id="_idTextAnchor157" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.993.1">Creating the detail models</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.994.1">To define the models, we </span><a id="_idIndexMarker873" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.995.1">need to take into account the data </span><a id="_idIndexMarker874" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.996.1">we want to show in the detail screen. </span><span class="kobospan" id="kobo.996.2">As we would like to create the same model for both movies and series, we will build an </span><strong class="source-inline"><span class="kobospan" id="kobo.997.1">ItemDetail</span></strong><span class="kobospan" id="kobo.998.1"> model </span><span><span class="kobospan" id="kobo.999.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1000.1">
data class ItemDetail(
    val type: Type,
    val title: String,
    val imageUrl: String,
    val rating: String,
    val year: String,
    val cast: List&lt;String&gt;,
    val description: String,
    val creators: List&lt;String&gt;,
    val episodes: List&lt;Episode&gt;,
    val movieUrl: String
) {
    enum class Type {
        MOVIE, SERIES
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1001.1">In the case that </span><strong class="source-inline"><span class="kobospan" id="kobo.1002.1">ItemDetail</span></strong><span class="kobospan" id="kobo.1003.1"> represents a streaming series item, we also should define the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1004.1">Episode</span></strong></span><span><span class="kobospan" id="kobo.1005.1"> model:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1006.1">
data class Episode(
    val title: String,
    val imageUrl: String,
    val duration: String,
    val episodeUrl: String
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1007.1">Now that we </span><a id="_idIndexMarker875" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1008.1">have </span><a id="_idIndexMarker876" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1009.1">our models ready, we can start building the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1010.1">DetailScreen</span></strong></span><span><span class="kobospan" id="kobo.1011.1"> composable.</span></span></p>
<h2 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor158" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1012.1">Building the DetailScreen</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1013.1">As we have done</span><a id="_idIndexMarker877" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1014.1"> on other occasions, we</span><a id="_idIndexMarker878" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1015.1"> will first build the structure we want the screen </span><span><span class="kobospan" id="kobo.1016.1">to have:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1017.1">
@Composable
fun ItemDetailScreen(item: ItemDetail =
createFakeItemDetail()) {
    val scrollState = rememberScrollState()
    Column(
        verticalArrangement = Arrangement.Top,
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
            .padding(all = 8.dp)
            .verticalScroll(scrollState)
    ) {
        ItemBannerImage(item.imageUrl)
        ItemTitleAndMetadata(item.title, item.isHD,
            item.year, item.duration)
        ItemActions(item.movieUrl)
        Text(text = item.description, color = Color.Gray)
        CastAndCreatorsList(item.cast, item.creators)
        AdditionalMovieDetails(item)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1018.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.1019.1">ItemDetailScreen</span></strong><span class="kobospan" id="kobo.1020.1">, all the composables included are shown in a vertical </span><strong class="source-inline"><span class="kobospan" id="kobo.1021.1">Column</span></strong><span class="kobospan" id="kobo.1022.1">, which allows us to build the UI progressively as we add </span><span><span class="kobospan" id="kobo.1023.1">new composables.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1024.1">Now, let’s start building</span><a id="_idIndexMarker879" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1025.1"> all those composables, starting</span><a id="_idIndexMarker880" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.1026.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1027.1">ItemBannerImage</span></strong></span><span><span class="kobospan" id="kobo.1028.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1029.1">
@Composable
fun ItemBannerImage(imageUrl: String) {
    Box(modifier = Modifier.fillMaxWidth()) {
        Image(
            painter = rememberAsyncImagePainter(model =
                imageUrl),
            contentDescription = "Movie Banner",
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .height(200.dp)
                .fillMaxWidth()
        )
        IconButton(
            onClick = {
                /* TODO: Handle back action */
            },
            modifier = Modifier
                .align(Alignment.TopStart)
                .padding(top = 32.dp, start = 16.dp)
        ) {
            Icon(
                imageVector = Icons.Default.ArrowBack,
                contentDescription = "Back",
                tint = Color.White
            )
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1030.1">This composable displays a banner image at the top of the screen, stretching it to fill the screen’s width. </span><span class="kobospan" id="kobo.1030.2">It uses a </span><strong class="source-inline"><span class="kobospan" id="kobo.1031.1">Box</span></strong><span class="kobospan" id="kobo.1032.1"> composable with a </span><strong class="source-inline"><span class="kobospan" id="kobo.1033.1">Modifier</span></strong><span class="kobospan" id="kobo.1034.1"> parameter that will make sure it takes up the full width of the screen, and an </span><strong class="source-inline"><span class="kobospan" id="kobo.1035.1">Image</span></strong><span class="kobospan" id="kobo.1036.1"> composable that loads an image from a given URL with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1037.1">rememberAsyncImagePainter</span></strong><span class="kobospan" id="kobo.1038.1"> function. </span><span class="kobospan" id="kobo.1038.2">The image is set to be 200 dp tall and automatically adjusts its width to fit the screen, ensuring that it’s properly cropped to the </span><span><span class="kobospan" id="kobo.1039.1">allocated space.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1040.1">On top of the </span><a id="_idIndexMarker881" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1041.1">image, there’s an </span><strong class="source-inline"><span class="kobospan" id="kobo.1042.1">IconButton</span></strong><span class="kobospan" id="kobo.1043.1"> composable </span><a id="_idIndexMarker882" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1044.1">that’s meant to act as a </span><strong class="bold"><span class="kobospan" id="kobo.1045.1">Back</span></strong><span class="kobospan" id="kobo.1046.1"> button. </span><span class="kobospan" id="kobo.1046.2">We place this button in the top-left corner with some padding. </span><span class="kobospan" id="kobo.1046.3">Inside this button, there’s an icon shaped like an arrow pointing back, suggesting that pressing it should take you back to the previous screen. </span><span class="kobospan" id="kobo.1046.4">The icon is white to make sure it’s visible on top of the </span><span><span class="kobospan" id="kobo.1047.1">banner image.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1048.1">Now, let’s build the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1049.1">ItemTitleAndMetadata</span></strong></span><span><span class="kobospan" id="kobo.1050.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1051.1">
@Composable
fun ItemTitleAndMetadata(
    title: String,
    isHD: Boolean,
    year: String,
    duration: String
) {
    Column {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold,
            color = Color.White
        )
        Row(verticalAlignment = Alignment.CenterVertically)
        {
            if (isHD) {
                Box(
                    modifier = Modifier
                        .border(BorderStroke(1.dp,
                            Color.White), shape =
                                RoundedCornerShape(4.dp))
                        .padding(horizontal = 6.dp,
                            vertical = 2.dp)
                ) {
                    Text(
                        text = "HD",
                        style =
                        MaterialTheme.typography.bodySmall,
                        color = Color.White
                    )
                }
                Spacer(modifier = Modifier.width(8.dp))
            }
            Text(
                text = year,
                style =
                    MaterialTheme.typography.bodyMedium,
                color = Color.Gray
            )
        }
        Text(
            text = duration,
            style = MaterialTheme.typography.bodyMedium,
            color = Color.Gray
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1052.1">We start by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.1053.1">Column</span></strong><span class="kobospan" id="kobo.1054.1"> layout because we want the details to </span><span><span class="kobospan" id="kobo.1055.1">stack vertically.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1056.1">In this column, we will display the title of the item. </span><span class="kobospan" id="kobo.1056.2">The style we choose here is </span><strong class="source-inline"><span class="kobospan" id="kobo.1057.1">bodyMedium</span></strong><span class="kobospan" id="kobo.1058.1"> from the Material Theme, ensuring it fits nicely with the overall design of </span><span><span class="kobospan" id="kobo.1059.1">the app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1060.1">Next, we align </span><a id="_idIndexMarker883" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1061.1">our HD</span><a id="_idIndexMarker884" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1062.1"> indicator and the year of release in a row, centering them vertically to ensure that they line up perfectly. </span><span class="kobospan" id="kobo.1062.2">We include a conditional check – only if </span><strong class="source-inline"><span class="kobospan" id="kobo.1063.1">isHD</span></strong><span class="kobospan" id="kobo.1064.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.1065.1">true</span></strong><span class="kobospan" id="kobo.1066.1"> do we display an </span><strong class="bold"><span class="kobospan" id="kobo.1067.1">HD</span></strong><span class="kobospan" id="kobo.1068.1"> badge. </span><span class="kobospan" id="kobo.1068.2">We give this badge a white border and a bit of padding to make it pop against </span><span><span class="kobospan" id="kobo.1069.1">any background.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1070.1">Following a small spacer, which adds some breathing room between our </span><strong class="bold"><span class="kobospan" id="kobo.1071.1">HD</span></strong><span class="kobospan" id="kobo.1072.1"> badge and the year, we place the text for the year. </span><span class="kobospan" id="kobo.1072.2">It’s styled to be less prominent than the title, using a medium </span><span><span class="kobospan" id="kobo.1073.1">gray color.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1074.1">Finally, below the row, we will show the duration of the item. </span><span class="kobospan" id="kobo.1074.2">It’s also in medium gray, matching the year, and using the same </span><strong class="source-inline"><span class="kobospan" id="kobo.1075.1">bodyMedium</span></strong><span class="kobospan" id="kobo.1076.1"> style </span><span><span class="kobospan" id="kobo.1077.1">for consistency.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1078.1">The next step is</span><a id="_idIndexMarker885" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1079.1"> to</span><a id="_idIndexMarker886" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1080.1"> create the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1081.1">ItemActions</span></strong></span><span><span class="kobospan" id="kobo.1082.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1083.1">
@Composable
fun ItemActions(
    itemUrl: String
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
    ) {
        ActionButton(
            icon = Icons.Filled.PlayArrow,
            label = "Play",
            onClick = { /* TODO: Handle play action */ }
        )
        ActionButton(
            icon = Icons.Default.Add,
            label = "My List",
            onClick = {
                /* TODO: Handle add to list action */ }
        )
    }
}
@Composable
fun ActionButton(icon: ImageVector, label: String, onClick:
() -&gt; Unit) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.clickable(onClick = onClick)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = label
        )
        Text(text = label)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1084.1">We start by laying this function in a column format so that our action buttons stack vertically – this column will take up the full width available and will have padding all around for some space from the </span><span><span class="kobospan" id="kobo.1085.1">screen edges.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1086.1">Inside this column, we’re placing two action buttons: one for playing the item and another for adding the item to a user’s personal list. </span><span class="kobospan" id="kobo.1086.2">To create these buttons, we are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1087.1">ActionButton</span></strong><span class="kobospan" id="kobo.1088.1"> composable function, which neatly bundles an icon and a label together</span><a id="_idIndexMarker887" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1089.1"> into</span><a id="_idIndexMarker888" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1090.1"> a clickable area. </span><span class="kobospan" id="kobo.1090.2">For the </span><strong class="bold"><span class="kobospan" id="kobo.1091.1">Play</span></strong><span class="kobospan" id="kobo.1092.1"> action, we are using a play arrow icon, and for adding to the list, we are using an </span><span><strong class="bold"><span class="kobospan" id="kobo.1093.1">Add</span></strong></span><span><span class="kobospan" id="kobo.1094.1"> icon.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1095.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1096.1">We have left placeholders in the code where the play and add-to-list actions can be written. </span><span class="kobospan" id="kobo.1096.2">In the next chapter, we will implement the </span><strong class="bold"><span class="kobospan" id="kobo.1097.1">Play</span></strong><span class="kobospan" id="kobo.1098.1"> button; however, I will leave you to add the add-to-list feature yourself. </span><span class="kobospan" id="kobo.1098.2">To do this, one solution could be to call an endpoint when the </span><strong class="bold"><span class="kobospan" id="kobo.1099.1">Add To List</span></strong><span class="kobospan" id="kobo.1100.1"> button is pressed, so the backend can store it in the user list (of course, imagining that we have a backend that handles this feature). </span><span class="kobospan" id="kobo.1100.2">You can refer to </span><a href="B19443_04_split_000.xhtml#_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1101.1">Chapter 4</span></em></span></a><span class="kobospan" id="kobo.1102.1"> where we connected Packtagram with </span><strong class="source-inline1"><span class="kobospan" id="kobo.1103.1">NewsFeed</span></strong><span class="kobospan" id="kobo.1104.1"> to understand how this can </span><span><span class="kobospan" id="kobo.1105.1">be done.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1106.1">Now, let’s continue</span><a id="_idIndexMarker889" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1107.1"> with the next</span><a id="_idIndexMarker890" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.1108.1">composable, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1109.1">CastAndCreatorsList</span></strong></span><span><span class="kobospan" id="kobo.1110.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1111.1">
@Composable
fun CastAndCreatorsList(cast: List&lt;String&gt;, creators:
List&lt;String&gt;) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            text = "Cast",
            style = MaterialTheme.typography.titleSmall,
            color = Color.White,
            modifier = Modifier.padding(horizontal = 16.dp,
                vertical = 8.dp)
        )
        LazyRow(
            contentPadding = PaddingValues(horizontal =
                16.dp),
            horizontalArrangement =
                Arrangement.spacedBy(8.dp)
        ) {
            items(cast) { actorName -&gt;
                Text(
                    text = actorName,
                    style =
                       MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    modifier = Modifier.background(
                        color = Color.DarkGray,
                        shape = RoundedCornerShape(4.dp)
                    ).padding(horizontal = 8.dp,
                        vertical = 4.dp)
                )
            }
        }
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Created by",
            style = MaterialTheme.typography.titleMedium,
            color = Color.White,
            modifier = Modifier.padding(horizontal = 16.dp,
                vertical = 8.dp)
        )
        LazyRow(
            contentPadding = PaddingValues(horizontal =
                16.dp),
            horizontalArrangement =
                Arrangement.spacedBy(8.dp)
        ) {
            items(creators) { creatorName -&gt;
                Text(
                    text = creatorName,
                    style =
                       MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    modifier = Modifier.background(
                        color = Color.DarkGray,
                        shape = RoundedCornerShape(4.dp)
                    ).padding(horizontal = 8.dp,
                        vertical = 4.dp)
                )
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1112.1">We start with </span><strong class="source-inline"><span class="kobospan" id="kobo.1113.1">Column</span></strong><span class="kobospan" id="kobo.1114.1">, which is going to stack our elements vertically. </span><span class="kobospan" id="kobo.1114.2">We want this to take up the full width available, so we </span><span><span class="kobospan" id="kobo.1115.1">use </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1116.1">Modifier.fillMaxWidth()</span></strong></span><span><span class="kobospan" id="kobo.1117.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1118.1">Then, we put a header labeled </span><strong class="source-inline"><span class="kobospan" id="kobo.1119.1">Cast</span></strong><span class="kobospan" id="kobo.1120.1"> at the top. </span><span class="kobospan" id="kobo.1120.2">We style this text to make it stand out using </span><strong class="source-inline"><span class="kobospan" id="kobo.1121.1">MaterialTheme.typography.titleSmall</span></strong><span class="kobospan" id="kobo.1122.1"> and set the color to white. </span><span class="kobospan" id="kobo.1122.2">To give it some breathing room, we add padding </span><span><span class="kobospan" id="kobo.1123.1">around it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1124.1">Next, we</span><a id="_idIndexMarker891" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1125.1"> introduce </span><a id="_idIndexMarker892" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1126.1">a </span><strong class="source-inline"><span class="kobospan" id="kobo.1127.1">LazyRow</span></strong><span class="kobospan" id="kobo.1128.1"> composable to display each actor’s name from the cast list using a </span><strong class="source-inline"><span class="kobospan" id="kobo.1129.1">Text</span></strong><span class="kobospan" id="kobo.1130.1"> composable. </span><span class="kobospan" id="kobo.1130.2">We style the names to stand out against the background by applying </span><strong class="source-inline"><span class="kobospan" id="kobo.1131.1">MaterialTheme.typography.bodyMedium</span></strong><span class="kobospan" id="kobo.1132.1"> and setting the text color to white. </span><span class="kobospan" id="kobo.1132.2">To further distinguish each name, we give them a tag-like appearance with a dark gray background and rounded corners using </span><strong class="source-inline"><span class="kobospan" id="kobo.1133.1">RoundedCornerShape(4.dp)</span></strong><span class="kobospan" id="kobo.1134.1">. </span><span class="kobospan" id="kobo.1134.2">Additionally, we add padding around the text to ensure that it doesn’t touch the edges of its gray backdrop, enhancing readability and </span><span><span class="kobospan" id="kobo.1135.1">visual appeal.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1136.1">Then, we separate the cast from the creators with a </span><strong class="source-inline"><span class="kobospan" id="kobo.1137.1">Spacer</span></strong><span class="kobospan" id="kobo.1138.1"> composable. </span><span class="kobospan" id="kobo.1138.2">This just adds a bit of vertical space between the two sections, so they don’t run into </span><span><span class="kobospan" id="kobo.1139.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1140.1">For the creators, the setup is pretty much the same. </span><span class="kobospan" id="kobo.1140.2">We have a header labeled </span><strong class="source-inline"><span class="kobospan" id="kobo.1141.1">"Created by"</span></strong><span class="kobospan" id="kobo.1142.1">, styled similarly to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1143.1">Cast</span></strong><span class="kobospan" id="kobo.1144.1"> header but a bit larger using </span><strong class="source-inline"><span class="kobospan" id="kobo.1145.1">titleMedium</span></strong><span class="kobospan" id="kobo.1146.1">. </span><span class="kobospan" id="kobo.1146.2">Then, we list out the creators in another </span><strong class="source-inline"><span class="kobospan" id="kobo.1147.1">LazyRow</span></strong><span class="kobospan" id="kobo.1148.1">, giving them the same styled text tags as </span><span><span class="kobospan" id="kobo.1149.1">the cast.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1150.1">Now, it’s time to </span><a id="_idIndexMarker893" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1151.1">work on the last composable of the </span><a id="_idIndexMarker894" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.1152.1">screen, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1153.1">AdditionalMovieDetails</span></strong></span><span><span class="kobospan" id="kobo.1154.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1155.1">
@Composable
fun AdditionalMovieDetails(item: ItemDetail) {
    Column(modifier = Modifier.fillMaxWidth()) {
        // Assuming item.episodes is a list of episodes
           with their details
        item.episodes.forEach { episode -&gt;
            EpisodeItem(episode = episode)
        }
    }
}
@Composable
fun EpisodeItem(episode: Episode) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable {
                /* TODO: Handle episode playback */ }
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Episode image
        Image(
            painter = rememberAsyncImagePainter(model =
                episode.imageUrl),
            contentDescription = "Episode Thumbnail",
            modifier = Modifier
                .size(width = 120.dp, height = 68.dp)
                .clip(RoundedCornerShape(4.dp)),
            contentScale = ContentScale.Crop
        )
        // Space between image and text details
        Spacer(modifier = Modifier.width(16.dp))
        // Episode title and duration
        Column {
            Text(
                text = episode.title,
                style =
                    MaterialTheme.typography.bodyMedium,
                color = Color.White
            )
            Text(
                text = "Duration: ${episode.duration}",
                style = MaterialTheme.typography.bodySmall,
                color = Color.Gray
            )
        }
    }
    Divider(color = Color.Gray, thickness = 0.5.dp)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1156.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.1157.1">AdditionalMovieDetails</span></strong><span class="kobospan" id="kobo.1158.1">, we’re setting up a column that expands to the maximum width of its parent container. </span><span class="kobospan" id="kobo.1158.2">Inside this column, we’re going through each episode in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1159.1">item.episodes</span></strong><span class="kobospan" id="kobo.1160.1"> list and, for each one, we’re calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.1161.1">EpisodeItem</span></strong><span class="kobospan" id="kobo.1162.1"> composable to render the details of </span><span><span class="kobospan" id="kobo.1163.1">that episode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1164.1">Now, moving on to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1165.1">EpisodeItem</span></strong><span class="kobospan" id="kobo.1166.1"> composable function, this is where we lay out each episode’s information. </span><span class="kobospan" id="kobo.1166.2">We create a row that stretches across the full width, which can be tapped – this is where we will want to add the code for what happens when someone clicks to play the episode. </span><span class="kobospan" id="kobo.1166.3">We are also adding some padding </span><span><span class="kobospan" id="kobo.1167.1">for spacing.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1168.1">Within this row, the first thing is the episode image. </span><span class="kobospan" id="kobo.1168.2">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.1169.1">rememberAsyncImagePainter</span></strong><span class="kobospan" id="kobo.1170.1"> to load the image from the episode URL, and we make sure it’s </span><a id="_idIndexMarker895" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1171.1">nicely</span><a id="_idIndexMarker896" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1172.1"> rounded and cropped to fit a specific size. </span><span class="kobospan" id="kobo.1172.2">This image will act as a thumbnail for </span><span><span class="kobospan" id="kobo.1173.1">the episode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1174.1">Next to the image, we add a spacer to give some breathing room before the text details of the episode. </span><span class="kobospan" id="kobo.1174.2">This is followed by a column that holds two pieces of text: the episode’s title, which stands out more, and below it, the duration of the episode in a smaller and less </span><span><span class="kobospan" id="kobo.1175.1">prominent color.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1176.1">Lastly, after each episode item, we draw a thin gray line, a divider, to visually separate the episodes from one another. </span><span class="kobospan" id="kobo.1176.2">It’s a common design pattern that helps users distinguish between different pieces </span><span><span class="kobospan" id="kobo.1177.1">of content.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1178.1">And with this composable, we have finished the detail screen and this chapter. </span><span class="kobospan" id="kobo.1178.2">Our detail screen should look </span><span><span class="kobospan" id="kobo.1179.1">like this:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer062">
<span class="kobospan" id="kobo.1180.1"><img alt="Figure 7.7: Detail screen" src="image/B19443_07_007.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1181.1">Figure 7.7: Detail screen</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1182.1">In the </span><a id="_idIndexMarker897" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1183.1">next chapter, we</span><a id="_idIndexMarker898" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1184.1"> will bring those movies and series to life by implementing </span><span><span class="kobospan" id="kobo.1185.1">the playback.</span></span></p>
<h1 id="_idParaDest-158" class="calibre5"><a id="_idTextAnchor159" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1186.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1187.1">As we close this chapter, we have laid a solid foundation for Packtflix, our video streaming app. </span><span class="kobospan" id="kobo.1187.2">We began by conceptualizing the project’s structure and modules, setting the stage for an organized and scalable app. </span><span class="kobospan" id="kobo.1187.3">This structure is pivotal for our journey ahead, where complexity will grow as we add </span><span><span class="kobospan" id="kobo.1188.1">more features.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1189.1">We then created the login screen, before venturing into the world of user authentication. </span><span class="kobospan" id="kobo.1189.2">Through the integration of OAuth2, we’ve equipped Packtflix with a secure authentication system that respects user privacy and guards against unauthorized access, ensuring a trustworthy environment for our users to enjoy their </span><span><span class="kobospan" id="kobo.1190.1">favorite content.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1191.1">Our progress continued as we crafted a UI to display a curated list of movies, leveraging the power of Jetpack Compose to create a dynamic and engaging experience. </span><span class="kobospan" id="kobo.1191.2">This attention to detail in presenting content is what will turn first-time users into loyal fans </span><span><span class="kobospan" id="kobo.1192.1">of Packtflix.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1193.1">In the next chapter, we will learn more about how to implement the playback, so our users can not only see the movies and series information but also play </span><span><span class="kobospan" id="kobo.1194.1">their videos.</span></span></p>
</div>
</body></html>