<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/>7</h1>
<h1 id="_idParaDest-142" class="calibre5"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/> Starting a Video Streaming App and Adding Authentication</h1>
<p class="calibre3">Having mastered how to create engaging social apps such as WhatsApp and Instagram, it’s now time to dive into the world of video streaming services. This chapter marks the beginning of our third project: a Netflix-like app. Let’s call it Packtflix. Here, we will explore a different aspect of Android development, focusing on multimedia content delivery and user authentication, while continuing to build captivating user interfaces.</p>
<p class="calibre3">Our journey will begin by laying the groundwork for our streaming app. We’ll start from scratch, setting up a new project and introducing you to the app’s structure and modules.</p>
<p class="calibre3">Following the setup, we’ll dive into one of the most critical aspects of any app: authenticating your users. In today’s digital age, security and privacy are more relevant than ever, so you’ll learn how to implement robust authentication mechanisms using OAuth2. This will ensure that your app’s users can securely access their accounts and personal preferences.</p>
<p class="calibre3">Once our users can log in, we’ll focus on presenting them with a rich selection of movies. We’ll employ Jetpack Compose to create dynamic and responsive lists, showcasing the available content.</p>
<p class="calibre3">Finally, we’ll delve into the details. Each movie or series in your app deserves its spotlight, and you’ll create detailed screens for them using Jetpack Compose. This will provide users with all the information they need to decide what to watch next.</p>
<p class="calibre3">So, this chapter will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Creating the app’s structure and modules</li>
<li class="calibre14">Building the login screen</li>
<li class="calibre14">Authenticating the app’s users</li>
<li class="calibre14">Creating your movie list</li>
<li class="calibre14">Making the movie and series detail screen</li>
</ul>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have installed Android Studio (or another editor of your preference).</p>
<p class="calibre3">We are going to start a new project in this chapter, so it is not necessary to download the changes made in the previous chapter.</p>
<p class="calibre3">You will find the complete code that we are going to build throughout this chapter in this repository: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7</a>.</p>
<h1 id="_idParaDest-144" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/>Creating the app’s structure and modules</h1>
<p class="calibre3">In this section, we’ll lay<a id="_idIndexMarker763" class="calibre6 pcalibre1 pcalibre"/> the foundation for our Packtflix app by organizing it into feature modules. As we have seen before, by dividing the app into modules such as login, list, and playback, we can work on one feature at a time without affecting the others and speed up the build process for larger projects. Additionally, we’ll set up a version catalog for our dependencies as we did before to streamline the management of libraries such as Jetpack Compose, Dagger Hilt, and Kotlin.</p>
<p class="calibre3">Let’s start creating the project. In Android Studio, select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project…</strong>, and choose <strong class="bold">Empty Compose Activity</strong>. Then, in the <strong class="bold">New Project</strong> panel, fill out <strong class="bold">Name</strong>, <strong class="bold">Package name</strong>, and <strong class="bold">Save location</strong>. For the <strong class="bold">Minimum SKD</strong> option, we will choose <strong class="bold">API 29</strong> again as it guarantees the best percentage of compatibility at the time of writing.</p>
<div><div><img alt="Figure 7.1: New project configuration for Packtflix" src="img/B19443_07_001.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1: New project configuration for Packtflix</p>
<p class="calibre3">The options in <em class="italic">Figure 7</em><em class="italic">.1</em> are the ones we will see using Android Studio Iguana (version 2023.2.1), though it may have variations depending on the version. For example, in other previous <a id="_idIndexMarker764" class="calibre6 pcalibre1 pcalibre"/>versions of Android Studio, we could also select whether we were going to use the version catalog for our dependencies.</p>
<p class="calibre3">Now, the version catalog is created by default, so we will already get a <code>libs.versions.toml</code> file in our project with the following content:</p>
<pre class="source-code">
[versions]
agp = "8.3.0-alpha18"
kotlin = "1.9.0"
coreKtx = "1.12.0"
junit = "4.13.2"
junitVersion = "1.1.5"
espressoCore = "3.5.1"
lifecycleRuntimeKtx = "2.7.0"
activityCompose = "1.8.2"
composeBom = "2023.08.00"
[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
[plugins]
androidApplication = { id = "com.android.application", version.ref = "agp" }
jetbrainsKotlinAndroid = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }</pre> <p class="calibre3">This code adds the basic dependencies to the version catalog to build an app with Kotlin, Android, and Jetpack <a id="_idIndexMarker765" class="calibre6 pcalibre1 pcalibre"/>Compose.</p>
<p class="calibre3">The next step will be to create the modules needed. Here, we will create three feature modules:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">:feature:login</strong>: We will use this module to include the login feature</li>
<li class="calibre14"><strong class="source-inline1">:feature:list</strong>: In this module, we will include the list screen as well as the detail screen</li>
<li class="calibre14"><strong class="source-inline1">:feature:playback</strong>: In this module, we will host all the playback functionality</li>
</ul>
<p class="calibre3">We will also create the following common modules:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">:app</strong>: This module will contain the entry point for our application</li>
<li class="calibre14"><strong class="source-inline1">:common</strong>: This module will contain common functionality needed in more than one module</li>
</ul>
<p class="calibre3">To create these modules, use the <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Module…</strong> option, as we have done in the previous projects. The final project structure should look like this:</p>
<div><div><img alt="Figure 7.2: Project module structure" src="img/B19443_07_002.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2: Project module structure</p>
<p class="calibre3">Now that we have <a id="_idIndexMarker766" class="calibre6 pcalibre1 pcalibre"/>created our module structure, it is time to set up the dependency injection framework.</p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/>Setting up the dependency injection framework</h2>
<p class="calibre3">As we saw in the <a id="_idIndexMarker767" class="calibre6 pcalibre1 pcalibre"/>previous <a id="_idIndexMarker768" class="calibre6 pcalibre1 pcalibre"/>chapters, the need for scalability, performance optimization, and testability has made the use of a dependency injection framework practically a must in Android. In this case, we will use Hilt again (to learn more about it, please refer to <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a> where we did a complete review of the framework and exposed its main advantages).</p>
<p class="calibre3">Let’s start adding the dependency to our version catalog. Open our <code>libs.versions.toml</code> file and add the Hilt dependencies in the <code>versions</code>, <code>libraries</code>, and <code>plugins</code> blocks, as follows:</p>
<pre class="source-code">
[versions]
// ...
hiltVersion = "2.50"
[libraries]
// ...
androidxHilt = { module = "com.google.dagger:hilt-android", name = "hilt", version.ref = "hiltVersion" }
hiltCompiler = { module = "com.google.dagger:hilt-android-compiler", name = "hilt-compiler", version.ref = "hiltVersion" }
[plugins]
// ...
hilt = { id = "com.google.dagger.hilt.android", version.ref = "hiltVersion" }</pre> <p class="calibre3">Then, we will add the plugin to the project-level <code>build.gradle.kts</code>:</p>
<pre class="source-code">
plugins {
    ...
    alias(libs.plugins.hilt) apply false
}</pre> <p class="calibre3">Next, in the <code>build.gradle.kts</code> file of every module, we will have to apply the plugin and<a id="_idIndexMarker769" class="calibre6 pcalibre1 pcalibre"/> add <a id="_idIndexMarker770" class="calibre6 pcalibre1 pcalibre"/>the Hilt dependency:</p>
<pre class="source-code">
plugins {
//...
    alias(libs.plugins.hilt)
}
dependencies {
//...
    implementation(libs.androidxHilt)
    kapt(libs.hiltCompiler)
}</pre> <p class="calibre3">Now, in the <code>:app</code> module, we can create the <code>PacktflixApp</code> class, which will be the entry point for the Hilt configuration:</p>
<pre class="source-code">
@HiltAndroidApp
class PacktflixApp: Application() {
}</pre> <p class="calibre3">With this annotation, we are enabling Hilt to generate the necessary components under the hood that will be used for dependency injection throughout our application.</p>
<p class="calibre3">Finally, we should include <code>PacktflixApp</code> in <code>AndroidManifest.xml</code>, so that our app uses it<a id="_idIndexMarker771" class="calibre6 pcalibre1 pcalibre"/> instead<a id="_idIndexMarker772" class="calibre6 pcalibre1 pcalibre"/> of the default <code>Application</code> class:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android =
"http://schemas.android.com/apk/res/android"
    xmlns:tools = "http://schemas.android.com/tools"&gt;
    &lt;application
        android:name = ".PacktflixApp"
        ...&gt;
....
    &lt;/application&gt;
&lt;/manifest&gt;</pre> <p class="calibre3">Now, we are all set to start building our new project. The first step will be to build the login screen as we <a id="_idIndexMarker773" class="calibre6 pcalibre1 pcalibre"/>want our users to <a id="_idIndexMarker774" class="calibre6 pcalibre1 pcalibre"/>authenticate themselves using their credentials. Let’s start working on it!</p>
<h1 id="_idParaDest-146" class="calibre5"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/>Building the login screen</h1>
<p class="calibre3">To build the<a id="_idIndexMarker775" class="calibre6 pcalibre1 pcalibre"/> login screen, we will start creating a <code>LoginScreen</code> composable <a id="_idIndexMarker776" class="calibre6 pcalibre1 pcalibre"/>with Jetpack Compose. We will have to include the app’s logo, fields to introduce the email and password, and a <strong class="bold">Login</strong> button. We can also include a text to show whether there are any errors when the user tries to log in.</p>
<p class="calibre3">This login screen is going to have four states (<code>Idle</code>, <code>Loading</code>, <code>Success</code>, and <code>Error</code>), so let’s start modeling the overall <code>ViewState</code>:</p>
<pre class="source-code">
sealed class LoginState {
    object Idle : LoginState()
    object Loading : LoginState()
    object Success : LoginState()
    data class Error(val message: String?) : LoginState()
}</pre> <p class="calibre3">Now, let’s <a id="_idIndexMarker777" class="calibre6 pcalibre1 pcalibre"/>create <a id="_idIndexMarker778" class="calibre6 pcalibre1 pcalibre"/>the <code>LoginScreen</code> composable:</p>
<pre class="source-code">
@Composable
fun LoginScreen() {
    val loginViewModel: LoginViewModel = hiltViewModel()
    val loginState =
        loginViewModel.loginState.collectAsState().value
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var errorMessage by remember { mutableStateOf("") }
//...
}</pre> <p class="calibre3">We start the composable function by obtaining <code>LoginViewModel</code>, accessed via <code>hiltViewModel()</code>. This <code>ViewModel</code> component manages the login logic and exposes the current login state through a <code>StateFlow</code> stream. The <code>collectAsState().value</code> call converts the asynchronous stream of login states into a composable-friendly state that triggers recompositions when the login state changes.</p>
<p class="calibre3">The function uses <code>remember { mutableStateOf("") }</code> to maintain the state of user inputs for email and password within the composable’s lifecycle. This state is mutable and reactive, meaning any changes to the input fields (handled by <code>onValueChange</code>) automatically update the corresponding variables and thus the UI.</p>
<p class="calibre3">Let’s continue now with the next part of the composable, which will include the name of the app, the <a id="_idIndexMarker779" class="calibre6 pcalibre1 pcalibre"/>fields for <code>email</code> and <code>password</code>, and<a id="_idIndexMarker780" class="calibre6 pcalibre1 pcalibre"/> the <strong class="bold">Login</strong> button:</p>
<pre class="source-code">
Surface(color = Color.Black, modifier =
Modifier.fillMaxSize()) {
        Column(
            horizontalAlignment =
                Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier
                .padding(16.dp)
        ) {
            if (loginState is LoginState.Error) {
                Text(
                    text = loginState.message ?:
                        "Unknown error",
                    color = Color.Red,
                    modifier = Modifier
                        .padding(bottom = 16.dp)
                )
            }
            Text(
                text = "PACKTFLIX",
                color = Color.Red,
                fontSize = 36.sp,
                modifier = Modifier.padding(bottom = 32.dp)
            )
            OutlinedTextField(
                value = email,
                onValueChange = { email = it },
                label = { Text("Email") },
                colors = OutlinedTextFieldDefaults.colors(
                    focusedContainerColor =
                        Color.Transparent,
                    focusedTextColor = Color.White,
                    focusedBorderColor = Color.Gray,
                    unfocusedBorderColor = Color.Gray
                ),
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Password") },
                visualTransformation =
                    PasswordVisualTransformation(),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedTextColor = Color.White,
                    focusedContainerColor =
                        Color.Transparent,
                    focusedBorderColor = Color.Gray,
                    unfocusedBorderColor = Color.Gray
                ),
                keyboardActions = KeyboardActions(
                    onDone = { loginViewModel.login(
                        email, password) }
                ),
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(24.dp))
            Button(
                onClick = { loginViewModel.login(email,
                    password) },
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.Gray)
            ) {
                Text("Sign In", color = Color.White)
            }
            Spacer(modifier = Modifier.height(24.dp))
            if (loginState is LoginState.Loading) {
                CircularProgressIndicator()
            }
        }
    }
    LaunchedEffect(loginState) {
        when (loginState) {
            is LoginState.Success -&gt; {
                // Navigate to next screen or show success
                   message
            }
            is LoginState.Error -&gt; {
                errorMessage = loginState.message ?:
                    "An error occurred"
            }
            else -&gt; Unit // Handle other states if
                            necessary
        }
    }</pre> <p class="calibre3">The UI dynamically adjusts based on the current login state. For example, if the login state is <code>LoginState.Error</code>, the function renders a <code>Text</code> composable to display the error message. This conditional rendering is crucial for providing feedback to the user, such as <a id="_idIndexMarker781" class="calibre6 pcalibre1 pcalibre"/>indicating a <a id="_idIndexMarker782" class="calibre6 pcalibre1 pcalibre"/>login failure or showing a loading indicator (<code>CircularProgressIndicator</code>) when the login process is underway. This approach to UI development is declarative, with the UI’s structure and content directly mapping to the application’s state.</p>
<p class="calibre3">The <code>OutlinedTextField</code> composables for <code>email</code> and <code>password</code> capture user inputs, which are then used to initiate the login process (<code>loginViewModel.login(email, password)</code>) when the user clicks the <code>password</code> field (via <code>KeyboardActions</code>). This demonstrates how to handle user actions and input in a composable, triggering <code>ViewModel</code> actions that ultimately lead to state changes.</p>
<p class="calibre3">Finally, the <code>LaunchedEffect</code> block listens for changes in the login state to perform side effects, such as navigation upon successful login or updating the error message state. This pattern separates side effects from the UI logic, ensuring that effects such as navigation or showing toasts only occur in response to state changes, not as a direct result of user actions.</p>
<p class="calibre3">Now, let’s start working on <code>LoginViewModel</code>:</p>
<pre class="source-code">
@HiltViewModel
class LoginViewModel @Inject constructor(
    private val loginUseCase: DoLoginUseCase
) : ViewModel() {
    private val _loginState =
        MutableStateFlow&lt;LoginState&gt;(LoginState.Idle)
    val loginState: StateFlow&lt;LoginState&gt; = _loginState
    fun login(email: String, password: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            val result = loginUseCase.doLogin(email,
                password)
            _loginState.value = when {
                result.isFailure -&gt; LoginState.Error(
                    result.exceptionOrNull()?.message)
                else -&gt; LoginState.Success
            }
        }
    }
}</pre> <p class="calibre3">Here, we start with the <a id="_idIndexMarker783" class="calibre6 pcalibre1 pcalibre"/>dependency injection stuff: the use of <code>@HiltViewModel</code> indicates that Hilt will be responsible for the instantiation and provision of <code>LoginViewModel</code>. The <code>@Inject</code> constructor signifies that Hilt will inject the necessary dependencies into this <code>ViewModel</code> instance, in this case, an implementation of a use case called <code>DoLoginUseCase</code> (we will implement this use case later).</p>
<p class="calibre3"> The <code>ViewModel</code> instance manages the login state using <code>MutableStateFlow&lt;LoginState&gt;</code>. Here, <code>_loginState</code> is a private, mutable state flow that holds the current state of the login process, which can be one of <code>Idle</code>, <code>Loading</code>, <code>Success</code>, or <code>Error</code>. The immutable <code>loginState</code> property exposes this state to the UI layer as a read-only <code>StateFlow</code>, ensuring that state updates are safely and efficiently communicated to the UI.</p>
<p class="calibre3">The login function embodies the core functionality of this <code>ViewModel</code> class. It initiates the login process by setting <code>_loginState</code> to <code>Loading</code>, indicating that the login operation has started. It then proceeds to call the <code>doLogin</code> method on the provided <code>loginUseCase</code> with the user’s email and password.</p>
<p class="calibre3">After attempting to log in, the function evaluates the result. If the login attempt fails (<code>result.isFailure</code>), <code>_loginState</code> is updated to <code>Error</code> with the exception message, providing feedback on why the login failed. If the login succeeds, <code>_loginState</code> is set to <code>Success</code>, indicating a successful login process. This conditional handling ensures that the UI can react appropriately to different outcomes of the login process.</p>
<p class="calibre3"> The login <a id="_idIndexMarker784" class="calibre6 pcalibre1 pcalibre"/>process is<a id="_idIndexMarker785" class="calibre6 pcalibre1 pcalibre"/> launched within <code>viewModelScope</code>, a coroutine scope tied to the <code>ViewModel</code> lifecycle. This ensures that any ongoing login operation is automatically canceled if the <code>ViewModel</code> instance is cleared (typically, when the associated UI component is destroyed), preventing memory leaks and unnecessary work.</p>
<p class="calibre3">With that, we have our login screen ready. The last step is to set up the Hilt modules and set the content of <code>MainActivity</code> to show the <code>LoginScreen</code> composable:</p>
<pre class="source-code">
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            PacktflixTheme {
                LoginScreen()
            }
        }
    }
}</pre> <p class="calibre3">If we now execute <a id="_idIndexMarker786" class="calibre6 pcalibre1 pcalibre"/>the app, we should see the following screen:</p>
<div><div><img alt="Figure 7.3: Packtflix login screen" src="img/B19443_07_003.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3: Packtflix login screen</p>
<p class="calibre3">Now that we have <a id="_idIndexMarker787" class="calibre6 pcalibre1 pcalibre"/>finished our UI, the next step will be to<a id="_idIndexMarker788" class="calibre6 pcalibre1 pcalibre"/> authenticate the users. Let’s learn how to do it.</p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/>Authenticating the app’s users</h1>
<p class="calibre3">In mobile applications, authentication <a id="_idIndexMarker789" class="calibre6 pcalibre1 pcalibre"/>plays a critical role in protecting user data and personal information from unauthorized access. As mobile devices often serve as personal gateways to a wide array of services and store a significant amount of sensitive data, ensuring that this data is securely managed and accessed is more important than ever. One of the preferred methods for authenticating users is OAuth2.</p>
<p class="calibre3"><strong class="bold">OAuth2</strong> is an authorization<a id="_idIndexMarker790" class="calibre6 pcalibre1 pcalibre"/> framework that allows third-party services to exchange web resources on behalf of a user. It enables users to grant websites or applications access to their information on other websites without giving them their passwords. This is particularly useful for providing functionalities such as logging in with Google, Facebook, or other social media accounts.</p>
<p class="calibre3">The following is a list of OAuth2’s most important features:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Security</strong>: It allows <a id="_idIndexMarker791" class="calibre6 pcalibre1 pcalibre"/>the user to authorize an application to access their resources on a different server without sharing their credentials, typically by using access tokens granted through a process involving user consent and secure token exchanges.<p class="calibre3">An OAuth <strong class="bold">token</strong> is a credential that represents the authorization granted to the application, allowing it to access specific resources on behalf of the user. These tokens can come in various formats, such as opaque tokens or <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>). Opaque <a id="_idIndexMarker792" class="calibre6 pcalibre1 pcalibre"/>tokens are simple strings without any specific structure, while JWTs are structured tokens that consist of three parts – a header, a payload, and a signature – all encoded in Base64.</p></li>
<li class="calibre14"><strong class="bold">Scalability</strong>: It allows for the delegation of user authentication to the service that hosts the user account, by offloading the technical complexities of secure authentication and infrastructure scalability to dedicated services. These services are usually managed by specific teams in charge of the complex and resource-intensive tasks of securing and scaling authentication processes.</li>
<li class="calibre14"><strong class="bold">Flexibility</strong>: It supports multiple flows (based on grant types, which will determine the flow the authentication process has to follow) for different types of clients, including mobile apps, websites, and server-side applications.</li>
<li class="calibre14"><strong class="bold">User Experience</strong>: It enables a smoother login experience for users, as users can use existing accounts<a id="_idIndexMarker793" class="calibre6 pcalibre1 pcalibre"/> to sign in to new services without creating new credentials.</li>
</ul>
<p class="calibre3">In essence, OAuth2 provides a secure and efficient way to implement authentication in mobile applications. It leverages existing user accounts, which simplifies the login process for users, and <a id="_idIndexMarker794" class="calibre6 pcalibre1 pcalibre"/>offloads the complexity of managing user credentials and sessions to a third-party service, enhancing both security and user experience.</p>
<p class="calibre3">Let’s add this feature to our app, starting by adding the models that are needed.</p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/>Creating the user model</h2>
<p class="calibre3">First, we will define <a id="_idIndexMarker795" class="calibre6 pcalibre1 pcalibre"/>a simple user model that will hold the user information we will receive upon successful authentication:</p>
<pre class="source-code">
data class User(
    val id: String,
    val name: String,
    val email: String,
    // Add other fields as necessary
)</pre> <p class="calibre3">In this code, we are defining the basic fields needed to hold the user information (depending on the requirements of your app, these fields will be different).</p>
<p class="calibre3">Then, to build the login request that we are going to send to the backend to obtain the authentication token, we will need another data class to hold the credentials:</p>
<pre class="source-code">
data class LoginRequest(val email: String, val password:
String)</pre> <p class="calibre3">Here, we are including the <code>email</code> and <code>password</code> fields, which will be mandatory to be able to log users in.</p>
<p class="calibre3">Once this request reaches the backend, if the credentials are correct, the backend will return an authorization token, which our app will store in a secure place and will use to authenticate the following API calls to the backend. We will need another model to hold this token <a id="_idIndexMarker796" class="calibre6 pcalibre1 pcalibre"/>information:</p>
<pre class="source-code">
data class AuthToken(val token: String)</pre> <p class="calibre3">Now, let’s set Retrofit to get this authorization token.</p>
<h2 id="_idParaDest-149" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/>Using Retrofit to get the authorization token</h2>
<p class="calibre3">To obtain the <a id="_idIndexMarker797" class="calibre6 pcalibre1 pcalibre"/>authorization <a id="_idIndexMarker798" class="calibre6 pcalibre1 pcalibre"/>token, we need<a id="_idIndexMarker799" class="calibre6 pcalibre1 pcalibre"/> our app to request it when the user provides their credentials. In order to send this request to the backend, we are going to use Retrofit. We already used Retrofit in <a href="B19443_04_split_000.xhtml#_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 4</em></a>, so let’s skip the introductions and start with the setup of an interface that Retrofit will use to make the HTTP requests:</p>
<pre class="source-code">
interface AuthService {
    @POST("auth/login")
    suspend fun login(@Body loginRequest: LoginRequest):
        Response&lt;AuthToken&gt;
}</pre> <p class="calibre3">This code defines an interface called <code>AuthService</code> with a unique login function. We will pass a <code>LoginRequest</code> object with the data needed for the request and then will obtain an <code>AuthToken</code> response.</p>
<p class="calibre3">Let’s build those models. First, we’ll build the <code>LoginRequest</code> model:</p>
<pre class="source-code">
data class LoginRequest(val email: String, val password:
String)</pre> <p class="calibre3">In this model, we will send the user’s credentials – their email and password – to the backend.</p>
<p class="calibre3">Then, if the login has been successful, the backend should answer with a response including an authorization token. We will structure this response as follows:</p>
<pre class="source-code">
data class AuthToken(val token: String)</pre> <p class="calibre3">This <code>AuthToken</code> model will include the aforementioned authorization token. Note that, usually, these tokens have a time window and so have to be renewed before they have expired. For simplicity, we are going to assume this token will not expire.</p>
<p class="calibre3">Now, let’s create<a id="_idIndexMarker800" class="calibre6 pcalibre1 pcalibre"/> our remote<a id="_idIndexMarker801" class="calibre6 pcalibre1 pcalibre"/> data source to retrieve <a id="_idIndexMarker802" class="calibre6 pcalibre1 pcalibre"/>the authorization token:</p>
<pre class="source-code">
class LoginRemoteDataSource(
    private val authService: AuthService
) {
    suspend fun login(email: String, password: String):
    Result&lt;String&gt; {
        return authService.login(
            LoginRequest(
                email = email,
                password = password
            )
        ).run {
            val token = this.body()?.token
            if (this.isSuccessful &amp;&amp; token != null) {
                Result.success(token)
            } else {
                Result.failure(getError(this))
            }
        }
    }
}</pre> <p class="calibre3">Here, we define the <code>LoginRemoteDataSource</code> class, which will act as a data source layer for handling login functionality by interacting with the remote authentication service. This class will have a single dependency, <code>authService</code>, which is an interface (presumably Retrofit or a similar networking library) responsible for making network requests related to authentication. The primary function within this class, <code>login</code>, is a suspended function that takes two parameters, <code>email</code> and <code>password</code>, which are used to construct a <code>LoginRequest</code> object. This object is then passed to the <code>authService.login</code> method, initiating a network request to log the user in.</p>
<p class="calibre3">Upon receiving the response from <code>authService.login</code>, the <code>run</code> block is executed to handle the response. Inside this block, the response is checked to determine whether the request was successful (<code>isSuccessful</code>) and whether the response body contains a non-<code>null</code> token. If both conditions are met, <code>Result.success(token)</code> is returned, encapsulating the token in a successful result. This indicates that the login was successful and provides the caller with the token. Conversely, if either condition is not satisfied – meaning the request failed or the token was null – a failure result is returned by calling <code>Result.failure(getError(this))</code>. The <code>getError</code> function will analyze the <code>Response&lt;AuthToken&gt;</code> object to determine the nature of the failure and <a id="_idIndexMarker803" class="calibre6 pcalibre1 pcalibre"/>return<a id="_idIndexMarker804" class="calibre6 pcalibre1 pcalibre"/> an <a id="_idIndexMarker805" class="calibre6 pcalibre1 pcalibre"/>appropriate <code>Throwable</code> object that describes the error.</p>
<p class="calibre3">At this point, let’s build the <code>getError()</code> function:</p>
<pre class="source-code">
    private fun getError(response: Response&lt;AuthToken&gt;):
    Throwable {
        return when (response.code()) {
            401 -&gt; LoginException.AuthenticationException(
                "Invalid email or password.")
            403 -&gt; LoginException.AccessDeniedException(
                "Access denied.")
            404 -&gt; LoginException.NotFoundException(
                "Login endpoint not found.")
            in 500..599 -&gt; LoginException.ServerException(
                "Server error: ${response.message()}.")
            else -&gt; LoginException.HttpException(
                response.code(),
                "HTTP error: ${response.code()}
                    ${response.message()}."
            )
        }
    }</pre> <p class="calibre3">In this <code>getError</code> function, we map the possible values of the status code from the response to different errors. If we wanted to, we could later process those errors and show messages to the user accordingly.</p>
<p class="calibre3">Let’s also define those errors, in which we will map the server response. We will define them as part of a <code>LoginException</code> sealed class, which is a special type of class in Kotlin that restricts the inheritance hierarchy to a specific set of subclasses, providing exhaustive <code>when</code> expressions<a id="_idIndexMarker806" class="calibre6 pcalibre1 pcalibre"/> and <a id="_idIndexMarker807" class="calibre6 pcalibre1 pcalibre"/>ensuring that every possible type <a id="_idIndexMarker808" class="calibre6 pcalibre1 pcalibre"/>of error is handled:</p>
<pre class="source-code">
sealed class LoginException(loginErrorMessage: String, val
code: Int? = null) : Exception(loginErrorMessage) {
    class AuthenticationException(message: String) :
        LoginException(message)
    class AccessDeniedException(message: String) :
        LoginException(message)
    class NotFoundException(message: String) :
        LoginException(message)
    class ServerException(message: String) :
        LoginException(message)
    class HttpException(code: Int, message: String) :
        LoginException(message, code)
}</pre> <p class="calibre3">Now that we have our <code>LoginRemoteDataSource</code> component, it is time to define how to<a id="_idIndexMarker809" class="calibre6 pcalibre1 pcalibre"/> store<a id="_idIndexMarker810" class="calibre6 pcalibre1 pcalibre"/> the<a id="_idIndexMarker811" class="calibre6 pcalibre1 pcalibre"/> token.</p>
<h2 id="_idParaDest-150" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/>Using DataStore to store the token</h2>
<p class="calibre3">Introduced by Google, <strong class="bold">DataStore</strong> is a data storage solution that provides an efficient, secure, and <a id="_idIndexMarker812" class="calibre6 pcalibre1 pcalibre"/>asynchronous<a id="_idIndexMarker813" class="calibre6 pcalibre1 pcalibre"/> way of persisting small pieces of data. It uses Kotlin coroutines and flow streams to store data asynchronously, ensuring UI thread safety and smoother performance.</p>
<p class="calibre3">DataStore comes with several features that make it a preferable data storage option in Android applications:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Asynchronous by default</strong>: DataStore <a id="_idIndexMarker814" class="calibre6 pcalibre1 pcalibre"/>operations are performed asynchronously using Kotlin coroutines, preventing blocking the main thread and improving app performance.</li>
<li class="calibre14"><strong class="bold">Safe and consistent</strong>: With built-in transactional data APIs, DataStore ensures data consistency and integrity, even if an app process is killed during a write operation.</li>
<li class="calibre14"><strong class="bold">Type safety</strong>: DataStore offers two implementations: Preferences DataStore, which stores and retrieves key-value pairs, and Proto DataStore, which allows for storing type-safe objects using Protocol Buffers.</li>
<li class="calibre14"><strong class="bold">Security</strong>: DataStore can be integrated with encryption mechanisms to securely store sensitive information. DataStore can be combined with encryption libraries such as Tink to encrypt the data before saving, making it a more secure option for handling<a id="_idIndexMarker815" class="calibre6 pcalibre1 pcalibre"/> user credentials, tokens, and other sensitive information.</li>
</ul>
<p class="calibre3">Why will we use DataStore and not Room (which we used previously for our WhatsPackt messenger project)? While both are robust data persistence libraries, they serve different purposes and have distinct use cases:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Use case suitability</strong>: DataStore<a id="_idIndexMarker816" class="calibre6 pcalibre1 pcalibre"/> is designed for storing small collections of data, such as settings, preferences, or application state. It excels in handling lightweight tasks where the data structure is simple. <strong class="source-inline1">RoomDatabase</strong> is a SQLite abstraction that significantly reduces the amount of boilerplate code needed to use SQLite. It’s intended for more complex data storage requirements, such as storing large datasets, relational data, or when we need to perform complex queries.</li>
<li class="calibre14"><strong class="bold">Performance and complexity</strong>: DataStore provides a simpler API for data storage with minimal setup, making it ideal for straightforward tasks. Its performance is optimized for small datasets and simple data structures. <strong class="source-inline1">RoomDatabase</strong>, being a database, is more suited for complex queries and large datasets. It involves more setup and is heavier than DataStore but offers more features and capabilities for comprehensive data management.</li>
<li class="calibre14"><strong class="bold">Data security</strong>: DataStore, especially with Proto DataStore, can easily be integrated with encryption mechanisms to store data securely, making it a more secure option for sensitive information. <strong class="source-inline1">RoomDatabase</strong> supports SQLite encryption, but integrating encryption requires additional setup and possibly third-party libraries.</li>
</ul>
<p class="calibre3">As we just need to<a id="_idIndexMarker817" class="calibre6 pcalibre1 pcalibre"/> store a small <a id="_idIndexMarker818" class="calibre6 pcalibre1 pcalibre"/>value (the token) and given its security features, DataStore is the best option.</p>
<p class="calibre3">So, to start using it, first, we need to set up the DataStore dependency and its version in our version catalog:</p>
<pre class="source-code">
[versions]
datastore = "1.0.0"
[libraries]
datastore = { module = "androidx.datastore:datastore-
preferences", version.ref = "datastore" }</pre> <p class="calibre3">Then, need to add it to our modules’ <code>gradle.build.kts</code> files:</p>
<pre class="source-code">
dependencies {
 ...
    implementation(libs.datastore)
}</pre> <p class="calibre3">With this code, we are only adding it to the modules where we would need to use the dependency – initially, this will just be in the <code>:feature:login</code> module.</p>
<p class="calibre3">Now, we can start using the DataStore library. We are going to build a <code>LoginLocalDataSource</code> component, which will be responsible for storing and retrieving the<a id="_idIndexMarker819" class="calibre6 pcalibre1 pcalibre"/> token in and<a id="_idIndexMarker820" class="calibre6 pcalibre1 pcalibre"/> from the DataStore:</p>
<pre class="source-code">
val Context.dataStore by preferencesDataStore(name = "user_preferences")
class LoginLocalDataSource(private val context: Context) {
    companion object {
        val TOKEN_KEY = stringPreferencesKey("auth_token")
    }
    suspend fun saveAuthToken(token: String) {
        context.dataStore.edit { preferences -&gt;
            preferences[TOKEN_KEY] = token
        }
    }
    suspend fun getAuthToken(): Result&lt;String&gt; {
        val preferences = context.dataStore.data.first()
        val token = preferences[TOKEN_KEY]
        return if (token != null) {
            Result.success(token)
        } else {
            Result.failure(TokenNotFoundError())
        }
    }
}
class TokenNotFoundError : Throwable("Auth token not
found")</pre> <p class="calibre3">In <code>LoginLocalDataSource</code>, first, we leverage Kotlin’s property delegation feature to initialize the DataStore. By defining <code>val Context.dataStore</code> with <code>preferencesDataStore(name: "user_preferences")</code>, we ensure a single instance of the DataStore is lazily initialized and tied to the application’s context. This method optimizes resource use and simplifies subsequent data operations.</p>
<p class="calibre3">Within <code>LoginLocalDataSource</code>, we define a companion object to hold <code>TOKEN_KEY</code>, a key used to store and retrieve the authentication token from the DataStore. This key is defined using <code>stringPreferencesKey("auth_token")</code>, indicating the data type we intend to store – in this case, a <code>String</code> type.</p>
<p class="calibre3">In the <code>saveAuthToken</code> function, we perform a write operation on the DataStore by calling <code>edit</code> and passing a lambda that assigns the provided token to <code>TOKEN_KEY</code>. This operation is atomic and thread-safe, ensuring the integrity of our data.</p>
<p class="calibre3">To retrieve<a id="_idIndexMarker821" class="calibre6 pcalibre1 pcalibre"/> the<a id="_idIndexMarker822" class="calibre6 pcalibre1 pcalibre"/> authentication token, <code>getAuthToken</code> also employs suspending semantics to facilitate asynchronous execution. It accesses the DataStore’s data as a flow, immediately fetching the first emitted value with <code>.data.first()</code>. This operation suspends the coroutine, effectively making the data retrieval feel synchronous while maintaining the benefits of asynchronous execution. The function then checks whether the token exists and returns it wrapped in <code>Result&lt;String&gt;</code>, providing a straightforward way to handle success and failure. In the absence of a token, it returns <code>Result.failure</code> with a custom <code>TokenNotFoundError</code>, offering precise error handling.</p>
<p class="calibre3">Now, it is time to implement <code>LoginRepository</code>, which is responsible for coordinating between the remote and local data sources. We will build it, as always, by creating an interface in the domain layer and the implementation in the data layer. This is because the domain shouldn’t have any explicit dependency from the data layer, to respect the clean architecture. So, we define the interface like so:</p>
<pre class="source-code">
interface LoginRepository {
    suspend fun getToken(): Result&lt;String&gt;
    suspend fun loginWithCredentials(email: String,
        password: String): Result&lt;Unit&gt;
}</pre> <p class="calibre3">Here, the interface will have two functions: one to obtain the token so it can be used elsewhere (for example, for the backend requests to authenticate the user once it has been obtained) <a id="_idIndexMarker823" class="calibre6 pcalibre1 pcalibre"/>and another<a id="_idIndexMarker824" class="calibre6 pcalibre1 pcalibre"/> to perform the login and store the newly obtained authentication token.</p>
<p class="calibre3">Now, let’s implement the repository:</p>
<pre class="source-code">
class LoginRepositoryImpl(
    private val localDataSource: LoginLocalDataSource,
    private val remoteDataSource: LoginRemoteDataSource
): LoginRepository {
    override suspend fun getToken(): Result&lt;String&gt; {
        return localDataSource.getAuthToken()
    }
    override suspend fun loginWithCredentials(email:
    String, password: String): Result&lt;Unit&gt; {
        return remoteDataSource.login(email, password)
            .fold(
                onSuccess = {
                    localDataSource.saveAuthToken(it)
                    Result.success(Unit)
                },
                onFailure = {
                    Result.failure(it)
                }
            )
    }
}</pre> <p class="calibre3">The <code>LoginRepositoryImpl</code> class serves as an implementation of the <code>LoginRepository</code> interface, acting as a mediator between the application’s data sources and its use cases or view models. This class abstracts the details of data retrieval and storage, providing a cohesive API for authentication processes. It relies on two primary data sources: <code>localDataSource</code> for local data storage and retrieval, and <code>remoteDataSource</code> for handling network requests related to user authentication.</p>
<p class="calibre3">In the <code>getToken</code> function, the repository directly delegates the call to <code>localDataSource.getAuthToken()</code>, which fetches the authentication token from local storage. This method returns a <code>Result&lt;String&gt;</code> object,  encapsulating the outcome<a id="_idIndexMarker825" class="calibre6 pcalibre1 pcalibre"/> of the<a id="_idIndexMarker826" class="calibre6 pcalibre1 pcalibre"/> operation in a type-safe manner. The token retrieval is critical for checking the user’s authentication status or for subsequent authenticated API calls that require a token.</p>
<p class="calibre3">The <code>loginWithCredentials</code> function implements the process of authenticating a user with their email and password. It first attempts to log in through the <code>remoteDataSource.login(email, password)</code> method. Upon a successful login, indicated by the <code>onSuccess</code> branch of the fold, it saves the received authorization token using <code>localDataSource.saveAuthToken(it)</code> and then signals the completion of the login process with <code>Result.success(Unit)</code>. Conversely, if the remote login attempt fails (<code>onFailure</code>), it propagates the failure as <code>Result.failure(it)</code>, allowing the calling code to handle the error appropriately. This design effectively separates concerns between local and remote data handling, ensuring that the repository remains the single source of truth for all authentication-related data flows within the application.</p>
<p class="calibre3">Now, we can build a <a id="_idIndexMarker827" class="calibre6 pcalibre1 pcalibre"/>use case to perform the login, consuming this <code>LoginRepository</code> component:</p>
<pre class="source-code">
interface DoLoginUseCase {
    suspend fun doLogin(email: String, password: String):
        Result&lt;Unit&gt;
}
class DoLogin(
    private val loginRepository: LoginRepository
) : DoLoginUseCase {
    override suspend fun doLogin(email: String, password:
    String): Result&lt;Unit&gt; {
        return loginRepository.loginWithCredentials(email,
            password)
    }
}</pre> <p class="calibre3">The <code>DoLogin</code> class implements the <code>DoLoginUseCase</code> interface, encapsulating the logic required to authenticate a user by their email and password. By delegating the authentication process to <code>loginRepository</code>, it invokes <code>loginRepository.loginWithCredentials(email, password)</code> to perform the actual login operation. The <code>DoLogin</code> use case simplifies the process of user authentication into a single method call, ensuring that the details of how the login is performed are encapsulated within the repository, thereby promoting the separation of concerns and<a id="_idIndexMarker828" class="calibre6 pcalibre1 pcalibre"/> making the<a id="_idIndexMarker829" class="calibre6 pcalibre1 pcalibre"/> code easier to maintain and test.</p>
<p class="calibre3">Now, we are all set to use the login functionality. Next, let’s use those tokens to validate the app requests.</p>
<h2 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/>Sending the authorization token in requests</h2>
<p class="calibre3">To finish the <a id="_idIndexMarker830" class="calibre6 pcalibre1 pcalibre"/>users authentication:authorization token, sending in requests” authentication <a id="_idIndexMarker831" class="calibre6 pcalibre1 pcalibre"/>tasks, there is still one thing we have to do. The reason we were obtaining this authentication token was to be used in the requests the app is going to send to the backend, so it will guarantee the authenticity of the user that has generated the request. To include the token in every request, we are going to take advantage of Retrofit interceptors.</p>
<p class="calibre3">A Retrofit <strong class="bold">interceptor</strong> is a<a id="_idIndexMarker832" class="calibre6 pcalibre1 pcalibre"/> powerful mechanism provided by OkHttp (the underlying HTTP client used by Retrofit) that allows you to intercept and manipulate the request and response chain. Interceptors can modify requests and responses or perform actions such as logging, adding headers, handling authentication, and much more, before the request is sent to the server or after the response is received by the client.</p>
<p class="calibre3">Interceptors can be broadly categorized into two types:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Application interceptors</strong>: These <a id="_idIndexMarker833" class="calibre6 pcalibre1 pcalibre"/>interceptors are called once for any single call to the server. They don’t need to worry about network specifics such as retries and redirects. Application interceptors are perfect for tasks such as adding a common header to all requests, logging the request and response body for debugging purposes, or managing application-level caching.</li>
<li class="calibre14"><strong class="bold">Network interceptors</strong>: These interceptors can monitor the data at the network level. They can observe and manipulate requests and responses that come from and go<a id="_idIndexMarker834" class="calibre6 pcalibre1 pcalibre"/> to the server, including any retries and redirects that occur as part of the network call process.</li>
</ul>
<p class="calibre3">To add an authentication token to all outgoing requests, we will choose an application interceptor. We will choose an application interceptor in this scenario because they are designed to operate at the application layer, directly modifying requests before they are sent out and processing responses once they are received. This makes them well suited for tasks such as adding<a id="_idIndexMarker835" class="calibre6 pcalibre1 pcalibre"/> headers that should be included in every request to the server, such as authentication tokens.</p>
<p class="calibre3">So, let’s write our interceptor:</p>
<pre class="source-code">
class AuthInterceptor(private val loginRepository:
LoginRepository) : Interceptor {
    override fun intercept(chain: Interceptor.Chain):
    Response {
        val originalRequest = chain.request()
        val token = runBlocking {
            loginRepository.getToken().getOrNull() }
        val requestWithToken = originalRequest.newBuilder()
            .apply {
                if (token != null) {
                    header("Authorization",
                        "Bearer $token")
                }
            }
            .build()
        return chain.proceed(requestWithToken)
    }
}</pre> <p class="calibre3">This class plays a critical role in enriching outgoing HTTP requests with authentication details. It achieves this by integrating with <code>LoginRepository</code>, from which it retrieves the current user’s authorization token. Upon intercepting a request, the interceptor fetches the<a id="_idIndexMarker836" class="calibre6 pcalibre1 pcalibre"/>users authentication:authorization token, sending in requests”  token <a id="_idIndexMarker837" class="calibre6 pcalibre1 pcalibre"/>synchronously using <code>runBlocking</code> (a mechanism that allows for the seamless integration of coroutine-based asynchronous token retrieval into the synchronous flow expected by interceptors).</p>
<p class="calibre3">If a token is present, it’s appended to the request as an <code>Authorization</code> header, adhering to the widely accepted bearer token format (the bearer token format is a security scheme where a client sends a token in the header of the requests to authenticate access, prefixed with the word <code>Bearer</code> followed by a space and the token itself), thereby ensuring that the request carries the necessary credentials for authentication by the server.</p>
<p class="calibre3">Using <code>runBlocking</code> within the interceptor is a pragmatic approach to accommodate the synchronous nature of the <code>intercept()</code> method, allowing for the immediate availability of the token. However, it’s crucial to ensure that the token retrieval operation is efficient and non-blocking to avoid performance bottlenecks – ideally, by fetching the token from a local cache or storage.</p>
<p class="calibre3">Finally, at the end of the function, we return <code>chain.proceed(requestwithToken)</code>, which will allow Retrofit to continue processing the request, including the interceptor changes (in this case, adding the authentication header).</p>
<p class="calibre3">Now, we should include <code>AuthInterceptor</code> as an <a id="_idIndexMarker838" class="calibre6 pcalibre1 pcalibre"/>interceptor when we are building the Retrofit client:</p>
<pre class="source-code">
    @Provides
    @Singleton
    fun provideRetrofit(
        moshi: Moshi,
        authInterceptor: AuthInterceptor
    ): Retrofit {
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .build()
        return Retrofit.Builder()
            .baseUrl("https://your.api.url/") // Replace
                                                 with your
                                                 actual
                                                 base URL
            .addConverterFactory(
                MoshiConverterFactory.create(moshi))
            .client(okHttpClient)
            .build()
    }</pre> <p class="calibre3">Here, we can see how we can integrate the interceptor we’ve created into our network layer setup, specifically within a Retrofit configuration.</p>
<p class="calibre3">Within the function, an <code>OkHttpClient</code> instance is created and configured to include the <code>authInterceptor</code> instance via the <code>addInterceptor</code> method. This setup ensures that every HTTP request made by this client will first pass through the <code>authInterceptor</code>, allowing it to modify the request as needed before it is sent out.</p>
<p class="calibre3">Following the configuration of the <code>OkHttpClient</code> instance, the Retrofit instance is built. The configured <code>OkHttpClient</code> instance is set as the client for Retrofit, linking the HTTP client, with its interceptor, to the Retrofit instance. Now, all the requests using this Retrofit instance will include the authentication token in the header, if it exists.</p>
<p class="calibre3">After that, we<a id="_idIndexMarker839" class="calibre6 pcalibre1 pcalibre"/>users authentication:authorization token, sending in requests”  handled<a id="_idIndexMarker840" class="calibre6 pcalibre1 pcalibre"/> the app authentication, from obtaining the token and storing it to providing this token in every request. Now, it’s time to build the main screen: the list of movies and series.</p>
<h1 id="_idParaDest-152" class="calibre5"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/>Creating your movie list</h1>
<p class="calibre3">One of the goals of <a id="_idIndexMarker841" class="calibre6 pcalibre1 pcalibre"/>our Packtflix app is for users to have the freedom to<a id="_idIndexMarker842" class="calibre6 pcalibre1 pcalibre"/> explore and enjoy an extensive range of movies (or TV series), ensuring they stay engaged with our app. To achieve this, we must present our movie catalog in the most appealing manner possible. For that reason, in this section, we will focus on building a movie (or series!) catalog screen.</p>
<p class="calibre3">To start building the classical main screen of our streaming app, we first need to create the models we will use to represent the information.</p>
<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/>Building the models</h2>
<p class="calibre3">Start by<a id="_idIndexMarker843" class="calibre6 pcalibre1 pcalibre"/> building<a id="_idIndexMarker844" class="calibre6 pcalibre1 pcalibre"/> the <code>Movie</code> model:</p>
<pre class="source-code">
data class Movie(
    val id: Int,
    val title: String,
    val imageUrl: String,
)</pre> <p class="calibre3">This is the model that will represent a movie – it includes the movie identification (<code>id</code>), its title, and a URL to an image of the movie.</p>
<p class="calibre3">Generally, movies in a streaming app are arranged by genres, so let’s create a <code>Genre</code> model too:</p>
<pre class="source-code">
data class Genre(
    val name: String,
    val movies: List&lt;Movie&gt;
)</pre> <p class="calibre3">Here we defined the name of the genre (needed to render it on the screen) and a list of the movies included in that genre.</p>
<p class="calibre3">Finally, we need a <code>MoviesViewState</code> class to represent the movie list screen state:</p>
<pre class="source-code">
data class MoviesViewState(
    val genres: List&lt;Genre&gt;
)</pre> <p class="calibre3">In this <code>MoviesViewState</code> class,  we are including just one property, <code>genres</code>, which will store the list of genres we want to show in the list of our streaming app.</p>
<p class="calibre3">Now, we are <a id="_idIndexMarker845" class="calibre6 pcalibre1 pcalibre"/>ready to start creating<a id="_idIndexMarker846" class="calibre6 pcalibre1 pcalibre"/> the <code>MoviesScreen</code> composable.</p>
<h2 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor155" class="calibre6 pcalibre1 pcalibre"/>Building the MoviesScreen composable</h2>
<p class="calibre3">To build <a id="_idIndexMarker847" class="calibre6 pcalibre1 pcalibre"/>the <code>MoviesScreen</code> composable, enter<a id="_idIndexMarker848" class="calibre6 pcalibre1 pcalibre"/> the following code:</p>
<pre class="source-code">
@Composable
fun MoviesScreen(moviesViewState: MoviesViewState =
sampleMoviesScreen()) {
    Scaffold(
        containerColor = Color.Black,
        topBar = { PacktflixTopBar() },
        bottomBar = { PacktflixBottomBar() }
    ) { innerPadding -&gt;
        GenreList(
            genres = moviesViewState.genres,
            modifier = Modifier.padding(innerPadding)
        )
    }
}</pre> <p class="calibre3">As we can see, we have created our <code>MoviesScreen</code> composable and a <code>Scaffold</code> inside of it. As a <code>topBar</code> component of the <code>Scaffold</code>, we are including a new composable called <code>PackflixTopBar</code>, then as a <code>bottomBar</code> component, we are including another new composable called <code>PacktflixBottomBar</code>. Finally, in the content of the Scaffold, we are showing a <code>GenreList</code> composable.</p>
<p class="calibre3">Now, let’s build these <a id="_idIndexMarker849" class="calibre6 pcalibre1 pcalibre"/>three <a id="_idIndexMarker850" class="calibre6 pcalibre1 pcalibre"/>composables: <code>PacktflixTopBar</code>, <code>PacktflixBottomBar</code>, and <code>GenreList</code>.</p>
<h3 class="calibre9">PacktflixTopBar</h3>
<p class="calibre3">Here is <a id="_idIndexMarker851" class="calibre6 pcalibre1 pcalibre"/>how<a id="_idIndexMarker852" class="calibre6 pcalibre1 pcalibre"/> we create the <code>PacktflixTopBar</code> composable:</p>
<pre class="source-code">
@Composable
fun PacktflixTopBar() {
    TopAppBar(
        title = {
            Text(
                text = "PACKTFLIX",
                color = Color.Red,
                fontSize = 48.sp,
                modifier = Modifier.padding(bottom = 32.dp)
            )
        },
        actions = {
            IconButton(onClick =
            { /* Handle profile action */ }) {
                Icon(
                    painter = painterResource(id =
                        R.drawable.ic_profile),
                    contentDescription = "Profile"
                )
            }
            IconButton(onClick = { /* Handle more action */ }) {
                Icon(
                    painter = painterResource(id =
                        R.drawable.ic_more),
                    contentDescription = "More"
                )
            }
        },
    )
}</pre> <p class="calibre3">Inside <code>TopAppBar</code>, there’s a title that displays the text <strong class="bold">PACKTFLIX</strong> on the screen – the text will be colored in red, with a large font size and some padding to create some space.</p>
<pre>IconButton</strong> composable that contains an icon, and each icon gets its image from a resource file.</pre>
<p class="calibre3">This is how <code>TopAppBar</code> will look:</p>
<div><div><img alt="Figure 7.4: Top bar in MoviesScreen" src="img/B19443_07_004.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4: Top bar in MoviesScreen</p>
<p class="calibre3">Let’s continue with the bottom bar.</p>
<h3 class="calibre9">PacktflixBottomBar</h3>
<p class="calibre3">Now, let’s <a id="_idIndexMarker855" class="calibre6 pcalibre1 pcalibre"/>build<a id="_idIndexMarker856" class="calibre6 pcalibre1 pcalibre"/> the <code>PacktflixBottomBar</code> composable:</p>
<pre class="source-code">
@Composable
fun PacktflixBottomBar() {
    NavigationBar (
        containerColor = Color.Black,
        contentColor = Color.White,
    ) {
        NavigationBarItem(
            icon = { Icon(Icons.Filled.Home,
                contentDescription = "Home") },
            selected = false,
            onClick = { /* Handle Home navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.Search,
                contentDescription = "Search") },
            selected = false,
            onClick = { /* Handle Search navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.ArrowDropDown,
                contentDescription = "Downloads") },
            selected = false,
            onClick = { /* Handle Downloads navigation */ }
        )
        NavigationBarItem(
            icon = { Icon(Icons.Filled.MoreVert,
                contentDescription = "More") },
            selected = false,
            onClick = { /* Handle More navigation */ }
        )
    }
}</pre> <p class="calibre3">This navigation bar sports a sleek black background with icons illuminated in white, offering a stark and stylish contrast. We’re also introducing four navigation items, each symbolized by a distinct icon. We’ve opted for icons from the Material Icons collection, assigning specific and intuitive symbols to signify <strong class="bold">Home</strong>, <strong class="bold">Search</strong>, <strong class="bold">Downloads</strong>, and <strong class="bold">More</strong> functionalities.</p>
<p class="calibre3">For each navigation item within <code>NavigationBarItem</code>, we have set up an icon along with an <code>onClick</code> listener. Initially, all these items are not selected (<code>selected = false</code>) to indicate that their selection state will be managed dynamically through user interactions <a id="_idIndexMarker857" class="calibre6 pcalibre1 pcalibre"/>or<a id="_idIndexMarker858" class="calibre6 pcalibre1 pcalibre"/> specific logic to be implemented in the future. The implementation of these sections is beyond the scope of this book.</p>
<p class="calibre3">We are also pairing each icon with <code>contentDescription</code>. This approach enhances app accessibility by offering screen readers a concise explanation of each button’s function.</p>
<p class="calibre3">Once it is finished, this is how <code>PacktflixBottomBar</code> will look:</p>
<div><div><img alt="Figure 7.5: Bottom bar in MoviesScreen" src="img/B19443_07_005.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5: Bottom bar in MoviesScreen</p>
<p class="calibre3">Now, let’s continue with the next step and complete this screen by implementing the list of movies.</p>
<h3 class="calibre9">GenreList</h3>
<p class="calibre3">Now, let’s start <a id="_idIndexMarker859" class="calibre6 pcalibre1 pcalibre"/>building the <code>GenreList</code> composable. Generally, the<a id="_idIndexMarker860" class="calibre6 pcalibre1 pcalibre"/> content of a movie screen in a streaming app is composed of a list of genres, where each one contains a list of movies. Let’s use the <code>Genre</code> model we defined previously and create this list of lists. We will start creating a vertical list composed of rows where every row will show the content of every <code>Genre</code> instance:</p>
<pre class="source-code">
@Composable
fun GenreList(genres: List&lt;Genre&gt;, modifier: Modifier =
Modifier) {
    LazyColumn(modifier = modifier) {
        items(genres.size) { index -&gt;
            GenreRow(genre = genres[index])
        }
    }
}</pre> <p class="calibre3">To efficiently display the <code>GenreList</code> composable, we employed <code>LazyColumn</code>, chosen for its ability to render items lazily – this means it only draws the items visible on the screen, enhancing performance, especially for long lists.</p>
<p class="calibre3">Inside <code>LazyColumn</code>, we iterate over the genre list. For each genre, we call items, specifying the size of our genre list to determine the number of items it should prepare to display.</p>
<p class="calibre3">Then, for every item (or genre, in our context), we invoke <code>GenreRow</code>, a custom composable function that we will define in a moment. This function is responsible for rendering a single row in our list, which represents a genre. We pass each genre to <code>GenreRow</code> by indexing it into our genres list with <code>genres[index]</code>.</p>
<p class="calibre3">Now, let’s build the <code>GenreRow</code> composable that we just mentioned:</p>
<pre class="source-code">
@Composable
fun GenreRow(genre: Genre) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(text = genre.name, style =
            MaterialTheme.typography.headlineSmall)
        LazyRow {
            items(genre.movies.size) { index -&gt;
                MovieCard(movie = genre.movies[index])
            }
        }
    }
}</pre> <p class="calibre3">We start with a vertical container, <code>Column</code>, that stretches across the full width of the screen. At the top of this container, we place the genre’s name in large, readable text. This makes it clear to the user which genre they’re looking at.</p>
<p class="calibre3">Right below the genre’s name, we set up a horizontal scroll area, <code>LazyRow</code>, filled with movie cards. Each card represents a movie in the genre, and users can scroll through them horizontally.</p>
<p class="calibre3">For each movie in<a id="_idIndexMarker861" class="calibre6 pcalibre1 pcalibre"/> the genre, we will <a id="_idIndexMarker862" class="calibre6 pcalibre1 pcalibre"/>create a <code>MovieCard</code> composable that will show the movie thumbnail image and the name:</p>
<pre class="source-code">
@Composable
fun MovieCard(movie: Movie) {
    Card(
        modifier = Modifier
            .padding(8.dp)
            .size(120.dp, 180.dp)
    ) {
        Image(
            painter = rememberAsyncImagePainter(model =
                movie.imageUrl),
            contentDescription = movie.title,
            contentScale = ContentScale.Crop
        )
    }
}</pre> <p class="calibre3">We start by using a <code>Card</code> composable that provides a Material Design card layout. This card is given specific dimensions and padding to ensure that it looks neat and uniform across the app. Specifically, we set each card to be <code>120dp</code> wide and <code>180dp</code> tall, with an <code>8dp</code> padding around it. This size is ideal for displaying movie posters without taking up too much screen space or looking too cramped.</p>
<p class="calibre3">Inside the card, we place an <code>Image</code> composable to show the movie’s poster. To load the image (the movie’s poster in this case) from a URL, we use <code>rememberAsyncImagePainter</code>, a handy function that handles asynchronous image loading and caching. This means our app can fetch movie posters from the internet efficiently and display them as they become available, without blocking the UI thread.</p>
<p class="calibre3">The image is set to crop to fit the card’s dimensions, ensuring that the most visually important part<a id="_idIndexMarker863" class="calibre6 pcalibre1 pcalibre"/> of the poster remains visible, even if <a id="_idIndexMarker864" class="calibre6 pcalibre1 pcalibre"/>the original image’s aspect ratio doesn’t exactly match the card’s dimensions. This cropping also maintains a consistent appearance across all movie cards.</p>
<p class="calibre3">Finally, we include <code>contentDescription</code> for the image, using the movie’s title, to make our list as accessible as possible.</p>
<p class="calibre3">With this component, we have finished our movie screen (or series screen – you just have to change the title and the content!). We can now test it using the <code>@Preview</code> annotation and providing a list of genres:</p>
<pre class="source-code">
@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    MoviesScreenUI(moviesViewState = sampleMoviesScreen())
}</pre> <p class="calibre3">Here, we are using the preview feature of Jetpack Compose to see what our list will look like. We would need to create some sample content, and that’s what the <code>sampleMoviesScreen()</code> function <a id="_idIndexMarker865" class="calibre6 pcalibre1 pcalibre"/>will do for<a id="_idIndexMarker866" class="calibre6 pcalibre1 pcalibre"/> us. For example, we could create this fake list of movies:</p>
<pre class="source-code">
fun sampleMoviesScreen(): MoviesViewState {
    return MoviesViewState(
        genres = listOf(
            Genre(
                name = "Comedy",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "The Hangover",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/b/b9/Hangoverposter09.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Superbad",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/8/8b/Superbad_Poster.png"
                    ),
                    Movie(
                        id = 3,
                        title = "Step Brothers",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/d/d9/StepbrothersMP08.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "Anchorman",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/6/64/Movie_poster_Anchorman_The_Legend_of_Ron_Burgundy.jpg"
                    )
                )
            ),
            Genre(
                name = "Mystery",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "Se7en",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/6/68/Seven_%28movie%29_poster.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Zodiac",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/3/3a/Zodiac2007Poster.jpg"
                    ),
                    Movie(
                        id = 3,
                        title = "Gone Girl",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/0/05/Gone_Girl_Poster.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "Shutter Island",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/7/76/Shutterislandposter.jpg"
                    )
                )
            ),
            Genre(
                name = "Documentary",
                movies = listOf(
                    Movie(
                        id = 1,
                        title = "March of the Penguins",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/1/19/March_of_the_penguins_poster.jpg"
                    ),
                    Movie(
                        id = 2,
                        title = "Bowling for Columbine",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/e/e7/Bowling_for_columbine.jpg"
                    ),
                    Movie(
                        id = 3,
                        title = "Blackfish",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/b/bd/BLACKFISH_Film_Poster.jpg"
                    ),
                    Movie(
                        id = 4,
                        title = "An Inconvenient Truth",
                        imageUrl = "https://upload.wikimedia.org/wikipedia/en/1/19/An_Inconvenient_Truth_Film_Poster.jpg"
                    )
                )
            )
        )</pre> <p class="calibre3">Here, we are<a id="_idIndexMarker867" class="calibre6 pcalibre1 pcalibre"/> creating fake data to make the <a id="_idIndexMarker868" class="calibre6 pcalibre1 pcalibre"/>testing of <code>MoviesScreen</code> easier. Note that the URLs provided are not the actual image URLs, so you would have to replace them for actual movie posters.</p>
<p class="calibre3">Once finished, our list screen should look like this:</p>
<div><div><img alt="Figure 7.6: Movies list screen" src="img/B19443_07_006.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.6: Movies list screen</p>
<p class="calibre3">Now that we have<a id="_idIndexMarker869" class="calibre6 pcalibre1 pcalibre"/> our list of genres and <a id="_idIndexMarker870" class="calibre6 pcalibre1 pcalibre"/>movies, let’s build the movie (or series) details page.</p>
<h1 id="_idParaDest-155" class="calibre5"><a id="_idTextAnchor156" class="calibre6 pcalibre1 pcalibre"/>Making the movie and series detail screen</h1>
<p class="calibre3">In this section, we will create<a id="_idIndexMarker871" class="calibre6 pcalibre1 pcalibre"/> the detail screen, which is the screen that will be shown when the user clicks a movie or series from the list. This screen will include information such as the plot summary, cast, year of release, and so on.</p>
<p class="calibre3">Before building<a id="_idIndexMarker872" class="calibre6 pcalibre1 pcalibre"/> the necessary composables, we need to think about the models we need. Let’s start creating them.</p>
<h2 id="_idParaDest-156" class="calibre7"><a id="_idTextAnchor157" class="calibre6 pcalibre1 pcalibre"/>Creating the detail models</h2>
<p class="calibre3">To define the models, we <a id="_idIndexMarker873" class="calibre6 pcalibre1 pcalibre"/>need to take into account the data <a id="_idIndexMarker874" class="calibre6 pcalibre1 pcalibre"/>we want to show in the detail screen. As we would like to create the same model for both movies and series, we will build an <code>ItemDetail</code> model as follows:</p>
<pre class="source-code">
data class ItemDetail(
    val type: Type,
    val title: String,
    val imageUrl: String,
    val rating: String,
    val year: String,
    val cast: List&lt;String&gt;,
    val description: String,
    val creators: List&lt;String&gt;,
    val episodes: List&lt;Episode&gt;,
    val movieUrl: String
) {
    enum class Type {
        MOVIE, SERIES
    }
}</pre> <p class="calibre3">In the case that <code>ItemDetail</code> represents a streaming series item, we also should define the <code>Episode</code> model:</p>
<pre class="source-code">
data class Episode(
    val title: String,
    val imageUrl: String,
    val duration: String,
    val episodeUrl: String
)</pre> <p class="calibre3">Now that we <a id="_idIndexMarker875" class="calibre6 pcalibre1 pcalibre"/>have <a id="_idIndexMarker876" class="calibre6 pcalibre1 pcalibre"/>our models ready, we can start building the <code>DetailScreen</code> composable.</p>
<h2 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor158" class="calibre6 pcalibre1 pcalibre"/>Building the DetailScreen</h2>
<p class="calibre3">As we have done<a id="_idIndexMarker877" class="calibre6 pcalibre1 pcalibre"/> on other occasions, we<a id="_idIndexMarker878" class="calibre6 pcalibre1 pcalibre"/> will first build the structure we want the screen to have:</p>
<pre class="source-code">
@Composable
fun ItemDetailScreen(item: ItemDetail =
createFakeItemDetail()) {
    val scrollState = rememberScrollState()
    Column(
        verticalArrangement = Arrangement.Top,
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black)
            .padding(all = 8.dp)
            .verticalScroll(scrollState)
    ) {
        ItemBannerImage(item.imageUrl)
        ItemTitleAndMetadata(item.title, item.isHD,
            item.year, item.duration)
        ItemActions(item.movieUrl)
        Text(text = item.description, color = Color.Gray)
        CastAndCreatorsList(item.cast, item.creators)
        AdditionalMovieDetails(item)
    }
}</pre> <p class="calibre3">In <code>ItemDetailScreen</code>, all the composables included are shown in a vertical <code>Column</code>, which allows us to build the UI progressively as we add new composables.</p>
<p class="calibre3">Now, let’s start building<a id="_idIndexMarker879" class="calibre6 pcalibre1 pcalibre"/> all those composables, starting<a id="_idIndexMarker880" class="calibre6 pcalibre1 pcalibre"/> with <code>ItemBannerImage</code>:</p>
<pre class="source-code">
@Composable
fun ItemBannerImage(imageUrl: String) {
    Box(modifier = Modifier.fillMaxWidth()) {
        Image(
            painter = rememberAsyncImagePainter(model =
                imageUrl),
            contentDescription = "Movie Banner",
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .height(200.dp)
                .fillMaxWidth()
        )
        IconButton(
            onClick = {
                /* TODO: Handle back action */
            },
            modifier = Modifier
                .align(Alignment.TopStart)
                .padding(top = 32.dp, start = 16.dp)
        ) {
            Icon(
                imageVector = Icons.Default.ArrowBack,
                contentDescription = "Back",
                tint = Color.White
            )
        }
    }
}</pre> <p class="calibre3">This composable displays a banner image at the top of the screen, stretching it to fill the screen’s width. It uses a <code>Box</code> composable with a <code>Modifier</code> parameter that will make sure it takes up the full width of the screen, and an <code>Image</code> composable that loads an image from a given URL with the <code>rememberAsyncImagePainter</code> function. The image is set to be 200 dp tall and automatically adjusts its width to fit the screen, ensuring that it’s properly cropped to the allocated space.</p>
<p class="calibre3">On top of the <a id="_idIndexMarker881" class="calibre6 pcalibre1 pcalibre"/>image, there’s an <code>IconButton</code> composable <a id="_idIndexMarker882" class="calibre6 pcalibre1 pcalibre"/>that’s meant to act as a <strong class="bold">Back</strong> button. We place this button in the top-left corner with some padding. Inside this button, there’s an icon shaped like an arrow pointing back, suggesting that pressing it should take you back to the previous screen. The icon is white to make sure it’s visible on top of the banner image.</p>
<p class="calibre3">Now, let’s build the <code>ItemTitleAndMetadata</code> composable:</p>
<pre class="source-code">
@Composable
fun ItemTitleAndMetadata(
    title: String,
    isHD: Boolean,
    year: String,
    duration: String
) {
    Column {
        Text(
            text = title,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold,
            color = Color.White
        )
        Row(verticalAlignment = Alignment.CenterVertically)
        {
            if (isHD) {
                Box(
                    modifier = Modifier
                        .border(BorderStroke(1.dp,
                            Color.White), shape =
                                RoundedCornerShape(4.dp))
                        .padding(horizontal = 6.dp,
                            vertical = 2.dp)
                ) {
                    Text(
                        text = "HD",
                        style =
                        MaterialTheme.typography.bodySmall,
                        color = Color.White
                    )
                }
                Spacer(modifier = Modifier.width(8.dp))
            }
            Text(
                text = year,
                style =
                    MaterialTheme.typography.bodyMedium,
                color = Color.Gray
            )
        }
        Text(
            text = duration,
            style = MaterialTheme.typography.bodyMedium,
            color = Color.Gray
        )
    }
}</pre> <p class="calibre3">We start by creating a <code>Column</code> layout because we want the details to stack vertically.</p>
<p class="calibre3">In this column, we will display the title of the item. The style we choose here is <code>bodyMedium</code> from the Material Theme, ensuring it fits nicely with the overall design of the app.</p>
<p class="calibre3">Next, we align <a id="_idIndexMarker883" class="calibre6 pcalibre1 pcalibre"/>our HD<a id="_idIndexMarker884" class="calibre6 pcalibre1 pcalibre"/> indicator and the year of release in a row, centering them vertically to ensure that they line up perfectly. We include a conditional check – only if <code>isHD</code> is <code>true</code> do we display an <strong class="bold">HD</strong> badge. We give this badge a white border and a bit of padding to make it pop against any background.</p>
<p class="calibre3">Following a small spacer, which adds some breathing room between our <strong class="bold">HD</strong> badge and the year, we place the text for the year. It’s styled to be less prominent than the title, using a medium gray color.</p>
<p class="calibre3">Finally, below the row, we will show the duration of the item. It’s also in medium gray, matching the year, and using the same <code>bodyMedium</code> style for consistency.</p>
<p class="calibre3">The next step is<a id="_idIndexMarker885" class="calibre6 pcalibre1 pcalibre"/> to<a id="_idIndexMarker886" class="calibre6 pcalibre1 pcalibre"/> create the <code>ItemActions</code> composable:</p>
<pre class="source-code">
@Composable
fun ItemActions(
    itemUrl: String
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
    ) {
        ActionButton(
            icon = Icons.Filled.PlayArrow,
            label = "Play",
            onClick = { /* TODO: Handle play action */ }
        )
        ActionButton(
            icon = Icons.Default.Add,
            label = "My List",
            onClick = {
                /* TODO: Handle add to list action */ }
        )
    }
}
@Composable
fun ActionButton(icon: ImageVector, label: String, onClick:
() -&gt; Unit) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.clickable(onClick = onClick)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = label
        )
        Text(text = label)
    }
}</pre> <p class="calibre3">We start by laying this function in a column format so that our action buttons stack vertically – this column will take up the full width available and will have padding all around for some space from the screen edges.</p>
<p class="calibre3">Inside this column, we’re placing two action buttons: one for playing the item and another for adding the item to a user’s personal list. To create these buttons, we are using the <code>ActionButton</code> composable function, which neatly bundles an icon and a label together<a id="_idIndexMarker887" class="calibre6 pcalibre1 pcalibre"/> into<a id="_idIndexMarker888" class="calibre6 pcalibre1 pcalibre"/> a clickable area. For the <strong class="bold">Play</strong> action, we are using a play arrow icon, and for adding to the list, we are using an <strong class="bold">Add</strong> icon.</p>
<p class="callout-heading">Note</p>
<p class="callout">We have left placeholders in the code where the play and add-to-list actions can be written. In the next chapter, we will implement the <strong class="bold">Play</strong> button; however, I will leave you to add the add-to-list feature yourself. To do this, one solution could be to call an endpoint when the <strong class="bold">Add To List</strong> button is pressed, so the backend can store it in the user list (of course, imagining that we have a backend that handles this feature). You can refer to <a href="B19443_04_split_000.xhtml#_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 4</em></a> where we connected Packtagram with <strong class="source-inline1">NewsFeed</strong> to understand how this can be done.</p>
<p class="calibre3">Now, let’s continue<a id="_idIndexMarker889" class="calibre6 pcalibre1 pcalibre"/> with the next<a id="_idIndexMarker890" class="calibre6 pcalibre1 pcalibre"/> composable, <code>CastAndCreatorsList</code>:</p>
<pre class="source-code">
@Composable
fun CastAndCreatorsList(cast: List&lt;String&gt;, creators:
List&lt;String&gt;) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            text = "Cast",
            style = MaterialTheme.typography.titleSmall,
            color = Color.White,
            modifier = Modifier.padding(horizontal = 16.dp,
                vertical = 8.dp)
        )
        LazyRow(
            contentPadding = PaddingValues(horizontal =
                16.dp),
            horizontalArrangement =
                Arrangement.spacedBy(8.dp)
        ) {
            items(cast) { actorName -&gt;
                Text(
                    text = actorName,
                    style =
                       MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    modifier = Modifier.background(
                        color = Color.DarkGray,
                        shape = RoundedCornerShape(4.dp)
                    ).padding(horizontal = 8.dp,
                        vertical = 4.dp)
                )
            }
        }
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Created by",
            style = MaterialTheme.typography.titleMedium,
            color = Color.White,
            modifier = Modifier.padding(horizontal = 16.dp,
                vertical = 8.dp)
        )
        LazyRow(
            contentPadding = PaddingValues(horizontal =
                16.dp),
            horizontalArrangement =
                Arrangement.spacedBy(8.dp)
        ) {
            items(creators) { creatorName -&gt;
                Text(
                    text = creatorName,
                    style =
                       MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    modifier = Modifier.background(
                        color = Color.DarkGray,
                        shape = RoundedCornerShape(4.dp)
                    ).padding(horizontal = 8.dp,
                        vertical = 4.dp)
                )
            }
        }
    }
}</pre> <p class="calibre3">We start with <code>Column</code>, which is going to stack our elements vertically. We want this to take up the full width available, so we use <code>Modifier.fillMaxWidth()</code>.</p>
<p class="calibre3">Then, we put a header labeled <code>Cast</code> at the top. We style this text to make it stand out using <code>MaterialTheme.typography.titleSmall</code> and set the color to white. To give it some breathing room, we add padding around it.</p>
<p class="calibre3">Next, we<a id="_idIndexMarker891" class="calibre6 pcalibre1 pcalibre"/> introduce <a id="_idIndexMarker892" class="calibre6 pcalibre1 pcalibre"/>a <code>LazyRow</code> composable to display each actor’s name from the cast list using a <code>Text</code> composable. We style the names to stand out against the background by applying <code>MaterialTheme.typography.bodyMedium</code> and setting the text color to white. To further distinguish each name, we give them a tag-like appearance with a dark gray background and rounded corners using <code>RoundedCornerShape(4.dp)</code>. Additionally, we add padding around the text to ensure that it doesn’t touch the edges of its gray backdrop, enhancing readability and visual appeal.</p>
<p class="calibre3">Then, we separate the cast from the creators with a <code>Spacer</code> composable. This just adds a bit of vertical space between the two sections, so they don’t run into each other.</p>
<p class="calibre3">For the creators, the setup is pretty much the same. We have a header labeled <code>"Created by"</code>, styled similarly to the <code>Cast</code> header but a bit larger using <code>titleMedium</code>. Then, we list out the creators in another <code>LazyRow</code>, giving them the same styled text tags as the cast.</p>
<p class="calibre3">Now, it’s time to <a id="_idIndexMarker893" class="calibre6 pcalibre1 pcalibre"/>work on the last composable of the <a id="_idIndexMarker894" class="calibre6 pcalibre1 pcalibre"/>screen, <code>AdditionalMovieDetails</code>:</p>
<pre class="source-code">
@Composable
fun AdditionalMovieDetails(item: ItemDetail) {
    Column(modifier = Modifier.fillMaxWidth()) {
        // Assuming item.episodes is a list of episodes
           with their details
        item.episodes.forEach { episode -&gt;
            EpisodeItem(episode = episode)
        }
    }
}
@Composable
fun EpisodeItem(episode: Episode) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable {
                /* TODO: Handle episode playback */ }
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Episode image
        Image(
            painter = rememberAsyncImagePainter(model =
                episode.imageUrl),
            contentDescription = "Episode Thumbnail",
            modifier = Modifier
                .size(width = 120.dp, height = 68.dp)
                .clip(RoundedCornerShape(4.dp)),
            contentScale = ContentScale.Crop
        )
        // Space between image and text details
        Spacer(modifier = Modifier.width(16.dp))
        // Episode title and duration
        Column {
            Text(
                text = episode.title,
                style =
                    MaterialTheme.typography.bodyMedium,
                color = Color.White
            )
            Text(
                text = "Duration: ${episode.duration}",
                style = MaterialTheme.typography.bodySmall,
                color = Color.Gray
            )
        }
    }
    Divider(color = Color.Gray, thickness = 0.5.dp)
}</pre> <p class="calibre3">In <code>AdditionalMovieDetails</code>, we’re setting up a column that expands to the maximum width of its parent container. Inside this column, we’re going through each episode in the <code>item.episodes</code> list and, for each one, we’re calling the <code>EpisodeItem</code> composable to render the details of that episode.</p>
<p class="calibre3">Now, moving on to the <code>EpisodeItem</code> composable function, this is where we lay out each episode’s information. We create a row that stretches across the full width, which can be tapped – this is where we will want to add the code for what happens when someone clicks to play the episode. We are also adding some padding for spacing.</p>
<p class="calibre3">Within this row, the first thing is the episode image. We use <code>rememberAsyncImagePainter</code> to load the image from the episode URL, and we make sure it’s <a id="_idIndexMarker895" class="calibre6 pcalibre1 pcalibre"/>nicely<a id="_idIndexMarker896" class="calibre6 pcalibre1 pcalibre"/> rounded and cropped to fit a specific size. This image will act as a thumbnail for the episode.</p>
<p class="calibre3">Next to the image, we add a spacer to give some breathing room before the text details of the episode. This is followed by a column that holds two pieces of text: the episode’s title, which stands out more, and below it, the duration of the episode in a smaller and less prominent color.</p>
<p class="calibre3">Lastly, after each episode item, we draw a thin gray line, a divider, to visually separate the episodes from one another. It’s a common design pattern that helps users distinguish between different pieces of content.</p>
<p class="calibre3">And with this composable, we have finished the detail screen and this chapter. Our detail screen should look like this:</p>
<div><div><img alt="Figure 7.7: Detail screen" src="img/B19443_07_007.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.7: Detail screen</p>
<p class="calibre3">In the <a id="_idIndexMarker897" class="calibre6 pcalibre1 pcalibre"/>next chapter, we<a id="_idIndexMarker898" class="calibre6 pcalibre1 pcalibre"/> will bring those movies and series to life by implementing the playback.</p>
<h1 id="_idParaDest-158" class="calibre5"><a id="_idTextAnchor159" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">As we close this chapter, we have laid a solid foundation for Packtflix, our video streaming app. We began by conceptualizing the project’s structure and modules, setting the stage for an organized and scalable app. This structure is pivotal for our journey ahead, where complexity will grow as we add more features.</p>
<p class="calibre3">We then created the login screen, before venturing into the world of user authentication. Through the integration of OAuth2, we’ve equipped Packtflix with a secure authentication system that respects user privacy and guards against unauthorized access, ensuring a trustworthy environment for our users to enjoy their favorite content.</p>
<p class="calibre3">Our progress continued as we crafted a UI to display a curated list of movies, leveraging the power of Jetpack Compose to create a dynamic and engaging experience. This attention to detail in presenting content is what will turn first-time users into loyal fans of Packtflix.</p>
<p class="calibre3">In the next chapter, we will learn more about how to implement the playback, so our users can not only see the movies and series information but also play their videos.</p>
</div>
</body></html>