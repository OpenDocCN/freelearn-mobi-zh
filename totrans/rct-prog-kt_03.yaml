- en: Observables, Observers, and Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Observables and subscribers are at the base of reactive programming. We can
    say that they are the building blocks of reactive programming. In the previous
    two chapters, you already got a glimpse of `Observables` and `subject`. We observed
    on data with `observable`/`subject` instances; but that''s not all we want; instead,
    we want to get all the actions and data changes reactively into the `observable`
    instances, making the application completely reactive. Also, while reading the
    previous chapters, you may have wondered how exactly does it operate? In this
    chapter, let''s have a foundation of the pillars of reactive programming—`Observables`,
    `Observers`, and `subjects`:'
  prefs: []
  type: TYPE_NORMAL
- en: We will look into details of transforming various data sources to `observable`
    instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn about various types of `Observables`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `Observer` instances and subscriptions, and, lastly, `subjects` and
    their various implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also learn about various factory methods of `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot to understand in this chapter, so let's start with understanding
    `Observables` first.
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed earlier, in reactive programming, `Observable` has an underlying
    computation that produces values that can be consumed by a consumer (`Observer`).
    The most important thing here is that the consumer (`Observer`) doesn''t pull
    values here; rather, `Observable` pushes the value to the consumer. So, we may
    say, an `Observable` is a push-based, composable iterator that emits its items
    through a series of operators to the final `Observer`, which finally consumes
    the items. Let''s now break things sequentially to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observer` subscribes to `Observable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable` starts emitting items that it has in it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer` reacts to whatever item `Observable` emits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's delve into how an `Observable` works through its events/methods, namely,
    `onNext`, `onComplete`, and `onError`.
  prefs: []
  type: TYPE_NORMAL
- en: How Observable works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we stated earlier, an `Observable` has three most important events/methods;
    let''s discuss them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext`: `Observable` passes all items one by one to this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: When all items have gone through the `onNext` method, `Observable`
    calls the `onComplete` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error, if defined. Note that both `onError` and `onComplete`
    are terminal events, and if `onError` is called, then it would never call `onComplete`
    and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing to note here, the item in `Observable` that we are talking about can
    be anything; it is defined as `Observable<T>`, where `T` can be any class; even
    an `array`/`list` can be assigned as an `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/919f75a0-7206-483e-aaae-2f3cb15ccda7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at this code example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared the `observer` instance of `Any` datatype
    on comment `(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are taking benefit of the `Any` datatype. In Kotlin, every class is
    a child class of `Any`. Also, in Kotlin, everything is class and object; there
    is no separate primitive datatype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `observer` interface has four methods declared in it. The `onComplete()`
    method at comment `2` gets called when `Observable` is finished with all its items
    without any error. On comment `3`, we defined the `onNext(item: Any)` function,
    which will be called by `observable` for each item it has to emit. In that method,
    we will print the data to the console. On comment `4`, we defined the `onError(e:
    Throwable)` method, which will be called in case any error is faced by `Observable`.
    On comment `5`, the `onSubscribe(d: Disposable)` method will get called whenever
    `Observer` subscribes to `Observable`. On comment `6`, we will create `Observable`
    from a `list` (`val observable`) and subscribe to `observable` with `observer`
    on comment `7`. On comment `8`, we will create an observable (`val observableOnList`)
    again, this it holds lists as items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a506ff43-49cd-4d87-8cae-33bd129186dc.png)'
  prefs: []
  type: TYPE_IMG
- en: So, as you can see in the output, for the first subscription (comment `7`),
    when we subscribe to `Observable`, it calls the `onSubscribe` method, and then
    `Observable` starts emitting items as `Observer` starts receiving them on the
    `onNext` method and prints them. When all items are emitted from `Observable`,
    it calls the `onComplete` method to denote that all items have been successfully
    emitted. Same with the second one, except that, here, each item is a list.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we gained some basis in `Observables`, let's learn various ways to create `Observable`—factory
    methods for `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observable.create method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create your own `Observable` with the `Observable.create` method at
    any time. This method takes an instance of the `ObservableEmitter<T>` interface
    as a source to observe on. So, let''s consider this following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we created an instance of the `Observer` interface as the previous example.
    I will not elaborate on `observer`, as we have already seen an overview in the
    previous example, and we will see it in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `1`, we created `Observable` with the `Observable.create` method;
    we emitted four `string` from `Observable` with the help of the `onNext` method,
    and then notified it is complete with the `onComplete` method.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `2`, we did almost the same, except here instead of calling `onComplete`,
    we called `onError` with a custom `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d101c509-0137-4601-8a3e-8603ef587d0c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Observable.create` method is useful, especially when you are working with
    a custom data structure and want to have control over what values are getting
    emitted. You can also emit values to `Observer` from a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Observable` contract ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    states that `Observable` must issue notifications to `observers` serially (not
    in parallel). They may issue these notifications from different threads, but there
    must be a formal happens—before relationship between the notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observable.from methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Observable.from` methods are comparatively simpler than the `Observable.create`
    method. You can create `Observable` instances from nearly every Kotlin structure
    with the help of `from` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in RxKotlin 1, you will have `Observale.from` as a method; however,
    from RxKotlin 2.0 (as with RxJava2.0), operator overloads have been renamed with
    a postfix, such as `fromArray`, `fromIterable`, `fromFuture`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On comment `1`, I used the `Observable.fromIterable` method to create `Observable`
    from an `Iterable` instance (here, `List`). On comment `2`, I called the `Observable.fromCallable`
    method to create `Observable` from a `Callable` instance, and same for comment
    `3`, where I called the `Observable.fromFuture` method to derive `Observable`
    from a `Future` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5892068-ffc1-4437-afeb-5ac26c1c8fb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the toObservable extension function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the extension functions of Kotlin, you can turn any `Iterable` instance,
    such as `List`, to `Observable` without much effort; we have already used this
    method in [Chapter 1](0c50d487-2455-4385-b1c6-822eae0591bf.xhtml), *A Short Introduction
    to Reactive Programming*, however, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/355f9436-754f-4a24-bd20-0e71f7c5ac62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, aren''t you curious to look into the `toObservable` method? Let''s do it.
    You can find this method inside the `observable.kt` file provided with the `RxKotlin`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, it basically uses the `Observable.from` method internally; thanks again
    to extension functions of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observable.just method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting factory method is `Observable.just`; this method creates
    `Observable` and adds the parameters passed to it as the only items of the `Observable`.
    Note that if you pass an `Iterable` instance to `Observable.just` as a single
    parameter, it will take the entire `list` as a single item, unlike `Observable.from`,
    where it will create items of `Observable` from each item in `Iterable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what happens when you call `Observable.just`:'
  prefs: []
  type: TYPE_NORMAL
- en: You call `Observable.just` with parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.just` will create `Observable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will emit each of its parameters as the `onNext` notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all parameters are emitted successfully, it will emit the `onComplete`
    notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at this code example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97067b1c-8d93-46a3-9404-c19a85540637.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the output, lists and maps are also treated as a single item,
    but look at comment `1` in the code where I passed three strings as parameters
    of the `Observable.just` method. `Observable.just` took each of the parameters
    as a separate item and emitted them accordingly (see the output).
  prefs: []
  type: TYPE_NORMAL
- en: Other Observable factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving forward with `Observer`, subscribing, unsubscribing, and `Subjects`,
    let's try our hands on a few other factory methods of `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s look at this code first, and then we will try to learn it line by
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On comment `(1)`, we created `Observable` with the `Observable.range()` factory
    method. This method creates an `Observable` and emits integers with the supplied
    `start` parameter until it emits a number of integers as per the `count` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we created `Observable` with the `Observable.empty()` method.
    This method creates `Observable` and emits `onComplete()` right away, without
    emitting any items with `onNext()`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(3)` and comment `(4)`, we used two interesting `Observable` factory
    methods. The method on comment `(3)`, `Observable.interval()`, emits numbers sequentially
    starting from `0`, after each specified interval. It will continue emitting until
    you unsubscribe and until the program runs. Whereas, the method on comment `(4)`,
    `Observable.timer()`, will emit only once with `0` after the specified time elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output if you are curious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d2d28f9-914d-4f1b-a1d8-ef3c70ee112e.png)'
  prefs: []
  type: TYPE_IMG
- en: Subscribers - the Observer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Subscriber` from RxKotlin 1.x,  essentially became an `Observer` in RxKotlin
    2.x. There is an `Observer` interface in RxKotlin 1.x, but `Subscriber` is what
    you pass to the `subscribe()` method, and it implements `Observer`. However, In
    RxJava 2.x, `Subscriber` only exists when talking about `Flowables`, which we
    will cover in [Chapter 4](44e60d80-46e4-4b97-a0ad-4047a5d7bfb7.xhtml), *Introduction
    to Backpressure and Flowables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous examples in this chapter, `Observer` is an interface
    with four methods in it—`onNext(item:T)`, `onError(error:Throwable)`, `onComplete()`,
    and `onSubscribe(d:Disposable)`. As stated earlier, when we connect `Observable`
    to `Observer`, it looks for these four methods in `Observer` and calls them. So,
    the following is a short description of the four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext`: `Observable` calls this method of `Observer` to pass each of the
    items one by one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: When `Observable` wants to denote, it''s done with passing items
    to the `onNext` method, and it calls the `onComplete` method of `Observer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error if defined in the `Observer`, otherwise, it throws the
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe`: This method is called whenever a new `Observable` subscribes
    to the `Observer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing and disposing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have `Observable` (the thing that should be observed upon) and we have `Observer`
    (that should observe); now what? How to connect them? `Observable` and `Observer`
    are like an input device (be it keyboard or mouse) and the computer, we need something
    to connect them (even wireless input devices have some connectivity channels,
    be it Bluetooth or Wi-Fi).
  prefs: []
  type: TYPE_NORMAL
- en: The `subscribe` operator serves the purpose of the media by connecting an `Observable`
    to `Observer`. We can pass one to three methods (`onNext`, `onComplete`, `onError`)
    to the `subscribe` operator, or we can pass an instance of the `Observer` interface
    to the `subscribe` operator to get the `Observable` connected with an `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at the following example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created `Observable` instance (on comment `1`) and
    used it twice with different overload `subscribe` operators. On comment `2`, we
    have passed three methods as arguments to the `subscribe` method. The first parameter
    is the `onNext` method, the second one is the `onError` method, and last, `onComplete`.
    On comment `2`, we have passed an instance of the `Observer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output can be easily predicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14269583-2a72-4485-acb0-aa6c06611a2b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we have got the concepts of subscribing, and we can do it now. What if you
    want to stop the emissions after some period of subscription? There must be a
    way, right? So let's inspect this.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `onSubscribe` method of `Observer`? There was a parameter on that
    method that we have not talked about yet. While you `subscribe`, if you pass the
    methods instead of the `Observer` instance, then the `subscribe` operator will
    return an instance of `Disposable`, or if you use an instance of `Observer`, then
    you will get the instance of `Disposable` in the parameter of the `onSubscribe`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the instance of the `Disposable` interface to stop emissions at
    any given time. Let''s take a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I hope you remember the `Observable.interval` factory method, from just few
    pages ago in this chapter. This method takes two parameters describing the interval
    period and time unit, then, it prints integers sequentially, starting from `0`.
    `Observable` created with interval never completes and never stops until you stop
    them or the program stops execution. I thought it will be the perfect fit in this
    scenario, as here we want to stop the `Observable` midway.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this example on comment `1`, we created an `Observable` with the `Observable.interval`
    factory method that will emit an integer after each `100` millisecond interval.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `2`, I have declared a `lateinit var disposable` of type `Disposable`
    (`lateinit` means the variable will get initialized at a later point of time).
    On comment `3`, inside the `onSubscribe` method, we will assign the received parameter
    value to the `disposable` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We intend to stop the execution after the sequence reaches `10`, that is, after
    `10` is emitted, the emission should be stopped immediately. To achieve that,
    we placed a check inside the `onNext` method, where we are checking if the value
    of the emitted item is equal to or greater than `10`, and if the emission is not
    already stopped (disposed), then we will dispose the emission (comment `5`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that no integer got emitted after the `disposable.dispose()`
    method was called, although the execution waited 500 milliseconds more (100*10=1000
    milliseconds to print sequence until `10`, and we called the `delay` method with
    1500, thus 500 milliseconds after emitting `10`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are curious to know the `Disposable` interface, then the following is
    the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It has one property that denotes if the emission is already notified to stop
    (`disposed`) and a method to notify the emission to stop (`dispose`).
  prefs: []
  type: TYPE_NORMAL
- en: Hot and Cold Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, as we have a grip on the basic concepts of `Observables` and `Observers`
    by now, let's move to something more interesting and advanced. The `Observables`
    that we are talking all about can be categorized into two categories based on
    their behavior. As the heading suggests, the two categories are `Hot Obervables`
    and `Cold Observable`. I can bet that, by now, you are craving to know more about
    `Hot` and `Cold Observables`, aren't you? So, let's dive into it.
  prefs: []
  type: TYPE_NORMAL
- en: Cold Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a careful look at all the previous examples. In all the examples, if you
    subscribe to the same `Observable` multiple times, you will get the emissions
    from the beginning for all the subscriptions. Don''t believe it? Take a look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae275fc1-b456-4a0e-9530-2db959bff3fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The program is quite straightforward. Declared an `Observable` on comment `1`,
    subscribed to the `Observable` twice—on comment `2` and `3`. Now, look at the
    output. For both the subscribe calls, you got the exact same emission from the
    first one to the last one.
  prefs: []
  type: TYPE_NORMAL
- en: Those `Observables`, which have this particular behavior, that is, emitting
    items from the beginning for each subscription, are called `Cold Observable`.
    To be more specific, `Cold Observables` start running upon subscriptions and `Cold
    Observable` starts pushing items after `subscribe` gets called, and pushes the
    same sequence of items on each subscription.
  prefs: []
  type: TYPE_NORMAL
- en: All the `Observable` factory methods we have used up until this chapter return
    `Cold Observables`. `Cold Observables` resemble data. When we are working with
    data, for example, say, while working with SQLite or Room database in Android,
    we rely more on `Cold Observables` than `Hot Observables`.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Cold Observables` are passive, they don''t emit anything until subscribe is
    called. `Hot Observables` are contrary to `Cold Observables`; it doesn''t need
    subscriptions to start emission. While you can compare `Cold Observables` to CD/DVD
    recordings, `Hot Observables` are like TV channels—they continue broadcasting
    (emitting) their content, irrespective of whether anyone is watching (Observing)
    it or not.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hot Observables` resemble events more than data. The events may carry data
    with them, but there is a time-sensitive component where `Observers` that subscribed
    lately can miss out previously emitted data. They are specifically useful for
    UI events while working with Android/JavaFX/Swing. They are also very useful in
    resembling server requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the ConnectableObservable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great example of `Hot Observables` is `ConnectableObservable`. It is one of
    the most helpful forms of `Hot Observables` as well. It can turn any `Observable`,
    even a `Cold Observable`, into a `Hot Observable`. It doesn't start emitting on
    the `subscribe` call; instead, it gets activated after you call the `connect`
    method. You have to make the `subscribe` calls before calling `connect`; any `subscribe`
    calls after calling connect will miss the emissions fired previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of `ConnectableObservable` is for `Observables` with multiple
    subscriptions to connect all subscriptions of an `Observable` together so that
    they can react to a single push; contrary to `Cold Observables` that repeats operations
    for doing the push, and pushes separately for each subscription, thus repeating
    the cycle. `ConnectableObservable` connects all `subscriptions` (`Observers`)
    called before the `connect` method and relays a single push to all `Observers`,
    `Observers` then react to/process that push.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created `Observable` with the `toObservable()`
    method, then, on comment `1`, we used the `publish` operator to convert `Cold
    Observable` into `ConnectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `2`, we subscribed to `connectableObservable`. On comment `3`, we
    used the `map` operator to reverse `String`, and, on comment `4`, we subscribed
    to the mapped `connectableObservable`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `5`, we called `connect` method, and emissions got started to both
    `Observers`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used the `map` operator in this example on comment `3`. We will
    discuss the `map` operator in detail in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml), *Asynchronous
    Data Operators and Transformations*. However, here is the definition, if you are
    curious. The `map` operator applies a function of your choosing to each item emitted
    by the source `Observable`, and returns an `Observable` that emits the results
    of these function applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e4d31f4-e707-4f13-9e93-0f2e7ee48dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, as the output suggests, each emission goes to each `Observer` simultaneously,
    and they are processing data in an interleaved fashion.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism of emitting from `Observable` once and then relaying the emission
    to all `Subscriptions`/`Observers` is known as **multicasting**.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the `subscribe` call on comment `6`, after `connect`, has not
    received any emissions, as `ConnectableObservable` is hot, and any new subscriptions
    occurred after connect will miss out the emissions fired previously (between the
    call of the `connect` method and the new subscription, remember that, within a
    few milliseconds, computers can do a lot of tasks); in this case, it missed all
    the emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code is another example to make you understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example is almost the same as the previous one, just a few tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used the `Observable.interval` method to create `Observable`; the benefit
    is that, as it takes an interval before each emission, it will give some room
    to the subscription after connect to get a few emissions.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `1`, we converted `Cold Observable` to `ConnectableObservable`, as
    with the previous one, and did two subscriptions and then connected, as in the
    previous example (comment `2`, `3`, `4`).
  prefs: []
  type: TYPE_NORMAL
- en: We called delay right after connect on comment `5`, then subscribed again on
    comment `6`, and again a delay on comment `7` to allow the `3`^(rd) subscription
    to print some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output will allow us to understand better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd8f60d-15e5-4168-b18b-6d90822b6a24.png)'
  prefs: []
  type: TYPE_IMG
- en: Go through the output carefully to note that the `3`^(rd) subscription received
    emissions from sequence `5`, and missed all previous ones (there were `5` emissions
    before the `3rd subscription`—500 millisecond delay/100 millisecond interval).
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another great way to implement `Hot Observables` is `Subject`. Basically, it
    is a combination of `Observable` and `Observer`, as it has many common behaviors
    to both `Observables` and `Observers`. Like `Hot Observables`, it maintains an
    internal `Observer` `list` and relays a single push to every `Observer` subscribed
    to it at the time of emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at what `Subject` has to offer us. And why is it called
    a combination of `Observables` and `Observers`? Please refer to the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: It has all the operators that `Observable` should have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like `Observer`, it can listen to any value emitted to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `Subject` is completed/errored/unsubscribed, it cannot be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most interesting point is that it passes values through itself. As an explanation,
    if you pass a value with `onNext` to a `Subject` (`Observer`) side, it will come
    out of the `Observable` side of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, `Subject` is a combination of `Observable` and `Observer`. You have already
    seen the use of `Subject` in the previous chapters, but, to make things clearer,
    let''s take a new example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the output first, and then we will explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c44c2ba-d572-4d82-8192-fb39bc96079f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's understand the code. In this program, we have used the good old `Observable.interval`
    method. So, on comment `1`, we again created an instance of `Observable` with
    `Observable.interval`, with a 100 millisecond interval.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `2`, we created `Subject` with `PublishSubject.create()`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of `Subject` available. `PublishSubject` is one of them.
    `PublishSubject` emits to an `observer` only those items that are emitted by the
    `Observable` sources subsequent to the time of the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss in detail about the various types of `Subject` in the next section
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `3`, we used the `Subject` instance just like `Observer`, to subscribe
    to the emissions by the `Observable` instance. On comment `4`, we used the `Subject`
    instance like an `Observable` and subscribed with lambda to listen to the emissions
    by the `Subject` instance.
  prefs: []
  type: TYPE_NORMAL
- en: You probably got used to it with the code in comment `5`; if not, then we used
    it to make the program wait for `1100` milliseconds so that we can see the outputs
    made by the interval program. You can think of the `delay` method as similar to
    the `sleep` method in Java, the only difference here is that you must use `delay`
    inside a `Coroutine context`, so, in order to use `delay` method, you have to
    specify and start a `Coroutine context`; this is not quite possible always. The
    `runBlocking` method is there to help you in that scenario; it mocks a `Coroutine
    context` inside the calling thread while blocking that thread until `runBlocking`
    completes executing all its code.
  prefs: []
  type: TYPE_NORMAL
- en: The `Subject` instance listens to the emissions by the `Observable` instance
    and then broadcasts those emissions to its `Observers`, very likely, to a TV Channel
    broadcasting a Film (from a CD/DVD recording).
  prefs: []
  type: TYPE_NORMAL
- en: 'You are probably thinking, what is the benefit of that? When I can directly
    `subscribe` and `Observer` to `Observable`, why should I use `PublishSubject`
    in between? To find the answers, let''s modify this code a little bit in a way
    that will help us understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code is almost the same until comment `5` (except on `Subscribe` on
    comment `3`, where I prepended `Subscription` `1` to the `String` output).
  prefs: []
  type: TYPE_NORMAL
- en: On comment `6`, we again subscribed to `subject`. As we are subscribing after
    `1100` milliseconds, it should receive emissions after the first 11 emissions.
    On comment `7`, we are again making the program wait by `1100` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the output, it is printing the second subscription from the `12`^(th) emission
    (sequence `11`). So, `Subject` doesn't replay the actions such as `Cold Observables`,
    it just relays the emission to all `Observers`, turning a `Cold Observable` into `Hot
    Oberservale` one.
  prefs: []
  type: TYPE_NORMAL
- en: Varieties of Subject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, there are a lot of varieties available for `Subject`s.
    As we have gained some grip in `Subject`, let''s now dive into varieties of `Subject`
    to understand it better. So, these are some of the most useful and important varieties
    of `Subject`, which we will discuss here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublishSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding AsyncSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AsyncSubject` only emits the last value of the source observable (`Observable`
    it listens on), and the last emission only. To say things more clearly, `AsyncSubject`
    will emit the last value it got, and will emit it only one time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a marble diagram for `AsyncSubject`, which has been taken from ReactiveX
    documentation ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beb3bc54-c9d7-4e3c-b25c-a102fcb273b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created an example with `Observable.just`, with `4` integers
    (on comment `1`). Then, on comment `2`, we created an `AsyncSubject` example.
    After that, on comment `3` and `4`, like the previous example, we subscribed to
    the `observable instance` with `subject` and then subscribed to the `Subject`
    instance with lambda; only this time, we passed all the three methods—`onNext`,
    `onError`, and `onComplete`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `6`, we called `onComplete`.
  prefs: []
  type: TYPE_NORMAL
- en: As the output suggests, `Subject` only emitted the last value it got, that is,
    `4`.
  prefs: []
  type: TYPE_NORMAL
- en: On `Subject` instances, you can pass values directly with the `onNext` method,
    without subscribing to any `Observable`. Recall the examples in the previous chapters
    where we used `Subject` (`PublishSubject`); there, we only used `onNext` to pass
    the values. You can subscribe to another `Observable` with `Subject`, or pass
    values with `onNext`. Basically, when you subscribe to `Observable` with `Subject`, `Subject`
    calls its `onNext` internally upon `Observable`'s value emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have doubts? Let''s tweak the code a little. Instead of subscribing to an `Observable`,
    we will call `onNext` only to pass values, and will have another subscription.
    Here is the code, to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05ff90e1-c0fa-442e-9e9a-3daf83c4277d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we passed all values via `onNext`; it only emitted the last value it got
    (`5`) to both of the subscriptions. Look carefully, the `1`^(st) subscription
    was before passing the last value. As `ConnectableObservable` starts emitting
    on call of `connect`, `AsyncSubject` emits its only value on call of `onComplete`
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as the outputs suggest, `AsyncSubject` doesn't in an interleave manner,
    that is, it will replay its action multiple times to emit the value to multiple
    `Observers`, although it is only one value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PublishSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PublishSubject` emits all subsequent values that it got at the time of subscription,
    whether it got the value via the `onNext` method or through another subscription.
    We have already seen the application of `PublishSubject`, and it is the most commonly
    used `Subject` variant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a graphical representation of `PublishSubject` which has been taken
    from ReactiveX documentation ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0346f006-649d-4f52-a166-7be1b02c12f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding BehaviorSubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we combine `AsyncSubject` and `PublishSubject`? Or mix the benefits
    of both? `BehaviorSubject` emits the last item it got before the subscription
    and all the subsequent items at the time of subscription while working with multicasting,
    that is, it keeps an internal `list` of `Observers` and relays the same emit to
    all of its `Observers` without replaying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the graphical representation which has been taken from ReactiveX documentation
    ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f45c48ad-aaa8-4225-8572-7e9ef9f358fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s modify the last example with `BehaviorSubject` and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I took the last example where we worked with `AsyncSubject`, and modified
    it with `BehaviorSubject`. So, let''s see the output and understand `BehaviorSubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While the `1`^(st) subscription gets `4` and `5`; `4` was emitted before its
    subscription and `5` after. For the `2`^(nd) subscription, it only got `5`, which
    was emitted before its subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ReplaySubject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is more like `Cold Observable`; it will replay all the items it got, regardless
    of when `Observer` subscribes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7550a0a-2d57-4c56-beca-ce76ce213749.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image credit: [http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous program with `ReplaySubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It emitted all of the items for both the subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about `Observables` and `Observers` and how to use
    them. We worked with several examples to get our grips strong on them. We learned
    that there are two categories of `Observables`—`Hot Observables` and `Cold Observables`.
    We also learned about several `Subject` and its variant. Several `Subject` are
    basically a combination of `Observables` and many `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: While `Observables` provide us with great flexibilities and power, it too has
    some disadvantages, such as backpressure. Curious about it? Want to know more
    about the disadvantages of `Observables` and how to overcome them? Rush to the
    fourth chapter then.
  prefs: []
  type: TYPE_NORMAL
