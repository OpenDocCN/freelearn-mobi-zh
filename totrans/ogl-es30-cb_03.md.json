["```java\n    #version 300 es\n    layout(location = 0) in vec4 VertexPosition; \n    layout(location = 1) in vec4 VertexColor; \n    out vec4 Color;\n    uniform mat4 MODELVIEWPROJECTIONMATRIX;\n\n    // Function with two input and one output storage qualifier\n    void calculatePosition(in mat4 MVP, in vec4 vp, out vec4 position){\n       position = MVP * vp;\n    }\n\n    void main() \n    {\n       vec4 position;\n       calculatePosition(MODELVIEWPROJECTIONMATRIX,\n                             VertexPosition, position);\n       gl_Position  = position;\n       Color        = VertexColor;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec4 Color; //in variable receive from shader\n    float blendFactor = 0.8;\n    layout(location = 0) out vec4 outColor; \n    // Function with input argument and output as return type\n    vec4 addBlend( in vec4 colorOpaque ) \n    {\n        return vec4(colorOpaque.x, colorOpaque.y, \n    colorOpaque.z, blendFactor);\n    }\n\n    void main() {\n        outColor = addBlend( Color );\n    }\n    ```", "```java\n    #define VERTEX_LOCATION 0\n    #define COLOR_LOCATION 1\n    ```", "```java\n    glGenBuffers(1, &vId); // Create VBO and bind data\n    glGenBuffers(1, &iId); // Create IBO and bind data\n\n    // Enable the attribute locations\n    glEnableVertexAttribArray(VERTEX_LOCATION);\n    glEnableVertexAttribArray(COLOR_LOCATION);\n    ```", "```java\n    void Cube::RenderCube() {\n       . . . . . \n       glBindBuffer( GL_ARRAY_BUFFER, vId );\n       glVertexAttribPointer(VERTEX_LOCATION, 3, \n       GL_FLOAT, GL_FALSE, 0, (void*)0);\n       glVertexAttribPointer(COLOR_LOCATION, 3, GL_FLOAT, \n       GL_FALSE, 0, (void*)size);\n       glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );\n       glDrawElements(GL_TRIANGLES, 36, \n       GL_UNSIGNED_SHORT, (void*)0);\n       . . . . . \n    }\n    ```", "```java\nvoid glBindAttribLocation( GLuint program, GLuint index, const GLchar *name );\n```", "```java\nuniform <block name>{\n[Type] <variable name 1>;\n[Type] <variable name 2>;\n. . .\n};\n```", "```java\nuniform mat4 ModelMatrix;\nuniform mat4 ViewMatrix;\nuniform mat4 ProjectionMatrix;\n```", "```java\nuniform Transformation{\n    mat4 ModelMatrix;\n    mat4 ViewMatrix;\n    mat4 ProjectionMatrix;\n};\n```", "```java\n    #version 300 es\n\n    layout(location = 0) in vec4 VertexPosition;\n    layout(location = 1) in vec4 VertexColor;\n\n    out vec4 Color;\n    // Uniform Block Declaration\n    uniform Transformation{\n        mat4 ModelMatrix;\n        mat4 ViewMatrix;\n        mat4 ProjectionMatrix;\n    };\n\n    void main()\n    {\n        gl_Position = ProjectionMatrix * ViewMatrix * \n                      ModelMatrix * VertexPosition;\n        Color = VertexColor;\n    }\n    ```", "```java\n    #version 300 es\n    precision mediump float;\n    in vec4 Color;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n      outColor = vec4(Color.x, Color.y, Color.z, 1.0);\n    }\n    ```", "```java\n    void Cube::CreateUniformBufferObject()\n    {\n        // Get the index of the uniform block\n        char blockIdx = glGetUniformBlockIndex\n        (program->ProgramID, \"Transformation\");\n\n        // Query uniform block size\n        GLint blockSize;\n        glGetActiveUniformBlockiv(program->ProgramID, blockIdx,\n        GL_UNIFORM_BLOCK_DATA_SIZE, &blockSize);\n\n        // Bind the block index to BindPoint\n        GLint bindingPoint = 0;\n        glUniformBlockBinding(program->ProgramID, \n        blockIdx, bindingPoint);\n\n        // Create Uniform Buffer Object(UBO) Handle\n        glGenBuffers(1, &UBO);\n        glBindBuffer(GL_UNIFORM_BUFFER, UBO);\n        glBufferData(GL_UNIFORM_BUFFER, blockSize, \n        0, GL_DYNAMIC_DRAW);\n\n        // Bind the UBO handle to BindPoint\n        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, UBO);\n    }\n    ```", "```java\n    void Cube::RenderCube()\n    {\n       // Bind the UBO\n       glBindBuffer( GL_UNIFORM_BUFFER, UBO );\n       // Map the buffer block for MVP matrix\n       glm::mat4* matrixBuf = (glm::mat4*)glMapBufferRange\n       (GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4*)*(3),\n    GL_MAP_WRITE_BIT);\n    // Assign updated matrix\n       matrixBuf[0] = *TransformObj->TransformGetModelMatrix();\n       matrixBuf[1] = *TransformObj->TransformGetViewMatrix();\n                matrixBuf[2]=*TransformObj->TransformGetProjectionMatrix();\n    // UnMap the buffer block\n       glUnmapBuffer ( GL_UNIFORM_BUFFER );\n\n    // Draw Geometry using VBO..\n    . . . .    \n    }\n    ```", "```java\n    void Grid::CreateGrid(GLfloat XDim, GLfloat ZDim, int XDiv, int ZDiv)\n    {\n       // Define geometry using Dimension and divisions\n       // Create VBO and IBO for grid geometry\n       // Create Vertex Array Object\n       // Enable VBO and set attribute parameters\n       // Unbind VAO, VBO and IBO \n    }\n    ```", "```java\n     // Create VBO ID\n     glGenBuffers(1, &vIdGrid);\n     glBindBuffer( GL_ARRAY_BUFFER, vIdGrid);\n     glBufferData( GL_ARRAY_BUFFER,size,0, GL_STATIC_DRAW);\n     glBufferSubData( GL_ARRAY_BUFFER, 0, size,gridVertex);\n    ```", "```java\n     // Create IBO for Grid\n     unsigned short indexSize=sizeof(unsigned short)*indexNum;\n     glGenBuffers(1, &iIdGrid);\n     glBindBuffer( GL_ARRAY_BUFFER, iIdGrid );\n     glBufferData(GL_ARRAY_BUFFER,indexSize,0,GL_STATIC_DRAW);\n     glBufferSubData(GL_ARRAY_BUFFER,0,indexSize,gridIndices);\n    ```", "```java\n          // Create Vertex Array Object\n          glGenVertexArrays(1, &Vertex_VAO_Id);\n          glBindVertexArray(Vertex_VAO_Id);    \n          // Create VBO and set attribute parameters\n          glBindBuffer( GL_ARRAY_BUFFER, vIdGrid );\n          glEnableVertexAttribArray(VERTEX_LOCATION);\n          glVertexAttribPointer(VERTEX_LOCATION,3,GL_FLOAT,\n          GL_FALSE,0, (void*)0);\n          glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iIdGrid );\n    ```", "```java\n    glBindVertexArray(0);\n    glBindBuffer( GL_ARRAY_BUFFER, 0 );\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );\n    ```", "```java\n       // void Grid::Render() \n       // Use shader program and apply transformation    \n       . . . . .\n       glBindVertexArray(Vertex_VAO_Id); // Bind VAO\n       glDrawElements(GL_LINES,((XDivision+1)+(ZDivision+1))*2,\n       GL_UNSIGNED_SHORT, (void*)0); }\n    ```", "```java\n    void Cube::RenderCube(){\n         if (clock() - last >= CLOCKS_PER_SEC * 0.1){\n            // Bind the Buffer Object for vertex Array.\n            glBindBuffer( GL_ARRAY_BUFFER, vId );\n            // Get the mapped memory pointer.\n            GLfloat* colorBuf = (GLfloat* )glMapBufferRange(\n     GL_ARRAY_BUFFER, size, size, GL_MAP_WRITE_BIT);\n            for(int i=0; i<size/sizeof(GLfloat); i++)\n    {  colorBuf[i] = float(rand()%255)/255; }\n            last = clock();\n            // Invalidate the mapped memory.\n            glUnmapBuffer ( GL_ARRAY_BUFFER );\n        }\n        // Perform Transformation.\n       . . . . . . .    \n        // Bind the VAO and Render the cube \n        // with Point primitive.\n        glBindVertexArray(Vertex_VAO_Id);\n        glDrawElements(GL_POINTS,36,GL_UNSIGNED_SHORT,(void*)0);\n    }\n    ```", "```java\n    colorBuf = (GLfloat*)glMapBufferRange (GL_ARRAY_BUFFER,\n     size, size, GL_MAP_WRITE_BIT);\n    ```", "```java\n        void *glMapBufferRange(GLenum target, GLintptr offset,\n                        GLsizeiptr length, GLbitfield access);\n        ```", "```java\n    // size/sizeof(GLfloat) gives total number of elements \n    // that needs to be updated with new color, the formula \n    // is- total size of buffer / unit item size \n    for(int i=0; i<size/sizeof(GLfloat); i++){\n        colorBuf[i] = float(rand()%255)/255;\n    }\n    ```", "```java\n    glUnmapBuffer ( GL_ARRAY_BUFFER );\n    ```", "```java\n        GLboolean glUnmapBuffer(GLenum target);\n        ```", "```java\n    glBindVertexArray(Vertex_VAO_Id);\n    glDrawElements(GL_POINTS, 36, GL_UNSIGNED_SHORT, (void*)0);\n    ```", "```java\n    layout(location = 0) in vec4 VertexPosition;\n    layout(location = 1) in vec4 VertexColor;\n    uniform mat4 MODELVIEWPROJECTIONMATRIX;\n    out vec4 Color;\n    void main(){\n      gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;\n      gl_PointSize= 80.0; // Size of GL_POINTS primitive\n      Color       = VertexColor;\n    }\n    ```", "```java\n    #version 300 es\n    layout(location = 0) in vec4 VertexPosition;\n    layout(location = 1) in vec4 VertexColor;\n    layout(location = 2) in mat4 MODELVIEWPROJECTIONMATRIX;\n    out vec4 Color;\n    void main() {\n      gl_Position = MODELVIEWPROJECTIONMATRIX * VertexPosition;\n      Color = VertexColor;\n    }\n    ```", "```java\n    // Create VBO for transformation matrix\n    glGenBuffers(1, &matrixId);\n    glBindBuffer (GL_ARRAY_BUFFER, matrixId);\n    ```", "```java\n    glm::mat4 transformMatrix[dimension][dimension][dimension];\n    glBufferData(GL_ARRAY_BUFFER, sizeof(transformMatrix) , 0, GL_DYNAMIC_DRAW);\n    ```", "```java\n    // Create VBO for transformation matrix and set attributes\n    glBindBuffer( GL_ARRAY_BUFFER, matrixId );\n    glEnableVertexAttribArray(MATRIX1_LOCATION);\n    glEnableVertexAttribArray(MATRIX2_LOCATION);\n    glEnableVertexAttribArray(MATRIX3_LOCATION);\n    glEnableVertexAttribArray(MATRIX4_LOCATION);\n\n    glVertexAttribPointer(MATRIX1_LOCATION,4,GL_FLOAT,GL_FALSE,\n      sizeof(glm::mat4),(void*)(sizeof(float)*0));\n    glVertexAttribPointer(MATRIX2_LOCATION,4,GL_FLOAT,GL_FALSE,\n      sizeof(glm::mat4),(void*)(sizeof(float)*4));\n    glVertexAttribPointer(MATRIX3_LOCATION,4,GL_FLOAT,GL_FALSE,\n      sizeof(glm::mat4), (void*)(sizeof(float)*8));\n    glVertexAttribPointer(MATRIX4_LOCATION,4,GL_FLOAT,GL_FALSE,\n      sizeof(glm::mat4), (void*)(sizeof(float)*12));\n\n    glVertexAttribDivisor(MATRIX1_LOCATION, 1);\n    glVertexAttribDivisor(MATRIX2_LOCATION, 1);\n    glVertexAttribDivisor(MATRIX3_LOCATION, 1);\n    glVertexAttribDivisor(MATRIX4_LOCATION, 1);\n    ```", "```java\n    void Cube::RenderCube()\n    {\n       glBindBuffer( GL_ARRAY_BUFFER, matrixId );\n       glm::mat4* matrixBuf = (glm::mat4*)glMapBufferRange\n       (GL_ARRAY_BUFFER, 0, sizeof(glm::mat4*)*(dimension    *dimension*dimension), GL_MAP_WRITE_BIT);\n       static float l = 0;\n       TransformObj->TransformRotate(l++, 1, 1, 1);\n       TransformObj->TransformTranslate\n       (-distance*dimension/4,-distance*dimension/4, -distance*dimension/4);\n       glm::mat4 projectionMatrix = *TransformObj->\n       TransformGetProjectionMatrix();\n       glm::mat4 modelMatrix = *TransformObj->\n       TransformGetModelMatrix();\n       glm::mat4 viewMatrix = *TransformObj->\n       TransformGetViewMatrix();\n       int instance= 0;\n       for ( int i = 0; i < dimension; i++ ){\n       for ( int j = 0; j < dimension; j++ ){\n       for ( int k = 0; k < dimension; k++ ){\n       matrixBuf[instance++] = projectionMatrix *\n       viewMatrix * glm::translate(modelMatrix, glm::vec3( i*distance , j*distance, k*distance)) * glm::rotate( modelMatrix, l, glm::vec3(1.0, 0.0, 0.0));\n                                            }\n                                            }\n                                            }\n\n       glUnmapBuffer ( GL_ARRAY_BUFFER );\n\n       glBindVertexArray(Vertex_VAO_Id);\n       glDrawElementsInstanced(GL_TRIANGLES,36,\n       GL_UNSIGNED_SHORT, (void*)0, dimension*dimension*dimension);\n    }\n    ```", "```java\nlayout(location = 2) in mat4 MODELVIEWPROJECTIONMATRIX;\n```", "```java\nvoid glVertexAttribDivisor(GLuint index, GLuint divisor);\n```", "```java\nvoid glDrawElementsInstanced(GLenum mode, GLsizei count, \nGLenum type, const void * indices, GLsizei primcount);\n```", "```java\n    GLfloat  cubeVerts[][3] = {\n      -1, -1, 1 , // V0\n      -1, 1, 1 ,  // V1\n      1, 1, 1 ,   // V2\n      1, -1, 1 ,  // V3\n      -1, -1, -1 ,// V4\n      -1, 1, -1 , // V5\n      1, 1, -1 ,  // V6\n      1, -1, -1   // V7\n      };\n    ```", "```java\n    // 36 indices\n    GLushort cubeIndices[] = {\n        0,3,1, 3,2,1,\n        7,4,6, 4,5,6,\n        4,0,5, 0,1,5,\n        0xFFFF, 3,7,2,\n        7,6,2, 1,2,5,\n        2,6,5, 3,0,7,\n        0,4,7\n    };\n    ```", "```java\n    //Bind the VBO\n    glBindBuffer( GL_ARRAY_BUFFER, vId );\n    glVertexAttribPointer(VERTEX_LOCATION, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n    glVertexAttribPointer(COLOR_LOCATION, 3, GL_FLOAT, GL_FALSE, 0, (void*)size);\n\n    glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, iId );\n    // Plus 36 + 1 because it has 1 Primitive Restart Index.\n    glDrawElements(GL_TRIANGLES, 36+1, GL_UNSIGNED_SHORT, (void*)0);\n    glDisable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n    ```"]