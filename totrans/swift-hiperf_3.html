<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Testing and Identifying Slow Code with the Swift Toolkit" id="RL0A1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Testing and Identifying Slow Code with the Swift Toolkit</h1></div></div></div><p class="calibre8">The process of application<a id="id168" class="calibre1"/> development can usually be split into three phases:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Trying out new ideas</li><li class="listitem">Implementing code and checking whether it works correctly</li><li class="listitem">Measuring the performance of the result obtained</li></ul></div><p class="calibre8">The first phase involves trying out a new idea. Let's say you would like to implement a sorting algorithm and you want to quickly prototype a solution.</p><p class="calibre8">In the second phase, you would actually implement the solution and check whether it is working correctly. In this chapter, we will cover how we can test and check whether a solution is implemented correctly.</p><p class="calibre8">The third and final phase involves measuring the performance of the software created. You would do this when you have developed enough code to test, or if you see bad performance characteristics while developing.</p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Testing and Identifying Slow Code with the Swift Toolkit" id="RL0A1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="REPL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec23" class="calibre1"/>REPL</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre9">REPL</strong></span> stands for <span class="strong"><strong class="calibre9">read-eval-print-loop</strong></span>. Swift REPL is an interactive<a id="id169" class="calibre1"/> Swift code interpreter that executes code immediately. To launch Swift REPL, open Terminal. app and execute this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ xcrun swift</strong></span>
</pre></div><p class="calibre8">Now, you can start typing Swift code and see the result. A nice thing about evaluating code in REPL is that if you make an error that would eventually stop the application execution if you compile and run it, you can still continue evaluating the code and preserve all of the progress. Let's play around and try this code in Swift REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">let a = 10</strong></span>
<span class="strong"><strong class="calibre9">let b = a + "c"</strong></span>
<span class="strong"><strong class="calibre9">let b = a + 10</strong></span>
</pre></div><div class="mediaobject"><img src="../images/00006.jpeg" alt="REPL" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Writing code in the <a id="id170" class="calibre1"/>REPL console is not as convenient as in the modern Xcode IDE, but being familiar with it is a useful skill. On top of the Swift REPL, Apple has built more powerful tools, such as Playgrounds, which has a nice source code editor and flexibility of Swift REPL.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Playgrounds"><div class="book" id="SJGS2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Playgrounds</h1></div></div></div><p class="calibre8">Playgrounds is a powerful tool <a id="id171" class="calibre1"/>for trying out code and getting the result. As its name suggests, it's a place to play. In a playground, Swift code is evaluated immediately, which is the same as in REPL. You can create a new playground by going to <span class="strong"><strong class="calibre9">File</strong></span> | <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Playground</strong></span>. Enter the file name and create it.</p><p class="calibre8">A playground <a id="id172" class="calibre1"/>consists of two parts, which are shown in the next<a id="id173" class="calibre1"/> screenshot:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Editor</li><li class="listitem">Result</li></ul></div><div class="mediaobject"><img src="../images/00007.jpeg" alt="Playgrounds" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Almost all the code examples shown in this book were created in playgrounds. As an example, let's create an array and play with it. We can apply filter and map functions and print the count of objects in an array:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="Playgrounds" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">You will see the<a id="id174" class="calibre1"/> result of the evaluated code appearing as you type. If you move the cursor to the one of the lines in the result section, it will become highlighted and two buttons will appear:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Quick Look</strong></span></li><li class="listitem"><span class="strong"><strong class="calibre9">Show / Hide result</strong></span></li></ul></div><p class="calibre8">
<span class="strong"><strong class="calibre9">Quick Look</strong></span> will display <a id="id175" class="calibre1"/>more details about the executed operation. This functionality is particularly interesting for functions. As an example, if you click on the <code class="literal">filter</code> function, you can see the result of every iteration; the results are <code class="literal">true</code> or <code class="literal">false</code> values. If you show the details of a function that has a numerical result, a <code class="literal">map</code> function, for example, it can show a nice graph.</p><p class="calibre8">
<span class="strong"><strong class="calibre9">Show / Hide Result</strong></span> allows <a id="id176" class="calibre1"/>you to add a <span class="strong"><strong class="calibre9">Quick Look</strong></span> result directly to the playground editor. It will always be visible and refresh the data unless you hide it.</p><p class="calibre8">Showing the Result View of a function with a numerical return type is  very useful when you are working with the math functions and you want to see the results in a visual representation. As an example, let's show the result of the <code class="literal">sin</code> and <code class="literal">pow</code> functions, as you can see in the following screenshot:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Playgrounds" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The other useful <a id="id177" class="calibre1"/>use case is for displaying the result of an algorithm. We will create a selection sort algorithm. It is often very useful to see the result of the algorithm at every step. You can easily inspect it in a playground:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Playgrounds" class="calibre11"/></div><p class="calibre12"> </p></div>

<div class="book" title="Playgrounds">
<div class="book" title="Interactive documentation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec35" class="calibre1"/>Interactive documentation</h2></div></div></div><p class="calibre8">The other use case<a id="id178" class="calibre1"/> for playgrounds is in making interactive documentation. You can add markup-formatted text to the playgrounds. In this way, you can combine interactive code examples that run in the playground with rich-formatted text descriptions.</p><p class="calibre8">The markup syntax is based on the <a id="id179" class="calibre1"/>well-known Markdown syntax:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Heading</strong></span>: <code class="literal"># Heading</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Strong</strong></span>: <code class="literal">**Bold Text**</code> or <code class="literal">__Bold Text__</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Inline code</strong></span>: <code class="literal">`Int`</code></li></ul></div><p class="calibre8">The complete <a id="id180" class="calibre1"/>Markdown documentation can be found at <a class="calibre1" href="http://daringfireball.net/projects/markdown/syntax">http://daringfireball.net/projects/markdown/syntax</a>.</p><p class="calibre8">There are two markup text styles in Playgrounds:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">One line</strong></span>: One line markup text style is as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">//: Markup text</strong></span>
</pre></div></li><li class="listitem"><span class="strong"><strong class="calibre9">Multiline</strong></span>: The <a id="id181" class="calibre1"/>multiline markup text style is as<a id="id182" class="calibre1"/> follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">/*:</strong></span>
<span class="strong"><strong class="calibre9">  Markup text</strong></span>
<span class="strong"><strong class="calibre9">/*</strong></span>
</pre></div></li></ul></div><p class="calibre8">Let's now add some markup text to playgrounds:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">//: # Array</strong></span>
<span class="strong"><strong class="calibre9">//: Arrays is an ordered collection. [Read more here](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html)</strong></span>
<span class="strong"><strong class="calibre9">//: Arrays operations:</strong></span>
<span class="strong"><strong class="calibre9">//: * Sort</strong></span>
<span class="strong"><strong class="calibre9">//: * Map</strong></span>
<span class="strong"><strong class="calibre9">//: * Etc.</strong></span>
</pre></div><p class="calibre8">The markup text can be presented in a playground in two modes, raw and rendered:</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Interactive documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">To switch between raw mode and rendered mode, go to <span class="strong"><strong class="calibre9">Editor</strong></span> | <span class="strong"><strong class="calibre9">Show Rendered Markup / Show Raw Markup</strong></span>. You can also switch between these modes by enabling the <span class="strong"><strong class="calibre9">Render Documentation</strong></span> checkbox in the <span class="strong"><strong class="calibre9">Playground Settings</strong></span> section in the <span class="strong"><strong class="calibre9">Utility</strong></span> panel, as shown here:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Interactive documentation" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The full <a id="id183" class="calibre1"/>documentation of the Playgrounds markup format <a id="id184" class="calibre1"/>can be found at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref">https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref</a>.</p></div></div>

<div class="book" title="Playgrounds">
<div class="book" title="The folder structure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec36" class="calibre1"/>The folder structure</h2></div></div></div><p class="calibre8">The playground file is <a id="id185" class="calibre1"/>actually not a simple file but a package that contains multiple files. You can explore its full <a id="id186" class="calibre1"/>contents by opening it in <span class="strong"><strong class="calibre9">Finder</strong></span>. Right-click on <span class="strong"><strong class="calibre9">Show Package Contents</strong></span>.</p><p class="calibre8">In Xcode, you can expand a playground file in <span class="strong"><strong class="calibre9">Project Navigator</strong></span>. It contains three items:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Source</strong></span>: A folder for additional <a id="id187" class="calibre1"/>Swift source files for the Playground</li><li class="listitem"><span class="strong"><strong class="calibre9">Resources</strong></span>: A folder for additional <a id="id188" class="calibre1"/>resources for Playground such as images, text files, and other things</li><li class="listitem"><span class="strong"><strong class="calibre9">Pages</strong></span>: A collection of<a id="id189" class="calibre1"/> playground files of a parent playground</li></ul></div><div class="book" title="The source folder"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec22" class="calibre1"/>The source folder</h3></div></div></div><p class="calibre8">By splitting a playground's <a id="id190" class="calibre1"/>source code into several Swift source code files, you can make the playground cleaner and faster. Every time you make a change in the playground, it will rerun the entire code in that playground. The more code you put into the playground, the slower it gets. The Swift source files in the <code class="literal">source</code> folder don't rerun every time you make a change in the playground file; they rerun only when you make a change to the content of that file. As an example, when we were playing with <code class="literal">Person</code>, it's the perfect use case for adding a <code class="literal">Person</code> type to a separate Swift source file in the <code class="literal">source</code> folder.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre8">The Swift files in the source folder are compiled into the framework. In the framework, you have to mark your types and functions with a <code class="literal">public</code> keyword to make them visible<a id="id191" class="calibre1"/> outside the framework, in our case in the playground.</p></div></div><div class="book" title="Resources"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec23" class="calibre1"/>Resources</h3></div></div></div><p class="calibre8">By including assets in the <code class="literal">Resources</code> folder, you can reference them in the playground. The simplest example<a id="id192" class="calibre1"/> would be adding a <code class="literal">circle.png</code> image file:</p><div class="informalexample"><pre class="programlisting">let circle = UIImage(named: "circle.png")</pre></div><p class="calibre8">The files in the <code class="literal">Resources</code> folder are available via <code class="literal">NSBundle.mainBundle</code>. Let's create the same circle, <code class="literal">UIImage</code>, but this time with the <code class="literal">NSBundle</code> API:</p><div class="informalexample"><pre class="programlisting">if let path = NSBundle.mainBundle().pathForResource("circle", ofType: "png") {
  let cicrcle2 = UIImage(contentsOfFile: path)
}</pre></div></div><div class="book" title="Pages"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec24" class="calibre1"/>Pages</h3></div></div></div><p class="calibre8">A playground file can contain many sub-playground files, called pages. A page is a fully functional <a id="id193" class="calibre1"/>playground file with its own sources and resources folders. A playground can contain many pages. To add a new page, go to <span class="strong"><strong class="calibre9">File</strong></span> | <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Playground Page</strong></span>, or simply right-click on the playground file and select <span class="strong"><strong class="calibre9">New Playground Page</strong></span>.</p><p class="calibre8">Playground pages are great for splitting content into separate parts, such as a page or section of a book.</p><p class="calibre8">For easy navigation among the pages in a playground, there is a page navigation markup. You can jump to the first, last, next, previous, or any specific page. The page navigation markup consists of two parts: <code class="literal">[Visible text]</code> and <code class="literal">(page-link)</code>. Let's see some examples of this markup:</p><div class="informalexample"><pre class="programlisting">First and last pages links
//: [First Page](@first)
//: [Last Page](@last) 

Next and previous pages links
//: [Next](@next)
//: [Previous](@previous) 

Page specific links. Use the same page name as a link. The space must be changed to "%20" 
//: [Type Safe](Type%20Safe)
//: [Optionals](Optionals)</pre></div><p class="calibre8">Many code examples<a id="id194" class="calibre1"/> in this book are created using playground pages.</p></div><div class="book" title="XCPlayground"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec25" class="calibre1"/>XCPlayground</h3></div></div></div><p class="calibre8">
<code class="literal">XCPlayground</code> is a <a id="id195" class="calibre1"/>module specially created for <a id="id196" class="calibre1"/>working with playgrounds. It's a very small module, with four main functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">XCPCaptureValue</code></li><li class="listitem"><code class="literal">XCPShowView</code></li><li class="listitem"><code class="literal">XCPSetExecutionShouldContinueIndefinitely</code></li><li class="listitem"><code class="literal">XCPSharedDataDirectoryPath</code></li></ul></div><p class="calibre8">Let take a quick look at these functions. The results of all of these functions are shown in the Playground timeline. To see it, go to <span class="strong"><strong class="calibre9">View</strong></span> | <span class="strong"><strong class="calibre9">Assistant Editor</strong></span> | <span class="strong"><strong class="calibre9">Show Assistant Editor</strong></span>, and select the timeline for the current playground.</p><p class="calibre8">
<code class="literal">XCPCaptureValue</code> allows<a id="id197" class="calibre1"/> you to manually capture a value and display it in the timeline view. In this way, you can create your own graph results:</p><div class="informalexample"><pre class="programlisting">for i in 0...100 {
  let r = arc4random_uniform(100)
  XCPCaptureValue("random", value: r)
}</pre></div><p class="calibre8">
<code class="literal">XCPShowView</code> displays<a id="id198" class="calibre1"/> a view in the <a id="id199" class="calibre1"/>playground timeline:</p><div class="informalexample"><pre class="programlisting">let frame = CGRect(x: 10, y: 10, width: 100, height: 100)
let view = UIView(frame: frame)
view.backgroundColor = .redColor()

XCPShowView("View", view: view)</pre></div><p class="calibre8">
<code class="literal">XCPSetExecutionShouldContinueIndefinitely</code> is very useful for asynchronous code execution in a <a id="id200" class="calibre1"/>playground. It tells playground to keep executing its run loop infinitely after the last instruction completes, and in this way, we can wait for asynchronous callbacks.</p><p class="calibre8">
<code class="literal">XCPSharedDataDirectoryPath</code> returns<a id="id201" class="calibre1"/> a path to the directory that is shared between all the playgrounds. In this way, you can save and share data between playgrounds and between each playground run.</p></div></div></div>
<div class="book" title="LLDB" id="TI1E1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>LLDB</h1></div></div></div><p class="calibre8">LLDB is a high-performance command-line debugger. It is available in Xcode. The easiest way to start it is to set a breakpoint and run the application. In the Xcode debug area view, you will find a console in which you can execute LLDB commands. Because we made an iOS<a id="id202" class="calibre1"/> app, we will set a breakpoint in the AppDelegate's <code class="literal">didFinishLaunchingWithOptions</code> <a id="id203" class="calibre1"/>method.</p><p class="calibre8">To print the content of a variable, we can use the <code class="literal">p</code> LLDB command. Just run <code class="literal">p</code> with the variable name, for example, <code class="literal">p name</code>, as shown here:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="LLDB" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">LLDB is a very <a id="id204" class="calibre1"/>powerful debugger. You can read more about the LLDB debugger at <a class="calibre1" href="http://www.objc.io/issues/19-debugging/lldb-debugging/">www.objc.io/issues/19-debugging/lldb-debugging/</a> and <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide">https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide</a>.</p></div>
<div class="book" title="REPL in Xcode" id="UGI01-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>REPL in Xcode</h1></div></div></div><p class="calibre8">One of the more<a id="id205" class="calibre1"/> interesting functionalities available in the Xcode LLDB console is that <a id="id206" class="calibre1"/>you can run Swift REPL there. You can enter and execute Swift code when you stop the application execution in the debugger. This is very useful for debugging purposes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">REPL can only access public types, functions, and public global variables. Local variables are not visible in REPL. If you need to work with local variables, use LLDB commands instead.</p></div><p class="calibre8">To enter an REPL console, we first have to stop the program execution and enter the LLDB debugger. There are three <a id="id207" class="calibre1"/>commands for interacting with<a id="id208" class="calibre1"/> REPL:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Enter REPL</strong></span>: <code class="literal">repl</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Exit REPL</strong></span>: <code class="literal">:</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Execute the LLDB</strong></span><a id="id209" class="calibre1"/><span class="strong"><strong class="calibre9"> command in REPL</strong></span>: <code class="literal">: command</code>, for example, <code class="literal">:p name</code></li></ul></div><p class="calibre8">We can execute the same function as before, but now use REPL commands in the debug console, as shown here:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="REPL in Xcode" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now let's look at more interesting use cases of REPL. When you enter REPL, you can enter and execute Swift code. You also have access to publicly declared Swift code in your application in<a id="id210" class="calibre1"/> REPL. To summarize, you can run existing code and add new code as well.</p><p class="calibre8">A great use case<a id="id211" class="calibre1"/> here is adding test code directly to REPL while debugging the application. As an example, let's implement a function for skipping negative numbers in an array:</p><div class="informalexample"><pre class="programlisting">public func skipNegatives(a: [Int]) -&gt; [Int] {
  return a.filter { $0 &gt;= 0 }
}

func REPLTutorial() {
  let numbers = [2, -3, 1]
  let result = skipNegatives(numbers) 
}</pre></div><p class="calibre8">The <code class="literal">skipNegatives</code> function's implementation is very simple, and it is easy to check whether it works correctly in this example, but your other functions could be much bigger and harder to understand. Also, the <code class="literal">numbers</code> array contains only three elements and the result should contain two elements. We can easily check this by looking out for it in the debugger view.</p><p class="calibre8">But what if our numbers array contained 1,000 elements? It would be harder to go through the array and verify that it doesn't contain negative elements. In this example, we have 505 non-negative elements in the array:</p><div class="informalexample"><pre class="programlisting">func REPLTutorial() {
    
  let manyNumbers = makeNumbers()
  let bigResult = skipNegatives(manyNumbers)
}

public func makeNumbers() -&gt; [Int] {
  var array = [Int]()
  for _ in 0..&lt;1000 {
    let rand = Int(arc4random_uniform(10)) - 5
    array.append(rand)
  }
  return array
}</pre></div><p class="calibre8">We could write a<a id="id212" class="calibre1"/> test function in REPL to check whether all the elements are positive. Let's do that, as follows:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="REPL in Xcode" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">First, as usual, run<a id="id213" class="calibre1"/> the program and stop at a breakpoint. The next step is to enter REPL and write an <code class="literal">isAllPositive</code> function to check whether all the numbers are positive. Then, just call <code class="literal">skipNegatives</code> and <code class="literal">isAllPositive</code>, and see whether the result is <code class="literal">true</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">(lldb) repl</strong></span>
<span class="strong"><strong class="calibre9">1&gt; func isAllPositive(ar: [Int]) -&gt; Bool { </strong></span>
<span class="strong"><strong class="calibre9">2.   let negatives = ar.filter { $0 &lt; 0 }</strong></span>
<span class="strong"><strong class="calibre9">3.   return negatives.count == 0</strong></span>
<span class="strong"><strong class="calibre9">4. }</strong></span>
<span class="strong"><strong class="calibre9">5&gt; </strong></span>
<span class="strong"><strong class="calibre9">6&gt; isAllPositive( skipNegatives([1, 2, -4, 7, 9, -1, 5, 12, -12, 24]))</strong></span>
<span class="strong"><strong class="calibre9">$R0: Bool = true</strong></span>
<span class="strong"><strong class="calibre9">7&gt; isAllPositive([1, 2, -4])</strong></span>
<span class="strong"><strong class="calibre9">$R1: Bool = false</strong></span>
<span class="strong"><strong class="calibre9">8&gt;</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre8">If you are going to use a test function more than once in REPL, it is better to create a Swift source file for debugging purposes and add it there. Then, you can call it from REPL.</p></div></div>
<div class="book" title="Console logs" id="VF2I1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>Console logs</h1></div></div></div><p class="calibre8">The other powerful debugging tool, which you should already be familiar with, is the console log. Console<a id="id214" class="calibre1"/> logs can be used to log all types of information, including:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Operation results</li><li class="listitem">Activities</li><li class="listitem">Performance measurement</li></ul></div><p class="calibre8">To log a statement to the console, you can use one of these functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">print</code></li><li class="listitem"><code class="literal">debugPrint</code></li></ul></div><p class="calibre8">Both of these functions<a id="id215" class="calibre1"/> accept any type.</p><p class="calibre8">To provide custom text <a id="id216" class="calibre1"/>formatting for print functions, you must conform to the <code class="literal">CustomStringConvertible</code> protocol, and for <code class="literal">debugPrint</code>, the <code class="literal">CustomDebugStringConvertible</code> protocol. Both of these protocols require the implementation of only one property. Let's create a simple <code class="literal">Person</code> type and implement custom log formatting:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let name: String
  let age: Int
  
extension Person: CustomStringConvertible, CustomDebugStringConvertible {

  // CustomStringConvertible
  var description: String {
    return "Name: \(name)"
  }
  
  // CustomDebugStringConvertible
  var debugDescription: String {
    return "Name: \(name) age: \(age)"
  }
}</pre></div><p class="calibre8">Now, when <code class="literal">print</code> or <code class="literal">debugPrint</code> is called with an instance of a <code class="literal">Person</code> type, it will show a custom description.</p><p class="calibre8">A more interesting use case of console logs is a method's performance logging. We would like to know how much time a particular method or piece of code took to run.</p><p class="calibre8">The first idea would be to use <code class="literal">NSDate</code> to measure time. <code class="literal">NSDate</code> works well, but there is a better solution for this in the <code class="literal">QuartzCore</code> framework—a <code class="literal">CACurrentMediaTime</code> function. It returns the result based on <code class="literal">mach_absolute_time</code>. The base pseudocode for our case would<a id="id217" class="calibre1"/> be as follows:</p><div class="informalexample"><pre class="programlisting">let startTime = CACurrentMediaTime()
// Perform code that we need to measure.
let endTime = CACurrentMediaTime()
print("Time - \(endTime - startTime)")</pre></div><p class="calibre8">We would like to use this performance-measuring function very often, and it would be very useful to extract this code into a separate reusable function. Because Swift supports the functional programming style, we can easily do this.</p><p class="calibre8">We will create a measure function. It will take another function that will perform a task for which we need to measure time:</p><div class="informalexample"><pre class="programlisting">func measure(call: () -&gt; Void) {
  let startTime = CACurrentMediaTime()
  call()
  let endTime = CACurrentMediaTime()

  print("Time - \(endTime - startTime)")
}</pre></div><p class="calibre8">Now, let's say we want to find out how much time it takes to create 1,000 instances of a <code class="literal">Person</code> type:</p><div class="informalexample"><pre class="programlisting">for i in 0...1000 {
  let person = Person(name: "Sam", age: i)
}</pre></div><p class="calibre8">What we need to do is simply wrap this code into a closure and pass it to the measure function:</p><div class="informalexample"><pre class="programlisting">measure {
  for i in 1...1000 {
    let person = Person(name: "Sam", age: i)
  }
}</pre></div><p class="calibre8">Running this measurement in the playground would give us the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">Time 0.000434298478008714.</strong></span>
</pre></div></div>
<div class="book" title="Performance measuring in unit tests" id="10DJ41-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>Performance measuring in unit tests</h1></div></div></div><p class="calibre8">When you create a new<a id="id218" class="calibre1"/> project, Xcode creates a unit test target for that project with the name <code class="literal">ProjectName</code> + <code class="literal">Tests</code>. If you are not familiar with unit testing, you can read<a id="id219" class="calibre1"/> about testing in Xcode at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode">https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode</a>.</p><p class="calibre8">Xcode will also create a<a id="id220" class="calibre1"/> simple unit test file for you. In our project, it's <code class="literal">Swift_ToolkitTests.swift</code>. The unit test has three main methods, with different purposes:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">setup</code></li><li class="listitem"><code class="literal">teardown</code></li><li class="listitem"><code class="literal">test</code><div class="note" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">The unit test function must begin with the <code class="literal">test</code> prefix, like this for example:</p><div class="informalexample"><pre class="programlisting">func testCreatingPerson
func testChangingName
</pre></div></div></li></ul></div><p class="calibre8">The names of these functions reflect their purposes. The <code class="literal">setup</code> function performs additional setup before the unit test is run, and <code class="literal">teardown</code> performs a cleanup, but the most interesting function for us is <code class="literal">test</code>, which performs testing.</p><p class="calibre8">The <code class="literal">XCTestCase</code> unit test class has a <a id="id221" class="calibre1"/>
<code class="literal">measureBlock</code> function that works in a way similar to the <code class="literal">measure</code> function that we have implemented. Let's implement a unit test to measure the performance for creating 1,000 people.</p><p class="calibre8">First, we need to make a <code class="literal">Person</code> type and other types in our application available to the unit test target. To do so, we need to import an app module with the <code class="literal">@testable attribute</code>—<code class="literal">@testable import {ModuleName}</code>. Now, all the <code class="literal">public</code> and <code class="literal">internal</code> types and methods in that module become available in the unit test target:</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">To enable<a id="id222" class="calibre1"/> <code class="literal">@testable</code>, the <span class="strong"><strong class="calibre9">Enable Testability</strong></span> project build setting must be set to <span class="strong"><strong class="calibre9">Yes</strong></span>. Xcode sets it to <span class="strong"><strong class="calibre9">Yes</strong></span> for the <span class="strong"><strong class="calibre9">Debug</strong></span> mode by default. You should never enable it for release mode.</p></div><div class="informalexample"><pre class="programlisting">@testable import Swift_Toolkit

func testCreatingPeoplePerformance() {
  measureBlock() {
    for i in 1...1000 {
      _ = Person(name: "Sam", age: i)
    }
  }
}</pre></div><p class="calibre8">When you run the unit tests, by going to <span class="strong"><strong class="calibre9">Product</strong></span> | <span class="strong"><strong class="calibre9">Test</strong></span> or using the <span class="strong"><em class="calibre10">CMD</em></span> + <span class="strong"><em class="calibre10">U</em></span> shortcut, you will see the performance characteristics on the right-hand side of the function name. When you click on it, you will see more details and a button for setting the baseline performance values, which will be used to compare future measurements.</p><p class="calibre8">The <code class="literal">measureBlock</code> runs <a id="id223" class="calibre1"/>a block of code a few times and shows an average time. You can see the performance for 10 different iterations in a detailed popup, as shown in this screenshot:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Performance measuring in unit tests" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Let's now set a baseline and run the unit test again. The test passes!</p><p class="calibre8">The purpose of performance unit tests is to measure performance and make sure that it doesn't decrease dramatically. By default, the allowed standard deviation is 10%. This means that if the performance for code decreases by more than 10%, the test fails. Let's try to simulate this and see what happens. To simulate the extra work, we will add a delay in the <code class="literal">person</code> initializer:</p><div class="informalexample"><pre class="programlisting">init(name: String, age:Int) {
  self.name = name
  self.age = age
  usleep(100)
}</pre></div><p class="calibre8">Now let's run the test again. You will see that test fails and shows a red sign next to the test function's name.</p><p class="calibre8">In this way, unit testing <a id="id224" class="calibre1"/>allows you to both measure performance and make sure that it doesn't decrease while you are working on the application.</p></div>
<div class="book" title="Instruments" id="11C3M1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Instruments</h1></div></div></div><p class="calibre8">The last tool that we are going to take a look at in this chapter is instruments. Although we are mentioning it towards the <a id="id225" class="calibre1"/>end of the chapter, it's is the most powerful tool for measuring all sorts of characteristics of an application: performance, memory usage and leaks, networking, monitoring, animation, hard drive, and file activity.</p><p class="calibre8">The easiest way to launch Instruments for the application is by going to <span class="strong"><strong class="calibre9">Product</strong></span> | <span class="strong"><strong class="calibre9">Profile</strong></span> or by using the <span class="strong"><em class="calibre10">CMD</em></span> + <span class="strong"><em class="calibre10">I</em></span> keyboard shortcut. This will launch the instrument for the current target and show you the available instrument measurement templates. We will choose a <span class="strong"><strong class="calibre9">Time Profiler</strong></span> template and click on <span class="strong"><strong class="calibre9">Record</strong></span>. This will start the application and record the performance for every called function. Now we can analyze the functions' performance:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Instruments" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Instruments is a very powerful tool, and it would take a separate chapter to cover its functionality completely. If you are not familiar with Instruments, you should read more about<a id="id226" class="calibre1"/> it at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide">https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide</a>.</p></div>
<div class="book" title="A reminder" id="12AK81-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec30" class="calibre1"/>A reminder</h1></div></div></div><p class="calibre8">Whenever you are doing any performance measurement, do it in release mode. The Swift compiler performs many <a id="id227" class="calibre1"/>optimization steps in the release mode and dramatically increases performance. To set release mode, go to <span class="strong"><strong class="calibre9">Product</strong></span> | <span class="strong"><strong class="calibre9">Scheme</strong></span> | <span class="strong"><strong class="calibre9">Edit Scheme</strong></span> | <span class="strong"><strong class="calibre9">Run</strong></span>, and adjust the <span class="strong"><strong class="calibre9">Build Configuration</strong></span> setting to <span class="strong"><strong class="calibre9">Release</strong></span>. Always use release mode for performance testing.</p></div>
<div class="book" title="Summary" id="1394Q1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec31" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered many tools that would boost your productivity. REPL and Playgrounds are perfect for trying out new code and quick code prototyping. Playgrounds can also be used to create interactive documentation and tutorials. Then we covered debugging tools (such as LLDB and REPL) in Xcode, which are very useful for checking the results of operations performed at runtime. The performance of an application can be measured in Instruments or using the console log. To make sure that the performance doesn't decrease, you should use unit testing.</p><p class="calibre8">Basically, in this chapter, you learned many tools for discovering slow and problematic code, and in the next chapter, you will learn how to improve and optimize it.</p></div></body></html>