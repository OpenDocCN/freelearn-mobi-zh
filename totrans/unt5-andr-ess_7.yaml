- en: Chapter 7. Troubleshooting and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primarily, this chapter will explore how to enhance the quality of games and
    applications using different techniques and physically-based shaders. Secondly,
    this chapter will describe global illumination in Unity 5\. At the end of the
    chapter, you will optimize a shader code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in the chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance with the built-in Android profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Android devices with the Unity profiler tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in scripts and shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring performance with the built-in Android profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at what kind of information we can see from the built-in Android
    profiler in Unity 5.
  prefs: []
  type: TYPE_NORMAL
- en: General CPU activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we're going to talk about the information we can get from the built-in
    profiler. To make it easier to understand the structure of these messages, we'll
    cover them in groups. The first group includes the general information or in other
    words the overall performance statistics on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the total time that was spent by the CPU in the parameter value
    called `cpu-player`. The time that was spent on the CPU side by the OpenGLES driver
    code will be seen in the value of the parameter called `cpu-ogles-drv`. Next,
    let's consider the following parameter, known as `cpu-waits-gpu`. This option
    will not appear in the built-in profiler for very small values. This value shows
    how much CPU time was spent waiting for the end of rendering on the GPU side.
    Next, let's consider the following parameter, known as `msaa-resolve`. This value
    shows how much CPU time was spent on anti-aliasing methods. Let's consider the
    following parameter, known as `cpu-present`. This value shows how much CPU time
    was spent on executing the OpenGLES `presentRenderbuffer` function. Let's also
    look at the value of the last parameter in this group, known as `frametime`. This
    value shows the time spent on the CPU side for frame execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refresh rate of the Android hardware is locked at about 60 Hz, so you will have
    the frame time at about ~16.7 ms (approximately 16.7 milliseconds we get from
    computing—1000 milliseconds divided by 60 Hz).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's consider the following group of statistics based on the rendering.
    This group contains only four parameters. The first parameter is called a `draw
    call`. The true meaning of this value is to show draw calls quantified per frame.
    The second parameter of this group is known as `tris`. This value indicates how
    many triangles the renderer will process. The third parameter of this group is
    known as `verts`. This value shows how many vertices the renderer will process.
    The upper limit number for static geometry is 10,000 vertices and much lower for
    skinned geometry. Finally, the last parameter, which we will study in this group,
    is called `batched`. The value of this parameter greatly affects your performance,
    so try to reduce this value as much as possible. This value demonstrates the number
    of automatically batched draw calls, triangles, and vertices by the Unity engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to improve Unity engine batching, you should use shared materials everywhere
    possible for all available objects.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed Unity player statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, consider the following group of statistics, which is more detailed. The
    first parameter in the detailed statistics of the built-in profiler is known as
    `physx`. This value indicates the time spent on physics engine execution. The
    text parameter is called `animation`. This value indicates the time spent on bone
    animations. The third parameter in the detailed statistics is called `culling`.
    This value indicates how much time was spent culling the object's execution. The
    fourth parameter in the detailed statistics of the built-in profiler is known
    as `skinning`. This value indicates the time we need to apply animations to skinned
    meshes. The fifth parameter in this detailed statistics is called `batching`.
    This value shows the time spent on batching geometry execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Batching static geometry is less expensive versus batching dynamic geometry.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth parameter in the detailed statistics is called `render`. This value
    represents the execution time spent on rendering visible objects. The seventh
    parameter is called `fixed-update-count`. This value shows the upper and lower
    values of the `FixedUpdate` execution time for the current frame. Try to decrease
    this value as much as possible because it can decrease your performance.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed script statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are just three obtainable parameters. The first one is known as `update`.
    This value determines the time used for execution per `Update` function in your
    scripts. The next parameter is called `fixedUpdate`. This value demonstrates the
    time used for all executions per `FixedUpdate` function in your scripts. The following
    parameter is known as `coroutines`. This value determines the time utilized for
    coroutines execution in your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed statistics on memory allocated by scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's cover the following group of statistics based on detailed statistics for
    memory allocation by your scripts. There are only four parameters. The first parameter
    is called `allocated heap`.
  prefs: []
  type: TYPE_NORMAL
- en: This value represents available memory for allocation. If we need more memory
    than is available in the heap, a garbage collector will be called. However, if
    the garbage collector cannot free up more memory for us, then the heap will be
    increased in size. The next parameter is known as `used heap`. This value indicates
    the allocated heap by objects. It will be increased for each new class instance,
    and not for structs before the garbage collector will be called one more time.
    The following parameter is known as `max numbers of collections`. This value shows
    the quantity of the garbage collector calls within the last 30 frames. The last
    parameter in this group, and the last one in the built-in profiler, is called
    `collection total duration`. This value displays the summarized milliseconds used
    for the garbage collector calls within the last 30 frames.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Android devices with the Unity profiler tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can open the Unity profiler window from the menu, which presents the whole
    Unity profiler tool. In the upcoming sections, we will explore more about the
    Unity profiler areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, we need to know how this tool is works and how simple it is
    to use. Firstly, let''s look more at the Unity profiler tool window structure
    and separate its parts. As we can see in the next screenshot, there are four main
    visual parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Profiler controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiler timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The upcoming sections focus on these distinctive parts of the Unity profiler
    tool. Let's dive into the most interesting thing in this instrument.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the visual profiler, you can connect to access devices on which your
    application is performing in order to further analyze the performance of your
    software. In order to connect to the other device, it is necessary (but not just
    sufficient) for the profiler to be on the same local network. The **Active Profiler**
    option allows you to select your device from a list of the desired connections.
    Besides that, your application should be launched with the **Development Build
    enabled** checkbox from **Build Settings**. Also in these settings, you will see
    the **Autoconnect profiler** option, which is necessary to signal whether Unity
    should or should not be connected to the profiler every time you start your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the Unity profiler buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep Profiler**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profile Editor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active Profiler**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Debugging Android devices with the Unity profiler tool](img/9191OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the top of the profiler window, you will see there is a toolbar,
    which we will examine in more detail later in the chapter. Using the buttons on
    the toolbar, you can enable or disable the profiler recording data. Also, you
    can clear the collected information or navigate in the frame set and much more;
    we will talk more about this later. Right in the toolbar, we see the **Current**
    button. After clicking on this button, we will automatically get on a frame and
    the last detail of its implementation. If your game was played in the Unity editor,
    it will be suspended, meaning it will be paused. It will also be suspended when
    switching frames forward or backward, using the arrows buttons, which are not
    far away from the **Current** button. Also, be aware that the profiler does not
    preserve all the frames, but only a certain number of the most recent frames.
    Furthermore, if you go from left to right on the toolbar profiler, we see a **Clear**
    button to clear all the data that was collected. After this, we see a **Active
    Profiler** button, which allows you to select a device or the Unity editor for
    further performance analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see a button called **Profile Editor**; if you click on this button,
    you will begin to get detailed statistics execution for the Unity editor. To the
    left of this button, you will see the **Deep Profile** button. When this button
    is activated, it will provide information about all of your scripts and function
    calls. Deep profiling can significantly slow down your application or your game,
    as it will be necessary to spend most of the time processing and requires a huge
    amount of memory space. Remember that very deep profiling will only work if you
    use it for small projects, otherwise you run the risk that Unity will not be able
    to obtain the necessary resources and hang, following which you will have to restart
    the Unity editor. Also, deep profiling is well suited not only for small projects,
    but is also very useful for testing key aspects of your game or application. You
    can use the code in deep profiling, and that is switched ON and OFF for specific
    pieces of code in your scripts. Only the necessary parts of the code will be profiled
    and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Profiler.BeginSample` and `Profiler.EndSample` calls are the beginning
    and endpoints, respectively, of profiling your code, which means that the code
    between these two function calls will be profiled and detailed statistics will
    be displayed in the bottom profiler window. We will talk about profiler scripting
    a little later in this chapter. On the left from the **Deep Profile** button is
    a button that is called **Record**, and it is needed to enable or disable profiling
    as we mentioned earlier. Well, the left-most button in the toolbar is called **Add
    Profiler,** and it is needed to display different profiler areas: **CPU**, **GPU**,
    **Rendering**, **Memory**, **Audio**, **Physics 3D**, and **Physics2D**. We will
    talk about these profiler areas later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: If your game or your application is running at a specific frame rate or is synchronized
    with the vertical blank, then Unity will keep the average time waiting for the
    synchronization of all frames in a parameter called `Wait For Target FPS`, which
    is displayed in the profiler. By default, the information on waiting times will
    not be published in the Unity profiler. To change the specified default behavior,
    you need to enable `View SyncTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Profiler timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the upper part of the profiler window is a graph that shows the profiler
    load data in real time. Statistics are processed in each frame and are saved only
    in the history of the last couple of hundred frames. If you select one of the
    frames for further consideration, you will see details at the bottom profiler,
    which in turn will depend on the selected timeline area (for example, **CPU**,
    **GPU,** or **Audio**). You can both add and remove various timeline areas. Also,
    note that the colored squares on the left display different timeline areas. In
    fact, it is not just the colored squares; they are radio buttons. Thus, it will
    be much easier to eliminate unnecessary data when optimizing your application.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CPU area clearly shows which specific place and how much total time was
    spent on the CPU side of course. If you choose it, then you will have hit on the
    CPU area. After that, you will see that the bottom profiler displays enough details
    solely about the execution of your application on the CPU. Also, you can choose
    two different modes of displaying detailed information:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Hierarchy** mode displays the information in a hierarchy, by grouping
    the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Group Hierarchy** mode displays information on groups that were distributed
    logically; for example, the **Rendering** group, the **Scripts** group, the **Physics**
    group, and many more groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Others** area of the CPU profiler incorporates **Loading**, **Audio**,
    **Animation**, **Particles**, **Playerloop**, **AI**, and **Networking**.
  prefs: []
  type: TYPE_NORMAL
- en: The Rendering area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Rendering** area displays rendering statistics as shown in the following
    screenshot. The timeline graphically presents the number of rendered **Draw Calls**,
    **Triangles**, and **Vertices**. As we can see, the bottom part of the following
    screenshot and **Game View Rendering Statistics** shown in the next figure are
    very similar. Further, we will cover the information shown in the following screenshot
    in details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rendering area](img/9191OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is very similar to the same statistics information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rendering area](img/9191OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| Time per frame and FPS | The time spent rendering one frame in milliseconds;
    represents quantity of frames per second. |'
  prefs: []
  type: TYPE_TB
- en: '| Draw calls | The amount of rendered meshes. |'
  prefs: []
  type: TYPE_TB
- en: '| Batched (draw Calls) | The number of batched draw calls. |'
  prefs: []
  type: TYPE_TB
- en: '| Tris and verts | The amount of drawn geometry (triangles and vertices). |'
  prefs: []
  type: TYPE_TB
- en: '| Used textures | This indicates how many textures were used and the amount
    of memory needed per frame. |'
  prefs: []
  type: TYPE_TB
- en: '| Render textures | This shows the amount of times active render texture was
    switched per frame; furthermore it demonstrates how much memory is used to render
    texture, and how many render textures there were. |'
  prefs: []
  type: TYPE_TB
- en: '| Screen | This shows the screen size with its anti-aliasing level and memory
    usage. |'
  prefs: []
  type: TYPE_TB
- en: '| VRAM usage | This roughly indicates the amount of video memory (VRAM) usage;
    furthermore, represents how much memory your graphic card has. |'
  prefs: []
  type: TYPE_TB
- en: '| VBO total | **Vertex Buffers Objects** (**VBO**) is the number of uploaded
    meshes to the graphics card. |'
  prefs: []
  type: TYPE_TB
- en: '| Visible Skinned Meshes | This shows the amount of rendered skinned meshes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Animations | This represents how many animations can be played. |'
  prefs: []
  type: TYPE_TB
- en: The Memory area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While profiling this area, you can choose one of the two available modes for
    different displaying modes. The first mode is to display very simple statistics,
    and the second mode is for displaying very detailed statistics. We cover these
    two modes in more detail in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The simple view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We begin with the simplest display mode statistics (as shown in the following
    screenshot). This shows the usage of memory for each profiled frame in a simpler
    form than it does in the detailed statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The simple view](img/9191OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The simple view of the Unity profiler
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use memory efficiently, Unity tries to keep a certain amount of
    memory in advance in the form of a pool, or in other words, as a backup buffer,
    which greatly improves performance. Statistics memory, or rather information about
    how much memory is consumed, and for what is the described method of reservation,
    will be shown at the bottom profiler window. Here are the parameters of these
    statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity**: This indicates the amount of memory used for allocations in the
    native Unity code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mono**: This shows how big the heap size was, and the amount of memory used
    for the garbage collector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gfx Driver**: This indicates the amount of memory used by the driver on shaders,
    meshes, render targets, and textures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FMOD**: This shows the amount of memory used on audio drivers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiler**: This indicates the amount of memory used for the Unity''s profiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The memory area displays information for fundamental types of objects and assets:
    textures, meshes, materials, animations, audio, and object count.'
  prefs: []
  type: TYPE_NORMAL
- en: The detailed view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a detailed view, you can save the current state for further analysis using
    the **Take Sample** button. In order to obtain such detailed information about
    the memory usage, the Unity profiler should take time to collect all information
    needed, and that's why you should not think that you can receive information in
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: '![The detailed view](img/9191OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The profiler will show information about where and on what the memory was consumed.
    The following is a list of groups of objects that will be spent in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: Referenced from native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scene object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marked as don't save
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you click on one of the objects in the list, Unity will highlight the
    selected items in the **Project** view or in the **Scene** view. When profiling
    your application in the Unity editor, the statistics will be less accurate than
    it could be on a particular device. Some of the costs associated with the Unity
    editor execution will also be displayed in the average values that will not be
    true for your application. Therefore, for a more precise analysis of your application,
    it is the best decision to connect to real devices and profile statistics in that
    case.
  prefs: []
  type: TYPE_NORMAL
- en: The audio area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This shows the information displayed in the audio area.
  prefs: []
  type: TYPE_NORMAL
- en: The physics area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of information displayed in the Physics 3D area (as
    shown in following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active Bodies**: This indicates the number of awake Rigidbodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sleeping Bodies**: This displays the number of sleeping Rigidbodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of Contacts**: This shows the total amount of contact points in the
    scene between all colliders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static Colliders**: This represents how many colliders were attached on non-Rigidbody
    objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Colliders**: This demonstrates how many colliders were attached on
    Rigidbody objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![The physics area](img/9191OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The detailed view of the Unity profiler
  prefs: []
  type: TYPE_NORMAL
- en: The GPU area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Statistics that are displayed in the profiler window for the GPU area are very
    similar to the displayed statistics for CPU area.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Mac, only OSX 10.7 Lion and later versions support GPU profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Real-practice techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two different performance optimization techniques that are used by
    many professional developers from all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: The high-speed, off-screen particles technique in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next technique is to optimize the particle system, which was introduced
    by NVIDIA, GPU Gems 3\. The first step in order to achieve the goal is to render
    particles into `RenderTexture` or, in other words, into another render target
    with smaller size than screen. The second step in this idea is to blend the particles
    back into screen. First, we need depth buffer. When we render into another render
    target, we need depth buffer for its z-testing. In the following line of code,
    you can register in the `Awake` or `Start` callbacks just as examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider following code for high-speed, off-screen particles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `yourLowerResolutionIntegerValue` determines the quality. The highest value
    means the worst quality and the best performance and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is very simple and means just tuning your main camera''s properties
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step includes rendering and blending particles into the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always release the particles render texture for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can render (after postprocessing) your `RenderTexture` to your destination
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The pool technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next technique is a basic pooling system (as shown in Listing 3-1) for
    Unity in addition for Shuriken particles. Put the pool component on your GameObject
    and set the name and prefab. The pool summons the `OnCreateEvent` strategy on
    entities when they are *made* in the pool (so put your initialization that typically
    will go in the `Start` or `Awake` callback) and an `OnLiberationEvent` system
    when reused items go into the pool. The `OnCreateEvent` strategy provides the
    pool that made the occurrence so that you can store it away and reuse your **GameObject**
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how to use this pooling system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In event of using a particle system with `YourPoolClass`, you should use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The scriptable profiler tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that developers can use the Unity profiler for profiling their own
    code or certain pieces of code is very important. In order to display statistics
    information about some of your function or for some part of your code in the Unity
    profiler, you just need to include your code between two calls, `Profiler.BeginSample`
    and `Profiler.EndSample`. After that you can use the visual Unity profiler tool
    to search for bottlenecks and spikes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The profiler is only available in Unity Pro. In standalone games, the profiler
    can dump all profiling information using `Profiler.log` and `Profiler.enabled`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your own tool, you can utilize the following Unity API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindObjectsOfTypeAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindObjectsOfType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRuntimeMemorySize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMonoHeapSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMonoUsedSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profiler.BeginSample`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profiler.EndSample`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnloadUnusedAssets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.GC.GetTotalMemory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profiler.usedHeapSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity profiler tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is the capability to export the profiling information to a binary file,
    which can then be imported again later. This is empowered through scripting by
    means of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And reimported into the profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The API to get to the profiler frame information into the script is uncovered
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Not documented, yet totally open in the `UnityEditorInternal` namespace. Other
    suitable APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a simple profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now is the time to develop our own simple and very useful profiler tool from
    scratch. In the future, you will be able to use these scripts from our simple
    profiler for all of your projects as well as any other examples discussed in this
    book. Of course, you can modify all methods to meet your specific problem if you
    have a strong desire or if you have to do it, or you can use them all in their
    original form if this functionality will be enough for your tasks. First, let''s
    look at a very simple class, which is a core class in our simple code profiler
    tool. In the following code you can see a very simple `ExampleProfilerClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1-3\. ExampleProfilerClass.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to attach the `ExampleProfilerClass` script to one of the objects
    in your scene. The code is very straightforward and simple, as are all the other
    examples in this book. The entire code of our profiler is shown in Listing 1-4:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1-4\. SimpleProfiler.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following is a simple test code, which performs mathematical operations
    in a cycle. You can hang this script on any object (or on multiple objects simultaneously)
    in your scene, just for testing your `SimpleCodeProfiler` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 1-5\. TestProfilerCode.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we researched our choices for optimization in Unity. We first
    discovered different Unity performance areas. We explored the in-built Unity profiler
    and it's log information structure. In this chapter, we particularly discussed
    the Unity's profiler tool and its window parts. We discovered how to attach the
    profiler to different platforms and devices. At the end of this chapter, we talked
    about best practices that are used by many professionals. We also discovered the
    Unity profiler programming area and created our own very simple profiler tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the bonus chapter, which is available online, I will show you how easy it
    is to develop the most popular game on Android Play Store (Glow Hockey has about
    100,000,000–500,000,000 downloads at [https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en](https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en))
    in Unity 5 from scratch. You will see how to create a camera for any screen resolutions
    and any screen sizes. Also, there you will see, in practice, how easy it is to
    use physics. You will learn in practice how to design beautiful effects, animations,
    physical behaviors, and other different real-world features and techniques for
    your Android games and applications. You will see how to optimize your project
    and any other real-world projects for Android devices. Many more useful things
    and features will be covered in the chapter.
  prefs: []
  type: TYPE_NORMAL
