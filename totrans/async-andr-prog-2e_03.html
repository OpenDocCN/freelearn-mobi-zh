<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Exploring the AsyncTask"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Exploring the AsyncTask</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Performing Work with Looper, Handler, and HandlerThread">Chapter 2</a>, <span class="emphasis"><em>Performing Work with Looper, Handler and HandlerThread</em></span>, we familiarized ourselves with the most basic asynchronous and concurrency constructs available on the Android platform: <code class="literal">Handler</code> and <code class="literal">Looper</code>. Those constructs underpin most of the evented and sequential processing used by the main thread to render the UI and to run the Android components life cycle.</p><p>In this chapter, we are going to explore <code class="literal">android.os.AsyncTask</code>, a higher level construct that provides us with a neat and lean interface to perform background work and publish results back to the main thread without having to manage the thread creation and the handler manipulation.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing AsyncTask</li><li class="listitem" style="list-style-type: disc">Declaring AsyncTask types</li><li class="listitem" style="list-style-type: disc">Executing AsyncTasks</li><li class="listitem" style="list-style-type: disc">Providing indeterministic progress feedback</li><li class="listitem" style="list-style-type: disc">Providing deterministic progress feedback</li><li class="listitem" style="list-style-type: disc">Canceling an AsyncTask</li><li class="listitem" style="list-style-type: disc">Handling exceptions</li><li class="listitem" style="list-style-type: disc">Controlling the level of concurrency</li><li class="listitem" style="list-style-type: disc">Common AsyncTask issues</li><li class="listitem" style="list-style-type: disc">Applications of AsyncTask</li></ul></div><div class="section" title="Introducing AsyncTask"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Introducing AsyncTask</h1></div></div></div><p>
<code class="literal">AsyncTask</code> was <a id="id131" class="indexterm"/>introduced on the Android platform with Android Cupcake (API Level 3), with the express purpose of helping developers to avoid blocking the main thread. The Async part of the name of this class comes from the word asynchronous, which literally means that the blocking task is not occurring at the same time we call it.</p><p>The <code class="literal">AsyncTask</code> encloses the creation of the background thread, the synchronization with the main thread, and the publishing of the progress of the execution in a single construct.</p><p>In contrast to the <code class="literal">Handler</code> and <code class="literal">Looper</code> constructs, the <code class="literal">AsyncTask</code> exempts the developer from the management of low level components, thread creation, and synchronization.</p><p>
<code class="literal">AsyncTask</code> is an abstract class, and as such, must be subclassed for use. At the minimum, our subclass must provide an implementation for the abstract <code class="literal">doInBackground</code> method, which defines the work that we want to get done off the main thread.</p><div class="informalexample"><pre class="programlisting">protected Result doInBackground(Params... params)</pre></div><p>The <code class="literal">doInBackground </code>is <a id="id132" class="indexterm"/>going to be executed in the current process in a parallel thread with the priority <code class="literal">THREAD_PRIORITY_BACKGROUND</code> (Nice level 10)<code class="literal"> </code>and with the name following the next form <code class="literal">AsyncTask #&lt;N&gt;</code>.</p><p>Apart from the method <code class="literal">doInBackground</code> the construct offers distinct methods which the developer might implement in the subclass to set up the task, publish progress, and post the final result into the main thread.</p><p>There are five other methods of <code class="literal">AsyncTask</code> which we may choose to override:</p><div class="informalexample"><pre class="programlisting">   protected void onPreExecute()
   protected void onProgressUpdate(Progress... values)
   protected void onPostExecute(Result result)
   protected void onCancelled(Result result)
   protected void onCancelled()</pre></div><p>Although we could override one or more of these five methods, we will not invoke them directly from our own code. These are callback methods, meaning that they will be invoked for us (called back) at the appropriate time throughout the <code class="literal">AsyncTask</code> lifecycle.</p><p>The key difference between <code class="literal">doInBackground()</code> and the other four methods is the thread on which they execute.</p><p>Before any background work begins, <code class="literal">onPreExecute()</code> will be invoked and will run synchronously to completion on the main thread when we call the execute (Params…)  method.</p><p>In the <code class="literal">onPreExecute</code>() method, we could set up the task or any progress dialog on the UI to indicate to the user that your task has just begun.</p><p>Once <code class="literal">onPreExecute()</code> completes, <code class="literal">doInBackground()</code> will be scheduled and will start work on a background thread.</p><p>During the background work, the developer can publish progress updates from <code class="literal">doInBackground()</code>, which trigger the main thread to execute <code class="literal">onProgressUpdate</code> with the progress values we provide. Internally, the <code class="literal">AsyncTask</code> makes use of a <code class="literal">Handler</code> bound to the main Thread <code class="literal">Looper</code> to publish results on the main Thread as explained in <a class="link" href="ch02.html" title="Chapter 2. Performing Work with Looper, Handler, and HandlerThread">Chapter 2</a>, <span class="emphasis"><em>Performing Work with Looper, Handler and HandlerThread</em></span>.</p><p>By invoking this on the main thread, <code class="literal">AsyncTask</code> makes it easy for us to update the user interface to show progress (remember that we can only update the user interface from the main thread).</p><p>When the background work <a id="id133" class="indexterm"/>completes successfully, <code class="literal">doInBackground() </code>may return a result. This result is passed to <code class="literal">onPostExecute(), </code>which is invoked for us on the main thread. With the result received on the <code class="literal">onPostExecute()</code>, we can update the user interface with the results of our background processing:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>This pattern of passing data from one thread to another is very important, because it allows us to run intensive and long tasks away from the crucial main thread. This construct simplifies the communication in the main thread and provides a high level API for executing asynchronous work on background threads.</p><p>Our <code class="literal">AsyncTask</code> could manipulate fields of the enclosing Activity class, but then we would have to take extra precautions, such as adding synchronization to prevent race conditions and ensure visibility of updates.</p></div></div><div class="mediaobject"><img src="graphics/Image_B05062_03_01.jpg" alt="Introducing AsyncTask"/><div class="caption"><p>Figure 3.1: AsyncTask callback execution function</p></div></div><p>The preceding figure displays a sequence of method calls executed by <code class="literal">AsyncTask</code>, illustrating which methods <a id="id134" class="indexterm"/>run on the main thread versus the <code class="literal">AsyncTask</code> background thread.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Since <code class="literal">onPreExecute()</code>, <code class="literal">onProgressUpdate()</code>, <code class="literal">onPostExecute()</code>, and <code class="literal">onCancelled()</code> methods are invoked on the main thread, we must not perform long-running/blocking operations in these methods.</p></div></div><p>With the <code class="literal">AsyncTask</code> reference invoking the <code class="literal">cancel</code> method before <code class="literal">doInBackground()</code> completes, <code class="literal">onPostExecute()</code> will not be called. Instead, the alternative <code class="literal">onCancelled()</code> callback method is invoked on the UI thread so that we can implement different behavior for a successful versus cancelled completion:</p><div class="mediaobject"><img src="graphics/Image_B05062_03_02.jpg" alt="Introducing AsyncTask"/><div class="caption"><p>Figure 3.2: AsyncTask cancelled task execution sequence</p></div></div><p>The preceding figure displays <a id="id135" class="indexterm"/>the sequence of method calls when a task is cancelled before the <code class="literal">doInBackground()</code> finishes. Like we have shown in the previous figure, the <code class="literal">cancel()</code> might be called by the main thread or from any other thread with access to the <code class="literal">AsyncTask</code> object reference.</p></div></div>
<div class="section" title="Declaring AsyncTask types"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Declaring AsyncTask types</h1></div></div></div><p>
<code class="literal">AsyncTask</code> is a <a id="id136" class="indexterm"/>generically typed class that exposes three generic type parameters:</p><div class="informalexample"><pre class="programlisting">abstract class AsyncTask&lt;Params, Progress, Result&gt;</pre></div><p>In order to use a generic type, we must provide one type argument per type parameter that was declared for the generic type.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The generic type class provides a way to re-use the same generic algorithms for different input types. A generic type could have one or more type parameters.</p></div></div><p>When we declare an <code class="literal">AsyncTask</code> subclass, we'll specify the types for Params, Progress, and Result; for example, if we want to pass a <code class="literal">String</code> parameter to <code class="literal">doInBackground</code>, report progress as a <code class="literal">Float</code>, and return a <code class="literal">Boolean</code> result, we would declare our <code class="literal">AsyncTask</code> subclass as follows:</p><div class="informalexample"><pre class="programlisting">    public class MyTask extends AsyncTask&lt;String, Float, Boolean&gt;</pre></div><p>If we don't need to pass any parameters, or don't want to report progress, a good type to use for those parameters is <code class="literal">java.lang.Void</code>, which signals our intent clearly, because <code class="literal">Void</code> is an uninstantiable class representing the void keyword.</p><p>Only reference types can be used as type arguments of a generic type. This includes classes, interfaces, enum <a id="id137" class="indexterm"/>types, nested and inner types, and array types. Primitive types are not allowed to be used as a type argument. The next declaration is considered illegal on a generic type class definition:</p><div class="informalexample"><pre class="programlisting">   // Error
   public class MyTask extends AsyncTask&lt;String, float, boolean&gt;</pre></div><p>Let's take a look at our first example, performing an expensive image download in the background and reporting the result into the current UI:</p><div class="informalexample"><pre class="programlisting">public class DownloadImageTask
  extends AsyncTask&lt;URL, Integer, Bitmap&gt; {

  // Weak reference to the UI View to update
  private final WeakReference&lt;ImageView&gt; imageViewRef;

  public DownloadImageTask(ImageView imageView) {
    this.imageViewRef = new WeakReference&lt;ImageView&gt;(imageView);
  }
 
  // Retrieves the image from a URL
  private Bitmap downloadBitmap(URL url) {
    // elided for brevity ...
    ...
  }

  @Override
  protected Bitmap doInBackground(URL... params) {
    URL url = params[0];
    // The IO operation invoked will take a significant ammount
    // to complete
    return downloadBitmap(url);
  }
  ...

  @Override
  protected void onPostExecute(Bitmap bitmap) {
    ImageView imageView = this.imageViewRef.get();
    if (imageView != null) {
      imageView.setImageBitmap(bitmap);
    }
  }
}</pre></div><p>Here, <code class="literal">DownloadImageTask </code>extends <code class="literal">AsyncTask</code>, specifying the Params type as a URL so that we can retrieve an image based on its url, Progress as Integer, and the Result type as Bitmap.</p><p>We pass <code class="literal">ImageView</code> to the constructor so that <code class="literal">DownloadImageTask </code>has a weak reference to the user interface that it should update upon completion.</p><p>We've implemented <code class="literal">doInBackground</code> to download the image in the background, where url is a URL parameter with the image resource location.</p><p>In <code class="literal">onPostExecute</code>, when the <a id="id138" class="indexterm"/>view weak reference is not null, we simply load the bitmap into the view that we stored in the constructor.</p><p>The <code class="literal">WeakReference</code> does not prevent the view from being garbage collected when the activity where the view was created is no longer active.</p></div>
<div class="section" title="Executing AsyncTasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Executing AsyncTasks</h1></div></div></div><p>Having implemented <a id="id139" class="indexterm"/><code class="literal">doInBackground</code> and <code class="literal">onPostExecute</code>, we want to get our task running. There are two methods we can use for this, each offering different levels of control over the degree of concurrency with which our tasks are executed. Let's look at the simpler of the two methods first:</p><div class="informalexample"><pre class="programlisting">  public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params...
  params)</pre></div><p>The return type is the type of our <code class="literal">AsyncTask</code> subclass, which is simply for convenience so that we can use method chaining to instantiate and start a task in a single line and still record a reference to the instance:</p><div class="informalexample"><pre class="programlisting">   class MyTask implements AsyncTask&lt;String,Void,String&gt;{ ... }
   MyTask task = new MyTask().execute("hello");</pre></div><p>The <code class="literal">Params... params</code> argument is the same Params type we used in our class declaration, because the values we supply to the execute method are later passed to our <code class="literal">doInBackground</code> method as its Params... params arguments. Notice that it is a varargs (variable number of <a id="id140" class="indexterm"/>parameters) parameter, meaning that we can pass any number of parameters of that type (including none).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Each instance of AsyncTask is a single-use object—once we have started an AsyncTask, it can never be started again, even if we cancel it or wait for it to complete first.</p><p>This is a safety feature, designed to protect us from concurrency issues such as the race condition.</p></div></div><p>Executing <code class="literal">DownloadImageTask </code>is straightforward—we need <code class="literal">Activity</code>, which constructs an instance of <code class="literal">DownloadImageTask </code>with a view to update, and then we invoke the <code class="literal">execute</code> method with a suitable value for the URL:</p><div class="informalexample"><pre class="programlisting">  public class ShowMyPuppyActivity extends Activity {
   
    @Override
 public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.show_my_puppy);

  // Get the show button reference
  Button showBut = (Button) findViewById(R.id.showImageBut);
  showBut.setOnClickListener(new View.OnClickListener() {
   
    @Override
    public void onClick(View v) {
      ...
      // My Puppie Image URL
      URL url = new URL("http://img.allw.mn/" +
                    "content/www/2009/03/april1.jpg");  
      // Get the Reference to Photo UI Image View               
      ImageView iv = (ImageView) findViewById(R.id.photo);
        // Download the Image in background and
        // load the image on the view
        new DownloadImageTask(iv).execute(url);
        ...
      }
  });
}</pre></div><p>Once we click on the UI show button, a new <code class="literal">DownloadAsyncTask</code> is created and attached to an <code class="literal">imageView</code> and we call the <code class="literal">execute()</code> method to start the async task in the background. When we call the <code class="literal">execute()</code> method on the task, this will result in a call to the <code class="literal">onPreExecute()</code> method followed by a call to the <code class="literal">doInBackground()</code> method.</p><p>Like we explained before, once the download is finished, the <code class="literal">onPostExecute()</code> is called to load the image <a id="id141" class="indexterm"/>downloaded (<code class="literal">Bitmap</code>) on the image view.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>You can download the example code files for all Packt Publishing books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div>
<div class="section" title="Providing indeterministic progress feedback"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Providing indeterministic progress feedback</h1></div></div></div><p>Having started what <a id="id142" class="indexterm"/>we know to be a <a id="id143" class="indexterm"/>potentially long-running task, we probably want to let the user know that something is happening. There are a lot of ways of doing this, but a common approach is to present a dialog displaying a relevant message.</p><p>A good place to present our dialog is from the <code class="literal">onPreExecute()</code> method of <code class="literal">AsyncTask</code> which executes on the main thread so it is allowed to interact with the user interface.</p><p>The modified <code class="literal">DownloadImageTask</code> will need a reference to a Context, so that it can prepare a <code class="literal">ProgressDialog</code>, which it will show and dismiss in <code class="literal">onPreExecute()</code> and <code class="literal">onPostExecute()</code> respectively. As <code class="literal">doInBackground()</code> has not changed, it is not shown in the following code, for brevity:</p><div class="informalexample"><pre class="programlisting">public class DownloadImageTask
  extends AsyncTask&lt;URL, Integer, Bitmap&gt; {
  ...
<span class="strong"><strong>  private final WeakReference&lt;Context&gt; ctx;</strong></span>
<span class="strong"><strong>  private ProgressDialog progress;</strong></span>
  ...
  public DownloadImageTask(Context ctx, ImageView imageView) {
    this.imageView = new WeakReference&lt;ImageView&gt;(imageView);
    this.ctx = new WeakReference&lt;Context&gt;(ctx);
  }

<span class="strong"><strong>  @Override</strong></span>
<span class="strong"><strong>  protected void onPreExecute() {</strong></span>
<span class="strong"><strong>    if ( ctx !=null &amp;&amp; ctx.get()!= null ) {</strong></span>
<span class="strong"><strong>      progress = new ProgressDialog(ctx.get());</strong></span>
<span class="strong"><strong>      progress.setTitle(R.string.downloading_image);</strong></span>
<span class="strong"><strong>                   progress.setIndeterminate(true);</strong></span>
<span class="strong"><strong>      progress.setCancelable(false);</strong></span>
<span class="strong"><strong>      progress.show();</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  }</strong></span>


  // ... doInBackground elided for brevity ...
  @Override
  protected void onPostExecute(Bitmap bitmap) {
    ...
<span class="strong"><strong>    if ( progress != null ) { progress.dismiss(); }</strong></span>
<span class="strong"><strong>    ...</strong></span>
  }
}</pre></div><p>All that remains is to <a id="id144" class="indexterm"/>pass a <code class="literal">Context</code> to <a id="id145" class="indexterm"/>the constructor of our modified <code class="literal">DownloadImageTask</code>. As <code class="literal">Activity</code> is a subclass of <code class="literal">Context</code>, we can simply pass a reference to the host <code class="literal">Activity</code>:</p><div class="informalexample"><pre class="programlisting">showBut.setOnClickListener(new View.OnClickListener() {

  @Override
  public void onClick(View v) {
      ...
      // Pass in the Context and the image view to load
      // the image
      new DownloadImageTask(
        ShowMyPuppyActivity.this, iv).execute(url);
         ...   
  }
});</pre></div><div class="mediaobject"><img src="graphics/Image_B05062_03_03.jpg" alt="Providing indeterministic progress feedback"/><div class="caption"><p>Figure 3.3 : Indeterministic Progress Dialog</p></div></div><p>Once the async task is started, the <code class="literal">onPreExecute()</code> callback will create an indeterministic <a id="id146" class="indexterm"/>progress dialog and display it <a id="id147" class="indexterm"/>as shown in Figure 3.3. The non-cancelable dialog will be placed over the UI screen in an opaque layer with the title defined. By indeterministic, we mean that beforehand, we can't estimate how much longer we have to wait for the task to complete.</p><p>Until the download finishes, and the dialog gets dismissed on <code class="literal">onPostExecute()</code>, the user is not able to interact with the application and the dialog will remain in the foreground.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>When any long computation is required before you are able to present your content in your application UI, you must present an indication that something is happening in the background while the user is waiting.</p></div></div></div>
<div class="section" title="Providing deterministic progress feedback"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Providing deterministic progress feedback</h1></div></div></div><p>Knowing that <a id="id148" class="indexterm"/>something is happening is a <a id="id149" class="indexterm"/>great relief to our users, but they might be getting impatient and wondering how much longer they need to wait. Let's show them how we're getting on by adding a progress bar to our dialog.</p><p>Remember that we aren't allowed to update the user interface directly from <code class="literal">doInBackground()</code>, because we aren't on the main thread. How, then, can we tell the main thread to make these updates for us?</p><p>
<code class="literal">AsyncTask</code> comes with a handy callback method for this, whose signature we saw at the beginning of the chapter:</p><div class="informalexample"><pre class="programlisting">protected void onProgressUpdate(Progress... values)</pre></div><p>We can override <code class="literal">onProgressUpdate()</code> to update the user interface from the main thread, but when does it get called and where does it get its <code class="literal">Progress... values</code> from? The glue between <code class="literal">doInBackground()</code> and <code class="literal">onProgressUpdate()</code> is another of AsyncTask's methods:</p><div class="informalexample"><pre class="programlisting">   protected final void publishProgress(Progress... values)</pre></div><p>To update the user interface with our progress, we simply publish progress updates from the background thread by invoking <code class="literal">publishProgress()</code> from within <code class="literal">doInBackground()</code>. Each time we call <code class="literal">publishProgress()</code>, the main thread will be scheduled to invoke <code class="literal">onProgressUpdate()</code> for us with these progress values.</p><p>The modifications to our running example to show a deterministic progress bar are quite simple. Since we have already defined the <code class="literal">DownloadImageTask</code> Progress type as Integer, now, we must change the setting progress values in the range 0 (<code class="literal">setProgress</code>) to 100 (<code class="literal">setMax</code>) and set the style and the bounds of the progress bar. We can do that with the following additions to <code class="literal">onPreExecute()</code>:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onPreExecute() {
    ...
    // Sets the progress bar style
    progress.setProgressStyle(
        ProgressDialog.STYLE_HORIZONTAL);
    progress.setIndeterminate(false);
    progress.setProgress(0);
    progress.setMax(100);
    progress.setCancelable(false);
    progress.show(); 
}</pre></div><p>We also need to implement the <code class="literal">onProgressUpdate</code> callback to update the progress bar from the <a id="id150" class="indexterm"/>main thread:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onProgressUpdate(Integer... values) {
  progress.setProgress(values[0]);
  }</pre></div><p>The final <a id="id151" class="indexterm"/>modification is to calculate the progress at each iteration of the <code class="literal">for</code> loop, and invoke <code class="literal">publishProgress()</code> so that the main thread knows to call back <code class="literal">onProgressUpdate()</code>:</p><div class="informalexample"><pre class="programlisting">private Bitmap downloadBitmap(URL url) {
  InputStream is = null;
  ...
  // Before Download starts
  publishProgress(0);
  downloadedBytes = 0;
  // Creates a Connection to the image URL
  HttpURLConnection conn = (HttpURLConnection) url.
                             openConnection();
  ...
  // Retrieves the image total length
  totalBytes = conn.getContentLength();
    ...
  BufferedInputStream bif = new BufferedInputStream(is) {

    int progress = 0;

      public int read(byte[] buffer, int byteOffset,
                      int byteCount) throws IOException {      
        // The number of bytes read in each stream read
      int readBytes = super.read(buffer, byteOffset,
                                 byteCount);
      ..
      // Actual number of bytes read from the file
      downloadedBytes += readBytes;
      // Percent of work done
      int percent = (int)((downloadedBytes * 100f) /
                      totalBytes);
      // Publish the progress to the main thread
      if (percent &gt; progress) {
        publishProgress(percent);
        progress = percent;
      }     
  ...
}</pre></div><p>It is important to understand that invoking <code class="literal">publishProgress()</code> does not directly invoke the main thread, but adds a task to the main thread's queue, which will be processed at some time in the near future by the main thread.</p><p>Notice that we're <a id="id152" class="indexterm"/>being careful to <a id="id153" class="indexterm"/>publish progress only when the percentage actually changes, avoiding any unnecessary overhead:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Is important to know that every time you invoke <code class="literal">publishProgress()</code> on the background thread, in <code class="literal">downloadBitmat()</code>, a new Handler message is sent automatically internally to push the progress to the main thread.</p></div></div><div class="mediaobject"><img src="graphics/Image_B05062_03_04.jpg" alt="Providing deterministic progress feedback"/><div class="caption"><p>Figure 3.4: Deterministic Progress Dialog showing the task progress</p></div></div><p>As can be seen in Figure 3.4, the deterministic dialog created in <code class="literal">onPreExecute()</code> is updated continuously in <code class="literal">doInBackground()</code> with the current progress of the task. The progress is calculated as a ratio, as in the following division:</p><p>The delay between publishing the progress and seeing the user interface update will be extremely short for this example and for any application that doesn't have too much UI work to process. The progress bar will update smoothly following the golden rule of not blocking the main <a id="id154" class="indexterm"/>thread for any of our <a id="id155" class="indexterm"/>code, since we only dispatch a progress update when the percentage changes.</p></div>
<div class="section" title="Canceling an AsyncTask"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Canceling an AsyncTask</h1></div></div></div><p>Another nice usability <a id="id156" class="indexterm"/>touch we can provide for our users is the ability to cancel a task before it completes—for example, if after starting the execution, the user is no longer interested in the operation result.  <code class="literal">AsyncTask</code> provides support for cancellation with the cancel method.</p><div class="informalexample"><pre class="programlisting">public final boolean cancel(boolean mayInterruptIfRunning)</pre></div><p>The <code class="literal">mayInterruptIfRunning</code> parameter allows us to specify whether an AsyncTask thread that is in an interruptible state, may actually be interrupted—for example, if our doInBackground code is performing a blocking interruptible function, such as  <code class="literal">Object.wait()</code>. When we set the <code class="literal">mayInterruptIfRunning</code> as <code class="literal">false</code>, the AsyncTask won't interrupt the current interruptible blocking operation and the AsyncTask background processing will only finish once the blocking operation terminates.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>In well behaved interruptible blocking functions, such as <code class="literal">Thread.sleep()</code>, <code class="literal">Thread.join(),</code> or <code class="literal">Object.wait(),</code> the execution is stopped immediately when the thread is interrupted with <code class="literal">Thread.interrupt()</code> and it throws an <code class="literal">InterruptedException</code>. The <code class="literal">InterruptedException</code> should be properly handled and swallowed only if you know the background thread is about to exit.</p></div></div><p>Simply invoking cancel is not sufficient to cause our task to finish early. We need to actively support cancellation by periodically checking the value returned from <code class="literal">isCancelled</code> and reacting appropriately in <code class="literal">doInBackground</code>.</p><p>First, let's set up our <code class="literal">ProgressDialog</code> to trigger the AsyncTask's <code class="literal">cancel</code> method by adding a few lines to <code class="literal">onPreExecute</code>:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onPreExecute() {
<span class="strong"><strong>  ...</strong></span>
<span class="strong"><strong>  progress.setCancelable(true);</strong></span>
<span class="strong"><strong>  progress.setOnCancelListener(</strong></span>
<span class="strong"><strong>    new DialogInterface.OnCancelListener() {</strong></span>
<span class="strong"><strong>       public void onCancel(DialogInterface dialog) {</strong></span>
<span class="strong"><strong>         DownloadImageTask.this.cancel(false);</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>     });</strong></span>
<span class="strong"><strong>  ...</strong></span>
}</pre></div><p>Now we can trigger <a id="id157" class="indexterm"/>cancel by touching outside the progress dialog, or pressing the device's back button while the dialog is visible.</p><p>We'll invoke <code class="literal">cancel</code> with <code class="literal">false</code>, as we don't want to immediately suspend the current IO operation during a network read or check the return value of the <code class="literal">Thread.interrupted()</code> function. We still need to check for the cancellation in <code class="literal">doInBackground</code>, so we will modify it as follows:</p><div class="informalexample"><pre class="programlisting">private Bitmap downloadBitmap(URL url) {
  Bitmap bitmap = null;
  BufferedInputStream bif = new BufferedInputStream(is) {
    ...

    public int read(byte[] buffer, int byteOffset,
                    int byteCount) throws IOException {

      // Read the bytes from the Connection
      int readBytes = super.read(buffer, byteOffset, byteCount);
     
      // Verify if the download was cancelled
      if ( isCancelled() ) {
        // Returning -1 means that there is
        // no more data and the stream has just ended
        return -1;
      }
      ...
    }
  }
  // If the download is cancelled the Bitmap is null
  if ( !isCancelled() ) {
    bitmap = BitmapFactory.decodeStream(bif);
  }
  return bitmap;
  }</pre></div><p>In the code above, in our Anonymous subclass of <code class="literal">BufferInputStream</code> we are able to intercept each read that happens on the connection. When that is in place, and once we cancel the AsyncTask, we <a id="id158" class="indexterm"/>are able to stop the data stream by simple returning a -1(End of stream) as the result of the read invoke. As soon as the <code class="literal">BitmapFactory.decodeStream</code> receives the end of the stream, it returns immediately and we return null as the result of the <code class="literal">downloadBitmap</code> invoke.</p><p>The cancelled <code class="literal">AsyncTask</code> does not receive the <code class="literal">onPostExecute</code> callback. Instead, we have the opportunity to implement different behavior for a cancelled execution by implementing <code class="literal">onCancelled</code>. There are two variants of this callback method:</p><div class="informalexample"><pre class="programlisting">protected void onCancelled(Result result);
protected void onCancelled();</pre></div><p>The default implementation of the parameterized <code class="literal">onCancelled</code>(Result result) method delegates to the <code class="literal">onCancelled()</code> method after it finishes.</p><p>If AsyncTask cannot provide either a partial result (such as a partial image data) or nothing, then we will probably want to override the zero argument <code class="literal">onCancelled()</code> method.</p><p>On the other hand, if we are performing an incremental computation in <code class="literal">syncTask</code>, we might choose to override the <code class="literal">onCancelled(Result result)</code> version when the partial result has some meaning to your application.</p><p>In both cases, since <code class="literal">onPostExecute()</code> does not get called on a canceled <code class="literal">AsyncTask</code>, we will want to make sure that our <code class="literal">onCancelled()</code> callbacks update the user interface appropriately—in our example, this entails dismissing the progress dialog we opened in <code class="literal">onPreExecute()</code>, and updating the image view with a default image available as drawable on the application package. </p><p>In our example, when the task is cancelled, the result from <code class="literal">doInBackground()</code> is a null object so we will override the no-argument <code class="literal">onCancelled()</code> function to add the behavior described previously:</p><div class="informalexample"><pre class="programlisting">@Override
protected void onCancelled() {
  if ( imageView !=null &amp;&amp; imageView.get() != null &amp;&amp;
       ctx !=null &amp;&amp; ctx.get() != null ) {
   
   // Load the Bitmap from the application resources
    Bitmap bitmap = BitmapFactory.decodeResource(
                      ctx.get().getResources(),
                      R.drawable.default_photo
                    );
    // Set the image bitmap on the image view
    this.imageView.get().setImageBitmap(bitmap);
  }
  // Remove the dialog from the screen
  progress.dismiss();
}</pre></div><p>Another situation to be <a id="id159" class="indexterm"/>aware of occurs when we cancel an AsyncTask that has not yet begun its <code class="literal">doInBackground()</code> method. If this happens, <code class="literal">doInBackground()</code> will never be invoked, though <code class="literal">onCancelled()</code> will still be called on the main thread.</p><div class="section" title="AsyncTask Execution State"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>AsyncTask Execution State</h2></div></div></div><p>The <code class="literal">execute()</code> method, could finish in a cancelled state or in a completed state, however if the <a id="id160" class="indexterm"/>user tries to call <code class="literal">execute()</code> a second time, the task will fail and throw an IllegalStateException exception saying:</p><p>
<span class="emphasis"><em>Cannot execute task, a task can be executed only once/the task is already running</em></span>
</p><p>With a reference to an <code class="literal">AsyncTask</code> object in hand, we can ascertain the status of your task over the <code class="literal">getStatus()</code> method, and react according to the status result. Let's take a look at the next snippet:</p><div class="informalexample"><pre class="programlisting">// Create a download task object
DownloadImageTask task  = new DownloadImageTask(
                            ShowMyPuppyActivity.this, iv);
...
if ( task.getStatus() == AsyncTask.Status.PENDING ) {
  // DownloadImageTask has not started yet so
  // we can can invoke execute()
} else if (task.getStatus() == AsyncTask.Status.RUNNING) {
  // DownloadImageTask is currently running in
  // doInBackground()
} else if (task.getStatus() == AsyncTask.Status.FINISHED
           &amp;&amp; task.isCancelled()) {
  // DownloadImageTask is done OnCancelled was called
} else {
  // DownloadImageTask is done onPostExecute was called
}</pre></div><p>Using the <code class="literal">getStatus()</code> instance method provided by <code class="literal">AsyncTask</code> we can keep up with the execution of the <a id="id161" class="indexterm"/>background task and know exactly what the current status of your background work is.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>If you want to repeat your background you have to instantiate a new task and call the <code class="literal">execute()</code> method again.</p></div></div></div></div>
<div class="section" title="Handling exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Handling exceptions</h1></div></div></div><p>The callback <a id="id162" class="indexterm"/>methods defined by <code class="literal">AsyncTask</code> dictate that we cannot throw checked exceptions, so we must wrap any code that throws checked exceptions with try/catch blocks. Unchecked exceptions that propagate out of <code class="literal">AsyncTask</code>'s methods will crash our application, so we must test carefully and handle these if necessary.</p><p>For the callback methods that run on the main thread—<code class="literal">onPreExecute()</code>, <code class="literal">onProgressUpdate()</code>, <code class="literal">onPostExecute()</code>, and <code class="literal">onCancelled()</code>—we can catch exceptions in the method and directly update the user interface to alert the user.</p><p>Of course, exceptions are likely to arise in our <code class="literal">doInBackground()</code> method too, as this is where the bulk of the work of <code class="literal">AsyncTask</code> is done, but unfortunately, we can't update the user interface from <code class="literal">doInBackground()</code>. A simple solution is to have <code class="literal">doInBackground()</code> return an object that may contain either the result or an exception. First we are going to create a generic class for storing the result of an operation and a member to store an exception:</p><div class="informalexample"><pre class="programlisting">public class Result&lt;T&gt; {
    public T result;
    public Throwable error;
}</pre></div><p>In the next step we will create a new download <code class="literal">AsyncTask</code>, called <code class="literal">SafeDownloadImageTask</code>, that takes care of the exception handling and has a result of type <code class="literal">Result&lt;Bitmap&gt;</code> instead of the <code class="literal">Bitmap</code>:</p><div class="informalexample"><pre class="programlisting">public class SafeDownloadImageTask extends
  AsyncTask&lt;URL, Integer, Result&lt;Bitmap&gt;&gt; {

   // Method executed on the Background Thread
   protected Result&lt;Bitmap&gt; doInBackground(URL... params) {
     Result&lt;Bitmap&gt; result = new Result&lt;Bitmap&gt;();
     try {
           // elided for brevity ...
          ...
       result.result = bitmap;
     } catch (Throwable e) {
       result.error = e;
     } ...     
   }
   return result;
}</pre></div><p>Now we can check <a id="id163" class="indexterm"/>in <code class="literal">onPostExecute</code> for the presence of an <code class="literal">Exception</code> in the <code class="literal">Result</code> object. If there is one, we can deal with it, perhaps by alerting the user; otherwise, we just use the actual result as normal and use the bitmap from the result:</p><div class="informalexample"><pre class="programlisting">@Override
protected final void onPostExecute(Result&lt;Bitmap&gt; result) {
  ...
  if ( result.error!= null) {
    // ... alert the user ...
    ...
    Log.e("SafeDownloadImageTask",
          "Failed to download image ",result.exception);
    loadDefaultImage(imageView);
  } else {
    // ... success, continue as normal ...
    imageView.setImageBitmap(result.actual);
  }
}</pre></div><p>With a safe implementation like the one above, any error thrown on the background thread is safely forwarded to the main thread and does not affect the normal lifecycle of the <code class="literal">AsyncTask</code>. Let's try to retrieve an image that does not exist and see if the exception is handled properly:</p><div class="informalexample"><pre class="programlisting">URL url = new URL("http://img.allw.mn" +
                  "/content/www/2009/03/notfound.jpg");
new SafeDownloadImageTask(ShowMyPuppyActivity.this, iv)
.execute(url);</pre></div><p>As expected, the error <a id="id164" class="indexterm"/>was caught, wrapped in a <code class="literal">Result</code> object, and printed in the Android log with a stack trace pointing to the <code class="literal">SafeDownloadImageTask.doInBrackground</code> method:</p><div class="informalexample"><pre class="programlisting">...downloadBitmap(SafeDownloadImageTask.java:85)
...doInBackground(SafeDownloadImageTask.java:60)
...

84: if (responseCode != HttpURLConnection.HTTP_OK){
85:      throw new Exception(...);
86: }</pre></div></div>
<div class="section" title="Controlling the level of concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Controlling the level of concurrency</h1></div></div></div><p>So far, we've <a id="id165" class="indexterm"/>carefully avoided being too specific about what exactly happens when we invoke the <code class="literal">AsyncTask</code> execute method. We know that <code class="literal">doInBackground()</code> will execute off the main thread, but what exactly does that mean?</p><p>The original goal of <code class="literal">AsyncTask</code> was created to help developers avoid blocking the main thread. In its initial form at API level 3, <code class="literal">AsyncTask</code>s were queued and executed serially (that is, one after the other) on a single background thread, guaranteeing that they would complete in the order they were started.</p><p>This changed in API level 4 to use a pool of up to 128 threads to execute multiple <code class="literal">AsyncTask</code>s concurrently with each other—a level of concurrency of up to 128. At first glance, this seems like a good thing, since a common use case for <code class="literal">AsyncTask</code> is to perform blocking I/O, where the thread spends much of its time idly waiting for data.</p><p>However, as we saw in <a class="link" href="ch01.html" title="Chapter 1. Asynchronous Programming in Android">Chapter 1</a>, <span class="emphasis"><em>Building Responsive Android Applications</em></span>, there are many issues that commonly arise in concurrent programming, and indeed, the Android team realized that by executing <code class="literal">AsyncTask</code>s concurrently by default, they were exposing developers to potential programming problems (for example, when executed concurrently, there are no guarantees that <code class="literal">AsyncTask</code>s will complete in the same order they were started).</p><p>As a result, a further change was made at API level 11, switching back to serial execution by default, and introducing a new method that gives concurrency control back to the app developer:</p><div class="informalexample"><pre class="programlisting">   public final AsyncTask&lt;Params, Progress, Result&gt;
       executeOnExecutor(Executor exec, Params... params)</pre></div><p>From API level 11 onwards, we can start AsyncTasks with <code class="literal">executeOnExecutor</code>, and in doing so, choose the level of concurrency for ourselves by supplying an Executor object.</p><p>Executor is an interface from the <code class="literal">java.util.concurrent</code> package of the JDK, as described in more detail in <a class="link" href="ch01.html" title="Chapter 1. Asynchronous Programming in Android">Chapter 1</a>, <span class="emphasis"><em>Building Responsive Android Applications</em></span>. Its purpose is to present a way to submit tasks for execution without spelling out precisely how or when the execution will be carried out. Implementations of <a id="id166" class="indexterm"/><code class="literal">Executor</code> may run tasks sequentially using a single thread, use a limited pool of threads to control the level of concurrency, or even directly create a new thread for each task.</p><p>The <code class="literal">AsyncTask</code> class provides two Executor instances that allow you to choose between the concurrency levels described earlier in this section:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SERIAL_EXECUTOR</code>: This Executor queues tasks and makes sure that the tasks are executed by the AsyncTask ThreadPool sequentially, in the order they were submitted.</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREAD_POOL_EXECUTOR</code>: This <code class="literal">Executor</code> runs tasks using a pool of threads for efficiency (starting a new thread comes with some overhead cost that can be avoided through pooling and reuse). <code class="literal">THREAD_POOL_EXECUTOR</code> is an instance of the JDK class <code class="literal">ThreadPoolExecutor</code>, which uses a pool of threads that grows and shrinks with demand. In the case of <code class="literal">AsyncTask</code>, the pool is configured to maintain at least five threads, and expands up to 128 threads. In Android Lollipop 5.0 (API Level 21), the maximum number of threads was reduced to the number of CPU cores * 2 + 1 and the <code class="literal">ThreadPool</code> global enqueuing capacity was increased.</li></ul></div><p>To execute <code class="literal">AsyncTask</code> using a specific executor, we invoke the <code class="literal">executeOnExecutor</code> method, supplying a reference to the executor we want to use, for example:</p><div class="informalexample"><pre class="programlisting">task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
                       params);</pre></div><p>As the default behavior of execute since API level 11 is to run AsyncTasks serially on a single background thread, the following two statements are equivalent:</p><div class="informalexample"><pre class="programlisting">   task.execute(params);
   task.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, params);</pre></div><p>In the next image we will show the differences between the serial executor and thread pool when either <a id="id167" class="indexterm"/>executors process a group of <code class="literal">AsyncTask</code> that were enqueued sequentially:</p><div class="informalexample"><pre class="programlisting">new SleepAsyncTask(1).execute(1000);
...
new SleepAsyncTask(4).execute(1000);</pre></div><div class="mediaobject"><img src="graphics/Image_B05062_03_05.jpg" alt="Controlling the level of concurrency"/></div><p>As shown in the preceding image, the serial executor uses the threads available in the <code class="literal">AsyncTask</code> Thread Pool, however they will only process the next <code class="literal">AsyncTask</code> when the previous <code class="literal">AsyncTask</code> finishes. Alternatively, <code class="literal">ThreadPoolExecutor</code> will start processing the next task as soon as it has a thread available to do the job without guaranteeing that they would complete in the order they were started:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>It is important to mention that all the <code class="literal">AsyncTasks</code> from the system will share the same static executor <code class="literal">AsyncTask.THREAD_POOL_EXECUTOR</code>. For the <code class="literal">SerialExecutor</code> the situation is worse because if an <code class="literal">AsyncTask</code> is occupying the single executor for a long period of time the next tasks will wait on a queue to get processed.</p></div></div><p>Besides the default executors provided by <code class="literal">AsyncTask</code> and the ones that are available on the <code class="literal">java.util.concurrent</code>, we can choose to create our own. For example, we might want to allow some concurrency by operating off a small pool of threads, and allow many tasks to be queued if all threads are currently busy.</p><p>This is easily achieved by configuring our own instance of <code class="literal">ThreadPoolExecutor</code> as a static member of one of our own classes—for example, our <code class="literal">Activity</code> class. Here's how we might configure an <a id="id168" class="indexterm"/>executor with a pool of four to eight threads and an effectively infinite queue:</p><div class="informalexample"><pre class="programlisting">  private static final Queue&lt;Runnable&gt; QUEUE =
     new LinkedBlockingQueue&lt;Runnable&gt;();
   public static final Executor MY_EXECUTOR =
     new ThreadPoolExecutor(4, 8, 1, TimeUnit.MINUTES, QUEUE);</pre></div><p>The parameters to the constructor indicate the core pool size (4), the maximum pool size (8), the time for which idle additional threads may live in the pool before being removed (1), the unit of time (minutes), and the queue to append work when the pool threads are occupied.</p><p>Using our own Executor is then as simple as invoking our <code class="literal">AsyncTask</code> as follows:</p><div class="informalexample"><pre class="programlisting">task.executeOnExecutor(MY_EXECUTOR, params);</pre></div></div>
<div class="section" title="Common AsyncTask issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Common AsyncTask issues</h1></div></div></div><p>As with any powerful <a id="id169" class="indexterm"/>programming abstraction, <code class="literal">AsyncTask</code> is not entirely free from issues and compromises. In the next sections we are going to list some of the pitfalls that we could face when we want to make use of this construct in our applications.</p><div class="section" title="Fragmentation issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Fragmentation issues</h2></div></div></div><p>In the Controlling the <a id="id170" class="indexterm"/>level of concurrency section, we saw how <code class="literal">AsyncTask</code> has evolved with new releases of the Android platform, resulting in behavior that varies with the platform of the device running the task, which is a part of the wider issue of fragmentation.</p><p>The simple fact is that if we target a broad range of API levels, the execution characteristics of our <code class="literal">AsyncTask</code>s—and therefore, the behavior of our apps— can vary considerably on different devices. So what can we do to reduce the likelihood of encountering AsyncTask issues due to fragmentation?</p><p>The most obvious approach is to deliberately target devices running at least Honeycomb, by setting a <code class="literal">minSdkVersion</code> of 11 in the Android Manifest file. This neatly puts us in the category of devices, which, by default, execute <code class="literal">AsyncTasks</code> serially, and therefore, much more predictably.</p><p>At the time of writing in October 2015, only 4% of Android devices run a version of Android in the danger zone between API Levels 4 and 10, and therefore targeting your application to Level 11 <a id="id171" class="indexterm"/>would not reduce your market reach significantly.</p><p>When the <code class="literal">ThreadPoolExecutor</code> is used as the executor, the changes introduced in Lollipop (API Level 21) could also bring behavior drifts in relation to older versions (API Level &gt;10). The modern <code class="literal">AsyncTask's</code> <code class="literal">ThreadPoolExecutor</code> is limited to the device's CPU cores * 2 + 1 concurrent threads, with an additional queue of 128 tasks to queue up work.</p><p>A second option is to design our code carefully and test exhaustively on a range of devices—always commendable practices of course, but as we've seen, concurrent programming is hard enough without the added complexity of fragmentation, and invariably, subtle bugs will remain.</p><p>A third solution that has been suggested by the Android development community is to reimplement <code class="literal">AsyncTask</code> in a package within your own project, then extend your own <code class="literal">AsyncTask</code> class instead of the SDK version. In this way, you are no longer at the mercy of the user's device platform, and can regain control of your <code class="literal">AsyncTasks</code>. Since the source code for <code class="literal">AsyncTask</code> is readily available, this is not difficult to do.</p></div><div class="section" title="Memory leaks"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Memory leaks</h2></div></div></div><p>In cases where we keep a <a id="id172" class="indexterm"/>reference to an <code class="literal">Activity</code> or a <code class="literal">View</code>, we could prevent an entire tree of objects from being garbage collected when the activity is destroyed. The developer needs to make sure that it cancels the task and removes the reference to the destroyed activity or view.</p></div><div class="section" title="Activity lifecycle issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Activity lifecycle issues</h2></div></div></div><p>Having deliberately <a id="id173" class="indexterm"/>moved any long-running tasks off the main thread, we've made our applications nice and responsive—the main thread is free to respond very quickly to any user interaction.</p><p>Unfortunately, we have also created a potential problem for ourselves, because the main thread is able to finish the Activity before our background tasks complete. The Activity might finish for many reasons, including configuration changes caused by the user rotating the device (the Activity is destroyed and created again with a new address in the memory), the user connecting the device to a docking station, or any other kind of context change.</p><p>If we continue processing a background task after the Activity has finished, we are probably doing unnecessary work, and therefore wasting CPU and other resources (including battery life), which could be put to better use.</p><p>On occasions after a device rotation, the <code class="literal">AsyncTask</code> continues to be meaningful and has valid content to deliver, however, it has reference to an activity or a view that was destroyed and therefore is no longer able to update the UI and finish its work and deliver its result.</p><p>Also, any object references held by the <code class="literal">AsyncTask</code> will not be eligible for garbage collection until the task <a id="id174" class="indexterm"/>explicitly nulls those references or completes and is itself <a id="id175" class="indexterm"/>eligible for <span class="strong"><strong>GC</strong></span> (<span class="strong"><strong>garbage collection</strong></span>). Since our <code class="literal">AsyncTask</code> probably references the Activity or parts of the View hierarchy, we can easily leak a significant amount of memory in this way.</p><p>A common usage of <code class="literal">AsyncTask</code> is to declare it as an anonymous inner class of the host Activity, which creates an implicit reference to the Activity and an even bigger memory leak.</p><p>There are two approaches for preventing these resource wastage problems.</p><div class="section" title="Handling lifecycle issues with early cancellation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Handling lifecycle issues with early cancellation</h3></div></div></div><p>First and <a id="id176" class="indexterm"/>foremost, we can synchronize our <code class="literal">AsyncTask</code> lifecycle with that of the Activity by canceling running tasks when our Activity is finishing.</p><p>When an <code class="literal">Activity</code> finishes, its lifecycle callback methods are invoked on the main thread. We can check to see why the lifecycle method is being called, and if the <code class="literal">Activity</code> is finishing, cancel the background tasks. The most appropriate <code class="literal">Activity</code> lifecycle method for this is <code class="literal">onPause</code>, which is guaranteed to be called before the <code class="literal">Activity</code> finishes:</p><div class="informalexample"><pre class="programlisting">   protected void onPause() {
     super.onPause();
     if ((task != null) &amp;&amp; (isFinishing()))
       task.cancel(false);
   }</pre></div><p>If the <code class="literal">Activity</code> is not finishing—say, because it has started another <code class="literal">Activity</code> and is still on the back stack—we might simply allow our background task to continue to completion.</p><p>This solution is straightforward and clean but far from ideal because you might waste precious resources by starting over the background work again unaware that you might already have a valid result or that your <code class="literal">AsyncTask</code> is still running.</p><p>Beyond <a id="id177" class="indexterm"/>that, when you start multiple <code class="literal">AsyncTasks</code> and start them again when the device rotation happens, the waste grows substantially since we have to cancel and fire up the same number of tasks again.</p></div><div class="section" title="Handling lifecycle issues with retained headless fragments"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Handling lifecycle issues with retained headless fragments</h3></div></div></div><p>If the <a id="id178" class="indexterm"/><code class="literal">Activit</code>y is finishing because of a configuration change, it may still be useful to use the results of the background task and display them in the restarted <code class="literal">Activity</code>. One pattern for achieving this is through the use of retained Fragments.</p><p>Fragments were introduced to Android at API level 11, but are available through a support library to applications targeting earlier API Levels. All of the downloadable examples use the support library, and target API Levels 7 through 23. To use <code class="literal">Fragment</code>, our <code class="literal">Activity</code> must extend the <code class="literal">FragmentActivity</code> class.</p><p>The Fragment lifecycle is closely bound to that of the host <code class="literal">Activity</code>, and a fragment will normally be disposed when the activity restarts. However, we can explicitly prevent this by invoking <code class="literal">setRetainInstance(true)</code> on our <code class="literal">Fragment</code> so that it survives across Activity restarts.</p><p>Typically, a <code class="literal">Fragment</code> will be responsible for creating and managing at least a portion of the user interface of an <code class="literal">Activity</code>, but this is not mandatory. A <code class="literal">Fragment</code> that does not manage a view of its own is known as a headless <code class="literal">Fragment</code>. Since they do not have a UI related to them, they do not have to be destroyed and recreated again when the user rotates the device, for example.</p><p>Isolating our <code class="literal">AsyncTask</code> in a retained headless <code class="literal">Fragment</code> makes it less likely that we will accidentally leak references to objects such as the <code class="literal">View</code> hierarchy, because the <code class="literal">AsyncTask</code> will no longer directly interact with the user interface. To demonstrate this, we'll start by defining an interface that our <code class="literal">Activity</code> will implement:</p><div class="informalexample"><pre class="programlisting">public interface AsyncListener {
    void onPreExecute();
    void onProgressUpdate(Integer... progress);
    void onPostExecute(Bitmap result);
    void onCancelled(Bitmap result);
}</pre></div><p>Next, we'll create a retained headless Fragment, which wraps our <code class="literal">AsyncTask</code>. For brevity, <code class="literal">doInBackground</code> is omitted, as it is unchanged from the previous examples—see the <a id="id179" class="indexterm"/>downloadable samples for the complete code.</p><div class="informalexample"><pre class="programlisting">public class DownloadImageHeadlessFragment extends Fragment {

  // Reference to the activity that receives the
  // async task callbacks
  private AsyncListener listener;   
  private DownloadImageTask task;

  // Function to create new instances
  public static DownloadImageHeadlessFragment
    newInstance(String url) {
    DownloadImageHeadlessFragment myFragment = new
                   DownloadImageHeadlessFragment();
    Bundle args = new Bundle();
    args.putString("url", url);
    myFragment.setArguments(args);
    return myFragment;
  }
  // Called to do initial creation of fragment
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setRetainInstance(true);
    task = new DownloadImageTask();
    url = new URL(getArguments().getString("url"));
    task.execute(url);
  }
  // Called when an activity is attached
  public void onAttach(Activity activity) {
    super.onAttach(activity);
  listener = (AsyncListener)activity;
}

public void onDetach() {
    super.onDetach();
    listener = null;
}
// Cancel the download
public void cancel() {
  if (task != null) {
      task.cancel(false);
  }
}

private class DownloadImageTask extends AsyncTask&lt;URL, Integer, Bitmap&gt; {
   
   // ... doInBackground elided for brevity ...        }

}</pre></div><p>As you might know, a fragment has its lifecycle tied to its own <code class="literal">Activity</code>, and therefore the callbacks are invoked in an orderly fashion following the current activity lifecycle events. For <a id="id180" class="indexterm"/>example, when the activity is stopped, all the fragments attached to it will be detached and notified of the <code class="literal">Activity</code> state change.</p><p>In our example, we're using the <code class="literal">Fragment</code> lifecycle methods (<code class="literal">onAttach</code> and <code class="literal">onDetach</code>) to save or remove the current <code class="literal">Activity</code> reference in our retained fragment.</p><p>When the <code class="literal">Activity</code> gets attached to our fragment, the <code class="literal">onCreate</code> method is invoked to create the private <code class="literal">DownloadImageTask</code> object and thereafter, the execute method is invoked to start the download in the background.</p><p>The <code class="literal">newInstance</code> static method is used to initialize and setup a new fragment, without having to call its constructor and a URL setter. As soon as we create the fragment object instance, we save the image URL in the bundle object stored by the fragment arguments member, using the <code class="literal">setArguments</code> function.  If the Android system restores our fragment, it calls the default constructor with no arguments, and moreover it could make use of the old bundle to recreate the fragment.</p><p>Whenever the activity gets destroyed and recreated during a configuration change, the <code class="literal">setRetainInstance(true)</code> forces the fragment to survive during the activity recycling transition. As you can perceive, this technique could be extremely useful in situations where we don't want to reconstruct objects that are expensive to recreate again or objects that have an independent lifecycle when an Activity is destroyed through a configuration change.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>It is important to know that the <code class="literal">retainInstance()</code> can only be used with fragments that are not in the back stack. On retained fragments, <code class="literal">onCreate()</code> and <code class="literal">onDestroy()</code> are not called when the activity is re-attached to a new Activity.</p></div></div><p>Next, our <code class="literal">Fragment</code> has to manage and execute a <code class="literal">DownloadImageTask</code>, that proxies progress <a id="id181" class="indexterm"/>updates and results back to the <code class="literal">Activity</code> via the <code class="literal">AsyncListener</code> interface:</p><div class="informalexample"><pre class="programlisting">private class DownloadImageTask extends AsyncTask&lt;URL, Integer, Bitmap&gt; {
  ...
  protected void onPreExecute() {
    if (listener != null)
      listener.onPreExecute();
  }
  protected void onProgressUpdate(Integer... values) {
    if (listener != null)
      listener.onProgressUpdate(values);
  }
  protected void onPostExecute(Bitmap result) {
    if (listener != null)
      listener.onPostExecute(result);
  }
  protected void onCancelled(Bitmap result) {
    if (listener != null)
      listener.onCancelled(result);
  }
}</pre></div><p>As described previously, the <code class="literal">AsyncListener</code>, is the entity that is responsible for updating the UI with the result that will come from our background task.</p><p>Now, all we need is the host Activity that implements <code class="literal">AsyncListener</code> and uses <code class="literal">DownloadImageHeadlessFragment</code> to implement its long-running task. The full source code is available to download from the Packt Publishing website, so we'll just take a look at the highlights:</p><div class="informalexample"><pre class="programlisting">public class ShowMyPuppyHeadlessActivity
    extends FragmentActivity implements     
    DownloadImageHeadlessFragment.AsyncListener {
 
  private static final String DOWNLOAD_PHOTO_FRAG =        
                         "download_photo_as_fragment";
   ..
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    ...
    FragmentManager fm = getSupportFragmentManager();
    downloadFragment = (DownloadImageHeadlessFragment)
       fm.findFragmentByTag(DOWNLOAD_PHOTO_FRAG);
   
    // If the Fragment is non-null, then it is currently being
    // retained across a configuration change.
    if (downloadFragment == null) {
     downloadFragment = DownloadImageHeadlessFragment.
          newInstance("http://img.allw.mn/content" +
                      "/www/2009/03/april1.jpg");
           fm.beginTransaction().add(downloadFragment,    
       DOWNLOAD_PHOTO_FRAG).
     commit();     
    }
  }</pre></div><p>First, when the activity is created in the <code class="literal">onCreate</code> callback, we check if the fragment already exists in <code class="literal">FragmentManager</code>, and we only create the instance if it is missing.</p><p>When the fragment is created, we build a fragment instance over the <code class="literal">newInstance</code> method and <a id="id182" class="indexterm"/>then we push the fragment to <code class="literal">FragmentManager</code>, the entity that will store and make the transition.</p><p>If our <code class="literal">Activity</code> has been restarted, it will need to re-display the progress dialog when a progress update callback is received, so we check and show it if necessary, before updating the progress bar:</p><div class="informalexample"><pre class="programlisting">@Override
public void onProgressUpdate(Integer... value) {
  if (progress == null)
    prepareProgressDialog();

  progress.setProgress(value[0]);
}</pre></div><p>Finally, <code class="literal">Activity</code> will need to implement the <code class="literal">onPostExecute</code> and <code class="literal">onCancelled</code> callbacks defined by <code class="literal">AsyncListener</code>. The <code class="literal">onPostExecute</code> will update the <code class="literal">resultView</code> as in the <a id="id183" class="indexterm"/>previous examples, and both will do a little cleanup—dismissing the dialog and removing Fragment as its work is now done:</p><div class="informalexample"><pre class="programlisting">@Override
public void onPostExecute(Bitmap result) {
  if (result != null) {
    ImageView iv = (ImageView) findViewById(
                     R.id.downloadedImage);
    iv.setImageBitmap(result);
  }
  cleanUp();
}

// When the task is cancelled the dialog is dimissed
@Override
public void onCancelled(Bitmap result) {
  cleanUp();
}

// Dismiss the progress dialog and remove the
// the fragment from the fragment manager
private void cleanUp() {
  if (progress != null) {
    progress.dismiss();
    progress = null;
  }
  FragmentManager fm = getSupportFragmentManager();
  Fragment frag = fm.findFragmentByTag(DOWNLOAD_PHOTO_FRAG);
  fm.beginTransaction().remove(frag).commit();
}</pre></div><p>This technique, well known in the Android development community as a headless <code class="literal">Fragment</code>, is simple and consistent, since it attaches the recreated activity to the headless <code class="literal">Fragment</code> each time a configuration change happens. An activity reference is maintained, on the fragment, and updated when the fragment gets attached (Activity creation) and gets detached (Activity destroyed).</p><p>Taking advantage of this pattern, the <code class="literal">AsyncTask</code> never has to follow the unpredictable occurrence <a id="id184" class="indexterm"/>of configuration changes or worry about UI updates when it finishes its work because it forwards the lifecycle callbacks to the current <code class="literal">Activity</code>.</p></div></div></div>
<div class="section" title="Applications of AsyncTask"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Applications of AsyncTask</h1></div></div></div><p>Now that we <a id="id185" class="indexterm"/>have seen how to use <code class="literal">AsyncTask</code>, we might ask ourselves when we should use it.</p><p>Good candidate applications for <code class="literal">AsyncTask</code> tend to be relatively short-lived operations (at most, for a second or two), which pertain directly to a specific <code class="literal">Fragment</code> or <code class="literal">Activity</code> and need to update its user interface.</p><p>
<code class="literal">AsyncTask</code> is ideal for running short, CPU-intensive tasks, such as number crunching or searching for words in large text strings, moving them off the main thread so that it can remain responsive to input and maintain high frame rates.</p><p>Blocking I/O operations such as reading and writing text files, or loading images from local files with <code class="literal">BitmapFactory</code> are also good use cases for <code class="literal">AsyncTask</code>.</p><p>Of course, there are use cases for which <code class="literal">AsyncTask</code> is not ideally suited. For anything that requires more than a second or two, we should weigh the cost of performing this operation repeatedly if the user rotates the device, or switches between apps or activities, or whatever else may be going on that we cannot control.</p><p>Taking these things into account, and the rate at which complexity increases as we try to deal with them (for example, retained headless fragments!), <code class="literal">AsyncTask</code> starts to lose its shine for longer operations.</p><p>
<code class="literal">AsyncTask</code> is often used to fetch data from remote web servers, but this can fall foul of the Activity lifecycle issues we looked at earlier. End users may be working with a flaky 3G or HSDPA connection, where network latencies and bandwidth can vary widely, and a complete HTTP request-response cycle can easily span many seconds. This is especially important when we are uploading a significant amount of data, such as an image, as the available bandwidth is often asymmetric.</p><p>While we must perform network I/O off the main thread, <code class="literal">AsyncTask</code> is not necessarily the ideal option—as we'll see later; there are more appropriate constructs available for offloading this kind of work from the main thread.</p><p>When we want to compose or chain background processing over <code class="literal">AsyncTasks</code>, we could end up in situation where it is extremely difficult to manage the callbacks and coordinate the work so <code class="literal">AsyncTask</code> will not help you here.</p><p>Other techniques will <a id="id186" class="indexterm"/>be introduced and detailed in the next chapters for handling these kinds of problems in a clear way.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we've taken a detailed look at <code class="literal">AsyncTask</code> and how to use it to write responsive applications that perform operations without blocking the main thread.</p><p>We saw how to keep users informed of the progress, and even allow them to cancel operations early. We also learned how to deal with issues that can arise when the Activity lifecycle conspires against our background tasks.</p><p>Finally, we considered when to use <code class="literal">AsyncTask</code>, and when it might not be appropriate.</p><p>In the next chapter we'll learn about Loader—a construct designed to streamline the asynchronous loading of data on the Android platform.</p></div></body></html>