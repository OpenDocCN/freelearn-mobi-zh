<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer029">&#13;
			<h1 id="_idParaDest-245"><em class="italic"><a id="_idTextAnchor251"/>Chapter 11</em>: Reactive Microservices with Vert.x</h1>&#13;
			<p>In the previous chapter, we familiarized ourselves with the Ktor framework. We created a web service that could store cats in its database. </p>&#13;
			<p>In this chapter, we'll continue working on the example from the previous chapter, but this time using the Vert.x framework and Kotlin. <strong class="bold">Vert.x</strong> is a Reactive framework that is built on top of Reactive principles, which we discussed in <a href="B17816_07_ePub.xhtml#_idTextAnchor178"><em class="italic">Chapter 7</em></a>, <em class="italic">Controlling the Data Flow</em>. We'll list some of the other benefits of the Vert.x framework in this chapter. You can always read more about Vert.x by going to the official website: <a href="https://vertx.io">https://vertx.io</a>.</p>&#13;
			<p>The microservice we'll develop in this chapter will provide an endpoint for health checks – the same as the one we created in Ktor – and will be able to delete and update the cats in our database.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Getting started with Vert.x</li>&#13;
				<li>Routing in Vert.x</li>&#13;
				<li>Verticles</li>&#13;
				<li>Handling requests</li>&#13;
				<li>Testing Vert.x applications</li>&#13;
				<li>Working with databases</li>&#13;
				<li>Understanding Event Loop</li>&#13;
				<li>Communicating with Event Bus</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-246"><a id="_idTextAnchor252"/>Technical requirements</h1>&#13;
			<p>For this chapter, you'll need the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">JDK 11</strong> or later</li>&#13;
				<li>IntelliJ IDEA</li>&#13;
				<li><strong class="bold">Gradle 6.8</strong> or later</li>&#13;
				<li><strong class="bold">PostgreSQL 14</strong> or later</li>&#13;
			</ul>&#13;
			<p>Like the previous chapter, this chapter will also assume that you have PostgreSQL already installed and that you have basic knowledge of working with it. We'll also use the same table structure we created with Ktor.</p>&#13;
			<p>You can find the full source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11</a>.</p>&#13;
			<h1 id="_idParaDest-247"><a id="_idTextAnchor253"/>Getting started with Vert.x</h1>&#13;
			<p><strong class="bold">Vert.x</strong> is a Reactive<a id="_idIndexMarker693"/> framework that is asynchronous and non-blocking. Let's understand what this means by looking at a concrete example.</p>&#13;
			<p>We'll start by creating a new Kotlin Gradle project or by using <a href="http://start.vertx.io">start.vertx.io</a>:</p>&#13;
			<ol>&#13;
				<li>From your IntelliJ IDEA application, select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> and choose <strong class="bold">Kotlin</strong> from the <strong class="bold">New Project</strong> wizard.</li>&#13;
				<li>Then, specify a name for your project – <strong class="source-inline">CatsShelterVertx</strong>, in my case – and choose <strong class="bold">Gradle Kotlin</strong> as your <strong class="bold">Build System</strong>. </li>&#13;
				<li>Then, select the <strong class="bold">Project JDK</strong> version that you have installed from the dropdown. The output should look as follows:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer028" class="IMG---Figure">&#13;
					<img src="Images/Figure_11.1_B17816.jpg" alt="Figure 11.1 – Creating a Kotlin application&#13;&#10;" width="1061" height="768"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.1 – Creating a Kotlin application</p>&#13;
			<p>Next, add the<a id="_idIndexMarker694"/> following dependencies to your <strong class="source-inline">build.gradle.kts</strong> file:</p>&#13;
			<p class="source-code">val vertxVersion = "4.1.5"</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    implementation("io.vertx:vertx-core:$vertxVersion")</p>&#13;
			<p class="source-code">    implementation("io.vertx:vertx-web:$vertxVersion")</p>&#13;
			<p class="source-code">    implementation("io.vertx:vertx-lang-</p>&#13;
			<p class="source-code">        kotlin:$vertxVersion")</p>&#13;
			<p class="source-code">    implementation("io.vertx:vertx-lang-kotlin-</p>&#13;
			<p class="source-code">        coroutines:$vertxVersion")</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Similar to what we discussed in the previous chapter, all the dependencies must be of the same version to avoid any conflicts. That's the reason we are using a variable for the library version – to be able to change all of them together.</p>&#13;
			<p>The following is an explanation of each dependency:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">vertx-core</strong> is the core library.</li>&#13;
				<li><strong class="source-inline">vertx-web</strong> is needed since we want our service to be REST-based.</li>&#13;
				<li><strong class="source-inline">vertx-lang-kotlin</strong> provides idiomatic ways to write Kotlin code with Vert.x.</li>&#13;
				<li>Finally, <strong class="source-inline">vertx-lang-kotlin-coroutines</strong> integrates with the coroutines, which we discussed in detail in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>.</li>&#13;
			</ul>&#13;
			<p>Then, we must <a id="_idIndexMarker695"/>create a file called <strong class="source-inline">server.kt</strong> in the <strong class="source-inline">src/main/kotlin</strong> folder with the following content:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    val vertx = Vertx.vertx()</p>&#13;
			<p class="source-code">    vertx.createHttpServer().requestHandler{ ctx -&gt;</p>&#13;
			<p class="source-code">        ctx.response().end("OK")</p>&#13;
			<p class="source-code">    }.listen(8081)</p>&#13;
			<p class="source-code">    println("open http://localhost:8081")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>That's all you need to start a web server that will respond with <strong class="source-inline">OK</strong> when you open <strong class="source-inline">http://localhost:8081</strong> in your browser. </p>&#13;
			<p>Now, let's understand what happens here. First, we create a Vert.x instance using the Factory method from <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>. </p>&#13;
			<p>The <strong class="source-inline">requestHandler</strong> method is just a simple listener or a subscriber. If you don't remember how it works, check out <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, for the Observable design pattern. In our case, it will be called for each new request. That's the asynchronous nature of Vert.x in action. </p>&#13;
			<p>Next, let's learn how to add routes in Vert.x.</p>&#13;
			<h1 id="_idParaDest-248"><a id="_idTextAnchor254"/>Routing in Vert.x</h1>&#13;
			<p>Notice that no<a id="_idIndexMarker696"/> matter which URL we specify, we always get the same result. Of course, that's not what we want to achieve. Let's start by adding the most basic endpoint, which will only tell us that the service is up and running. </p>&#13;
			<p>For that, we'll use <strong class="source-inline">Router</strong>:</p>&#13;
			<p class="source-code">val vertx = Vertx.vertx()  </p>&#13;
			<p class="source-code">val router = Router.router(vertx) </p>&#13;
			<p class="source-code">...</p>&#13;
			<p><strong class="source-inline">Router</strong> lets you specify handlers for different HTTP methods and URLs.</p>&#13;
			<p>Now, let's add a <strong class="source-inline">/status</strong> endpoint that will return an HTTP status code of <strong class="source-inline">200</strong> and a message stating <strong class="source-inline">OK</strong> to our user:</p>&#13;
			<p class="source-code">router.get("/status").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    ctx.response()</p>&#13;
			<p class="source-code">        .setStatusCode(200)</p>&#13;
			<p class="source-code">        .end("OK")</p>&#13;
			<p class="source-code">} </p>&#13;
			<p class="source-code">vertx.createHttpServer()</p>&#13;
			<p class="source-code">    .requestHandler(router)</p>&#13;
			<p class="source-code">    .listen(8081)</p>&#13;
			<p>Now, instead of specifying the request handler as a block, we will pass this function to our <strong class="source-inline">router</strong> object. This makes our code easier to manage.</p>&#13;
			<p>We learned how we return a flat text response in the very first example. So, now, let's return JSON instead. Most real-life applications use JSON for communication. Let's replace the body of our status handler with the following code:</p>&#13;
			<p class="source-code">val json = json {</p>&#13;
			<p class="source-code">    obj(</p>&#13;
			<p class="source-code">        "status" to "OK"</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">ctx.response()</p>&#13;
			<p class="source-code">    .setStatusCode(200)</p>&#13;
			<p class="source-code">    .end(json.toString())</p>&#13;
			<p>Here, we are using a DSL, which we discussed in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, to create a JSON object. </p>&#13;
			<p>You can open <strong class="source-inline">http://localhost:8081/status</strong> in your browser and make sure that you get <strong class="source-inline">{"status": "OK"}</strong> as a response.</p>&#13;
			<p>Now, let's <a id="_idIndexMarker697"/>discuss how we can structure our code better with the Vert.x framework.</p>&#13;
			<h1 id="_idParaDest-249"><a id="_idTextAnchor255"/>Verticles</h1>&#13;
			<p>Our current<a id="_idIndexMarker698"/> code <a id="_idIndexMarker699"/>resides in the <strong class="source-inline">server.kt</strong> file, which is getting bigger and bigger. We need to find a way to split it. In Vert.x, code is split into classes called <strong class="bold">verticles</strong>.</p>&#13;
			<p>You can think of a verticle as a lightweight actor. We discussed Actors in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>. </p>&#13;
			<p>Let's see how we can create a new verticle that will encapsulate our server:</p>&#13;
			<p class="source-code">class ServerVerticle : CoroutineVerticle() {</p>&#13;
			<p class="source-code">    override suspend fun start() {</p>&#13;
			<p class="source-code">        val router = router()</p>&#13;
			<p class="source-code">        vertx.createHttpServer()</p>&#13;
			<p class="source-code">            .requestHandler(router)</p>&#13;
			<p class="source-code">            .listen(8081)</p>&#13;
			<p class="source-code">        println("open http://localhost:8081")</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    private fun router(): Router {</p>&#13;
			<p class="source-code">        // Our router code comes here now  </p>&#13;
			<p class="source-code">        val router = Router.router(vertx)</p>&#13;
			<p class="source-code">        ...</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">        return router</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Every verticle has a <strong class="source-inline">start()</strong> method that handles its initialization. As you can see, we moved all the code from our <strong class="source-inline">main()</strong> function to the <strong class="source-inline">start()</strong> method. If we run the code now, though, nothing <a id="_idIndexMarker700"/>will <a id="_idIndexMarker701"/>happen. That's because the verticle hasn't been started yet.</p>&#13;
			<p>There are different ways to start a verticle, but the simplest way is to pass the instance of the class to the <strong class="source-inline">deployVerticle()</strong> method. In our case, this is the <strong class="source-inline">ServerVerticle</strong> class:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    val vertx = Vertx.vertx()</p>&#13;
			<p class="source-code">    vertx.deployVerticle(ServerVerticle())</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here is another, more flexible way to specify the class name as a string:</p>&#13;
			<p class="source-code">fun main() {</p>&#13;
			<p class="source-code">    val vertx = Vertx.vertx()</p>&#13;
			<p class="source-code">    vertx.deployVerticle("ServerVerticle")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>If our verticle class is not in the default package, we'll need to specify the fully qualified path for Vert.x to be able to initialize it.</p>&#13;
			<p>Now, our code has been split into two files, <strong class="source-inline">ServerVerticle.kt</strong> and <strong class="source-inline">server.kt</strong>, and is organized better. Next, we'll learn how we can do the same refactoring to organize our <a id="_idIndexMarker702"/>routes <a id="_idIndexMarker703"/>in a better way.</p>&#13;
			<h1 id="_idParaDest-250"><a id="_idTextAnchor256"/>Handling requests</h1>&#13;
			<p>As we <a id="_idIndexMarker704"/>discussed <a id="_idIndexMarker705"/>earlier in this chapter, all requests in Vert.x are handled by the <strong class="source-inline">Router</strong> class. We covered the concept of routing in the previous chapter, so now, let's just discuss the differences between the Ktor and Vert.x approaches to routing requests.</p>&#13;
			<p>We'll declare two endpoints to delete cats from the database and update information about a particular cat. We'll use the <strong class="source-inline">delete</strong> and <strong class="source-inline">put</strong> verbs, respectively, for this:</p>&#13;
			<p class="source-code">router.delete("/cats/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    // Code for deleting a cat</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">router.put("/cats/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    // Code for updating a cat</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Both endpoints receive a URL parameter. In Vert.x, we use a colon notation for this.</p>&#13;
			<p>To be able to parse JSON requests and responses, Vert.x has a <strong class="source-inline">BodyHandler</strong> class. Now, let's declare it as well. This should come just after the instantiation of our router:</p>&#13;
			<p class="source-code">val router = Router.router(vertx)</p>&#13;
			<p class="source-code">router.route().handler(BodyHandler.create())</p>&#13;
			<p>This will tell Vert.x to parse the request body into JSON for any request. </p>&#13;
			<p>Notice that the <strong class="source-inline">/cat</strong> prefix is repeated multiple times in our code now. To avoid that and make our code more modular, we can use a subrouter, which we'll discuss in the next section.</p>&#13;
			<h2 id="_idParaDest-251"><a id="_idTextAnchor257"/>Subrouting the requests</h2>&#13;
			<p><strong class="bold">Subrouting</strong> allows us <a id="_idIndexMarker706"/>to split routes into multiple classes to keep our code more organized. Let's move the new routes to a new function by following these steps:</p>&#13;
			<ol>&#13;
				<li value="1">We'll leave the <strong class="source-inline">/alive</strong> endpoint as is, but we'll extract all the other endpoints into a separate function:<p class="source-code">private fun catsRouter(): Router {</p><p class="source-code">    val router = Router.router(vertx)</p><p class="source-code">    router.delete("/:id").handler { ctx -&gt;</p><p class="source-code">        // Code for deleting a cat</p><p class="source-code">    }</p><p class="source-code">    router.put("/:id").handler { ctx -&gt;</p><p class="source-code">        // Code for updating a cat</p><p class="source-code">    }</p><p class="source-code">    return router</p><p class="source-code">}</p><p>Inside this function, we create a separate <strong class="source-inline">Router</strong> object that will only handle the routes for cats, not the status routes. </p></li>&#13;
				<li>Now, we need to connect <strong class="source-inline">SubRouter</strong> to our main router:<p class="source-code">router.mountSubRouter("/cats", catsRouter())</p><p>Keeping our code clean and well separated is very important. Extracting routes into subrouters helps us with that.</p></li>&#13;
			</ol>&#13;
			<p>Now, let's discuss how this code can be tested.</p>&#13;
			<h1 id="_idParaDest-252"><a id="_idTextAnchor258"/>Testing Vert.x applications</h1>&#13;
			<p>To test <a id="_idIndexMarker707"/>our Vert.x application, we'll use the <strong class="bold">JUnit 5</strong> framework, which we discussed in the previous chapter. </p>&#13;
			<p>You'll need the following two dependencies in your <strong class="source-inline">build.gradle.kts</strong> file:</p>&#13;
			<p class="source-code">dependencies {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">    testImplementation("org.junit.jupiter:junit-jupiter-</p>&#13;
			<p class="source-code">        api:5.6.0")</p>&#13;
			<p class="source-code">    testRuntimeOnly("org.junit.jupiter:junit-jupiter-</p>&#13;
			<p class="source-code">        engine:5.6.0")</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Our first test will be located in the <strong class="source-inline">/src/test/kotlin/ServerTest.kt</strong> file.</p>&#13;
			<p>The basic structure of all the integration tests looks something like this:</p>&#13;
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>&#13;
			<p class="source-code">class ServerTest {</p>&#13;
			<p class="source-code">    private val vertx: Vertx = Vertx.vertx()</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    @BeforeAll</p>&#13;
			<p class="source-code">    fun setup() {</p>&#13;
			<p class="source-code">        runBlocking {</p>&#13;
			<p class="source-code">            vertx.deployVerticle(ServerVerticle()).await()</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    @AfterAll</p>&#13;
			<p class="source-code">    fun tearDown() {</p>&#13;
			<p class="source-code">        // And you want to stop your server once</p>&#13;
			<p class="source-code">        vertx.close()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">    </p>&#13;
			<p class="source-code">    @Test</p>&#13;
			<p class="source-code">    fun `status should return 200`() {</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This structure is different from what we've seen in Ktor. Here, we start the server ourselves, in the <strong class="source-inline">setup()</strong> method. </p>&#13;
			<p>Since Vert.x is Reactive, the <strong class="source-inline">deployVerticle()</strong> method will return a <strong class="source-inline">Future</strong> object<a id="_idIndexMarker708"/> immediately, releasing the thread, but that doesn't mean that the server verticle has started yet.</p>&#13;
			<p>To avoid this race, we can use the <strong class="source-inline">await()</strong> method, which will block the execution of our tests until the server is ready to receive requests.</p>&#13;
			<p>Now, we want to issue an actual HTTP call to our <strong class="source-inline">/status</strong> endpoint, for example, and check the response code. For that, we'll use the Vert.x web client. </p>&#13;
			<p>Let's add it to our <strong class="source-inline">build.gradle.kts</strong> dependencies section:</p>&#13;
			<p class="source-code">testImplementation("io.vertx:vertx-web-client:$vertxVersion")</p>&#13;
			<p>Since we only plan to use <strong class="source-inline">WebClient</strong> in tests, we specify <strong class="source-inline">testImplementation</strong> instead of <strong class="source-inline">implementation</strong>. But <strong class="source-inline">WebClient</strong> is so useful that you'll probably end up using it in your production code anyway.</p>&#13;
			<p>After adding this new dependency, we need to instantiate our web client in the <strong class="source-inline">setup</strong> method:</p>&#13;
			<p class="source-code">lateinit var client: WebClient</p>&#13;
			<p class="source-code">@BeforeAll</p>&#13;
			<p class="source-code">fun setup() {</p>&#13;
			<p class="source-code">    vertx.deployVerticle(ServerVerticle())</p>&#13;
			<p class="source-code">    client = WebClient.create(</p>&#13;
			<p class="source-code">        vertx,</p>&#13;
			<p class="source-code">        WebClientOptions()</p>&#13;
			<p class="source-code">            .setDefaultPort(8081)</p>&#13;
			<p class="source-code">            .setDefaultHost("localhost")</p>&#13;
			<p class="source-code">    )</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The <strong class="source-inline">setup()</strong> method <a id="_idIndexMarker709"/>will be called once before all the tests start. In this method, we are deploying our server verticle and creating a web client with some defaults for all our tests to share.</p>&#13;
			<p>Now, let's write a test to check that our server is up and running:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `status should return 200`() {</p>&#13;
			<p class="source-code">    runBlocking {</p>&#13;
			<p class="source-code">        val response = client.get("/status").send().await()</p>&#13;
			<p class="source-code">        assertEquals(201, response.statusCode())</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, let's understand what happens in this test:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">client</strong> is an instance of <strong class="source-inline">WebClient</strong> that is shared by all our tests. We invoke the <strong class="source-inline">/status</strong> endpoint using the <strong class="source-inline">get</strong> verb. This is a Builder design pattern, so to issue our request, we need to use the <strong class="source-inline">send()</strong> method. Otherwise, nothing will happen.</li>&#13;
				<li>Vert.x is a Reactive framework, so instead of blocking our thread until a response is received, the <strong class="source-inline">send()</strong> method returns a Future. Then, we use <strong class="source-inline">await()</strong>, which adapts a Future to a Kotlin coroutine to be able to wait for the results concurrently.</li>&#13;
				<li>Once the response is received, we check it in the same way that we did in other tests – by using the <strong class="source-inline">assertEquals</strong> function, which comes from JUnit.</li>&#13;
			</ul>&#13;
			<p>Now that we <a id="_idIndexMarker710"/>know how to write tests in Vert.x, let's discuss how we can work with databases in a Reactive manner.</p>&#13;
			<h1 id="_idParaDest-253"><a id="_idTextAnchor259"/>Working with databases</h1>&#13;
			<p>To be able to <a id="_idIndexMarker711"/>progress further with our tests, we need the ability to create entities in the database. For that, we'll need to connect to the database.</p>&#13;
			<p>First, let's add the following two lines to our <strong class="source-inline">build.gradle.kts</strong> dependencies section:</p>&#13;
			<p class="source-code">implementation("org.postgresql:postgresql:42.3.0")</p>&#13;
			<p class="source-code">implementation("io.vertx:vertx-pg-client:$vertxVersion")</p>&#13;
			<p>The first line of code fetches the PostgreSQL driver. The second one adds the Vert.x JDBC client, which allows Vert.x, which has the driver, to connect to any database that supports JDBC.</p>&#13;
			<h2 id="_idParaDest-254"><a id="_idTextAnchor260"/>Managing configuration</h2>&#13;
			<p>Now, we want<a id="_idIndexMarker712"/> to hold the database configuration somewhere. For local development, it may be fine to have those configurations hardcoded. We'll execute the following steps to do this:</p>&#13;
			<ol>&#13;
				<li value="1">When we connect to the database, we need to specify the following parameters at the very least:<ul><li>Username</li><li>Password</li><li>Host</li><li>Database name</li></ul><p>We'll store the preceding parameters in a <strong class="source-inline">Singleton</strong> object:</p><p class="source-code">object Db {</p><p class="source-code">    val username = System.getenv("DATABASE_USERNAME")         ?: "cats_admin"</p><p class="source-code">    val password = System.getenv("DATABASE_PASSWORD")         ?: "abcd1234"</p><p class="source-code">    val database = System.getenv("DATABASE_NAME")         ?: "cats_db"</p><p class="source-code">    val host = System.getenv("DATABASE_HOST")         ?: "localhost"</p><p class="source-code">}</p><p>Our <strong class="source-inline">Singleton</strong> object has four members. For each, we check whether an environment <a id="_idIndexMarker713"/>variable was set, and if there's no such environment variable, we provide a default value using the Elvis operator.</p></li>&#13;
				<li>Now, let's add a function that will return a connection pool:<p class="source-code">fun connect(vertx: Vertx): SqlClient {</p><p class="source-code">    val connectOptions = PgConnectOptions()</p><p class="source-code">        .setPort(5432)</p><p class="source-code">        .setHost(host)</p><p class="source-code">        .setDatabase(database)</p><p class="source-code">        .setUser(username)</p><p class="source-code">        .setPassword(password)</p><p class="source-code"> </p><p class="source-code">    val poolOptions = PoolOptions()</p><p class="source-code">        .setMaxSize(20)</p><p class="source-code"> </p><p class="source-code">    return PgPool.client(</p><p class="source-code">        vertx,</p><p class="source-code">        connectOptions,</p><p class="source-code">        poolOptions</p><p class="source-code">    )</p><p class="source-code">}</p><p>Our <strong class="source-inline">connect()</strong> method creates two configuration objects: <strong class="source-inline">PgConnectOptions</strong> sets the configuration for the database we want to connect <a id="_idIndexMarker714"/>to, while <strong class="source-inline">PoolOptions</strong> specifies the configuration of the connection pool.</p></li>&#13;
				<li>Now, all we need to do is instantiate the database client in our test:<p class="source-code">...</p><p class="source-code">lateinit var db: SqlClient</p><p class="source-code"> </p><p class="source-code">@BeforeAll</p><p class="source-code">fun setup() {</p><p class="source-code">    runBlocking {</p><p class="source-code">        ...</p><p class="source-code">        db = Db.connect(vertx)</p><p class="source-code">    }</p><p class="source-code">}</p></li>&#13;
				<li>Having done that, let's create a new <strong class="source-inline">Nested</strong> class in our test file for cases where we expect to have a cat in our database:<p class="source-code">@Nested</p><p class="source-code">inner class `With Cat` {</p><p class="source-code">    @BeforeEach</p><p class="source-code">    fun createCats() {</p><p class="source-code">        ...</p><p class="source-code">    }</p><p class="source-code">    </p><p class="source-code">    @AfterEach</p><p class="source-code">    fun deleteAll() {</p><p class="source-code">        ...</p><p class="source-code">    }</p><p class="source-code">}</p><p>Unlike the Exposed<a id="_idIndexMarker715"/> framework, which we discussed in the previous chapter, the database client in Vert.x doesn't have specific methods for insertion, deletion, and so on. Instead, it provides a lower-level API that allows us to execute any type of query on the database. </p></li>&#13;
				<li>First, let's write a query that will clean our database:<p class="source-code">@AfterEach</p><p class="source-code">fun deleteAll() {</p><p class="source-code">    runBlocking {</p><p class="source-code">        db.preparedQuery("DELETE FROM cats")            .execute().await()</p><p class="source-code">    }</p><p class="source-code">}</p><p>The basic structure for working with the database client in Vert.x is to pass a query to the <strong class="source-inline">prepareQuery()</strong> method, then execute it using <strong class="source-inline">execute()</strong>.</p><p>We want to wait for the query to complete before we move on to the next test, so we use the <strong class="source-inline">await()</strong> function to wait for the current coroutine, and we use the <strong class="source-inline">runBlocking()</strong> adapter method to have a coroutine context to do so.</p></li>&#13;
				<li>Now, let's <a id="_idIndexMarker716"/>write another query that will add a cat to the database before each test runs:<p class="source-code">lateinit var catRow: Row</p><p class="source-code"> </p><p class="source-code">@BeforeEach</p><p class="source-code">fun createCats() {</p><p class="source-code">    runBlocking {</p><p class="source-code">        val result = db.preparedQuery(</p><p class="source-code">            """INSERT INTO cats (name, age) </p><p class="source-code">            VALUES ($1, $2) </p><p class="source-code">            RETURNING ID""".trimIndent()</p><p class="source-code">        ).execute(Tuple.of("Binky", 7)).await()</p><p class="source-code">        catRow = result.first()</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we are using the <strong class="source-inline">preparedQuery()</strong> method once more, but this time, our SQL query string contains placeholders. Each placeholder starts with a dollar sign and their indexes start with <strong class="source-inline">1</strong>.</p><p>Then, we pass the values for those placeholders to the <strong class="source-inline">execute()</strong> method. <strong class="source-inline">Tuple.of</strong> is a Factory method design pattern that you should be able to recognize well by now.</p><p>We also want to remember the ID of the cat that we create since we'll use that ID to delete or update the cat. For this reason, we store the created row in a <strong class="source-inline">lateinit</strong> variable. </p></li>&#13;
				<li>We now <a id="_idIndexMarker717"/>have everything prepared to write our test:<p class="source-code">@Test</p><p class="source-code">fun `delete deletes a cat by ID`() {</p><p class="source-code">    runBlocking {</p><p class="source-code">        val catId = catRow.getInteger(0)</p><p class="source-code">        client.delete("/cats/${catId}").send().await()</p><p class="source-code"> </p><p class="source-code">        val result = db.preparedQuery("SELECT * FROM             cats WHERE id = $1")            .execute(Tuple.of(catId)).await()</p><p class="source-code"> </p><p class="source-code">        assertEquals(0, result.size())</p><p class="source-code">    }</p><p class="source-code">}</p><p>First, we get the ID of the cat we want to delete from the database row using the <strong class="source-inline">getInteger()</strong> method. Unlike parameters that start with <strong class="source-inline">1</strong>, the columns of a database row start with <strong class="source-inline">0</strong>. So, by getting an integer at index <strong class="source-inline">0</strong>, we get the ID of our cat.</p><p>Then, we invoke the web client's <strong class="source-inline">delete()</strong> method and wait for it to complete.</p><p>Afterward, we execute a <strong class="source-inline">SELECT</strong> statement on our database, checking that the row was indeed deleted.</p></li>&#13;
			</ol>&#13;
			<p>If you run this test now, it will fail, because we haven't implemented the <strong class="source-inline">delete</strong> endpoint <a id="_idIndexMarker718"/>yet. We'll do that in the next section.</p>&#13;
			<h1 id="_idParaDest-255"><a id="_idTextAnchor261"/>Understanding Event Loop</h1>&#13;
			<p>The goal of <a id="_idIndexMarker719"/>the <strong class="bold">Event Loop</strong> design pattern is to continuously check for new events in a queue, and each time a new event comes in, to quickly dispatch it to someone who knows how to handle it. This way, a single thread or a very limited number of threads can handle a huge number of events.</p>&#13;
			<p>In the case of web frameworks such as Vert.x, events may be requests to our server.</p>&#13;
			<p>To understand the concept of the Event Loop better, let's go back to our server code and attempt to implement an endpoint for deleting a cat:</p>&#13;
			<p class="source-code">val db = Db.connect(vertx)</p>&#13;
			<p class="source-code">router.delete("/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    val id = ctx.request().getParam("id").toInt()</p>&#13;
			<p class="source-code">    db.preparedQuery("DELETE FROM cats WHERE ID = $1")        .execute(Tuple.of(id)).await()</p>&#13;
			<p class="source-code">    ctx.end()</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This code is very similar to what we've written in our tests in the previous section. We read the URL parameter from the request using the <strong class="source-inline">getParam()</strong> function, then we pass this ID to the prepared query. This time, though, we can't use the <strong class="source-inline">runBlocking</strong> adapter function, since it will block the Event Loop.</p>&#13;
			<p>Vert.x uses a limited number of threads, as many as twice the number of your CPU cores, to run all its code efficiently. However, this means that we cannot execute any blocking operations on those threads since it will negatively impact the performance of our application.</p>&#13;
			<p>To solve this issue, we can use a coroutine builder we're already familiar with: <strong class="source-inline">launch()</strong>. Let's see how this works:</p>&#13;
			<p class="source-code">router.delete("/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        val id = ctx.request().getParam("id").toInt()</p>&#13;
			<p class="source-code">        db.preparedQuery("DELETE FROM cats WHERE ID = $1")            .execute(Tuple.of(id)).await()</p>&#13;
			<p class="source-code">        ctx.end()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Since our<a id="_idIndexMarker720"/> verticle extends <strong class="source-inline">CoroutineVerticle</strong>, we have access to all the regular coroutine builders that will run on the Event Loop.</p>&#13;
			<p>Now, all we need to do is mark our routing functions with the <strong class="source-inline">suspend</strong> keyword:</p>&#13;
			<p class="source-code">private suspend fun router(): Router {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p class="source-code">private suspend fun catsRouter(): Router {</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Now, let's add another test for updating a cat:</p>&#13;
			<p class="source-code">@Test</p>&#13;
			<p class="source-code">fun `put updates a cat by ID`() {</p>&#13;
			<p class="source-code">    runBlocking {</p>&#13;
			<p class="source-code">        val catId = catRow.getInteger(0)</p>&#13;
			<p class="source-code">        val requestBody = json {</p>&#13;
			<p class="source-code">            obj("name" to "Meatloaf", "age" to 4)</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">        client.put("/cats/${catId}")</p>&#13;
			<p class="source-code">            .sendBuffer(Buffer.buffer(requestBody.toString()))</p>&#13;
			<p class="source-code">            .await()</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">        val result = db.preparedQuery("SELECT * FROM cats </p>&#13;
			<p class="source-code">            WHERE id = $1")</p>&#13;
			<p class="source-code">            .execute(Tuple.of(catId)).await()</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">        assertEquals("Meatloaf",             result.first().getString("name"))</p>&#13;
			<p class="source-code">        assertEquals(4, result.first().getInteger("age"))</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>This test is very similar <a id="_idIndexMarker721"/>to the deletion test, with the only major difference being that we use <strong class="source-inline">sendBuffer</strong> and not the <strong class="source-inline">send()</strong> method, so we can send a JSON body to our <strong class="source-inline">put</strong> endpoint. </p>&#13;
			<p>We create the JSON similarly to what we saw when we implemented the <strong class="source-inline">/status</strong> endpoint earlier in this chapter.</p>&#13;
			<p>Now, let's implement the <strong class="source-inline">put</strong> endpoint for the test to pass:</p>&#13;
			<p class="source-code">router.put("/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        val id = ctx.request().getParam("id").toInt()</p>&#13;
			<p class="source-code">        val body = ctx.bodyAsJson</p>&#13;
			<p class="source-code">        db.preparedQuery("UPDATE cats SET name = $1, age =             $2 WHERE ID = $3")</p>&#13;
			<p class="source-code">            .execute(</p>&#13;
			<p class="source-code">                Tuple.of(</p>&#13;
			<p class="source-code">                    body.getString("name"),</p>&#13;
			<p class="source-code">                    body.getInteger("age"),</p>&#13;
			<p class="source-code">                    id</p>&#13;
			<p class="source-code">                )</p>&#13;
			<p class="source-code">            ).await()</p>&#13;
			<p class="source-code">        ctx.end()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, the main difference from the previous endpoint we've implemented is that this time, we need to parse our request <strong class="source-inline">body</strong>. We can do that by using the <strong class="source-inline">bodyAsJson</strong> property. Then, we can use the <strong class="source-inline">getString</strong> and <strong class="source-inline">getInteger</strong> methods, which are available in JSON, to get the new values for <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong>.</p>&#13;
			<p>With this, you <a id="_idIndexMarker722"/>should have all the required knowledge to implement other endpoints as needed. Now, let's learn how to structure our code in a better way using the concept of Event Bus since it all resides in a single large class. </p>&#13;
			<h1 id="_idParaDest-256"><a id="_idTextAnchor262"/>Communicating with Event Bus</h1>&#13;
			<p><strong class="bold">Event Bus</strong> is an<a id="_idIndexMarker723"/> implementation of the Observable design pattern, which we discussed in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>.</p>&#13;
			<p>We've already mentioned that Vert.x is based on the concept of verticles, which are isolated actors. We've already seen the other types of actors in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. Kotlin's <strong class="source-inline">coroutines</strong> library provides the <strong class="source-inline">actor()</strong> and <strong class="source-inline">producer()</strong> coroutine generators, which create a coroutine bound to a channel.</p>&#13;
			<p>Similarly, all the verticles in the Vert.x framework are bound by Event Bus and can pass messages to one another using it. Now, let's extract the code from our <strong class="source-inline">ServerVerticle</strong> class into a new class, which we'll call <strong class="source-inline">CatVerticle</strong>. </p>&#13;
			<p>Any verticle can send a message over Event Bus by choosing between the following methods:</p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">request()</strong> will send a message to only one subscriber and wait for a response.</li>&#13;
				<li><strong class="source-inline">send()</strong> will send a message to only one subscriber, without waiting for a response.</li>&#13;
				<li><strong class="source-inline">publish()</strong> will send a message to all subscribers, without waiting for a response.</li>&#13;
			</ul>&#13;
			<p>No matter which <a id="_idIndexMarker724"/>method is used to send the message, you subscribe to it using the <strong class="source-inline">consumer()</strong> method on Event Bus. </p>&#13;
			<p>Now, let's subscribe to an event in our <strong class="source-inline">CatsVerticle</strong> class:</p>&#13;
			<p class="source-code">class CatsVerticle : CoroutineVerticle() {</p>&#13;
			<p class="source-code">    override suspend fun start() {</p>&#13;
			<p class="source-code">        val db = Db.connect(vertx)</p>&#13;
			<p class="source-code">        vertx.eventBus().consumer&lt;Int&gt;("cats:delete"){req-&gt;</p>&#13;
			<p class="source-code">            launch {</p>&#13;
			<p class="source-code">                val id = req.body()</p>&#13;
			<p class="source-code">                db.preparedQuery("DELETE FROM                   cats WHERE ID = $1")</p>&#13;
			<p class="source-code">                    .execute(Tuple.of(id)).await()</p>&#13;
			<p class="source-code">                req.reply(null)</p>&#13;
			<p class="source-code">            }</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>The generic type of the <strong class="source-inline">consumer()</strong> method specifies the type of message we'll receive. In this case, it's <strong class="source-inline">Int</strong>. </p>&#13;
			<p>The string that we provide to the method – in our case, <strong class="source-inline">cats:delete</strong> – is the address we subscribe to. It can be any string, but it is good to have some convention, such as what type of object we operate on and what we want to do with it. </p>&#13;
			<p>Once the delete action has been executed, we respond to our publisher with the <strong class="source-inline">reply()</strong> method. Since we don't have any information to send back, we simply send <strong class="source-inline">null</strong>.</p>&#13;
			<p>Now, let's<a id="_idIndexMarker725"/> replace our previous <strong class="source-inline">delete</strong> route with the following code:</p>&#13;
			<p class="source-code">router.delete("/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    val id = ctx.request().getParam("id").toInt()</p>&#13;
			<p class="source-code">    vertx.eventBus().request&lt;Nothing&gt;("cats:delete", id) {</p>&#13;
			<p class="source-code">        ctx.end()</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, we send the ID of the cat we received from the request to one of our listeners using the <strong class="source-inline">request()</strong> method, and we specify that the type of our message is <strong class="source-inline">Int</strong>. We also use the same address we specified in the consumer code. </p>&#13;
			<p>Since we have split our code into a new verticle, we need to remember to start it as well. Add the following line to both the <strong class="source-inline">main()</strong> function and the <strong class="source-inline">setup()</strong> method in your test:</p>&#13;
			<p class="source-code">vertx.deployVerticle(CatsVerticle())</p>&#13;
			<p>Next, let's learn how to send complex objects over Event Bus.</p>&#13;
			<h2 id="_idParaDest-257"><a id="_idTextAnchor263"/>Sending JSON over Event Bus</h2>&#13;
			<p>As our final <a id="_idIndexMarker726"/>exercise, let's <a id="_idIndexMarker727"/>learn how to update a cat. For that, we'll need to send more than just an ID over Event Bus. </p>&#13;
			<p>Let's rewrite our <strong class="source-inline">put</strong> handler, as follows:</p>&#13;
			<p class="source-code">router.put("/:id").handler { ctx -&gt;</p>&#13;
			<p class="source-code">    launch {</p>&#13;
			<p class="source-code">        val id = ctx.request().getParam("id").toInt()</p>&#13;
			<p class="source-code">        val body: JsonObject = ctx.bodyAsJson.mergeIn(json{            obj("id" to id)</p>&#13;
			<p class="source-code">        })</p>&#13;
			<p class="source-code"> </p>&#13;
			<p class="source-code">        vertx.eventBus().request&lt;Int&gt;("cats:update", body) </p>&#13;
			<p class="source-code">          { res -&gt;</p>&#13;
			<p class="source-code">            ctx.end(res.result().body().toString())</p>&#13;
			<p class="source-code">        }</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>Here, you can see that we can send JSON objects over Event Bus easily. We merge the ID we receive as a URL parameter with the rest of the request <strong class="source-inline">body</strong> and send this JSON over an Event Bus. When a response is received, we output it back to the user.</p>&#13;
			<p>Now, let's see how we consume the event we just sent:</p>&#13;
			<p class="source-code">vertx.eventBus().consumer&lt;JsonObject&gt;("cats:update"){req -&gt;    launch {</p>&#13;
			<p class="source-code">        val body = req.body()</p>&#13;
			<p class="source-code">        db.preparedQuery("UPDATE cats SET name = $1, age =             $2 WHERE ID = $3")</p>&#13;
			<p class="source-code">            .execute(</p>&#13;
			<p class="source-code">                Tuple.of(</p>&#13;
			<p class="source-code">                    body.getString("name"),</p>&#13;
			<p class="source-code">                    body.getInteger("age"),</p>&#13;
			<p class="source-code">                    body.getInteger("id")</p>&#13;
			<p class="source-code">                )</p>&#13;
			<p class="source-code">            ).await()</p>&#13;
			<p class="source-code">        req.reply(body.getInteger("id"))</p>&#13;
			<p class="source-code">    }</p>&#13;
			<p class="source-code">}</p>&#13;
			<p>We moved our logic from <strong class="source-inline">Router</strong> to our <strong class="source-inline">CatsVerticle</strong> class, but since we use JSON to communicate, the code stayed almost the same. In our verticle, we listen to the <strong class="source-inline">cats:update</strong> event, and once we receive the response, we extract <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">id</strong> from the JSON object to confirm that the operation was successful.</p>&#13;
			<p>This concludes our chapter. There is still much for you to learn about the Vert.x framework<a id="_idIndexMarker728"/> in case you're curious, but with the knowledge you've <a id="_idIndexMarker729"/>gained from this chapter at hand, you should be able to do so with some confidence. </p>&#13;
			<h1 id="_idParaDest-258"><a id="_idTextAnchor264"/>Summary</h1>&#13;
			<p>This chapter concludes our journey into the design patterns in Kotlin. Vert.x uses actors, called verticles, to organize the logic of the application. Actors communicate between themselves using Event Bus, which is an implementation of the Observable design pattern.</p>&#13;
			<p>We also discussed the Event Loop pattern, how it allows Vert.x to process lots of events concurrently, and why it's important not to block its execution.</p>&#13;
			<p>Now, you should be able to write microservices in Kotlin using two different frameworks, and you can choose what approach works best for you.</p>&#13;
			<p>Vert.x provides a lower-level API than Ktor, which means that we may think more about how we structure our code, but the resulting application may be more performant as well. Since this is the end of this book, all that's left is for me to wish you the best of luck in learning about Kotlin and its ecosystem. You can always get some help from me and other Kotlin enthusiasts by going to <a href="https://stackoverflow.com/questions/tagged/kotlin">https://stackoverflow.com/questions/tagged/kotlin</a> and <a href="https://discuss.kotlinlang.org/">https://discuss.kotlinlang.org/</a>.</p>&#13;
			<p><em class="italic">Happy learning!</em></p>&#13;
			<h1 id="_idParaDest-259"><a id="_idTextAnchor265"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What's a verticle in Vert.x?</li>&#13;
				<li>What's the goal of the Event Bus?</li>&#13;
				<li>Why shouldn't we block the Event Loop?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>