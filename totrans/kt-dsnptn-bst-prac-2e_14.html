<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-245"><em class="italic"><a id="_idTextAnchor251"/>Chapter 11</em>: Reactive Microservices with Vert.x</h1>&#13;
			<p>In the previous chapter, we familiarized ourselves with the Ktor framework. We created a web service that could store cats in its database. </p>&#13;
			<p>In this chapter, we'll continue working on the example from the previous chapter, but this time using the Vert.x framework and Kotlin. <strong class="bold">Vert.x</strong> is a Reactive framework that is built on top of Reactive principles, which we discussed in <a href="B17816_07_ePub.xhtml#_idTextAnchor178"><em class="italic">Chapter 7</em></a>, <em class="italic">Controlling the Data Flow</em>. We'll list some of the other benefits of the Vert.x framework in this chapter. You can always read more about Vert.x by going to the official website: <a href="https://vertx.io">https://vertx.io</a>.</p>&#13;
			<p>The microservice we'll develop in this chapter will provide an endpoint for health checks – the same as the one we created in Ktor – and will be able to delete and update the cats in our database.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Getting started with Vert.x</li>&#13;
				<li>Routing in Vert.x</li>&#13;
				<li>Verticles</li>&#13;
				<li>Handling requests</li>&#13;
				<li>Testing Vert.x applications</li>&#13;
				<li>Working with databases</li>&#13;
				<li>Understanding Event Loop</li>&#13;
				<li>Communicating with Event Bus</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-246"><a id="_idTextAnchor252"/>Technical requirements</h1>&#13;
			<p>For this chapter, you'll need the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">JDK 11</strong> or later</li>&#13;
				<li>IntelliJ IDEA</li>&#13;
				<li><strong class="bold">Gradle 6.8</strong> or later</li>&#13;
				<li><strong class="bold">PostgreSQL 14</strong> or later</li>&#13;
			</ul>&#13;
			<p>Like the previous chapter, this chapter will also assume that you have PostgreSQL already installed and that you have basic knowledge of working with it. We'll also use the same table structure we created with Ktor.</p>&#13;
			<p>You can find the full source code for this chapter here: <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter11</a>.</p>&#13;
			<h1 id="_idParaDest-247"><a id="_idTextAnchor253"/>Getting started with Vert.x</h1>&#13;
			<p><strong class="bold">Vert.x</strong> is a Reactive<a id="_idIndexMarker693"/> framework that is asynchronous and non-blocking. Let's understand what this means by looking at a concrete example.</p>&#13;
			<p>We'll start by creating a new Kotlin Gradle project or by using <a href="http://start.vertx.io">start.vertx.io</a>:</p>&#13;
			<ol>&#13;
				<li>From your IntelliJ IDEA application, select <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project</strong> and choose <strong class="bold">Kotlin</strong> from the <strong class="bold">New Project</strong> wizard.</li>&#13;
				<li>Then, specify a name for your project – <code>CatsShelterVertx</code>, in my case – and choose <strong class="bold">Gradle Kotlin</strong> as your <strong class="bold">Build System</strong>. </li>&#13;
				<li>Then, select the <strong class="bold">Project JDK</strong> version that you have installed from the dropdown. The output should look as follows:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/Figure_11.1_B17816.jpg" alt="Figure 11.1 – Creating a Kotlin application&#13;&#10;" width="1061" height="768"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 11.1 – Creating a Kotlin application</p>&#13;
			<p>Next, add the<a id="_idIndexMarker694"/> following dependencies to your <code>build.gradle.kts</code> file:</p>&#13;
			<pre>val vertxVersion = "4.1.5"</pre>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    implementation("io.vertx:vertx-core:$vertxVersion")</pre>&#13;
			<pre>    implementation("io.vertx:vertx-web:$vertxVersion")</pre>&#13;
			<pre>    implementation("io.vertx:vertx-lang-</pre>&#13;
			<pre>        kotlin:$vertxVersion")</pre>&#13;
			<pre>    implementation("io.vertx:vertx-lang-kotlin-</pre>&#13;
			<pre>        coroutines:$vertxVersion")</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Similar to what we discussed in the previous chapter, all the dependencies must be of the same version to avoid any conflicts. That's the reason we are using a variable for the library version – to be able to change all of them together.</p>&#13;
			<p>The following is an explanation of each dependency:</p>&#13;
			<ul>&#13;
				<li><code>vertx-core</code> is the core library.</li>&#13;
				<li><code>vertx-web</code> is needed since we want our service to be REST-based.</li>&#13;
				<li><code>vertx-lang-kotlin</code> provides idiomatic ways to write Kotlin code with Vert.x.</li>&#13;
				<li>Finally, <code>vertx-lang-kotlin-coroutines</code> integrates with the coroutines, which we discussed in detail in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>.</li>&#13;
			</ul>&#13;
			<p>Then, we must <a id="_idIndexMarker695"/>create a file called <code>server.kt</code> in the <code>src/main/kotlin</code> folder with the following content:</p>&#13;
			<pre>fun main() {</pre>&#13;
			<pre>    val vertx = Vertx.vertx()</pre>&#13;
			<pre>    vertx.createHttpServer().requestHandler{ ctx -&gt;</pre>&#13;
			<pre>        ctx.response().end("OK")</pre>&#13;
			<pre>    }.listen(8081)</pre>&#13;
			<pre>    println("open http://localhost:8081")</pre>&#13;
			<pre>}</pre>&#13;
			<p>That's all you need to start a web server that will respond with <code>OK</code> when you open <code>http://localhost:8081</code> in your browser. </p>&#13;
			<p>Now, let's understand what happens here. First, we create a Vert.x instance using the Factory method from <a href="B17816_03_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Structural Patterns</em>. </p>&#13;
			<p>The <code>requestHandler</code> method is just a simple listener or a subscriber. If you don't remember how it works, check out <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, for the Observable design pattern. In our case, it will be called for each new request. That's the asynchronous nature of Vert.x in action. </p>&#13;
			<p>Next, let's learn how to add routes in Vert.x.</p>&#13;
			<h1 id="_idParaDest-248"><a id="_idTextAnchor254"/>Routing in Vert.x</h1>&#13;
			<p>Notice that no<a id="_idIndexMarker696"/> matter which URL we specify, we always get the same result. Of course, that's not what we want to achieve. Let's start by adding the most basic endpoint, which will only tell us that the service is up and running. </p>&#13;
			<p>For that, we'll use <code>Router</code>:</p>&#13;
			<pre>val vertx = Vertx.vertx()  </pre>&#13;
			<pre>val router = Router.router(vertx) </pre>&#13;
			<pre>...</pre>&#13;
			<p><code>Router</code> lets you specify handlers for different HTTP methods and URLs.</p>&#13;
			<p>Now, let's add a <code>/status</code> endpoint that will return an HTTP status code of <code>200</code> and a message stating <code>OK</code> to our user:</p>&#13;
			<pre>router.get("/status").handler { ctx -&gt;</pre>&#13;
			<pre>    ctx.response()</pre>&#13;
			<pre>        .setStatusCode(200)</pre>&#13;
			<pre>        .end("OK")</pre>&#13;
			<pre>} </pre>&#13;
			<pre>vertx.createHttpServer()</pre>&#13;
			<pre>    .requestHandler(router)</pre>&#13;
			<pre>    .listen(8081)</pre>&#13;
			<p>Now, instead of specifying the request handler as a block, we will pass this function to our <code>router</code> object. This makes our code easier to manage.</p>&#13;
			<p>We learned how we return a flat text response in the very first example. So, now, let's return JSON instead. Most real-life applications use JSON for communication. Let's replace the body of our status handler with the following code:</p>&#13;
			<pre>val json = json {</pre>&#13;
			<pre>    obj(</pre>&#13;
			<pre>        "status" to "OK"</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>}</pre>&#13;
			<pre>ctx.response()</pre>&#13;
			<pre>    .setStatusCode(200)</pre>&#13;
			<pre>    .end(json.toString())</pre>&#13;
			<p>Here, we are using a DSL, which we discussed in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>, to create a JSON object. </p>&#13;
			<p>You can open <code>http://localhost:8081/status</code> in your browser and make sure that you get <code>{"status": "OK"}</code> as a response.</p>&#13;
			<p>Now, let's <a id="_idIndexMarker697"/>discuss how we can structure our code better with the Vert.x framework.</p>&#13;
			<h1 id="_idParaDest-249"><a id="_idTextAnchor255"/>Verticles</h1>&#13;
			<p>Our current<a id="_idIndexMarker698"/> code <a id="_idIndexMarker699"/>resides in the <code>server.kt</code> file, which is getting bigger and bigger. We need to find a way to split it. In Vert.x, code is split into classes called <strong class="bold">verticles</strong>.</p>&#13;
			<p>You can think of a verticle as a lightweight actor. We discussed Actors in <a href="B17816_05_ePub.xhtml#_idTextAnchor144"><em class="italic">Chapter 5</em></a>, <em class="italic">Introducing Functional Programming</em>. </p>&#13;
			<p>Let's see how we can create a new verticle that will encapsulate our server:</p>&#13;
			<pre>class ServerVerticle : CoroutineVerticle() {</pre>&#13;
			<pre>    override suspend fun start() {</pre>&#13;
			<pre>        val router = router()</pre>&#13;
			<pre>        vertx.createHttpServer()</pre>&#13;
			<pre>            .requestHandler(router)</pre>&#13;
			<pre>            .listen(8081)</pre>&#13;
			<pre>        println("open http://localhost:8081")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    private fun router(): Router {</pre>&#13;
			<pre>        // Our router code comes here now  </pre>&#13;
			<pre>        val router = Router.router(vertx)</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre> </pre>&#13;
			<pre>        return router</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Every verticle has a <code>start()</code> method that handles its initialization. As you can see, we moved all the code from our <code>main()</code> function to the <code>start()</code> method. If we run the code now, though, nothing <a id="_idIndexMarker700"/>will <a id="_idIndexMarker701"/>happen. That's because the verticle hasn't been started yet.</p>&#13;
			<p>There are different ways to start a verticle, but the simplest way is to pass the instance of the class to the <code>deployVerticle()</code> method. In our case, this is the <code>ServerVerticle</code> class:</p>&#13;
			<pre>fun main() {</pre>&#13;
			<pre>    val vertx = Vertx.vertx()</pre>&#13;
			<pre>    vertx.deployVerticle(ServerVerticle())</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here is another, more flexible way to specify the class name as a string:</p>&#13;
			<pre>fun main() {</pre>&#13;
			<pre>    val vertx = Vertx.vertx()</pre>&#13;
			<pre>    vertx.deployVerticle("ServerVerticle")</pre>&#13;
			<pre>}</pre>&#13;
			<p>If our verticle class is not in the default package, we'll need to specify the fully qualified path for Vert.x to be able to initialize it.</p>&#13;
			<p>Now, our code has been split into two files, <code>ServerVerticle.kt</code> and <code>server.kt</code>, and is organized better. Next, we'll learn how we can do the same refactoring to organize our <a id="_idIndexMarker702"/>routes <a id="_idIndexMarker703"/>in a better way.</p>&#13;
			<h1 id="_idParaDest-250"><a id="_idTextAnchor256"/>Handling requests</h1>&#13;
			<p>As we <a id="_idIndexMarker704"/>discussed <a id="_idIndexMarker705"/>earlier in this chapter, all requests in Vert.x are handled by the <code>Router</code> class. We covered the concept of routing in the previous chapter, so now, let's just discuss the differences between the Ktor and Vert.x approaches to routing requests.</p>&#13;
			<p>We'll declare two endpoints to delete cats from the database and update information about a particular cat. We'll use the <code>delete</code> and <code>put</code> verbs, respectively, for this:</p>&#13;
			<pre>router.delete("/cats/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    // Code for deleting a cat</pre>&#13;
			<pre>}</pre>&#13;
			<pre>router.put("/cats/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    // Code for updating a cat</pre>&#13;
			<pre>}</pre>&#13;
			<p>Both endpoints receive a URL parameter. In Vert.x, we use a colon notation for this.</p>&#13;
			<p>To be able to parse JSON requests and responses, Vert.x has a <code>BodyHandler</code> class. Now, let's declare it as well. This should come just after the instantiation of our router:</p>&#13;
			<pre>val router = Router.router(vertx)</pre>&#13;
			<pre>router.route().handler(BodyHandler.create())</pre>&#13;
			<p>This will tell Vert.x to parse the request body into JSON for any request. </p>&#13;
			<p>Notice that the <code>/cat</code> prefix is repeated multiple times in our code now. To avoid that and make our code more modular, we can use a subrouter, which we'll discuss in the next section.</p>&#13;
			<h2 id="_idParaDest-251"><a id="_idTextAnchor257"/>Subrouting the requests</h2>&#13;
			<p><strong class="bold">Subrouting</strong> allows us <a id="_idIndexMarker706"/>to split routes into multiple classes to keep our code more organized. Let's move the new routes to a new function by following these steps:</p>&#13;
			<ol>&#13;
				<li value="1">We'll leave the <code>/alive</code> endpoint as is, but we'll extract all the other endpoints into a separate function:<pre>private fun catsRouter(): Router {
    val router = Router.router(vertx)
    router.delete("/:id").handler { ctx -&gt;
        // Code for deleting a cat
    }
    router.put("/:id").handler { ctx -&gt;
        // Code for updating a cat
    }
    return router
}</pre><p>Inside this function, we create a separate <code>Router</code> object that will only handle the routes for cats, not the status routes. </p></li>&#13;
				<li>Now, we need to connect <code>SubRouter</code> to our main router:<pre>router.mountSubRouter("/cats", catsRouter())</pre><p>Keeping our code clean and well separated is very important. Extracting routes into subrouters helps us with that.</p></li>&#13;
			</ol>&#13;
			<p>Now, let's discuss how this code can be tested.</p>&#13;
			<h1 id="_idParaDest-252"><a id="_idTextAnchor258"/>Testing Vert.x applications</h1>&#13;
			<p>To test <a id="_idIndexMarker707"/>our Vert.x application, we'll use the <strong class="bold">JUnit 5</strong> framework, which we discussed in the previous chapter. </p>&#13;
			<p>You'll need the following two dependencies in your <code>build.gradle.kts</code> file:</p>&#13;
			<pre>dependencies {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>    testImplementation("org.junit.jupiter:junit-jupiter-</pre>&#13;
			<pre>        api:5.6.0")</pre>&#13;
			<pre>    testRuntimeOnly("org.junit.jupiter:junit-jupiter-</pre>&#13;
			<pre>        engine:5.6.0")</pre>&#13;
			<pre>}</pre>&#13;
			<p>Our first test will be located in the <code>/src/test/kotlin/ServerTest.kt</code> file.</p>&#13;
			<p>The basic structure of all the integration tests looks something like this:</p>&#13;
			<pre>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</pre>&#13;
			<pre>class ServerTest {</pre>&#13;
			<pre>    private val vertx: Vertx = Vertx.vertx()</pre>&#13;
			<pre> </pre>&#13;
			<pre>    @BeforeAll</pre>&#13;
			<pre>    fun setup() {</pre>&#13;
			<pre>        runBlocking {</pre>&#13;
			<pre>            vertx.deployVerticle(ServerVerticle()).await()</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    @AfterAll</pre>&#13;
			<pre>    fun tearDown() {</pre>&#13;
			<pre>        // And you want to stop your server once</pre>&#13;
			<pre>        vertx.close()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    </pre>&#13;
			<pre>    @Test</pre>&#13;
			<pre>    fun `status should return 200`() {</pre>&#13;
			<pre> </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This structure is different from what we've seen in Ktor. Here, we start the server ourselves, in the <code>setup()</code> method. </p>&#13;
			<p>Since Vert.x is Reactive, the <code>deployVerticle()</code> method will return a <code>Future</code> object<a id="_idIndexMarker708"/> immediately, releasing the thread, but that doesn't mean that the server verticle has started yet.</p>&#13;
			<p>To avoid this race, we can use the <code>await()</code> method, which will block the execution of our tests until the server is ready to receive requests.</p>&#13;
			<p>Now, we want to issue an actual HTTP call to our <code>/status</code> endpoint, for example, and check the response code. For that, we'll use the Vert.x web client. </p>&#13;
			<p>Let's add it to our <code>build.gradle.kts</code> dependencies section:</p>&#13;
			<pre>testImplementation("io.vertx:vertx-web-client:$vertxVersion")</pre>&#13;
			<p>Since we only plan to use <code>WebClient</code> in tests, we specify <code>testImplementation</code> instead of <code>implementation</code>. But <code>WebClient</code> is so useful that you'll probably end up using it in your production code anyway.</p>&#13;
			<p>After adding this new dependency, we need to instantiate our web client in the <code>setup</code> method:</p>&#13;
			<pre>lateinit var client: WebClient</pre>&#13;
			<pre>@BeforeAll</pre>&#13;
			<pre>fun setup() {</pre>&#13;
			<pre>    vertx.deployVerticle(ServerVerticle())</pre>&#13;
			<pre>    client = WebClient.create(</pre>&#13;
			<pre>        vertx,</pre>&#13;
			<pre>        WebClientOptions()</pre>&#13;
			<pre>            .setDefaultPort(8081)</pre>&#13;
			<pre>            .setDefaultHost("localhost")</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>}</pre>&#13;
			<p>The <code>setup()</code> method <a id="_idIndexMarker709"/>will be called once before all the tests start. In this method, we are deploying our server verticle and creating a web client with some defaults for all our tests to share.</p>&#13;
			<p>Now, let's write a test to check that our server is up and running:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `status should return 200`() {</pre>&#13;
			<pre>    runBlocking {</pre>&#13;
			<pre>        val response = client.get("/status").send().await()</pre>&#13;
			<pre>        assertEquals(201, response.statusCode())</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's understand what happens in this test:</p>&#13;
			<ul>&#13;
				<li><code>client</code> is an instance of <code>WebClient</code> that is shared by all our tests. We invoke the <code>/status</code> endpoint using the <code>get</code> verb. This is a Builder design pattern, so to issue our request, we need to use the <code>send()</code> method. Otherwise, nothing will happen.</li>&#13;
				<li>Vert.x is a Reactive framework, so instead of blocking our thread until a response is received, the <code>send()</code> method returns a Future. Then, we use <code>await()</code>, which adapts a Future to a Kotlin coroutine to be able to wait for the results concurrently.</li>&#13;
				<li>Once the response is received, we check it in the same way that we did in other tests – by using the <code>assertEquals</code> function, which comes from JUnit.</li>&#13;
			</ul>&#13;
			<p>Now that we <a id="_idIndexMarker710"/>know how to write tests in Vert.x, let's discuss how we can work with databases in a Reactive manner.</p>&#13;
			<h1 id="_idParaDest-253"><a id="_idTextAnchor259"/>Working with databases</h1>&#13;
			<p>To be able to <a id="_idIndexMarker711"/>progress further with our tests, we need the ability to create entities in the database. For that, we'll need to connect to the database.</p>&#13;
			<p>First, let's add the following two lines to our <code>build.gradle.kts</code> dependencies section:</p>&#13;
			<pre>implementation("org.postgresql:postgresql:42.3.0")</pre>&#13;
			<pre>implementation("io.vertx:vertx-pg-client:$vertxVersion")</pre>&#13;
			<p>The first line of code fetches the PostgreSQL driver. The second one adds the Vert.x JDBC client, which allows Vert.x, which has the driver, to connect to any database that supports JDBC.</p>&#13;
			<h2 id="_idParaDest-254"><a id="_idTextAnchor260"/>Managing configuration</h2>&#13;
			<p>Now, we want<a id="_idIndexMarker712"/> to hold the database configuration somewhere. For local development, it may be fine to have those configurations hardcoded. We'll execute the following steps to do this:</p>&#13;
			<ol>&#13;
				<li value="1">When we connect to the database, we need to specify the following parameters at the very least:<ul><li>Username</li><li>Password</li><li>Host</li><li>Database name</li></ul><p>We'll store the preceding parameters in a <code>Singleton</code> object:</p><pre>object Db {
    val username = System.getenv("DATABASE_USERNAME")         ?: "cats_admin"
    val password = System.getenv("DATABASE_PASSWORD")         ?: "abcd1234"
    val database = System.getenv("DATABASE_NAME")         ?: "cats_db"
    val host = System.getenv("DATABASE_HOST")         ?: "localhost"
}</pre><p>Our <code>Singleton</code> object has four members. For each, we check whether an environment <a id="_idIndexMarker713"/>variable was set, and if there's no such environment variable, we provide a default value using the Elvis operator.</p></li>&#13;
				<li>Now, let's add a function that will return a connection pool:<pre>fun connect(vertx: Vertx): SqlClient {
    val connectOptions = PgConnectOptions()
        .setPort(5432)
        .setHost(host)
        .setDatabase(database)
        .setUser(username)
        .setPassword(password)
 
    val poolOptions = PoolOptions()
        .setMaxSize(20)
 
    return PgPool.client(
        vertx,
        connectOptions,
        poolOptions
    )
}</pre><p>Our <code>connect()</code> method creates two configuration objects: <code>PgConnectOptions</code> sets the configuration for the database we want to connect <a id="_idIndexMarker714"/>to, while <code>PoolOptions</code> specifies the configuration of the connection pool.</p></li>&#13;
				<li>Now, all we need to do is instantiate the database client in our test:<pre>...
lateinit var db: SqlClient
 
@BeforeAll
fun setup() {
    runBlocking {
        ...
        db = Db.connect(vertx)
    }
}</pre></li>&#13;
				<li>Having done that, let's create a new <code>Nested</code> class in our test file for cases where we expect to have a cat in our database:<pre>@Nested
inner class `With Cat` {
    @BeforeEach
    fun createCats() {
        ...
    }
    
    @AfterEach
    fun deleteAll() {
        ...
    }
}</pre><p>Unlike the Exposed<a id="_idIndexMarker715"/> framework, which we discussed in the previous chapter, the database client in Vert.x doesn't have specific methods for insertion, deletion, and so on. Instead, it provides a lower-level API that allows us to execute any type of query on the database. </p></li>&#13;
				<li>First, let's write a query that will clean our database:<pre>@AfterEach
fun deleteAll() {
    runBlocking {
        db.preparedQuery("DELETE FROM cats")            .execute().await()
    }
}</pre><p>The basic structure for working with the database client in Vert.x is to pass a query to the <code>prepareQuery()</code> method, then execute it using <code>execute()</code>.</p><p>We want to wait for the query to complete before we move on to the next test, so we use the <code>await()</code> function to wait for the current coroutine, and we use the <code>runBlocking()</code> adapter method to have a coroutine context to do so.</p></li>&#13;
				<li>Now, let's <a id="_idIndexMarker716"/>write another query that will add a cat to the database before each test runs:<pre>lateinit var catRow: Row
 
@BeforeEach
fun createCats() {
    runBlocking {
        val result = db.preparedQuery(
            """INSERT INTO cats (name, age) 
            VALUES ($1, $2) 
            RETURNING ID""".trimIndent()
        ).execute(Tuple.of("Binky", 7)).await()
        catRow = result.first()
    }
}</pre><p>Here, we are using the <code>preparedQuery()</code> method once more, but this time, our SQL query string contains placeholders. Each placeholder starts with a dollar sign and their indexes start with <code>1</code>.</p><p>Then, we pass the values for those placeholders to the <code>execute()</code> method. <code>Tuple.of</code> is a Factory method design pattern that you should be able to recognize well by now.</p><p>We also want to remember the ID of the cat that we create since we'll use that ID to delete or update the cat. For this reason, we store the created row in a <code>lateinit</code> variable. </p></li>&#13;
				<li>We now <a id="_idIndexMarker717"/>have everything prepared to write our test:<pre>@Test
fun `delete deletes a cat by ID`() {
    runBlocking {
        val catId = catRow.getInteger(0)
        client.delete("/cats/${catId}").send().await()
 
        val result = db.preparedQuery("SELECT * FROM             cats WHERE id = $1")            .execute(Tuple.of(catId)).await()
 
        assertEquals(0, result.size())
    }
}</pre><p>First, we get the ID of the cat we want to delete from the database row using the <code>getInteger()</code> method. Unlike parameters that start with <code>1</code>, the columns of a database row start with <code>0</code>. So, by getting an integer at index <code>0</code>, we get the ID of our cat.</p><p>Then, we invoke the web client's <code>delete()</code> method and wait for it to complete.</p><p>Afterward, we execute a <code>SELECT</code> statement on our database, checking that the row was indeed deleted.</p></li>&#13;
			</ol>&#13;
			<p>If you run this test now, it will fail, because we haven't implemented the <code>delete</code> endpoint <a id="_idIndexMarker718"/>yet. We'll do that in the next section.</p>&#13;
			<h1 id="_idParaDest-255"><a id="_idTextAnchor261"/>Understanding Event Loop</h1>&#13;
			<p>The goal of <a id="_idIndexMarker719"/>the <strong class="bold">Event Loop</strong> design pattern is to continuously check for new events in a queue, and each time a new event comes in, to quickly dispatch it to someone who knows how to handle it. This way, a single thread or a very limited number of threads can handle a huge number of events.</p>&#13;
			<p>In the case of web frameworks such as Vert.x, events may be requests to our server.</p>&#13;
			<p>To understand the concept of the Event Loop better, let's go back to our server code and attempt to implement an endpoint for deleting a cat:</p>&#13;
			<pre>val db = Db.connect(vertx)</pre>&#13;
			<pre>router.delete("/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    val id = ctx.request().getParam("id").toInt()</pre>&#13;
			<pre>    db.preparedQuery("DELETE FROM cats WHERE ID = $1")        .execute(Tuple.of(id)).await()</pre>&#13;
			<pre>    ctx.end()</pre>&#13;
			<pre>}</pre>&#13;
			<p>This code is very similar to what we've written in our tests in the previous section. We read the URL parameter from the request using the <code>getParam()</code> function, then we pass this ID to the prepared query. This time, though, we can't use the <code>runBlocking</code> adapter function, since it will block the Event Loop.</p>&#13;
			<p>Vert.x uses a limited number of threads, as many as twice the number of your CPU cores, to run all its code efficiently. However, this means that we cannot execute any blocking operations on those threads since it will negatively impact the performance of our application.</p>&#13;
			<p>To solve this issue, we can use a coroutine builder we're already familiar with: <code>launch()</code>. Let's see how this works:</p>&#13;
			<pre>router.delete("/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    launch {</pre>&#13;
			<pre>        val id = ctx.request().getParam("id").toInt()</pre>&#13;
			<pre>        db.preparedQuery("DELETE FROM cats WHERE ID = $1")            .execute(Tuple.of(id)).await()</pre>&#13;
			<pre>        ctx.end()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Since our<a id="_idIndexMarker720"/> verticle extends <code>CoroutineVerticle</code>, we have access to all the regular coroutine builders that will run on the Event Loop.</p>&#13;
			<p>Now, all we need to do is mark our routing functions with the <code>suspend</code> keyword:</p>&#13;
			<pre>private suspend fun router(): Router {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<pre>private suspend fun catsRouter(): Router {</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, let's add another test for updating a cat:</p>&#13;
			<pre>@Test</pre>&#13;
			<pre>fun `put updates a cat by ID`() {</pre>&#13;
			<pre>    runBlocking {</pre>&#13;
			<pre>        val catId = catRow.getInteger(0)</pre>&#13;
			<pre>        val requestBody = json {</pre>&#13;
			<pre>            obj("name" to "Meatloaf", "age" to 4)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        client.put("/cats/${catId}")</pre>&#13;
			<pre>            .sendBuffer(Buffer.buffer(requestBody.toString()))</pre>&#13;
			<pre>            .await()</pre>&#13;
			<pre> </pre>&#13;
			<pre>        val result = db.preparedQuery("SELECT * FROM cats </pre>&#13;
			<pre>            WHERE id = $1")</pre>&#13;
			<pre>            .execute(Tuple.of(catId)).await()</pre>&#13;
			<pre> </pre>&#13;
			<pre>        assertEquals("Meatloaf",             result.first().getString("name"))</pre>&#13;
			<pre>        assertEquals(4, result.first().getInteger("age"))</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>This test is very similar <a id="_idIndexMarker721"/>to the deletion test, with the only major difference being that we use <code>sendBuffer</code> and not the <code>send()</code> method, so we can send a JSON body to our <code>put</code> endpoint. </p>&#13;
			<p>We create the JSON similarly to what we saw when we implemented the <code>/status</code> endpoint earlier in this chapter.</p>&#13;
			<p>Now, let's implement the <code>put</code> endpoint for the test to pass:</p>&#13;
			<pre>router.put("/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    launch {</pre>&#13;
			<pre>        val id = ctx.request().getParam("id").toInt()</pre>&#13;
			<pre>        val body = ctx.bodyAsJson</pre>&#13;
			<pre>        db.preparedQuery("UPDATE cats SET name = $1, age =             $2 WHERE ID = $3")</pre>&#13;
			<pre>            .execute(</pre>&#13;
			<pre>                Tuple.of(</pre>&#13;
			<pre>                    body.getString("name"),</pre>&#13;
			<pre>                    body.getInteger("age"),</pre>&#13;
			<pre>                    id</pre>&#13;
			<pre>                )</pre>&#13;
			<pre>            ).await()</pre>&#13;
			<pre>        ctx.end()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, the main difference from the previous endpoint we've implemented is that this time, we need to parse our request <code>body</code>. We can do that by using the <code>bodyAsJson</code> property. Then, we can use the <code>getString</code> and <code>getInteger</code> methods, which are available in JSON, to get the new values for <code>name</code> and <code>age</code>.</p>&#13;
			<p>With this, you <a id="_idIndexMarker722"/>should have all the required knowledge to implement other endpoints as needed. Now, let's learn how to structure our code in a better way using the concept of Event Bus since it all resides in a single large class. </p>&#13;
			<h1 id="_idParaDest-256"><a id="_idTextAnchor262"/>Communicating with Event Bus</h1>&#13;
			<p><strong class="bold">Event Bus</strong> is an<a id="_idIndexMarker723"/> implementation of the Observable design pattern, which we discussed in <a href="B17816_04_ePub.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Familiar with Behavioral Patterns</em>.</p>&#13;
			<p>We've already mentioned that Vert.x is based on the concept of verticles, which are isolated actors. We've already seen the other types of actors in <a href="B17816_06_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 6</em></a>, <em class="italic">Threads and Coroutines</em>. Kotlin's <code>coroutines</code> library provides the <code>actor()</code> and <code>producer()</code> coroutine generators, which create a coroutine bound to a channel.</p>&#13;
			<p>Similarly, all the verticles in the Vert.x framework are bound by Event Bus and can pass messages to one another using it. Now, let's extract the code from our <code>ServerVerticle</code> class into a new class, which we'll call <code>CatVerticle</code>. </p>&#13;
			<p>Any verticle can send a message over Event Bus by choosing between the following methods:</p>&#13;
			<ul>&#13;
				<li><code>request()</code> will send a message to only one subscriber and wait for a response.</li>&#13;
				<li><code>send()</code> will send a message to only one subscriber, without waiting for a response.</li>&#13;
				<li><code>publish()</code> will send a message to all subscribers, without waiting for a response.</li>&#13;
			</ul>&#13;
			<p>No matter which <a id="_idIndexMarker724"/>method is used to send the message, you subscribe to it using the <code>consumer()</code> method on Event Bus. </p>&#13;
			<p>Now, let's subscribe to an event in our <code>CatsVerticle</code> class:</p>&#13;
			<pre>class CatsVerticle : CoroutineVerticle() {</pre>&#13;
			<pre>    override suspend fun start() {</pre>&#13;
			<pre>        val db = Db.connect(vertx)</pre>&#13;
			<pre>        vertx.eventBus().consumer&lt;Int&gt;("cats:delete"){req-&gt;</pre>&#13;
			<pre>            launch {</pre>&#13;
			<pre>                val id = req.body()</pre>&#13;
			<pre>                db.preparedQuery("DELETE FROM                   cats WHERE ID = $1")</pre>&#13;
			<pre>                    .execute(Tuple.of(id)).await()</pre>&#13;
			<pre>                req.reply(null)</pre>&#13;
			<pre>            }</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The generic type of the <code>consumer()</code> method specifies the type of message we'll receive. In this case, it's <code>Int</code>. </p>&#13;
			<p>The string that we provide to the method – in our case, <code>cats:delete</code> – is the address we subscribe to. It can be any string, but it is good to have some convention, such as what type of object we operate on and what we want to do with it. </p>&#13;
			<p>Once the delete action has been executed, we respond to our publisher with the <code>reply()</code> method. Since we don't have any information to send back, we simply send <code>null</code>.</p>&#13;
			<p>Now, let's<a id="_idIndexMarker725"/> replace our previous <code>delete</code> route with the following code:</p>&#13;
			<pre>router.delete("/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    val id = ctx.request().getParam("id").toInt()</pre>&#13;
			<pre>    vertx.eventBus().request&lt;Nothing&gt;("cats:delete", id) {</pre>&#13;
			<pre>        ctx.end()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we send the ID of the cat we received from the request to one of our listeners using the <code>request()</code> method, and we specify that the type of our message is <code>Int</code>. We also use the same address we specified in the consumer code. </p>&#13;
			<p>Since we have split our code into a new verticle, we need to remember to start it as well. Add the following line to both the <code>main()</code> function and the <code>setup()</code> method in your test:</p>&#13;
			<pre>vertx.deployVerticle(CatsVerticle())</pre>&#13;
			<p>Next, let's learn how to send complex objects over Event Bus.</p>&#13;
			<h2 id="_idParaDest-257"><a id="_idTextAnchor263"/>Sending JSON over Event Bus</h2>&#13;
			<p>As our final <a id="_idIndexMarker726"/>exercise, let's <a id="_idIndexMarker727"/>learn how to update a cat. For that, we'll need to send more than just an ID over Event Bus. </p>&#13;
			<p>Let's rewrite our <code>put</code> handler, as follows:</p>&#13;
			<pre>router.put("/:id").handler { ctx -&gt;</pre>&#13;
			<pre>    launch {</pre>&#13;
			<pre>        val id = ctx.request().getParam("id").toInt()</pre>&#13;
			<pre>        val body: JsonObject = ctx.bodyAsJson.mergeIn(json{            obj("id" to id)</pre>&#13;
			<pre>        })</pre>&#13;
			<pre> </pre>&#13;
			<pre>        vertx.eventBus().request&lt;Int&gt;("cats:update", body) </pre>&#13;
			<pre>          { res -&gt;</pre>&#13;
			<pre>            ctx.end(res.result().body().toString())</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, you can see that we can send JSON objects over Event Bus easily. We merge the ID we receive as a URL parameter with the rest of the request <code>body</code> and send this JSON over an Event Bus. When a response is received, we output it back to the user.</p>&#13;
			<p>Now, let's see how we consume the event we just sent:</p>&#13;
			<pre>vertx.eventBus().consumer&lt;JsonObject&gt;("cats:update"){req -&gt;    launch {</pre>&#13;
			<pre>        val body = req.body()</pre>&#13;
			<pre>        db.preparedQuery("UPDATE cats SET name = $1, age =             $2 WHERE ID = $3")</pre>&#13;
			<pre>            .execute(</pre>&#13;
			<pre>                Tuple.of(</pre>&#13;
			<pre>                    body.getString("name"),</pre>&#13;
			<pre>                    body.getInteger("age"),</pre>&#13;
			<pre>                    body.getInteger("id")</pre>&#13;
			<pre>                )</pre>&#13;
			<pre>            ).await()</pre>&#13;
			<pre>        req.reply(body.getInteger("id"))</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>We moved our logic from <code>Router</code> to our <code>CatsVerticle</code> class, but since we use JSON to communicate, the code stayed almost the same. In our verticle, we listen to the <code>cats:update</code> event, and once we receive the response, we extract <code>name</code>, <code>age</code>, and <code>id</code> from the JSON object to confirm that the operation was successful.</p>&#13;
			<p>This concludes our chapter. There is still much for you to learn about the Vert.x framework<a id="_idIndexMarker728"/> in case you're curious, but with the knowledge you've <a id="_idIndexMarker729"/>gained from this chapter at hand, you should be able to do so with some confidence. </p>&#13;
			<h1 id="_idParaDest-258"><a id="_idTextAnchor264"/>Summary</h1>&#13;
			<p>This chapter concludes our journey into the design patterns in Kotlin. Vert.x uses actors, called verticles, to organize the logic of the application. Actors communicate between themselves using Event Bus, which is an implementation of the Observable design pattern.</p>&#13;
			<p>We also discussed the Event Loop pattern, how it allows Vert.x to process lots of events concurrently, and why it's important not to block its execution.</p>&#13;
			<p>Now, you should be able to write microservices in Kotlin using two different frameworks, and you can choose what approach works best for you.</p>&#13;
			<p>Vert.x provides a lower-level API than Ktor, which means that we may think more about how we structure our code, but the resulting application may be more performant as well. Since this is the end of this book, all that's left is for me to wish you the best of luck in learning about Kotlin and its ecosystem. You can always get some help from me and other Kotlin enthusiasts by going to <a href="https://stackoverflow.com/questions/tagged/kotlin">https://stackoverflow.com/questions/tagged/kotlin</a> and <a href="https://discuss.kotlinlang.org/">https://discuss.kotlinlang.org/</a>.</p>&#13;
			<p><em class="italic">Happy learning!</em></p>&#13;
			<h1 id="_idParaDest-259"><a id="_idTextAnchor265"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">What's a verticle in Vert.x?</li>&#13;
				<li>What's the goal of the Event Bus?</li>&#13;
				<li>Why shouldn't we block the Event Loop?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>