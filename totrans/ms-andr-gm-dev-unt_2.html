<html><head></head><body>
        

            
                <h1 class="header-title">Finishing the Perky Penguin 2D Game</h1>
            

            
                
<p>The previous chapter was all about new and beginner developers interested in Unity and game development. As this book is focused on game development for the Android platform, so the previous chapter, which happens to be the very first chapter of the book, introduced the Android platform, its different versions, and its marketplace, Google Play. Then the chapter revised the concepts of game engines and then brought Unity 3D into light by comparing it with other major game engines such as Unreal, Adobe Flash, and Game Maker Studio. The chapter made a transition through the very basics of Unity game development, such as introducing Unity's interface, its panels, such as the inspector panel, the hierarchy panel, and so on. It also introduced the concepts of scene view and game view and how they interact with each other and how these views help developers to make it an easy and fun experience to create awesome games.</p>
<p>This chapter includes the following topics:</p>
<ul>
<li>Adding particle systems to a game</li>
<li>Camera management</li>
<li>Prefabs and level management</li>
<li>Lasers and enemies in a game</li>
</ul>
<p>After providing enough information on the theoretical side of unity game development for Android platforms, the previous chapter started practical examples from configuring empty game projects which are especially useful for 2D games. Configuring empty projects is the very first step in any game and we covered this in <a href="ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Android Game Development with Unity 3D</em>, in a very practical manner, and we also introduced a 2D game called <strong>Perky Penguin</strong>. The following is the screenshot of the game from the previous chapter:</p>
<div><img class=" image-border" src="img/image_02_001.png"/></div>
<p>Figure 2.1 Perky Penguin game</p>
<p>We learned how a player, such as the penguin, is added in Unity and how the colliders and physics were applied on the penguin. Unity also supports scripting and programming in C# or JavaScript languages to define custom behaviors such as making the penguin jump, avoiding gravity while flying, stopping the penguin from leaving the screen during gameplay, and so on. The chapter finished by having a Perky Penguin game with a penguin jumping in it.</p>
<p>If you are already familiar with the 2D concepts of Unity or have created 2D games already, then you can skip this chapter and move on to the third dimension.</p>
<p>In this chapter, we will finish this Penguin Perky game by learning some other advanced concepts of Unity 2D, such as adding particle effects, camera management, creating levels, using animations and controllers introduced in Unity 4.x versions, and so on. Until now, the Perky Penguin game has a cute penguin that can fly and jump on the screen but it can't walk forward and neither can it explore the game world. One thing to note here is that how the penguin is flying, whereas in real life, penguins don't fly. In our game, the penguin has got its hands on a red rocket which gives a boost of fire on the penguin to make it fly for a little instant. In the game, this boost is applied by a single tap on the screen of an Android device.</p>
<p>In the next section, we will start work on our game and bring the game to life by adding particle effects.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding Particle Systems</h1>
            

            
                
<p>Before we delve into the details of particle systems, let's discuss what exactly these systems are and how they are used. Let's start with a discussion of what particle systems are.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">What is a Particle System?</h1>
            

            
                
<p>In any 3D complex game, characters, props, and environment elements are mostly created as 3D meshes and models, while in 2D games, sprites and images are used for these same purposes. Now, whether these objects are meshes or sprites, they mostly represent solid objects which contain a well-defined shape. But any game contains other entities such as fluids, liquids, smokes, clouds, flames, magic balls, and so on. These are some sort of special kinds of animations and objects, and are handled also with a special type of properties and behaviors, called particle systems in Unity.</p>
<p>The screenshot below shows some interesting magic spell particle systems created in Unity:</p>
<div><img class="image-border" height="255" src="img/image_02_002.jpg" width="439"/></div>
<p>Figure 2.2: Different Particle Effects or magic spells created in Unity</p>
<p>Particles are small and simple images, or even meshes, that are displayed and animated in a huge number by a full-fledged system known as a Particle System. In any particle system, each small particle contributes a minor role and, overall, it looks like some highly polished animation or effect. For example, a snowfall effect can be treated as a particle system. A single particle of snow doesn't represent any snowfall if it is animated singularly, but if those same single snow particles are animated in a huge quantity with random speed, random direction, and random size, all these particles will not look like some image animation; rather, they will look like a system of snowfall in the game. That's the main key power of using a Particle System in Unity--it allows batch operations of heavy code in a very light and optimized way, resulting in very beautiful effects for games.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Basics of Particle System</h1>
            

            
                
<p>In Unity, a Particle System consists of all of the particles. Developers are only expected to manage the particles and the rest will be handled by Unity. Each particle has a predetermined lifetime through various changes, such as fading away for any snowfall effect, or getting scaled up and fading for any smoke effect, and so on. Like all other physical game objects, these particles have velocity to change the speed and direction throughout their lifetime duration, and these particles can be affected by forces and gravity applied by the environment's physics kinematics.</p>
<p>The developers' end is to manage and control the particle's lifetime and its behavior, such as how many seconds will a particle last? How it will grow throughout its lifetime duration? Will it scale up or not? Will it fade away throughout its lifetime? All these questions are answered by developers and Unity will award them an amazing particle system in the form of an effect.</p>
<p>The particles can be as simple as a sphere of white color or can be as complex as any mesh with high-resolution texture and normal maps.</p>
<p>The particle system's job is to manage all these particles from an abstract view. This system tells when to generate the next particle and where it should be, with what position, rotation, and scale. What should be the emission shape of the system, for example, hemisphere, code, or simple box? What should be the emission rate of the particles and how long should any particle effect take to execute one complete cycle of the system?</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a rocket fire Particle Effect for a game</h1>
            

            
                
<p>So, after getting to grips with some basic knowledge of particle effects and particle systems in Unity, let's put this knowledge into action by creating the first particle system for our Perky Penguin game. As we know, the penguin wears a rocket tied to its back which lets it fly and boost when tapped on screen by the player. Now, this rocket will create a small fire-like effect when it becomes active. The following screenshot shows the rocket with its fire effect of boost as the final result of this small particle system exercise:</p>
<div><img class=" image-border" height="180" src="img/image_02_003.png" width="168"/></div>
<p>Figure 2.3: Rocket's fire effect final result</p>
<p>As shown in the preceding screenshot, you can observe how the fire starts from the edge of the rocket and how it disappears slowly with a fading effect, similar to real life. Now, let's create this simple particle effect for our penguin's rocket in our last created <kbd>PerkyPenguin_PenguinMovement</kbd> project from <a href="ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Android Game Development with Unity 3D</em>.</p>
<p>Let's start creating a particle system object by selecting GameObject | Particle System as shown in the following figure:</p>
<div><img class=" image-border" height="233" src="img/image_02_004.png" width="312"/></div>
<p>Figure 2.4 Creating Particle System GameObject</p>
<p>This will add a game object with the name Particle System in the Hierarchy panel immediately. But you might notice a strange thing here of the white spheres moving outward in the Scene View as soon the object is created and selected. The screenshot below shows a simple example of those white spheres in the Scene view below:</p>
<div><img class=" image-border" height="269" src="img/image_02_005.png" width="464"/></div>
<p>Figure 2.5 A Particle System GameObject selected in Unity</p>
<p>You can see that, as we created a Particle System object, a simple white sphere particle system started playing in the scene. A small control panel is shown in the scene, consisting of controls such as pause, stop, playback speed, and playback time. As you select any other game object or deselect the Particle System game object, the Particle System will stop automatically.</p>
<p>One of feature of the interface of Unity is that developers don't need to play the game in order to test their particle systems. These can be checked directly within the scene view.</p>
<p>Also, you should notice the Inspector panel of the selected Particle System and see how lots of different properties are shown in the Particle System component of the object, as shown in the following screenshot:</p>
<div><img class=" image-border" height="526" src="img/image_02_006.png" width="250"/></div>
<p>Figure 2.6 Particle System component in Inspector panel</p>
<p>It would be good to know that almost everything about the Unity's Particle System is provided in this Particle System component, which is a set of a huge number of properties. On tweaking and changing the values of these properties, a snowfall can be converted into burning fire, or it can be converted into an explosion for any airplane games, or it can be converted in a magic ball or magic spell for any dungeon role-playing games, and so on. To learn about it, let's continue our rocket fire particle system by following the steps given below:</p>
<ul>
<li>In order to put the particle system always below the rocket, it should be a child of the penguin object. So drag the Particle System object onto the penguin game object in the Hierarchy panel and you will see something like the following screenshot:</li>
</ul>
<div><img class=" image-border" src="img/image_02_007.png"/></div>
<p>Figure 2.7 Particle System GameObject as child of penguin object</p>
<ul>
<li>Rename the Particle System to rocketFire.</li>
<li>Set its Position to (-0.62, -0.33, 0) to move it to the nozzle of the rocket.</li>
<li>Set its Rotation to (65, 270, 270) to set the direction of the particles in orientation with the rocket.</li>
</ul>
<p>The following screenshot highlights all the changes provided in the above steps of the Inspector panel:</p>
<div><img class=" image-border" height="191" src="img/image_02_008.png" width="248"/></div>
<p>Figure 2.8 The rocketFire Transform in Inspector panel</p>
<p>Still in the Inspector panel with the rocketFire particle system object selected, let's alter the values of the Particle System component to create a beautiful type of fire for our penguin's rocket to boost. Here are the steps to follow:</p>
<ul>
<li>Set Start Lifetime to 0.5</li>
<li>Set Start Size to 0.3</li>
<li>Click on Start Color and set Red to 255, Green to 135, Blue to 40 and Alpha to 255, this will turn our white particles into orange ones</li>
<li>Expand the Emission section and set Rate to 300</li>
<li>Expand the Shape section and set Shape to Cone, Angle to 12 and Radius to 0.1</li>
<li>Set the Random Direction checkbox to checked state to create randomness in fire particles</li>
</ul>
<p>The following screenshot shows the Particle System component's previously set along with its result of rocket fire below the penguin in the Scene view:</p>
<div><img class=" image-border" src="img/image_02_009.png"/></div>
<p>Figure 2.9 The rocketFire Particle System</p>
<p>You can observe how the random white spheres being generated and moving in random directions have changed into a cone-shaped fire emission from a rocket tied on the back of the penguin. What we have done is to alter some values in the Particle System component in the Inspector panel. Let's briefly look at what these properties actually do:</p>
<ul>
<li><strong>Start Lifetime</strong> is the total lifetime in seconds that particles will have when emitted</li>
<li><strong>Start Size</strong> is the initial size of particles when emitted</li>
<li><strong>Start Color</strong> is the initial color of particles when emitted</li>
<li><strong>Emission Rate</strong> is the number of particles emitted per unit of time or distance moved</li>
<li><strong>Shape</strong> is the shape of the emission volume: the options are <em>Sphere</em>, <em>Hemisphere</em>, <em>Cone</em>, <em>Box</em>, <em>Mesh</em>, <em>Circle</em> and <em>Edge</em></li>
<li><strong>Angle</strong> is the angle of the cone at its point (for cones only)</li>
<li><strong>Radius</strong> is the radius of the circular aspect of the shape</li>
<li><strong>Random Direction</strong> enabled means that the particles' initial direction will be chosen randomly</li>
</ul>
<p>You can see more of these properties and their purposes on Unity's manual or documentation website at <a href="http://docs.unity3d.com/Manual/ParticleSystemModules.html">http://docs.unity3d.com/Manual/ParticleSystemModules.html</a>.</p>
<p>So, our rocket fire Particle System is ready. But, in real life, fire never ends instantly, it always ends by getting faded over time. We can also add this property into our fire by enabling the Start Color property in the Particle System component. Then click on the Color box and select the top slider on the right, which is for alpha of the end color, and set its value to 0.</p>
<p>The whole setting is shown in the following screenshot:</p>
<div><img class=" image-border" src="img/image_02_010.png"/></div>
<p>Figure 2.10 Adding fade effect in fire using Color over Lifetime</p>
<p>If you are not sure of what exactly Color over Lifetime changed in the fire effect, the following screenshot shows the difference in the fire particle system with and without the fading effect:</p>
<div><img class=" image-border" height="145" src="img/image_02_011.png" width="224"/></div>
<p>Figure 2.11 The fire effects with and without fade effects</p>
<p>So far, we have a penguin which flies on a tap of the screen and its rocket is exploding fire all the time. Now it's time to put some environment in the game to make the theme of the game. This environment will be for the penguin to move forward through and our game needs an endless room for the background. But, in order to test the penguin walking, we will only add background without any endless moving functionality.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding game-level backgrounds</h1>
            

            
                
<p>A game with no background or theme is no game at all. So far, the penguin has got no reason to walk through the game, fly, or use its rocket to boost because it is in a void space of blue color. Let's bring this penguin into the snowy and hilly world where it actually belongs. And in order to survive melting ice due to global warming, it can also use its rocket to fly a little. In this section, we will learn how to add backgrounds and how the order of these backgrounds and sprites is managed in any 2D game where z-order is not used at all.</p>
<p>We will start by creating backgrounds for the levels of the game. These backgrounds can be created in your favorite graphics tools, such as Adobe Photoshop and so on. The following screenshot shows the background we created for the Perky Penguin game:</p>
<div><img class=" image-border" src="img/image_02_012.png"/></div>
<p>Fig 2.12 Background of the Penguin Perky Game</p>
<p>We have already learned about how the images are imported as sprites in Unity. For backgrounds, we have to do exactly the same procedure again. We have prepared two repeatable images with the names <kbd>bg_snow1.png</kbd> and <kbd>bg_snow2.png</kbd> and imported these images into the Graphics folder of the Assets directory in the Project Browser panel. The following screenshot shows the Project Browser panel with background images in it:</p>
<div><img class=" image-border" src="img/image_02_013.png"/></div>
<p>Figure 2.13 Backgrounds in the Project browser panel</p>
<p>It must be noted that the backgrounds should be repeatable so that when these images are put together, they should merge and avoid players recognizing the repeating order. The following screenshot shows both the background images we have designed for the Penguin Perky game:</p>
<div><img class=" image-border" height="184" src="img/image_02_014.png" width="267"/></div>
<p>Figure 2.14 Backgrounds of Penguin Perky game</p>
<p>You can see in the images that if we keep these two images repeating beside each other, it will create a very smooth background which will forever be repeating over and over again. We will do that with some scripting later in this chapter. For now, let's set up the scene background of the game.</p>
<p>After importing the background images in the Graphics folder of Assets, place two objects of <kbd>bg_snow1.png</kbd> and one object of <kbd>bg_snow2.png</kbd> in the Hierarchy panel. Set the first <kbd>bg_snow1.png</kbd> position to (0, 0, 0), then the <kbd>bg_snow2.png</kbd> position to (4.8, 0, 0), and finally another <kbd>bg_snow1.png</kbd> position to (9.6, 0, 0), and you will get a small background in the scene. So, now you will observe that the penguin is hidden behind these backgrounds. As this is a 2D game, so there is no concept of a z-axis here. We can set the z-axis position and bring forward and backward the sprites and images but for 2D games it is not a good approach. Unity provides developers with an ordering mechanism for placing 2D images front and backward optimized for 2D games especially. This is done through the sorting layers. Select the <kbd>bg_snow1</kbd> object in the Hierarchy panel and look at the Inspector in the SpriteRenderer component, and you will see an option of Sorting Layer as shown in the following screenshot:</p>
<div><img class=" image-border" height="270" src="img/image_02_015.png" width="453"/></div>
<p>Figure 2.15 Sorting Layer in SpriteRenderer in Inspector panel</p>
<p>Initially, all the sprites you import in Unity have a default sorting layer. Click on the drop-down menu and you will see the list of all sorting layers in the project. At the moment, we only have one layer called Default and there is another option, Add Sorting Layer..., to add a new layer. Click on the Add Sorting Layer... option as shown in the following screenshot:</p>
<div><img class=" image-border" height="158" src="img/image_02_016.png" width="258"/></div>
<p>Figure 2.16 Add Sorting Layer... option</p>
<p>This will open a new Tags &amp; Layers panel in place of the Inspector panel. Add four layers, namely Background, Surroundings, Objects, and Player in the order as explained. This is shown in the following screenshot:</p>
<div><img class=" image-border" height="213" src="img/image_02_017.png" width="251"/></div>
<p>Figure 2.17 Sorting Layers panel</p>
<p>You can drag these layers up or down by pressing and dragging the two lines icon to the left of each layer row. Moving these layers up or down describes the order of layers. For example, currently the Default layer is the lowest layer and it will be behind everything, and the Player layer will be in front of everything that uses layers except the Player layer.</p>
<p>There is a huge difference between Sorting Layers and Layers. Sorting Layers are only used to arrange 2D sprites for 2D games but the Layers are not for arranging purposes. It's totally a different concept and you must be careful when using layers in order to avoid any conflict between layers and sorting layers.</p>
<p>Right now, we only need Player and Background sorting layers; we will use other layers later in this chapter. Now, select the penguin game object in the Hierarchy panel and choose the Player layer from the Sorting Layer option in Sprite Renderer, as shown in the following screenshot:</p>
<div><img class=" image-border" height="192" src="img/image_02_018.png" width="384"/></div>
<p>Figure 2.18 Selecting Penguin's Sorting Layer</p>
<p>Similarly, select the Background layer for all the snow background objects in the scene. And now you will observe that the penguin will be in front of these snow backgrounds.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Camera management</h1>
            

            
                
<p>So now we have a game in which we have a penguin that can fly and jump with a rocket fire particle system effect. Also, we have a basic environment of snow backgrounds in the scene as well. In this section, we will learn about how we to make the penguin move throughout an endless generated level and how the camera will always be focused on the penguin.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Making the penguin move forward</h1>
            

            
                
<p>Let's start by making our penguin move in a forward direction. To do that, open the file <kbd>PenguinController.cs</kbd> created in <a href="ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Android Game Development with Unity3D</em>. This file is contained in the Scripts folder of the Assets directory. Add the forward speed public field in the class, as shown in the following code:</p>
<pre>
    public float forwardMovementSpeed = 3.0f;
</pre>
<p>Recall that adding any public field results in the addition of a property in the script's game object, as shown in the Inspector panel in the following screenshot:</p>
<div><img class=" image-border" height="254" src="img/image_02_020.png" width="415"/></div>
<p>Figure 2.19 Forward Movement speed field in the Inspector panel</p>
<p>Now, in order to move the penguin with any speed, we have to update the speed of the penguin in the <kbd>Update()</kbd> or <kbd>FixedUpdate()</kbd> methods. Since we are using the <kbd>FixedUpdate()</kbd> method in order to utilize the physics behavior of the penguin, so add this code at end of the <kbd>FixedUpdate()</kbd> method:</p>
<div><img class=" image-border" height="74" src="img/image_02_021.png" width="475"/></div>
<p>Well, there is not much of anything new in this code snippet. As we updated the penguin's y-position in through jetpack force, we are updating only the x-axis of the penguin's object. See how we are assigning <kbd>forwardMovementSpeed</kbd> in each frame on the velocity of penguin's game object. When you run the project, the penguin will start moving in the right direction, and after a minute, it will leave the screen. Our next task is to make the camera follow the penguin so that the penguin always remains on screen and never gets out of bounds of the camera.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Making the camera follow the Penguin</h1>
            

            
                
<p>Object as a child of the penguin game object, as shown in the following screenshot:</p>
<p>We have lots of methods to make the camera follow the penguin. The easiest is to put the Camera object as a child of the penguin game object, as shown in the following screenshot:</p>
<div><img src="img/image_02_022.png"/></div>
<p>Figure 2.21 Camera as child of the Penguin object</p>
<p>Well, you can do this, but there is a problem with this solution. When the penguin jumps or flies, the camera also moves up or down with it. We don't need that in our game. We only need to move the camera horizontally and continuously move forward keeping the penguin in the bounds. So, we will do that by creating another C# script file in the Script folder of the Assets directory with the name <kbd>CameraFollow.cs</kbd>. Now, add a public <kbd>GameObject</kbd> field with a variable named <kbd>targetObject</kbd>. This field will tell the camera about which object to follow. We will keep a reference of the penguin's game object in this field. And finally, to move the camera continuously forward, we will do code similar to the penguin's moving forward code. The only difference here is that we put our code in the <kbd>Update()</kbd> method instead of <kbd>FixedUpdate()</kbd>. The reason for this is that <kbd>FixedUpdate()</kbd> should be used when the object has a rigid body and/or other physical behaviors. As our camera has no connection with the physics, we can do this by simply adding the moving code in the <kbd>Update()</kbd> method. The following is the whole code of the <kbd>CameraFollow.cs</kbd> file:</p>
<div><img class=" image-border" height="246" src="img/image_02_023.png" width="506"/></div>
<p>After writing the code, let's put this script on the Camera object. Select the Main Camera object in the Hierarchy panel, and click on the Add Component button in Inspector and choose Scripts - CameraFollow.cs, as shown in the following screenshot:</p>
<div><img class=" image-border" height="424" src="img/image_02_024.png" width="390"/></div>
<p>Figure 2.22 Adding CameraFollow.cs on camera</p>
<p>You can also apply scripts on the game objects by simply dragging the script files from the Project Browser panel directly onto game objects in the Hierarchy panel.</p>
<p>When you run the project, although the Camera will move, you will a see an error in the Debug Log panel, as shown in the following screenshot:</p>
<div><img class=" image-border" height="81" src="img/image_02_025.png" width="558"/></div>
<p>Figure 2.23 Camera error in Debug Log</p>
<p>The problem is that the variable <kbd>targetObject</kbd> in the <kbd>CameraFollow</kbd> script is not assigned to any value and we are accessing it the <kbd>Update()</kbd> method. Recall from earlier that we need to assign the penguin game object in the <kbd>targetObject</kbd> value to tell the camera about the target to follow. You can use Unity's public inspector feature and directly assign the penguin object by dragging it into the camera's <kbd>targetObject</kbd> field in the Inspector panel, as shown in the following screenshot:</p>
<div><img class=" image-border" height="258" src="img/image_02_026.png" width="420"/></div>
<p>Figure 2.24 Assigning Penguin Object in Target Object</p>
<p>Now run the game and you will see the camera will never allow the penguin off the screen. However, after moving for a short time, the penguin will start falling since its floor has been left behind and the penguin has no physical support to oppose its gravity. To fix this and continue with the game, we will now work on creating endless levels in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Prefabs and level management</h1>
            

            
                
<p>There is not a single game which doesn't contain at least one level. Levels are what makes games feel like an experience and adventure. Levels come with different kinds of difficulties and players start to have feelings of accomplishing something and rewards. So, to put the soul in our Penguin Perky game, let's add levels to our game. But the question that arises here is what type of levels we should add to the game. Since the game is endless, so it would be a very suitable to add automatically generated levels with random obstacles and enemies in the game. In order to do that, we need a script that will take care of generating random environments and rooms along with putting enemies and barriers to balance the game difficulty.</p>
<p>Unity provides developers with the opportunity to instantiate the game objects at runtime and define behaviours in them, also at runtime. We can add rooms, levels, coins, enemies, and so on separately at runtime but Unity provides a better and organized way to handle these types of situations to manage reusable elements at runtime. This is done through the Prefab objects. Let's discuss Prefabs in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Prefabs</h1>
            

            
                
<p>According to Unity's documentation, a Prefab is a type of asset--a reusable <kbd>GameObject</kbd> stored in Project View. Prefabs can be inserted into any number of scenes, multiple times per scene. When you add a Prefab to a scene, you create an instance of it. All Prefab instances are linked to the original Prefab and are essentially clones of it. No matter how many instances exist in your project, when you make any changes to the Prefab, you will see the change applied to all instances.</p>
<p>The following screenshot shows the empty Prefab in the Project browser view:</p>
<div><img class=" image-border" height="165" src="img/image_02_027.png" width="282"/></div>
<p>Figure 2.25 An empty BoxPrefab in the Project browser panel</p>
<p>You will notice that we have a folder called Prefabs in our Assets directory. We created this folder when configuring the project. We will store all the Prefabs used in the game in this directory.</p>
<p>Prefabs are exactly like game objects. They can have colliders, rigid body, scripts, other components, and so on. The only difference between Prefabs and game objects is that Prefabs can be instantiated at runtime and copy the same behavior at runtime, but game objects can be generated at runtime.</p>
<p>In order to create an endless level, we have to create a small block of levels for our game. This block will be continuously generated at runtime over and over again as the penguin keeps going through the level. Let's create the small level block in the next section and see how this Prefab theory goes into action.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a Level Block Prefab</h1>
            

            
                
<p>The Level Block Prefab will have a ground object and a ceiling object to avoid the penguin going out of the bounds from the screen and it will have an environment in the background for decoration and theme purposes.</p>
<p>Let's start by creating an empty game object in the Hierarchy by right-clicking in hierarchy view and clicking Create Empty, as shown in the following screenshot:</p>
<div><img class=" image-border" height="506" src="img/image_02_028.png" width="234"/></div>
<p>Figure 2.26 Creating an empty GameObject</p>
<p>Now, put all the necessary game objects to be included in the Prefab as a child of this empty game object. We are adding <kbd>snow_bg1</kbd> and <kbd>snow_bg2</kbd> backgrounds, the <kbd>floor</kbd> object, and the <kbd>ceiling</kbd> object at the moment. We can update it later at any time and add new objects and components in the Prefabs. But you must remember that it would change all the existing Prefab objects as well, so you must be careful when you update the Prefab.</p>
<p>All these objects can be dragged onto the empty created game object to make these children and rename the empty game object <kbd>level_block</kbd> then. The following screenshot shows the game object hierarchy of the <kbd>level_block</kbd> object:</p>
<div><img class=" image-border" src="img/image_02_029.png"/></div>
<p>Figure 2.27 The level_block game object</p>
<p>If you have decorated your level block with more objects, decorations, surroundings, and so on, then you should also add them to the level block empty game object.</p>
<p>We have created a level block game object. Now it's time to put it into Prefab form. To do that, right-click on the Prefabs folder in the Assets directory, and choose Create - Prefab from the menu, as shown in the following screenshot:</p>
<div><img class=" image-border" height="403" src="img/image_02_030.png" width="662"/></div>
<p>Figure 2.28 Creating a Prefab</p>
<p>It will create an empty Prefab in the Prefabs folder. Now, drag the level_block game object from the hierarchy view onto the empty created Prefab and your Prefab will be ready. This is shown in the following screenshot:</p>
<div><img class=" image-border" height="193" src="img/image_02_031.png" width="458"/></div>
<p>Figure 2.29 Adding an Object to a Prefab</p>
<p>Once the Prefab is created, it will show you a small preview of the game object contents in the Project Browser panel. You will also observe a small arrow in it, which will explore all the objects put into the Prefab as well. The following screenshot shows the preview of Level Block Prefab in the Project Browser panel:</p>
<div><img class=" image-border" height="290" src="img/image_02_032.png" width="435"/></div>
<p>Figure 2.30 Prefab in Project Browser Panel</p>
<p>The Prefabs can be used in any scenes. These are reusable anywhere throughout the project.</p>
<p>In order to see how the Prefabs will work at runtime, just drag our Level Block Prefab object into the scene a few times in different positions and see how it comes in the view. The following screenshot shows a few level blocks placed in a scene:</p>
<div><img class=" image-border" height="303" src="img/image_02_033.png" width="700"/></div>
<p>Figure 2.31 Level Block Prefabs placed randomly in the scene</p>
<p>You can observe that whenever we drag any Prefab into the scene, it creates the whole block, consisting of all the functionality, child objects, behaviors, scripts, and so on. That is the main advantage of using Prefabs in Unity.</p>
<p>Our Level Block Prefab is ready. Now we have to tell Unity when to create the block at runtime and at what positions it should be instantiated. We will do this by adding a script called <kbd>BlockGenerator.cs</kbd> into the penguin object. Let's explain about this generator in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The level block generator concept</h1>
            

            
                
<p>The idea behind the generator script is quite simple. The script has an array of level blocks it can generate (for now, we have only one block created), a list of blocks currently generated, and two additional methods. One method checks to see whether another block needs to be added and the other method actually adds a block.</p>
<p>To check whether a block needs to be added, the script will enumerate all existing rooms and see whether there is a room ahead, farther than the screen width, to guarantee that the player never sees the end of the level. To understand this more clearly, let's look at the following screenshot:</p>
<div><img class=" image-border" height="345" src="img/image_02_034.png" width="484"/></div>
<p>Figure 2.32 Level block generator idea</p>
<p>You can see in scenario 1, there is enough space or width yet to cover some distance in the block. But in scenario 2, there is not enough space to cover, because as the penguin moves forward, the empty space will start to show up. So before it shows any blank space, we need to add a new level block beside the current block so that the player never sees any empty spaces there. The figure only tries to clarify the rough concept of how the new block will be added and when. The following screenshot shows a sample generation of blocks and our penguin's moving forward status:</p>
<div><img class=" image-border" height="252" src="img/image_02_035.png" width="675"/></div>
<p>Figure 2.33 Penguin Moving Forward and Level Blocks Generating</p>
<p>You can see that as the penguin keeps moving forward, new blocks will be generating over and over again. Once any block leaves the screen, it will be deleted to optimize the memory usage and increase game performance.</p>
<p>Let's now bring this whole scenario into action by writing the <kbd>BlockGenerator.cs</kbd> code in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The BlockGenerator.cs code</h1>
            

            
                
<p>Let's start by creating an empty C# script file in the Scripts folder of the Assets directory with the name <kbd>BlockGenerator.cs</kbd>. Then drag this script onto the penguin object to apply on the penguin.</p>
<p>Any game object can have many scripts applied to it. There is no restriction of scripts or components applied on the game objects.</p>
<p>Open <kbd>BlockGenerator.cs</kbd> in <kbd>MonoDevelop</kbd> by double-clicking it in the Project view or in the Inspector panel.</p>
<p>You have to add the <kbd>System.Collections.Generic</kbd> namespace if you're going to use the <kbd>List&lt;T&gt;</kbd> class.</p>
<p>Add the following field variables into the <kbd>BlockGenerator</kbd> class:</p>
<pre>
    public GameObject[] availableBlocks;<br/>    public List&lt;GameObject&gt; currentBlocks;<br/>    private float screenWidthInPoints;
</pre>
<p><kbd>availableBlocks</kbd> will contain an array of Prefabs which the script can generate. Currently, we have only one Prefab (<kbd>LevelBlockPrefab</kbd>). But we can create many different blocks types and add them all to this array, so that the script could randomly choose which block type to generate. The <kbd>currentBlocks</kbd> list will store instanced blocks, so that it can check where the last block ends and whether it needs to add more blocks. Once the block is behind the player character, it will remove it as well. The <kbd>screenWidthInPoints</kbd> variable is just required to cache screen size in points.</p>
<p>You can see these fields in the Inspector view of the penguin game object, as shown in the following screenshot:</p>
<div><img class=" image-border" height="330" src="img/image_02_037.png" width="215"/></div>
<p>Figure 2.34 Block Generator Fields in Inspector</p>
<p>Now, add the following code in the <kbd>Start()</kbd> method of the <kbd>BlockGenerator.cs</kbd> file:</p>
<div><img class=" image-border" height="86" src="img/image_02_038.png" width="418"/></div>
<p>Here you calculate the size of the screen in points. The screen size will be used to determine whether you need to generate a new block, described previously.</p>
<p>Add the following <kbd>AddBlock()</kbd> method to <kbd>BlockGenerator.cs</kbd>:</p>
<div><img class=" image-border" height="267" src="img/image_02_039.png" width="507"/></div>
<p>This method adds a new block using the <kbd>farhtestBlockEndX</kbd> point, which is the rightmost point of the level so far. Here is description of every line of this method:</p>
<ul>
<li>Picks a random index of the block type (Prefab) to generate.</li>
<li>Creates a block object from the array of available blocks using the random index above.</li>
<li>Since the block is empty containing all the block parts, you cannot simply take its size. Instead, you get the size of the floor inside the block, which is equal to the block's width.</li>
<li>When you set the block position, you set the position of its center so you add the half block width to the position where the level ends. This way gets the point at which you should add the block, so that it starts straight after the last block.</li>
<li>This sets the position of the block. You need to change only the x-coordinate since all blocks have the same y and z coordinates equal to zero.</li>
<li>Finally, you add the block to the list of current blocks. It will be cleared in the next method, which is why you need to maintain this list.</li>
</ul>
<p>After the <kbd>AddBlock()</kbd> method, let's go into the details of the <kbd>GenerateBlockIfRequired()</kbd> method:</p>
<div><img class=" image-border" height="472" src="img/image_02_040.png" width="423"/></div>
<p>This method is the implementation of the idea explained in the previous section:</p>
<ol>
<li>Creates a new list to store blocks that need to be removed. Separate lists are required since you cannot remove items from the list while you are iterating through it.</li>
<li>This is a flag that shows whether you need to add more blocks. By default, it is set to true, but most of the time it will be set to false inside the <kbd>foreach</kbd>.</li>
</ol>
<ol start="3">
<li>Saves player position.</li>
<li>This is the point after which the block should be removed. If a block's position is behind this point (to the left), it needs to be removed.</li>
<li>If there is no block after the <kbd>addBlockX</kbd>point, you need to add a block, since the end of the level is closer than the screen width.</li>
<li>In <kbd>farthestBlockEndX</kbd>, you store the point where the level currently ends. You will use this variable to add a new block if required, since the new block should start at that point to make the level seamless.</li>
<li>In <kbd>foreach</kbd>, you simply enumerate the current blocks. You use the floor to get the block width and calculate the <kbd>BlockStartX</kbd> (the point where the block starts, the leftmost point of the block) and <kbd>BlockEndX</kbd> (the point where the block ends, the rightmost point of the block).</li>
<li>If there is a block that starts after <kbd>addBlockX</kbd> then you don't need to add blocks right now. However, there is no <kbd>break</kbd> instruction here, since you still need to check whether this block needs to be removed.</li>
<li>If a block ends to the left of the <kbd>removeBlockX</kbd> point, then it is already off the screen and needs to be removed.</li>
<li>Here you simply find the rightmost point of the level. This will be the point where the level currently ends. It is used only if you need to add a block.</li>
<li>This removes blocks that are marked for removal. The mouse <kbd>GameObject</kbd> already flew through them and thus they are far behind, so you need to remove them.</li>
<li>If at this point <kbd>addBlocks</kbd> is still <kbd>true</kbd>, then the level end is near. <kbd>addBlocks</kbd> will be true if it didn't find a block starting farther than the screen width. This indicates that a new block needs to be added.</li>
</ol>
<p>So, after all this explanation, let's add our final method, <kbd>FixedUpdate()</kbd> to the the <kbd>BlockGenerator.cs</kbd> files as follows:</p>
<pre>
    void FixedUpdate() <br/>    {<br/>        GenerateBlockIfRequired(); <br/>    }
</pre>
<p>Generating blocks in <kbd>FixedUpdate()</kbd> will continue to periodically make sure that the player never experiences blank space in the game. Now, return to Unity and select the <em>penguin</em> GameObject in the Hierarchy. In the Inspector, find the <kbd>BlockGenerator</kbd> component. Drag the LevelBlockPrefab from the Hierarchy to the Current Blocks list. Then open the Prefabs folder in Project Browser and drag LevelBlockPrefab from it to Available Blocks. The following screenshot shows the <kbd>BlockGenerator</kbd> component of the penguin object after adding Prefabs in the lists:</p>
<div><img class=" image-border" height="131" src="img/image_02_042.png" width="237"/></div>
<p>Figure 2.35 Block Generator Component with Prefabs</p>
<p>Now run the project and you will see that blocks will keep generating. Note that blocks are appearing and disappearing in the Hierarchy while you fly. And for even more fun, run the scene and switch to the <em>Scene View</em> without stopping the game. This way, you will see how blocks are added and removed in real time.</p>
<p>So, after level generation, let's discuss how to add obstacles such as ice spikes in the game to make the penguin be little careful while going through the level in the next section.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding ice spikes to the game</h1>
            

            
                
<p>The penguin flying through the level looks great but the game is all about the challenges and obstacles. So, this section is all about the obstacles which can be added to the game. We will add ice spikes, which will be generated randomly in a similar manner as you generate blocks. Let's create the ice spike first. You need two images for the spikes on and spikes off states.</p>
<p>The following screenshot shows the spikes on and spikes off states:</p>
<div><img class=" image-border" height="126" src="img/image_02_043.png" width="106"/></div>
<p>Figure 2.36 Block generator fields in Inspector pane</p>
<p>Import these images into Unity with the names <kbd>spike_on.png</kbd> and <kbd>spike_off.png</kbd> in the Graphics folder of the Assets directory. And then we have to create a Prefab of the spike for it. So, here are the steps below:</p>
<ol>
<li>In the Project view, find the <kbd>spike_on</kbd> sprite and drag it to the scene.</li>
<li>Select it in the Hierarchy and rename it <kbd>spike</kbd>.</li>
<li>Set its Sorting Layer to Objects<em>.</em></li>
<li>Add a Box Collider 2D component.</li>
<li>Enable the Is Trigger property in the Box Collider 2D component.</li>
</ol>
<p>When the Is Trigger property is enabled, the collider will trigger collision events, but will be ignored by the physics engine.</p>
<ol start="6">
<li>Set the Size of the collider, <em>X</em> to <em>0.18</em> and <em>Y</em> to <em>3.1</em>.</li>
<li>Create a new C# script named <kbd>SpikeScript.cs</kbd> in the Scripts folder and attach it to the <kbd>spike</kbd> game object.</li>
</ol>
<p>The following screenshot shows all the steps done here to create a spike GameObject:</p>
<div><img class=" image-border" height="466" src="img/image_02_044.png" width="533"/></div>
<p>Fig 2.37 Adding a spike game object</p>
<p>Now open <kbd>SpikeScript.cs</kbd> and add the following fields in the class:</p>
<div><img class=" image-border" height="141" src="img/image_02_045.png" width="212"/></div>
<p>Then add the following code in the <kbd>Start()</kbd> method like this:</p>
<div><img class=" image-border" height="54" src="img/image_02_046.png" width="201"/></div>
<p>This will set the time until the spike should toggle its state for the first time. Then, to toggle and rotate the spike, add <kbd>FixedUpdate()</kbd> with the following:</p>
<div><img class=" image-border" height="179" src="img/image_02_047.png" width="580"/></div>
<p>Now, select <kbd>spike</kbd> in the Hierarchy. Drag the <kbd>spike_on</kbd> sprite from project browser to the Spike On Sprite property of the <kbd>SpikeScript</kbd> component in the inspector view. Also, do it for the <kbd>spike_off</kbd> sprite as well. Set Rotation speed to 30 and position to (2, 0.25, 0). Run the project and you will get a spike nicely rotating and finally turn into spike game object into a SpikePrefab in spikes folder as we did in the earlier section.</p>
<p>The following screenshot shows the spike running in the game:</p>
<div><img class=" image-border" height="213" src="img/image_02_048.png" width="548"/></div>
<p>Figure 2.38 Spike in the game</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we continued our Perky Penguin game and added particle systems to it. Then we learned about managing the camera, and we made the camera follow the penguin throughout the game. Then we worked on Prefabs and created a level block Prefab which we generated in the game from the code to make an endless level generating game. Then we created a Spike Prefab to create an obstacle for the penguin in the game which gets generated randomly and rotates with different speeds at runtime.</p>
<p>In the next chapter, we will move our concepts of making games to 3D and introduce you to the workflow and systems to create 3D complex games in Unity 3D.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>