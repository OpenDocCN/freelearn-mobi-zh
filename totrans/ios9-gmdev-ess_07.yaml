- en: Chapter 6. Exhibit the Metal in Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 展示你的Metal游戏
- en: Up to this point, we have learned quite a bit. We looked into Apple's Swift
    programming language, got an idea of the general flow of an iOS app, and how to
    control that through code and/or storyboards. We got an understanding of how 2D
    games and 2D overlays can be made with **SpriteKit** and how 3D games can be designed
    even in the **Xcode** editor with SceneKit. Finally, we reviewed how to create
    reusable game logic, components, and AI with the various aspects of **GameplayKit**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了很多。我们研究了苹果的Swift编程语言，了解了iOS应用的一般流程，以及如何通过代码和/或故事板来控制它。我们了解了如何使用**SpriteKit**制作2D游戏和2D叠加层，以及如何在**Xcode**编辑器中使用SceneKit设计3D游戏。最后，我们回顾了如何使用**GameplayKit**的各个方面创建可重用的游戏逻辑、组件和AI。
- en: Essentially, this is all that is needed to get right to planning, coding, and
    building your own games. If there's a game idea that has come to your mind at
    this time, go right ahead and start planning it out. The frameworks and Xcode
    features from the past chapters can help take your abstract ideas and start turning
    them into what could soon be a playable application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是规划、编码和构建你自己的游戏所需的所有内容。如果你此时脑海中闪过一个游戏想法，那就直接开始规划吧。前几章中的框架和Xcode功能可以帮助将你的抽象想法转化为可能很快就能玩的应用程序。
- en: However, before moving forward, we'd like to take this time to go over a few
    more tips, tricks, and topics that we either briefly mentioned or have yet to
    go over. These topics mainly cover the ways we can optimize our games and get
    more out of the Apple hardware. In this chapter, we shall review a bit on the
    rather advanced topic of the Apple Metal low-level graphics API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续前进之前，我们想利用这个时间回顾一些额外的提示、技巧和主题，我们要么简要提到了，要么还没有涉及。这些主题主要涵盖了我们可以优化游戏并从苹果硬件中获得更多的方式。在本章中，我们将简要回顾一下苹果Metal低级图形API的相当高级的主题。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just a warning that the topic of low-level graphics APIs can get rather advanced.
    This won't be an all-encompassing tutorial on the subject; more of an upper-level
    summary and a way to appreciate all that SpriteKit and SceneKit do in the background
    for us. We hope that, at the very least, it makes you wish to pursue how to build
    your own custom rendering objects that might potentially allow the development
    of extremely performant and detailed games.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于低级图形API可能相当高级的警告。这不会是一个关于该主题的全面教程；更像是高级总结，以及如何欣赏SpriteKit和SceneKit在后台为我们所做的一切。我们希望至少它能让你想要探索如何构建自己的自定义渲染对象，这可能会使开发出性能极强且细节丰富的游戏成为可能。
- en: The Apple Metal API and the graphics pipeline
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 苹果Metal API和图形管线
- en: One of the rules, if not *the golden rule* of modern video game development,
    is to keep our games running constantly at 60 frames per second or greater. If
    developing for VR devices and applications, this is of even more importance as
    dropped frame rates could lead to a sickening and game ending experience for the
    player.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是现代视频游戏开发的黄金法则，那么一条规则就是保持我们的游戏以每秒60帧或更高的速度持续运行。如果为VR设备和应用程序开发，这一点尤为重要，因为帧率下降可能会导致玩家感到恶心，甚至结束游戏体验。
- en: In the past, being lean was the name of the game; hardware limitations prevented
    much from not only being written to the screen but how much memory storage a game
    could hold. This limited the number of scenes, characters, effects, and levels.
    In the past, game development was built more with an engineering mindset, so the
    developers made the things work with what little they had. Many of the games on
    8-bit systems and earlier had levels and characters that were only different because
    of elaborate sprite slicing and recoloring.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，保持精简是游戏的名字；硬件限制不仅阻止了将内容写入屏幕，还限制了游戏可以存储的内存量。这限制了场景、角色、效果和级别的数量。在过去，游戏开发更多地采用工程思维，因此开发者用他们所拥有的少量资源使事物工作。许多8位系统及更早的游戏中的关卡和角色之所以不同，仅仅是因为复杂的精灵切割和重新着色。
- en: Over time, advances in hardware, particularly that of GPUs allowed for richer
    graphical experiences. This leads to the advent of computation-heavy 3D models,
    real-time lighting, robust shaders, and other effects that we can use to make
    our games present an even greater player experience; this while trying to stuff
    it all in that precious .016666 second/60 Hz window.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，硬件的进步，尤其是GPU的进步，使得图形体验更加丰富。这导致了计算密集型3D模型、实时照明、强大的着色器以及其他效果的诞生，我们可以利用这些效果让我们的游戏呈现出更佳的玩家体验；同时，我们还要在这宝贵的0.016666秒/60Hz窗口中尽可能塞入所有这些内容。
- en: To get everything out of the hardware and combat the clash between a designer's
    need to make the best looking experience and the engineering reality of hardware
    limitations in even today's CPU/GPUs, Apple developed the Metal API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从硬件中获取一切，并对抗设计师希望创造最佳视觉体验的需求与硬件在当今CPU/GPU中存在的限制之间的冲突，苹果开发了Metal API。
- en: CPU/GPU framework levels
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU/GPU框架级别
- en: Metal is what's known as a low-level GPU API. When we build our games on the
    iOS platform, there are different levels between the machine code in our GPU/CPU
    hardware and what we use to design our games. This goes for any piece of computer
    hardware we work with, be it Apple or others. For example, on the CPU side of
    things, at the very base of it all is the **machine code**. The next level up
    is the **assembly language** of the chipset. Assembly language differs based on
    the CPU chipset and allows the programmer to be as detailed as determining the
    individual registers to swap data in and out of in the processor. Just a few lines
    of a for-loop in C/C++ would take up a decent number of lines to code in assembly.
    The benefit of working in the lower levels of code is that we could make our games
    run much faster. However, most of the mid-upper level languages/APIs are made
    to work well enough so that this isn't a necessity anymore.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Metal是一种低级GPU API。当我们在iOS平台上构建游戏时，我们的GPU/CPU硬件中的机器代码与我们用来设计游戏的东西之间存在不同的级别。这适用于我们工作的任何计算机硬件，无论是苹果还是其他公司。例如，在CPU方面，在最底层是**机器代码**。再往上一层是芯片组的**汇编语言**。汇编语言根据CPU芯片组的不同而有所不同，允许程序员尽可能详细，比如确定交换数据进出的处理器中的单个寄存器。在C/C++中，一个简单的for循环可能需要几行代码在汇编语言中实现。在代码的较低级别工作的好处是我们可以让我们的游戏运行得更快。然而，大多数中高级别的语言/API都是为了足够好地工作而设计的，因此这不再是必需的。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Game developers have coded in assembly even after the very early days of game
    development. In the late 1990's, the game developer Chris Sawyer created his game,
    **Rollercoster Tycoon™**, almost entirely in the x86 assembly language! Assembly
    can be a great challenge for any enthusiastic developer who loves to tinker with
    the inner workings of computer hardware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在游戏开发的早期阶段，游戏开发者就已经开始使用汇编语言编写代码。在20世纪90年代末，游戏开发者Chris Sawyer几乎完全使用x86汇编语言创建了其游戏**Rollercoster
    Tycoon™**！对于任何喜欢摆弄计算机硬件内部结构的热情开发者来说，汇编语言可能是一个巨大的挑战。
- en: Moving up the chain we have where C/C++ code would be and just above that is
    where we'd find Swift and Objective-C code. Languages such as Ruby and JavaScript,
    which some developers can use in Xcode, are yet another level up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在链向上移动，我们会遇到C/C++代码的位置，再上面则是Swift和Objective-C代码的位置。像Ruby和JavaScript这样的语言，一些开发者可以在Xcode中使用，它们又是一个级别向上。
- en: That was about the CPU, now on to the GPU. The **Graphics Processing Unit**
    (**GPU**) is the coprocessor that works with the CPU to make the calculations
    for the visuals we see on the screen. The following diagram shows the GPU, the
    APIs that work with the GPU, and possible iOS games that can be made based on
    which framework/API is chosen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那是关于CPU的，现在转到GPU。**图形处理单元（GPU**）是协同CPU工作以计算我们在屏幕上看到的视觉效果的协处理器。以下图表显示了GPU、与GPU一起工作的API以及基于所选框架/API可以制作的可能的iOS游戏。
- en: '![CPU/GPU framework levels](img/00074.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![CPU/GPU框架级别](img/00074.jpeg)'
- en: Like the CPU, the lowest level is the processor's machine code. To work as close
    to the GPU's machine code as possible, many developers would use Silicon Graphics'
    **OpenGL API**. For mobile devices, such as the iPhone and iPad, it would be the
    OpenGL subset, **OpenGL ES**. Apple provides a helper framework/library to OpenGL
    ES named **GLKit**. GLKit helps simplify some of the shader logic and lessen the
    manual work that goes into working with the GPU at this level. For many game developers,
    this was practically the only option to make 3D games on the iOS device family
    originally; though some use of iOS's Core Graphics, Core Animation and UIKit frameworks
    were perfectly fine for simpler games.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CPU一样，最低级别是处理器的机器码。为了尽可能接近GPU的机器码，许多开发者会使用Silicon Graphics的**OpenGL API**。对于移动设备，如iPhone和iPad，将是OpenGL子集，**OpenGL
    ES**。苹果提供了一个名为**GLKit**的辅助框架/库来帮助OpenGL ES。GLKit有助于简化一些着色器逻辑，并减少在此级别与GPU一起工作时的人工操作。对于许多游戏开发者来说，这实际上是最初在iOS设备家族上制作3D游戏的唯一选择；尽管iOS的Core
    Graphics、Core Animation和UIKit框架的使用对于简单的游戏来说完全是可以接受的。
- en: Not too long into the lifespan of the iOS device family, third-party frameworks
    came into play, which were aimed at game development. Using OpenGL ES as its base,
    thus sitting directly one level above it, is the **Cocos2D framework**. This was
    actually the framework used in the original release of Rovio's Angry Birds™ series
    of games back in 2009\. Eventually, Apple realized how important gaming was for
    the success of the platform and made their own game-centric frameworks, that is,
    the SpriteKit and SceneKit frameworks. They too, like Cocos2D/3D, sat directly
    above OpenGL ES. When we made SKSprite nodes or SCNNodes in our Xcode projects,
    up until the introduction of Metal, OpenGL operations were being used to draw
    these objects in the update/render cycle behind the scenes. As of iOS 9, SpriteKit
    and SceneKit use Metal's rendering pipeline to process graphics to the screen.
    If the device is older, they revert to OpenGL ES as the underlying graphics API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS设备家族的生命周期中不久，第三方框架开始发挥作用，这些框架旨在游戏开发。以OpenGL ES为基础，直接位于其上一级的是**Cocos2D框架**。实际上，这个框架被用于Rovio的Angry
    Birds™游戏系列在2009年的原始版本中。最终，苹果公司意识到游戏对于平台成功的重要性，并创建了他们自己的以游戏为中心的框架，即SpriteKit和SceneKit框架。它们也像Cocos2D/3D一样，直接位于OpenGL
    ES之上。当我们在我们Xcode项目中创建SKSprite节点或SCNNodes时，直到Metal的引入，OpenGL操作在幕后用于在更新/渲染周期中绘制这些对象。截至iOS
    9，SpriteKit和SceneKit使用Metal的渲染管线将图形处理到屏幕上。如果设备较旧，它们会回退到OpenGL ES作为底层图形API。
- en: Graphics pipeline overview
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形管线概览
- en: 'This topic can be a book all on its own, but let''s take a look at the graphics
    pipeline to get an idea, at least on an upper level, of what the GPU is doing
    during a single rendered frame. We can imagine the graphical data of our games
    being divided in two main categories:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题可以是一本完整的书，但让我们看看图形管线，至少在较高层次上了解GPU在单个渲染帧期间做了什么。我们可以想象我们的游戏图形数据被分为两大类：
- en: '**Vertex data**: This is the position information of where on the screen this
    data can be rendered. Vector/vertex data can be expressed as points, lines, or
    triangles. Remember the old saying about video game graphics, "everything is a
    triangle." All of those polygons in a game are just a collection of triangles
    via their point/vector positions. The GPU''s **Vertex Processing Unit** (**VPU**)
    handles this data.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点数据**：这是这些数据可以在屏幕上渲染的位置信息。向量/顶点数据可以表示为点、线或三角形。记住关于视频游戏图形的古老说法，“一切皆三角形。”游戏中所有的多边形都是通过它们的点/向量位置集合而成的三角形。GPU的**顶点处理单元**（**VPU**）处理这些数据。'
- en: '**Rendering/pixel data**: Controlled by the GPU''s Rasterizer, this is the
    data that tells the GPU how the objects, positioned by the vertex data, will be
    colored/shaded on the screen. For example, this is where color channels, such
    as RGB and alpha, are handled. In short, it''s the pixel data and what we actually
    see on the screen.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染/像素数据**：由GPU的光栅化器控制，这是告诉GPU如何根据顶点数据定位的对象在屏幕上着色/阴影的数据。例如，这里处理了颜色通道，如RGB和alpha。简而言之，这是像素数据，这是我们实际上在屏幕上看到的内容。'
- en: 'Here''s a diagram showing the graphics pipeline overview:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个显示图形管线概览的图表：
- en: '![Graphics pipeline overview](img/00075.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图形管线概览](img/00075.jpeg)'
- en: 'The graphics pipeline is the sequence of steps it takes to have our data rendered
    to the screen. The previous diagram is a simplified example of this process. Here
    are the main sections that can make up the pipeline:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管道是将我们的数据渲染到屏幕上的步骤序列。前面的图是这个过程的一个简化示例。以下是可能组成管道的主要部分：
- en: '**Buffer objects**: These are known as **Vertex Buffer Objects** in OpenGL
    and are of the class `MTLBuffer` in the Metal API. These are the objects we create
    in our code that are sent from the CPU to the GPU for **primitive processing**.
    These objects contain data, such as the positions, normal vectors, alphas, colors,
    and more.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区对象**：在 OpenGL 中被称为 **顶点缓冲区对象**，在 Metal API 中是 `MTLBuffer` 类。这些是我们代码中创建的对象，从
    CPU 发送到 GPU 进行 **原始处理**。这些对象包含数据，例如位置、法向量、alpha 值、颜色等。'
- en: '**Primitive processing**: These are the steps in the GPU that take our Buffer
    Objects, break down the various vertex and rendering data in those objects, and
    then draw this information to the frame buffer, which is the screen output we
    see on the device.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始处理**：这些是在 GPU 中进行的步骤，它们将我们的缓冲区对象分解成各种顶点和渲染数据，然后将这些信息绘制到帧缓冲区中，这是我们看到的设备上的屏幕输出。'
- en: Before we go over the steps of primitive processing done in Metal, we should
    first understand the history and basics of shaders.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍 Metal 中原始处理步骤之前，我们首先应该了解着色器的历史和基础知识。
- en: What are shaders?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器是什么？
- en: GPUs first came into use because of none other than the video game industry.
    Arcade cabinets in the 1970's had GPU chips separate from the main CPU to handle
    the specialized visual needs of the games compared with other computing applications
    at the time. Eventually, the need to draw 3D graphics in games in the mid-1990's
    led to the modern GPU architecture we have now. Shaders were actually first introduced
    in 1988 by Pixar back when the company was run by Apple's cofounder Steve Jobs.
    Shaders are little programs we can write directly to the GPU to process the vertex
    and pixel data. Originally, APIs such as OpenGL ES 1.0 didn't make use of shader
    processing but instead were what's known as fixed-function APIs. In fixed-function
    APIs, programmers just referenced simple set rendering commands to the GPU. As
    GPUs evolved and took more work away from the CPU, the use of shaders increased.
    Although a rather more advanced way to traverse the graphics pipeline than the
    fixed-function methodology, shaders allow for even deeper customization of what
    the GPU displays to the screen. Game developers and 3D artists continue to push
    visual effects in games with them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 的首次使用并非因为其他原因，而是因为视频游戏行业。20 世纪 70 年代的街机柜中装有与主 CPU 分离的 GPU 芯片，以处理游戏相对于当时其他计算应用的专业视觉需求。最终，在
    1990 年代中期，在游戏中绘制 3D 图形的需求导致了我们现在所拥有的现代 GPU 架构。着色器实际上是在 1988 年由皮克斯公司首次引入的，当时公司由苹果公司的联合创始人史蒂夫·乔布斯领导。着色器是我们可以直接写入
    GPU 以处理顶点和像素数据的小程序。最初，OpenGL ES 1.0 等 API 并未使用着色器处理，而是被称为固定功能 API。在固定功能 API 中，程序员只需将简单的渲染命令引用到
    GPU 上。随着 GPU 的发展，从 CPU 中接管了更多的工作，着色器的使用量也随之增加。尽管着色器是比固定功能方法更高级的遍历图形管道的方式，但它允许对
    GPU 显示到屏幕上的内容进行更深入的定制。游戏开发者和 3D 艺术家继续使用它们推动游戏中的视觉效果。
- en: From OpenGL 2.0 and onwards, shaders were built in the API's C-like language
    named GLSL. In the Apple Metal API, we build shaders with the Metal Shading Language,
    which is a subset of C++11 of the file type `.metal` and can run the pipeline
    in either Objective-C or Swift with our view controllers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenGL 2.0 开始，着色器是用 API 的类似 C 语言 GLSL 构建的。在 Apple Metal API 中，我们使用 Metal 着色语言来构建着色器，这是一种
    C++11 的子集，文件类型为 `.metal`，并且可以使用我们的视图控制器在 Objective-C 或 Swift 中运行管道。
- en: Types of shaders
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器的类型
- en: Shaders come in a number of types that continue to grow as 3D games and art
    animation continues to progress. The most commonly used are Vertex shaders and
    Fragment shaders. Vertex shaders are used to transform 3D coordinates into 2D
    coordinates for the screen to display, in short, the positioning data of our graphics.
    Fragment shaders, also known as Pixel shaders, are what are used to convert colors
    and other visual attributes of pixels on the screen. These other attributes of
    Fragment Shaders can include bump mapping, shadows, and specific highlights as
    well. We emphasized the word *attributes* because that's usually the name given
    for the properties or input of our shader programs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器有多种类型，随着3D游戏和艺术动画的不断发展，这些类型也在不断增加。最常用的有顶点着色器和片段着色器。顶点着色器用于将3D坐标转换为屏幕显示的2D坐标，简而言之，就是我们的图形的位置数据。片段着色器，也称为像素着色器，用于转换屏幕上像素的颜色和其他视觉属性。片段着色器的其他属性还可以包括凹凸贴图、阴影和特定的高光。我们强调“属性”这个词，因为通常这是我们的着色器程序属性或输入的名称。
- en: Here is a code sample of a simple Vertex and Fragment shader written in the
    Metal Shading Language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个用Metal着色语言编写的简单顶点和片段着色器的代码示例。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code here is a bit different than what we've seen throughout the course
    of the book. Let's go over it line by line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与我们在书中看到的不同。让我们逐行过一遍。
- en: The Metal Shading Language is a C++11-like language, so we see that the Metal
    Standard Library is imported into the shader file with the line `#include <metal_stdlib>`
    in addition to `using namespace metal;`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metal着色语言是一种类似于C++11的语言，所以我们看到Metal标准库通过在着色器文件中使用`#include <metal_stdlib>`行导入，以及`using
    namespace metal;`。
- en: The next line is the creation of our Vertex shader using the keyword `vertex`.
    This shader is a vertex of four floats. Why four floats when 3D space only deals
    with *x*, *y*, and *z* coordinates? To summarize, 3D matrix math involves a fourth
    component, *w*, to accurately handle the math calculations of 3D space. In short
    if *w= 0*, the *x*, *y*, and *z* coordinates are vectors; if *w = 1*, then those
    coordinates are points. The purpose of this shader will be to draw simple points
    to the screen, so *w* will be 1.0.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行是使用`vertex`关键字创建我们的顶点着色器。这个着色器有四个浮点数。为什么是四个浮点数，而3D空间只处理*x*、*y*和*z*坐标？为了总结，3D矩阵数学涉及一个第四个组件*w*，以准确处理3D空间的数学计算。简而言之，如果*w=
    0*，则*x*、*y*和*z*坐标是向量；如果*w = 1*，则这些坐标是点。这个着色器的作用将是将简单的点绘制到屏幕上，所以*w*将是1.0。
- en: Here, we create a pointer to an array of float3 type (holders for our *x*, *y*,
    and *z* coordinates) and set it to the very first buffer with the `[[ buffer(0)
    ]]` declaration. The `[[ ]]` syntax is used to declare inputs/attributes for our
    shaders.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个指向`float3`类型数组（用于我们的*x*、*y*和*z*坐标）的指针，并将其设置为第一个缓冲区，使用`[[ buffer(0)
    ]]`声明。`[[ ]]`语法用于声明着色器输入/属性。
- en: The unsigned integer `vertexID` is what we name the `vertex_id` attribute of
    this particular array of vertices.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无符号整数`vertexID`是我们为这个特定顶点数组的`vertex_id`属性命名的名称。
- en: 'This is where the float4 type is returned, or in this case, the final position
    of this vertex array. We see that it returns two sections of the output: the first
    being the reference to this vertex array, identified by the `vertex_id` attribute
    and the `w` value of `1.0`, to represent that these are points in space.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`float4`类型是返回的，或者在这种情况下，这个顶点数组的最终位置。我们看到它返回输出中的两个部分：第一部分是引用这个顶点数组，通过`vertex_id`属性和`w`值为`1.0`来识别，表示这些是空间中的点。
- en: This line is where we create the fragment shader, using the `fragment` keyword.
    This shader is of the data type `half4`, which is an array of [4,4] 16-bit floats.
    This is, in this case, ultimately to create 16-bit colored pixels. The data in
    this [4,4]-component vector type saves 16 bits to R, G, B, and alpha channels.
    This shader is going to simply show pure white pixel shading with no transparency,
    so we simply write `return half4(1.0);`. This sets all of the bits to 1, which
    is equivalent to `rgba(1,1,1,1)`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一行是我们创建片段着色器的地方，使用`fragment`关键字。这个着色器的数据类型是`half4`，它是一个[4,4]的16位浮点数数组。在这种情况下，最终目的是创建16位彩色像素。这个[4,4]组件向量类型将16位保存到R、G、B和alpha通道。这个着色器将简单地显示纯白色像素着色，没有透明度，所以我们简单地写`return
    half4(1.0);`。这会将所有位设置为1，相当于`rgba(1,1,1,1)`。
- en: When we create a Buffer Object, which can just be a Struct of floating points
    on the screen, we pass that data through these shaders and out would pop up a
    white triangle or set of triangle shapes on the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个缓冲区对象时，它可以是屏幕上浮点数的结构体，我们将这些数据通过这些着色器传递，然后在屏幕上会出现一个白色三角形或一组三角形形状。
- en: Looking back at the *Graphics pipeline* diagram, we see that after the vertex
    shader is calculated, the GPU does what's known as **Primitive Assembly**. This
    is essentially where the points and vectors defined in the vertex shader are mapped
    to coordinates in screen space. The Rasterizer step, in simple terms, then figures
    from the vertex data where and how we can and can't color that pixel data onto
    the screen using the fragment shader information. After taking in the fragment
    shader information, the GPU then uses that information for the blending of that
    pixel data. Finally, that output is sent to or committed to the frame buffer where
    the player sees that output. This all happens in a single draw call in the render
    cycle. Having all of your game's lights, pixels, effects, physics, and other graphics
    cycle through this in .016666 seconds is the name of the game.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下**图形管线**图，我们看到在顶点着色器计算之后，GPU执行了所谓的**原语装配**。这本质上是将顶点着色器中定义的点向量映射到屏幕空间中的坐标。简而言之，光栅化步骤确定从顶点数据中我们可以和不能使用片段着色器信息将像素数据着色到屏幕上的位置和方式。在接收了片段着色器信息后，GPU然后使用这些信息进行像素数据的混合。最后，这些输出被发送到或提交到帧缓冲区，玩家在那里看到这些输出。所有这些都在渲染周期中的单个绘制调用中发生。让你的游戏中的所有灯光、像素、效果、物理和其他图形在0.016666秒内通过这个循环，这就是游戏的名字。
- en: We'll go over some more Metal code later but understand for now that shaders
    are like little instruction factories for data input we send to them in our Swift/Object-C
    code. Other shader types that have arisen over the years are Geometry Shaders
    and Tessellation Shaders.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后介绍更多的Metal代码，但你现在需要理解的是，着色器就像是我们Swift/Object-C代码中发送给它们的输入数据的小型指令工厂。多年来出现的其他着色器类型包括几何着色器和细分着色器。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both the Vertex and Fragment shaders are present in this single `.metal` file,
    but typically shaders are written in separate files. Xcode and Metal will combine
    all `.metal` files in your project, so it doesn't matter if the shaders are in
    one file or not. OpenGL's GLSL for the most part forces the separation of shader
    types.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单独的`.metal`文件中，既有顶点着色器也有片段着色器，但通常着色器是单独编写的。Xcode和Metal会将项目中的所有`.metal`文件合并，所以着色器是否在一个文件中并不重要。OpenGL的GLSL大部分情况下强制着色器类型的分离。
- en: For years, OpenGL worked well for many different GPUs but as we all see, Apple
    Metal allows us to perform draw calls up to 10x times faster than OpenGL ES.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，OpenGL为许多不同的GPU提供了良好的工作效果，但正如我们所见，Apple Metal允许我们以比OpenGL ES快10倍的速度执行绘制调用。
- en: Why is Metal faster than OpenGL ES?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Metal比OpenGL ES快？
- en: In late 2013, Apple announced the **iPhone 5s**. Built into the 5s was the **A7
    Processor**, the first 64 bit GPU for the iOS device family. It provided a decent
    graphical boost compared with prior devices and reflected how GPUs in mobile devices
    were quickly catching up to gaming consoles released just a few years prior. OpenGL,
    though a staple in low-level graphics APIs, didn't squeeze the most out of the
    A7 chip.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在2013年底，Apple宣布了**iPhone 5s**。5s内置了**A7处理器**，这是iOS设备家族的第一个64位GPU。与之前的设备相比，它提供了相当不错的图形提升，并反映了移动设备中的GPU如何快速赶上几年前发布的游戏机。尽管OpenGL是底层图形API的基石，但它并没有充分利用A7芯片。
- en: Seen in the next diagram, the interaction between the CPU and GPU doesn't always
    perform the optimal way we'd want it to for our games.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图中可以看到，CPU和GPU之间的交互并不总是以我们希望的方式为我们的游戏执行。
- en: '![Why is Metal faster than OpenGL ES?](img/00076.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![为什么Metal比OpenGL ES快？](img/00076.jpeg)'
- en: 'Be it textures, shaders, or render targets, draw calls use their own state
    vector. The CPU via the low-level API uses much of that time verifying the state
    of the draw call. This process is very expensive for the CPU. What happens is
    that in many cycles, the GPU is sitting idle, waiting for the CPU to finish its
    past instruction. Here''s what''s taking up all of that time in the API:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是纹理、着色器还是渲染目标，绘制调用都使用它们自己的状态向量。CPU通过低级API使用大量时间来验证绘制调用的状态。这个过程对CPU来说非常昂贵。发生的情况是，在许多周期中，GPU处于空闲状态，等待CPU完成其之前的指令。以下是API中占用所有这些时间的操作：
- en: '**State validation**: Confirming API usage is valid. This encodes API state
    to the hardware state.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态验证**：确认API使用是有效的。这会将API状态编码到硬件状态。'
- en: '**Shader compilation**: Runtime generation of the shader machine code. This
    deals with interactions between the state and shaders.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器编译**：运行时生成着色器机器代码。这涉及到状态和着色器之间的交互。'
- en: '**Sending work to the GPU**: Managing resource residency batching commands.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向 GPU 发送工作**：管理资源驻留批处理命令。'
- en: What Apple did with their Metal API is do these steps in a smarter fashion.
    Shader compilation is done during the application's load time. There's no need
    to reload the shaders every cycle; this was simply a relic of older hardware limitations.
    This is why in our previous code example, we can build more than one shader in
    one Metal file, while this was prohibited in OpenGL ES. State validation, though
    important, doesn't need to be checked every cycle. Checking the state validation
    can be set to happen only when new content is loaded.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在他们的 Metal API 中所做的，是以更智能的方式完成这些步骤。着色器编译是在应用程序的加载时间完成的。不需要在每个周期重新加载着色器；这仅仅是旧硬件限制的遗迹。这就是为什么在我们的上一个代码示例中，我们可以在一个
    Metal 文件中构建多个着色器，而在 OpenGL ES 中这是被禁止的。尽管状态验证很重要，但不需要在每个周期进行检查。状态验证的检查可以设置为仅在加载新内容时发生。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Even with Metal's advantages, this is why it's recommended to store 2D animations
    in **SpriteSheets**. We mentioned SpriteSheets back in our discussion of on SpritKit.
    They are a collection of sprites fitted onto one texture. The graphics pipeline
    then only has to deal with one version of that content. Internally under the hood
    of SpriteKit, the GPU then doesn't have to do as many state vector calls compared
    to having each character animation being placed on its own separate texture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Metal 有其优势，这也是为什么建议将 2D 动画存储在 **SpriteSheets** 中的原因。我们之前在讨论 SpritKit 时提到了
    SpriteSheets。它们是一组适合在一个纹理上的精灵。图形管线随后只需处理该内容的单个版本。在 SpriteKit 的内部机制下，与每个角色动画都放置在其单独的纹理上相比，GPU
    内部不需要进行那么多的状态向量调用。
- en: 'The last process for the CPU is when it sends the information out to the GPU
    for processing. This is going to be done during each draw call, and in either
    Metal or Open GL ES, it will still be this process that will happen the most frequently.
    Here is the result of this internal, low-level restructuring done in the Metal
    API:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 的最后一个处理过程是将信息发送到 GPU 进行处理。这将在每次绘制调用期间完成，无论是在 Metal 还是 Open GL ES 中，这个过程都将是最频繁发生的。以下是
    Metal API 中进行的这种内部、低级别重构的结果：
- en: '![Why is Metal faster than OpenGL ES?](img/00077.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![为什么 Metal 比 OpenGL ES 快？](img/00077.jpeg)'
- en: As we see in the diagram from *WWDC14*, there are up to 10 extra draw calls
    that can be added during the render cycle! We can use that time saved for other
    processes instead of extra draw calls, such as more physics or AI in our games.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *WWDC14* 的图中看到的，在渲染周期中可以添加多达 10 个额外的绘制调用！我们可以利用节省下来的时间用于其他过程，而不是额外的绘制调用，例如在我们的游戏中增加更多的物理或人工智能。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The cycle diagrams shown are from the original Metal API announcement at *WWDC2014*
    and used a frame rate of 30 fps. If developing for VR where 60 fps or greater
    is necessary for a working game, these numbers are halved. Either way this is
    rather impressive for mobile device GPUs. Search online for games made in Metal
    and you'd be impressed. With this much room to add more to our game during each
    render cycle, there's no reason not to have an impressive game at the full 60
    fps. Additionally, as of iOS 9, the SpriteKit and SceneKit frameworks by default
    are backed by Metal. Even if the Metal API is too much to understand, we can still
    utilize these render saving benefits from what we already learned about these
    frameworks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的周期图来自 *WWDC2014* 上原始 Metal API 的公告，并使用了 30 fps 的帧率。如果开发 VR 游戏需要 60 fps 或更高的帧率，这些数字将减半。无论如何，这对于移动设备
    GPU 来说都非常令人印象深刻。在网上搜索使用 Metal 开发的游戏，你会感到惊讶。由于在每个渲染周期中都有这么多的空间来添加更多内容，所以在 60 fps
    下拥有令人印象深刻的游戏是没有理由的。此外，截至 iOS 9，SpriteKit 和 SceneKit 框架默认由 Metal 支持。即使 Metal API
    难以理解，我们仍然可以利用我们从这些框架中学到的渲染节省优势。
- en: The basic Metal object/code structure
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 Metal 对象/代码结构
- en: To finish off our talk about Apple Metal, let's look at an overview of the API's
    object and code structuring. We already briefly saw some shader code in the Metal
    Shading Language, so let's see how we can work with this API in our projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对 Apple Metal 的讨论，让我们看一下 API 的对象和代码结构概述。我们已经在 Metal 着色语言中简要地看到了一些着色器代码，所以让我们看看我们如何在项目中使用这个
    API。
- en: '| Objects | Purpose |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 目的 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Device | Reference to the GPU |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | 对 GPU 的引用 |'
- en: '| Command queue | Serial sequence of command buffers |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 命令队列 | 命令缓冲区的串行序列 |'
- en: '| Command buffer | Contains GPU hardware commands |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 命令缓冲区 | 包含GPU硬件命令 |'
- en: '| Command encoder | Translates API commands to GPU hardware commands |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 命令编码器 | 将API命令转换为GPU硬件命令 |'
- en: '| State | Framebuffer configuration, depth, samplers, blend, and so on |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 帧缓冲区配置、深度、采样器、混合等 |'
- en: '| Code | Shaders (vertex, fragment, geometry, and tessellation) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 着色器（顶点、片段、几何和细分） |'
- en: '| Resources | Textures and Data Buffer Objects (vertices, constants, and so
    on) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 纹理和数据缓冲对象（顶点、常量等） |'
- en: The preceding table represents the various types of objects that we'd work with
    if writing a game directly in the Metal API. They are the Device, the State, the
    Command Buffer, our Shaders, Textures, and many more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格表示我们在直接在Metal API中编写游戏时将与之工作的各种对象类型。它们是设备、状态、命令缓冲区、我们的着色器、纹理以及更多。
- en: 'We can import the Metal API into `ViewController.swift` class with the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式将Metal API导入到 `ViewController.swift` 类中：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This imports the Metal API. The QuartzCore API is needed as well since the `CAMetalLayer`
    object we will work with is a member of that library. Also, make sure that you
    set your target device to an actual iOS device as new or newer than the iPhone
    5S, the Xcode simulator does not support Metal. Otherwise, Xcode will give you
    the *Could Not Build* Objective-C model `Metal` error. This is true as of the
    writing of this book with the Xcode 7 Beta. Over time and probably after the official
    public release of the El Capitan OS, this will no longer be needed. For now, to
    test your own custom Metal code, you will have to test on an actual device. Doing
    so will involve having to pay for your own Apple Development account. More on
    this is given in the next chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这导入了Metal API。还需要QuartzCore API，因为我们将要与之工作的 `CAMetalLayer` 对象是该库的一个成员。同时，确保将您的目标设备设置为实际iOS设备，新或更新的iPhone
    5S，Xcode模拟器不支持Metal。否则，Xcode将给出“无法构建”Objective-C模型 `Metal` 错误。截至本书编写时的Xcode 7
    Beta版本，这是真的。随着时间的推移，很可能在El Capitan OS的官方公共版本发布后，这将不再需要。目前，为了测试您自己的自定义Metal代码，您必须在实际设备上进行测试。这样做将涉及支付自己的Apple开发账户费用。更多内容将在下一章中介绍。
- en: 'Here''s the order in which we''d have to work with the objects in the table
    shown previously as well as some code samples in Swift that accomplish these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要按照的顺序与之前显示的表格中的对象一起工作，以及一些用Swift实现的这些步骤的代码示例：
- en: 'Create the reference to the Device with the `MTLDevice` class as:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MTLDevice` 类创建对设备的引用：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `CAMetalLayer` object for these objects to be placed on the screen
    as:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这些对象在屏幕上创建一个 `CAMetalLayer` 对象：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create Vertex Data/Buffer Object(s) (VBOs) to send data to shaders as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶点数据/缓冲对象（VBOs），如下发送数据到着色器：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create our shaders that will work with these VBOs.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这些VBO创建将与之工作的着色器。
- en: We did this in our previous shader code samples. The vertex data combined with
    our previously made shaders together create a simple white triangle to the screen.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在之前的着色器代码示例中做了这件事。顶点数据与之前制作的着色器结合，在屏幕上创建了一个简单的白色三角形。
- en: 'Set up a Render Pipeline as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下设置渲染管线：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a command queue as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下创建一个命令队列：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To actually render these objects in our game, we''d have to do the following
    processes in our view controller:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏中实际渲染这些对象，我们必须在视图控制器中执行以下过程：
- en: Create a display link. This is a timer that refreshes every time the screen
    refreshes. It's a member of the class `CADisplayLink` and at every screen refresh,
    we call the `gameRenderLoop` function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示链接。这是一个每次屏幕刷新时都会刷新的计时器。它是 `CADisplayLink` 类的一个成员，并且每次屏幕刷新时，我们都会调用 `gameRenderLoop`
    函数。
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `gameRenderLoop` function can look like the following. It calls the soon-to-be
    filled in function, `render()`:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gameRenderLoop` 函数可能看起来像以下这样。它调用即将填充的函数 `render()`：'
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a Render Pass Descriptor. For this example, a mostly red texture is
    to be created around our white triangle as shown here:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个渲染传递描述符。对于这个例子，要在我们的白色三角形周围创建一个主要为红色的纹理，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a Command Buffer in our `render()` function:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `render()` 函数中创建一个命令缓冲区：
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a Render Command Encoder. In other words, a set of commands for `commandQueue`.
    In the code example given later, this tells the GPU to draw triangles with the
    VBO we created earlier. This is placed (in this example) in the `render()` function.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个渲染命令编码器。换句话说，是 `commandQueue` 的一组命令。在稍后的代码示例中，这告诉GPU使用我们之前创建的VBO绘制三角形。这被放置（在这个例子中）在
    `render()` 函数中。
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Commit your Command Buffer. This essentially tells the GPU to do its draw call
    based on the commands that have been packed into the `commandBuffer` object. Place
    this after the past code's `if` statement in the `render()` function.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的命令缓冲区。这本质上告诉GPU根据已经打包到`commandBuffer`对象中的命令进行绘制调用。在`render()`函数中，将此代码放在之前的`if`语句之后。
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That is the short of it. That's the general process of drawing a simple triangle
    to the screen and manually creating the render loop on the GPU.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的简短版本。这是在屏幕上绘制一个简单的三角形并手动在GPU上创建渲染循环的一般过程。
- en: Should you rather opt for SpriteKit and SceneKit to do all of this manual work
    for you? That would be understandable. Remember though, like when playing a game
    on hard mode, it comes with its rewards to take the harder route. Yes, as of iOS
    9, the SpriteKit and SceneKit frameworks are default to Metal. Game engines, such
    as Unity and Unreal Engine, even implement Metal when converting projects to the
    platform. However, knowing how to build your games in a low-level graphics API,
    such as Metal or OpenGL, will give the developer the ability to have the potential
    for most lean/fast performing game for the device family. Be sure to check out
    some of the games created with Metal next time you search online. They can really
    give your players a great experience. At the same time, this can challenge your
    skills as a game developer since being a game developer is the combination of
    an artist, engineer, and computer scientist. Working directly in the GPU's basic
    functions will challenge all of that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否更愿意选择SpriteKit和SceneKit来为你完成所有这些手动工作？这是可以理解的。但记住，就像在困难模式下玩游戏一样，选择更难的路线也会带来回报。是的，从iOS
    9开始，SpriteKit和SceneKit框架默认使用Metal。游戏引擎，如Unity和Unreal Engine，在将项目转换为平台时也会实现Metal。然而，了解如何在Metal或OpenGL这样的低级图形API中构建你的游戏，将赋予开发者创建性能最优化游戏的能力。下次你在网上搜索时，一定要查看一些使用Metal创建的游戏。它们真的可以为你的玩家提供极佳的体验。同时，这也将挑战你作为游戏开发者的技能，因为成为一名游戏开发者是艺术家、工程师和计算机科学家的结合。直接在GPU的基本功能上工作将挑战这一切。
- en: 'To dive more into the rabbit hole that is low-level graphics development with
    Metal, check out these links:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地探索Metal的低级图形开发这个兔子洞，请查看以下链接：
- en: '[https://developer.apple.com/metal/](https://developer.apple.com/metal/)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/metal/](https://developer.apple.com/metal/)'
- en: '[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html](https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/data-types/data-types.html)'
- en: '[http://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started](http://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started](http://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started)'
- en: '[https://realm.io/news/3d-graphics-metal-swift/](https://realm.io/news/3d-graphics-metal-swift/)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://realm.io/news/3d-graphics-metal-swift/](https://realm.io/news/3d-graphics-metal-swift/)'
- en: The first link is to the official Apple Developer page for Metal. The next link
    is Apple's list of data types used in the Metal API. The last two links are two
    separate tutorials to make simple Metal scenes in Swift. Some of the code we used
    can be found in these tutorials as well as full Xcode projects. The first of these
    two links are to the iOS tutorial site [www.raywenderlich.com](http://www.raywenderlich.com).
    The last link is to a page that has a great video presentation and full instructions
    on Swift and Metal 3D graphics by former Apple Engineer, *Warren Moore*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个链接是苹果官方开发者页面上的Metal页面。下一个链接是苹果在Metal API中使用的数据类型列表。最后两个链接是两个使用Swift创建简单Metal场景的教程。我们使用的部分代码也可以在这些教程以及完整的Xcode项目中找到。这两个链接中的第一个链接是iOS教程网站[www.raywenderlich.com](http://www.raywenderlich.com)。最后一个链接是一个页面，上面有前苹果工程师*沃伦·摩尔*关于Swift和Metal
    3D图形的精彩视频演示和完整说明。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congrats on getting this far. If this book were a game, we'd probably have earned
    an achievement for this chapter alone. As we saw, working with a low-level API
    such as Metal can be a bit daunting. We first reviewed what it means when developers
    and engineers mention lower and upper level frameworks and code. On the CPU side,
    we saw that the lowest level is the machine's code with Swift and Objective-C
    in the middle, and above C/C++ and Assembly code. Next, we spoke about the GPU
    side and where the visual graphics APIs we've gone over in the past chapters stand
    in the hierarchy. We then got an understanding of the history of lower-level graphics
    APIs such as OpenGL ES, how the graphic pipeline generally works under the hood,
    and how to make basic shaders. Finally, we reviewed why Metal is faster during
    the render cycle than OpenGL, the general structure behind Metal, and some of
    the code/objects used to manually set up the render loop. This chapter merely
    scratched the surface on this topic, so if you are up to the challenge, it's highly
    recommended to continue reading documentation on how Metal can make your games
    stand out from the rest.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到这一步。如果这本书是一部游戏，我们可能仅凭这一章就能获得成就。正如我们所见，使用像Metal这样的低级API可能会有些令人畏惧。我们首先回顾了当开发者和工程师提到低级和高级框架以及代码时，这意味着什么。在CPU方面，我们看到最低级的是机器代码，Swift和Objective-C位于中间，而C/C++和汇编代码位于其上。接下来，我们讨论了GPU方面，以及我们在前几章中提到的视觉图形API在层次结构中的位置。然后，我们了解了低级图形API（如OpenGL
    ES）的历史，图形管道在底层通常是如何工作的，以及如何制作基本的着色器。最后，我们回顾了为什么Metal在渲染周期中比OpenGL更快，Metal背后的总体结构，以及一些用于手动设置渲染循环的代码/对象。这一章只是在这个主题上略作探讨，所以如果你愿意接受挑战，强烈建议继续阅读有关Metal如何让你的游戏与众不同的文档。
- en: At this point, you should now have all that it takes to make a game on the iOS
    platform. The last essential lesson for iOS game development is learning how to
    test, publish, and update your published game in the app store. In the next chapter,
    let's learn how to get that game on the Apple app store.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经拥有了在iOS平台上制作游戏所需的一切。iOS游戏开发的最后一堂必修课是学习如何测试、发布和更新你在App Store上发布的应用。在下一章中，我们将学习如何将游戏上传到Apple
    App Store。
