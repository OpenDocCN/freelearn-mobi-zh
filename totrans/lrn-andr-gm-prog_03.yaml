- en: Managing Inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to run a program on the Android Emulator, it is
    time for us to do some more cool stuff, which will equip us with the knowledge
    required to make our game. In this chapter, we will continue with XML files and
    will step into the territory of taking user inputs. In a gist, we will be learning
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different types of XML files and the resource folder further
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating buttons and linking them to take inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with accelerometer readings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile touch inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Resource folder in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we used the `activity_fullscreen.xml` file to edit the
    frontend of our application. Now, we will take a look at some more of these XML
    files and understand how they can be useful to us for making games. To understand
    these type of files, we must first know a little bit about them. To start off,
    the very basic information about XML is that it's a short form of *Extensible
    Markup Language*. Now, if you have studied HTML, you will know that its full form
    is quite similar to it--HyperText Markup Language. It's quite similar in syntax
    as well, but the function of an XML file is to hold data. If you go by the definition
    of an XML file, it goes something like this: XML is a software and hardware-independent
    tool for storing and transporting data.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about XML files at [https://en.wikipedia.org/wiki/XML](https://en.wikipedia.org/wiki/XML).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have not yet seen an XML file in the code yet, so let''s do that. Click
    on Text as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_01_33.png)'
  prefs: []
  type: TYPE_IMG
- en: The Text mode for code editing is just besides the Design button
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can actually see the XML code opened up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_01_34.png)'
  prefs: []
  type: TYPE_IMG
- en: This is your default XML code
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to this code, and you will find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you see this, you can observe your `Hello World!` text on the very first
    line of this code. The data that we changed visually in our previous chapter can
    be changed through code over here. It is almost the same for all components, and
    you will learn about different components as you practice further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is not the only type of XML file. As we read in the definition, XML
    files are used to store data. Let''s see the other kinds of XML files, which can
    be used to store data. We can use these files for storing game scores, filenames,
    text data, and so much more. Let''s take one such new type of XML file, which
    is already available in our project folder to understand further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_01_35.png)'
  prefs: []
  type: TYPE_IMG
- en: The strings.xml file contains all your string data and is in the res/values/
    folder
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `app/res/values/` folder and double-click on the strings.xml file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the code for this file when you open it. Here, you can observe
    that there are multiple values and an ID to each value in the form of a `name`.
    Observe carefully the second line that reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember this name? We had set this as our app name when we started the project.
    It is stored in the value `app_name`. Also, if you go back and search for `app_name` using
    *Ctrl* + *F *on your `activity_fullscreen.xml` file, you will find this entry.
    Go ahead and explore a little for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, check out the other files to get an understanding. Here''s a basic explanation
    for the four XML files in our project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attrs.xml`: This declares custom theme attributes that allow changing the
    styles that are used for button bars, depending on the API level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colors.xml`: This defines colors that can be used in hex code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings.xml`: This holds data for all string-related values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styles.xml`: This sets the base theme of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, that's it about XML files. Let's now move on to something even more interesting--inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Taking user inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways in which you can take inputs from your Android device.
    Here are a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'UI buttons: Buttons drawn on your app''s UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardware buttons: The keys on your Android device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch screen inputs: Touches mapped based on the screen coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accelerometer readings: Motion sensor readings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be taking a look at each of these input types. So, let's start with
    the very first type of input, UI buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Button input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The button input is one of the most common type of components used in an Android
    project. Let''s come back to our design mode and create a button on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_01_36.png)'
  prefs: []
  type: TYPE_IMG
- en: Reverting back to Design mode from Text mode
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Design button and switch back to our visual editor mode on our activity_fullscreen.xml file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will need to do some changes to our XML file. Follow the steps as
    mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Palette, scroll down and find Linear Layout(Horizontal) and drag and
    drop it inside the fullscreen_content_controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Component Tree window below the Palette, drag and drop your TextView under
    your newly created LinearLayout(horizontal).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Button component from your Palette and drag and drop it in into your
    Component Tree window's LinearLayout(horizontal).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you do this, you will get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: You now have a button and text on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If we had not used the Linear Layout component, then our button and text would
    have overlapped each other since if you observe in your Component Tree our TextView
    was initially inside FrameLayout, which does not have alignment options. You can
    try dragging your button and text inside the FrameLayout and see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s proceed toward making this button work. Click on your newly created
    button, and in the properties window on right side, take a look at the ID property.
    This is the property that lets your code know which button to interact with; change
    it to `myFirstButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now given a custom ID to your button.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the same for your TextView by changing its ID to `myTextView`. Keep these
    two IDs in mind, and let's move on to our next step. Now, we will actually link
    this visual button to our code, so we can change the text of our TextView component. Go
    to your `app/java/nikhil.nikmlnkr.game` folder and open up the FullscreenActivity.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `nikhil.nikmlnkr.game` is the package name used in this book. Your
    package name might be different based on what you set it initially, so navigate
    to the folder based on your package name. For the purpose of this book, we will
    assume the package name is `nikhil.nikmlnkr.game`.
  prefs: []
  type: TYPE_NORMAL
- en: After we open that file, we will have opened the main Java code for our application.
    You can see that there is already a lot of code written over there. Don't get
    overwhelmed by it because soon you will understand on your own what each code
    block is about. Let's start by writing some code of our own to get started to
    link our button to our code file; search for the `void onCreate` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `onCreate()` method is where you initialize your activity. If the activity
    is started and the application is not loaded, then both `onCreate()` methods will
    be called. You can initialize your variables and methods over here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify it to look somewhat like this; changes are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By writing this code, you have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linked your button's ID to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked your text view's ID to your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a button click listener, which is needed, to take input from a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you are ready with this, run your app on the emulator with the steps we learned
    in the preceding chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: On pressing our Button, the text will change to Button Clicked, as we coded
    in our file.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware button input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s test out our hardware buttons along with a Toast example. Don''t
    feel hungry yet reading Toast! It''s not the one that you are going to eat. A
    Toast is a message that gets displayed on your screen for a few seconds and disappears.
    You will see what it is in a few minutes. So, now open up your `FullscreenActivity.java`
    file where you typed your `onCreate` code, and after your `onCreate` method, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Observe the code here. In the first line, we have used the keyword `@Override`.
    This is because we are overriding the parent class functionality, which is the
    default Android behavior to do something else that we want. If you do not override
    the function, then by default Android will close the app since that is the function
    of the back button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are getting an error on Toast with a red underline, then click on the
    text where you are getting the error and then press *Alt* + *Enter*. This will
    add the missing imports that are required to be included for running it. Once
    you are done with it, run your app again on the emulator, and you will see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: So, now you have successfully mapped your hardware button to display a Toast
    message. Bravo! Let's move ahead and try to track our touch coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Touch input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen how to map our hardware buttons, let''s dive deeper into
    the most commonly used input on Android: touch input. However, before we understand
    touch input, we must understand the coordinate system used to track touches on
    the screen. Let''s take a look at the following illustration to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Coordinates system in Android
  prefs: []
  type: TYPE_NORMAL
- en: In order to track our touches, we must have a basic understanding of how screen
    coordinates are mapped on our device. As you can see in the preceding image, our
    screen's coordinates start from (0,0) at the top-left corner and end at the bottom-right
    corner with **(w,h)** where w is the screen width and h is the screen height.
    So, let's say if your phone's resolution is 480 x 850, then your bottom-right
    corner coordinates will be `w=480`, `h=850`. Thus, your extreme coordinates will
    be mapped as (480,850). Just keep this in mind, and you will understand the reason
    why we need to know this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open up your XML file and drag and drop another TextView component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Give it an ID `coords` and text as `Coords`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on your LinearLayout from the Component Tree view and give it an ID
    as `parent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to your `FullscreenActivity.java` code file and modify your `onCreate`
    function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To give an explanation for the preceding code, what we have done over here
    is quite simple: we have declared a reference for our LinearLayout as `parent`
    and then another reference for our newly created coords(TextView). Now, after
    our declaration, we instructed the `parent` class to have a `Touch listener` property
    on it. This will help us get the coordinates that we touched. As you can see in
    the preceding code, we have a `MotionEvent` variable `ev`, which will give us
    the coordinates. Then, in the next line, we fetched the value in the form of *x*
    and *y* coordinates, which will then be set as text on our coords(TextView).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run your code now, and when the emulator starts, try clicking
    randomly anywhere; that will give you coordinates that you just touched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: It will show you where you touched on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, by this time, you must have observed that it is pretty tedious to drag
    and drop and align all the texts properly, right? That is because we are working
    with LinearLayout. There is a way through which you can organize all your texts
    properly. That is through RelativeLayout. Let''s take a look at a working example
    to help you get a better understanding of the same. Go to the TextView of your
    XML file as we learned to do in the preceding chapter, and wherever you see LinearLayout change
    it to RelativeLayout. Here is a reference code for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you have successfully converted your LinearLayout to RelativeLayout, which
    will give you more control over your design options. You can now adjust your components
    on screen with more ease, and so you can align them nicely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you do this, you can easily adjust your texts by simply dragging them anywhere
    you want. You won't mess up the layouts when you use RelativeLayouts. Now, let's
    move on to the next example for getting accelerometer inputs, and take another TextView
    component on screen for that as you see in the preceding code and give it an ID
    `accel` with a text `Accelerometer`. However, before we proceed with the code
    for the same, there is a minor change that we need to do in our existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we just changed our LinearLayout to RelativeLayout, we also have to reference
    the same for our touch function in our Java code file. Open up your Java code
    file, and there you will observe that it is already giving you an error prompt
    on LinearLayout. That is because there is actually no LinearLayout in our project
    with the ID parent because we changed it to RelativeLayout. Don''t worry about
    this though; simply type in RelativeLayout instead of LinearLayout, and you are
    sorted. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app once, and you can see how neat it looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have successfully made pretty neat adjustments to our layout as well
    as implemented a touch listener to detect touches.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we move on to our final type of input for this chapter, *The Accelerometer
    input*.
  prefs: []
  type: TYPE_NORMAL
- en: The Accelerometer input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now take a look at the accelerometer component on Android. If you don''t
    know what an accelerometer is, it is something that is used to detect movement
    in Android. In layman terms, we can call it the motion sensor. The best example
    for this is any racing game that lets you control the car based on your phone''s
    movement. This is something really interesting, which you can use in further chapters
    to apply motion to objects, so make sure that you grasp this properly. Type in
    the code you see in the following block starting from `sensorManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, over here if you get an error related to import statements while typing,
    then press *Alt* + *Enter* and you will be prompted with suggestions. Select the
    corresponding import statement from the list to solve the error. Now, the code
    will be explained. We made a variable for our `sensorManager` component of Android,
    which is responsible for tracking our `accelerometer` values. As you can see after
    the line following it, we have taken the sensor type as `TYPE_ACCELEROMETER`.
    Next, we created another listener for our component and then we took in the `x`,
    `y`, and `z` values. After that, we simply took a reference to the accel TextView
    component in our XML file and set its text to display those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is obvious that you won''t be able to see accelerometer values changing
    on your emulator, so you will have to test it on your mobile device. However,
    just for curiosity''s sake, try and run the code on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_15.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see some values, but they will not be changing because our PC does
    not have a motion sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s run our app on our mobile now. We can do this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and deploy directly to our device through USB, which will allow us to
    run the app directly on a physical device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an apk and then transfer the apk file to our phone and install it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying through USB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make your device ready for debugging you need to enable your device for
    debugging first. In order to enable your device for debugging in Developer options.
    To access these settings, open the Developer options in the system settings. On
    Android 4.2 and higher versions, the Developer options screen is hidden by default.
    To make it visible, go to Settings | About phone and tap on Build number seven
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, return to the previous screen to find Developer options at the
    bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, enable the USB debugging option on your device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With an Android-powered device, you can develop and debug your Android applications
    just as you would on the emulator. Before you can start, there are just a few
    things to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that your application is debuggable in your manifest or `build.gradle`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the build file, make sure that the `debuggable` property in the `debug`
    build type is set to true. The build type property overrides the manifest setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `AndroidManifest.xml` file, add `android:debuggable="true"` to the `<application>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If you manually enable debugging in the manifest file, ensure that you
    disable it in your release build (your published application should usually *not*
    be debuggable).'
  prefs: []
  type: TYPE_NORMAL
- en: Enable USB debugging in the device system settings, under Settings | Developer
    options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: On Android 4.2 and newer versions, Developer options is hidden by default.
    To make it available, go to Settings | About phone and tap on Build number seven
    times. Return to the previous screen to find Developer options.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set up your system to detect your device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're developing on Windows, you need to install a USB driver for ADB. For
    an installation guide and links to OEM drivers, refer to the [OEM USB Drivers](https://developer.android.com/tools/extras/oem-usb.html)
    document.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're developing on macOS X, it just works, so skip this step.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re developing on Ubuntu Linux, you need to add a udev rules file that
    contains a USB configuration for each type of device you want to use for development.
    In the rules file, each device manufacturer is identified by a unique vendor ID,
    as specified by the ATTR{idVendor} property. For a list of vendor IDs, refer to [USB
    Vendor IDs](https://developer.android.com/studio/run/device.html#VendorIds), as
    follows. To set up device detection on Ubuntu Linux, perform the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Log in as root and create this file: `/etc/udev/rules.d/51-android.rules`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following format to add each vendor to the file:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", MODE="0666", GROUP="plugdev"`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, the vendor ID is for HTC. The MODE assignment specifies read/write
    permissions, and GROUP defines which Unix group owns the device node.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: The rule syntax may vary slightly depending on your environment. Consult
    the udev documentation for your system as needed. For an overview of rule syntax,
    refer to this guide at [writing udev rules](http://www.reactivated.net/writing_udev_rules.html).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, execute `chmod a+r /etc/udev/rules.d/51-android.rules`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: When you connect a device running Android 4.2.2 or higher versions to
    your computer, the system shows a dialog asking whether to accept an RSA key that
    allows debugging through this computer. This security mechanism protects user
    devices because it ensures that USB debugging and other ADB commands cannot be
    executed unless you''re able to unlock the device and acknowledge the dialog.
    This requires that you have ADB version 1.0.31 (available with SDK Platform-tools
    r16.0.1 and higher) in order to debug on a device running Android 4.2.2 or higher
    versions.'
  prefs: []
  type: TYPE_NORMAL
- en: When plugged in over USB, you can verify that your device is connected by executing
    ADB devices from your SDK platform-tools/ directory. If connected, you'll see
    the device name listed as a device.
  prefs: []
  type: TYPE_NORMAL
- en: On pressing run or debugging your application, you will be presented with a
    Device Chooser dialog that lists the available emulator(s) and connected device(s).
    Select the device on which you want to install and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: If using the **Android Debug Bridge** (**ADB**), you can issue commands with
    the `-d` flag to target your connected device.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the vendor IDs at [https://developer.android.com/studio/run/device.html](https://developer.android.com/studio/run/device.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building an apk and installing on device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the top task bar where you see File, Edit, and so on, click on Build and
    then click on Generate APK. Once you have done this, it will start generating
    an apk for you. Once it is finished right-click on your app folder, which is on
    the left-hand side, as seen in the following screenshot, and click on Show in
    Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Show in Explorer will open the window in which your project folder is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In your project folder, navigate to the `app/build/outputs/apk/` folder, and
    there you will see your `app-debug.apk` file. Transfer this onto your mobile phone
    and install the apk and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_03_20.png)'
  prefs: []
  type: TYPE_IMG
- en: Accelerometer values will change as you move your phone around.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You also learned how to create an apk and run it on your actual
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to take different types of user inputs
    and also how to generate an apk and run it on your actual device. You also learned
    the various types of XML files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create sprites--no, not the cold drink!
    We will learn how to create images as well as play with colors. The next chapter
    will be our entry into creating graphics on screen and will be a big step for
    you.
  prefs: []
  type: TYPE_NORMAL
