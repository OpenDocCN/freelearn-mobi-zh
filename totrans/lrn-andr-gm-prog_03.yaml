- en: Managing Inputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理输入
- en: 'Now that we have learned how to run a program on the Android Emulator, it is
    time for us to do some more cool stuff, which will equip us with the knowledge
    required to make our game. In this chapter, we will continue with XML files and
    will step into the territory of taking user inputs. In a gist, we will be learning
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在 Android 模拟器上运行程序，是时候我们做一些更酷的事情了，这将使我们具备制作游戏所需的知识。在本章中，我们将继续探讨 XML
    文件，并进入获取用户输入的领域。简而言之，我们将学习以下内容：
- en: Exploring different types of XML files and the resource folder further
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索不同类型的 XML 文件和资源文件夹
- en: Creating buttons and linking them to take inputs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮并将它们链接起来以获取输入
- en: Working with accelerometer readings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与加速度计读数一起工作
- en: Mobile touch inputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动触摸输入
- en: So, let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧。
- en: Resource folder in detail
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源文件夹的详细情况
- en: In the last chapter, we used the `activity_fullscreen.xml` file to edit the
    frontend of our application. Now, we will take a look at some more of these XML
    files and understand how they can be useful to us for making games. To understand
    these type of files, we must first know a little bit about them. To start off,
    the very basic information about XML is that it's a short form of *Extensible
    Markup Language*. Now, if you have studied HTML, you will know that its full form
    is quite similar to it--HyperText Markup Language. It's quite similar in syntax
    as well, but the function of an XML file is to hold data. If you go by the definition
    of an XML file, it goes something like this: XML is a software and hardware-independent
    tool for storing and transporting data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了 `activity_fullscreen.xml` 文件来编辑应用程序的前端。现在，我们将查看更多这类 XML 文件，并了解它们如何对我们制作游戏有所帮助。为了理解这类文件，我们首先需要了解一些关于它们的基本信息。首先，关于
    XML 的最基本信息是它是一种扩展标记语言的简称。现在，如果你已经学习了 HTML，你会知道它的全称与它非常相似——超文本标记语言。它们的语法也非常相似，但
    XML 文件的功能是存储数据。如果你按照 XML 文件的定义来看，它可能如下所示：XML 是一种软件和硬件独立的存储和传输数据的工具。
- en: You can read more about XML files at [https://en.wikipedia.org/wiki/XML](https://en.wikipedia.org/wiki/XML).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://en.wikipedia.org/wiki/XML](https://en.wikipedia.org/wiki/XML)
    上了解更多关于 XML 文件的信息。
- en: 'We have not yet seen an XML file in the code yet, so let''s do that. Click
    on Text as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在代码中看到 XML 文件，所以让我们来做这件事。点击以下截图所示的“文本”：
- en: '![](img/B05066_01_33.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_01_33.png)'
- en: The Text mode for code editing is just besides the Design button
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑的文本模式就在设计按钮旁边
- en: 'Now, you can actually see the XML code opened up:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你实际上可以看到打开的 XML 代码：
- en: '![](img/B05066_01_34.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_01_34.png)'
- en: This is your default XML code
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的默认 XML 代码
- en: 'Pay close attention to this code, and you will find something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细关注这段代码，你会发现如下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you see this, you can observe your `Hello World!` text on the very first
    line of this code. The data that we changed visually in our previous chapter can
    be changed through code over here. It is almost the same for all components, and
    you will learn about different components as you practice further.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个，你可以在代码的第一行看到你的“Hello World!”文本。我们在上一章中通过视觉方式更改的数据可以通过代码在这里进行更改。对于所有组件来说，几乎都是一样的，随着你进一步练习，你将了解不同的组件。
- en: 'Now, this is not the only type of XML file. As we read in the definition, XML
    files are used to store data. Let''s see the other kinds of XML files, which can
    be used to store data. We can use these files for storing game scores, filenames,
    text data, and so much more. Let''s take one such new type of XML file, which
    is already available in our project folder to understand further:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这并不是唯一的 XML 文件类型。正如我们在定义中读到的，XML 文件用于存储数据。让我们看看其他类型的 XML 文件，这些文件可以用来存储游戏得分、文件名、文本数据等等。让我们取一个这样的新类型的
    XML 文件，它已经存在于我们的项目文件夹中，以便进一步了解：
- en: '![](img/B05066_01_35.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_01_35.png)'
- en: The strings.xml file contains all your string data and is in the res/values/
    folder
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: strings.xml 文件包含所有字符串数据，位于 res/values/ 文件夹中
- en: Navigate to the `app/res/values/` folder and double-click on the strings.xml file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 `app/res/values/` 文件夹，并双击 `strings.xml` 文件。
- en: 'You can see the code for this file when you open it. Here, you can observe
    that there are multiple values and an ID to each value in the form of a `name`.
    Observe carefully the second line that reads as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个文件时，你可以看到这个文件的代码。在这里，你可以观察到每个值都有多个值和一个以 `name` 形式的 ID。仔细观察第二行，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember this name? We had set this as our app name when we started the project.
    It is stored in the value `app_name`. Also, if you go back and search for `app_name` using
    *Ctrl* + *F *on your `activity_fullscreen.xml` file, you will find this entry.
    Go ahead and explore a little for yourself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个名字吗？我们在开始项目时将其设置为我们的应用程序名称。它存储在`app_name`的值中。另外，如果您回到`activity_fullscreen.xml`文件并使用*Ctrl*
    + *F*搜索`app_name`，您将找到此条目。您可以自己探索一下。
- en: 'Also, check out the other files to get an understanding. Here''s a basic explanation
    for the four XML files in our project folder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还要查看其他文件以了解情况。以下是项目文件夹中四个XML文件的基本说明：
- en: '`attrs.xml`: This declares custom theme attributes that allow changing the
    styles that are used for button bars, depending on the API level'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attrs.xml`：这声明了允许根据API级别更改按钮栏样式的自定义主题属性'
- en: '`colors.xml`: This defines colors that can be used in hex code'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors.xml`：这定义了可以使用十六进制代码使用的颜色'
- en: '`strings.xml`: This holds data for all string-related values'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.xml`：这包含所有字符串相关值的数据库'
- en: '`styles.xml`: This sets the base theme of the application'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles.xml`：这设置了应用程序的基本主题'
- en: So, that's it about XML files. Let's now move on to something even more interesting--inputs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于XML文件的内容就到这里了。现在让我们继续到更有趣的部分——输入。
- en: Taking user inputs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: 'There are multiple ways in which you can take inputs from your Android device.
    Here are a few ways:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Android设备获取输入的多种方式。以下是一些方法：
- en: 'UI buttons: Buttons drawn on your app''s UI'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI按钮：绘制在您的应用程序UI上的按钮
- en: 'Hardware buttons: The keys on your Android device'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件按钮：您的Android设备上的按键
- en: Touch screen inputs: Touches mapped based on the screen coordinates
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏输入：基于屏幕坐标映射的触摸
- en: 'Accelerometer readings: Motion sensor readings'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计读数：运动传感器读数
- en: We will be taking a look at each of these input types. So, let's start with
    the very first type of input, UI buttons.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看每种输入类型。所以，让我们从第一种输入类型，UI按钮开始。
- en: Button input
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮输入
- en: 'The button input is one of the most common type of components used in an Android
    project. Let''s come back to our design mode and create a button on the screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮输入是Android项目中使用的最常见组件类型之一。让我们回到设计模式，并在屏幕上创建一个按钮：
- en: '![](img/B05066_01_36.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_01_36.png)'
- en: Reverting back to Design mode from Text mode
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本模式恢复到设计模式
- en: Click on the Design button and switch back to our visual editor mode on our activity_fullscreen.xml file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击设计按钮，切换回我们的activity_fullscreen.xml文件上的视觉编辑模式。
- en: 'Here, we will need to do some changes to our XML file. Follow the steps as
    mentioned:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要对我们的XML文件进行一些更改。按照以下步骤操作：
- en: From the Palette, scroll down and find Linear Layout(Horizontal) and drag and
    drop it inside the fullscreen_content_controls.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中向下滚动，找到线性布局（水平）并将其拖放到fullscreen_content_controls内部。
- en: In the Component Tree window below the Palette, drag and drop your TextView under
    your newly created LinearLayout(horizontal).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调色板下方拖动您的TextView到您刚刚创建的LinearLayout（水平）下。
- en: Select the Button component from your Palette and drag and drop it in into your
    Component Tree window's LinearLayout(horizontal).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从调色板中选择按钮组件并将其拖放到组件树窗口的LinearLayout（水平）中。
- en: 'Once you do this, you will get an output like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您将得到如下输出：
- en: '![](img/B05066_03_05.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_05.png)'
- en: You now have a button and text on the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在屏幕上有一个按钮和文本。
- en: If we had not used the Linear Layout component, then our button and text would
    have overlapped each other since if you observe in your Component Tree our TextView
    was initially inside FrameLayout, which does not have alignment options. You can
    try dragging your button and text inside the FrameLayout and see for yourself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用线性布局组件，那么我们的按钮和文本将相互重叠，因为如果您观察组件树，我们的TextView最初是在FrameLayout内部，它没有对齐选项。您可以尝试将您的按钮和文本拖放到FrameLayout内部，自己看看。
- en: 'Now, let''s proceed toward making this button work. Click on your newly created
    button, and in the properties window on right side, take a look at the ID property.
    This is the property that lets your code know which button to interact with; change
    it to `myFirstButton`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续制作这个按钮工作。点击您刚刚创建的按钮，在右侧的属性窗口中查看ID属性。这是让您的代码知道与哪个按钮交互的属性；将其更改为`myFirstButton`：
- en: '![](img/B05066_03_06.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_06.png)'
- en: You have now given a custom ID to your button.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已为您的按钮分配了一个自定义ID。
- en: Repeat the same for your TextView by changing its ID to `myTextView`. Keep these
    two IDs in mind, and let's move on to our next step. Now, we will actually link
    this visual button to our code, so we can change the text of our TextView component. Go
    to your `app/java/nikhil.nikmlnkr.game` folder and open up the FullscreenActivity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TextView，重复相同的步骤，将其 ID 更改为 `myTextView`。记住这两个 ID，然后继续我们的下一步。现在，我们将实际将这个视觉按钮链接到我们的代码中，以便我们可以更改
    TextView 组件的文本。前往你的 `app/java/nikhil.nikmlnkr.game` 文件夹，并打开 FullscreenActivity。
- en: Note that `nikhil.nikmlnkr.game` is the package name used in this book. Your
    package name might be different based on what you set it initially, so navigate
    to the folder based on your package name. For the purpose of this book, we will
    assume the package name is `nikhil.nikmlnkr.game`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nikhil.nikmlnkr.game` 是本书中使用的包名。你的包名可能因你最初设置的而不同，所以根据你的包名导航到文件夹。为了本书的目的，我们将假设包名是
    `nikhil.nikmlnkr.game`。
- en: After we open that file, we will have opened the main Java code for our application.
    You can see that there is already a lot of code written over there. Don't get
    overwhelmed by it because soon you will understand on your own what each code
    block is about. Let's start by writing some code of our own to get started to
    link our button to our code file; search for the `void onCreate` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开该文件后，我们将打开应用程序的主 Java 代码。你可以看到那里已经写了很多代码。不要被它吓到，因为很快你就会自己理解每个代码块是关于什么的。让我们先编写一些自己的代码，以便开始将按钮链接到代码文件；搜索
    `void onCreate` 函数。
- en: The `onCreate()` method is where you initialize your activity. If the activity
    is started and the application is not loaded, then both `onCreate()` methods will
    be called. You can initialize your variables and methods over here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreate()` 方法是初始化你的活动的地方。如果活动被启动且应用程序未加载，则两个 `onCreate()` 方法都将被调用。你可以在这里初始化你的变量和方法。'
- en: 'You can see something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到类似这样的内容：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, modify it to look somewhat like this; changes are marked in bold:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其修改为看起来像这样；更改已用粗体标出：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By writing this code, you have done the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写此代码，你已经完成了以下操作：
- en: Linked your button's ID to your code
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的按钮 ID 链接到你的代码
- en: Linked your text view's ID to your code
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的文本视图 ID 链接到你的代码
- en: Created a button click listener, which is needed, to take input from a button
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个按钮点击监听器，这是从按钮获取输入所必需的
- en: 'Once you are ready with this, run your app on the emulator with the steps we learned
    in the preceding chapter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好之后，按照我们在上一章中学到的步骤在模拟器上运行你的应用程序：
- en: '![](img/B05066_03_07.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_07.png)'
- en: On pressing our Button, the text will change to Button Clicked, as we coded
    in our file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按下我们的按钮时，文本将更改为“Button Clicked”，正如我们在文件中编码的那样。
- en: Hardware button input
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件按钮输入
- en: 'Now, let''s test out our hardware buttons along with a Toast example. Don''t
    feel hungry yet reading Toast! It''s not the one that you are going to eat. A
    Toast is a message that gets displayed on your screen for a few seconds and disappears.
    You will see what it is in a few minutes. So, now open up your `FullscreenActivity.java`
    file where you typed your `onCreate` code, and after your `onCreate` method, type
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下我们的硬件按钮，并使用 Toast 示例。阅读 Toast 时不要感到饿！它不是你将要吃的那个。Toast 是一个在屏幕上显示几秒钟后消失的消息。你将在几分钟内看到它是什么。所以，现在打开你编写的
    `FullscreenActivity.java` 文件，并在 `onCreate` 方法之后，输入以下内容：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Observe the code here. In the first line, we have used the keyword `@Override`.
    This is because we are overriding the parent class functionality, which is the
    default Android behavior to do something else that we want. If you do not override
    the function, then by default Android will close the app since that is the function
    of the back button.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这里的代码。在第一行，我们使用了关键字 `@Override`。这是因为我们正在覆盖父类功能，这是 Android 默认行为，以便执行我们想要的另一项操作。如果你不覆盖该函数，那么默认情况下
    Android 将关闭应用程序，因为这是返回按钮的功能。
- en: 'If you are getting an error on Toast with a red underline, then click on the
    text where you are getting the error and then press *Alt* + *Enter*. This will
    add the missing imports that are required to be included for running it. Once
    you are done with it, run your app again on the emulator, and you will see the
    following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个带有红色下划线的 Toast 错误，请点击你得到错误的地方，然后按 *Alt* + *Enter*。这将添加运行它所需的缺失导入。完成后，再次在模拟器上运行你的应用程序，你将看到以下输出：
- en: '![](img/B05066_03_08.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_08.png)'
- en: So, now you have successfully mapped your hardware button to display a Toast
    message. Bravo! Let's move ahead and try to track our touch coordinates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经成功地将你的硬件按钮映射到显示Toast消息。太棒了！让我们继续前进，尝试跟踪我们的触摸坐标。
- en: Touch input
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸输入
- en: 'Now that we have seen how to map our hardware buttons, let''s dive deeper into
    the most commonly used input on Android: touch input. However, before we understand
    touch input, we must understand the coordinate system used to track touches on
    the screen. Let''s take a look at the following illustration to understand this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何映射我们的硬件按钮，让我们更深入地探讨Android中最常用的输入方式：触摸输入。然而，在我们理解触摸输入之前，我们必须了解用于跟踪屏幕上触摸的坐标系。让我们看一下下面的插图来理解这一点：
- en: '![](img/B05066_03_09.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_09.png)'
- en: Coordinates system in Android
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的坐标系
- en: In order to track our touches, we must have a basic understanding of how screen
    coordinates are mapped on our device. As you can see in the preceding image, our
    screen's coordinates start from (0,0) at the top-left corner and end at the bottom-right
    corner with **(w,h)** where w is the screen width and h is the screen height.
    So, let's say if your phone's resolution is 480 x 850, then your bottom-right
    corner coordinates will be `w=480`, `h=850`. Thus, your extreme coordinates will
    be mapped as (480,850). Just keep this in mind, and you will understand the reason
    why we need to know this shortly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们的触摸，我们必须对屏幕坐标如何在我们的设备上映射有一个基本的了解。正如你在前面的图像中看到的，我们的屏幕坐标从左上角的(0,0)开始，到右下角的**(w,h)**结束，其中w是屏幕宽度，h是屏幕高度。所以，如果你的手机分辨率为480
    x 850，那么你的右下角坐标将是`w=480`，`h=850`。因此，你的极端坐标将被映射为(480,850)。只需记住这一点，你很快就会理解为什么我们需要知道这个。
- en: 'Now, open up your XML file and drag and drop another TextView component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的XML文件，并拖放另一个TextView组件：
- en: '![](img/B05066_03_10.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_10.png)'
- en: 'Give it an ID `coords` and text as `Coords`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 给它一个ID `coords` 和文本 `Coords`：
- en: '![](img/B05066_03_11.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_11.png)'
- en: Now, click on your LinearLayout from the Component Tree view and give it an ID
    as `parent`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击组件树视图中的LinearLayout，并给它一个ID为`parent`。
- en: 'Now, go to your `FullscreenActivity.java` code file and modify your `onCreate`
    function to look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往你的`FullscreenActivity.java`代码文件，并修改你的`onCreate`函数，使其看起来像这样：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To give an explanation for the preceding code, what we have done over here
    is quite simple: we have declared a reference for our LinearLayout as `parent`
    and then another reference for our newly created coords(TextView). Now, after
    our declaration, we instructed the `parent` class to have a `Touch listener` property
    on it. This will help us get the coordinates that we touched. As you can see in
    the preceding code, we have a `MotionEvent` variable `ev`, which will give us
    the coordinates. Then, in the next line, we fetched the value in the form of *x*
    and *y* coordinates, which will then be set as text on our coords(TextView).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面的代码，我们在这里所做的是相当简单的：我们为我们的LinearLayout声明了一个引用`parent`，然后为我们的新创建的coords(TextView)声明了另一个引用。现在，在我们的声明之后，我们指示`parent`类在其上有一个`Touch
    listener`属性。这将帮助我们获取我们触摸的坐标。正如你在前面的代码中看到的，我们有一个`MotionEvent`变量`ev`，它将给我们坐标。然后，在下一条线中，我们以*x*和*y*坐标的形式获取了值，然后将其设置为coords(TextView)上的文本。
- en: 'Go ahead and run your code now, and when the emulator starts, try clicking
    randomly anywhere; that will give you coordinates that you just touched:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行你的代码，当模拟器启动时，尝试随机点击任何地方；这将给出你刚刚触摸的坐标：
- en: '![](img/B05066_03_12.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_12.png)'
- en: It will show you where you touched on the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示你在屏幕上触摸的位置。
- en: 'Now, by this time, you must have observed that it is pretty tedious to drag
    and drop and align all the texts properly, right? That is because we are working
    with LinearLayout. There is a way through which you can organize all your texts
    properly. That is through RelativeLayout. Let''s take a look at a working example
    to help you get a better understanding of the same. Go to the TextView of your
    XML file as we learned to do in the preceding chapter, and wherever you see LinearLayout change
    it to RelativeLayout. Here is a reference code for the same:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到这个时候，你必须已经注意到，拖放并正确对齐所有文本相当繁琐，对吧？这是因为我们正在使用LinearLayout。有一种方法可以正确组织所有文本。那就是通过RelativeLayout。让我们看看一个工作示例，帮助你更好地理解这一点。前往你的XML文件中的TextView，就像我们在上一章中学到的那样，将你看到的LinearLayout更改为RelativeLayout。以下是相应的参考代码：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you have successfully converted your LinearLayout to RelativeLayout, which
    will give you more control over your design options. You can now adjust your components
    on screen with more ease, and so you can align them nicely as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经成功地将你的LinearLayout转换为RelativeLayout，这将为你提供更多的设计选项控制。你现在可以更轻松地调整屏幕上的组件，因此你可以将它们对齐如下：
- en: '![](img/B05066_03_13.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_13.png)'
- en: Once you do this, you can easily adjust your texts by simply dragging them anywhere
    you want. You won't mess up the layouts when you use RelativeLayouts. Now, let's
    move on to the next example for getting accelerometer inputs, and take another TextView
    component on screen for that as you see in the preceding code and give it an ID
    `accel` with a text `Accelerometer`. However, before we proceed with the code
    for the same, there is a minor change that we need to do in our existing code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你可以轻松地通过简单地拖动它们到任何你想要的位置来调整你的文本。当你使用RelativeLayouts时，你不会弄乱布局。现在，让我们继续到下一个示例，获取加速度计输入，并在屏幕上选择另一个TextView组件，如前述代码所示，给它一个ID
    `accel` 并设置文本为`加速度计`。然而，在我们继续相同的代码之前，我们需要在我们的现有代码中进行一个小的更改。
- en: 'Since we just changed our LinearLayout to RelativeLayout, we also have to reference
    the same for our touch function in our Java code file. Open up your Java code
    file, and there you will observe that it is already giving you an error prompt
    on LinearLayout. That is because there is actually no LinearLayout in our project
    with the ID parent because we changed it to RelativeLayout. Don''t worry about
    this though; simply type in RelativeLayout instead of LinearLayout, and you are
    sorted. Here is how:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚将我们的LinearLayout更改为RelativeLayout，我们还需要在我们的Java代码文件中为我们的触摸功能引用相同的RelativeLayout。打开你的Java代码文件，你将注意到它已经在LinearLayout上给出了错误提示。这是因为实际上在我们的项目中没有ID为parent的LinearLayout，因为我们将其更改为RelativeLayout。不过，不用担心这个问题；只需输入RelativeLayout而不是LinearLayout，问题就解决了。以下是方法：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run your app once, and you can see how neat it looks now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用一次，你就可以看到它现在看起来多么整洁：
- en: '![](img/B05066_03_14.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_14.png)'
- en: Now, we have successfully made pretty neat adjustments to our layout as well
    as implemented a touch listener to detect touches.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地对我们的布局进行了相当整洁的调整，并实现了触摸监听器以检测触摸。
- en: Now, we move on to our final type of input for this chapter, *The Accelerometer
    input*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续本章的最后一个输入类型，*加速度计输入*。
- en: The Accelerometer input
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速度计输入
- en: 'We will now take a look at the accelerometer component on Android. If you don''t
    know what an accelerometer is, it is something that is used to detect movement
    in Android. In layman terms, we can call it the motion sensor. The best example
    for this is any racing game that lets you control the car based on your phone''s
    movement. This is something really interesting, which you can use in further chapters
    to apply motion to objects, so make sure that you grasp this properly. Type in
    the code you see in the following block starting from `sensorManager`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看Android上的加速度计组件。如果你不知道加速度计是什么，它是一种用于检测Android中运动的设备。用通俗易懂的话来说，我们可以称它为运动传感器。最好的例子是任何允许你根据手机运动来控制汽车的赛车游戏。这真的很有趣，你可以在后续章节中将运动应用到对象上，所以请确保你正确理解这一点。从`sensorManager`开始输入你看到的以下代码块：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, over here if you get an error related to import statements while typing,
    then press *Alt* + *Enter* and you will be prompted with suggestions. Select the
    corresponding import statement from the list to solve the error. Now, the code
    will be explained. We made a variable for our `sensorManager` component of Android,
    which is responsible for tracking our `accelerometer` values. As you can see after
    the line following it, we have taken the sensor type as `TYPE_ACCELEROMETER`.
    Next, we created another listener for our component and then we took in the `x`,
    `y`, and `z` values. After that, we simply took a reference to the accel TextView
    component in our XML file and set its text to display those values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你在输入时遇到与导入语句相关的错误，请按 *Alt* + *Enter*，你将收到建议。从列表中选择相应的导入语句以解决错误。现在，代码将被解释。我们为Android的`sensorManager`组件创建了一个变量，该组件负责跟踪我们的`加速度计`值。正如你在其后的行中可以看到的，我们将传感器类型设置为`TYPE_ACCELEROMETER`。接下来，我们为我们的组件创建了一个另一个监听器，然后我们获取了`x`、`y`和`z`值。之后，我们简单地引用了XML文件中的accel
    TextView组件，并将其文本设置为显示这些值。
- en: 'Now, it is obvious that you won''t be able to see accelerometer values changing
    on your emulator, so you will have to test it on your mobile device. However,
    just for curiosity''s sake, try and run the code on your computer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显你无法在模拟器上看到加速度计值的变化，所以你将不得不在移动设备上测试它。然而，出于好奇，尝试在你的电脑上运行代码：
- en: '![](img/B05066_03_15.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_15.png)'
- en: You will see some values, but they will not be changing because our PC does
    not have a motion sensor.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些值，但它们不会变化，因为我们的 PC 没有运动传感器。
- en: 'So, let''s run our app on our mobile now. We can do this in two ways:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们在我们的移动设备上运行我们的应用。我们可以用两种方式来做这件事：
- en: Build and deploy directly to our device through USB, which will allow us to
    run the app directly on a physical device
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 USB 直接构建和部署到我们的设备，这将允许我们在物理设备上直接运行应用
- en: Build an apk and then transfer the apk file to our phone and install it
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 apk 文件，然后将 apk 文件传输到我们的手机并安装它
- en: Let's start!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Building and deploying through USB
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 USB 构建 和 部署
- en: 'To make your device ready for debugging you need to enable your device for
    debugging first. In order to enable your device for debugging in Developer options.
    To access these settings, open the Developer options in the system settings. On
    Android 4.2 and higher versions, the Developer options screen is hidden by default.
    To make it visible, go to Settings | About phone and tap on Build number seven
    times:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的设备准备好调试，首先需要启用调试功能。为了在开发者选项中启用调试功能，需要访问这些设置，请打开系统设置中的开发者选项。在 Android 4.2
    及更高版本中，开发者选项屏幕默认隐藏。要使其可见，请转到设置 | 关于手机，然后连续点击七次“构建号”：
- en: '![](img/B05066_03_21.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_21.png)'
- en: 'After this, return to the previous screen to find Developer options at the
    bottom:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，返回上一屏幕，在底部找到开发者选项：
- en: '![](img/B05066_03_22.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_22.png)'
- en: 'Now, enable the USB debugging option on your device:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的设备上启用 USB 调试选项：
- en: '![](img/B05066_03_23.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_03_23.png)'
- en: 'With an Android-powered device, you can develop and debug your Android applications
    just as you would on the emulator. Before you can start, there are just a few
    things to do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android 设备，你可以像在模拟器上一样开发和调试你的 Android 应用。在开始之前，只需做一些事情：
- en: Verify that your application is debuggable in your manifest or `build.gradle`
    file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的清单文件或 `build.gradle` 文件中验证你的应用是否可调试。
- en: 'In the build file, make sure that the `debuggable` property in the `debug`
    build type is set to true. The build type property overrides the manifest setting:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建文件中，确保 `debug` 构建类型的 `debuggable` 属性设置为 true。构建类型属性会覆盖清单设置：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `AndroidManifest.xml` file, add `android:debuggable="true"` to the `<application>`
    element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，将 `android:debuggable="true"` 添加到 `<application>`
    元素中。
- en: 'Note: If you manually enable debugging in the manifest file, ensure that you
    disable it in your release build (your published application should usually *not*
    be debuggable).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你在清单文件中手动启用调试，确保你在发布构建中禁用它（你发布的应用通常不应该可调试）。
- en: Enable USB debugging in the device system settings, under Settings | Developer
    options.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备系统设置中，在设置 | 开发者选项下启用 USB 调试。
- en: 'Note: On Android 4.2 and newer versions, Developer options is hidden by default.
    To make it available, go to Settings | About phone and tap on Build number seven
    times. Return to the previous screen to find Developer options.'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：在 Android 4.2 及更高版本中，开发者选项默认隐藏。要使其可用，请转到设置 | 关于手机，然后连续点击七次“构建号”。返回上一屏幕以找到开发者选项。
- en: 'Set up your system to detect your device:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的系统以检测你的设备：
- en: If you're developing on Windows, you need to install a USB driver for ADB. For
    an installation guide and links to OEM drivers, refer to the [OEM USB Drivers](https://developer.android.com/tools/extras/oem-usb.html)
    document.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在 Windows 上开发，你需要安装 ADB 的 USB 驱动程序。有关安装指南和 OEM 驱动程序的链接，请参阅[OEM USB 驱动程序](https://developer.android.com/tools/extras/oem-usb.html)文档。
- en: If you're developing on macOS X, it just works, so skip this step.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在 macOS X 上开发，它就会正常工作，所以跳过这一步。
- en: 'If you''re developing on Ubuntu Linux, you need to add a udev rules file that
    contains a USB configuration for each type of device you want to use for development.
    In the rules file, each device manufacturer is identified by a unique vendor ID,
    as specified by the ATTR{idVendor} property. For a list of vendor IDs, refer to [USB
    Vendor IDs](https://developer.android.com/studio/run/device.html#VendorIds), as
    follows. To set up device detection on Ubuntu Linux, perform the following:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在 Ubuntu Linux 上开发，你需要添加一个 udev 规则文件，该文件包含你想要用于开发的每种设备的 USB 配置。在规则文件中，每个设备制造商由一个唯一的供应商
    ID 标识，如 `ATTR{idVendor}` 属性所指定。有关供应商 ID 的列表，请参阅 [USB 供应商 ID](https://developer.android.com/studio/run/device.html#VendorIds)，如下所示。要在
    Ubuntu Linux 上设置设备检测，请执行以下操作：
- en: 'Log in as root and create this file: `/etc/udev/rules.d/51-android.rules`.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 身份登录并创建此文件：`/etc/udev/rules.d/51-android.rules`。
- en: 'Use the following format to add each vendor to the file:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下格式将每个供应商添加到文件中：
- en: '`SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", MODE="0666", GROUP="plugdev"`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", MODE="0666", GROUP="plugdev"`'
- en: In this example, the vendor ID is for HTC. The MODE assignment specifies read/write
    permissions, and GROUP defines which Unix group owns the device node.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此示例中，供应商 ID 是为 HTC 设计的。MODE 分配指定了读写权限，GROUP 定义了哪个 Unix 组拥有设备节点。
- en: 'Note: The rule syntax may vary slightly depending on your environment. Consult
    the udev documentation for your system as needed. For an overview of rule syntax,
    refer to this guide at [writing udev rules](http://www.reactivated.net/writing_udev_rules.html).'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：规则语法可能因环境而略有不同。如有需要，请咨询您系统的 udev 文档。有关规则语法的概述，请参阅此指南 [编写 udev 规则](http://www.reactivated.net/writing_udev_rules.html)。
- en: Now, execute `chmod a+r /etc/udev/rules.d/51-android.rules`.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行 `chmod a+r /etc/udev/rules.d/51-android.rules`。
- en: 'Note: When you connect a device running Android 4.2.2 or higher versions to
    your computer, the system shows a dialog asking whether to accept an RSA key that
    allows debugging through this computer. This security mechanism protects user
    devices because it ensures that USB debugging and other ADB commands cannot be
    executed unless you''re able to unlock the device and acknowledge the dialog.
    This requires that you have ADB version 1.0.31 (available with SDK Platform-tools
    r16.0.1 and higher) in order to debug on a device running Android 4.2.2 or higher
    versions.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你将运行 Android 4.2.2 或更高版本的设备连接到计算机时，系统会显示一个对话框，询问是否接受允许通过此计算机进行调试的 RSA 密钥。这种安全机制保护用户设备，因为它确保除非你能够解锁设备并确认对话框，否则无法执行
    USB 调试和其他 ADB 命令。这需要你有 ADB 版本 1.0.31（在 SDK 平台工具 r16.0.1 及更高版本中可用）才能在运行 Android
    4.2.2 或更高版本的设备上进行调试。
- en: When plugged in over USB, you can verify that your device is connected by executing
    ADB devices from your SDK platform-tools/ directory. If connected, you'll see
    the device name listed as a device.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 USB 连接时，你可以通过执行 SDK 平台工具目录中的 ADB devices 来验证你的设备是否已连接。如果已连接，你将看到设备名称作为设备列出。
- en: On pressing run or debugging your application, you will be presented with a
    Device Chooser dialog that lists the available emulator(s) and connected device(s).
    Select the device on which you want to install and run the application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行或调试应用程序时，你将看到一个设备选择对话框，其中列出可用的模拟器（s）和连接的设备（s）。选择你想要安装和运行应用程序的设备。
- en: If using the **Android Debug Bridge** (**ADB**), you can issue commands with
    the `-d` flag to target your connected device.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 **Android 调试桥接**（**ADB**），你可以使用 `-d` 标志来针对你的连接设备发出命令。
- en: You can find the vendor IDs at [https://developer.android.com/studio/run/device.html](https://developer.android.com/studio/run/device.html).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.android.com/studio/run/device.html](https://developer.android.com/studio/run/device.html)
    找到供应商 ID。
- en: Building an apk and installing on device
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 apk 并在设备上安装
- en: 'From the top task bar where you see File, Edit, and so on, click on Build and
    then click on Generate APK. Once you have done this, it will start generating
    an apk for you. Once it is finished right-click on your app folder, which is on
    the left-hand side, as seen in the following screenshot, and click on Show in
    Explorer:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部的任务栏，你看到文件、编辑等，点击构建，然后点击生成 APK。完成此操作后，它将开始为你生成 apk。完成后，右键单击左侧可见的应用程序文件夹，然后点击在资源管理器中显示：
- en: '![](img/B05066_03_16.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_03_16.png)'
- en: 'Show in Explorer will open the window in which your project folder is located:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源管理器中显示将打开包含你的项目文件夹的窗口：
- en: '![](img/B05066_03_17.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_03_17.png)'
- en: 'In your project folder, navigate to the `app/build/outputs/apk/` folder, and
    there you will see your `app-debug.apk` file. Transfer this onto your mobile phone
    and install the apk and run it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中，导航到`app/build/outputs/apk/`文件夹，在那里你会看到你的`app-debug.apk`文件。将这个文件传输到你的手机上，安装apk并运行它：
- en: '![](img/B05066_03_18.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_03_18.png)'
- en: 'Click on Install:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“安装”：
- en: '![](img/B05066_03_19.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_03_19.png)'
- en: 'Click on Open:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“打开”：
- en: '![](img/B05066_03_20.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_03_20.png)'
- en: Accelerometer values will change as you move your phone around.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移动手机时，加速度计的值将会改变。
- en: Congratulations! You also learned how to create an apk and run it on your actual
    device.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你也学会了如何创建apk并在你的实际设备上运行它。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to take different types of user inputs
    and also how to generate an apk and run it on your actual device. You also learned
    the various types of XML files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何接收不同类型的用户输入，以及如何生成apk并在你的实际设备上运行它。你还学习了各种类型的XML文件。
- en: In the next chapter, we will learn how to create sprites--no, not the cold drink!
    We will learn how to create images as well as play with colors. The next chapter
    will be our entry into creating graphics on screen and will be a big step for
    you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建精灵——不，不是冷饮！我们将学习如何创建图像以及如何玩转颜色。下一章将是我们进入屏幕图形创作的起点，对你来说将是一个巨大的进步。
