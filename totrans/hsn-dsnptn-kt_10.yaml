- en: Idioms and Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses the best and worst practices in Kotlin. You'll learn
    what idiomatic Kotlin code should look like and which patterns to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you should be able to write more readable and
    maintainable Kotlin code, as well as avoid some common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Let
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try-with-resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor overload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with nulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit async
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed, not enumerated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More companions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, we use `let()` to do something only if the object is `not null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One common gotcha here is that `let()` by itself also works on nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget the question mark, `?`, when you use `let()` for null checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of `let()` is not related to the type it operates on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code will print `"string"` and return `Int 6` as its length.
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed `apply()` in previous chapters. It returns the same
    object it operates on and sets the context to `this`. The most useful case for
    this function is setting the fields of a mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of how many times you had to create a class with an empty constructor,
    then call a lot of setters, one after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set only `name` and `movie`, but leave `alsoStarring` blank, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the context is set to this, we can simplify it to the following nice
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function is especially good when you work with Java classes that usually
    have a lot of setters.
  prefs: []
  type: TYPE_NORMAL
- en: Also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Single-expression functions are very nice and concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But often, you have a single-statement function, that also needs to write to
    a log, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write it the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But then it's not a single statement function anymore, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'And we also introduced another variable. To the rescue, `also()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function will set results of the expression to `it` and return the result
    of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also useful when you want to have a side effect on a chain of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not related to threads in any way, `run()` is much like `let()`, but it sets
    the context to `this` instead of using `it`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, `this` could be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is mostly useful when you plan to call a number of methods on the same object,
    much like `apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return result, unlike `apply()`, may be of a totally different type, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the other four scoping functions, `with()` is not an extension function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, `with()` receives the object you want to scope as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And as usual, we can omit `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just like `run()` and `let()`, you can return any result from `with()`.
  prefs: []
  type: TYPE_NORMAL
- en: Instance checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming from Java, you may be inclined to check what type your object is using, `is`,
    and cast it using `as`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But as you may know, Kotlin has smart casts, so implicit casting, in this case,
    is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, in most cases, using `when()` while smart-casting produces cleaner
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a rule of thumb, you should avoid using casts and rely on smart casts most
    of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you absolutely must, there''s also a safe cast operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Try-with-resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java7 added the notion of `AutoCloseable` and the try-with-resources statement.
  prefs: []
  type: TYPE_NORMAL
- en: This statement allows us to provide a set of resources that would be automatically
    closed after the code is done with them. No more risk (or at least less risk)
    of forgetting to close a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Java7, that was a total mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After Java7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, the `this` statement is replaced with the `use()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Inline functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of inline functions as a copy/paste instruction for the compiler.
    Each time the compiler sees a call to a function marked with inline, it will replace
    the call with the `concrete` function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes sense to use the inline function only if it''s a higher-order function
    that receives a lambda as one of its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most common use case where you would like to use `inline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You call it as usual, with the block body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you view the bytecode, you''ll see it''s actually translated to the
    lines produces and not to a function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the actual code, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice there's absolutely no difference between the two blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Since the inline function is copy/paste, you shouldn't use it if you have more
    than a few lines of code. It would be more efficient to have it as a regular function.
  prefs: []
  type: TYPE_NORMAL
- en: Reified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the inline function is copied, we can get rid of one of the major JVM
    limitations–type erasure. After all, inside the function, we know exactly what
    type we're getting.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the following example. You would like to create a generic function,
    which will receive a number but will print it only if it's of the same type as
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try writing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But this code won''t compile with an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What we usually do in Java, in this case, is pass the class as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check this code by running the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has a few downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We had to use reflection, and for that, we had to include the `kotlin-reflect`
    library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the `is` operator and must use the `isInstance()` function instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must pass the correct class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we canuse a `reified` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test that our code still works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We get all the benefits of the language this way:'
  prefs: []
  type: TYPE_NORMAL
- en: No need for another dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear method signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to use the `is` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the same rules as regular inline functions apply. This code would
    be replicated, so it shouldn't be too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another case regarding function overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This won''t compile because there''s a platform declaration clash. Both have
    the same signature in terms of JVM: `printList(list: List)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But with `reified`, we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since everything in Java is an object (unless you're a primitive type), we're
    used to putting all the constants inside our objects as static members.
  prefs: []
  type: TYPE_NORMAL
- en: 'And since Kotlin has companion objects, we usually try putting them there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will work, but you should remember that companion object is an object,
    after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this will be translated to the following code, more or less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And the call to our constant looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, we have our class, `Spock`, inside of which we have another class. But what
    we wanted was only `static final String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now mark this value as constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the bytecode changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there's no call to this constant at all since the compiler already
    inlined its value for us. After all, it's constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all you need is a constant, you can also set it up outside of any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you need namespacing, you can wrap it in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Constructor overload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, we''re used to having overloaded constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simulate the same behavior in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But it''s usually better to have default parameter values and named arguments
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with nulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nulls are unavoidable, especially if you work with Java libraries or get data
    from a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can check for null the Java way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in a shorter form, with the `Elvis` operator. If the length is not null,
    this operator will return its value. Otherwise, it will return the default value
    we supplied, zero in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a nested object, you can chain those checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the `let()` block for those checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to get rid of the `it()` everywhere, you can use run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'By all means, do try to avoid the unsafe `!!` null operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This will result in `KotlinNullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw in the previous chapter, in Kotlin it is very easy to introduce
    concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'But that concurrency may be unexpected behavior to the user of the function,
    as they may expect a simple value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, what''s missing here is `await()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'But it would have been a lot more obvious if we''d named our function accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As a rule, you should establish some kind of convention to distinguish async
    functions from regular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How many times did you have to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can check arguments with `require()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code a lot more fluent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `require()` to check for nested nulls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'But there''s also `requireNotNull()` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `check()` to validate the state of your object. This is useful when you
    provide some object that the user may not have set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, there''s a shortcut for `null`: `checkNotNull()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sealed, not enumerated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming from Java, you may be tempted to overload your `enum` with functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can use the `sealed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of this approach is that we can now pass data around along with
    the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In general, sealed classes are good if you want to have data associated with
    a state.
  prefs: []
  type: TYPE_NORMAL
- en: More companions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are limited to having only one companion object in your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can have as many objects in your class as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is sometimes used to produce namespacing. Namespacing is important because
    it provides you with better naming conventions. Think about having cases when
    you created classes such as `SimpleJsonParser`, which inherits from `JsonParser`,
    which inherits from `Parser`. You could convert this structure to `Json.Parser`,
    for example, which is much more concise and practical, as Kotlin code should be.
  prefs: []
  type: TYPE_NORMAL
- en: Scala functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developers coming into Kotlin from Scala may sometimes define their function
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function won''t print what you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re missing is the second set of parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s because the single-expression definition could be translated into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be further translated into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see where that function came from, at least.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed best practices in Kotlin, as well as some of the
    caveats of the language. Now you should be able to write more idiomatic code that
    is also performant and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: You should make use of scoping functions, but make sure not to overuse them,
    as they may make the code confusing, especially for those newer to the language.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to handle nulls and type casts correctly, with `let()`, the `Elvis`
    operator, and smart casts that the language provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we'll put those skills to use by writing a real-life
    microservice using everything we've learned.
  prefs: []
  type: TYPE_NORMAL
