<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11.  Advanced Features and Concepts </h1></div></div></div><div><blockquote class="blockquote"><p>
<em>"Man is a genius when he is dreaming."
                                              - Akira Kurosawa</em>
</p></blockquote></div><p>In this chapter, we introduce the design concerns and API features related to making apps run as if they were always on. We develop an activity to demonstrate the always-on capability. We then touch upon debugging wear apps over Bluetooth connections and conclude with a preview of Android Wear 2.0.</p><div><h3 class="title"><a id="note20"/>Note</h3><p>The code accompanying this chapter is available for reference on GitHub (<a class="ulink" href="https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11">https://github.com/siddii/mastering-android-wear/tree/master/Chapter_11</a>). Note that for the sake of brevity, code snippets are only included as needed. The reader is encouraged to download the referenced code from GitHub and follow along as they progress through the chapter.</p></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec68"/>Keeping the watch running</h1></div></div></div><p>You may recall our discussion of watch faces in the previous chapter wherein a watch face starts out running in interactive mode. As the screen times out, the watch face continues to run as the device goes into its power-saving ambient mode.</p><p>While this feature, meaning the watch face's always-on capability, is inherent to watch faces—we don't want our watch to slack off when we want the time—it is not necessarily inherent to all wearable apps. For instance, if we had our <code class="literal">todo</code> app or <code class="literal">Step counter</code> app active, it would only be a matter of time before the screen timed out and rendered the watch face. If we then wanted to return to our app, we would have to interact with our wearable device to snap it out of ambient mode and bring up our last used activity or app. We can imagine scenarios where this can be a source of user frustration.</p><p>Fortunately, if our devices are running Android version 5.1 or higher, we can harness the power of the Android Wear APIs to conserve power during the execution of our wearable apps. These devices allow apps to remain in the foreground while still conserving battery power. Apps can be coded to control what is displayed in ambient mode even as they continue fulfilling their primary purpose, whatever that may be. Such apps are, in effect, always on.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec58"/>Making an app to stay always on</h2></div></div></div><p>Here are some of the things we need to do and/or keep in mind when looking to enable ambient mode for our wearable apps:</p><div><ul class="itemizedlist"><li class="listitem">Our SDK should be updated to include the Android 5.1 or higher platform as this version provides activities with ambient mode support. See the <em>Android SDK Packages</em> section in <a class="link" title="Chapter 2.  Setting up the Development Environment" href="part0020.xhtml#aid-J2B81">Chapter 2</a>, <em>Setting up Development Environment on Android Studio</em>, for more information.</li><li class="listitem">We must set our manifest <code class="literal">targetSdkVersion</code> to API level 22 or higher (that is, version 5.1).</li><li class="listitem">We may choose to provide backward compatibility for devices running an Android version prior to 5.1 by specifying a <code class="literal">minSdkVersion</code> attribute. By doing so, the activities that support ambient mode will automatically fall back by returning to the home screen and exit the activity.</li><li class="listitem">Our activities should extend the <code class="literal">WearableActivity </code>API class so as to inherit all the methods needed to enable ambient mode.</li><li class="listitem">We should invoke the <code class="literal">setAmbientEnabled()</code> method in the<code class="literal">onCreate()</code> listener of our activity.</li><li class="listitem">We should have a clear understanding of the transitions between interactive and ambient mode and the relevant listeners that are called during those transitions, as shown in the figure at the end of this section.</li><li class="listitem">We should pay special attention to updating the activity UI in the ambient mode to use a basic layout and a minimal palette of colors to maximize better power conservation.</li><li class="listitem">We should try to update the activity UI using a consistent layout so that the transition between interactive and ambient modes appears as seamless as possible to the user.</li><li class="listitem">We should exercise care not to update the screen too frequently when in ambient mode. Remember that the whole point of the ambient mode is to save power. Updating the activity UI more frequently than 10 seconds can be a source of power drainage and be counter-productive to enabling ambient mode altogether. If it does become necessary to perform more frequent updates due to the nature of the app (as with mapping or fitness), consider the use of the API's <code class="literal">AlarmManager</code> class (<a class="ulink" href="https://developer.android.com/reference/android/app/AlarmManager.html">https://developer.android.com/reference/android/app/AlarmManager.html</a>).</li></ul></div><div><h3 class="title"><a id="note21"/>Note</h3><p>It is worth repeating that devices running a version of Android prior to 5.1 (API Level 22) may not have access to the always-on capabilities of the newer APIs, but they should still run these apps without errors provided we specify a <code class="literal">minSdkVersion</code> attribute of 20 or higher in the manifest.</p></div><p>Consider the following diagram, depicting the update in the UI activity of the screen:</p><p>
</p><div><img src="img/image00223.jpeg" alt="Making an app to stay always on"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec69"/>An always running step counter</h1></div></div></div><p>Now, let's demonstrate everything we presented in the previous section in practice by augmenting our step counter from <a class="link" title="Chapter 7.  Voice Interactions, Sensors, and Tracking" href="part0051.xhtml#aid-1GKCM1">Chapter 7</a>, <em>Voice Interactions, Sensors, and Tracking</em>, to be always on. Let's dive right in.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec59"/>The Android manifest file</h2></div></div></div><p>The first thing to do is to update the <code class="literal">AndroidManifest.xml</code> file and set up the <code class="literal">StepCounterActivity</code> class to have its <code class="literal">launchMode</code> set to <code class="literal">singleInstance</code>. This is necessary in order to update the screen more than once per minute in ambient mode. Not doing so will cause the <code class="literal">AlarmManager</code> class to launch an intent to open a new activity every time the alarm is triggered rather than reusing the same (already active) activity. Here is the snippet from the file:</p><pre class="programlisting">&lt;activity 
    android:name=".StepCounterActivity" 
    android:label="@string/daily_step_count_title" 
    android:launchMode="singleInstance" 
/&gt; 
</pre><p>As soon as we launch our step counter, we see a colorful background image and a display showing the number of steps taken so far since a reboot of the device, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00224.jpeg" alt="The Android manifest file"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec12"/>The StepCounterActivity class</h3></div></div></div><p>This activity does the bulk of the work for our step counter. We modify the <code class="literal">onCreate()</code> method with a call to the <code class="literal">setAmbientEnabled()</code> method setting it to true. We also define a helper method, <code class="literal">refreshDisplayAndSetNextUpdate()</code>, that we call from our <code class="literal">onCreate()</code> listener, as well as the <code class="literal">onEnterAmbient()</code> and <code class="literal">onUpdateAmbient()</code> listeners. A call to the <code class="literal">isAmbient()</code> method determines whether we use the value from the ambient interval or the active interval. Furthermore, in ambient mode, we remove the background, make the pixels black, and paint the data with a white foreground. Maximizing the use of black and minimizing the use of white directly contributes to battery power conservation.</p><p>The following code listing presents the <code class="literal">StepCounterActivity</code> class for our step counter:</p><pre class="programlisting">public class StepCounterActivity extends WearableActivity  implements SensorEventListener 
{ 
  private SensorManager mSensorManager; 
  private Sensor mSensor; 
 
  // Steps counted since the last reboot 
  private int mSteps = 0; 
 
  private static final String TAG =  StepCounterActivity.class.getName(); 
  private BoxInsetLayout stepCounterLayout; 
  private CardFrame cardFrame; 
  private TextView title, desc; 
  private AlarmManager mAmbientStateAlarmManager; 
  private PendingIntent mAmbientStatePendingIntent; 
 
  /** 
   * This custom handler is used for updates in "Active" mode. We use a separate static class to 
   * help us avoid memory leaks. 
   */ 
 
  private final Handler mActiveModeUpdateHandler = new UpdateHandler(this); 
 
  /** 
   * Custom 'what' for Message sent to Handler. 
   */ 
 
  private static final int MSG_UPDATE_SCREEN = 0; 
 
  /** 
   * Milliseconds between updates based on state. 
   */ 
 
  private static final long ACTIVE_INTERVAL_MS =  TimeUnit.SECONDS.toMillis(1); 
  private static final long AMBIENT_INTERVAL_MS =  TimeUnit.SECONDS.toMillis(20); 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState)  
  { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_daily_step_counter); 
 
    mSensorManager = (SensorManager)  getSystemService(Context.SENSOR_SERVICE); 
    mSensor =  mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER); 
 
    setAmbientEnabled(); 
 
    mAmbientStateAlarmManager = (AlarmManager)  getSystemService(Context.ALARM_SERVICE); 
    Intent ambientStateIntent = new  Intent(getApplicationContext(), DailyTotalActivity.class); 
 
    mAmbientStatePendingIntent = PendingIntent.getActivity( 
      getApplicationContext(), 
      0 /* requestCode */, 
      ambientStateIntent, 
      PendingIntent.FLAG_UPDATE_CURRENT); 
 
    stepCounterLayout = (BoxInsetLayout)  findViewById(R.id.step_counter_layout); 
    cardFrame = (CardFrame)  findViewById(R.id.step_counter_card_frame); 
    title = (TextView) findViewById(R.id.daily_step_count_title); 
    desc = (TextView) findViewById(R.id.daily_step_count_desc); 
    refreshDisplayAndSetNextUpdate(); 
  } 
 
  /** 
   * Loads data/updates screen (via method), but most importantly, sets up the next refresh 
   * (active mode = Handler and ambient mode = Alarm). 
   */ 
 
  private void refreshDisplayAndSetNextUpdate()  
  { 
    Log.i(TAG, "Refresh display and set next update "); 
    refreshStepCount(); 
    long timeMs = System.currentTimeMillis(); 
    if (isAmbient())  
    { 
      /** Calculate next trigger time (based on state). */ 
      long delayMs = AMBIENT_INTERVAL_MS - (timeMs %  AMBIENT_INTERVAL_MS); 
      long triggerTimeMs = timeMs + delayMs; 
 
      /** 
       * Note: Make sure you have set activity launchMode to singleInstance in the manifest. 
       * Otherwise, it is easy for the AlarmManager launch intent to open a new activity 
       * every time the Alarm is triggered rather than reusing this Activity 
       */ 
 
      mAmbientStateAlarmManager.setExact( 
        AlarmManager.RTC_WAKEUP, 
        triggerTimeMs, 
        mAmbientStatePendingIntent); 
 
    } 
    else  
    { 
      /** Calculate next trigger time (based on state). */ 
      long delayMs = ACTIVE_INTERVAL_MS - (timeMs %  ACTIVE_INTERVAL_MS); 
 
      mActiveModeUpdateHandler.removeMessages(MSG_UPDATE_SCREEN); 
      mActiveModeUpdateHandler.sendEmptyMessageDelayed  (MSG_UPDATE_SCREEN, delayMs); 
    } 
  } 
 
  /** 
   * Prepares UI for Ambient view. 
   */ 
 
  @Override 
  public void onEnterAmbient(Bundle ambientDetails)  
  { 
    Log.d(TAG, "onEnterAmbient()"); 
    super.onEnterAmbient(ambientDetails); 
 
    /** Clears Handler queue (only needed for updates in active mode). */ 
 
    mActiveModeUpdateHandler.removeMessages(MSG_UPDATE_SCREEN); 
 
    /** 
     * Following best practices outlined in WatchFaces API (keeping most pixels black, 
     * avoiding large blocks of white pixels, using only black and white, 
     * and disabling anti-aliasing, etc.) 
     */ 
 
    stepCounterLayout.setBackgroundColor(Color.BLACK); 
    cardFrame.setBackgroundColor(Color.BLACK); 
    desc.setTextColor(Color.WHITE); 
    desc.getPaint().setAntiAlias(false); 
    title.setTextColor(Color.WHITE); 
    title.getPaint().setAntiAlias(false); 
    refreshDisplayAndSetNextUpdate(); 
  } 
 
  @Override 
public void onUpdateAmbient()  
{ 
    Log.d(TAG, "onUpdateAmbient()"); 
    super.onUpdateAmbient(); 
 
    refreshDisplayAndSetNextUpdate(); 
} 
 
/** 
 * Prepares UI for Active view (non-Ambient). 
 */ 
@Override 
public void onExitAmbient()  
{ 
    Log.d(TAG, "onExitAmbient()"); 
    super.onExitAmbient(); 
 
    /** Clears out Alarms since they are only used in ambient mode. */ 
    mAmbientStateAlarmManager.cancel(mAmbientStatePendingIntent); 
 
    stepCounterLayout.setBackgroundResource(R.drawable.jogging); 
    cardFrame.setBackgroundColor(Color.WHITE); 
 
    desc.setTextColor(Color.BLACK); 
    desc.getPaint().setAntiAlias(true); 
 
    title.setTextColor(Color.BLACK); 
    title.getPaint().setAntiAlias(true); 
 
    refreshDisplayAndSetNextUpdate(); 
  } 
} 
</pre><p>As a result of the preceding changes, this is how the step counter shows up in ambient mode now:</p><p>
</p><div><img src="img/image00225.jpeg" alt="The StepCounterActivity class"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec70"/>Debugging wearable apps</h1></div></div></div><p>An important and extremely useful tool available to developers is the ability to set up debugging for our wearable apps running on our wearable device. We have the ability to run debug commands from our development machine to troubleshoot our wearable apps and have any debug output from the wearable be sent over to the handheld, which in turn must be connected to the development machine. Some setup is required in order to accomplish this. The general connectivity between devices is as shown in the following diagram:</p><p>
</p><div><img src="img/image00226.jpeg" alt="Debugging wearable apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The greatest payoff here is that we don't need to run two separate USB connections from the development machine—one to the handheld and the other to the wearable device. Instead, we can deploy and debug code straight to the handheld device from the development machine using a Bluetooth connection. This becomes especially helpful when such troubleshooting needs to be performed repetitively during development. Without this feature, we would have to endure the clutter of too many cables, and we know we can do without that.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec60"/>Device setup</h2></div></div></div><p>Debugging must be set up on the companion handheld as well as the wearable device, albeit a bit differently.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec13"/>USB debugging on the handheld app</h3></div></div></div><p>Follow the steps mentioned to perform the debugging on the handheld app:</p><div><ol class="orderedlist arabic"><li class="listitem">Launch the <strong>Settings</strong> screen in the handheld device and make sure the USB debugging is turned on in <strong>Developer</strong> <strong>options</strong>.</li><li class="listitem">Locate and launch the <strong>Developer options</strong>. Alternatively, you may have to tap the <strong>About Phone</strong> menu, scroll down the build number and tap it seven times to activate the <strong>Developer Options</strong> menu item. Tap it once it is available.</li><li class="listitem">Choose to enable <strong>USB debugging</strong>, as shown in the following screenshot:</li></ol><div></div><p>
</p><div><img src="img/image00227.jpeg" alt="USB debugging on the handheld app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec14"/>Bluetooth debugging on the wearable app</h3></div></div></div><p>Follow the steps mentioned here to perform debugging on the wearable app using Bluetooth:</p><div><ol class="orderedlist arabic"><li class="listitem">Launch the <strong>Wear</strong> menu by tapping the home screen twice.</li><li class="listitem">Launch <strong>Settings</strong>.</li><li class="listitem">Locate and launch <strong>Developer Options</strong>. Alternatively, you may have to tap <strong>About Phone</strong>, scroll down the build number and tap it seven times to activate the <strong>Developer Options</strong> menu item. Tap it once it is available.</li><li class="listitem">Choose to enable <strong>Debugging over Bluetooth</strong> option.</li></ol><div></div></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec15"/>Session setup on the handhelds apps</h3></div></div></div><p>Perform the following steps to set up the session in handheld apps:</p><div><ol class="orderedlist arabic"><li class="listitem">Launch the Android Wear companion app on the handheld.</li><li class="listitem">Launch <strong>Settings</strong> from the menu in the top-right corner:<p>
</p><div><img src="img/image00228.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li><li class="listitem">Choose to enable the <strong>Debugging over Bluetooth</strong> option. Note that the following message shows up on your handheld under that option:</li></ol><div></div><pre class="programlisting">      Host: disconnected 
      Target: connected 
</pre><p>
</p><div><img src="img/image00229.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>This is because we are yet to connect your handheld to your development machine. Let's do that next.</p><p>Let's now connect the handheld to our development machine using a USB cable, and type the following at the <code class="literal">adb</code> command prompt. We use an arbitrary port <code class="literal">4444</code>, we could use any available port:</p><pre class="programlisting">
<strong>adb forward tcp:4444 localabstract:/adb-hub</strong>
<strong>adb connect localhost:4444</strong>
</pre><p>In the companion app on the handheld, you should now see the following under the <strong>Debugging over Bluetooth</strong> option:</p><pre class="programlisting">Host: connected 
Target: connected 
</pre><p>
</p><div><img src="img/image00230.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>We have thus completed setting up a debugging session for our wearable. After the successful connection, we see a notification shown as follows on the wearable device:</p><p>
</p><div><img src="img/image00231.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now, let's test it all out by executing some debug commands.</p><p>Note that if we execute the <code class="literal">adb devices</code> command at the <code class="literal">adb</code> command prompt, we should see our wearable device show up as <code class="literal">localhost:4444</code>. We can now execute the <code class="literal">adb</code> commands to debug our application, using the following format:</p><pre class="programlisting">
<strong>adb -s localhost:4444 &lt;command&gt;</strong>
</pre><p>Consider following command, for example:</p><pre class="programlisting">
<strong>adb -s localhost:4444 shell</strong>
</pre><p>In the developer options in the wearable device, we can see that the <strong>ADB debugging</strong> and <strong>Debug over Bluetooth</strong> options are enabled:</p><p>
</p><div><img src="img/image00232.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now that we have established a successful connection between the development machine, handheld device and wearable device, we will be able to deploy and debug our code straight from Android Studio to the wearable device using the Bluetooth connection. The watch will show up as a deployment target, depicted in the following screenshot:</p><p>
</p><div><img src="img/image00233.jpeg" alt="Session setup on the handhelds apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec71"/>The way forward - reviewing Android Wear 2.0</h1></div></div></div><p>Back when we began work on this book, Android Wear 2.0 was well past ideation and into design. The Android Wear preview API was still in the works, being scheduled for release about the time we rounded a corner taking us past the halfway point of our first draft. Although the 2.0 APIs are still being fleshed out and development is underway, interested developers can try it out as part of the Android Wear 2.0 developer preview edition of the API.</p><p>In this section, we are going to highlight some of the key new features being baked into the 2.0 APIs, with an eye on what we've seen in the previous chapters of this book.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec61"/>Watch face complications</h2></div></div></div><p>In our discussion of watch faces, we had advanced the idea of interactive watch faces whereby we made available limited user interaction with the watch face primarily through tap gestures. Android Wear 2.0 formalizes such additional display complexity into the idea of a complication. A complication is essentially any feature that displays data beyond the time, that is, the hours and minutes. Version 2.0 offers a watch face complications API that lets watch faces display extra information without requiring underlying plumbing to get the data. Instead, the provision of data—be it a battery level indicator, or weather information—is externalized through the complications API to a complication data provider, which then takes control of how the data is rendered on the watch face. The watch face that consumes data from such a complication data provider is still responsible for drawing the complications.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec62"/>Navigation and action drawers</h2></div></div></div><p>Android Wear 2.0 API is heavily based on material design from top to bottom, and we see the realization of its design principles in the core components and stock widgets.</p><p>We introduced the navigation and action drawers back in <a class="link" title="Chapter 9.  Material Design" href="part0063.xhtml#aid-1S2JE2">Chapter 9</a>, <em>Material Design</em>, in the course of a discussion on material design. Android Wear 2.0 has further solidified the alignment of these widgets with material design concepts.</p><p>There is additional support for drawer peeking so that users may access these drawers as they scroll. Also, the peek view and navigation drawer closure operations have been automated with the added ability to show the first action in the <code class="literal">WearableActionDrawer</code> API's peek view. These drawer widgets are also extensible in the new 2.0 APIs with support to create custom drawers.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec63"/>Expanded and messaging style notifications</h2></div></div></div><p>Android Wear 2.0 has made significant changes to notifications and the visual interactions with them. Users can get an improved experience through what are called expanded notifications. When we specify additional content pages and actions for a notification, they become available to the user in an expanded notification. Each expanded notification follows material design principles. The user can view the expanded notification by simply tapping on a notification. However, the notification would have to be generated by an app on the paired companion handheld, and it should not have a <code class="literal">Notification.contentIntent</code> class set for it.</p><p>The 2.0 version also offers a <code class="literal">Notification.MessagingStyle</code> class, which uses chat messages included in a <code class="literal">MessagingStyle</code> notification. The result is an enhanced app-like experience in the expanded notification.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec64"/>The Input Method Framework</h2></div></div></div><p>Android's <strong>Input Method Framework</strong> (<strong>IMF</strong>) allows users to enter text using the system's default IME or third-party IMEs. The input may be accomplished through tapping individual keys or by gesture typing. Android Wear 2.0 extends these same capabilities to wearable devices. Users will have the ability to enable more than one IME from a list of installed IMEs with one of them set as the default.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec65"/>Remote input and smart reply</h2></div></div></div><p>Wear 2.0 allows users to choose from a range of input options through the remote input API. These include dictation, emoji, smart reply, a developer-provided list of canned response, and the default IME.</p><p>In addition, developers can enable a <em>smart reply</em> feature for their notifications whereby users get a fast and reliable means to respond to chat messages. Contextually-relevant choices can be made to appear in expanded notifications, as well as in remote input.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec66"/>Wrist gestures</h2></div></div></div><p>Imagine being able to interact with our wearable device through a mere flick of our wrist. That is exactly what the designers of the Wear 2.0 APIs had in mind when they provided for the enablement of two wrist gestures for use by apps—the <em>Flick Wrist Out</em> and the <em>Flick Wrist In</em> gestures. A typical use case for this would be scrolling through a list of notifications or news articles while doing anything that forces you to interact with one hand only, for instance, when there is a large cup of coffee in the other hand.</p><p>Wrist gestures in 2.0 can be enabled/disabled by going to <strong>Settings</strong> | <strong>Gestures</strong> | <strong>Wrist Gestures</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec67"/>Bridging mode</h2></div></div></div><p>Notifications are, by default, shared (also known as bridged) from an app on a companion handheld to wearable device. If there is also a standalone wearable app issuing the same notifications, then this can be a source of annoyance, as the same notification appears from the standalone app as well as from the companion handheld, owing to the bridging.</p><p>To ameliorate this issue, the Android Wear 2.0 Preview edition includes a feature called <strong>bridging mode</strong>. This mode allows the standalone app to turn on or off, through its manifest, the bridging of notifications from the companion handheld app. Further, the APIs permit notification dismissals to be synchronized across devices through the declaration of dismissal IDs.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec68"/>Standalone wearables</h2></div></div></div><p>This was inevitable. The companion handheld is a valuable design metaphor in making the apps smart with respect to resource usage. But with perpetual strides in concentrating power and memory into small-form devices, the possibility of reducing dependence on companion handhelds, or even doing away with them, is becoming more and more real.</p><p>Standalone devices will let wearable apps work independently of companion apps. Rather than having an Android Wear app be embedded in its corresponding companion app (as is currently the case), the use of multi-APK delivery method will allow developers to release Android Wear apps independently of their corresponding companion apps.</p><div><h3 class="title"><a id="note22"/>Note</h3><p>APK is the Android file format used for installation to the Android operating system. We'll talk more about this in the next chapter. For now, suffice it to understand that Google Play offers multi-APK support that lets us publish different APKs for our apps, each targeting a different device configuration. Thus, each APK is an independent version of the app, even though they may share the same application listing and package name on Google Play. Each APK is also signed with the same release key.</p></div><p>Eliminating dependence on the companion app, in turn, eliminates the need for a wearable data layer API. Android Wear apps will be able to make network requests directly. Furthermore, direct access to network resources opens up new ways for Wear apps to authenticate. These ways include the following:</p><div><ul class="itemizedlist"><li class="listitem">Using the standard Google keyboard for direct text entry</li><li class="listitem">Using the <code class="literal">android.accounts.AccountManager</code> API class to sync and store account data</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec72"/>Summary</h1></div></div></div><p>We began this chapter with a discussion of how to keep our apps running when our wearable device goes into ambient mode. We then augmented our step counter activity using our <code class="literal">Today</code> app from <a class="link" title="Chapter 7.  Voice Interactions, Sensors, and Tracking" href="part0051.xhtml#aid-1GKCM1">Chapter 7</a>, <em>Voice Interaction, Sensors, and Tracking</em>, to make it always on, thereby getting up close to the parts of the Android Wear API that let us enable ambient mode for our apps. We then concluded with a brief note on debugging wearable apps over Bluetooth before proving a sneak preview of Android Wear 2.0.</p></div></body></html>