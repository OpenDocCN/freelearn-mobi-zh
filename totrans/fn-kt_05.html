<html><head></head><body>
        

                            
                    <h1 class="header-title">More on Functions</h1>
                
            
            
                
<p class="mce-root">In the previous chapters, we covered many features of Kotlin's functions. But now we'll expand on these many features, most of them borrowed from other languages, but with a new twist to fully accommodate them into Kotlin's overall goals and flavour—type-safety and pragmatical conciseness.</p>
<p>Some features, such as <strong>Domain Specific Languages</strong> (<strong>DSLs</strong>), let developers extend the language to domains that were not considered when Kotlin was first designed.</p>
<p class="mce-root">At the end of this chapter, you'll have a big picture of all function features, including:</p>
<ul>
<li class="mce-root">Extension functions</li>
<li class="mce-root">Operator overloading</li>
<li class="mce-root">Type-safe builders</li>
<li class="mce-root">Inline functions</li>
<li>Recursion and corecursion</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Single-expression functions</h1>
                
            
            
                
<p>Until now, all our examples were declared in a normal way.</p>
<p>The function sum takes two <kbd>Int</kbd> values and adds them. Declared in a normal way, we must provide a body with curly braces and an explicit <kbd>return</kbd>:</p>
<pre>fun sum(a:Int, b:Int): Int {<br/>   return a + b<br/>}</pre>
<p>Our <kbd>sum</kbd> function has its body declared inside curly braces with a <kbd>return</kbd> clause. But if our function is just one expression, it could have been written in a single line:</p>
<pre>fun sum(a:Int, b:Int): Int = a + b</pre>
<p>So, no curly braces, no <kbd>return</kbd> clause, and an equals (<kbd>=</kbd>) symbol. If you pay attention, it just looks similar to a lambda. </p>
<p>If you want to cut even more characters, you can use type inference too:</p>
<pre>fun sum(a:Int, b:Int) = a + b</pre>
<p>Use type inference for a function's return when it is very evident which type you are trying to return. A good rule of thumb is to use it for simple types such as numeric values, Boolean, string, and simple <kbd>data class</kbd> constructors. Anything more complicated, especially if the function does any transformation, should have explicit types. Your future self will be glad!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parameters</h1>
                
            
            
                
<p>A function can have zero or more parameters. Our function, <kbd>basicFunction</kbd>, takes two parameters, as shown in the following code:</p>
<pre>fun basicFunction(name: String, size: Int) {<br/><br/>}</pre>
<p>Each parameter is defined as <kbd>parameterName: ParameterType</kbd>, in our example, <kbd>name: String</kbd> and <kbd>size: Int</kbd>. Nothing new here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">vararg</h1>
                
            
            
                
<p>It gets interesting when parameters have two types that we have already covered—<kbd>vararg</kbd> and lambdas:</p>
<pre>fun aVarargFun(vararg names: String) {<br/>   names.forEach(::println)<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   aVarargFun()<br/>   aVarargFun("Angela", "Brenda", "Caroline")<br/>}</pre>
<p>A function with a parameter marked with the modifier, <kbd>vararg</kbd> can be called with zero or more values:</p>
<pre>fun multipleVarargs(vararg names: String, vararg sizes: Int) {<br/>// Compilation error, "Multiple vararg-parameters are prohibited"<br/>}</pre>
<p>A function can't have multiple <kbd>vararg</kbd> parameters, not even with different types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda</h1>
                
            
            
                
<p>We already discussed how, if a function's last parameter is a lambda, it can't be passed outside the parenthesis and inside curly braces, as if the lambda itself is the body of a control structure.</p>
<p>We covered this <kbd>unless</kbd> function in <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>, in the section, <em>First-class and high-order functions</em>. Let's have a look at the following code:</p>
<pre>fun unless(condition: Boolean, block: () -&gt; Unit) {<br/>   if (!condition) block()<br/>}<br/><br/>unless(someBoolean) {<br/>   println("You can't access this website")<br/>}</pre>
<p>Now, what happens if we combine <kbd>vararg</kbd> and lambda? Let's check it in the following code snippet:</p>
<pre>fun &lt;T, R&gt; transform(vararg ts: T, f: (T) -&gt; R): List&lt;R&gt; = ts.map(f)</pre>
<p>Lambdas can be at the end of a function with a <kbd>vararg</kbd> parameter:</p>
<pre>transform(1, 2, 3, 4) { i -&gt; i.toString() }</pre>
<p>Let's get a little adventurous, a <kbd>vararg</kbd> parameter of lambdas:</p>
<pre>fun &lt;T&gt; emit(t: T, vararg listeners: (T) -&gt; Unit) = listeners.forEach { listener -&gt;<br/>    listener(t)<br/>}<br/><br/>emit(1){i -&gt; println(i)} //Compilation error. Passing value as a vararg is only allowed inside a parenthesized argument list</pre>
<p>We can't pass a lambda outside of the parenthesis, but we can pass many lambdas inside:</p>
<pre>emit(1, ::println, {i -&gt; println(i * 2)})</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Named parameters</h1>
                
            
            
                
<p>Ideally, our functions should not have too many parameters, but this isn't always the case. Some functions tend to be big, for example, the <kbd>data class</kbd> constructors (constructors are technically a function that returns a new instance).</p>
<p>What is the problem with functions with many parameters?</p>
<ul>
<li>They are hard to use. This can be alleviated or fixed with default parameters that we will cover in the next section, <em>Default parameters</em>.</li>
<li>They are hard to read—named parameters to the rescue.</li>
<li>They are probably doing too much. Are you sure that your function isn't too big? Try to refactor it and clean up. Look for possible side effects and other harmful practices. A special case is <kbd>data class</kbd> constructors, as they are just autogenerated assignments.</li>
</ul>
<p>With named parameters, you can add readability to any function invocation.</p>
<p>Let's use a <kbd>data class</kbd> constructor as an example:</p>
<pre>typealias Kg = Double<br/>typealias cm = Int<br/><br/>data class Customer(val firstName: String,<br/>               val middleName: String,<br/>               val lastName: String,<br/>               val passportNumber: String,<br/>               val weight: Kg,<br/>               val height: cm)</pre>
<p class="mce-root">A normal invocation will look like this:</p>
<pre>val customer1 = Customer("John", "Carl", "Doe", "XX234", 82.3, 180)</pre>
<p>But including named parameters will increase the information available for the reader/maintainer and reduce mental work. We can also pass the parameters in any order that is more convenient or meaningful for the actual context:</p>
<pre>val customer2 = Customer(<br/>      lastName = "Doe",<br/>      firstName = "John",<br/>      middleName = "Carl",<br/>      height = 180,<br/>      weight = 82.3,<br/>      passportNumber = "XX234")</pre>
<p>Named parameters are very useful when they are combined with a <kbd>vararg</kbd> parameter:</p>
<pre>fun paramAfterVararg(courseId: Int, vararg students: String, roomTemperature: Double) {<br/>    //Do something here<br/>}<br/><br/>paramAfterVararg(68, "Abel", "Barbara", "Carl", "Diane", roomTemperature = 18.0)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Named parameters on high-order functions</h1>
                
            
            
                
<p>Usually when we define a high-order function, we never name the parameters for the lambda(s):</p>
<pre>fun high(f: (Int, String) -&gt; Unit) {<br/>   f(1, "Romeo")<br/>}<br/><br/>high { q, w -&gt;<br/>    //Do something<br/>}</pre>
<p>But it is possible to add them. So, the <kbd>f</kbd> lambda now has its parameters named—<kbd>age</kbd> and <kbd>name</kbd>:</p>
<pre>fun high(f: (age:Int, name:String) -&gt; Unit) {<br/>   f(1, "Romeo")<br/>}</pre>
<p>This doesn't change any behavior, it is just to give more clarity on the intended use of this lambda:</p>
<pre>fun high(f: (age:Int, name:String) -&gt; Unit) {<br/>   f(age = 3, name = "Luciana") //compilation error<br/>}</pre>
<p>But it isn't possible to call a lambda with named parameters. In our example, invoking <kbd>f</kbd> with names produces a compilation error.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Default parameters</h1>
                
            
            
                
<p>In Kotlin, function parameters can have default values. For the <kbd>Programmer</kbd>, the <kbd>favouriteLanguage</kbd> and <kbd>yearsOfExperience</kbd> data classes have default values (remember that a constructor is a function too):</p>
<pre>data class Programmer(val firstName: String,<br/>                 val lastName: String,<br/>                 val favouriteLanguage: String = "Kotlin",<br/>                 val yearsOfExperience: Int = 0)</pre>
<p>So, <kbd>Programmer</kbd> can be created with just two parameters:</p>
<pre>val programmer1 = Programmer("John", "Doe")</pre>
<p>But if you want to pass <kbd>yearsOfExperience</kbd>, it must be as a named parameter:</p>
<pre>val programmer2 = Programmer("John", "Doe", 12) //Error<br/><br/>val programmer2 = Programmer("John", "Doe", yearsOfExperience = 12) //OK</pre>
<p>You can still pass all parameters if you want to, but they must be provided in the right order if you aren't using named arguments:</p>
<pre>val programmer3 = Programmer("John", "Doe", "TypeScript", 1)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions</h1>
                
            
            
                
<p>Definitively, one of the best features of Kotlin is extension functions. Extension functions let you modify existing types with new functions:</p>
<pre>fun String.sendToConsole() = println(this)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   "Hello world! (from an extension function)".sendToConsole()<br/>}</pre>
<p>To add an extension function to an existing type, you must write the function's name next to the type's name, joined by a dot (<kbd>.</kbd>).</p>
<p>In our example, we add an extension function (<kbd>sendToConsole()</kbd>) to the <kbd>String</kbd> type. Inside the function's body, <kbd>this</kbd> refers the instance of <kbd>String</kbd> type (in this extension function, <kbd>string</kbd> is the receiver type).</p>
<p>Apart from the dot (<kbd>.</kbd>) and <kbd>this</kbd>, extension functions have the same syntax rules and features as a normal function. Indeed, behind the scenes, an extension function is a normal function whose first parameter is a value of the receiver type. So, our <kbd>sendToConsole()</kbd> extension function is equivalent to the next code:</p>
<pre>fun sendToConsole(string: String) = println(string)<br/><br/>sendToConsole("Hello world! (from a normal function)")</pre>
<p>So, in reality, we aren't modifying a type with new functions. Extension functions are a very elegant way to write utility functions, easy to write, very fun to use, and nice to read—a win-win. This also means that extension functions have one restriction—they can't access private members of <kbd>this</kbd>, in contrast with a proper member function that can access everything inside the instance:</p>
<pre>class Human(private val name: String)<br/><br/>fun Human.speak(): String = "${this.name} makes a noise" //Cannot access 'name': it is private in 'Human'</pre>
<p>Invoking an extension function is the same as a normal function—with an instance of the receiver type (that will be referenced as <kbd>this</kbd> inside the extension), invoke the function by name. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions and inheritance</h1>
                
            
            
                
<p>There is a big difference between member functions and extension functions when we talk about inheritance.</p>
<p class="mce-root">The open class <kbd>Canine</kbd> has a subclass, <kbd>Dog</kbd>. A standalone function, <kbd>printSpeak</kbd>, receives a parameter of type <kbd>Canine</kbd> and prints the content of the result of the function <kbd>speak(): String</kbd>:</p>
<pre>open class Canine {<br/>   open fun speak() = "&lt;generic canine noise&gt;"<br/>}<br/><br/>class Dog : Canine() {<br/>   override fun speak() = "woof!!"<br/>}<br/><br/>fun printSpeak(canine: Canine) {<br/>   println(canine.speak())<br/>}</pre>
<p>We already covered this in <a href="6fd42581-3c3e-4471-b103-22a571a138a4.xhtml">Chapter 1</a>, <em>Kotlin – Data Types, Objects and Classes</em>, in the <em>Inheritance </em>section. Open classes with <kbd>open</kbd> methods (member functions) can be extended and alter their behavior. Invoking the <kbd>speak</kbd> function will act differently depending on which type is your instance.</p>
<p>The <kbd>printSpeak</kbd> function can be invoked with any instance of a class that <em>is-a</em> <kbd>Canine</kbd>, either <kbd>Canine</kbd> itself or any subclass:</p>
<pre>printSpeak(Canine())<br/>printSpeak(Dog())</pre>
<p>If we execute this code, we can see this on the console:</p>
<div><img height="38" width="157" src="img/07ebfddd-9372-4688-aa65-a4baba259a7a.png"/></div>
<p>Although both are <kbd>Canine</kbd>, the behavior of <kbd>speak</kbd> is different in both cases, as the subclass overrides the parent implementation.</p>
<p>But with extension functions, many things are different.</p>
<p>As with the previous example, <kbd>Feline</kbd> is an open class extended by the <kbd>Cat</kbd> class. But <kbd>speak</kbd> is now an extension function:</p>
<pre>open class Feline<br/><br/>fun Feline.speak() = "&lt;generic feline noise&gt;"<br/><br/>class Cat : Feline()<br/><br/>fun Cat.speak() = "meow!!"<br/><br/>fun printSpeak(feline: Feline) {<br/>   println(feline.speak())<br/>}</pre>
<p>Extension functions don't need to be marked as override, because we aren't overriding anything:</p>
<pre>printSpeak(Feline())<br/>printSpeak(Cat()</pre>
<p>If we execute this code, we can see this on the console:</p>
<div><img height="39" width="158" src="img/0d28f873-ad11-4f56-a174-1b3c0bd91f3e.png"/></div>
<p>In this case, both invocations produce the same result. Although in the beginning it seems confusing, once you analyse what is happening, it becomes clear. We're invoking the <kbd>Feline.speak()</kbd> function twice; this is because each parameter that we pass is a <kbd>Feline</kbd> to the <kbd>printSpeak(Feline)</kbd> function:</p>
<pre>open class Primate(val name: String)<br/><br/>fun Primate.speak() = "$name: &lt;generic primate noise&gt;"<br/><br/>open class GiantApe(name: String) : Primate(name)<br/><br/>fun GiantApe.speak() = "${this.name} :&lt;scary 100db roar&gt;"<br/><br/>fun printSpeak(primate: Primate) {<br/> println(primate.speak())<br/>}<br/><br/>printSpeak(Primate("Koko"))<br/>printSpeak(GiantApe("Kong"))</pre>
<p>If we execute this code, we can see this on the console:</p>
<div><img height="40" width="201" src="img/50f03c90-318c-4fec-9028-d4d9de9d9372.png"/> </div>
<p>In this case, it is still the same behavior as with the previous examples, but using the right value for <kbd>name</kbd>. Speaking of which, we can reference <kbd>name</kbd> with <kbd>name</kbd> and <kbd>this.name</kbd>; both are valid.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions as members</h1>
                
            
            
                
<p>Extension functions can be declared as members of a class. An instance of a class with extension functions declared is called the <strong>dispatch receiver.</strong></p>
<p>The <kbd>Caregiver</kbd> open class internally defines, extension functions for two different classes, <kbd>Feline</kbd> and <kbd>Primate</kbd>:</p>
<pre>open class Caregiver(val name: String) {<br/>   open fun Feline.react() = "PURRR!!!"<br/>   <br/>   fun Primate.react() = "*$name plays with ${this@Caregiver.name}*"<br/><br/>   fun takeCare(feline: Feline) {<br/>      println("Feline reacts: ${feline.react()}")<br/>   }<br/>   <br/>   fun takeCare(primate: Primate){<br/>      println("Primate reacts: ${primate.react()}")<br/>   }<br/>}</pre>
<p>Both extension functions are meant to be used inside an instance of <kbd>Caregiver</kbd>. Indeed, it is a good practice to mark member extension functions as private, if they aren't open.</p>
<p>In the case of <kbd>Primate.react()</kbd>, we are using the <kbd>name</kbd> value from <kbd>Primate</kbd> and the <kbd>name</kbd> value from <kbd>Caregiver</kbd>. To access members with a name conflict, the extension receiver (<kbd>this</kbd>) takes precedence and to access members of the dispatcher receiver, the qualified <kbd>this</kbd> syntax must be used. Other members of the dispatcher receiver that don't have a name conflict can be used without qualified <kbd>this</kbd>.</p>
<p class="mce-root">Don't get confused by the various means of <kbd>this</kbd> that we have already covered:</p>
<ul>
<li>Inside a class, <kbd>this</kbd> means the instance of that class</li>
<li>Inside an extension function, <kbd>this</kbd> means the instance of the receiver type like the first parameter in our utility function with nice syntax:</li>
</ul>
<pre>class Dispatcher {<br/>   val dispatcher: Dispatcher = this<br/><br/>   fun Int.extension(){<br/>      val receiver: Int = this<br/>      val dispatcher: Dispatcher = this@Dispatcher<br/>   }<br/>}</pre>
<p>Going back to our <em>Zoo</em> example, we instantiate a <kbd>Caregiver</kbd>, a <kbd>Cat</kbd>, and a <kbd>Primate</kbd>, and we invoke the function <kbd>Caregiver.takeCare</kbd> with both animal instances:</p>
<pre>val adam = Caregiver("Adam")<br/><br/>val fulgencio = Cat()<br/><br/>val koko = Primate("Koko")<br/><br/>adam.takeCare(fulgencio)<br/>adam.takeCare(koko)</pre>
<p>If we execute this code, we can see this on the console:</p>
<div><img height="35" width="239" src="img/8cad2a39-09ef-4755-963c-d27ae0a94429.png"/></div>
<p>Any zoo needs a veterinary surgeon. The class <kbd>Vet</kbd> extends <kbd>Caregiver</kbd>:</p>
<pre>open class Vet(name: String): Caregiver(name) {<br/>   override fun Feline.react() = "*runs away from $name*"<br/>}</pre>
<p>We override the <kbd>Feline.react()</kbd> function with a different implementation. We are also using the <kbd>Vet</kbd> class's name directly, as the <kbd>Feline</kbd> class doesn't have a property name:</p>
<pre>val brenda = Vet("Brenda")<br/><br/>listOf(adam, brenda).forEach { caregiver -&gt;<br/>   println("${caregiver.javaClass.simpleName} ${caregiver.name}")<br/>   caregiver.takeCare(fulgencio)<br/>   caregiver.takeCare(koko)<br/>}<br/></pre>
<p>After which, we get the following output:</p>
<div><img height="97" width="236" src="img/25274a35-6b26-4563-a986-33c61c6b238b.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions with conflicting names</h1>
                
            
            
                
<p>What happens when an extension function has the same name as a member function?</p>
<p>The <kbd>Worker</kbd> class has a function <kbd>work(): String</kbd> and a private function <kbd>rest(): String</kbd>. We also have two extension functions with the same signature, <kbd>work</kbd> and <kbd>rest</kbd>:</p>
<pre>class Worker {<br/>   fun work() = "*working hard*"<br/><br/>   private fun rest() = "*resting*"<br/>}<br/><br/>fun Worker.work() = "*not working so hard*"<br/><br/>fun &lt;T&gt; Worker.work(t:T) = "*working on $t*"<br/><br/>fun Worker.rest() = "*playing video games*"</pre>
<p>Having extension functions with the same signature isn't a compilation error, but a warning: <kbd>Extension is shadowed by a member: public final fun work(): String</kbd></p>
<p>It is legal to declare a function with the same signature as a member function, but the member function always takes precedence, therefore, the extension function is never invoked. This behavior changes when the member function is private, in this case, the extension function takes precedence.</p>
<p>It is also possible to overload an existing member function with an extension function:</p>
<pre>val worker = Worker()<br/><br/>println(worker.work())<br/><br/>println(worker.work("refactoring"))<br/><br/>println(worker.rest())</pre>
<p class="mce-root CDPAlignLeft CDPAlign">On execution, <kbd>work()</kbd> invokes the member function and <kbd>work(String)</kbd> and <kbd>rest()</kbd> are extension functions:</p>
<div><img height="58" width="174" src="img/6eaa0a12-3eb0-4256-98c1-1e54da9793c8.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Extension functions for objects</h1>
                
            
            
                
<p>In Kotlin, objects are a type, therefore they can have functions, including extension functions (among other things, such as extending interfaces and others).</p>
<p>We can add a <kbd>buildBridge</kbd> extension function to the object, <kbd>Builder</kbd>:</p>
<pre>object Builder {<br/><br/>}<br/><br/>fun Builder.buildBridge() = "A shinny new bridge"</pre>
<p>We can include companion objects. The class <kbd>Designer</kbd> has two inner objects, the <kbd>companion</kbd> object and <kbd>Desk</kbd> object:</p>
<pre>class Designer {<br/>   companion object {<br/><br/>   }<br/><br/>   object Desk {<br/><br/>   }<br/>}<br/><br/><br/>fun Designer.Companion.fastPrototype() = "Prototype"<br/><br/>fun Designer.Desk.portofolio() = listOf("Project1", "Project2")</pre>
<p>Calling this functions works like any normal object member function:</p>
<pre>Designer.fastPrototype()<br/>Designer.Desk.portofolio().forEach(::println)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Infix functions</h1>
                
            
            
                
<p>Functions (normal or extension) with just one parameter can be marked as <kbd>infix</kbd> and used with the <kbd>infix</kbd> notation. The <kbd>infix</kbd> notation is useful to express the code naturally for some domains, for example, math and algebra operations.</p>
<p>Let's add an <kbd>infix</kbd> extension function to the <kbd>Int</kbd> type, <kbd>superOperation</kbd> (which is just a regular sum with a fancy name):</p>
<pre>infix fun Int.superOperation(i: Int) = this + i<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   1 superOperation 2<br/>   1.superOperation(2)<br/>}</pre>
<p>We can use the <kbd>superOperation</kbd> function with the <kbd>infix</kbd> notation or normal notation.</p>
<p>Another area where the <kbd>infix</kbd> notation is commonly used, is on assertion libraries, such as <strong>HamKrest</strong> (<a href="https://github.com/npryce/hamkrest">https://github.com/npryce/hamkrest</a>) or <strong>Kluent</strong> (<a href="https://github.com/MarkusAmshove/Kluent">https://github.com/MarkusAmshove/Kluent</a>). Writing specification code in a natural, easy to understand language is a huge advantage.</p>
<p>Kluent assertions look like natural English expressions:</p>
<pre>"Kotlin" shouldStartWith "Ko"</pre>
<p class="mce-root">Kluent also comes with a backtick version for even greater readability:</p>
<pre>"Kotlin" `should start with` "Ko"</pre>
<p class="mce-root">Backticks (<kbd>`</kbd>) let you write arbitrary identifiers, including words that are reserved in Kotlin. Now, you can write your own kaomoji functions:</p>
<div><img height="77" width="400" src="img/12e0fde8-446a-469c-8fa6-855d64ec3c1a.png"/></div>
<p>You can chain many <kbd>infix</kbd> functions to produce internal DSLs, or recreate classic memes:</p>
<pre>object All {<br/>   infix fun your(base: Pair&lt;Base, Us&gt;) {}<br/>}<br/><br/>object Base {<br/>   infix fun are(belong: Belong) = this<br/>}<br/><br/>object Belong<br/><br/>object Us<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   All your (Base are Belong to Us)<br/>}</pre>
<p class="mce-root">The <kbd>your</kbd>  function, receives <kbd>Pair&lt;Base, Us&gt;</kbd> as a parameter (a kind of tuple that comes with and is widely used on the Kotlin standard library) and the <kbd>infix</kbd> extension function <kbd>&lt;K, V&gt; K.to(v: V)</kbd> returns a <kbd>Pair&lt;K, V&gt;</kbd> using the receiver as the first member and the parameter as the second parameter (<kbd>to</kbd> can be invoked with any combination of types).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator overloading</h1>
                
            
            
                
<p><strong>Operator overloading</strong> is a form of polymorphism. Some operators change behaviors on different types. The classic example is the operator plus (<kbd>+</kbd>). On numeric values, plus is a sum operation and on <kbd>String</kbd> is a concatenation. Operator overloading is a useful tool to provide your API with a natural surface. Let's say that we're writing a <kbd>Time</kbd> and <kbd>Date</kbd> library; it'll be natural to have the plus and minus operators defined on time units.  </p>
<p>Kotlin lets you define the behavior of operators on your own or existing types with functions, normal or extension, marked with the <kbd>operator</kbd> modifier:</p>
<pre>class Wolf(val name:String) {<br/>   operator fun plus(wolf: Wolf) = Pack(mapOf(name to this, wolf.name to wolf))<br/>}<br/><br/>class Pack(val members:Map&lt;String, Wolf&gt;)<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val talbot = Wolf("Talbot")<br/>   val northPack: Pack = talbot + Wolf("Big Bertha") // talbot.plus(Wolf("..."))<br/>}</pre>
<p>The operator function plus returns a <kbd>Pack</kbd> value. To invoke it, you can use the <kbd>infix</kbd> operator way (<kbd>Wolf + Wolf</kbd>) or the normal way (<kbd>Wolf.plus(Wolf)</kbd>).</p>
<p>Something to be aware of about operator overloading in Kotlin—the operators that you can override in Kotlin are limited; you can't create arbitrary operators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary operators</h1>
                
            
            
                
<p>Binary operators receive a parameter (there are exceptions to this rule—<kbd>invoke</kbd> and indexed access).</p>
<p>The <kbd>Pack.plus</kbd> extension function receives a <kbd>Wolf</kbd> parameter and returns a new <kbd>Pack</kbd>. Note that <kbd>MutableMap</kbd> also has a plus (<kbd>+</kbd>) operator:</p>
<pre>operator fun Pack.plus(wolf: Wolf) = Pack(this.members.toMutableMap() + (wolf.name to wolf))<br/><br/>val biggerPack = northPack + Wolf("Bad Wolf")</pre>
<p>The following table will show you all the possible binary operators that can be overloaded:<br/></p>
<table>
<tbody>
<tr>
<td>
<p class="mce-root"><strong>Operator</strong></p>
</td>
<td><strong>Equivalent</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td><kbd>x + y</kbd></td>
<td><kbd>x.plus(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x - y</kbd></td>
<td><kbd>x.minus(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x * y</kbd></td>
<td><kbd>x.times(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x / y</kbd></td>
<td><kbd>x.div(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x % y</kbd></td>
<td><kbd>x.rem(y)</kbd></td>
<td>
<p>From Kotlin 1.1, previously <kbd>mod</kbd>.</p>
</td>
</tr>
<tr>
<td><kbd>x..y</kbd></td>
<td><kbd>x.rangeTo(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x in y</kbd></td>
<td><kbd>y.contains(x)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x !in y</kbd></td>
<td><kbd>!y.contains(x)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x += y</kbd></td>
<td><kbd>x.plussAssign(y)</kbd></td>
<td>Must return <kbd>Unit</kbd>.</td>
</tr>
<tr>
<td><kbd>x -= y</kbd></td>
<td><kbd>x.minusAssign(y)</kbd></td>
<td>Must return <kbd>Unit</kbd>.</td>
</tr>
<tr>
<td><kbd>x *= y</kbd></td>
<td><kbd>x.timesAssign(y)</kbd></td>
<td>Must return <kbd>Unit</kbd>.</td>
</tr>
<tr>
<td><kbd>x /= y</kbd></td>
<td><kbd>x.divAssign(y)</kbd></td>
<td>Must return <kbd>Unit</kbd>.</td>
</tr>
<tr>
<td><kbd>x %= y</kbd></td>
<td><kbd>x.remAssign(y)</kbd></td>
<td>From Kotlin 1.1, previously <kbd>modAssign</kbd>. Must return <kbd>Unit</kbd>.</td>
</tr>
<tr>
<td><kbd>x == y</kbd></td>
<td><kbd>x?.equals(y) ?: (y === null)</kbd></td>
<td>Checks for <kbd>null</kbd>.</td>
</tr>
<tr>
<td><kbd>x != y</kbd></td>
<td><kbd>!(x?.equals(y) ?: (y === null))</kbd></td>
<td>Checks for <kbd>null</kbd>.</td>
</tr>
<tr>
<td><kbd>x &lt; y</kbd></td>
<td><kbd>x.compareTo(y) &lt; 0</kbd></td>
<td>Must return <kbd>Int</kbd>.</td>
</tr>
<tr>
<td><kbd>x &gt; y</kbd></td>
<td><kbd>x.compareTo(y) &gt; 0</kbd></td>
<td>Must return <kbd>Int</kbd>.</td>
</tr>
<tr>
<td><kbd>x &lt;= y</kbd></td>
<td><kbd>x.compareTo(y) &lt;= 0</kbd></td>
<td>Must return <kbd>Int</kbd>.</td>
</tr>
<tr>
<td><kbd>x &gt;= y</kbd></td>
<td><kbd>x.compareTo(y) &gt;= 0</kbd></td>
<td>Must return <kbd>Int</kbd>.</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Invoke</h1>
                
            
            
                
<p>Back in <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>, in the section <em>First-class and high-order functions</em>, when we introduced lambda functions, we show the definition of <kbd>Function1</kbd>:</p>
<pre>/** A function that takes 1 argument. */<br/>public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {<br/>    /** Invokes the function with the specified argument. */<br/>    public operator fun invoke(p1: P1): R<br/>}</pre>
<p>The <kbd>invoke</kbd> function is an operator, a curious one. The <kbd>invoke</kbd> operator can be called without <kbd>name</kbd>.</p>
<p>The class <kbd>Wolf</kbd> has an <kbd>invoke</kbd> operator:</p>
<pre>enum class WolfActions {<br/>   SLEEP, WALK, BITE<br/>}<br/><br/>class Wolf(val name:String) {<br/>   operator fun invoke(action: WolfActions) = when (action) {<br/>      WolfActions.SLEEP -&gt; "$name is sleeping"<br/>      WolfActions.WALK -&gt; "$name is walking"<br/>      WolfActions.BITE -&gt; "$name is biting"<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val talbot = Wolf("Talbot")<br/><br/>   talbot(WolfActions.SLEEP) // talbot.invoke(WolfActions.SLEEP)<br/>}</pre>
<p>That's why we can call a lambda function directly with parenthesis; we are, indeed, calling the <kbd>invoke</kbd> operator.</p>
<p>The following table will show you different declarations of <kbd>invoke</kbd> with a number of different arguments:</p>
<table>
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Equivalent</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td><kbd>x()</kbd></td>
<td><kbd>x.invoke()</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x(y)</kbd></td>
<td><kbd>x.invoke(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x(y1, y2)</kbd></td>
<td><kbd>x.invoke(y1, y2)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x(y1, y2..., yN)</kbd></td>
<td><kbd>x.invoke(y1, y2..., yN)</kbd></td>
<td/>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Indexed access</h1>
                
            
            
                
<p>The indexed access operator is the array read and write operations with square brackets (<kbd>[]</kbd>), that is used on languages with C-like syntax. In Kotlin, we use the <kbd>get</kbd> operators for reading and <kbd>set</kbd> for writing.</p>
<p>With the <kbd>Pack.get</kbd> operator, we can use <kbd>Pack</kbd> as an array:</p>
<pre>operator fun Pack.get(name: String) = members[name]!!<br/><br/>val badWolf = biggerPack["Bad Wolf"]</pre>
<p>Most of Kotlin data structures have a definition of the <kbd>get</kbd> operator, in this case, the <kbd>Map&lt;K, V&gt;</kbd> returns a <kbd>V?</kbd>.</p>
<p class="mce-root">The following table will show you different declarations of <kbd>get</kbd> with a different number of arguments:</p>
<table>
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Equivalent</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td><kbd>x[y]</kbd></td>
<td><kbd>x.get(y)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x[y1, y2]</kbd></td>
<td><kbd>x.get(y1, y2)</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x[y1, y2..., yN]</kbd></td>
<td><kbd>x.get(y1, y2..., yN)</kbd></td>
<td/>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The <kbd>set</kbd> operator has similar syntax:</p>
<pre>enum class WolfRelationships {<br/>   FRIEND, SIBLING, ENEMY, PARTNER<br/>}<br/><br/>operator fun Wolf.set(relationship: WolfRelationships, wolf: Wolf) {<br/>   println("${wolf.name} is my new $relationship")<br/>}<br/><br/>talbot[WolfRelationships.ENEMY] = badWolf</pre>
<p>The operators <kbd>get</kbd> and <kbd>set</kbd> can have any arbitrary code, but it is a very well-known and old convention that indexed access is used for reading and writing. When you write these operators (and by the way, all the other operators too), use the principle of <em>least surprise</em>. Limiting the operators to their natural meaning on a specific domain, makes them easier to use and read in the long run.</p>
<p>The following table will show you different declarations of <kbd>set</kbd> with a different number of arguments:</p>
<div><table>
<tbody>
<tr>
<td><strong>Operator</strong></td>
<td><strong>Equivalent</strong></td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td><kbd>x[y] = z</kbd></td>
<td><kbd>x.set(y, z)</kbd></td>
<td>Return value is ignored</td>
</tr>
<tr>
<td><kbd>x[y1, y2] = z</kbd></td>
<td><kbd>x.set(y1, y2, z)</kbd></td>
<td>Return value is ignored</td>
</tr>
<tr>
<td><kbd>x[y1, y2..., yN] = z</kbd></td>
<td><kbd>x.set(y1, y2..., yN, z)</kbd></td>
<td>Return value is ignored</td>
</tr>
</tbody>
</table>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Unary operators</h1>
                
            
            
                
<p><strong>Unary operators</strong> don't have parameters and act directly in the dispatcher.</p>
<p>We can add a <kbd>not</kbd> operator to the <kbd>Wolf</kbd> class:</p>
<pre>operator fun Wolf.not() = "$name is angry!!!"<br/><br/>!talbot // talbot.not()<br/></pre>
<p>The following table will show you all the possible unary operators that can be overloaded:</p>
<table>
<tbody>
<tr>
<td>
<p class="mce-root"><strong>Operator</strong></p>
</td>
<td>
<p class="mce-root"><strong>Equivalent</strong></p>
</td>
<td><strong>Notes</strong></td>
</tr>
<tr>
<td><kbd>+x</kbd></td>
<td><kbd>x.unaryPlus()</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>-x</kbd></td>
<td><kbd>x.unaryMinus()</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>!x</kbd></td>
<td><kbd>x.not()</kbd></td>
<td/>
</tr>
<tr>
<td><kbd>x++</kbd></td>
<td><kbd>x.inc()</kbd></td>
<td>Postfix, it must be a call on a <kbd>var</kbd>, should return a compatible type with the dispatcher type, shouldn't mutate the dispatcher.</td>
</tr>
<tr>
<td><kbd>x--</kbd></td>
<td><kbd>x.dec()</kbd></td>
<td>Postfix, it must be a call on a <kbd>var</kbd>, should return a compatible type with the dispatcher type, shouldn't mutate the dispatcher.</td>
</tr>
<tr>
<td><kbd>++x</kbd></td>
<td><kbd>x.inc()</kbd></td>
<td>Prefix, it must be a call on a <kbd>var</kbd>, should return a compatible type with the dispatcher type, shouldn't mutate the dispatcher.</td>
</tr>
<tr>
<td><kbd>--x</kbd></td>
<td><kbd>x.dec()</kbd></td>
<td>Prefix, it must be a call on a <kbd>var</kbd>, should return a compatible type with the dispatcher type, shouldn't mutate the dispatcher.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Postfix (increment and decrement) returns the original value and then changes the variable with the operator returned value. Prefix returns the operator's returned value and then changes the variable with that value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Type-safe builders</h1>
                
            
            
                
<p>With the two previous sections (<kbd>infix</kbd> functions and operator overloading), we have a good foundation for building fantastic DSLs. A <strong>DSL</strong> is a language that is specialized to a particular domain, in contrast to <strong>general-purpose language</strong> (<strong>GPL</strong>). Classic examples of DSLs (even when people don't realize it) are HTML (markup) and SQL (relational database queries).  </p>
<p>Kotlin provides many features to create internal DSLs (a DSL that runs internally inside a host GPL), but there is one feature that we still need to cover, type-safe builders. Type-safe builders let us define data in a (semi) declarative way and are very useful to define GUIs,  HTML markup, XML, and others.</p>
<p>An example of a beautiful Kotlin DSL is TornadoFX. <strong>TornadoFX</strong> (<a href="https://tornadofx.io/">https://tornadofx.io/</a>) is DSL for creating JavaFX applications.</p>
<p>We write an <kbd>FxApp</kbd> class that extends <kbd>tornadofx.App</kbd> and receives a <kbd>tornadofx.View</kbd> class (a class reference, not an instance):</p>
<pre>import javafx.application.Application<br/>import tornadofx.*<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   Application.launch(FxApp::class.java, *args)<br/>}<br/><br/>class FxApp: App(FxView::class)<br/><br/>class FxView: View() {<br/>   override val root = vbox {<br/>      label("Functional Kotlin")<br/>      button("Press me")<br/>   }<br/>}</pre>
<p>In less than 20 lines of code, including imports and main function, we can create a GUI application:</p>
<div><img height="78" width="109" src="img/aa2565c7-bdb1-44e8-bb59-e574a6cd5318.png"/></div>
<p>Of course, right now, it doesn't do anything, but it is simple to create a JavaFX Application with TornadoFX, if you compare it with Java. People with JavaFX experience could say that you can achieve something similar with FXML (a declarative XML language designed to build JavaFX layouts), but as with any other XML file, writing and maintaining is hard, and TornadoFX's DSL is simpler, flexible, and is compiled with Kotlin's type-safety.</p>
<p>But how do type-safe builders work?</p>
<p>Let's start with an example from the Kotlin Standard Library:</p>
<pre>val joinWithPipe = with(listOf("One", "Two", "Three")){<br/>   joinToString(separator = "|")<br/>}</pre>
<p>We can find <kbd>with</kbd> blocks in other languages, such as JavaScript and Visual Basic (including .Net). A <kbd>with</kbd> block is a language construct that lets us use any property or method on the value that we pass as a parameter. But in Kotlin, <kbd>with</kbd> is not a reserved keyword but rather a normal function with a special type of parameter.</p>
<p>Let's have a look at the <kbd>with</kbd> declaration:</p>
<pre>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {<br/>    return receiver.block()<br/>}</pre>
<p>The first parameter is any value of type <kbd>T</kbd>, a receiver (as in extension function?) and the second one, <kbd>block</kbd>, is a function of type <kbd>T.() -&gt; R</kbd>. In Kotlin's documentation, this kind of function is named <strong>function type</strong> with receiver and with any instance of <kbd>T,</kbd> we can call the <kbd>block</kbd> function. No worries about the <kbd>inline</kbd> modifier, we'll cover it in the next section.</p>
<p>A trick to understanding the function type with receiver is to think of it as an extension function. Have a look at the declaration with that familiar dot (<kbd>.</kbd>), and inside the function, we can use any member of the receiver type using <kbd>this</kbd>, as in extension functions.</p>
<p>What about another example? Let's have a look at it:</p>
<div><pre>val html = buildString {<br/>   append("&lt;html&gt;\n")<br/>   append("\t&lt;body&gt;\n")<br/>   append("\t\t&lt;ul&gt;\n")<br/>   listOf(1, 2, 3).forEach { i -&gt;<br/>      append("\t\t\t&lt;li&gt;$i&lt;/li&gt;\n")<br/>   }<br/>   append("\t\t&lt;ul&gt;\n")<br/>   append("\t&lt;/body&gt;\n")<br/>   append("&lt;/htm<br/><br/>l&gt;")<br/>}</pre></div>
<p>The <kbd>buildString</kbd> function receives a <kbd>StringBuilder.() -&gt; Unit</kbd> parameter and returns a <kbd>String</kbd>; the declaration is astonishingly simple:</p>
<pre>public inline fun buildString(builderAction: StringBuilder.() -&gt; Unit): String =<br/>        StringBuilder().apply(builderAction).toString()</pre>
<p>The <kbd>apply</kbd> function is an extension function similar to <kbd>with</kbd> but instead of returning <kbd>R</kbd>, returns the receiver instance. Usually, <kbd>apply</kbd> is used for <em>initializing</em> and <em>instance</em>:</p>
<pre>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {    <br/>    block()<br/>    return this<br/>}</pre>
<p>As you can see, all these functions are very simple to understand, but they increase Kotlin's usefulness and readability a great deal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a DSL</h1>
                
            
            
                
<p>One of my big passions is cycling. The emotion of movement, the effort, the health benefits, and enjoying the landscape are some of the benefits (and I can keep going on and on).</p>
<p>I want to create a way to have a registry of my bikes and their components. For the prototype phase, I'll use XML, but later on we can change to a different implementation:</p>
<pre>&lt;bicycle description="Fast carbon commuter"&gt;<br/>    &lt;bar material="ALUMINIUM" type="FLAT"&gt;<br/>    &lt;/bar&gt;<br/>    &lt;frame material="CARBON"&gt;<br/>        &lt;wheel brake="DISK" material="ALUMINIUM"&gt;<br/>        &lt;/wheel&gt;<br/>    &lt;/frame&gt;<br/>    &lt;fork material="CARBON"&gt;<br/>        &lt;wheel brake="DISK" material="ALUMINIUM"&gt;<br/>        &lt;/wheel&gt;<br/>    &lt;/fork&gt;<br/>&lt;/bicycle&gt;  </pre>
<p>This is the perfect scenario to create a type-safe builder in Kotlin.</p>
<p>In the end, my <kbd>bicycle</kbd> DSL should look like this:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val commuter = bicycle {<br/>      description("Fast carbon commuter")<br/>      bar {<br/>         barType = FLAT<br/>         material = ALUMINIUM<br/>      }<br/>      frame {<br/>         material = CARBON<br/>         backWheel {<br/>            material = ALUMINIUM<br/>            brake = DISK<br/>         }<br/>      }<br/>      fork {<br/>         material = CARBON<br/>         frontWheel {<br/>            material = ALUMINIUM<br/>            brake = DISK<br/>         }<br/>      }<br/>   }<br/><br/>   println(commuter)<br/>}</pre>
<p>My DSL is regular Kotlin code, is compiled fast, and my IDE will help me to autocomplete, and will complain when I make a mistake—a win-win situation.</p>
<p>Let's start with the program:</p>
<pre>interface Element {<br/>   fun render(builder: StringBuilder, indent: String)<br/>}</pre>
<p>All parts of my <kbd>bicycle</kbd> in my DSL will extend/implement the <kbd>Element</kbd> interface:</p>
<pre>@DslMarker<br/>annotation class ElementMarker<br/><br/>@ElementMarker<br/>abstract class Part(private val name: String) : Element {<br/>   private val children = arrayListOf&lt;Element&gt;()<br/>   protected val attributes = hashMapOf&lt;String, String&gt;()<br/><br/>   protected fun &lt;T : Element&gt; initElement(element: T, init: T.() -&gt; Unit): T {<br/>      element.init()<br/>      children.add(element)<br/>      return element<br/>   }<br/><br/>   override fun render(builder: StringBuilder, indent: String) {<br/>      builder.append("$indent&lt;$name${renderAttributes()}&gt;\n")<br/>      children.forEach { c -&gt; c.render(builder, indent + "\t") }<br/>      builder.append("$indent&lt;/$name&gt;\n")<br/>   }<br/><br/>   private fun renderAttributes(): String = buildString {<br/>      attributes.forEach { attr, value -&gt; append(" $attr=\"$value\"") }<br/>   }<br/><br/>   override fun toString(): String = buildString {<br/>      render(this, "")<br/>   }<br/>}</pre>
<p><kbd>Part</kbd> is the base class for all my parts; it has <kbd>children</kbd> and <kbd>attributes</kbd> properties; it also inherits the <kbd>Element</kbd> interface with an XML implementation. Changing to a different format (JSON, YAML, and others) should not be too difficult.</p>
<p>The <kbd>initElement</kbd> function receives two parameters, an element <kbd>T</kbd> and an <kbd>init</kbd> function with receiver <kbd>T.() -&gt; Unit</kbd>. Internally, the <kbd>init</kbd> function is executed and the element is added as children.</p>
<p><kbd>Part</kbd> is annotated with an <kbd>@ElementMarker</kbd> annotation, that is itself annotated with <kbd>@DslMarker</kbd>. It prevents inner elements from reaching outer elements.</p>
<p>In this example, we can use <kbd>frame</kbd>:</p>
<pre>val commuter = bicycle {<br/>   description("Fast carbon commuter")<br/>   bar {<br/>      barType = FLAT<br/>      material = ALUMINIUM<br/>      frame {  } //compilation error<br/>   }</pre>
<p>It is still possible to do it explicitly with <kbd>this</kbd> qualified:</p>
<pre>val commuter = bicycle {<br/>   description("Fast carbon commuter")<br/>   bar {<br/>      barType = FLAT<br/>      material = ALUMINIUM<br/>      this@bicycle.frame{ }<br/>   }</pre>
<p>Now, several enumerations to describe materials, bar types, and brakes:</p>
<pre>enum class Material {<br/>   CARBON, STEEL, TITANIUM, ALUMINIUM<br/>}<br/><br/>enum class BarType {<br/>   DROP, FLAT, TT, BULLHORN<br/>}<br/><br/>enum class Brake {<br/>   RIM, DISK<br/>}</pre>
<p>Some of these parts have a <kbd>material</kbd> attribute:</p>
<pre>abstract class PartWithMaterial(name: String) : Part(name) {<br/>   var material: Material<br/>      get() = Material.valueOf(attributes["material"]!!)<br/>      set(value) {<br/>         attributes["material"] = value.name<br/>      }<br/>}</pre>
<p>We use a <kbd>material</kbd> property of type <kbd>Material</kbd> enumeration, and we store it inside the <kbd>attributes</kbd> map, transforming the value back and forth:</p>
<pre>class Bicycle : Part("bicycle") {<br/><br/>   fun description(description: String) {<br/>      attributes["description"] = description<br/>   }<br/><br/>   fun frame(init: Frame.() -&gt; Unit) = initElement(Frame(), init)<br/><br/>   fun fork(init: Fork.() -&gt; Unit) = initElement(Fork(), init)<br/><br/>   fun bar(init: Bar.() -&gt; Unit) = initElement(Bar(), init)<br/>}</pre>
<p><kbd>Bicycle</kbd> defines a <kbd>description</kbd> function and functions for <kbd>frame</kbd>, <kbd>fork</kbd>, and <kbd>bar</kbd>. Each function receives an <kbd>init</kbd> function that we pass directly to <kbd>initElement</kbd>.</p>
<p><kbd>Frame</kbd> has a function for the back wheel:</p>
<pre>class Frame : PartWithMaterial("frame") {<br/>   fun backWheel(init: Wheel.() -&gt; Unit) = initElement(Wheel(), init)<br/>}</pre>
<p><kbd>Wheel</kbd> has a property <kbd>brake</kbd> using the <kbd>Brake</kbd> enumeration:</p>
<pre>class Wheel : PartWithMaterial("wheel") {<br/>   var brake: Brake<br/>      get() = Brake.valueOf(attributes["brake"]!!)<br/>      set(value) {<br/>         attributes["brake"] = value.name<br/>      }<br/>}</pre>
<p><kbd>Bar</kbd> has a property for its type, using the <kbd>BarType</kbd> enumeration:</p>
<pre>class Bar : PartWithMaterial("bar") {<br/><br/>   var barType: BarType<br/>      get() = BarType.valueOf(attributes["type"]!!)<br/>      set(value) {<br/>         attributes["type"] = value.name<br/>      }<br/>}</pre>
<p><kbd>Fork</kbd> defines a function for the front wheel:</p>
<pre>class Fork : PartWithMaterial("fork") {<br/>   fun frontWheel(init: Wheel.() -&gt; Unit) = initElement(Wheel(), init)<br/>}</pre>
<p>We are close to the finish, the only thing that we need now is an entry function for our DSL:</p>
<pre>fun bicycle(init: Bicycle.() -&gt; Unit): Bicycle {<br/>   val cycle = Bicycle()<br/>   cycle.init()<br/>   return cycle<br/>}</pre>
<p>And that's all. DSLs in Kotlin with the <kbd>infix</kbd> functions, operator overloading, and type-safe builders are extremely powerful, and the Kotlin community is creating new and exciting libraries every day.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inline functions</h1>
                
            
            
                
<p>High-order functions are very useful and fancy, but they come with a caveat—performance penalties. Remember, from <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>, in the section, <em>First-class and high-order functions</em>, that on compilation time, a lambda gets translated into an object that is allocated, and we are calling its <kbd>invoke</kbd> operator; those operations consume CPU power and memory, regardless of how small they are.</p>
<p>A function like this:</p>
<pre>fun &lt;T&gt; time(body: () -&gt; T): Pair&lt;T, Long&gt; {<br/>   val startTime = System.nanoTime()<br/>   val v = body()<br/>   val endTime = System.nanoTime()<br/>   return v to endTime - startTime<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val (_,time) = time { Thread.sleep(1000) }<br/>   println("time = $time")<br/>}</pre>
<p>Once compiled, it will look like this:</p>
<pre>val (_, time) = time(object : Function0&lt;Unit&gt; {<br/>   override fun invoke() {<br/>      Thread.sleep(1000)<br/>   }<br/>})</pre>
<p>If performance is a priority for you (mission critical application, games, video streaming), you can mark a high-order function as <kbd>inline</kbd>:</p>
<pre>inline fun &lt;T&gt; inTime(body: () -&gt; T): Pair&lt;T, Long&gt; {<br/>   val startTime = System.nanoTime()<br/>   val v = body()<br/>   val endTime = System.nanoTime()<br/>   return v to endTime - startTime<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val (_, inTime) = inTime { Thread.sleep(1000) }<br/>   println("inTime = $inTime")<br/>}<br/><br/></pre>
<p>Once compiled, it will look like this:</p>
<pre>val startTime = System.nanoTime()<br/>val v = Thread.sleep(1000)<br/>val endTime = System.nanoTime()<br/>val (_, inTime) = (v to endTime - startTime)</pre>
<p>The whole function execution is replaced by the high-order function's body and the lambda's body. The <kbd>inline</kbd> functions are faster, albeit generating more bytecode:</p>
<div><img height="39" width="148" src="img/0dfad12f-a9ed-4580-9e9e-c085050fbfcf.png"/></div>
<p>2.3 milliseconds per execution doesn't look like a lot, but in the long run and with more optimizations, can create a noticeable compound effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inline restrictions</h1>
                
            
            
                
<p>Inline lambda functions have an important restriction—they can't be manipulated in any way (stored, copied, and others).</p>
<p>The <kbd>UserService</kbd> stores a list of listeners <kbd>(User) -&gt; Unit</kbd>:</p>
<pre>data class User(val name: String)<br/><br/>class UserService {<br/>   val listeners = mutableListOf&lt;(User) -&gt; Unit&gt;()<br/>   val users = mutableListOf&lt;User&gt;() <br/><br/>   fun addListener(listener: (User) -&gt; Unit) {<br/>      listeners += listener<br/>   }<br/>}</pre>
<p>  Changing <kbd>addListener</kbd> into an <kbd>inline</kbd> function will produce a compilation error:</p>
<pre>inline fun addListener(listener: (User) -&gt; Unit) {<br/>   listeners += listener //compilation error: Illegal use of inline-parameter listener<br/>}</pre>
<p>If you think about it, it makes sense. When we inline a lambda, we're replacing it for its body, and that isn't something that we can store on a <kbd>Map</kbd>.</p>
<p>We can fix this problem with the <kbd>noinline</kbd> modifier:</p>
<pre>//Warning: Expected performance impact of inlining addListener can be insignificant<br/>inline fun addListener(noinline listener: (User) -&gt; Unit) { <br/>   listeners += listener<br/>}</pre>
<p>Using <kbd>noinline</kbd> on an <kbd>inline</kbd> function will inline just the high-order function body but not the <kbd>noinline</kbd> lambda parameters (an <kbd>inline</kbd> high-order function can have both: <kbd>inline</kbd> and <kbd>noinline</kbd> lambdas). The resulting bytecode isn't as fast as a fully inline function, and the compiler will show a warning.</p>
<p>Inline lambda functions can't be used inside another execution context (local object, nested lambda).</p>
<p>In this example, we can't use <kbd>transform</kbd> inside the <kbd>buildUser</kbd> lambda:</p>
<pre>inline fun transformName(transform: (name: String) -&gt; String): List&lt;User&gt; {<br/><br/>   val buildUser = { name: String -&gt;<br/>      User(transform(name)) //compilation error: Can't inline transform here<br/>   }<br/><br/>   return users.map { user -&gt; buildUser(user.name) }<br/>}</pre>
<p>To fix this problem, we need a <kbd>crossinline</kbd> modifier (alternatively, we can use <kbd>noinline</kbd> but with the associated performance lost):</p>
<pre>inline fun transformName(crossinline transform: (name: String) -&gt; String): List&lt;User&gt; {<br/><br/>   val buildUser = { name: String -&gt;<br/>      User(transform(name)) <br/>   }<br/><br/>   return users.map { user -&gt; buildUser(user.name) }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val service = UserService()<br/>    <br/>   service.transformName(String::toLowerCase)<br/>}</pre>
<p>The generated code is quite complex. Many pieces are generated:</p>
<ul>
<li>A class that extends <kbd>(String) -&gt; User</kbd> to represent <kbd>buildUser</kbd> and internally creates <kbd>User</kbd> using <kbd>String::toLowerCase</kbd> to transform the name</li>
<li>A normal inline code to execute <kbd>List&lt;User&gt;.map()</kbd> using an instance of the class that represents <kbd>buildUser</kbd></li>
<li><kbd>List&lt;T&gt;.map()</kbd> is <kbd>inline</kbd>, so that code gets generated too</li>
</ul>
<p>Once you're aware of its restrictions, inline high-order functions are a great way to increase the execution speed of your code. Indeed, a lot of the high-order functions inside the Kotlin Standard Library are <kbd>inline</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Recursion and corecursion</h1>
                
            
            
                
<p>In <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>, in the section, <em>Recursion</em>, we cover recursion extensively (albeit there are recursion topics that are outside the scope of this book).</p>
<p>We used recursion to write classic algorithms such as Fibonacci (we're reusing <kbd>tailrecFib</kbd> from <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>):</p>
<pre>fun tailrecFib(n: Long): Long {<br/>   tailrec fun go(n: Long, prev: Long, cur: Long): Long {<br/>      return if (n == 0L) {<br/>         prev<br/>      } else {<br/>         go(n - 1, cur, prev + cur)<br/>      }<br/>   }<br/><br/>   return go(n, 0, 1)<br/>}</pre>
<p>And Factorial (same here, reusing <kbd>tailrecFactorial</kbd> from <a href="cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml">Chapter 2</a>, <em>Getting Started with Functional Programming</em>):</p>
<pre>fun tailrecFactorial(n: Long): Long {<br/>   tailrec fun go(n: Long, acc: Long): Long {<br/>      return if (n &lt;= 0) {<br/>         acc<br/>      } else {<br/>         go(n - 1, n * acc)<br/>      }<br/>   }<br/><br/>   return go(n, 1)<br/>}</pre>
<p>In both cases, we started with a number, and we reduced it to reach a base condition.</p>
<p>Another example that we looked at was <kbd>FunList</kbd>:</p>
<pre>sealed class FunList&lt;out T&gt; {<br/>   object Nil : FunList&lt;Nothing&gt;()<br/><br/>   data class Cons&lt;out T&gt;(val head: T, val tail: FunList&lt;T&gt;) : FunList&lt;T&gt;()<br/><br/>   fun forEach(f: (T) -&gt; Unit) {<br/>      tailrec fun go(list: FunList&lt;T&gt;, f: (T) -&gt; Unit) {<br/>         when (list) {<br/>            is Cons -&gt; {<br/>               f(list.head)<br/>               go(list.tail, f)<br/>            }<br/>            is Nil -&gt; Unit//Do nothing<br/>         }<br/>      }<br/><br/>      go(this, f)<br/>   }<br/><br/>   fun &lt;R&gt; fold(init: R, f: (R, T) -&gt; R): R {<br/>      tailrec fun go(list: FunList&lt;T&gt;, init: R, f: (R, T) -&gt; R): R = when (list) {<br/>         is Cons -&gt; go(list.tail, f(init, list.head), f)<br/>         is Nil -&gt; init<br/>      }<br/><br/>      return go(this, init, f)<br/>   }<br/><br/>   fun reverse(): FunList&lt;T&gt; = fold(Nil as FunList&lt;T&gt;) { acc, i -&gt; Cons(i, acc) }<br/><br/>   fun &lt;R&gt; foldRight(init: R, f: (R, T) -&gt; R): R = this.reverse().fold(init, f)<br/><br/>   fun &lt;R&gt; map(f:(T) -&gt; R): FunList&lt;R&gt; = foldRight(Nil as FunList&lt;R&gt;){ tail, head -&gt; Cons(f(head), tail) }<br/><br/>}</pre>
<p>The functions, <kbd>forEach</kbd> and <kbd>fold</kbd>, are recursive. Starting with the complete list, we reduce it until we reach the end (represented with a <kbd>Nil</kbd>), the base case. The other functions—<kbd>reverse</kbd>, <kbd>foldRight</kbd>, and <kbd>map</kbd> are just using <kbd>fold</kbd> with different variations.</p>
<p>So, on one hand, recursion takes a complex value and reduces it to the desired answer and on the other hand, corecursion takes a value and builds on top of it to produce a compound value (including potentially infinite data structures such as <kbd>Sequence&lt;T&gt;</kbd>).</p>
<p>As we use a <kbd>fold</kbd> function for recursive operations, we can use an <kbd>unfold</kbd> function:</p>
<pre>fun &lt;T, S&gt; unfold(s: S, f: (S) -&gt; Pair&lt;T, S&gt;?): Sequence&lt;T&gt; {<br/>   val result = f(s)<br/>   return if (result != null) {<br/>      sequenceOf(result.first) + unfold(result.second, f)<br/>   } else {<br/>      sequenceOf()<br/>   }<br/>}</pre>
<p>The <kbd>unfold</kbd> function takes two parameters, an initial <kbd>S</kbd> value that represents the starting or base step, and an <kbd>f</kbd> lambda that takes that <kbd>S</kbd> step and produces a <kbd>Pair&lt;T, S&gt;?</kbd> (a nullable <kbd>Pair</kbd>) of the <kbd>T</kbd> value to add to the sequence and the next <kbd>S</kbd> step. </p>
<p>If the result of <kbd>f(s)</kbd> is null, we return an empty sequence, else we create a single value sequence and add the result of <kbd>unfold</kbd> with the new step.</p>
<p>Using <kbd>unfold,</kbd> we can create a function that repeats a single element many times:</p>
<pre>fun &lt;T&gt; elements(element: T, numOfValues: Int): Sequence&lt;T&gt; {<br/>   return unfold(1) { i -&gt;<br/>      if (numOfValues &gt; i)<br/>         element to i + 1<br/>      else<br/>         null<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val strings = elements("Kotlin", 5)<br/>   strings.forEach(::println)<br/>}</pre>
<p>The <kbd>elements</kbd> function takes the element to repeat any number of values. Internally, it uses <kbd>unfold</kbd>, passing <kbd>1</kbd> as the initial step and a lambda that takes the current step and compares it with <kbd>numOfValues</kbd>, returning <kbd>Pair&lt;T, Int&gt;</kbd> with the same element and the current step <kbd>+ 1</kbd> or <kbd>null.</kbd></p>
<p>It is okay, but not very interesting. What about returning a Factorial sequence? We have you covered:</p>
<pre>fun factorial(size: Int): Sequence&lt;Long&gt; {<br/>   return sequenceOf(1L) + unfold(1L to 1) { (acc, n) -&gt;<br/>      if (size &gt; n) {<br/>         val x = n * acc<br/>         (x) to (x to n + 1)<br/>      } else<br/>         null<br/>   }<br/>}</pre>
<p>Same principle, the only difference is that our initial step is <kbd>Pair&lt;Long, Int&gt;</kbd> (the first element to carry the calculation and the second to evaluate against size) and therefore, our lambda should return <kbd>Pair&lt;Long, Pair&lt;Long, Int&gt;&gt;</kbd>.</p>
<p>Fibonacci will look similar:</p>
<pre>fun fib(size: Int): Sequence&lt;Long&gt; {<br/>   return sequenceOf(1L) + unfold(Triple(0L, 1L, 1)) { (cur, next&lt;/span&gt;, n) -&gt;<br/>      if (size &gt; n) {<br/>         val x = cur + next<br/>         (x) to Triple(next, x, n + 1)<br/>      }<br/>      else<br/>         null<br/>   }<br/>}</pre>
<p>Except that in this case, we use <kbd>Triple&lt;Long, Long, Int&gt;</kbd>.</p>
<p>The corecursive implementations to generate Factorial and Fibonacci sequences are a mirror of the recursive implementations to calculate a Factorial or a Fibonacci number, respectively—and some people can argue that is easier to understand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>With this chapter, we have already covered most of the Kotlin features for functional programming. We reviewed how to write shorter functions with single-expression functions, the different kind of parameters, how to extend our types with extension functions, and how to write natural and readable code with <kbd>infix</kbd> functions and operators. We also covered the basics of DSL authoring with type-safe builders and how to write efficient high-order functions. Last, but not least, we learned about recursion and corecursion.</p>
<p>In the next chapter, we will learn about Kotlin delegates. </p>
<p class="mce-root"/>


            

            
        
    </body></html>