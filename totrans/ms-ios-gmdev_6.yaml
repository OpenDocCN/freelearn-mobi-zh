- en: Chapter 6. Making Our Game More Efficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed quite a few debugging techniques, and there are a lot of them.
    Not all of them, however, help us when it comes to efficiency. What do we mean
    by efficiency? Your app can run great, but that doesn't mean it's going to cause
    the device to run great. Overheating, extreme battery drain, and other such things
    can ruin the gameplay experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let''s get an idea of what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing extreme battery drain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing lag (or at least minimizing it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a critical step in your game development, as you don't want people to
    complain and delete your app because it's too laggy (or causes the app to stutter
    because the device is having issues rendering the current scene) or it kills the
    battery.
  prefs: []
  type: TYPE_NORMAL
- en: I know you may have never experienced such an issue, but it happens more often
    than not.
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if you had downloaded a game that was extremely laggy and
    killed your battery after an hour of gameplay? You'd, no doubt, delete it off
    your phone or request a refund.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's dive into how we can optimize things!
  prefs: []
  type: TYPE_NORMAL
- en: Managing effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've been programming our game so far, we have been haphazardly creating
    without thinking about how our effects will run on older devices.
  prefs: []
  type: TYPE_NORMAL
- en: Have no fear! Because we can detect which device the player is using and adjust
    our particle effects and the number of enemies that will spawn on the screen at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, in our `GameLevelScene.m` file, we will add the following line of
    code at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This framework will allow us access to detecting the exact device we are working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just under the `@implementation` line, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to see which device appears, you can add the `deviceName()`
    function to the `NSLog` function in our init section, which would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, your log will now display the device on which you are running, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing effects](img/B03553_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not sure what **x86_64** means? In this case, because I am running off the simulator,
    **x86_64** will be displayed on a 64-bit iMac, or if you are running a 32-bit
    machine (for older Macs), you will see **i386**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a breakdown of what will appear for each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i386** on 32-bit Machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86_64** on 64-bit Machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPod1,1** on iPod Touch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPod2,1** on iPod Touch Second Generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPod3,1** on iPod Touch Third Generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPod4,1** on iPod Touch Fourth Generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone1,1** on iPhone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone1,2** on iPhone 3G'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone2,1** on iPhone 3GS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad1,1** on iPad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad2,1** on iPad 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad3,1** on 3rd Generation iPad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone3,1** on iPhone 4 (GSM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone3,3** on iPhone 4 (CDMA/Verizon/Sprint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone4,1** on iPhone 4s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone5,1** on iPhone 5 (model A1428, AT&T/Canada)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone5,2** on iPhone 5 (model A1429, everything else)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad3,4** on 4th Generation iPad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad2,5** on iPad Mini'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone5,3** on iPhone 5c (model A1456, A1532 | GSM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone5,4** on iPhone 5c (model A1507, A1516, A1526 (China), A1529 | Global)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone6,1** on iPhone 5s (model A1433, A1533 | GSM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone6,2** on iPhone 5s (model A1457, A1518, A1528 (China), A1530 | Global)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad4,1** on 5th Generation iPad (iPad Air) - Wifi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad4,2** on 5th Generation iPad (iPad Air) - Cellular'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad4,4** on 2nd Generation iPad Mini - Wifi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPad4,5** on 2nd Generation iPad Mini - Cellular'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone7,1** on iPhone 6 Plus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iPhone7,2** on iPhone 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretty extensive, isn't it? However, it will help when it comes to developing
    for all devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can begin setting up the functions to change our particle emission
    according to the device we are running. For example, as we saw in the previous
    screenshot, we are running **x86_64**, or in other words, a Mac computer. So,
    to test this function (while running our game via the simulator), in our `GameLevelScene.m`
    file, scroll down to the `- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent
    *)event` function and add this block of code just before the `[self addChild:rainEmitter];`
    function where we create our rain emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now play with the birthrate number to see what looks good and performs
    well. If you adjust the birthrate and test your project, you will see the particles
    adjust accordingly, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing effects](img/B03553_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, in the preceding image, the birth rate is set to `15,000`. While
    it does look like torrential downpours, the frame rate suffers considerably. Keep
    in mind that when I take a screenshot, the framerate does plummet quite a bit,
    but you get the idea that it was averaging about 25fps, because there was such
    an immense amount for the device to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we drop it down to `1500`, we see quite a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing effects](img/B03553_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It doesn't look as torrential as it did previously, but we see a major increase
    in the framerate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t want to crank down the rain? Let''s try adjusting the fire effects on
    the screen in the same way that we reduced the rain by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This drops the original birthrate that was set to `200` down to `100`. While
    a difference of 100 may seem like a huge number, and our particles won't look
    as good; it's just enough to reduce the lag and not affect the visual appeal of
    the flames themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Nice! A solid 60 fps *while* taking the screenshot! It looks pretty good too!
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing effects](img/B03553_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's keep in mind that this is set for the iOS simulator on our Mac, so
    you can even expect the app to run a little differently, but it does give you
    a great idea of how it will perform.
  prefs: []
  type: TYPE_NORMAL
- en: Hoping that we have already decided which devices we will support on our game,
    we will now add the functions to test the supported devices. For this example,
    I will only support the iPhone 4S and up, including the iPad 4th generation and
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that would be added to test these devices is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I know it's a lot to have to write and test as well. These numbers were all
    guesstimated, as I don't own all these devices. However, I did run test them on
    each simulator and all of them seemed to run at a solid framerate.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with an `if` statement to check which device we are running. If we
    do not detect the device checked, we use an `else if` statement. This will cause
    the code to check the next line for the device. When it finds the running device,
    it will adjust the birth rate accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same when it comes to the fire effects or any other effect that
    you have running in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also limit the amount of enemies being spawned simply by changing your
    update timer function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Simply adjusting the `if (self.lastSpawnTimeInterval > 2)` statement to a higher
    number will reduce the amount of enemies being spawned at a time, as we are increasing
    the time we will spawn a new enemy. So, the higher the interval, the longer it
    takes to spawn enemies.
  prefs: []
  type: TYPE_NORMAL
- en: By reducing these simple things, we will greatly improve the performance of
    the device, especially older ones that are getting tired and are unable to perform
    as they used to.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, better performance (the device not running so hard) equals extended
    battery life, extended play time, and happier customers.
  prefs: []
  type: TYPE_NORMAL
- en: There are a plethora of other ways in which we can optimize things; for example,
    as we mentioned earlier in this book, we can look at the sprites we created, and
    if they are large files, we can try saving other formats to save space and make
    it easier for the device to render them.
  prefs: []
  type: TYPE_NORMAL
- en: You've come here to master iOS development, and you want to learn everything!
    So, let me explain everything.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will discuss is how to prevent, or at least how to limit
    the amount our app runs in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Battery management – doing less in the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user isn't actively using your game/app, the device will place it into
    a background state. The device may eventually suspend the app if it's not performing
    important tasks, such as finishing a task the user initiated (for example, sending
    photos or updating a newsfeed) or running in a specially declared background execution
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: To save further battery life, your app shouldn't wait to be suspended by the
    device. It should begin pausing activity immediately once the app has notified
    that the state has changed (refer to the following image).
  prefs: []
  type: TYPE_NORMAL
- en: When your app completes any queued tasks, it should notify the device that the
    background activity is complete. Failing to do so causes the app to remain active
    and draw energy unnecessarily, unnecessarily, as can be summed up perfectly in
    the following image:.
  prefs: []
  type: TYPE_NORMAL
- en: '![Battery management – doing less in the background](img/B03553_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why don't the batteries last longer? It plagues us all...Well, yes, they are
    improving the battery usage with each new iPhone released, but they are adding
    more things in the OS that drains the battery, so you're not really getting anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Common Causes of Energy Wasted by Background Apps* section of *The Energy
    Efficiency Guide for iOS App* states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Apps performing unnecessary background activity (like music, Facebook or news
    apps constantly working in the background) waste energy. The following are the
    common causes of wasted energy in background refreshing apps:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not notifying the system when background activity is complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing silent audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing location updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Bluetooth accessories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are all things, regardless of whether you are creating a game or an app,
    that you should keep in mind when developing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notifying the system when background activity is complete**: For apps, if
    you are pulling information from a website, you will need to either pause it until
    the app resumes or set a refresh interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Playing silent audio**: For our games, again, when the app enters the background,
    the sounds and music need to be paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performing location updates**: Have you noticed that annoying arrow icon
    on the status bar? That equals battery drainage. When the app enters the background,
    turn location services off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interacting with Bluetooth accessories**: This applies for apps and games,
    especially for something as intensive as Bluetooth speakers or even a Bluetooth
    keyboard or gamepad. Ensure that Bluetooth disconnects and goes into a rest mode
    when the app goes into the background. Don''t forget to resume once the app reenters
    the foreground!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firstly, you can to scan for peripherals, such as bluetooth controllers, or
    other devices only when needed. To do this, use the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pretty easy stuff, eh? I know, this is a lot to take in. Trust me, though, this
    is all super important stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when you are finished with the Bluetooth device, simply use the following
    two methods to disconnect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How do you suspend activity when your app becomes inactive or moves to the background?
    Implementing the `UIApplicationDelegate` methods in your app delegate (if it hasn't
    been already, since our app already has this method in the `AppDelegate.m` file)
    will allow the device to receive notifications and suspend activity when your
    app becomes inactive or transitions from the foreground to the background.
  prefs: []
  type: TYPE_NORMAL
- en: The `applicationWillResignActive` method is called when the app enters an inactive
    state, such as when a telemarketer calls you to clean your ducts, a text comes
    in, or the player switches to another app and your app begins the transition to
    a background state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where you want to pause any activity, save data, and prepare for any
    suspension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, one big thing to keep in mind, is you don't want to rely strictly on saving
    data when the application enters the background. You always want to save data
    at proper points during the gameplay, such as at the end of the level. If you
    rely strictly on saving data during a state change, such as a level change, or
    the player pausing or exiting the game, the game won't save as reliably and the
    poor player could lose some information. For example, let's say you're playing
    your favourite game, but the game only saves when you finish 3 levels, you could
    lose important high score, or collected items. Plus the player wouldn't want to
    have to replay those completed levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another state, `applicationDidEnterBackground:` is called as soon as your app
    enters the background. With this method, you can stop operations, animations,
    and update methods immediately, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method is only called for a few seconds, so if the app requires more time
    to complete called requests, you would have to request more execution time using
    the `beginBackgroundTaskWithExpirationHandler:` method, which is to be called
    if extra time is required.
  prefs: []
  type: TYPE_NORMAL
- en: When the background tasks are completed, you will be required to call the `endBackgroundTask:`
    method to let the device know the tasks are finished. If you don't call the method,
    iOS will allow the app a little more time to complete any additional functions.
    If any saving or unloading methods don't complete in the additional time iOS provides,
    the app will be suspended.
  prefs: []
  type: TYPE_NORMAL
- en: To expand, if your app is still wrapping up any methods by the time your app
    enters the background and the app becomes suspended, all the important performance
    tweaks, save game, will not occur. Potentially ruining the user's experience.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have talked about what to do when the app enters the background,
    it's time to talk about what to do (or how to do it) when the app resumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two methods that will allow us to call any reconnection methods that
    we may have disconnected, such as Bluetooth devices, location services, and many
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called immediately before the app transitions from the background
    to active. Start resuming operations, loading data, reinitializing the User Interface,
    and getting your app ready for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ApplicationDidBecomeActive` function is called immediately after the app
    becomes an active app after being launched by the device or transitioning from
    a background or inactive state. Essentially, we are fully resuming any operations
    that were halted.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are a few great things to keep in mind when developing timers,
    Bluetooth connections, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind, is avoiding extreme graphics and animations.
    As you have seen in our game, we haven't used any intensive animations. Instead,
    a majority of our characters have two to four images per animation.
  prefs: []
  type: TYPE_NORMAL
- en: If your app uses only the standard windows and controls, such as an app like
    notes, you don't really need to worry about updates to your content, as the system
    APIs are created with maximum efficiency in mind.
  prefs: []
  type: TYPE_NORMAL
- en: If you have custom windows and controls, let's say **Shazam** for example, you
    really have to ensure that the code in which you draw everything is efficient.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you don't want to be refreshing everything on the screen all the
    time, especially items that are hidden, or even by going overkill on your animations.
    I know they look good, but they do waste battery life.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that every time an app draws images and text to the screen, it
    requires CPU usage, GPU usage, and the screen needs to be active. Ergo, the more
    you are displaying and refreshing, the more the battery will drain, hence why
    certain apps murder battery life.
  prefs: []
  type: TYPE_NORMAL
- en: So you should be mindful of over updating or even inefficient content drawing,
    as it will draw significant power from the battery.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some more things to keep in mind. You should always reduce the number
    of views that are in the app (all of which will be drawing power from the battery).
  prefs: []
  type: TYPE_NORMAL
- en: If you can help it at all, which I know isn't always possible, you should tune
    down the number of onscreen effects you use, such as opacity, transparency, and
    so on. If effects are needed, you should avoid using them on items that refresh
    frequently, as this will again draw battery power because both the opacity objects
    and the content underneath need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: In regards to animations, use a maximum of 60fps per animation, anything faster
    will be troublesome when rendering, as it will require more CPU/GPU to boost the
    framerate. Also, try to keep all your animation speeds at the same frame rate
    so the engine isn't struggling to render your character at 60fps and an enemy
    at 30fps, for example. While having extra frames in the animation may look great,
    those extra frames are inefficient and will require extra computing, which you
    guessed it, equals more battery drainage.
  prefs: []
  type: TYPE_NORMAL
- en: It's even recommended to only use SpriteKit, SceneKit, and Metal when developing
    games, as these frameworks are made to give you the best performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean that you can't use a framework, such as Cocos2d. Cocos2D is
    actually built on top of the SpriteKit framework and is just as easy to use and
    just as powerful.
  prefs: []
  type: TYPE_NORMAL
- en: When testing your app, keep a keen eye set on the debugging tools we discussed
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Watch out for these signs:'
  prefs: []
  type: TYPE_NORMAL
- en: Battery drain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity when you expect your app to be idle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An unresponsive or slow user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large amounts of work on the main thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High use of animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High use of view opacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory stalls and cache misses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock contention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive context switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive use of timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive drawing to screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive or repeated small disk I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-overhead communication, such as network activity with small packets and
    buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing device sleep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we didn't look at measuring the energy usage with Instruments
    in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Instruments provide us with a graphical timeline of the usage on our device.
    You will be able to gather info about the app's CPU usage, network usage, disk
    usage, and the graphic usage.
  prefs: []
  type: TYPE_NORMAL
- en: By viewing this timeline, you will be able to analyze the performance of your
    app, and glean certain points in your app which may be causing lag, slow downs,
    or potential drops in frame rate so you can make adjustments at those exact moments.
  prefs: []
  type: TYPE_NORMAL
- en: To access these energy diagnostics, launch Instruments, connect it to your app,
    and then click on the **Energy Diagnostics** template.
  prefs: []
  type: TYPE_NORMAL
- en: The **Energy Diagnostics** template monitors factors that affect energy usage
    on an iOS device, as mentioned earlier, including the CPU and network activity,
    screen brightness, and much more. Then, you can see the areas in which the usage
    is highest, and check whether you can reduce the impact in those areas. For example,
    you might find an opportunity to defer certain Bluetooth tasks until more energy-efficient
    times, such as when the device is plugged in or connected to Wi-Fi.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s all discretionary; as you start to play with the debugging Instruments,
    you will see what works for you and when is the best time to use certain methods.
    As you can see by the following image, there are so many excellent tools at your
    disposal to make your app the most efficient app possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Battery management – doing less in the background](img/B03553_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With our fantastic game running, click on **Choose a profiling template for**
    and select the device you are running on (which is the only way you can test battery
    usage), then select your app.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the **Energy Diagnostics** profile template. Then, at the top
    of the new window that pops up, click on the red record button to begin recording
    our energy usage. Play your game as you normally would. Don't worry, **Instruments**
    will be recording all your data as you play, so you can focus on looking for bugs
    while recording your energy usage.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: When you have completed testing, simply click on the **Stop** button or press
    *Command* + *R* to stop recording.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will have a complete log of all the data that was recorded. Scroll
    through and check whether there are any spikes in the log. If so, go back and
    check the code in those areas where there was a spike to check whether there is
    an issue causing the spike.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, the energy usage template shows readings from 0-20 which will
    indicate how much your app is using the energy at that time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Battery management – doing less in the background](img/B03553_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If, let's say you have some awesome particles flying around, and you are connected
    to a Bluetooth device during gameplay, you will no doubt see that your energy
    usage is high all the time. This doesn't mean that your app has an issue. It just
    means your app requires more power to run everything you've implemented.
  prefs: []
  type: TYPE_NORMAL
- en: I'll take a certain app I use on a regular basis as an example. The app is from
    a website loaded with some cool and funny photos. Anyways, when I use this app,
    my phone heats up within minutes and the battery level starts to plummet. Does
    this mean something is wrong with the app? No! Especially not when you start to
    figure what the app is doing as you are using it.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the app need to load photos from the server, but it uses your
    Wi-Fi and location services and shows ads—all this while keeping you logged in
    to their website so that you can make comments on the photos.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this does not equate to the ideal user experience, but if you want access
    photos, you need to expect this type of performance. So don't worry if your device
    gets warm or the battery drains a little bit—this is a normal byproduct of device
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Don't have access to your computer and need to log energy? Log the usage right
    on your device!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have already connected your device to Xcode, you will now have access
    to developer options on your device, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Battery management – doing less in the background](img/B03553_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this option, you can select **Logging** under the **Instruments** section,
    then click on **Energy** to enable logging, and then click on the **Start Recording**
    button to begin logging your energy usage, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Battery management – doing less in the background](img/B03553_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, use your app the same way you normally would, and **Instruments** will
    log the data for you as your play.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, go back to this setting. You will see that the **Start Recording**
    button has now changed to **Stop Recording**. Simply click on **Stop Recording**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back in Xcode Instruments, in the **Energy Diagnostics** option, navigate
    to **File** | **Import Logged Data from Device**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will be greeted with the same data log as you would if you ran the
    test directly in Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Whew! That's a lot to consider!
  prefs: []
  type: TYPE_NORMAL
- en: I know I've been talking a lot, it's all extremely important information.
  prefs: []
  type: TYPE_NORMAL
- en: As I've been testing the app, everything ran just perfectly. In fact, the only
    issued that seemed to bog the device down at all were the particles! And we managed
    to fix that programmatically by checking what device we are running and then adjusting
    our crazy particles accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed a lot in this chapter, a lot of which was best practices on
    how to manage your device's performance and battery drainage.
  prefs: []
  type: TYPE_NORMAL
- en: You are now well prepared to tackle the testing process and ensure that your
    device is running as efficiently as possible so that no customers return your
    app or give you low ratings because of how terribly your app affects their device.
  prefs: []
  type: TYPE_NORMAL
- en: Get excited for the next chapter boys and girls! We will talk about the awesomeness
    that is deploying your app and monetizing it so that you can make bajillions of
    dollars! Well, maybe not, but at least enough to pay for your developer cost would
    be OK.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready because now is the time when it gets fun, and you get to see all your
    hard work come together.
  prefs: []
  type: TYPE_NORMAL
- en: I'll see you in the next chapter my friends!
  prefs: []
  type: TYPE_NORMAL
