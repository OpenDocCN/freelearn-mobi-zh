- en: Chapter 6. Parsing Networked Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many iOS applications need to communicate with other servers or devices. This
    chapter presents both HTTP and non-HTTP networking in Swift, and how data can
    be parsed from either JSON or XML. It first demonstrates how to load data efficiently
    from URLs, followed by how to stream larger data responses. It then concludes
    with how to perform both synchronous and asynchronous network requests over protocols
    other than HTTP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from URLs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the user interface from a background thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON and XML data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream-based connections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous data communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data from URLs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to load data from a remote network source is to use an HTTP
    (or HTTPS) URL of the form [https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json](https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: URLs can be manipulated with the `NSURL` class, which comes from the `Foundation`
    module (which is transitively imported from the `UIKit` module). The main `NSURL`
    initializer takes a `String` initializer with a full URL, although other initializers
    exist to create relative URLs or for references to file paths.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The `NSURLSession` class is typically used to perform operations with URLs,
    and individual sessions can be created through the initializer or the standard
    **shared session** can be used. The `NSURLConnection` class was used in older
    versions of iOS and Mac OS X. References to this class can still be seen in some
    tutorials, or may be required if Mac OS X 10.8 or iOS 6 needs to be supported;
    otherwise, the `NSURLSession` class should be preferred.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSURLSession` class provides a means to create tasks. These include:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Data task:** This can be used to process network data programmatically'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upload task:** This can be used to upload data to a remote server'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download task:** This can be used to download to local storage or to resume
    a previous or partial download'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks are created from the `NSURLSession` class methods, and can take a URL
    argument and an optional *completion handler*. A completion handler is a lot like
    a delegate, except that it can be customized per task, and it is usually represented
    as a function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tasks can be *suspended* or *resumed* to stop and start the process. Tasks are
    created in a suspended state by default, and so they have to be initially resumed
    to start processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'When a data task completes, the completion handler is called back with three
    arguments: an `NSData` object that represents the returned data, an `NSURLResponse`
    object that represents the response from the remote URL server, and an optional
    `NSError` object if anything failed during the request.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, the `SampleTable` that was created in the previous chapter
    can load data from a network URL by obtaining a session, initiating a data task,
    and then resuming it. The completion handler will get called when the data is
    available, which can be used to add the content to the table.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `viewDidLoad` method of the `SampleTable` class to load the `SampleTable.json`
    file by adding the following to the end of the method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates an `NSURL` and an `NSURLSession`, and then creates a data, task
    and immediately resumes it. After the content is downloaded, the completion handler
    is called, which passes the data as an `NSData` object. The `String` initializer
    is used to decode `UTF8` text from the `NSData` object, and is explicitly cast
    to a `String` so that it can be added to the `items` array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NSURLSession` class also provides other factory methods, including one
    that takes a configuration argument that includes options, such as whether responses
    should be cached, whether network connections should go over the cellular network,
    and whether any cookies or other headers should be sent with the task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the item is added to the `items` and the `tableView` is reloaded to
    show the new data. Please note that this does not work immediately if it is not
    run on the main UI thread; the table has to be rotated or moved in order to redraw
    the display. Running on the UI thread is covered in the *Networking and user interface*
    section later in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Errors are a fact of life, especially on mobile devices with intermittent connectivity.
    The completion handler is called with a third argument, which represents any error
    raised during the operation. If this is `nil`, then the operation was a success;
    if not, then the `localizedDescription` property of the `error` can be used to
    notify the user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing purposes, if an error is detected add the `localizedDescription`
    to the `items` in the list. Modify the `viewDidLoad` method as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An error can be simulated using a nonexistent hostname or an unknown protocol
    in the URL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing content
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Errors are reported if the remote server cannot be contacted, such as when the
    hostname is incorrect or the server is down. If the server is operational, then
    an error will not be reported; but it is still possible that the file that is
    requested will not be found, or that the server will experience an error while
    serving the request. These are reported with HTTP status codes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an HTTP URL is not found, the server sends back a `404` status code. This
    can be used by the client to determine whether a different file should be accessed
    or whether another server should be queried. For example, browsers will often
    ask the server for a `favicon.ico` file and use this to display a small logo;
    if this file is missing, then a generic page icon is displayed instead. In general,
    `4xx` responses are client errors, while `5xx` responses are server errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSURLResponse` object doesn''t have the concept of an HTTP status code,
    because it can be used for any protocol, including `ftp`. However, if the request
    used HTTP, then the response is likely to be HTTP and so it can be cast to an
    `NSURLHttpResponse`, which has a `statusCode` property. This can be used to provide
    more specific feedback when the file is not found. Modify the code as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if the server responds but indicates that either the client made a bad
    request or the server suffered a problem, the user interface will be updated appropriately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Nested if and switch statements
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the error handling logic can get convoluted with handling different
    cases, particularly if there are different values that need to be tested. In the
    previous section, both the `NSError` and HTTP `statusCode` needed to be checked.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to use a `switch` statement with `where` clauses.
    These can be used to test multiple different conditions and also show which part
    of the condition is being tested. Although a `switch` statement requires a single
    expression, it is possible to use a *tuple* to group multiple values into a single
    expression.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using a tuple is that it permits the cases to be matched
    on types. In the networking case, some URLs are based on `http` or `https`, which
    means that the response will be an `NSHTTPURLResponse` type. However, if the URL
    is a different type (such as a `file` or `ftp` protocol), then it will be of a
    different subtype of `NSURLResponse`. Unconditionally casting to `NSHTTPURLResponse`
    with `as` will fail in these cases and cause a crash.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests can be rewritten as a `switch` block as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the `default` block is used to execute the success condition,
    and the prior `case` statements are used to match the error conditions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The `case (_,_,let e) where e != nil` case is an example of a *conditional pattern
    match*. The underscore, which is called a *wildcard pattern* in Swift (also known
    as a **hole** in other languages), is something that will match any value. The
    third parameter, `let e`, is a *value binding pattern*, and has the effect of
    `let e = error` in this case. Finally, the `where` clause adds the test to ensure
    this case only occurs when `e` is not `nil`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be possible to use the identifier `error` instead of `let e` in the
    `case` statement, using `case (_,_,_) where error != nil` would have had the same
    effect. However, it is bad practice to capture values outside of the `switch`
    statement for case matching purposes because if the `error` variable is renamed,
    then the `case` statement may become invalid. Generally, use `let` patterns inside
    `case` statements to ensure that the correct expression value is being matched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The second and third cases perform both a `let` assignment and a type test/conversion.
    When `case (_,let r as NSHTTPURLResponse,_)` is matched, not only is the value
    of that part in the tuple assigned the constant `r`, but it is also cast to an
    `NSHTTPURLRepsonse`. If the value is not of type `NSHTTPURLResponse`, then the
    case statement is automatically skipped. This is equivalent to an `if` test with
    an `is` expression followed by a cast with `as`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第三个情况同时执行一个`let`赋值和一个类型测试/转换。当`case (_,let r as NSHTTPURLResponse,_)`匹配时，不仅元组中该部分的值被赋给常量`r`，它还被转换为`NSHTTPURLResponse`类型。如果该值不是`NSHTTPURLResponse`类型，则自动跳过该情况语句。这相当于一个带有`is`表达式的`if`测试，后面跟着一个使用`as`的转换。
- en: Although the patterns are the same in both, the `where` clauses are different.
    The first `where` clause looks for the case where `r.statusCode` is 400 or greater
    and less than 500, while the second is matched where `r.statusCode` is 500 or
    greater.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种模式相同，但`where`子句不同。第一个`where`子句寻找`r.statusCode`为400或更大但小于500的情况，而第二个匹配的是`r.statusCode`为500或更大的情况。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whether nested `if` statements or the `switch` statement is used, the code that
    performs the test is likely to be very similar. It typically comes down to developer
    preference, but more developers are likely to be familiar with nested `if` statements.
    In Swift, the `switch` statement is more powerful than in other languages, and
    so, this kind of pattern is likely to become more popular.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用嵌套的`if`语句还是`switch`语句，执行测试的代码可能非常相似。这通常取决于开发者的偏好，但更多的开发者可能更熟悉嵌套的`if`语句。在Swift中，`switch`语句比其他语言更强大，因此这种模式可能变得更加流行。
- en: 'An alternative with Swift 2 is to use the `guard` statement to ensure that
    if certain error conditions occur, then appropriate action can be taken instead.
    The `guard` statement is like an `if` statement where there is no `true` block
    and the `false` block must always leave the function. For example, the code could
    be rewritten as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 2中，可以使用`guard`语句来确保如果发生某些错误条件，可以采取适当的行动。`guard`语句类似于`if`语句，但没有`true`块，并且`false`块必须始终离开函数。例如，代码可以被重写为：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that the `guard` block must exit the calling function; so, if additional
    operations are required, either the body of the implementation must be moved to
    a different function or the `switch` or `if` blocks used instead. The examples
    later in this chapter assume the use of the `if` blocks for simplicity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`guard`块必须退出调用函数；因此，如果需要额外的操作，要么将实现体的主体移动到不同的函数中，要么使用`switch`或`if`块。本章后面的示例假设使用`if`块以保持简单。
- en: Networking and user interfaces
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和用户界面
- en: One outstanding problem with the current callback approach is that the callback
    cannot be guaranteed to be called from the *main thread*. As a result, user interface
    operations may not work correctly or throw errors. The right solution is to set
    up another call using the main thread.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当前回调方法的一个突出问题是无法保证回调函数一定会在*主线程*中被调用。因此，用户界面操作可能无法正确执行或引发错误。正确的解决方案是使用主线程设置另一个调用。
- en: 'Accessing the main thread in Swift is done in the same way as it is in Objective-C:
    using **Grand Central Dispatch** (**GCD**). The *main queue* can be accessed with
    `dispatch_get_main_queue`, which is used by the thread that all UI updates should
    use. Background tasks are submitted with `dispatch_async` to a queue. To invoke
    the `reloadData` call on the main thread, wrap it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中访问主线程的方式与在Objective-C中相同：使用**Grand Central Dispatch**（**GCD**）。可以使用`dispatch_get_main_queue`访问*主队列*，这是所有UI更新应使用的线程。后台任务通过`dispatch_async`提交到队列。要在主线程上调用`reloadData`，可以这样包装：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This style of call will be valid for both Objective-C and Swift (although Objective-C
    uses the ^ (caret) as a block prefix). However, Swift has a special syntax for
    functions that take blocks; the block can be promoted out of the function''s argument
    and left as a trailing argument. This is known as a *trailing closure*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用方式对Objective-C和Swift都有效（尽管Objective-C使用^（尖括号）作为块前缀）。然而，Swift为接受块的函数有特殊的语法；块可以被提升出函数的参数，并作为尾随参数留下。这被称为*尾随闭包*：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although this is a minor difference, it makes it look like `dispatch_async`
    is more like a keyword, such as `if` or `switch`, which takes a block of code.
    This can be used for any function whose final argument is a function; there is
    no special syntax needed in the function definition. Additionally, the same technique
    works for functions that are defined outside of Swift; in the case of `dispatch_async`,
    the function is defined as a C-language function and can be transparently used
    in a portable way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Running functions on the main thread
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the UI needs to be updated, the update must be run on the main thread.
    This can be done using the previous pattern to perform updates as they will always
    be threaded. However, it can be a pain to remember to do this each time it is
    required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to build a Swift function that takes another function and runs
    it on the main thread automatically. `NSThread.isMainThread` can be used to determine
    whether the current thread is the UI thread or not; so to run a block of code
    on the main thread, regardless of whether it''s on the main thread or not, the
    following can be used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This allows code to be submitted to the background thread using:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the lack of parenthesis, the `reloadData` function is not called, but
    it is passed in as a function pointer. It is dispatched to the correct thread
    inside the `runOnUIThread` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is more than one function that needs to be called, an inline block
    can be created. As this can be passed as a trailing closure to the `runOnUIThread`
    method, the parenthesis are optional:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Parsing JSON
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular mechanism to send structured data over a network is to encode
    it in **JSON**, which stands for **JavaScript Object Notation**. This provides
    a hierarchical tree data structure, which can store simple numeric, logical, and
    string-based types, along with array and dictionary representations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Both Mac OS X and iOS come with a built-in parser for JSON documents, in the
    `NSJSONSerialization` class. This provides a means to parse a data object and
    return an `NSDictionary` that contains the key/value pairs of a JSON object, or
    an `NSArray` to represent JSON arrays. Other literals are parsed and are represented
    as either `NSNumber` or `NSString` values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The JSON parser uses `JSONObjectWithData` to create an object from an `NSData`
    object containing a string. This is typically the format that is returned by network
    APIs, and it can be created from an existing string using `dataUsingEncoding`
    with one of the built-in encoding types, such as `NSUTF8StringEncoding`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JSON array of numbers can be parsed as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The return type of this is an optional `AnyObject`. The optionality represents
    the fact that the data content may not be valid JSON data. This can be cast to
    an appropriate type using the `as` keyword; if there is a parsing failure, then
    an error will be thrown.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `options` can be used to indicate whether the return type should be mutable
    or not. Mutable data allows the caller to add or delete items after being returned
    from the parsing function; if not specified, the return value will be immutable.
    The `NSJSONReadingOptions` options include `MutableContainers` (containing data
    structures are mutable), `MutableLeaves` (the child leaves are mutable), and `AllowFragments`
    (allow nonobject, non-array values to be parsed).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SampleTable.json` file (referred to in the `viewDidLoad` method) stores
    an array of entries, with `title` and `content` fields holding text data per entry:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To parse the JSON file and entries to the table, replace the `default` clause
    in the `SampleTable` with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the application will show the **Sample Title** and **Sample Content**
    entries in the table, which have been loaded and parsed from the book's GitHub
    repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there are problems parsing the JSON data then the return type of the `try?
    JSONObjectWithData` function will return a `nil` value. If the type is implicitly
    unwrapped, then accessing the element will cause an error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `parsed` value will be of type `AnyObject?` although the `let` block will
    implicitly unwrap the value, known as *optional binding*. In the previous section,
    the code was cast to an `NSArray` directly, but if the returned result contains
    different types (for example, an `NSDictionary` or one of the fragment types `NSNumber`
    or `NSString`), then attempting to cast to a type that is incompatible with the
    runtime type will cause a failure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the object can be tested with `if [object] is [type]`. However,
    as the next step is usually to cast it to a different class with `as`, a shorthand
    form `as?` can perform both the test and the cast in one step:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A `switch` statement can be used to check the type of multiple values at the
    same time. As the values are optional `AnyObject` objects, they need to be converted
    to a `String` before they can be used in Swift:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now when the application is run, any errors are detected and handled without
    the application crashing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although JSON is more commonly used, there are still many XML-based network
    services. Fortunately XML parsing has existed in iOS since version 5 in the `NSXMLParser`
    class and is simple to access from Swift. For example, some data feeds (such as
    blog posts) use XML documents, such as Atom or RSS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSXMLParser` is a stream-oriented parser; that is, it reports individual
    elements as they are seen. The parser calls the `delegate` to notify when elements
    are seen and have finished. When an element is seen, the parser also includes
    any attributes that were present; and for text nodes, the string content. Parsing
    an XML file involves some state management in the parser. The example used in
    this section will be to parse an Atom (news feed) file, whose (simplified) structure
    looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the goal is to extract all the `entry` elements from the feed,
    specifically the `title` and the `link`. This presents a few challenges that will
    become apparent later on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Creating a parser delegate
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing an XML file requires creating a class that conforms to the `NSXMLParserDelegate`
    protocol. To do this, create a new class, `FeedParser`, that extends `NSObject`
    and conforms to the `NSXMLParserDelegate` protocol.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'It should have an `init` method that takes an `NSData`, and an `items` property
    that will be used to acquire the results after they have been parsed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NSXMLParserDelegate` protocol requires that the object also conform to
    the `NSObjectProtocol`. The easiest way to do this is to subclass `NSObject`.
    The first mentioned super type is the super class; the second and subsequent super
    types must be protocols.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the data
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The XML parser can either parse a stream of data as it is downloaded, or it
    can take an `NSData` object that has been downloaded previously. On successful
    download, the `FeedParser` can be used to parse the `NSData` instance and return
    the list of items.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Although individual expressions can be assigned temporary values that are similar
    to last time, the statement can be written in a single line (although please note
    that the error handling is not present). Add the following to the end of the `viewDidLoad`
    method of `SampleTable`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will download the Atom XML feed for the Swift posts from the author's blog
    at [https://alblue.bandlem.com](https://alblue.bandlem.com). Currently, the data
    is not parsed, so nothing will be added to the table in this step.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that both the download operation and the parsing are handled off the
    main thread as both of these operations may take some time. Once the data is downloaded,
    it can be parsed, and after it is parsed, the UI can be notified to redisplay
    the contents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the data
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To process the downloaded XML file, it is necessary to parse the data. This
    involves writing a parser delegate to listen for the `title` and `link` elements.
    However, the `title` and `link` elements exist both at the individual `entry`
    level and also at the top level of the blog. It is therefore necessary to represent
    some kind of state in the parser, which detects when the parser is inside an `entry`
    element to allow the correct values to be used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements are reported with the `parser:didStartElement:` method and the `parser:didEndElement:`
    method. This can be used to determine if the parser is inside an `entry` element
    by setting a boolean value when an `entry` element starts and resetting it when
    the `entry` element ends. Add the following to the `FeedParser` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `link` stores the value of the references in an `href` attribute of the
    element. This is passed when the start element is called, so it is trivial to
    store. At this point, the title may not be known, so the value of the `link` has
    to be stored in an optional field:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `title` stores its data as a text node, which needs to be implemented with
    another boolean flag indicating whether the parser is inside a `title` node. Text
    nodes are reported with the `parser:foundCharacters:` delegate method. Add the
    following to the `FeedParser`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By storing the `title` and `link` as optional fields when the end of the `entry`
    element is seen, the fields can be appended into the `items` list, followed by
    resetting the state of the parser:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, having implemented the callback methods, the remaining steps are to
    create an `NSXMLParser` from the data passed in previously, set the `delegate`
    (and optionally, the namespace handling), and then invoke the parser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assignment of `self` to the `delegate` cannot be done until after `super.init`
    has been called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Now when the application is run, a set of news feed items will be displayed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If running on iOS 9 targets and downloading from http sites, a **App Transport
    Security has blocked a cleartext HTTP resource load** message may be seen in the
    console. The solution to fix this is to add an exception in the `Info.plist` file,
    which permits connections via HTTP, either for the explicit domain or for all
    domains. Add the following to the `Info.plist` after the first `<dict>` element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now when the application is run, the error should no longer be seen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Direct network connections
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although most application networking will involve downloading content over standard
    protocols, such as HTTP(S), and using standard representations, there are times
    when having a specific data stream protocol is required. In this case, a *stream*-oriented
    process will allow individual bytes to be read or written, or a *datagram* or
    *packet*-oriented process can be used to send individual packets of data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: There are networking libraries to support both; an `NSStream` higher-level Objective-C
    based class provides a mechanism to drive stream-based responses, and although
    lower-level packet connections are possible with the `CoreFoundation` or the `POSIX`
    layer, local multiplayer gaming using the `MultipeerConnectivity` module is often
    appropriate.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Local networking with the `MultipeerConnectivity` module involves creating an
    `MCSession`, followed by `sendData` to send `NSData` objects to connected peers,
    and using the `MCSessionDelegate` to `receiveData` from connected peers. This
    is often used to synchronize the state of the world, such as the player's current
    location or health.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Opening a stream-based connection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream is a reliable, ordered sequence of bytes, which is used by most internet
    protocols. Streams can be created from a network host and port using the `NSStream`
    class method `getStreamsToHostWithName`. This allows an `NSInputStream` and `NSOutputStream`
    to be acquired at the same time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this is an existing Objective-C API, the streams are returned via *inout
    parameters*. In Swift, this translates to the parameters being passed back with
    an ampersand (`&`) and declaring the variables as optional.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The input and output streams can then be used to send data asynchronously or
    synchronously. Asynchronous mechanisms involve scheduling the data processing
    on the application's run-loop and is covered in the *Asynchronous reading and
    writing* section. Synchronous mechanisms use `read` and `write` to receive or
    send buffers of data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the streams have been acquired, they need to be *open* to receive or send
    data. Forgetting this step will result in no networking data being sent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify acquiring the streams, the following can be created as an extension
    of the `NSStream` class. An extension makes a method appear to come from an original
    class but is implemented externally to that class. Add a `StreamExtensions.swift`
    file to the `CustomViews` project with the following content:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A connection to a remote host can be obtained by calling `NSStream.open(host,port)`,
    which returns an open pair of input/output streams.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous reading and writing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSInputStream` method `read` allows bytes to be read from a stream synchronously,
    while the `NSOutputStream` method `write` allows bytes to be written to a stream.
    These take different types, but the most common approach is to create an array
    of bytes `[UInt8]` in Swift as the buffer, and then read into or out of it with
    an `UnsafeMutablePointer` (equivalent to an ampersand in C).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The `read` and `write` methods both return a number of bytes read/written. This
    can be negative (in the case of an error), zero, or positive in the case of bytes
    having been processed. Both calls take a buffer and a maximum length, though it
    is not guaranteed that the full maximum length will be processed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check the return value of `write` or `read` as it is possible that only
    part of the buffer has been written. Best practice (for synchronous connections)
    is to wrap the call in a `while` loop or have some other form of `retry` in order
    to ensure that all the data is written.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to NSOutputStream
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make it easier to write `NSData` content to streams, an extension method
    on `NSOuptutStream` can be created that performs a full write, based on the size
    of the data:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code takes an `NSData` and writes it to the underlying stream, returning
    the number of bytes written (or a negative value if there are problems). The return
    value of the `write` method is checked, and if the value is negative, it is returned
    to the caller directly. Otherwise, the `completed` counter is incremented with
    the number of bytes written.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If the number of written bytes reaches the size of the data requested, then
    the value is returned. Otherwise the loop recurs, this time starting at the point
    where it left off.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although uncommon in Swift, pointer arithmetic is possible by acquiring an `UnsafePointer`
    to the `data.bytes` array, and then incrementing it by the number of bytes already
    written. The length of the remaining bytes is calculated with `size-completed`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Reading from an NSInputStream
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A similar approach can be used to read a full buffer from an `NSInputStream`
    by creating a `readBytes` method that returns an array of bytes of a known size,
    and a means to convert this to an `NSData` for easier processing/parsing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `readData` method returns an `NSData`, while the `readBytes` method returns
    an array of `UInt8` values. The `NSData` approach is useful in some cases (particularly,
    creating a `String` from the returned data), and in other cases, being able to
    process the bytes directly is useful (for example, parsing binary formats). Having
    both allows either to be used as appropriate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Synchronous reads can block forever; if the client application requests exactly
    10 bytes but the server only sends 9 bytes, then it will hang permanently until
    the tenth byte is sent. It is best practice to use asynchronous reads, which cannot
    block in this way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing hexadecimal and UTF8 data
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being able to process data as UTF8 values or hexadecimal values can be useful
    in some protocols. Although both `NSString` and `NSData` provide means to convert
    to and from UTF8, the syntax is overly verbose as it is based on pre-existing
    Objective-C methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate the conversions, extension methods can be created to provide
    a simple way of converting to and from UTF8 representations. In addition to class
    and instance functions, it is possible to use extensions to add dynamic properties
    to an existing object. This can be used to create `utf8data` and `utf8string`
    properties on `NSData` and `String` by adding extensions in a file `Extensions.swift`,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This allows expressions, such as `data.utf8string` and `string.utf8data`, which
    are much more compact. Each time the expression is evaluated, the associated getter
    function will be called.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no standard convention to name extensions in Swift at the time this
    book was written. If there are extensions to a single type of data—such as the
    streams previously—then the file can be named `[Type]Extensions.swift`. Alternatively,
    the name can be used for the type of methods that are called; for example, in
    this case, `UTF8Extensions.swift` could have been used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing hexadecimal data from strings and integers can also be added to the
    `String` and `Int` types, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This allows hex values to be created with `int.toHex` and `string.fromHex`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Git protocol
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to write a client to query a remote git server using the `git://`
    protocol to determine the hashes of remote tags/branches/references.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git://` protocol works by sending *packet lines* of data with each line
    prefixed with four hexadecimal digits in ASCII, indicating the length of the rest
    of the data (including the four initial digits). Sending a `git-upload-pack` request
    will return a list of references on the remote repository.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `git://` protocol uses packet lines, create a `PacketLineExtensions.swift`
    file with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When an empty `NSData` object is passed, the special packet line `0000` is written,
    indicating the end of the conversation. When a non-empty `NSData` is written,
    the length of the data is written as a hexadecimal value (including the 4 bytes
    for the length), followed by the data itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will result in a protocol conversation such as:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Reading a packet line is similar:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, the first 4 bytes are read to determine what the remaining length
    is. If it is zero, a `nil` value is returned to indicate the end of stream. If
    it is non-zero, the data is read (less the 4 that is used for the packet line
    length header). An additional `readPacketLineString` is provided to allow an easy
    creation of the packet line as an `NSString`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Listing git references remotely
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remotely query a git repository for references, the `git-upload-pack` command
    needs to be sent along with a reference to the repository in question, and optionally,
    a host. To provide an API to query this programmatically, create a `RemoteGitRepository`
    class with an initializer that stores the host, port, and repository, and an `lsRemote`
    function, which returns the value of the references:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To load the data from the repository, a connection to the remote host needs
    to be made on the default port (in this case, `9418` is the default for the `git://`
    protocol). Once the streams are opened, the `git-upload-pack [repository]\0host=[host]\0`
    packet line is sent, and subsequently, lines can be read of the form `hash reference`.
    Add the following to the `lsRemote` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Calling the `lsRemote` function on a `RemoteGitRepository` instance with an
    appropriate `host` and `repo` will return a list of hashes by reference.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the network call into the UI
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the network can introduce delays or can even result in a complete failure,
    network calls should never be performed on the UI thread. Previously, the `SampleTable`
    was used to introduce a `runOnUIThread` function. A similar approach can be used
    to run a function on a background thread. Add the following to the `SampleTable`
    class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will permit `viewDidLoad` to invoke a call in order to query the remote
    references from the repository, and add them to the table. As before, the call
    to update the table must be called from the UI thread. Add the following to the
    end of the `viewDidLoad` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now when the application is launched, entries corresponding to the branches
    and tags in the remote repository should be added to the table.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous reading and writing
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as synchronous reading and writing, it is also possible to perform *asynchronous*
    reading and writing. Instead of spinning in a `while` loop, the application can
    be use callbacks scheduled on the application's run loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: To receive callbacks, a class that implements `NSStreamDelegate` must be created
    and assigned to the stream's `delegate` field. When events occur, the `stream`
    method is called with the type of event and the associated stream.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The stream is registered with `scheduleInRunLoop` (using `NSRunLoop.mainRunLoop()`
    with a `NSDefaultRunLoopMode` mode). Finally, the stream can be opened.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the stream is opened before the delegate is set or scheduled in the run loop,
    then events will not be delivered.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Events are defined in the `NSStreamEvent` class, and they include `HasSpaceAvailable`
    (for output streams) and `HasBytesAvailable` (for input streams). By responding
    to callbacks, the application can process results asynchronously.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Swift, the `NSStreamDelegate` is treated as a `weak` delegate on
    the input stream or output stream. This presents problems when using an inline
    class to provide input parsing; doing so will result in an `EXC_BAD_ACCESS` as
    the delegate is automatically reclaimed by the runtime. This can be avoided by
    storing a strong circular reference to `self` in the initializer and assigning
    it to `nil` when the streams are closed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Reading data asynchronously from an NSInputStream
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is especially useful for asynchronous protocols, such as XMPP, which may
    send additional messages at arbitrary times. It also allows battery-powered devices
    to not spin the CPU if the remote server is slow or hangs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: To receive data asynchronously, a delegate must implement the `NSStreamDelegate`
    method `stream(stream:handleEvent)`. When data is available, the `HasBytesAvailable`
    event will be sent, and data can be read accordingly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the previous example to an asynchronous form, a few changes need
    to be made. Firstly, the `open` extension method that was created in *Opening
    a stream connection* section needs to be augmented with a `connect` method, but
    which does not perform the `open` immediately:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to receive events asynchronously, the delegate must be set and the
    stream must be scheduled on a run loop before the stream is opened.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stream delegate
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a stream delegate, create a file called `PacketLineParser.swift`
    with the following content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This parser has a callback, which is invoked for each packet line read; when
    the `HasBytesAvailable` event is sent, the line is read (using the same synchronous
    mechanism as before) and then passed to the callback. Unlike the synchronous approach,
    there is no `while` loop here—when data is available, it triggers the parsing
    of the data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this will be assigned to an input stream delegate (which holds a weak reference),
    it is necessary to capture a cyclic reference to itself with `capture = self`
    in order to avoid the runtime from evicting the instance. When the streams are
    closed, the `capture` will be set to `nil`, which will release the instance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The `readPacketLine` returns `nil` to indicate either an error or a completed
    stream; in this case, an empty packet line is sent (to tell the remote server
    that no further interaction is required), and then both streams are closed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is necessary to clean up the streams and remove them from run loops, both
    when the stream content is successful and when communication errors occur. In
    addition to the `HasBytesAvailable` event, there are also events that are sent
    when the stream's end is encountered or an error occurs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: These should be handled in the same way as when the connection comes to a natural
    end; resources should be tidied, and in particular, the streams should be removed
    from run loop processing. Finally, the cyclic reference should be removed to permit
    the `delegate` object to be removed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing `close` code can be moved to its own separate function, and additional
    cases of the stream ending or errors occurring can perform the same cleanup:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Listing references asynchronously
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide a list of references asynchronously, the delegate has to be set up
    with a suitable callback that will parse the returned data. Instead of the method
    returning a dictionary (which would require synchronous blocking), a callback
    will be passed, which can be called with references as they are found.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please note that there are two separate callbacks: the `PacketLineParser` callback
    (which reads in network data and returns `NSString` instances on a per-packet-line
    basis), and the reference parsing callback (which translates the `NSString` into
    a `(String,String)` tuple).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the process, the `git-upload-pack` needs to be sent synchronously
    after which subsequent responses will be processed asynchronously. This can be
    done by creating a new method, `lsRemoteAsync`, in the `RemoteGitRepository` class,
    which takes a callback function for the `(String,String)` tuple:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This creates a connection (but without opening the streams), sets the `delegate`,
    and schedules the run loop for the input stream, and finally, opens both streams
    for interaction. Once this is done, the initial `git-upload-pack` message is sent
    as before. At this point the `lsRemoteAsync` method returns, and subsequent events
    occur when input data is received from the server.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: When a line is received through the `PacketLineParser` callback, it is split
    into a reference and a hash and then hands the results to the callback passed
    into the argument in the first place.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous programming often involves many callbacks. Instead of a synchronous
    program that may look like `A;B;C;`, an asynchronous program often looks like
    `A(callback:B(callback:C))`. When an input trigger occurs—a network request, user
    interaction, or timer firing—a sequence of actions can occur via these nested
    callbacks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程通常涉及许多回调。与看起来像 `A;B;C;` 的同步程序不同，异步程序通常看起来像 `A(callback:B(callback:C))`。当发生输入触发——网络请求、用户交互或定时器触发时，可以通过这些嵌套回调发生一系列操作。
- en: Asynchronous pipelines are generally preferred for battery performance reasons
    as blocking in a `while` spin loop will waste CPU energy until the condition is
    satisfied.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 `while` 循环中阻塞会浪费 CPU 能量直到条件满足，因此出于电池性能的原因，通常更喜欢异步管道。
- en: Displaying asynchronous references in the UI
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 UI 中显示异步引用
- en: To display the asynchronous data to the screen, the callback must be modified
    to allow individual elements to update the GUI.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示异步数据，必须修改回调以允许单个元素更新 GUI。
- en: 'In `SampleTable`, instead of calling `repo.lsRemote` (which performs a synchronous
    lookup), use `repo.lsRemoteAsync` instead. This requires a callback, which can
    be used to update the table data and causes the view to reload the contents:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SampleTable` 中，不要调用 `repo.lsRemote`（它执行同步查找），而应使用 `repo.lsRemoteAsync`。这需要一个回调，它可以用来更新表格数据并导致视图重新加载内容：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now when the application is run, the references will be updated asynchronously
    and the UI will not be blocked by a slow or hung server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，引用将被异步更新，UI 不会被缓慢或挂起的服务器阻塞。
- en: Writing data asynchronously to an NSOutputStream
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据异步写入 NSOutputStream
- en: Asynchronous sending is not as useful as asynchronous reading unless large uploads
    are required. If there is a lot of data, then it is unlikely to be written synchronously
    in a single `write` call. It is better to perform any additional writes asynchronously.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 除非需要大文件上传，否则异步发送不如异步读取有用。如果有大量数据，那么在单个 `write` 调用中不太可能同步写入。最好异步执行任何额外的写入。
- en: 'To write data asynchronously requires storing the `completed` count as a variable
    outside of the function. The `write` method can be used to replace the `while`
    loop as before by writing a segment of the data on each iteration of the stream
    method. Although the code isn''t needed in this example, code would look something
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步写入数据，需要将 `completed` 计数存储为函数外的变量。`write` 方法可以用来替换之前的 `while` 循环，通过在流方法的每次迭代中写入数据的一个片段。尽管在这个例子中不需要代码，代码可能看起来像这样：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Asynchronous data always starts with a call to synchronously write the data.
    If not all of the data is written (in other words, `completed < size`) then subsequent
    callbacks will occur on the `NSStreamDelegate`. This can then pick up where the
    `data` value left off using a similar technique to the synchronous case but without
    a `while` loop. Instead of the iteration blocking to write the whole data value,
    the stream call will be called multiple times (in effect replacing each iteration
    of the `while` loop). On the final run, when `completed == size`, the data is
    released, and the completion counter is reset.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 异步数据始终以同步写入数据的调用开始。如果并非所有数据都被写入（换句话说，`completed < size`），则后续回调将在 `NSStreamDelegate`
    上发生。然后可以使用与同步情况类似的技术来继续 `data` 值，但不使用 `while` 循环。而不是迭代阻塞以写入整个数据值，流调用将被多次调用（实际上替换了
    `while` 循环的每次迭代）。在最后一次运行时，当 `completed == size` 时，数据被释放，完成计数器被重置。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The stream callback is called enough times to write all the data. If no data
    is written, then events are no longer called. New data is only written when an
    additional value is passed. Care must be taken when writing data from different
    threads as the data value is processed as an instance variable, and overwriting
    it may cause data to be lost. The reader is invited to extend the single element
    data into an array of outstanding data elements so that they can be queued up
    appropriately.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 流回调被调用足够多次以写入所有数据。如果没有数据被写入，则事件不再被调用。只有当传递了额外的值时，才会写入新数据。在从不同线程写入数据时必须小心，因为数据值被处理为一个实例变量，覆盖它可能会导致数据丢失。读者被邀请将单个元素数据扩展到未完成数据元素的数组中，以便它们可以适当地排队。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented the common techniques that are used to deal with networked
    data in Swift-based applications with a particular focus on how to maximize battery
    usage on portable devices using asynchronous techniques to access data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在基于Swift的应用程序中处理网络数据时常用的技术，特别关注如何使用异步技术访问数据来最大化便携设备的电池使用。
- en: As most network requests are likely to provide either a JSON or XML-based representation
    over HTTP(S), the first section of this chapter covered using `NSURLSession` and
    the asynchronous `dataTask` operations to pull data down from a remote server.
    The second and third sections then presented how this data can be parsed from
    either JSON or XML depending on the format required.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数网络请求很可能会通过HTTP(S)提供基于JSON或XML的表示，本章的第一节涵盖了使用`NSURLSession`和异步的`dataTask`操作从远程服务器拉取数据。然后第二和第三部分介绍了如何根据所需格式从JSON或XML中解析这些数据。
- en: 'The last section presented how to make network connections directly to deal
    with protocols other than HTTP; and as an example, showed how a remote `git` command
    can be executed to find out what references are available in a remote git repository.
    This was presented in two forms: as a synchronous API (to demonstrate the technique
    of how to work with streams, and to explain the git protocol), followed by its
    conversion to an asynchronous API, which can be used to minimize CPU cycles and,
    thus, battery usage, to allow other such translations to be performed in the future.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节展示了如何直接建立网络连接来处理除HTTP之外的协议；作为一个例子，展示了如何执行远程`git`命令以找出远程git仓库中可用的引用。这以两种形式呈现：首先作为一个同步API（以展示如何与流一起工作的技术，并解释git协议），然后转换为异步API，这可以用来最小化CPU周期，从而降低电池使用，以便将来执行其他此类转换。
- en: The next chapter will present how to integrate all of the ideas covered in this
    book into an iOS application to display GitHub repositories.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示如何将本书中涵盖的所有想法整合到一个iOS应用程序中，以显示GitHub仓库。
