- en: Chapter 6. Parsing Networked Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many iOS applications need to communicate with other servers or devices. This
    chapter presents both HTTP and non-HTTP networking in Swift, and how data can
    be parsed from either JSON or XML. It first demonstrates how to load data efficiently
    from URLs, followed by how to stream larger data responses. It then concludes
    with how to perform both synchronous and asynchronous network requests over protocols
    other than HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the user interface from a background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON and XML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream-based connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous data communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data from URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to load data from a remote network source is to use an HTTP
    (or HTTPS) URL of the form [https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json](https://raw.githubusercontent.com/alblue/com.packtpub.swift.essentials/master/CustomViews/CustomViews/SampleTable.json).
  prefs: []
  type: TYPE_NORMAL
- en: URLs can be manipulated with the `NSURL` class, which comes from the `Foundation`
    module (which is transitively imported from the `UIKit` module). The main `NSURL`
    initializer takes a `String` initializer with a full URL, although other initializers
    exist to create relative URLs or for references to file paths.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSURLSession` class is typically used to perform operations with URLs,
    and individual sessions can be created through the initializer or the standard
    **shared session** can be used. The `NSURLConnection` class was used in older
    versions of iOS and Mac OS X. References to this class can still be seen in some
    tutorials, or may be required if Mac OS X 10.8 or iOS 6 needs to be supported;
    otherwise, the `NSURLSession` class should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSURLSession` class provides a means to create tasks. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data task:** This can be used to process network data programmatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upload task:** This can be used to upload data to a remote server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download task:** This can be used to download to local storage or to resume
    a previous or partial download'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks are created from the `NSURLSession` class methods, and can take a URL
    argument and an optional *completion handler*. A completion handler is a lot like
    a delegate, except that it can be customized per task, and it is usually represented
    as a function.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks can be *suspended* or *resumed* to stop and start the process. Tasks are
    created in a suspended state by default, and so they have to be initially resumed
    to start processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a data task completes, the completion handler is called back with three
    arguments: an `NSData` object that represents the returned data, an `NSURLResponse`
    object that represents the response from the remote URL server, and an optional
    `NSError` object if anything failed during the request.'
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, the `SampleTable` that was created in the previous chapter
    can load data from a network URL by obtaining a session, initiating a data task,
    and then resuming it. The completion handler will get called when the data is
    available, which can be used to add the content to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `viewDidLoad` method of the `SampleTable` class to load the `SampleTable.json`
    file by adding the following to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This creates an `NSURL` and an `NSURLSession`, and then creates a data, task
    and immediately resumes it. After the content is downloaded, the completion handler
    is called, which passes the data as an `NSData` object. The `String` initializer
    is used to decode `UTF8` text from the `NSData` object, and is explicitly cast
    to a `String` so that it can be added to the `items` array.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NSURLSession` class also provides other factory methods, including one
    that takes a configuration argument that includes options, such as whether responses
    should be cached, whether network connections should go over the cellular network,
    and whether any cookies or other headers should be sent with the task.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the item is added to the `items` and the `tableView` is reloaded to
    show the new data. Please note that this does not work immediately if it is not
    run on the main UI thread; the table has to be rotated or moved in order to redraw
    the display. Running on the UI thread is covered in the *Networking and user interface*
    section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Errors are a fact of life, especially on mobile devices with intermittent connectivity.
    The completion handler is called with a third argument, which represents any error
    raised during the operation. If this is `nil`, then the operation was a success;
    if not, then the `localizedDescription` property of the `error` can be used to
    notify the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing purposes, if an error is detected add the `localizedDescription`
    to the `items` in the list. Modify the `viewDidLoad` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An error can be simulated using a nonexistent hostname or an unknown protocol
    in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Errors are reported if the remote server cannot be contacted, such as when the
    hostname is incorrect or the server is down. If the server is operational, then
    an error will not be reported; but it is still possible that the file that is
    requested will not be found, or that the server will experience an error while
    serving the request. These are reported with HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an HTTP URL is not found, the server sends back a `404` status code. This
    can be used by the client to determine whether a different file should be accessed
    or whether another server should be queried. For example, browsers will often
    ask the server for a `favicon.ico` file and use this to display a small logo;
    if this file is missing, then a generic page icon is displayed instead. In general,
    `4xx` responses are client errors, while `5xx` responses are server errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSURLResponse` object doesn''t have the concept of an HTTP status code,
    because it can be used for any protocol, including `ftp`. However, if the request
    used HTTP, then the response is likely to be HTTP and so it can be cast to an
    `NSURLHttpResponse`, which has a `statusCode` property. This can be used to provide
    more specific feedback when the file is not found. Modify the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the server responds but indicates that either the client made a bad
    request or the server suffered a problem, the user interface will be updated appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Nested if and switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the error handling logic can get convoluted with handling different
    cases, particularly if there are different values that need to be tested. In the
    previous section, both the `NSError` and HTTP `statusCode` needed to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to use a `switch` statement with `where` clauses.
    These can be used to test multiple different conditions and also show which part
    of the condition is being tested. Although a `switch` statement requires a single
    expression, it is possible to use a *tuple* to group multiple values into a single
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using a tuple is that it permits the cases to be matched
    on types. In the networking case, some URLs are based on `http` or `https`, which
    means that the response will be an `NSHTTPURLResponse` type. However, if the URL
    is a different type (such as a `file` or `ftp` protocol), then it will be of a
    different subtype of `NSURLResponse`. Unconditionally casting to `NSHTTPURLResponse`
    with `as` will fail in these cases and cause a crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests can be rewritten as a `switch` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `default` block is used to execute the success condition,
    and the prior `case` statements are used to match the error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The `case (_,_,let e) where e != nil` case is an example of a *conditional pattern
    match*. The underscore, which is called a *wildcard pattern* in Swift (also known
    as a **hole** in other languages), is something that will match any value. The
    third parameter, `let e`, is a *value binding pattern*, and has the effect of
    `let e = error` in this case. Finally, the `where` clause adds the test to ensure
    this case only occurs when `e` is not `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be possible to use the identifier `error` instead of `let e` in the
    `case` statement, using `case (_,_,_) where error != nil` would have had the same
    effect. However, it is bad practice to capture values outside of the `switch`
    statement for case matching purposes because if the `error` variable is renamed,
    then the `case` statement may become invalid. Generally, use `let` patterns inside
    `case` statements to ensure that the correct expression value is being matched.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third cases perform both a `let` assignment and a type test/conversion.
    When `case (_,let r as NSHTTPURLResponse,_)` is matched, not only is the value
    of that part in the tuple assigned the constant `r`, but it is also cast to an
    `NSHTTPURLRepsonse`. If the value is not of type `NSHTTPURLResponse`, then the
    case statement is automatically skipped. This is equivalent to an `if` test with
    an `is` expression followed by a cast with `as`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the patterns are the same in both, the `where` clauses are different.
    The first `where` clause looks for the case where `r.statusCode` is 400 or greater
    and less than 500, while the second is matched where `r.statusCode` is 500 or
    greater.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether nested `if` statements or the `switch` statement is used, the code that
    performs the test is likely to be very similar. It typically comes down to developer
    preference, but more developers are likely to be familiar with nested `if` statements.
    In Swift, the `switch` statement is more powerful than in other languages, and
    so, this kind of pattern is likely to become more popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative with Swift 2 is to use the `guard` statement to ensure that
    if certain error conditions occur, then appropriate action can be taken instead.
    The `guard` statement is like an `if` statement where there is no `true` block
    and the `false` block must always leave the function. For example, the code could
    be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `guard` block must exit the calling function; so, if additional
    operations are required, either the body of the implementation must be moved to
    a different function or the `switch` or `if` blocks used instead. The examples
    later in this chapter assume the use of the `if` blocks for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Networking and user interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One outstanding problem with the current callback approach is that the callback
    cannot be guaranteed to be called from the *main thread*. As a result, user interface
    operations may not work correctly or throw errors. The right solution is to set
    up another call using the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the main thread in Swift is done in the same way as it is in Objective-C:
    using **Grand Central Dispatch** (**GCD**). The *main queue* can be accessed with
    `dispatch_get_main_queue`, which is used by the thread that all UI updates should
    use. Background tasks are submitted with `dispatch_async` to a queue. To invoke
    the `reloadData` call on the main thread, wrap it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of call will be valid for both Objective-C and Swift (although Objective-C
    uses the ^ (caret) as a block prefix). However, Swift has a special syntax for
    functions that take blocks; the block can be promoted out of the function''s argument
    and left as a trailing argument. This is known as a *trailing closure*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a minor difference, it makes it look like `dispatch_async`
    is more like a keyword, such as `if` or `switch`, which takes a block of code.
    This can be used for any function whose final argument is a function; there is
    no special syntax needed in the function definition. Additionally, the same technique
    works for functions that are defined outside of Swift; in the case of `dispatch_async`,
    the function is defined as a C-language function and can be transparently used
    in a portable way.
  prefs: []
  type: TYPE_NORMAL
- en: Running functions on the main thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the UI needs to be updated, the update must be run on the main thread.
    This can be done using the previous pattern to perform updates as they will always
    be threaded. However, it can be a pain to remember to do this each time it is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to build a Swift function that takes another function and runs
    it on the main thread automatically. `NSThread.isMainThread` can be used to determine
    whether the current thread is the UI thread or not; so to run a block of code
    on the main thread, regardless of whether it''s on the main thread or not, the
    following can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows code to be submitted to the background thread using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the lack of parenthesis, the `reloadData` function is not called, but
    it is passed in as a function pointer. It is dispatched to the correct thread
    inside the `runOnUIThread` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is more than one function that needs to be called, an inline block
    can be created. As this can be passed as a trailing closure to the `runOnUIThread`
    method, the parenthesis are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Parsing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular mechanism to send structured data over a network is to encode
    it in **JSON**, which stands for **JavaScript Object Notation**. This provides
    a hierarchical tree data structure, which can store simple numeric, logical, and
    string-based types, along with array and dictionary representations.
  prefs: []
  type: TYPE_NORMAL
- en: Both Mac OS X and iOS come with a built-in parser for JSON documents, in the
    `NSJSONSerialization` class. This provides a means to parse a data object and
    return an `NSDictionary` that contains the key/value pairs of a JSON object, or
    an `NSArray` to represent JSON arrays. Other literals are parsed and are represented
    as either `NSNumber` or `NSString` values.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON parser uses `JSONObjectWithData` to create an object from an `NSData`
    object containing a string. This is typically the format that is returned by network
    APIs, and it can be created from an existing string using `dataUsingEncoding`
    with one of the built-in encoding types, such as `NSUTF8StringEncoding`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JSON array of numbers can be parsed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The return type of this is an optional `AnyObject`. The optionality represents
    the fact that the data content may not be valid JSON data. This can be cast to
    an appropriate type using the `as` keyword; if there is a parsing failure, then
    an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The `options` can be used to indicate whether the return type should be mutable
    or not. Mutable data allows the caller to add or delete items after being returned
    from the parsing function; if not specified, the return value will be immutable.
    The `NSJSONReadingOptions` options include `MutableContainers` (containing data
    structures are mutable), `MutableLeaves` (the child leaves are mutable), and `AllowFragments`
    (allow nonobject, non-array values to be parsed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SampleTable.json` file (referred to in the `viewDidLoad` method) stores
    an array of entries, with `title` and `content` fields holding text data per entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse the JSON file and entries to the table, replace the `default` clause
    in the `SampleTable` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the application will show the **Sample Title** and **Sample Content**
    entries in the table, which have been loaded and parsed from the book's GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there are problems parsing the JSON data then the return type of the `try?
    JSONObjectWithData` function will return a `nil` value. If the type is implicitly
    unwrapped, then accessing the element will cause an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `parsed` value will be of type `AnyObject?` although the `let` block will
    implicitly unwrap the value, known as *optional binding*. In the previous section,
    the code was cast to an `NSArray` directly, but if the returned result contains
    different types (for example, an `NSDictionary` or one of the fragment types `NSNumber`
    or `NSString`), then attempting to cast to a type that is incompatible with the
    runtime type will cause a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the object can be tested with `if [object] is [type]`. However,
    as the next step is usually to cast it to a different class with `as`, a shorthand
    form `as?` can perform both the test and the cast in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A `switch` statement can be used to check the type of multiple values at the
    same time. As the values are optional `AnyObject` objects, they need to be converted
    to a `String` before they can be used in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now when the application is run, any errors are detected and handled without
    the application crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although JSON is more commonly used, there are still many XML-based network
    services. Fortunately XML parsing has existed in iOS since version 5 in the `NSXMLParser`
    class and is simple to access from Swift. For example, some data feeds (such as
    blog posts) use XML documents, such as Atom or RSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NSXMLParser` is a stream-oriented parser; that is, it reports individual
    elements as they are seen. The parser calls the `delegate` to notify when elements
    are seen and have finished. When an element is seen, the parser also includes
    any attributes that were present; and for text nodes, the string content. Parsing
    an XML file involves some state management in the parser. The example used in
    this section will be to parse an Atom (news feed) file, whose (simplified) structure
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the goal is to extract all the `entry` elements from the feed,
    specifically the `title` and the `link`. This presents a few challenges that will
    become apparent later on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a parser delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parsing an XML file requires creating a class that conforms to the `NSXMLParserDelegate`
    protocol. To do this, create a new class, `FeedParser`, that extends `NSObject`
    and conforms to the `NSXMLParserDelegate` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should have an `init` method that takes an `NSData`, and an `items` property
    that will be used to acquire the results after they have been parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NSXMLParserDelegate` protocol requires that the object also conform to
    the `NSObjectProtocol`. The easiest way to do this is to subclass `NSObject`.
    The first mentioned super type is the super class; the second and subsequent super
    types must be protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The XML parser can either parse a stream of data as it is downloaded, or it
    can take an `NSData` object that has been downloaded previously. On successful
    download, the `FeedParser` can be used to parse the `NSData` instance and return
    the list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although individual expressions can be assigned temporary values that are similar
    to last time, the statement can be written in a single line (although please note
    that the error handling is not present). Add the following to the end of the `viewDidLoad`
    method of `SampleTable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will download the Atom XML feed for the Swift posts from the author's blog
    at [https://alblue.bandlem.com](https://alblue.bandlem.com). Currently, the data
    is not parsed, so nothing will be added to the table in this step.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that both the download operation and the parsing are handled off the
    main thread as both of these operations may take some time. Once the data is downloaded,
    it can be parsed, and after it is parsed, the UI can be notified to redisplay
    the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To process the downloaded XML file, it is necessary to parse the data. This
    involves writing a parser delegate to listen for the `title` and `link` elements.
    However, the `title` and `link` elements exist both at the individual `entry`
    level and also at the top level of the blog. It is therefore necessary to represent
    some kind of state in the parser, which detects when the parser is inside an `entry`
    element to allow the correct values to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements are reported with the `parser:didStartElement:` method and the `parser:didEndElement:`
    method. This can be used to determine if the parser is inside an `entry` element
    by setting a boolean value when an `entry` element starts and resetting it when
    the `entry` element ends. Add the following to the `FeedParser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `link` stores the value of the references in an `href` attribute of the
    element. This is passed when the start element is called, so it is trivial to
    store. At this point, the title may not be known, so the value of the `link` has
    to be stored in an optional field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `title` stores its data as a text node, which needs to be implemented with
    another boolean flag indicating whether the parser is inside a `title` node. Text
    nodes are reported with the `parser:foundCharacters:` delegate method. Add the
    following to the `FeedParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By storing the `title` and `link` as optional fields when the end of the `entry`
    element is seen, the fields can be appended into the `items` list, followed by
    resetting the state of the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, having implemented the callback methods, the remaining steps are to
    create an `NSXMLParser` from the data passed in previously, set the `delegate`
    (and optionally, the namespace handling), and then invoke the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assignment of `self` to the `delegate` cannot be done until after `super.init`
    has been called.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the application is run, a set of news feed items will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If running on iOS 9 targets and downloading from http sites, a **App Transport
    Security has blocked a cleartext HTTP resource load** message may be seen in the
    console. The solution to fix this is to add an exception in the `Info.plist` file,
    which permits connections via HTTP, either for the explicit domain or for all
    domains. Add the following to the `Info.plist` after the first `<dict>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now when the application is run, the error should no longer be seen.
  prefs: []
  type: TYPE_NORMAL
- en: Direct network connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although most application networking will involve downloading content over standard
    protocols, such as HTTP(S), and using standard representations, there are times
    when having a specific data stream protocol is required. In this case, a *stream*-oriented
    process will allow individual bytes to be read or written, or a *datagram* or
    *packet*-oriented process can be used to send individual packets of data.
  prefs: []
  type: TYPE_NORMAL
- en: There are networking libraries to support both; an `NSStream` higher-level Objective-C
    based class provides a mechanism to drive stream-based responses, and although
    lower-level packet connections are possible with the `CoreFoundation` or the `POSIX`
    layer, local multiplayer gaming using the `MultipeerConnectivity` module is often
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Local networking with the `MultipeerConnectivity` module involves creating an
    `MCSession`, followed by `sendData` to send `NSData` objects to connected peers,
    and using the `MCSessionDelegate` to `receiveData` from connected peers. This
    is often used to synchronize the state of the world, such as the player's current
    location or health.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a stream-based connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream is a reliable, ordered sequence of bytes, which is used by most internet
    protocols. Streams can be created from a network host and port using the `NSStream`
    class method `getStreamsToHostWithName`. This allows an `NSInputStream` and `NSOutputStream`
    to be acquired at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this is an existing Objective-C API, the streams are returned via *inout
    parameters*. In Swift, this translates to the parameters being passed back with
    an ampersand (`&`) and declaring the variables as optional.
  prefs: []
  type: TYPE_NORMAL
- en: The input and output streams can then be used to send data asynchronously or
    synchronously. Asynchronous mechanisms involve scheduling the data processing
    on the application's run-loop and is covered in the *Asynchronous reading and
    writing* section. Synchronous mechanisms use `read` and `write` to receive or
    send buffers of data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the streams have been acquired, they need to be *open* to receive or send
    data. Forgetting this step will result in no networking data being sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify acquiring the streams, the following can be created as an extension
    of the `NSStream` class. An extension makes a method appear to come from an original
    class but is implemented externally to that class. Add a `StreamExtensions.swift`
    file to the `CustomViews` project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A connection to a remote host can be obtained by calling `NSStream.open(host,port)`,
    which returns an open pair of input/output streams.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous reading and writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NSInputStream` method `read` allows bytes to be read from a stream synchronously,
    while the `NSOutputStream` method `write` allows bytes to be written to a stream.
    These take different types, but the most common approach is to create an array
    of bytes `[UInt8]` in Swift as the buffer, and then read into or out of it with
    an `UnsafeMutablePointer` (equivalent to an ampersand in C).
  prefs: []
  type: TYPE_NORMAL
- en: The `read` and `write` methods both return a number of bytes read/written. This
    can be negative (in the case of an error), zero, or positive in the case of bytes
    having been processed. Both calls take a buffer and a maximum length, though it
    is not guaranteed that the full maximum length will be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check the return value of `write` or `read` as it is possible that only
    part of the buffer has been written. Best practice (for synchronous connections)
    is to wrap the call in a `while` loop or have some other form of `retry` in order
    to ensure that all the data is written.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to NSOutputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make it easier to write `NSData` content to streams, an extension method
    on `NSOuptutStream` can be created that performs a full write, based on the size
    of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code takes an `NSData` and writes it to the underlying stream, returning
    the number of bytes written (or a negative value if there are problems). The return
    value of the `write` method is checked, and if the value is negative, it is returned
    to the caller directly. Otherwise, the `completed` counter is incremented with
    the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of written bytes reaches the size of the data requested, then
    the value is returned. Otherwise the loop recurs, this time starting at the point
    where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although uncommon in Swift, pointer arithmetic is possible by acquiring an `UnsafePointer`
    to the `data.bytes` array, and then incrementing it by the number of bytes already
    written. The length of the remaining bytes is calculated with `size-completed`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from an NSInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A similar approach can be used to read a full buffer from an `NSInputStream`
    by creating a `readBytes` method that returns an array of bytes of a known size,
    and a means to convert this to an `NSData` for easier processing/parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `readData` method returns an `NSData`, while the `readBytes` method returns
    an array of `UInt8` values. The `NSData` approach is useful in some cases (particularly,
    creating a `String` from the returned data), and in other cases, being able to
    process the bytes directly is useful (for example, parsing binary formats). Having
    both allows either to be used as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Synchronous reads can block forever; if the client application requests exactly
    10 bytes but the server only sends 9 bytes, then it will hang permanently until
    the tenth byte is sent. It is best practice to use asynchronous reads, which cannot
    block in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing hexadecimal and UTF8 data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being able to process data as UTF8 values or hexadecimal values can be useful
    in some protocols. Although both `NSString` and `NSData` provide means to convert
    to and from UTF8, the syntax is overly verbose as it is based on pre-existing
    Objective-C methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate the conversions, extension methods can be created to provide
    a simple way of converting to and from UTF8 representations. In addition to class
    and instance functions, it is possible to use extensions to add dynamic properties
    to an existing object. This can be used to create `utf8data` and `utf8string`
    properties on `NSData` and `String` by adding extensions in a file `Extensions.swift`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This allows expressions, such as `data.utf8string` and `string.utf8data`, which
    are much more compact. Each time the expression is evaluated, the associated getter
    function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no standard convention to name extensions in Swift at the time this
    book was written. If there are extensions to a single type of data—such as the
    streams previously—then the file can be named `[Type]Extensions.swift`. Alternatively,
    the name can be used for the type of methods that are called; for example, in
    this case, `UTF8Extensions.swift` could have been used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing hexadecimal data from strings and integers can also be added to the
    `String` and `Int` types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This allows hex values to be created with `int.toHex` and `string.fromHex`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Git protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to write a client to query a remote git server using the `git://`
    protocol to determine the hashes of remote tags/branches/references.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git://` protocol works by sending *packet lines* of data with each line
    prefixed with four hexadecimal digits in ASCII, indicating the length of the rest
    of the data (including the four initial digits). Sending a `git-upload-pack` request
    will return a list of references on the remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `git://` protocol uses packet lines, create a `PacketLineExtensions.swift`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When an empty `NSData` object is passed, the special packet line `0000` is written,
    indicating the end of the conversation. When a non-empty `NSData` is written,
    the length of the data is written as a hexadecimal value (including the 4 bytes
    for the length), followed by the data itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This will result in a protocol conversation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading a packet line is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the first 4 bytes are read to determine what the remaining length
    is. If it is zero, a `nil` value is returned to indicate the end of stream. If
    it is non-zero, the data is read (less the 4 that is used for the packet line
    length header). An additional `readPacketLineString` is provided to allow an easy
    creation of the packet line as an `NSString`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing git references remotely
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remotely query a git repository for references, the `git-upload-pack` command
    needs to be sent along with a reference to the repository in question, and optionally,
    a host. To provide an API to query this programmatically, create a `RemoteGitRepository`
    class with an initializer that stores the host, port, and repository, and an `lsRemote`
    function, which returns the value of the references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To load the data from the repository, a connection to the remote host needs
    to be made on the default port (in this case, `9418` is the default for the `git://`
    protocol). Once the streams are opened, the `git-upload-pack [repository]\0host=[host]\0`
    packet line is sent, and subsequently, lines can be read of the form `hash reference`.
    Add the following to the `lsRemote` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `lsRemote` function on a `RemoteGitRepository` instance with an
    appropriate `host` and `repo` will return a list of hashes by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the network call into the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the network can introduce delays or can even result in a complete failure,
    network calls should never be performed on the UI thread. Previously, the `SampleTable`
    was used to introduce a `runOnUIThread` function. A similar approach can be used
    to run a function on a background thread. Add the following to the `SampleTable`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will permit `viewDidLoad` to invoke a call in order to query the remote
    references from the repository, and add them to the table. As before, the call
    to update the table must be called from the UI thread. Add the following to the
    end of the `viewDidLoad` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now when the application is launched, entries corresponding to the branches
    and tags in the remote repository should be added to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous reading and writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as synchronous reading and writing, it is also possible to perform *asynchronous*
    reading and writing. Instead of spinning in a `while` loop, the application can
    be use callbacks scheduled on the application's run loop.
  prefs: []
  type: TYPE_NORMAL
- en: To receive callbacks, a class that implements `NSStreamDelegate` must be created
    and assigned to the stream's `delegate` field. When events occur, the `stream`
    method is called with the type of event and the associated stream.
  prefs: []
  type: TYPE_NORMAL
- en: The stream is registered with `scheduleInRunLoop` (using `NSRunLoop.mainRunLoop()`
    with a `NSDefaultRunLoopMode` mode). Finally, the stream can be opened.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the stream is opened before the delegate is set or scheduled in the run loop,
    then events will not be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Events are defined in the `NSStreamEvent` class, and they include `HasSpaceAvailable`
    (for output streams) and `HasBytesAvailable` (for input streams). By responding
    to callbacks, the application can process results asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Swift, the `NSStreamDelegate` is treated as a `weak` delegate on
    the input stream or output stream. This presents problems when using an inline
    class to provide input parsing; doing so will result in an `EXC_BAD_ACCESS` as
    the delegate is automatically reclaimed by the runtime. This can be avoided by
    storing a strong circular reference to `self` in the initializer and assigning
    it to `nil` when the streams are closed.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data asynchronously from an NSInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is especially useful for asynchronous protocols, such as XMPP, which may
    send additional messages at arbitrary times. It also allows battery-powered devices
    to not spin the CPU if the remote server is slow or hangs.
  prefs: []
  type: TYPE_NORMAL
- en: To receive data asynchronously, a delegate must implement the `NSStreamDelegate`
    method `stream(stream:handleEvent)`. When data is available, the `HasBytesAvailable`
    event will be sent, and data can be read accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the previous example to an asynchronous form, a few changes need
    to be made. Firstly, the `open` extension method that was created in *Opening
    a stream connection* section needs to be augmented with a `connect` method, but
    which does not perform the `open` immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to receive events asynchronously, the delegate must be set and the
    stream must be scheduled on a run loop before the stream is opened.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stream delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a stream delegate, create a file called `PacketLineParser.swift`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This parser has a callback, which is invoked for each packet line read; when
    the `HasBytesAvailable` event is sent, the line is read (using the same synchronous
    mechanism as before) and then passed to the callback. Unlike the synchronous approach,
    there is no `while` loop here—when data is available, it triggers the parsing
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As this will be assigned to an input stream delegate (which holds a weak reference),
    it is necessary to capture a cyclic reference to itself with `capture = self`
    in order to avoid the runtime from evicting the instance. When the streams are
    closed, the `capture` will be set to `nil`, which will release the instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `readPacketLine` returns `nil` to indicate either an error or a completed
    stream; in this case, an empty packet line is sent (to tell the remote server
    that no further interaction is required), and then both streams are closed.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is necessary to clean up the streams and remove them from run loops, both
    when the stream content is successful and when communication errors occur. In
    addition to the `HasBytesAvailable` event, there are also events that are sent
    when the stream's end is encountered or an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: These should be handled in the same way as when the connection comes to a natural
    end; resources should be tidied, and in particular, the streams should be removed
    from run loop processing. Finally, the cyclic reference should be removed to permit
    the `delegate` object to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing `close` code can be moved to its own separate function, and additional
    cases of the stream ending or errors occurring can perform the same cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Listing references asynchronously
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide a list of references asynchronously, the delegate has to be set up
    with a suitable callback that will parse the returned data. Instead of the method
    returning a dictionary (which would require synchronous blocking), a callback
    will be passed, which can be called with references as they are found.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please note that there are two separate callbacks: the `PacketLineParser` callback
    (which reads in network data and returns `NSString` instances on a per-packet-line
    basis), and the reference parsing callback (which translates the `NSString` into
    a `(String,String)` tuple).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the process, the `git-upload-pack` needs to be sent synchronously
    after which subsequent responses will be processed asynchronously. This can be
    done by creating a new method, `lsRemoteAsync`, in the `RemoteGitRepository` class,
    which takes a callback function for the `(String,String)` tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This creates a connection (but without opening the streams), sets the `delegate`,
    and schedules the run loop for the input stream, and finally, opens both streams
    for interaction. Once this is done, the initial `git-upload-pack` message is sent
    as before. At this point the `lsRemoteAsync` method returns, and subsequent events
    occur when input data is received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: When a line is received through the `PacketLineParser` callback, it is split
    into a reference and a hash and then hands the results to the callback passed
    into the argument in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous programming often involves many callbacks. Instead of a synchronous
    program that may look like `A;B;C;`, an asynchronous program often looks like
    `A(callback:B(callback:C))`. When an input trigger occurs—a network request, user
    interaction, or timer firing—a sequence of actions can occur via these nested
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous pipelines are generally preferred for battery performance reasons
    as blocking in a `while` spin loop will waste CPU energy until the condition is
    satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying asynchronous references in the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To display the asynchronous data to the screen, the callback must be modified
    to allow individual elements to update the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SampleTable`, instead of calling `repo.lsRemote` (which performs a synchronous
    lookup), use `repo.lsRemoteAsync` instead. This requires a callback, which can
    be used to update the table data and causes the view to reload the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now when the application is run, the references will be updated asynchronously
    and the UI will not be blocked by a slow or hung server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data asynchronously to an NSOutputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Asynchronous sending is not as useful as asynchronous reading unless large uploads
    are required. If there is a lot of data, then it is unlikely to be written synchronously
    in a single `write` call. It is better to perform any additional writes asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write data asynchronously requires storing the `completed` count as a variable
    outside of the function. The `write` method can be used to replace the `while`
    loop as before by writing a segment of the data on each iteration of the stream
    method. Although the code isn''t needed in this example, code would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous data always starts with a call to synchronously write the data.
    If not all of the data is written (in other words, `completed < size`) then subsequent
    callbacks will occur on the `NSStreamDelegate`. This can then pick up where the
    `data` value left off using a similar technique to the synchronous case but without
    a `while` loop. Instead of the iteration blocking to write the whole data value,
    the stream call will be called multiple times (in effect replacing each iteration
    of the `while` loop). On the final run, when `completed == size`, the data is
    released, and the completion counter is reset.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stream callback is called enough times to write all the data. If no data
    is written, then events are no longer called. New data is only written when an
    additional value is passed. Care must be taken when writing data from different
    threads as the data value is processed as an instance variable, and overwriting
    it may cause data to be lost. The reader is invited to extend the single element
    data into an array of outstanding data elements so that they can be queued up
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented the common techniques that are used to deal with networked
    data in Swift-based applications with a particular focus on how to maximize battery
    usage on portable devices using asynchronous techniques to access data.
  prefs: []
  type: TYPE_NORMAL
- en: As most network requests are likely to provide either a JSON or XML-based representation
    over HTTP(S), the first section of this chapter covered using `NSURLSession` and
    the asynchronous `dataTask` operations to pull data down from a remote server.
    The second and third sections then presented how this data can be parsed from
    either JSON or XML depending on the format required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last section presented how to make network connections directly to deal
    with protocols other than HTTP; and as an example, showed how a remote `git` command
    can be executed to find out what references are available in a remote git repository.
    This was presented in two forms: as a synchronous API (to demonstrate the technique
    of how to work with streams, and to explain the git protocol), followed by its
    conversion to an asynchronous API, which can be used to minimize CPU cycles and,
    thus, battery usage, to allow other such translations to be performed in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will present how to integrate all of the ideas covered in this
    book into an iOS application to display GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
