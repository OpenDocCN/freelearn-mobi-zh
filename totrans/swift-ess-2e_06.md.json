["```swift\nlet url = NSURL(string: \"https://raw.githubusercontent.com/\n  alblue/com.packtpub.swift.essentials/master/\n  CustomViews/CustomViews/SampleTable.json\")!\nlet session = NSURLSession.sharedSession()\nlet encoding = NSUTF8StringEncoding\nlet task = session.dataTaskWithURL(url,completionHandler:\n {data,response,error -> Void in\n  let contents = String(data:data!,encoding:encoding)!\n  self.items += [(url.absoluteString,contents)]\n // table data won't reload – needs to be on ui thread\n  self.tableView.reloadData()\n})\ntask.resume()\n```", "```swift\nlet task = session.dataTaskWithURL(url, completionHandler:\n {data,response,error -> Void in\n  if error == nil {\n    let contents = String(data:data!,encoding:encoding)!\n    self.items += [(url.absoluteString,contents)]\n  } else {\n self.items += [(\"Error\",error!.localizedDescription)]\n }\n // table data won't reload – needs to be on UI thread\n  self.tableView.reloadData()\n})\n```", "```swift\nif error == nil {\n  let httpResponse = response as! NSHTTPURLResponse\n let statusCode = httpResponse.statusCode\n if (statusCode >= 400 && statusCode < 500) {\n self.items += [(\"Client error \\(statusCode)\",\n url.absoluteString)]\n } else if (statusCode >= 500) {\n self.items += [(\"Server error \\(statusCode)\",\n url.absoluteString)]\n } else {\n    let contents = String(data:data!,encoding:encoding)!\n    self.items += [(url.absoluteString,contents)]\n  }\n} else {...}\n```", "```swift\nswitch (data,response,error) {\n  case (_,_,let e) where e != nil:\n    self.items += [(\"Error\",e.localizedDescription)]\n  case (_,let r as NSHTTPURLResponse,_) \n   where r.statusCode >= 400 && r.statusCode < 500:\n    self.items += [(\"Client error \\(r.statusCode)\",\n     url.absoluteString)]\n  // see note below\n  case (_,let r as NSHTTPURLResponse,_) \n   where r.statusCode >= 500:\n    self.items += [(\"Server error \\(r.statusCode)\",\n      url.absoluteString)]\n  default:\n    let contents = String(data:data!,encoding:encoding)!\n    self.items += [(url.absoluteString,contents)]\n}\n```", "```swift\nguard error == nil else {\n  self.items += [(\"Error\",error!.localizedDescription)]\n  return\n}\nlet statusCode = (response as! NSHTTPURLResponse).statusCode\n\nguard statusCode < 500 else {\n  self.items += [(\"Server error \\(statusCode)\",\n    url.absoluteString)]\n  return\n}\n\nguard statusCode < 400 else {\n  self.items += [(\"Client error \\(statusCode)\",\n   url.absoluteString)]\n  return\n}\n\nlet contents = String(data:data!,encoding:encoding)!\nself.items += [(url.absoluteString,contents)]\n```", "```swift\ndispatch_async(dispatch_get_main_queue(), {\n  self.tableView.reloadData()\n})\n\n```", "```swift\ndispatch_async(dispatch_get_main_queue()) {\n  self.tableView.reloadData()\n}\n\n```", "```swift\nfunc runOnUIThread(fn:()->()) {\n  if NSThread.isMainThread() {\n    fn()\n  } else {\n    dispatch_async(dispatch_get_main_queue(), fn)\n  }\n}\n```", "```swift\nself.runOnUIThread(self.tableView.reloadData)\n```", "```swift\nself.runOnUIThread {\n  self.tableView.backgroundColor = UIColor.redColor()\n  self.tableView.reloadData()\n  self.tableView.backgroundColor = UIColor.greenColor()\n}\n```", "```swift\nlet array = \"[1,2,3]\".dataUsingEncoding(NSUTF8StringEncoding)!\nlet parsed = try? NSJSONSerialization.JSONObjectWithData(\n  array, options:.AllowFragments)\n```", "```swift\n[{\"title\":\"Sample Title\",\"content\":\"Sample Content\"}]\n```", "```swift\ndefault:\n  let parsed = try? NSJSONSerialization.JSONObjectWithData(\n    data!, options:.AllowFragments) as! NSArray\n  for entry in parsed {\n    self.items += \n      [(entry[\"title\"] as! String,\n        entry[\"content\"] as! String)]\n  }\n```", "```swift\ndo {\n let parsed = try NSJSONSerialization.JSONObjectWithData(data!,\n options:.AllowFragments) {\n  // do something with parsed\n} catch let error as NSError {\n  self.items += [(\"Error\", \n   \"Cannot parse JSON \\(error.localizedDescription)\")]\n  // show message to user\n}\n```", "```swift\n if let array = parsed as? NSArray {\n  for entry in array {\n    // process elements\n  }\n} else {\n  self.items += [(\"Error\", \"JSON is not an array\")]\n}\n```", "```swift\nfor entry in array {\n  switch (entry[\"title\"], entry[\"content\"]) {\n    case (let title as String, let content as String):\n      self.items += [(title,content)]\n    default:\n      self.items += [(\"Error\", \"Missing unknown entry\")]\n  }\n}\n```", "```swift\n<feed >\n  <title>AlBlue's Blog</title>\n  <link href=\"http://alblue.bandlem.com/atom.xml\" rel=\"self\"/>\n  <entry>\n    <title type=\"html\">QConLondon and Swift Essentials</title>\n    <link href=\"http://alblue.bandlem.com/2015/01/qcon-swift-essentials.html\"/>\n    ... \n  </entry>\n  ...\n</feed> \n```", "```swift\nclass FeedParser: NSObject, NSXMLParserDelegate {\n  var items:[(String,String)] = []\n  init(_ data:NSData) {\n    // parse XML\n  }\n}\n```", "```swift\nsession.dataTaskWithURL(\n  NSURL(string:\"https://alblue.bandlem.com/Tag/swift/atom.xml\")!,\n  completionHandler: {data,response,error -> Void in\n    if let data = data {\n      self.items += FeedParser(data).items\n      self.runOnUIThread(self.tableView.reloadData)\n    }\n}).resume()\n```", "```swift\nvar inEntry:Bool = false\nfunc parser(parser: NSXMLParser,\n didStartElement elementName: String,\n namespaceURI: String?, qualifiedName: \n String?, attributes: [String:String]) {\n  switch elementName {\n    case \"entry\":\n      inEntry = true\n    default: break\n  }\n}\n```", "```swift\nvar link:String?\n...\n// in parser:didStartElement method\ncase \"entry\":\n  inEntry = true\ncase \"link\":\n link = attributes[\"href\"]\ndefault break;\n```", "```swift\nvar title:String?\nvar inTitle: Bool = false\n...\n// in parser:didStartElement method\ncase \"entry\":\n  inEntry = true\ncase \"title\":\n inTitle = true\ncase \"link\":\n...\nfunc parser(parser: NSXMLParser, foundCharacters string:String) {\n if inEntry && inTitle {\n title = string\n }\n}\n\n```", "```swift\nfunc parser(parser: NSXMLParser,\n didEndElement elementName: String,\n namespaceURI: String?, qualifiedName: String?) {\n  switch elementName {\n    case \"entry\":\n      inEntry = false\n      if title != nil && link != nil {\n        items += [(title!,link!)]\n      }\n      title = nil\n      link = nil\n    case \"title\":\n      inTitle = false\n    default: break\n  }\n}\n```", "```swift\ninit(_ data:NSData) {\n  let parser = NSXMLParser(data: data)\n  parser.shouldProcessNamespaces = true\n  super.init()\n  parser.delegate = self\n  parser.parse() }\n```", "```swift\n<key>NSAppTransportSecurity</key>\n<dict>\n  <key>NSAllowsArbitraryLoads</key>\n  <true/>\n</dict>\n```", "```swift\nextension NSStream {\n  class func open(host:String,_ port:Int)\n   -> (NSInputStream, NSOutputStream)? {\n    var input:NSInputStream?\n    var output:NSOutputStream?\n    NSStream.getStreamsToHostWithName(\n      host, port: port, \n      inputStream: &input,\n      outputStream: &output)\n    guard let i = input, o = output else {\n      return nil\n    }\n    o.open()\n    i.open()\n    return (i,o)\n  }\n}\n```", "```swift\nextension NSOutputStream {\n  func writeData(data:NSData) -> Int {\n    let size = data.length\n    var completed = 0\n    while completed < size {\n      let wrote = write(UnsafePointer(data.bytes) +\n       completed, maxLength:size - completed)\n      if wrote < 0 {\n        return wrote\n      } else {\n        completed += wrote\n      }\n    }\n    return completed\n  }\n}\n```", "```swift\nextension NSInputStream {\n  func readBytes(size:Int) -> [UInt8]? {\n    let buffer = Array<UInt8>(count:size,repeatedValue:0)\n    var completed = 0\n    while completed < size {\n      let read = self.read(\n       UnsafeMutablePointer(buffer) + completed,\n       maxLength: size - completed)\n      if read < 0 {\n        return nil\n      } else {\n        completed += read\n      }\n    }\n    return buffer\n  }\n  func readData(size:Int) -> NSData? {\n    if let buffer = readBytes(size) {\n      return NSData(\n       bytes: UnsafeMutablePointer(buffer),\n       length: buffer.count)\n    } else {\n      return nil\n    }\n  }\n}\n```", "```swift\nextension NSData {\n  var utf8string:String {\n    return String(data:self,\n     encoding:NSUTF8StringEncoding)!\n  }\n}\nextension String {\n  var utf8data:NSData {\n    return self.dataUsingEncoding(\n      NSUTF8StringEncoding, allowLossyConversion: false)!\n  }\n}\n```", "```swift\nextension String {\n  func fromHex() -> Int {\n    var result = 0\n    for c in self.characters {\n      result *= 16\n      switch c {\n      case \"0\":result += 0      case \"1\":result += 1\n      case \"2\":result += 2      case \"3\":result += 3\n      case \"4\":result += 4      case \"5\":result += 5\n      case \"6\":result += 6      case \"7\":result += 7\n      case \"8\":result += 8      case \"9\":result += 9\n      case \"a\",\"A\":result += 10 case \"b\",\"B\":result += 11\n      case \"c\",\"C\":result += 12 case \"d\",\"D\":result += 13\n      case \"e\",\"E\":result += 14 case \"f\",\"F\":result += 15\n      default: break\n      }\n    }\n    return result;\n  }\n}\nextension Int {\n  func toHex(digits:Int) -> String {\n    return String(format:\"%0\\(digits)x\",self)\n  }\n}\n```", "```swift\nextension NSOutputStream {\n  func writePacketLine(message:String = \"\") -> Int {\n    let data = message.utf8data\n    let length = data.length\n    if length == 0 {\n      return writeData(\"0000\".utf8data)\n    } else {\n      let prefix = (length + 4).toHex(4).utf8data\n      return self.writeData(prefix) + self.writeData(data)\n    }\n  }\n}\n```", "```swift\n> 004egit-upload-pack /alblue/com.packtpub.swift.essentials.git\\0host=github.com\\0\n< 00dfadaa46b98ce211ff819f0bb343395ad6a2ec6ef1 HEAD\\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed symref=HEAD:refs/heads/master agent=git/2:2.1.1+github-611-gd89bd9f\n< 003fadaa46b98ce211ff819f0bb343395ad6a2ec6ef1 refs/heads/master\n> 0000\n< 0000\n```", "```swift\nextension NSInputStream {\n  func readPacketLine() -> NSData? {\n    if let data = readData(4) {\n      let length = data.utf8string.fromHex()\n      if length == 0 {\n        return nil\n      } else {\n        return readData(length - 4)\n      }\n    } else {\n      return nil\n    }\n  }\n  func readPacketLineString() -> NSString? {\n    if let data = self.readPacketLine() {\n      return data.utf8string\n    } else {\n      return nil\n    }\n  }\n}\n```", "```swift\nclass RemoteGitRepository {\n  let host:String\n  let repo:String\n  let port:Int\n  init(host:String, repo:String, _ port:Int = 9418) {\n    self.host = host\n    self.repo = repo\n    self.port = port\n  }\n  func lsRemote() -> [String:String] {\n    var refs = [String:String]()\n    // load the data\n    return refs\n  }\n}\n```", "```swift\n// load the data\nif let (input,output) = NSStream.open(host,port) {\n  output.writePacketLine(\n   \"git-upload-pack \\(repo)\\0host=\\(host)\\0\")\n  while true {\n    if let response = input.readPacketLineString() {\n      let hash = String(response.substringToIndex(41))\n      let ref = String(response.substringFromIndex(41))\n      if ref.hasPrefix(\"HEAD\") {\n        continue\n      } else {\n        refs[ref] = hash\n      }\n    } else {\n      break\n    }\n  }\n  output.writePacketLine()\n  input.close()\n  output.close()\n}\n```", "```swift\nfunc runOnBackgroundThread(fn:()->()) {\n  dispatch_async(\n   dispatch_get_global_queue(\n    DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)\n   ,fn)\n}\n```", "```swift\nrunOnBackgroundThread {\n  let repo = RemoteGitRepository(host: \"github.com\", \n   repo: \"/alblue/com.packtpub.swift.essentials.git\")\n  for (ref,hash) in repo.lsRemote() {\n    self.items += [(ref,hash)]\n  }\n  self.runOnUIThread(self.tableView.reloadData)\n}\n```", "```swift\nclass func open(host:String,_ port:Int)\n -> (NSInputStream, NSOutputStream)? {\n  if let (input,output) = connect(host,port) {\n    input.open()\n    output.open()\n    return (input,output)\n  } else {\n    return nil\n  }\n}\nclass func connect(host:String,_ port:Int)\n  -> (NSInputStream, NSOutputStream)? {\n    var input:NSInputStream?\n    var output:NSOutputStream?\n    NSStream.getStreamsToHostWithName(\n      host, port: port, \n      inputStream: &input,\n      outputStream: &output)\n    guard let i = input, o = output else {\n      return nil\n    }\n    return (i,o)\n  } \n}\n```", "```swift\nclass PacketLineParser: NSObject, NSStreamDelegate {\n  let output:NSOutputStream\n  let callback:(NSString)->()\n  var capture:PacketLineParser?\n  init(_ output:NSOutputStream, _ callback:(NSString) -> ()) {\n    self.output = output\n    self.callback = callback\n    super.init()\n    capture = self\n  }\n  func stream(stream: NSStream, handleEvent: NSStreamEvent) {\n    let input = stream as! NSInputStream\n    if handleEvent == NSStreamEvent.HasBytesAvailable {\n      if let line = input.readPacketLineString() {\n        callback(line)\n      } else {\n        output.writePacketLine()\n        input.close()\n        output.close()\n        capture = nil\n      }\n    }\n  }\n}\n```", "```swift\nfunc stream(stream: NSStream, handleEvent: NSStreamEvent) {\n  let input = stream as! NSInputStream\n  if handleEvent == NSStreamEvent.HasBytesAvailable {\n    if let line = input.readPacketLineString() {\n      callback(line)\n    } else {\n      closeStreams(input,output)\n    }\n  }\n  if handleEvent == NSStreamEvent.EndEncountered \n || handleEvent == NSStreamEvent.ErrorOccurred {\n closeStreams(input,output)\n }\n}\nfunc closeStreams(input:NSInputStream,_ output:NSOutputStream) {\n  if capture != nil {\n    capture = nil\n    output.removeFromRunLoop(NSRunLoop.mainRunLoop(),\n     forMode: NSDefaultRunLoopMode)\n    input.removeFromRunLoop(NSRunLoop.mainRunLoop(),\n     forMode: NSDefaultRunLoopMode)\n    input.delegate = nil\n    output.delegate = nil\n    if output.streamStatus != NSStreamStatus.Closed {\n      output.writePacketLine()\n      output.close()\n    }\n    if input.streamStatus != NSStreamStatus.Closed {\n      input.close()\n    }\n  }\n}\n```", "```swift\nfunc lsRemoteAsync(fn:(String,String) -> ()) {\n  if let (input,output) = NSStream.connect(host,port) {\n    input.delegate = PacketLineParser(output) {\n    (response:NSString) -> () in\n      let hash = String(response.substringToIndex(41))\n      let ref = String(response.substringFromIndex(41))\n      if !ref.hasPrefix(\"HEAD\") {\n        fn(ref,hash)\n      }\n    }\n    input.scheduleInRunLoop(NSRunLoop.mainRunLoop(), \n     forMode: NSDefaultRunLoopMode)\n    input.open()\n    output.open()\n    output.writePacketLine(\n     \"git-upload-pack \\(repo)\\0host=\\(host)\\0\")\n  }\n}\n```", "```swift\n// for (ref,hash) in repo.lsRemote() {\n//   self.items += [(ref,hash)]\n// }\nrepo.lsRemoteAsync() { (ref:String,hash:String) in\n  self.items += [(ref,hash)]\n  self.runOnUIThread(self.tableView.reloadData)\n}\n```", "```swift\n…\nself.data = data\n// initial write to kick off subsequent events\ncompleted = output.write(UnsafePointer(data.bytes), \n maxLength: data.length\n…\nvar completed:Int\nvar data:NSData?\nfunc stream(stream: NSStream, handleEvent: NSStreamEvent) {\n  let output = stream as! NSOutputStream\n  if handleEvent == NSStreamEvent.HasSpaceAvailable \n   && data != nil {\n    let size = data!.length\n    completed += output.write(\n     UnsafePointer(data!.bytes) + completed,\n     maxLength: size – completed)\n    if completed == size {\n      completed = 0\n      data = nil\n    }\n  }\n}\n```"]