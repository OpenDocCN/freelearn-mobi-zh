<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Creating a HUD</h1></div></div></div><p>The <strong>Heads-Up Display</strong> (<strong>HUD</strong>) is a key technique <a id="id238" class="indexterm"/>that game designers use in order to provide information to the user. It's basically a set of graphics or text that are detached from the world itself and that are used to tell the player things such as how much life or <em>mana</em> they have left, or what their score is.</p><p>We're going to create a simple HUD that will give us really useful information such as the direction in which the character is going and its position in world coordinates. This will be enough to illustrate how to create a HUD. You will want to display more useful information in your own game. So let's go!</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec54"/>The basics</h1></div></div></div><p>Create a file called <code class="literal">hud.lua</code>, require it from <code class="literal">game.lua</code>, and let's start our module.</p><p>Our HUD implementation <a id="id239" class="indexterm"/>will be based on the idea that we don't want world coordinates to position objects that are not inside the world. Also, we're more used to designing layouts for <a id="id240" class="indexterm"/>UIs thinking about (0, 0) on the top-left corner and the <code class="literal">Y</code> axis growing downward.</p><p>So that's what we're going to do:</p><div><pre class="programlisting">module ( "HUD", package.seeall )
function HUD:initialize ()
    self.viewport = MOAIViewport.new ()</pre></div><p>It can be done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">In order to use a different coordinate system, we'll create a new viewport.<div><pre class="programlisting">    viewport:setSize ( SCREEN_RESOLUTION_X, SCREEN_RESOLUTION_Y )</pre></div></li><li class="listitem">This viewport will have the same size as the screen:<div><pre class="programlisting">   viewport:setScale  (SCREEN_RESOLUTION_X, -SCREEN_RESOLUTION_Y )</pre></div></li><li class="listitem">It won't use world coordinates. Instead, it will use screen coordinates, but we'll invert the <code class="literal">Y</code> axis so that it grows downward.<div><pre class="programlisting">    viewport:setOffset ( -1, 1 )</pre></div></li><li class="listitem">Now here's <a id="id241" class="indexterm"/>something new. The <code class="literal">setOffset</code> method<a id="id242" class="indexterm"/> is used to move the viewport using the projection space. The projection<a id="id243" class="indexterm"/> space is a 2 x 2 rectangle with its <code class="literal">Y</code> axis pointing upwards. Passing <code class="literal">-1</code> as the <code class="literal">X</code> value to <code class="literal">setOffset</code> moves this projection space half a screen to the left, and passing <code class="literal">1</code> as the <code class="literal">Y</code> value moves it half a screen to the top, achieving our goal of having the (0, 0) coordinate on the top-left corner.<div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>You can see here that this is pretty useful; you could move the (0, 0) to wherever you want and the positions will be calculated based on that.</p></div></div></li><li class="listitem">After this, we create a layer and load it into the render table like we're used to:<div><pre class="programlisting">    self.layer = MOAILayer2D.new ()
    self.layer:setViewport ( self.viewport )
    -- Now we need to render the layer.
    local renderTable = MOAIRenderMgr.getRenderTable ()
    table.insert ( renderTable, self.layer )
    MOAIRenderMgr.setRenderTable ( renderTable )
end</pre></div></li><li class="listitem">Add a call to <code class="literal">HUD:initialize ()</code> <a id="id244" class="indexterm"/>at the bottom of <code class="literal">Game:initialize</code> and you should be good to go.</li></ol></div><p>Now, we're ready to start creating our <code class="literal">HUD</code> elements.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Left or right, that's the question</h1></div></div></div><p>Now we're going to display our information<a id="id245" class="indexterm"/> on the screen:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, we need to define a font in <code class="literal">game.lua</code> inside the <code class="literal">resource_definitions</code> table.<p>We provided one with the source code for this chapter, but you can use whatever font you like:</p><div><pre class="programlisting">    hudFont ={
        type = RESOURCE_TYPE_FONT,
        fileName = 'fonts/tuffy.ttf',
    glyphs = 
    "abcdefghijklmnopqrstuvwxyzABCDEFGHI
    JKLMNOPQRSTUVWXYZ0123456789,.?!",
    fontSize = 26,
    dpi = 160
  }</pre></div><p>This should be familiar, since we talked about it in <a class="link" href="ch06.html" title="Chapter 6. Resource Manager">Chapter 6</a>, <em>Resource Manager</em>.</p><p>Now we know <code class="literal">hudFont</code> will reference our font.</p></li><li class="listitem">Let's go <a id="id246" class="indexterm"/>back to <code class="literal">hud.lua</code>, create a method called <code class="literal">initializeDebugHud</code>, <a id="id247" class="indexterm"/>and call it from <code class="literal">HUD:initialize</code>:<div><pre class="programlisting">function HUD:initializeDebugHud ()
    self.font = MOAIFont.new ()
    self.font = ResourceManager:get ( "hudFont" )</pre></div><p>We use the font resource that we've just created as the font for our textboxes:</p><div><pre class="programlisting">    self.leftRightIndicator = self:newDebugTextBox ( 30, {10, 10, 100, 50} )
    self.positionIndicator = self:newDebugTextBox ( 30, {10, 50, 200, 100} )
end</pre></div></li><li class="listitem">Then we call an auxiliary method that we will create in a moment. It will receive the font size and a rectangle where the text will be placed. The rectangle consists of the coordinates for the upper-left and bottom-right corners of the box:<div><ol class="orderedlist arabic"><li class="listitem">First of all, we create <code class="literal">MOAITextBox</code>. This is the class that will be used to display text. It inherits from <code class="literal">MOAIProp</code>, so you'll be able to move it, insert it into a layer, and do everything else you can do with <code class="literal">MOAIProp</code>:<div><pre class="programlisting">function HUD:newDebugTextBox ( size, rectangle )
    local textBox = MOAITextBox.new ()</pre></div></li><li class="listitem">We set the font we loaded previously:<div><pre class="programlisting">    textBox:setFont ( self.font )</pre></div></li><li class="listitem">Then we set the size using the <code class="literal">size</code> parameter:<div><pre class="programlisting">    textBox:setTextSize ( size )</pre></div><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>You can use multiple text styles in <code class="literal">MOAITextBox</code>; take a look at <code class="literal">setStyle</code> and <code class="literal">MOAITextStyle</code> in the documents.</p></div></div></li><li class="listitem">We split the <code class="literal">rectangle</code> table into parameters using <code class="literal">unpack</code>:<div><pre class="programlisting">    textBox:setRect ( unpack(rectangle) )</pre></div></li><li class="listitem">The rectangle defines a box on the screen to which the text is confined. Text won't render outside the rectangle defined using <code class="literal">setRect</code>.</li><li class="listitem">We insert the textbox in the HUD's layer.<div><pre class="programlisting">    layer:insertProp ( textBox )</pre></div></li><li class="listitem">And finally return the textbox, so it can be referenced later.<div><pre class="programlisting">    return textBox
end</pre></div></li></ol></div></li></ol></div><p>Now we <a id="id248" class="indexterm"/>have our <code class="literal">HUD</code> layer populated with the textboxes, but there is one more thing we need in order to finish our goal.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Updating information</h1></div></div></div><p>We need to write <a id="id249" class="indexterm"/>something into those textboxes. What we'll do in this case is call an <code class="literal">update</code> method in <code class="literal">HUD</code> periodically, so that it can refresh the data and print it on the screen:</p><div><pre class="programlisting">function HUD:update ()
    local x, y = Character.prop:getScl ()</pre></div><div><ol class="orderedlist arabic"><li class="listitem">We get the scale that we used to set the character's direction, and store it in a local variable <code class="literal">x</code>:<div><pre class="programlisting">    if x &gt; 0 then
        self.leftRightIndicator:setString ( "Left" )
    else
        self.leftRightIndicator:setString ( "Right" )
    end</pre></div></li><li class="listitem">If you remember what we did before, this should be pretty clear. In order to turn right we scaled the character's <code class="literal">prop</code> to <code class="literal">-1</code> in the <code class="literal">x</code> axis, and to <code class="literal">1</code> to turn the character to the left. So that's what we're doing here. If the <code class="literal">x</code> value of the scale is positive, then we're facing left. Otherwise, if it is <code class="literal">-1</code>, we're facing right. Then, depending on the case, we use <code class="literal">MOAITextBox:setString</code> to update the string with the correct direction.<div><pre class="programlisting">    x, y = Character.physics.body:getPosition ()
    self.positionIndicator:setString ("(" .. 
    math.floor(x) .. ", " .. 
    math.floor(y) .. ")")
end</pre></div></li><li class="listitem">Finally we update the textbox; we get the position from the physics body. Using the <code class="literal">..</code> operator to concatenate strings, we generate the correct string formatted as <code class="literal">(x, y)</code>. We then use <code class="literal">math.floor</code> to round down the position, since it's a decimal number.</li></ol></div><p>The only<a id="id250" class="indexterm"/> thing we need to do now is add a call to <code class="literal">HUD:update ()</code> on the <code class="literal">while</code> loop inside <code class="literal">Game:start</code> and we should see both debug strings on the screen.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>If you are uncertain about the size and layout of the boxes, you can use <code class="literal">MOAIDebugLines.setStyle(MOAIDebugLines.TEXT_BOX)</code> in order to debug them. This will display a line around each textbox.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter we learned the basics about how to implement a <code class="literal">HUD</code> with Moai SDK. We dug deeper into the <code class="literal">MOAIViewport</code> configuration in order to create a special viewport that used a different coordinate system than the one we've been using so far. We also displayed text for the first time using <code class="literal">MOAITextBox</code>.</p><p>In the next chapter, we'll dive into another important aspect of games: sound and music.</p></div></body></html>