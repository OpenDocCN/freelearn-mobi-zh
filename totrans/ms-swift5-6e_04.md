# 4

# 可选类型

当我开始使用 Swift 时，我最难以理解的概念是可选类型。由于我的背景是 Objective-C、C、Java 和 Python，我能够将 Swift 的许多功能与我了解的其他语言中的工作方式联系起来，但可选类型是不同的。当 Swift 首次发布时，我所使用的其他语言中几乎没有类似的可选类型，因此我花了很多时间去完全理解它们。

在本章中，我们将涵盖以下主题：

+   可选类型是什么？

+   为什么我们需要在 Swift 中使用可选类型？

+   如何解包可选类型

+   什么是可选绑定？

+   可选链是什么？

# 介绍可选类型

当我们在 Swift 中声明变量时，它们默认是非可选的，这意味着它们必须包含一个有效、非 nil 的值。如果我们尝试将非可选变量设置为 `nil`，将会导致错误。

例如，以下代码在尝试将 `message` 变量设置为 `nil` 时将抛出错误，因为它是一个非可选类型：

[PRE0]

非常重要的是要理解 Swift 中的 `nil` 与 Objective-C 或其他基于 C 的语言中的 `nil` 非常不同。在这些语言中，`nil` 是指向一个不存在对象的指针；然而，在 Swift 中，`nil` 值表示没有值。掌握这个概念对于完全理解 Swift 中的可选类型非常重要。

被定义为可选的变量可以包含一个有效值，或者它可以表示没有值。我们通过将其分配一个特殊的 `nil` 值来表示没有值。任何类型的可选都可以设置为 `nil`，而在 Objective-C 中，只有对象可以被设置为 `nil`。

要真正理解可选背后的概念，让我们看看定义可选类型的一行代码：

[PRE1]

行尾的问号表示 `myString` 变量是一个可选类型。我们读取这一行代码时，可以说 `myString` 变量是一个可选类型，它可能包含 `string` 类型的值，也可能不包含任何值。如何编写这一行对于理解可选的工作方式非常重要。

可选是 Swift 中的一个特殊类型。当我们定义 `myString` 变量时，我们实际上定义了它为一个可选类型。为了理解这一点，让我们看看一些更多的代码：

[PRE2]

这两个声明是等效的。两行都声明了一个可能包含 `String` 类型或可能没有值的可选类型。在 Swift 中，我们可以将值的缺失视为设置为 `nil`，但始终记住这与在 Objective-C 中将某物设置为 `nil` 是不同的。在这本书中，当我们提到 `nil` 时，我们是指 Swift 如何使用 `nil`，而不是 Objective-C 如何使用 `nil`。

可选类型是一个有两个可能值的枚举，`None`和`Some(T)`，其中`T`是与可选相关联的泛型值。我们将在*第11章*，*泛型*中讨论泛型。如果我们将可选设置为`nil`，它将具有`None`的值，如果我们设置一个值，可选将具有`Some`的值，并带有相关联的适当类型的值。在*第3章*，*了解变量、常量、字符串和运算符*中，我们解释了Swift中的枚举可能具有关联值。关联值允许我们在枚举成员值中存储额外的信息。

在内部，可选类型被定义为如下：

[PRE3]

在这里，`T`是与可选相关联的类型。`T`符号用于定义泛型，可以用来表示任何类型。

# Swift中可选类型的需求

现在，一个迫切的问题：为什么Swift需要可选类型？为了理解这个问题，我们应该检查可选类型旨在解决哪些问题。

在大多数语言中，可以在不提供初始化值的情况下创建一个变量。例如，在Objective-C中，这两行代码都是有效的：

[PRE4]

现在，假设用Objective-C编写的`MyObject`类有以下方法：

[PRE5]

此方法接受从`i`参数传递的值，将其乘以二，并返回结果。让我们尝试使用以下代码调用此方法：

[PRE6]

我们的第一反应可能认为此代码将显示`Value: 10`，因为我们传递了`5`的值给一个将值加倍的方法；然而，这是不正确的。实际上，此代码将显示`Value: 0`，因为我们没有在使用之前初始化`m`对象。

当我们忘记初始化一个对象或为变量设置值时，我们可能会在运行时得到意外的结果，就像我们刚才演示的那样。有时，这些意外的结果可能非常难以追踪。

使用可选类型，Swift能够在编译时检测到此类问题，并在它成为运行时问题之前提醒我们。如果我们期望在使用之前变量或对象始终包含一个值，我们将变量声明为非可选（这是默认声明）。然后，如果我们尝试在使用之前初始化它，我们将收到一个错误。让我们看看这个例子。以下代码将显示一个错误，因为我们试图在使用之前使用一个非可选变量：

[PRE7]

如果一个变量被声明为可选，在尝试使用它之前验证它是否包含一个有效值是良好的编程实践。我们只应该将变量声明为可选，如果存在一个合理的理由让变量不包含值。这就是Swift默认将变量声明为非可选的原因。

现在我们对可选类型及其旨在解决的问题有了更好的理解，让我们看看如何使用它们。

# 定义可选类型

需要注意的一件事是，我们在变量声明中定义的类型实际上是可选枚举中的关联值。以下代码显示了我们会如何通常声明一个可选值：

[PRE8]

这段代码声明了一个可能包含字符串或可能不包含值的可选变量。当声明此类变量时，默认情况下它被设置为nil。既然我们已经看到了如何定义可选值，让我们看看我们如何使用它。

# 使用可选值

使用可选值的关键是始终在访问之前验证它们是否包含有效值。这样做的原因是，如果我们尝试使用未验证是否包含有效值的可选值，我们可能会遇到运行时错误，导致我们的应用程序崩溃。我们使用术语解包来指代从可选值中检索值的过程。我们将介绍两种用于检索可选值的方法；请记住，使用可选绑定是首选的。

## 可选值的强制解包

要解包或检索可选值的值，我们在变量名后放置一个感叹号（`!`）。这被称为强制解包。以这种方式进行的强制解包非常危险，只有在确定变量包含非nil值时才应使用。否则，如果它包含nil值，我们将得到运行时错误，应用程序将崩溃。

当我们使用感叹号来解包可选值时，我们是在告诉编译器我们知道可选值包含一个值，所以请继续给我们。让我们看看如何做到这一点：

[PRE9]

这段代码将按预期工作，其中`test`变量将包含字符串`"test"`；然而，如果设置`myString1`可选值为`test`的行被删除，当应用程序运行时，我们将收到运行时错误。请注意，编译器不会提醒我们问题，因为我们正在使用感叹号来解包可选值；因此，编译器假设我们知道我们在做什么，并会愉快地为我们编译代码。在解包之前，我们应该验证`myString1`可选值是否包含有效值。以下示例是这样做的一种方式：

[PRE10]

现在，如果设置`myString1`可选值为`test`的行被删除，我们不会收到运行时错误，因为我们只有在`myString1`可选值包含有效（非nil）值时才会解包它。

解包可选值，正如我们刚才所描述的，并不是最佳做法，也不建议以这种方式解包可选值。我们可以将验证和解包合并为一步，称为可选绑定。

## 可选绑定

可选绑定是推荐的方式来解包可选值。使用可选绑定，我们执行一个检查以查看可选值是否包含有效值，如果是这样，就将其解包到一个临时变量或常量中。这一切都在一步中完成。

可选绑定使用`if`或`while`条件语句执行。如果我们想将可选类型的值放入一个常量中，它将采取以下格式：

[PRE11]

如果我们需要将值放入变量中，而不是常量，我们可以使用`var`关键字，如下例所示：

[PRE12]

以下示例展示了如何执行可选绑定：

[PRE13]

在示例中，我们将`myString3`变量定义为可选类型。如果`myString3`可选类型包含一个有效值，新变量`tempvar`将被设置为该值并打印到控制台。如果`myString3`可选类型不包含值，则控制台将打印`No value`。

我们能够在同一可选绑定行中解包多个可选类型。例如，如果我们有三个名为`optional1`、`optional2`和`optional3`的可选类型，我们可以使用以下代码一次性尝试解包所有三个：

[PRE14]

如果其中任何一个可选类型是`nil`，整个可选绑定语句将失败。使用可选绑定将值赋给同名的变量也是完全可以接受的。以下代码说明了这一点：

[PRE15]

注意一点是，临时变量仅限于条件块的作用域，不能在块外使用。为了说明临时变量的作用域，让我们看看以下代码：

[PRE16]

此代码将无法编译，因为`tmp`变量仅在条件块内有效，而我们试图在块外使用它。

使用可选绑定比手动验证可选类型是否有值并使用强制解包来检索可选类型的值要干净和简单得多。我们可以以不同的方式使用元组中的可选类型，让我们来看看这些。

## 元组中的可选类型

我们可以将整个元组定义为可选类型，或者将元组中的任何元素定义为可选类型。当从函数或方法返回元组时，使用可选类型与元组一起特别有用。这允许我们将元组的部分（或全部）作为`nil`返回。以下示例展示了如何将元组定义为可选类型，以及如何将元组的单个元素定义为可选类型：

[PRE17]

第一行定义整个元组为一个可选类型。第二行定义元组中的第二个值为可选，而第一个值不是可选的。

## 可选链

可选链允许我们在可能为`nil`的可选类型上调用属性、方法和下标。如果链中的任何值返回`nil`，则返回值将为`nil`。以下代码给出了使用虚构的`car`对象进行可选链的示例。在这个例子中，如果`car`或`tires`可选变量中的任何一个为`nil`，则`tireSize`变量将为`nil`，否则`tireSize`变量将等于`tireSize`属性：

[PRE18]

我们将在第8章“类、结构和协议”中再次探讨可选链。

## 空合并运算符

空合并运算符与我们在*第3章*，*了解变量、常量、字符串和运算符*中讨论的三元运算符类似。三元运算符根据比较运算符或布尔值的评估给变量赋值。空合并运算符尝试展开一个可选值，如果它包含一个值，它将返回该值，或者在可选值为nil时返回默认值，如下面的代码所示。

让我们看看空合并运算符的原型：

[PRE19]

在这个例子中，我们演示了当可选值为nil以及它包含值时如何使用空合并运算符：

[PRE20]

在这个例子中，我们首先将`defaultName`变量初始化为`Jon`。然后我们定义了两个可选值，分别命名为`optionalA`和`optionalB`。`optionalA`变量被设置为nil，而`optionalB`变量被设置为`Buddy`。

空合并运算符用于最后两行。由于`optionalA`变量包含nil，`nameA`变量将被设置为`defaultName`变量的值，即`Jon`。`nameB`变量将被设置为`optionalB`变量的值，因为它包含一个值。

空合并运算符是以下使用三元运算符的简写：

[PRE21]

如我们所见，空合并运算符比等效的三元运算符更简洁、更容易阅读。

## 摘要

在本章中，我们描述了可选值实际上是什么以及它们在Swift语言内部是如何定义的。理解这个概念很重要，因为可选值在Swift中使用得很多，了解它们是如何在内部工作的将有助于你正确地使用它们。虽然Swift语言中使用的可选类型的概念一开始可能有些令人困惑，但随着你使用它们的次数越多，它们就会变得更有意义。可选类型的一个最大优点是额外的编译时检查，它会提醒我们在使用之前忘记初始化非可选值。我们将在本书的后面部分看到更多关于可选值的示例。

在下一章中，我们将探讨如何使用集合。
