<html><head></head><body>
		<div><h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor293"/>Chapter 9</em>: Implementing Dependency Injection with Jetpack Hilt</h1>
			<p>In this chapter, we're continuing our journey of improving the architectural design of the Restaurants app. More precisely, we will be incorporating <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) in our project.</p>
			<p>In the first section, <em class="italic">What is DI?</em>, we will start by defining DI and understanding its basic concepts, from what a dependency is, the types of dependencies, and what injection represents, through to concepts such as dependency containers and manual injection.</p>
			<p>Afterward, in the <em class="italic">Why is DI needed?</em> section, we will focus in more detail on the benefits that DI brings to our projects.</p>
			<p>In the last section, <em class="italic">Implementing DI with Hilt</em>, we will first understand how the Jetpack Hilt DI library works, and how to use it, and finally, with its help, we will incorporate DI in our Restaurants app.</p>
			<p>To summarize, in this chapter we will be covering the following sections:</p>
			<ul>
				<li>What is DI?</li>
				<li>Why is DI needed?</li>
				<li>Implementing DI with Hilt</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor294"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter would usually require your day-to-day tools; however, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_08</code> directory of the repository and importing the Android project entitled <code>chapter_8_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_09</code> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app</a>.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor295"/>What is DI?</h1>
			<p>In simple terms, <strong class="bold">DI</strong> represents the concept<a id="_idIndexMarker665"/> of providing the instances of the dependencies that a class needs, instead of having it construct them itself. But, what are dependencies?</p>
			<p><code>ExampleViewModel</code> class could contain a <code>repository</code> variable of type <code>Repository</code>:</p>
			<pre>class ExampleViewModel {
    private val repository: Repository = Repository()
    fun doSomething() {
        repository.use()
    }
}</pre>
			<p>That's why <code>ExampleViewModel</code> depends on <code>Repository</code>, or <code>Repository</code> is a dependency for <code>ExampleViewModel</code>. Most of the time, classes have many more dependencies, but we'll stick with only one for the sake<a id="_idIndexMarker667"/> of simplicity. In this case, the <code>ExampleViewModel</code> provides its own dependencies so it's very easy to create an instance of it:</p>
			<pre>fun main() {
    val vm = ExampleViewModel()
    vm.doSomething()
}</pre>
			<p>Now, the previous example doesn't incorporate DI, mainly because <code>ExampleViewModel</code> provides instances for its own dependencies. It does that by instantiating a <code>Repository</code> instance (through the <code>Repository()</code> constructor) and by passing it to the <code>repository</code> variable.</p>
			<p>To incorporate DI, we must create a component that provides <code>ExampleViewModel</code> with its dependencies:</p>
			<pre>object DependencyContainer {
    val repo: Repository = Repository()
}</pre>
			<p>The <code>DependencyContainer</code> class will act, as the name suggests, as a <strong class="bold">dependency container</strong>, as it will provide instances for all the dependencies<a id="_idIndexMarker668"/> our classes need. When a class needs an instance for its dependency, this container will provide it. This way, we centralize the creation of the instances of dependencies so we can handle this process (which can become elaborate for complex projects where each dependency has other dependencies, for example) within a single place in our project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Apart from the DI<a id="_idIndexMarker669"/> technique, you can also use the <code>ServiceLocator</code> component. Both DI and the service locator pattern are useful; however, we will only cover DI in this chapter.</p>
			<p>Getting back to incorporating DI, we then must allow <code>DependencyContainer</code> to provide a <code>Repository</code> instance to <code>ExampleViewModel</code>:</p>
			<pre>class ExampleViewModel {
    private val repository: Repository = 
        <strong class="bold">DependencyContainer.repo</strong>
    fun doSomething() {
        repository.use()
    }
}</pre>
			<p>This technique of having dependencies<a id="_idIndexMarker670"/> declared as variables (for example, <code>ExampleViewModel</code> contains a <code>repository</code> variable) and then providing their instances<a id="_idIndexMarker671"/> through a container is a form of DI called <strong class="bold">field injection</strong>.</p>
			<p>There are several issues with this approach, mainly caused by the fact that we have declared dependencies as field variables. The most notable ones are as follows:</p>
			<ul>
				<li>The <code>ExampleViewModel</code> class is tightly coupled to our <code>DependencyContainer</code> and we cannot use the <code>ViewModel</code> without it.</li>
				<li>The dependencies are <code>ExampleViewModel</code> doesn't know about the <code>ViewModel</code> class's dependencies or their creation.</li>
			</ul>
			<p>This won't allow us to reuse the same <code>ExampleViewModel</code> with other implementations of its dependencies (given its dependencies, such as <code>Repository</code>, are interfaces that can be implemented by different classes).</p>
			<ul>
				<li>Since <code>ExampleViewModel</code> has hidden dependencies, it becomes hard for us to test it. As we will instantiate the <code>ExampleViewModel</code> and put it under test, it will create its own <code>Repository</code> instance that will probably make real I/O requests for every test. We want our tests to be fast and reliable and not dependent on real third-party APIs.</li>
			</ul>
			<p>To alleviate these issues, we must first refactor <code>ExampleViewModel</code> to expose its dependencies through its public API to the outside world. The most appropriate<a id="_idIndexMarker673"/> way to do that is through its public <code>constructor</code>:</p>
			<pre>class ExampleViewModel <strong class="bold">constructor</strong>(<strong class="bold">private val repo: Repository</strong>) {
    fun doSomething() { repo.use() }
}</pre>
			<p>Now, <code>ExampleViewModel</code> exposes its dependencies to the outside world through its constructor, making those<a id="_idIndexMarker674"/> dependencies <strong class="bold">explicit</strong>. Yet, who's going to provide the dependencies from outside?</p>
			<p>When we need to instantiate <code>ExampleViewModel</code>, <code>DependencyContainer</code> will provide it with the necessary dependencies from the outside:</p>
			<pre>fun main() {
<strong class="bold">    val repoDependency = DependencyContainer.repository</strong>
<strong class="bold">    </strong>val vm = ExampleViewModel(<strong class="bold">repoDependency</strong>)
<strong class="bold">    </strong>vm.doSomething()
}</pre>
			<p>In the previous example, instead of field injection, we have used <code>ExampleViewModel</code> from the outside world through its constructor.</p>
			<p>As opposed to field injection, constructor injection allows us to do the following:</p>
			<ul>
				<li>Decouple our classes from the DI container, just like <code>ExampleViewModel</code> no longer depends on <code>DependencyContainer</code>.</li>
				<li>The dependencies are exposed to the outside world, so we can reuse the same <code>ExampleViewModel</code> with other implementations of <code>Repository</code> (given <code>Repository</code> is an interface).</li>
				<li>The <code>ExampleViewModel</code> class can no longer decide which dependency implementation to get and use as was the case with field injection, so we have now inverted this responsibility from <code>ExampleViewModel</code> to the outside world.</li>
				<li><code>ExampleViewModel</code> is easier to test, as we can easily pass a mock or a fake <code>Repository</code> implementation (given <code>Repository</code> is an interface) that will behave the way we're expecting it to in a test.</li>
			</ul>
			<p>So far, with the help of a dependency<a id="_idIndexMarker676"/> container, we have incorporated DI by ourselves by allowing <code>DependencyContainer</code> to provide instances of dependencies<a id="_idIndexMarker677"/> to our classes (that is, an instance of <code>ExampleViewModel</code>). This technique is called <strong class="bold">manual DI</strong>.</p>
			<p>Apart from manual DI, you can have DI done automatically through frameworks that relieve you from the burden of the following:</p>
			<ul>
				<li>Providing instances of dependencies to the classes that need them. More specifically, frameworks help you wire up complex object relationships for the required dependencies, so you don't have to write boilerplate code to generate instances and pass them to appropriate objects. This infrastructure code is often cumbersome for large-sized apps, so a framework that automates that for you can be quite handy.</li>
				<li>Scoping dependencies to certain lifetime scopes, such as the <code>Application</code> scope or <code>Activity</code> scope. For example, if you want a certain dependency to be a singleton (to be scoped to the lifetime of the application), you must manually make sure that only one instance is created in memory while also avoiding concurrency issues due to concurrent access. A framework can do that for you behind the scenes.</li>
			</ul>
			<p>In Android, a very simple DI library is <strong class="bold">Hilt</strong>, and we will explore<a id="_idIndexMarker678"/> it in the <em class="italic">Implementing DI with Hilt</em> section. But until then, let's better understand why DI is needed in the first place.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor296"/>Why is DI needed?</h1>
			<p>DI is not a must for all projects. Until now, our Restaurants app<a id="_idIndexMarker679"/> worked just fine without any DI incorporated. Yet, while not including DI might not seem like a big issue, by incorporating it you bring a lot of benefits to your project; the most notable advantages are that you can do the following:</p>
			<ul>
				<li>Write less boilerplate code.</li>
				<li>Write testable classes.</li>
			</ul>
			<p>Let's cover these two next.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor297"/>Write less boilerplate code</h2>
			<p>Let's circle back to our Restaurants app, and let's have a look<a id="_idIndexMarker680"/> at how we instantiate the Retrofit interface within the <code>RestaurantsRepository</code> class:</p>
			<pre>class RestaurantsRepository {
<strong class="bold">    private var restInterface: RestaurantsApiService =</strong>
<strong class="bold">        Retrofit.Builder()</strong>
<strong class="bold">             .addConverterFactory(</strong>
<strong class="bold">                 GsonConverterFactory.create())</strong>
<strong class="bold">             .baseUrl("your_firebase_database_url")</strong>
<strong class="bold">            .build()</strong>
<strong class="bold">            .create(RestaurantsApiService::class.java)</strong>
    [...]
}</pre>
			<p>Now, let's have a look at how we similarly instantiate the Retrofit<a id="_idIndexMarker681"/> interface within the <code>RestaurantsDetailsViewModel</code> class:</p>
			<pre>class RestaurantDetailsViewModel(…): ViewModel() {
    private var <strong class="bold">restInterface: RestaurantsApiService</strong>
    [...]
    init {
        <strong class="bold">val retrofit: Retrofit = Retrofit.Builder()</strong>
<strong class="bold">            .addConverterFactory(GsonConverterFactory.create())</strong>
<strong class="bold">            .baseUrl("your_firebase_database_url")</strong>
<strong class="bold">            .build()</strong>
        <strong class="bold">restInterface = retrofit</strong>
<strong class="bold">            .create(RestaurantsApiService::class.java)</strong>
        [...]
    }
    [...]
}</pre>
			<p>While the code seems different, in essence, it's the same code needed to instantiate a concrete instance of <code>RestaurantsApiService</code>. Unfortunately, we have duplicated this instantiation code in two places, both in the <code>RestaurantsRepository</code> class and in the <code>RestaurantsDetailsViewModel</code> class.</p>
			<p>In medium to large-sized production apps, the relationship between objects is often much more complex, making such infrastructure code plague every class, mostly because, without any DI, every class builds the instances of the dependencies it needs. Such code is often duplicated throughout the project and ultimately becomes difficult to manage.</p>
			<p>DI will help us centralize this infrastructure code and will eliminate all the duplicated code needed to provide instances of dependencies, wherever we need them throughout the project.</p>
			<p>Going back to our Restaurants app, if we were to use manual DI, all this instantiation code could be extracted into a <code>DependencyContainer</code> class that would provide us with a <code>RestaurantsApiService</code> instance wherever we need it, so we would have no more duplicated code! Don't worry, we will incorporate DI soon, in the upcoming <em class="italic">Implementing DI with Hilt</em> section.</p>
			<p>Now that we touched<a id="_idIndexMarker682"/> upon how DI helps us with containing and organizing the code related to building instances of classes, it's time to check out another essential advantage of DI.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor298"/>Write testable classes</h2>
			<p>Let's suppose that we want to test the behavior of <code>RestaurantsRepository</code> to make sure that it performs<a id="_idIndexMarker683"/> as expected. But first, let's have a quick look at the existing implementation of <code>RestaurantsRepository</code>:</p>
			<pre>class RestaurantsRepository {
    <strong class="bold">private var restInterface: RestaurantsApiService =</strong> 
        <strong class="bold">Retrofit.Builder()</strong>
            <strong class="bold">.[...]</strong>
            <strong class="bold">.create(RestaurantsApiService::class.java)</strong>
    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong>
<strong class="bold">        .getDaoInstance(</strong>
<strong class="bold">            RestaurantsApplication.getAppContext()</strong>
<strong class="bold">        )</strong>
    suspend fun toggleFavoriteRestaurant(…) = {…}
    suspend fun getRestaurants(): List&lt;Restaurant&gt; {…}
    [...]
}</pre>
			<p>We can see that no DI is currently incorporated, as <code>RestaurantsRepository</code> has two implicit dependencies: an instance of <code>RestaurantsApiService</code> and an instance of <code>RestaurantsDao</code>. The <code>RestaurantsRepository</code> provides<a id="_idIndexMarker684"/> instances to its own dependencies, first by constructing a <code>Retrofit.Builder()</code> object and creating the concrete instance by calling <code>.create(…)</code>.</p>
			<p>Now, let's say we want to test this <code>RestaurantsRepository</code> class, and make sure that it behaves correctly by running different verifications. Let's imagine how such a test class would look:</p>
			<pre>class RestaurantsRepositoryTest {
    @Test
    fun repository_worksCorrectly() {
        val repo = RestaurantsRepository()
        assertNotNull(repo)
        // Perform other verifications
    }
}</pre>
			<p>The previous test structure is simple: we created a <code>RestaurantsRepository</code> instance by using its constructor and then we saved it inside a <code>repo</code> variable. We then asserted that the instance of the <code>Repository</code> is not <code>null</code>, so we can proceed with testing its behavior.</p>
			<p>This is optional, yet if you're trying to write the previous test class and follow this process, make sure that the <code>RestaurantsRepositoryTest</code> class is placed inside the <code>test</code> directory of the application:</p>
			<div><div><img src="img/B17788_09_1.jpg" alt="Figure 9.1 – Placement of test classes in the project structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Placement of test classes in the project structure</p>
			<p>Now, if we would to run this test, it will throw an exception<a id="_idIndexMarker685"/> before having the chance to verify anything. The stack trace would look like this:</p>
			<div><div><img src="img/B17788_09_2.jpg" alt="Figure 9.2 – Stack trace of running invalid test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Stack trace of running invalid test</p>
			<p>This happens because we're trying to write a small test for <code>RestaurantsRepository</code> but this class is not yet testable (in fact, we're trying to perform a Unit test – we will tackle this in more detail in <a href="B17788_10_ePub.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, <em class="italic">Test Your App with UI and Unit Tests</em>).</p>
			<p>But, why is our simple test throwing <code>UninitializedPropertyAccessException</code>?</p>
			<p>If we have a look at the stack trace, we can see that the crash is caused because our test is trying to obtain the application context through <code>getAppContext()</code> from the <code>RestaurantsApplication</code> class.</p>
			<p>It makes sense because, if we have another look at <code>RestaurantsRepository</code>, we can see that to obtain the <code>restaurantsDao</code> instance, the <code>Repository</code> calls <code>RestaurantsDb.getDaoInstance()</code> that initializes the Room database, and it needs an instance of <code>Context</code> to do that:</p>
			<pre>class RestaurantsRepository {
    […]
    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong>
<strong class="bold">        .getDaoInstance(</strong>
<strong class="bold">            RestaurantsApplication.getAppContext()</strong>
<strong class="bold">        )</strong>
    suspend fun toggleFavoriteRestaurant(…) = {…}
    suspend fun getRestaurants(): List&lt;Restaurant&gt; {…}
    [...]
}</pre>
			<p>Our small test shouldn't need a <code>Context</code> object, simply because it should neither try to create a Room database<a id="_idIndexMarker686"/> nor to create a Retrofit client instance; it shouldn't even depend on these concrete implementations. This is not efficient for small tests simply because such operations are memory-expensive and will do nothing but slow down our tests.</p>
			<p>Moreover, we don't want our small test (that should run with much ease and very fast, several times in a short time frame) to make Room queries or, even worse, network requests through Retrofit, simply because the tests are dependent on the external world and so they become expensive and difficult to automate.</p>
			<p>If, however, we would have had DI in place with constructor injection, we could have created our own classes that <em class="italic">fake</em> the behavior, ultimately making our <code>Repository</code> class easy to test and independent of concrete implementations that perform heavy I/O operations. We'll cover more about tests and <em class="italic">faking</em> in <a href="B17788_10_ePub.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, <em class="italic">Test Your App with UI and Unit Tests</em>.</p>
			<p>Going back to our app, we're not yet ready to write tests, because as you could see, we're lacking DI in our project. Now that we've seen that, without DI, life is somehow tough, let's learn how we can incorporate DI in the Restaurants app with the help of the Hilt library!</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor299"/>Implementing DI with Hilt</h1>
			<p>DI libraries are often used to simplify<a id="_idIndexMarker687"/> and accelerate the incorporation of DI<a id="_idIndexMarker688"/> in our projects, especially when the infrastructure code required by manual DI gets difficult to manage in large projects. </p>
			<p><strong class="bold">Hilt</strong> is a DI library that is part of Jetpack, and it removes the unnecessary boilerplate involved in manual dependency injection in Android apps by generating the code and the infrastructure that you otherwise<a id="_idIndexMarker689"/> would have had to develop<a id="_idIndexMarker690"/> manually.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Hilt is a DI library based on another popular DI framework called <strong class="bold">Dagger</strong>, meaning that they are strongly related, so we will often<a id="_idIndexMarker691"/> refer to Hilt as <em class="italic">Dagger Hilt</em> in this chapter. Due to the steep learning curve of the Dagger APIs, Hilt was developed as an abstraction layer over Dagger to allow easier adoption of automated DI in Android projects.</p>
			<p>Dagger Hilt relies on annotation processors to automatically generate code at build time, making it able to create and optimize the process of managing and providing dependencies throughout your project. Because of that, its core concepts are strongly connected to the use of annotations, so before we start adding and implementing Hilt in our Restaurants app, we must first cover a few concepts to better understand how Dagger Hilt works.</p>
			<p>To summarize, in this section we will be doing the following:</p>
			<ul>
				<li>Understanding the basics of Dagger Hilt</li>
				<li>Setting up Hilt</li>
				<li>Using Hilt for DI</li>
			</ul>
			<p>Let's begin!</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor300"/>Understanding the basics of Dagger Hilt</h2>
			<p>Let's analyze the three most important<a id="_idIndexMarker692"/> concepts and their corresponding annotations that we're required to work with to enable automatic DI in our project:</p>
			<ul>
				<li>Injection</li>
				<li>Modules</li>
				<li>Components</li>
			</ul>
			<p>Let's start with injection!</p>
			<h3>Injection</h3>
			<p>Dagger Hilt needs to know the type<a id="_idIndexMarker693"/> of instances we want it to provide us with. When we discussed manual constructor injection, we initially wanted <code>ExampleViewModel</code> to be injected wherever we needed it, and we used a <code>DependencyContainer</code> class for that.</p>
			<p>If we want Dagger Hilt to inject instances of a class somewhere, we must first declare a variable of that type and annotate it with the <code>@Inject</code> annotation.</p>
			<p>Let's say that inside the <code>main()</code> function used for the manual DI example, we no longer want to use manual DI to get an instance of <code>ExampleViewModel</code>. Instead, we want Dagger to instantiate this class. That's why we will annotate the <code>ExampleViewModel</code> variable with the Java <code>@Inject</code> annotation and refrain from instantiating the <code>ViewModel</code> class by ourselves. Dagger Hilt should do that for us now:</p>
			<pre>import javax.inject.Inject
<strong class="bold">@Inject</strong>
val vm: ExampleViewModel
fun main() {
    vm.doSomething()
}</pre>
			<p>Now, for Dagger Hilt to know how to provide us with an instance of the <code>ExampleViewModel</code> class, we must also add the <code>@Inject</code> annotation to the dependencies of <code>ExampleViewModel</code> so that Dagger knows how to instantiate the <code>ViewModel</code> class.</p>
			<p>Since the dependencies of <code>ExampleViewModel</code> are inside the constructor (from when we used manual constructor injection), we can directly add the <code>@Inject</code> annotation to <code>constructor</code>:</p>
			<pre>class ExampleViewModel <strong class="bold">@Inject</strong> constructor(private val repo:Repository) {
    fun doSomething() { repo.use() }
}</pre>
			<p>Now, Dagger Hilt also needs<a id="_idIndexMarker694"/> to know how to inject the dependencies of <code>ExampleViewModel</code>, more precisely the <code>Repository</code> class.</p>
			<p>Let's consider that <code>Repository</code> has only one dependency, a <code>Retrofit</code> constructor variable. For Dagger to know how to inject a <code>Repository</code> class, we must annotate its constructor with <code>@Inject</code> as well:</p>
			<pre>class Repository <strong class="bold">@Inject</strong> constructor(val retrofit: Retrofit){
    fun use() { retrofit.baseUrl() }
}</pre>
			<p>Until now, we got away with <code>@Inject</code> annotations because we had access to the classes and dependencies that we were trying to inject, but now, how can Dagger know how to provide us with a <code>Retrofit</code> instance? We have no way of tapping inside the <code>Retrofit</code> class and annotating its constructor with <code>@Inject</code>, since it's in an external library.</p>
			<p>To instruct Dagger on how to provide us with specific dependencies, let's learn a bit about modules!</p>
			<h3>Modules</h3>
			<p><code>@Module</code> that allow us to instruct Dagger Hilt on how to provide<a id="_idIndexMarker695"/> dependencies. For example, we need Dagger Hilt to provide us with a <code>Retrofit</code> instance in our <code>Repository</code>, so we could define a <code>DataModule</code> class that tells Dagger Hilt how to do so:</p>
			<pre>@Module
object DataModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder().baseUrl("some_url").build()
    }
}</pre>
			<p>To tell the library how to provide<a id="_idIndexMarker696"/> us with a dependency, we must create a method inside the <code>@Module</code> annotated class where we manually build that class instance.</p>
			<p>Since we don't have access to the <code>Retrofit</code> class and we need it injected, we've created a <code>provideRetrofit()</code> method (you can call it any way you want) annotated with the <code>@Provides</code> annotation, and that returns a <code>Retrofit</code> object. Inside the method, we manually created the <code>Retrofit</code> instance the way we needed it to be built.</p>
			<p>Now, Dagger Hilt knows how to provide us with all the dependencies our <code>ExampleViewModel</code> needs (its direct <code>Repository</code> dependency and <code>Repository</code> <code>Retrofit</code> dependency). Yet, Dagger will complain that it needs a component class in which the module we've created must be installed.</p>
			<p>Let's have a brief look at components next!</p>
			<h3>Components</h3>
			<p><strong class="bold">Components</strong> are interfaces that represent the container for a certain set of dependencies. A component<a id="_idIndexMarker697"/> takes in modules and makes sure that the injection of its dependencies happens with respect to a certain lifecycle.</p>
			<p>For our example with the <code>ExampleViewModel</code>, <code>Repository</code>, and <code>Retrofit</code> dependencies, let's say that we create a component that manages the creation for these dependencies.</p>
			<p>With Dagger Hilt, you can define a component with the <code>@DefineComponent</code> annotation:</p>
			<pre>@DefineComponent()
interface MyCustomComponent(…) { /* component build code */ }</pre>
			<p>Afterward, we could install our <code>DataModule</code> in this component:</p>
			<pre>@Module
<strong class="bold">@InstallIn(MyCustomComponent::class)</strong>
object DataModule {
    @Provides
    fun provideRetrofit(): Retrofit { […] }
}</pre>
			<p>In practice though, the process of defining and building a component is more complex than that. This is because a component<a id="_idIndexMarker698"/> must scope its dependencies to a certain lifetime scope (such as the lifetime of the application) and have a pre-existent parent component.</p>
			<p>Luckily, Hilt provides components for us out of the box. Such predefined components allow us to install modules in them and to scope dependencies to their corresponding lifetime scope.</p>
			<p>Some of the most important predefined components are as follows: </p>
			<ul>
				<li><code>SingletonComponent</code>: Allows us to scope dependencies to the lifetime of the application, as singletons, by annotating them with the <code>@Singleton</code> annotation. Every time a dependency annotated with <code>@Singleton</code> is requested, Dagger will provide the same instance.</li>
				<li><code>ActivityComponent</code>: Allows us to scope dependencies to the lifetime of an <code>Activity</code>, with the <code>@ActivityScoped</code> annotation. If the <code>Activity</code> is recreated, a new instance of the dependency will be provided.</li>
				<li><code>ActivityRetainedComponent</code>: Allows us to scope dependencies to the lifetime of an <code>Activity</code>, surpassing its recreation upon orientation change, with the <code>@ActivityRetainedScoped</code> annotation. If the <code>Activity</code> is recreated upon orientation change, the same instance of the dependency is provided.</li>
				<li><code>ViewModelComponent</code>: Allows us to scope dependencies to the lifetime of a <code>ViewModel</code>, with the <code>@ViewModelScoped</code> annotation.</li>
			</ul>
			<p>As the lifetime scope of these components varies, this also translates into the fact that each component derives its lifetime scope from each other, from the widest <code>@Singleton</code> lifetime scope (of the application) to narrower scopes such as <code>@ActivityScoped</code> (of an <code>Activity</code>):</p>
			<div><div><img src="img/B17788_09_3.jpg" alt="Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their corresponding components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their corresponding components</p>
			<p>While in our Restaurants app, we will mostly be using <code>SingletonComponent</code> and its <code>@Singleton</code> scope annotation; it's important to note that Dagger Hilt<a id="_idIndexMarker699"/> exposes a broader variety of predefined components<a id="_idIndexMarker700"/> and scopes. Check them out in the documentation here: <a href="https://dagger.dev/hilt/components.html">https://dagger.dev/hilt/components.html</a>.</p>
			<p>Now that we've briefly covered components, it's time to add Hilt to our Restaurants app!</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor301"/>Setting up Hilt</h2>
			<p>Before injecting dependencies<a id="_idIndexMarker701"/> with Hilt, we must first set up Hilt. Let's begin!</p>
			<ol>
				<li>In the project-level <code>build.gradle</code> file, inside the <code>dependencies</code> block, add the Hilt-Android Gradle dependency:<pre>buildscript {
    ...
    dependencies {
        ...
        <strong class="bold">classpath 'com.google.dagger:hilt-android-</strong>
<strong class="bold">            gradle-plugin:2.40.5'</strong>
    }
}</pre></li>
				<li>Moving inside<a id="_idIndexMarker702"/> the application-level <code>build.gradle</code> file, add the Dagger Hilt plugin inside the <code>plugins</code> block:<pre>plugins {
    […]
    id 'kotlin-kapt'
    <strong class="bold">id 'dagger.hilt.android.plugin'</strong>
}</pre></li>
				<li>Still inside the application-level <code>build.gradle</code>, inside the <code>dependencies</code> block, add the Android-Hilt dependencies:<pre>dependencies {
    […]
    <strong class="bold">implementation "com.google.dagger:hilt-</strong>
<strong class="bold">        android:2.40.5"</strong>
    <strong class="bold">kapt "com.google.dagger:hilt-compiler:2.40.5"</strong>
}</pre></li>
			</ol>
			<p>The <code>kapt</code> keyword stands for <strong class="bold">Kotlin Annotation Processor Tool</strong> and is required by Dagger Hilt<a id="_idIndexMarker703"/> to generate code based on the annotations we will be using.</p>
			<p>After updating the <code>build.gradle</code> files, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="4">Annotate the <code>RestaurantsApplication</code> class with the <code>@HiltAndroidApp</code> annotation:<pre><strong class="bold">@HiltAndroidApp</strong>
class RestaurantsApplication: Application() { […] }</pre></li>
			</ol>
			<p>To make use of automated DI<a id="_idIndexMarker704"/> with Hilt, we must annotate our <code>Application</code> class with the <code>HiltAndroidApp</code> annotation. This annotation allows Hilt to generate DI-related boilerplate code, starting with the application-level dependency container.</p>
			<ol>
				<li value="5">Build the project to trigger Hilt's code generation.</li>
				<li>Optionally, if you want to check out the generated classes, first, expand the <strong class="bold">Project</strong> tab on the left, and then expand the package for the generated code. These classes are the proof that Hilt generates a lot of code behind the scenes so we can incorporate DI much easier:</li>
			</ol>
			<div><div><img src="img/B17788_09_4.jpg" alt="Figure 9.4 – Automatically generated classes by Hilt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Automatically generated classes by Hilt</p>
			<p>Let's move on to the actual implementation!</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor302"/>Using Hilt for DI</h2>
			<p>In this sub-section, we will implement DI<a id="_idIndexMarker705"/> with Hilt for the first screen of our app where the list of restaurants<a id="_idIndexMarker706"/> is displayed. In other words, we want to inject all the dependencies that <code>RestaurantsScreen()</code> needs or depends on.</p>
			<p>To have a starting point, let's have a look inside the <code>RestaurantsApp()</code> composable for the <code>RestaurantsScreen()</code> destination and see what we have to inject first:</p>
			<pre>@Composable
private fun RestaurantsApp() {
   val navController = rememberNavController()
   NavHost(navController, startDestination = "restaurants") {
      composable(route = "restaurants") {
         val <strong class="bold">viewModel: RestaurantsViewModel</strong> = viewModel()
         RestaurantsScreen(state = <strong class="bold">viewModel</strong>.state.value, […])
      }
      composable(…) { RestaurantDetailsScreen() }
   }
}</pre>
			<p>It's clear that <code>RestaurantsScreen()</code> depends on <code>RestaurantsViewModel</code> to obtain its state and consume it.</p>
			<p>This means that we must first inject an instance of <code>RestaurantsViewModel</code> inside the <code>composable()</code> destination where the <code>RestaurantsScreen()</code> resides:</p>
			<ol>
				<li value="1">Since we cannot add the <code>@Inject</code> annotation inside a composable function, we must use a special composable function to inject a <code>ViewModel</code>. To do that, first, add the <code>hilt-navigation-compose</code> dependency inside the <code>dependencies</code> block of the app-level <code>build.gradle</code> file:<pre>dependencies {
    […]
    implementation "com.google.dagger:hilt-
        android:2.40.5"
    kapt "com.google.dagger:hilt-compiler:2.40.5"
    <strong class="bold">implementation 'androidx.hilt:hilt-navigation-</strong>
<strong class="bold">        compose:1.0.0'</strong>
}</pre></li>
			</ol>
			<p>After updating the <code>build.gradle</code> file, make sure to sync your project<a id="_idIndexMarker707"/> with its Gradle files. You can do that by pressing<a id="_idIndexMarker708"/> on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Then, going back inside the <code>RestaurantsApp()</code> composable, in the DSL <code>composable()</code> destination for our <code>RestaurantsScreen()</code> composable, replace the <code>viewModel()</code> constructor of <code>RestaurantsViewModel</code> with the <code>hiltViewModel()</code> composable:<pre>@Composable
private fun RestaurantsApp() {
   val navController = rememberNavController()
   NavHost(navController, startDestination = 
           "restaurants") {
      composable(route = "restaurants") {
         val viewModel: RestaurantsViewModel <strong class="bold">= </strong>
<strong class="bold">             hiltViewModel()</strong>
         RestaurantsScreen(…)
      }
      composable(…) { RestaurantDetailsScreen() }
   }
}</pre></li>
			</ol>
			<p>The <code>hiltViewModel()</code> function injects an instance of <code>RestaurantsViewModel</code> scoped to the lifetime of the <code>RestaurantsScreen()</code> navigation component destination.</p>
			<ol>
				<li value="3">Since now our composable hierarchy<a id="_idIndexMarker709"/> injects a <code>ViewModel</code> at some point with the help of Hilt, we must annotate<a id="_idIndexMarker710"/> the Android component that is the host of the <code>RestaurantsApp()</code> root composable with the <code>@AndroidEntryPoint</code> annotation. In our case, the <code>RestaurantsApp()</code> composable is hosted by the <code>MainActivity</code> class, so we must annotate it with the <code>@AndroidEntryPoint</code> annotation:<pre><strong class="bold">@AndroidEntryPoint</strong>
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RestaurantsAppTheme { RestaurantsApp() }
        }
    }
}</pre></li>
			</ol>
			<p>The <code>@AndroidEntryPoint</code> annotation generates another component for our <code>Activity</code> with a lifetime narrower than the lifetime of the application. More precisely, this component allows us to scope dependencies to the lifetime of our <code>Activity</code>. </p>
			<ol>
				<li value="4">In the <code>RestaurantsViewModel</code> class, first refactor it to explicitly declare its dependencies by moving them inside its constructor so that testability is promoted through constructor injection:<pre>class RestaurantsViewModel <strong class="bold">constructor</strong>(
   <strong class="bold">private val getRestaurantsUseCase:</strong> 
<strong class="bold">       GetInitialRestaurantsUseCase</strong>,
    <strong class="bold">private val toggleRestaurantsUseCase:</strong> 
        <strong class="bold">ToggleRestaurantUseCase</strong>
<strong class="bold">)</strong> : ViewModel() {
    private val _state = mutableStateOf(...)
    [...]
}</pre></li>
			</ol>
			<p>Notice that, while we extracted<a id="_idIndexMarker711"/> the two Use Case variables into the constructor, we're no longer<a id="_idIndexMarker712"/> instantiating them – we will leave that to Hilt.</p>
			<ol>
				<li value="5">To get Hilt to inject <code>RestaurantsViewModel</code> for us, mark the <code>ViewModel</code> with the <code>@HiltViewModel</code> annotation, while also annotating its constructor with the <code>@Inject</code> annotation so that Hilt understands which dependencies of the <code>ViewModel</code> must be provided:<pre><strong class="bold">@HiltViewModel</strong>
class RestaurantsViewModel <strong class="bold">@Inject</strong> constructor(
   private val getRestaurantsUseCase: […] ,
   private val toggleRestaurantsUseCase: […]) : 
       ViewModel() {
    [...]
}</pre></li>
			</ol>
			<p>Now that our <code>ViewModel</code> is annotated with <code>@HiltViewModel</code>, instances of <code>RestaurantsViewModel</code> will be provided by <code>ViewModelComponent</code> that respects the lifecycle of a <code>ViewModel</code> (bound to the lifetime of the composable destination while also surviving configuration changes).</p>
			<ol>
				<li value="6">Now that we instructed Hilt how to provide <code>RestaurantsViewModel</code>, we might think we're done; yet, if we build the application, we will get this exception:</li>
			</ol>
			<div><div><img src="img/B17788_09_5.jpg" alt="Figure 9.5 – Hilt compilation error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Hilt compilation error</p>
			<p>The issue lies in the fact that, while we instructed Hilt<a id="_idIndexMarker713"/> to inject <code>RestaurantsViewModel</code> and its dependencies, we never made sure that Hilt<a id="_idIndexMarker714"/> knows how to provide those dependencies: neither the <code>GetInitialRestaurantsUseCase</code> dependency nor the <code>ToggleRestaurantsUseCase</code> dependency.</p>
			<p>In other words, if we want <code>RestaurantsViewModel</code> to be injected, we need to make sure that its dependencies can be provided by Hilt, and their dependencies too, and so on.</p>
			<ol>
				<li value="7">Let's first make sure that Hilt knows how to provide <code>GetInitialRestaurantsUseCase</code> to <code>RestaurantsViewModel</code>. Inside the <code>GetInitialRestaurantsUseCase</code> class, move its dependencies inside the constructor and mark it with <code>@Inject</code>, just like we did with <code>RestaurantsViewModel</code>:<pre>class GetInitialRestaurantsUseCase <strong class="bold">@Inject constructor</strong>(
    <strong class="bold">private val repository: RestaurantsRepository,</strong>
    <strong class="bold">private val getSortedRestaurantsUseCase: </strong>
<strong class="bold">        GetSortedRestaurantsUseCase</strong>) {
    suspend operator fun invoke(): List&lt;Restaurant&gt; { … }
}</pre></li>
			</ol>
			<p>After you add the <code>repository</code> and <code>getSortedRestaurantsUseCase</code> variables inside<a id="_idIndexMarker715"/> the constructor, remember to remove the old member variables<a id="_idIndexMarker716"/> as well as their instantiation code from the body of <code>GetInitialRestaurantsUseCase</code>.</p>
			<p>Note that we aren't annotating the <code>GetInitialRestaurantsUseCase</code> class with any Hilt scope annotations, simply because we don't want it to be tied to a certain lifetime scope.</p>
			<p>Now, Hilt knows how to inject the <code>GetInitialRestaurantsUseCase</code> class, yet we must also instruct Hilt how to provide its dependencies as well: <code>RestaurantsRepository</code> and <code>GetSortedRestaurantsUseCase</code>.</p>
			<p>We need to make sure that Hilt knows how to provide instances of  <code>RestaurantsRepository</code>. We can see that its dependencies are <code>RestaurantsApiService</code> (the Retrofit interface) and <code>RestaurantsDao</code> (the Room Data Access Object interface):</p>
			<pre>class RestaurantsRepository {
    private var restInterface: RestaurantsApiService =
        Retrofit.Builder()
        […]
        .create(RestaurantsApiService::class.java)
    private var restaurantsDao = RestaurantsDb
        .getDaoInstance(
            RestaurantsApplication.getAppContext()
        )
    […]
}</pre>
			<p>The issue here is that once we place these dependencies inside the constructor and inject them, Hilt will have no idea how to provide them – simply because we cannot tap into the internal workings of Room or Retrofit and inject their dependencies too, like we did with <code>RestaurantsViewModel</code>, <code>GetInitialRestaurantsUseCase</code>, and now with <code>RestaurantsRepository</code>.</p>
			<p>For Hilt to know how to provide dependencies<a id="_idIndexMarker717"/> out of our reach, we must create a <code>module</code> class where we will instruct Hilt<a id="_idIndexMarker718"/> on how to provide us with instances of <code>RestaurantsApiService</code> and <code>RestaurantsDao</code>:</p>
			<ol>
				<li value="8">Expand the <code>restaurants</code> package, then right click on the <code>data</code> package, and create a new package called <code>di</code> (short for dependency injection). Inside this package, create a new <code>object</code> class called <code>RestaurantsModule</code> and add the following code inside:<pre>@Module
@InstallIn(SingletonComponent::class)
object RestaurantsModule { }</pre></li>
			</ol>
			<p><code>RestaurantsModule</code> will allow us to instruct Hilt on how to provide Room and Retrofit dependencies to <code>RestaurantsRepository</code>. Since this is a Hilt module, we have done the following:</p>
			<ul>
				<li>Annotated it with <code>@Module</code> so that Hilt recognizes it as a module that provides instances of dependencies.</li>
				<li>Annotated it with <code>@InstallIn()</code> and passed the predefined <code>SingletonComponent</code> component provided by Hilt. Since our module is installed in this component, the dependencies that are contained can be provided anywhere throughout the application since <code>SingletonComponent</code> is an application-level dependency container.</li>
			</ul>
			<ol>
				<li value="9">Next up, inside <code>RestaurantsModule</code>, we need to tell Hilt how to provide our dependencies, so we will start with <code>RestaurantsDao</code>. For us to obtain an instance to <code>RestaurantsDao</code>, we must first instruct Hilt on how to instantiate a <code>RestaurantsDb</code> class.</li>
			</ol>
			<p>Add a <code>provideRoomDatabase</code> method annotated<a id="_idIndexMarker719"/> with <code>@Provides</code> that will instruct Hilt<a id="_idIndexMarker720"/> how to provide an <code>RestaurantsDb</code> object by borrowing part of the instantiation code of the <code>database</code> class from the <code>companion object</code> of the <code>RestaurantsDb</code> class:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
object RestaurantsModule {
<strong class="bold">    @Singleton</strong>
<strong class="bold">    @Provides</strong>
<strong class="bold">    fun provideRoomDatabase(</strong>
<strong class="bold">        @ApplicationContext appContext: Context</strong>
<strong class="bold">    ): RestaurantsDb {</strong>
<strong class="bold">        return Room.databaseBuilder(</strong>
<strong class="bold">            appContext,</strong>
<strong class="bold">            RestaurantsDb::class.java,</strong>
<strong class="bold">            "restaurants_database"</strong>
<strong class="bold">        ).fallbackToDestructiveMigration().build()</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>First off, we've annotated the <code>provideRoomDatabase()</code> method with the <code>@Singleton</code> instance so that Hilt will create only one instance of <code>RestaurantsDb</code> for the whole application, allowing us to save memory.</p>
			<p>Then, we can see that the <code>provideRoomDatabase()</code> method builds a <code>RestaurantsDb</code> instance, yet for this to work, we needed to provide<a id="_idIndexMarker721"/> the application-wide context<a id="_idIndexMarker722"/> to the <code>Room.databaseBuilder()</code> method. To achieve this, we have passed a <code>Context</code> object as a parameter of <code>provideRoomDatabase()</code> and annotated it with <code>@ApplicationContext</code>.</p>
			<p>To understand how Hilt provides us with the application <code>Context</code> object, we must first note that each Hilt container comes with a set of default bindings that we can inject as dependencies. The <code>SingletonComponent</code> container provides us with the application-wide <code>Context</code> object wherever we need it by defining the <code>@ApplicationContext</code> annotation.</p>
			<ol>
				<li value="10">Now that Hilt knows to provide us with <code>RestaurantsDb</code>, we can create another <code>@Provides</code> method that takes in a <code>RestaurantsDb</code> variable (which Hilt will now know how to provide) and return a <code>RestaurantsDao</code> instance:<pre>@Module
@InstallIn(SingletonComponent::class)
object RestaurantsModule {
<strong class="bold">  @Provides</strong>
<strong class="bold">  fun provideRoomDao(database: RestaurantsDb): </strong>
<strong class="bold">      RestaurantsDao  {</strong>
<strong class="bold">        return database.dao</strong>
<strong class="bold">  }</strong>
  @Singleton
  @Provides
  fun provideRoomDatabase(
      @ApplicationContext appContext: Context
  ): RestaurantsDb { ... }
}</pre></li>
				<li>Still inside <code>RestaurantsModule</code>, we now have<a id="_idIndexMarker723"/> to tell Hilt how to provide<a id="_idIndexMarker724"/> us with an instance of <code>RestaurantsApiService</code>. Do the same as before, but this time add a <code>@Provides</code> method for an instance of <code>Retrofit</code>, and one for an instance of <code>RestaurantsApiService</code>. Now, <code>RestaurantsModule</code> should look like this:<pre>@Module
@InstallIn(SingletonComponent::class)
object RestaurantsModule {
    @Provides
    fun provideRoomDao(database: RestaurantsDb): […] {
        return database.dao
    }
    @Singleton
    @Provides
    fun provideRoomDatabase(@ApplicationContext
        appContext: Context): RestaurantsDb {  [...]  }
<strong class="bold">    @Singleton</strong>
<strong class="bold">    @Provides</strong>
<strong class="bold">    fun provideRetrofit(): Retrofit {</strong>
<strong class="bold">        return Retrofit.Builder()</strong>
<strong class="bold">            .addConverterFactory([…])</strong>
<strong class="bold">            .baseUrl("[…]")</strong>
<strong class="bold">            .build()</strong>
<strong class="bold">    }</strong>
<strong class="bold">    @Provides</strong>
<strong class="bold">    fun provideRetrofitApi(retrofit: Retrofit):  </strong>
<strong class="bold">        RestaurantsApiService {</strong>
<strong class="bold">    return retrofit</strong>
<strong class="bold">        .create(RestaurantsApiService::class.java)</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>Remember that all this instantiation code resides in <code>RestaurantsRepository</code>, so you can get it from there.</p>
			<ol>
				<li value="12">Now that Hilt knows <a id="_idIndexMarker725"/>how to provide both dependencies of <code>RestaurantsRepository</code>, head back in the <code>RestaurantsRepository</code> class and apply constructor<a id="_idIndexMarker726"/> injection with Hilt by adding the <code>@Inject</code> annotation to the constructor while moving its <code>RestaurantsApiService</code> and <code>RestaurantsDao</code> dependencies inside the constructor:<pre><strong class="bold">@Singleton</strong>
class RestaurantsRepository <strong class="bold">@Inject constructor</strong>(
    <strong class="bold">private val restInterface: RestaurantsApiService,</strong>
    <strong class="bold">private val restaurantsDao: RestaurantsDao</strong>
) {
    suspend fun toggleFavoriteRestaurant(…) = […]
         […]  
    }</pre></li>
			</ol>
			<p>Usually, <code>Repository</code> classes have a static instance so that only one instance is re-used throughout the app. This is useful when different data is stored in memory globally in <code>Repository</code> classes (be cautious with system-initiated process death because that will wipe anything in memory!).</p>
			<p>Finally, to have only one instance of <code>RestaurantsRepository</code> that can then be reused across the app, we have annotated the class with the <code>@Singleton</code> annotation. This annotation<a id="_idIndexMarker727"/> is provided by the Hilt <code>SingletonComponent</code> container and allows<a id="_idIndexMarker728"/> us to scope instances of classes to the lifetime of the application.</p>
			<ol>
				<li value="13">Now that Hilt knows how to inject <code>RestaurantsRepository</code>, let's get back to the other remaining dependency of <code>GetInitialRestaurantsUseCase</code>: the <code>GetSortedRestaurantsUseCase</code> class. Head inside this class and make sure to inject its dependencies by moving the <code>repository</code> variable inside the constructor as we did before with other classes:<pre>class GetSortedRestaurantsUseCase <strong class="bold">@Inject constructor(</strong>
    <strong class="bold">private val repository: RestaurantsRepository</strong>
<strong class="bold">)</strong> {
    suspend operator fun invoke(): List&lt;Restaurant&gt; {
        return repository.getRestaurants()
            .sortedBy { it.title }
    }
}</pre></li>
			</ol>
			<p>While we have annotated <code>RestaurantsRepository</code> with a scope annotation, we haven't added any scope annotation for this Use Case class simply because we don't want the instance to be preserved across a specific lifetime.</p>
			<p>Now, we have instructed Hilt how to provide all the dependencies for the first dependency of <code>RestaurantsViewModel</code>, which is <code>GetInitialRestaurantsUseCase</code>!</p>
			<ol>
				<li value="14">Next up, let's tell Hilt how to provide the dependencies for the second and last dependency of <code>RestaurantsViewModel</code>, the <code>ToggleRestaurantUseCase</code> class. Head inside this class<a id="_idIndexMarker729"/> and make sure to inject its dependencies<a id="_idIndexMarker730"/> by moving the <code>repository</code> and <code>getSortedRestaurantsUseCase</code> variables inside the constructor as we did before with other classes:<pre>class ToggleRestaurantUseCase <strong class="bold">@Inject constructor(</strong>
<strong class="bold">    private val repository: RestaurantsRepository,</strong>
<strong class="bold">    private val getSortedRestaurantsUseCase: </strong>
<strong class="bold">        GetSortedRestaurantsUseCase</strong>
<strong class="bold">) </strong>{
    suspend operator fun invoke(id: Int, oldValue: 
        Boolean): List&lt;Restaurant&gt; {
        val newFav = oldValue.not()
        repository.toggleFavoriteRestaurant(id, newFav)
        return getSortedRestaurantsUseCase()
    }
}</pre></li>
				<li>Optionally, you can head inside the <code>RestaurantsDb</code> class and delete the entire <code>companion object</code> that was in charge of providing a singleton instance for our <code>RestaurantsDao</code>. The <code>RestaurantsDb</code> class should now be much slimmer and look like this:<pre>@Database(
    entities = [LocalRestaurant::class],
    version = 3,
    exportSchema = false
)
abstract class RestaurantsDb : RoomDatabase() {
    abstract val dao: RestaurantsDao
}</pre></li>
			</ol>
			<p>It's safe to delete this instantiation code because from now on, Hilt will do that for us out of the box.</p>
			<ol>
				<li value="16">Also, if you followed the previous<a id="_idIndexMarker731"/> step of cleaning up the <code>RestaurantsDb</code> class, inside <code>RestaurantsApplication</code>, you can also remove all the logic inside<a id="_idIndexMarker732"/> this class that was related to obtaining the application-wide <code>Context</code> object. From now on, Hilt will do that for us out of the box.</li>
			</ol>
			<p>The <code>RestaurantsApplication</code> class should be much slimmer and look like this:</p>
			<pre>@HiltAndroidApp
class RestaurantsApplication: Application()</pre>
			<ol>
				<li value="17">Build and run the application. Now, the build should be successful because Hilt is in charge of providing the dependencies that we required it to provide.</li>
			</ol>
			<p>With the help of DI, we have now promoted testability while also extracting the boilerplate associated with building class instances.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">We have integrated DI with Hilt for the first screen of <code>RestaurantsApplication</code>. However, the project is still not incorporating DI entirely because the second destination of our app (represented by the <code>RestaurantDetailsScreen()</code> composable) has neither its <code>RestaurantDetailsViewModel</code> injected nor this <code>ViewModel</code> class's dependencies injected. As a take-home assignment, incorporate DI in this second screen. This will allow you to get rid of the redundant Retrofit client instantiation inside <code>RestaurantDetailsViewModel</code> – remember that you can now inject a <code>RestaurantsApiService</code> instance directly with Hilt!</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor303"/>Summary</h1>
			<p>In this chapter, we improved the architecture of the Restaurants App by incorporating DI.</p>
			<p>We discussed what DI is and covered its basic concepts: dependency with its implicit or explicit types, injection, dependency containers, and manual injection.</p>
			<p>We then examined the main benefits that DI brings to our projects: testable classes and less boilerplate code.</p>
			<p>Finally, we covered how DI frameworks can help us with the injection of dependencies, and explored the Jetpack Hilt library as a viable solution for DI on Android. Afterward, we practiced what we learned as we incorporated DI with Hilt in our Restaurants app.</p>
			<p>Since we incorporated DI, it's a bit clearer that our classes can be easily tested, so it's time we start writing some tests in the next chapter!</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor304"/>Further reading</h1>
			<p>Knowing how to work with the basics of Hilt is usually enough for most projects. However, sometimes you might need to use more advanced features of Hilt or Dagger. To learn more about Dagger and how the framework automatically creates the dependencies for you by building a dependency graph, check this article: <a href="https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82">https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82</a>.</p>
			<p>On the same note, apart from the <code>@Singleton</code> scope that was the most used scope throughout our app, Dagger Hilt exposes a broader variety of predefined components and scopes that allow you to scope different classes to various lifecycles. Check out more about components and their scopes in the official documentation: <a href="https://dagger.dev/hilt/components.html">https://dagger.dev/hilt/components.html</a>.</p>
			<p>Leaving components and their scopes aside, in some projects, you might need to allow injection of dependencies in other Android classes than <code>Activity</code>. To see which Android classes can be annotated with <code>@AndroidEntryPoint</code>, check out the documentation: https://dagger.dev/hilt/android-entry-point.</p>
		</div>
	</body></html>