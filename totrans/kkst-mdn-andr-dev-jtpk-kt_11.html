<html><head></head><body>
		<div id="_idContainer099">
			<h1 id="_idParaDest-120"><em class="italic"><a id="_idTextAnchor293"/>Chapter 9</em>: Implementing Dependency Injection with Jetpack Hilt</h1>
			<p>In this chapter, we're continuing our journey of improving the architectural design of the Restaurants app. More precisely, we will be incorporating <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) in our project.</p>
			<p>In the first section, <em class="italic">What is DI?</em>, we will start by defining DI and understanding its basic concepts, from what a dependency is, the types of dependencies, and what injection represents, through to concepts such as dependency containers and manual injection.</p>
			<p>Afterward, in the <em class="italic">Why is DI needed?</em> section, we will focus in more detail on the benefits that DI brings to our projects.</p>
			<p>In the last section, <em class="italic">Implementing DI with Hilt</em>, we will first understand how the Jetpack Hilt DI library works, and how to use it, and finally, with its help, we will incorporate DI in our Restaurants app.</p>
			<p>To summarize, in this chapter we will be covering the following sections:</p>
			<ul>
				<li>What is DI?</li>
				<li>Why is DI needed?</li>
				<li>Implementing DI with Hilt</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor294"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter would usually require your day-to-day tools; however, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_08</strong> directory of the repository and importing the Android project entitled <strong class="source-inline">chapter_8_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_09</strong> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_09/chapter_9_restaurants_app</a>.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor295"/>What is DI?</h1>
			<p>In simple terms, <strong class="bold">DI</strong> represents the concept<a id="_idIndexMarker665"/> of providing the instances of the dependencies that a class needs, instead of having it construct them itself. But, what are dependencies?</p>
			<p><strong class="bold">Dependencies</strong> are other classes<a id="_idIndexMarker666"/> that a certain class <em class="italic">depends on</em>. For example, an <strong class="source-inline">ExampleViewModel</strong> class could contain a <strong class="source-inline">repository</strong> variable of type <strong class="source-inline">Repository</strong>:</p>
			<p class="source-code">class ExampleViewModel {</p>
			<p class="source-code">    private val repository: Repository = Repository()</p>
			<p class="source-code">    fun doSomething() {</p>
			<p class="source-code">        repository.use()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That's why <strong class="source-inline">ExampleViewModel</strong> depends on <strong class="source-inline">Repository</strong>, or <strong class="source-inline">Repository</strong> is a dependency for <strong class="source-inline">ExampleViewModel</strong>. Most of the time, classes have many more dependencies, but we'll stick with only one for the sake<a id="_idIndexMarker667"/> of simplicity. In this case, the <strong class="source-inline">ExampleViewModel</strong> provides its own dependencies so it's very easy to create an instance of it:</p>
			<p class="source-code">fun main() {</p>
			<p class="source-code">    val vm = ExampleViewModel()</p>
			<p class="source-code">    vm.doSomething()</p>
			<p class="source-code">}</p>
			<p>Now, the previous example doesn't incorporate DI, mainly because <strong class="source-inline">ExampleViewModel</strong> provides instances for its own dependencies. It does that by instantiating a <strong class="source-inline">Repository</strong> instance (through the <strong class="source-inline">Repository()</strong> constructor) and by passing it to the <strong class="source-inline">repository</strong> variable.</p>
			<p>To incorporate DI, we must create a component that provides <strong class="source-inline">ExampleViewModel</strong> with its dependencies:</p>
			<p class="source-code">object DependencyContainer {</p>
			<p class="source-code">    val repo: Repository = Repository()</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">DependencyContainer</strong> class will act, as the name suggests, as a <strong class="bold">dependency container</strong>, as it will provide instances for all the dependencies<a id="_idIndexMarker668"/> our classes need. When a class needs an instance for its dependency, this container will provide it. This way, we centralize the creation of the instances of dependencies so we can handle this process (which can become elaborate for complex projects where each dependency has other dependencies, for example) within a single place in our project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Apart from the DI<a id="_idIndexMarker669"/> technique, you can also use the <strong class="bold">service locator</strong> pattern to construct classes. Unlike DI, if you try to follow the service locator pattern, then the class that needs to be constructed will be responsible for creating its own dependencies with the help of a <strong class="source-inline">ServiceLocator</strong> component. Both DI and the service locator pattern are useful; however, we will only cover DI in this chapter.</p>
			<p>Getting back to incorporating DI, we then must allow <strong class="source-inline">DependencyContainer</strong> to provide a <strong class="source-inline">Repository</strong> instance to <strong class="source-inline">ExampleViewModel</strong>:</p>
			<p class="source-code">class ExampleViewModel {</p>
			<p class="source-code">    private val repository: Repository = </p>
			<p class="source-code">        <strong class="bold">DependencyContainer.repo</strong></p>
			<p class="source-code">    fun doSomething() {</p>
			<p class="source-code">        repository.use()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This technique of having dependencies<a id="_idIndexMarker670"/> declared as variables (for example, <strong class="source-inline">ExampleViewModel</strong> contains a <strong class="source-inline">repository</strong> variable) and then providing their instances<a id="_idIndexMarker671"/> through a container is a form of DI called <strong class="bold">field injection</strong>.</p>
			<p>There are several issues with this approach, mainly caused by the fact that we have declared dependencies as field variables. The most notable ones are as follows:</p>
			<ul>
				<li>The <strong class="source-inline">ExampleViewModel</strong> class is tightly coupled to our <strong class="source-inline">DependencyContainer</strong> and we cannot use the <strong class="source-inline">ViewModel</strong> without it.</li>
				<li>The dependencies are <strong class="bold">implicit</strong>, which means<a id="_idIndexMarker672"/> they are hidden from the outside world. In other words, whoever is instantiating <strong class="source-inline">ExampleViewModel</strong> doesn't know about the <strong class="source-inline">ViewModel</strong> class's dependencies or their creation.</li>
			</ul>
			<p>This won't allow us to reuse the same <strong class="source-inline">ExampleViewModel</strong> with other implementations of its dependencies (given its dependencies, such as <strong class="source-inline">Repository</strong>, are interfaces that can be implemented by different classes).</p>
			<ul>
				<li>Since <strong class="source-inline">ExampleViewModel</strong> has hidden dependencies, it becomes hard for us to test it. As we will instantiate the <strong class="source-inline">ExampleViewModel</strong> and put it under test, it will create its own <strong class="source-inline">Repository</strong> instance that will probably make real I/O requests for every test. We want our tests to be fast and reliable and not dependent on real third-party APIs.</li>
			</ul>
			<p>To alleviate these issues, we must first refactor <strong class="source-inline">ExampleViewModel</strong> to expose its dependencies through its public API to the outside world. The most appropriate<a id="_idIndexMarker673"/> way to do that is through its public <strong class="source-inline">constructor</strong>:</p>
			<p class="source-code">class ExampleViewModel <strong class="bold">constructor</strong>(<strong class="bold">private val repo: Repository</strong>) {</p>
			<p class="source-code">    fun doSomething() { repo.use() }</p>
			<p class="source-code">}</p>
			<p>Now, <strong class="source-inline">ExampleViewModel</strong> exposes its dependencies to the outside world through its constructor, making those<a id="_idIndexMarker674"/> dependencies <strong class="bold">explicit</strong>. Yet, who's going to provide the dependencies from outside?</p>
			<p>When we need to instantiate <strong class="source-inline">ExampleViewModel</strong>, <strong class="source-inline">DependencyContainer</strong> will provide it with the necessary dependencies from the outside:</p>
			<p class="source-code">fun main() {</p>
			<p class="source-code"><strong class="bold">    val repoDependency = DependencyContainer.repository</strong></p>
			<p class="source-code"><strong class="bold">    </strong>val vm = ExampleViewModel(<strong class="bold">repoDependency</strong>)</p>
			<p class="source-code"><strong class="bold">    </strong>vm.doSomething()</p>
			<p class="source-code">}</p>
			<p>In the previous example, instead of field injection, we have used <strong class="bold">constructor injection</strong>. This is because we have provided<a id="_idIndexMarker675"/> and injected the dependencies to <strong class="source-inline">ExampleViewModel</strong> from the outside world through its constructor.</p>
			<p>As opposed to field injection, constructor injection allows us to do the following:</p>
			<ul>
				<li>Decouple our classes from the DI container, just like <strong class="source-inline">ExampleViewModel</strong> no longer depends on <strong class="source-inline">DependencyContainer</strong>.</li>
				<li>The dependencies are exposed to the outside world, so we can reuse the same <strong class="source-inline">ExampleViewModel</strong> with other implementations of <strong class="source-inline">Repository</strong> (given <strong class="source-inline">Repository</strong> is an interface).</li>
				<li>The <strong class="source-inline">ExampleViewModel</strong> class can no longer decide which dependency implementation to get and use as was the case with field injection, so we have now inverted this responsibility from <strong class="source-inline">ExampleViewModel</strong> to the outside world.</li>
				<li><strong class="source-inline">ExampleViewModel</strong> is easier to test, as we can easily pass a mock or a fake <strong class="source-inline">Repository</strong> implementation (given <strong class="source-inline">Repository</strong> is an interface) that will behave the way we're expecting it to in a test.</li>
			</ul>
			<p>So far, with the help of a dependency<a id="_idIndexMarker676"/> container, we have incorporated DI by ourselves by allowing <strong class="source-inline">DependencyContainer</strong> to provide instances of dependencies<a id="_idIndexMarker677"/> to our classes (that is, an instance of <strong class="source-inline">ExampleViewModel</strong>). This technique is called <strong class="bold">manual DI</strong>.</p>
			<p>Apart from manual DI, you can have DI done automatically through frameworks that relieve you from the burden of the following:</p>
			<ul>
				<li>Providing instances of dependencies to the classes that need them. More specifically, frameworks help you wire up complex object relationships for the required dependencies, so you don't have to write boilerplate code to generate instances and pass them to appropriate objects. This infrastructure code is often cumbersome for large-sized apps, so a framework that automates that for you can be quite handy.</li>
				<li>Scoping dependencies to certain lifetime scopes, such as the <strong class="source-inline">Application</strong> scope or <strong class="source-inline">Activity</strong> scope. For example, if you want a certain dependency to be a singleton (to be scoped to the lifetime of the application), you must manually make sure that only one instance is created in memory while also avoiding concurrency issues due to concurrent access. A framework can do that for you behind the scenes.</li>
			</ul>
			<p>In Android, a very simple DI library is <strong class="bold">Hilt</strong>, and we will explore<a id="_idIndexMarker678"/> it in the <em class="italic">Implementing DI with Hilt</em> section. But until then, let's better understand why DI is needed in the first place.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor296"/>Why is DI needed?</h1>
			<p>DI is not a must for all projects. Until now, our Restaurants app<a id="_idIndexMarker679"/> worked just fine without any DI incorporated. Yet, while not including DI might not seem like a big issue, by incorporating it you bring a lot of benefits to your project; the most notable advantages are that you can do the following:</p>
			<ul>
				<li>Write less boilerplate code.</li>
				<li>Write testable classes.</li>
			</ul>
			<p>Let's cover these two next.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor297"/>Write less boilerplate code</h2>
			<p>Let's circle back to our Restaurants app, and let's have a look<a id="_idIndexMarker680"/> at how we instantiate the Retrofit interface within the <strong class="source-inline">RestaurantsRepository</strong> class:</p>
			<p class="source-code">class RestaurantsRepository {</p>
			<p class="source-code"><strong class="bold">    private var restInterface: RestaurantsApiService =</strong></p>
			<p class="source-code"><strong class="bold">        Retrofit.Builder()</strong></p>
			<p class="source-code"><strong class="bold">             .addConverterFactory(</strong></p>
			<p class="source-code"><strong class="bold">                 GsonConverterFactory.create())</strong></p>
			<p class="source-code"><strong class="bold">             .baseUrl("your_firebase_database_url")</strong></p>
			<p class="source-code"><strong class="bold">            .build()</strong></p>
			<p class="source-code"><strong class="bold">            .create(RestaurantsApiService::class.java)</strong></p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>Now, let's have a look at how we similarly instantiate the Retrofit<a id="_idIndexMarker681"/> interface within the <strong class="source-inline">RestaurantsDetailsViewModel</strong> class:</p>
			<p class="source-code">class RestaurantDetailsViewModel(…): ViewModel() {</p>
			<p class="source-code">    private var <strong class="bold">restInterface: RestaurantsApiService</strong></p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        <strong class="bold">val retrofit: Retrofit = Retrofit.Builder()</strong></p>
			<p class="source-code"><strong class="bold">            .addConverterFactory(GsonConverterFactory.create())</strong></p>
			<p class="source-code"><strong class="bold">            .baseUrl("your_firebase_database_url")</strong></p>
			<p class="source-code"><strong class="bold">            .build()</strong></p>
			<p class="source-code">        <strong class="bold">restInterface = retrofit</strong></p>
			<p class="source-code"><strong class="bold">            .create(RestaurantsApiService::class.java)</strong></p>
			<p class="source-code">        [...]</p>
			<p class="source-code">    }</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>While the code seems different, in essence, it's the same code needed to instantiate a concrete instance of <strong class="source-inline">RestaurantsApiService</strong>. Unfortunately, we have duplicated this instantiation code in two places, both in the <strong class="source-inline">RestaurantsRepository</strong> class and in the <strong class="source-inline">RestaurantsDetailsViewModel</strong> class.</p>
			<p>In medium to large-sized production apps, the relationship between objects is often much more complex, making such infrastructure code plague every class, mostly because, without any DI, every class builds the instances of the dependencies it needs. Such code is often duplicated throughout the project and ultimately becomes difficult to manage.</p>
			<p>DI will help us centralize this infrastructure code and will eliminate all the duplicated code needed to provide instances of dependencies, wherever we need them throughout the project.</p>
			<p>Going back to our Restaurants app, if we were to use manual DI, all this instantiation code could be extracted into a <strong class="source-inline">DependencyContainer</strong> class that would provide us with a <strong class="source-inline">RestaurantsApiService</strong> instance wherever we need it, so we would have no more duplicated code! Don't worry, we will incorporate DI soon, in the upcoming <em class="italic">Implementing DI with Hilt</em> section.</p>
			<p>Now that we touched<a id="_idIndexMarker682"/> upon how DI helps us with containing and organizing the code related to building instances of classes, it's time to check out another essential advantage of DI.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor298"/>Write testable classes</h2>
			<p>Let's suppose that we want to test the behavior of <strong class="source-inline">RestaurantsRepository</strong> to make sure that it performs<a id="_idIndexMarker683"/> as expected. But first, let's have a quick look at the existing implementation of <strong class="source-inline">RestaurantsRepository</strong>:</p>
			<p class="source-code">class RestaurantsRepository {</p>
			<p class="source-code">    <strong class="bold">private var restInterface: RestaurantsApiService =</strong> </p>
			<p class="source-code">        <strong class="bold">Retrofit.Builder()</strong></p>
			<p class="source-code">            <strong class="bold">.[...]</strong></p>
			<p class="source-code">            <strong class="bold">.create(RestaurantsApiService::class.java)</strong></p>
			<p class="source-code">    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong></p>
			<p class="source-code"><strong class="bold">        .getDaoInstance(</strong></p>
			<p class="source-code"><strong class="bold">            RestaurantsApplication.getAppContext()</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code">    suspend fun toggleFavoriteRestaurant(…) = {…}</p>
			<p class="source-code">    suspend fun getRestaurants(): List&lt;Restaurant&gt; {…}</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>We can see that no DI is currently incorporated, as <strong class="source-inline">RestaurantsRepository</strong> has two implicit dependencies: an instance of <strong class="source-inline">RestaurantsApiService</strong> and an instance of <strong class="source-inline">RestaurantsDao</strong>. The <strong class="source-inline">RestaurantsRepository</strong> provides<a id="_idIndexMarker684"/> instances to its own dependencies, first by constructing a <strong class="source-inline">Retrofit.Builder()</strong> object and creating the concrete instance by calling <strong class="source-inline">.create(…)</strong>.</p>
			<p>Now, let's say we want to test this <strong class="source-inline">RestaurantsRepository</strong> class, and make sure that it behaves correctly by running different verifications. Let's imagine how such a test class would look:</p>
			<p class="source-code">class RestaurantsRepositoryTest {</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    fun repository_worksCorrectly() {</p>
			<p class="source-code">        val repo = RestaurantsRepository()</p>
			<p class="source-code">        assertNotNull(repo)</p>
			<p class="source-code">        // Perform other verifications</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The previous test structure is simple: we created a <strong class="source-inline">RestaurantsRepository</strong> instance by using its constructor and then we saved it inside a <strong class="source-inline">repo</strong> variable. We then asserted that the instance of the <strong class="source-inline">Repository</strong> is not <strong class="source-inline">null</strong>, so we can proceed with testing its behavior.</p>
			<p>This is optional, yet if you're trying to write the previous test class and follow this process, make sure that the <strong class="source-inline">RestaurantsRepositoryTest</strong> class is placed inside the <strong class="source-inline">test</strong> directory of the application:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B17788_09_1.jpg" alt="Figure 9.1 – Placement of test classes in the project structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Placement of test classes in the project structure</p>
			<p>Now, if we would to run this test, it will throw an exception<a id="_idIndexMarker685"/> before having the chance to verify anything. The stack trace would look like this:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B17788_09_2.jpg" alt="Figure 9.2 – Stack trace of running invalid test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Stack trace of running invalid test</p>
			<p>This happens because we're trying to write a small test for <strong class="source-inline">RestaurantsRepository</strong> but this class is not yet testable (in fact, we're trying to perform a Unit test – we will tackle this in more detail in <a href="B17788_10_ePub.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, <em class="italic">Test Your App with UI and Unit Tests</em>).</p>
			<p>But, why is our simple test throwing <strong class="source-inline">UninitializedPropertyAccessException</strong>?</p>
			<p>If we have a look at the stack trace, we can see that the crash is caused because our test is trying to obtain the application context through <strong class="source-inline">getAppContext()</strong> from the <strong class="source-inline">RestaurantsApplication</strong> class.</p>
			<p>It makes sense because, if we have another look at <strong class="source-inline">RestaurantsRepository</strong>, we can see that to obtain the <strong class="source-inline">restaurantsDao</strong> instance, the <strong class="source-inline">Repository</strong> calls <strong class="source-inline">RestaurantsDb.getDaoInstance()</strong> that initializes the Room database, and it needs an instance of <strong class="source-inline">Context</strong> to do that:</p>
			<p class="source-code">class RestaurantsRepository {</p>
			<p class="source-code">    […]</p>
			<p class="source-code">    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong></p>
			<p class="source-code"><strong class="bold">        .getDaoInstance(</strong></p>
			<p class="source-code"><strong class="bold">            RestaurantsApplication.getAppContext()</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code">    suspend fun toggleFavoriteRestaurant(…) = {…}</p>
			<p class="source-code">    suspend fun getRestaurants(): List&lt;Restaurant&gt; {…}</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>Our small test shouldn't need a <strong class="source-inline">Context</strong> object, simply because it should neither try to create a Room database<a id="_idIndexMarker686"/> nor to create a Retrofit client instance; it shouldn't even depend on these concrete implementations. This is not efficient for small tests simply because such operations are memory-expensive and will do nothing but slow down our tests.</p>
			<p>Moreover, we don't want our small test (that should run with much ease and very fast, several times in a short time frame) to make Room queries or, even worse, network requests through Retrofit, simply because the tests are dependent on the external world and so they become expensive and difficult to automate.</p>
			<p>If, however, we would have had DI in place with constructor injection, we could have created our own classes that <em class="italic">fake</em> the behavior, ultimately making our <strong class="source-inline">Repository</strong> class easy to test and independent of concrete implementations that perform heavy I/O operations. We'll cover more about tests and <em class="italic">faking</em> in <a href="B17788_10_ePub.xhtml#_idTextAnchor305"><em class="italic">Chapter 10</em></a>, <em class="italic">Test Your App with UI and Unit Tests</em>.</p>
			<p>Going back to our app, we're not yet ready to write tests, because as you could see, we're lacking DI in our project. Now that we've seen that, without DI, life is somehow tough, let's learn how we can incorporate DI in the Restaurants app with the help of the Hilt library!</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor299"/>Implementing DI with Hilt</h1>
			<p>DI libraries are often used to simplify<a id="_idIndexMarker687"/> and accelerate the incorporation of DI<a id="_idIndexMarker688"/> in our projects, especially when the infrastructure code required by manual DI gets difficult to manage in large projects. </p>
			<p><strong class="bold">Hilt</strong> is a DI library that is part of Jetpack, and it removes the unnecessary boilerplate involved in manual dependency injection in Android apps by generating the code and the infrastructure that you otherwise<a id="_idIndexMarker689"/> would have had to develop<a id="_idIndexMarker690"/> manually.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Hilt is a DI library based on another popular DI framework called <strong class="bold">Dagger</strong>, meaning that they are strongly related, so we will often<a id="_idIndexMarker691"/> refer to Hilt as <em class="italic">Dagger Hilt</em> in this chapter. Due to the steep learning curve of the Dagger APIs, Hilt was developed as an abstraction layer over Dagger to allow easier adoption of automated DI in Android projects.</p>
			<p>Dagger Hilt relies on annotation processors to automatically generate code at build time, making it able to create and optimize the process of managing and providing dependencies throughout your project. Because of that, its core concepts are strongly connected to the use of annotations, so before we start adding and implementing Hilt in our Restaurants app, we must first cover a few concepts to better understand how Dagger Hilt works.</p>
			<p>To summarize, in this section we will be doing the following:</p>
			<ul>
				<li>Understanding the basics of Dagger Hilt</li>
				<li>Setting up Hilt</li>
				<li>Using Hilt for DI</li>
			</ul>
			<p>Let's begin!</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor300"/>Understanding the basics of Dagger Hilt</h2>
			<p>Let's analyze the three most important<a id="_idIndexMarker692"/> concepts and their corresponding annotations that we're required to work with to enable automatic DI in our project:</p>
			<ul>
				<li>Injection</li>
				<li>Modules</li>
				<li>Components</li>
			</ul>
			<p>Let's start with injection!</p>
			<h3>Injection</h3>
			<p>Dagger Hilt needs to know the type<a id="_idIndexMarker693"/> of instances we want it to provide us with. When we discussed manual constructor injection, we initially wanted <strong class="source-inline">ExampleViewModel</strong> to be injected wherever we needed it, and we used a <strong class="source-inline">DependencyContainer</strong> class for that.</p>
			<p>If we want Dagger Hilt to inject instances of a class somewhere, we must first declare a variable of that type and annotate it with the <strong class="source-inline">@Inject</strong> annotation.</p>
			<p>Let's say that inside the <strong class="source-inline">main()</strong> function used for the manual DI example, we no longer want to use manual DI to get an instance of <strong class="source-inline">ExampleViewModel</strong>. Instead, we want Dagger to instantiate this class. That's why we will annotate the <strong class="source-inline">ExampleViewModel</strong> variable with the Java <strong class="source-inline">@Inject</strong> annotation and refrain from instantiating the <strong class="source-inline">ViewModel</strong> class by ourselves. Dagger Hilt should do that for us now:</p>
			<p class="source-code">import javax.inject.Inject</p>
			<p class="source-code"><strong class="bold">@Inject</strong></p>
			<p class="source-code">val vm: ExampleViewModel</p>
			<p class="source-code">fun main() {</p>
			<p class="source-code">    vm.doSomething()</p>
			<p class="source-code">}</p>
			<p>Now, for Dagger Hilt to know how to provide us with an instance of the <strong class="source-inline">ExampleViewModel</strong> class, we must also add the <strong class="source-inline">@Inject</strong> annotation to the dependencies of <strong class="source-inline">ExampleViewModel</strong> so that Dagger knows how to instantiate the <strong class="source-inline">ViewModel</strong> class.</p>
			<p>Since the dependencies of <strong class="source-inline">ExampleViewModel</strong> are inside the constructor (from when we used manual constructor injection), we can directly add the <strong class="source-inline">@Inject</strong> annotation to <strong class="source-inline">constructor</strong>:</p>
			<p class="source-code">class ExampleViewModel <strong class="bold">@Inject</strong> constructor(private val repo:Repository) {</p>
			<p class="source-code">    fun doSomething() { repo.use() }</p>
			<p class="source-code">}</p>
			<p>Now, Dagger Hilt also needs<a id="_idIndexMarker694"/> to know how to inject the dependencies of <strong class="source-inline">ExampleViewModel</strong>, more precisely the <strong class="source-inline">Repository</strong> class.</p>
			<p>Let's consider that <strong class="source-inline">Repository</strong> has only one dependency, a <strong class="source-inline">Retrofit</strong> constructor variable. For Dagger to know how to inject a <strong class="source-inline">Repository</strong> class, we must annotate its constructor with <strong class="source-inline">@Inject</strong> as well:</p>
			<p class="source-code">class Repository <strong class="bold">@Inject</strong> constructor(val retrofit: Retrofit){</p>
			<p class="source-code">    fun use() { retrofit.baseUrl() }</p>
			<p class="source-code">}</p>
			<p>Until now, we got away with <strong class="source-inline">@Inject</strong> annotations because we had access to the classes and dependencies that we were trying to inject, but now, how can Dagger know how to provide us with a <strong class="source-inline">Retrofit</strong> instance? We have no way of tapping inside the <strong class="source-inline">Retrofit</strong> class and annotating its constructor with <strong class="source-inline">@Inject</strong>, since it's in an external library.</p>
			<p>To instruct Dagger on how to provide us with specific dependencies, let's learn a bit about modules!</p>
			<h3>Modules</h3>
			<p><strong class="bold">Modules</strong> are classes annotated with <strong class="source-inline">@Module</strong> that allow us to instruct Dagger Hilt on how to provide<a id="_idIndexMarker695"/> dependencies. For example, we need Dagger Hilt to provide us with a <strong class="source-inline">Retrofit</strong> instance in our <strong class="source-inline">Repository</strong>, so we could define a <strong class="source-inline">DataModule</strong> class that tells Dagger Hilt how to do so:</p>
			<p class="source-code">@Module</p>
			<p class="source-code">object DataModule {</p>
			<p class="source-code">    @Provides</p>
			<p class="source-code">    fun provideRetrofit(): Retrofit {</p>
			<p class="source-code">        return Retrofit.Builder().baseUrl("some_url").build()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>To tell the library how to provide<a id="_idIndexMarker696"/> us with a dependency, we must create a method inside the <strong class="source-inline">@Module</strong> annotated class where we manually build that class instance.</p>
			<p>Since we don't have access to the <strong class="source-inline">Retrofit</strong> class and we need it injected, we've created a <strong class="source-inline">provideRetrofit()</strong> method (you can call it any way you want) annotated with the <strong class="source-inline">@Provides</strong> annotation, and that returns a <strong class="source-inline">Retrofit</strong> object. Inside the method, we manually created the <strong class="source-inline">Retrofit</strong> instance the way we needed it to be built.</p>
			<p>Now, Dagger Hilt knows how to provide us with all the dependencies our <strong class="source-inline">ExampleViewModel</strong> needs (its direct <strong class="source-inline">Repository</strong> dependency and <strong class="source-inline">Repository</strong> <strong class="source-inline">Retrofit</strong> dependency). Yet, Dagger will complain that it needs a component class in which the module we've created must be installed.</p>
			<p>Let's have a brief look at components next!</p>
			<h3>Components</h3>
			<p><strong class="bold">Components</strong> are interfaces that represent the container for a certain set of dependencies. A component<a id="_idIndexMarker697"/> takes in modules and makes sure that the injection of its dependencies happens with respect to a certain lifecycle.</p>
			<p>For our example with the <strong class="source-inline">ExampleViewModel</strong>, <strong class="source-inline">Repository</strong>, and <strong class="source-inline">Retrofit</strong> dependencies, let's say that we create a component that manages the creation for these dependencies.</p>
			<p>With Dagger Hilt, you can define a component with the <strong class="source-inline">@DefineComponent</strong> annotation:</p>
			<p class="source-code">@DefineComponent()</p>
			<p class="source-code">interface MyCustomComponent(…) { /* component build code */ }</p>
			<p>Afterward, we could install our <strong class="source-inline">DataModule</strong> in this component:</p>
			<p class="source-code">@Module</p>
			<p class="source-code"><strong class="bold">@InstallIn(MyCustomComponent::class)</strong></p>
			<p class="source-code">object DataModule {</p>
			<p class="source-code">    @Provides</p>
			<p class="source-code">    fun provideRetrofit(): Retrofit { […] }</p>
			<p class="source-code">}</p>
			<p>In practice though, the process of defining and building a component is more complex than that. This is because a component<a id="_idIndexMarker698"/> must scope its dependencies to a certain lifetime scope (such as the lifetime of the application) and have a pre-existent parent component.</p>
			<p>Luckily, Hilt provides components for us out of the box. Such predefined components allow us to install modules in them and to scope dependencies to their corresponding lifetime scope.</p>
			<p>Some of the most important predefined components are as follows: </p>
			<ul>
				<li><strong class="source-inline">SingletonComponent</strong>: Allows us to scope dependencies to the lifetime of the application, as singletons, by annotating them with the <strong class="source-inline">@Singleton</strong> annotation. Every time a dependency annotated with <strong class="source-inline">@Singleton</strong> is requested, Dagger will provide the same instance.</li>
				<li><strong class="source-inline">ActivityComponent</strong>: Allows us to scope dependencies to the lifetime of an <strong class="source-inline">Activity</strong>, with the <strong class="source-inline">@ActivityScoped</strong> annotation. If the <strong class="source-inline">Activity</strong> is recreated, a new instance of the dependency will be provided.</li>
				<li><strong class="source-inline">ActivityRetainedComponent</strong>: Allows us to scope dependencies to the lifetime of an <strong class="source-inline">Activity</strong>, surpassing its recreation upon orientation change, with the <strong class="source-inline">@ActivityRetainedScoped</strong> annotation. If the <strong class="source-inline">Activity</strong> is recreated upon orientation change, the same instance of the dependency is provided.</li>
				<li><strong class="source-inline">ViewModelComponent</strong>: Allows us to scope dependencies to the lifetime of a <strong class="source-inline">ViewModel</strong>, with the <strong class="source-inline">@ViewModelScoped</strong> annotation.</li>
			</ul>
			<p>As the lifetime scope of these components varies, this also translates into the fact that each component derives its lifetime scope from each other, from the widest <strong class="source-inline">@Singleton</strong> lifetime scope (of the application) to narrower scopes such as <strong class="source-inline">@ActivityScoped</strong> (of an <strong class="source-inline">Activity</strong>):</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B17788_09_3.jpg" alt="Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their corresponding components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Simplified version of Dagger Hilt scope annotations and their corresponding components</p>
			<p>While in our Restaurants app, we will mostly be using <strong class="source-inline">SingletonComponent</strong> and its <strong class="source-inline">@Singleton</strong> scope annotation; it's important to note that Dagger Hilt<a id="_idIndexMarker699"/> exposes a broader variety of predefined components<a id="_idIndexMarker700"/> and scopes. Check them out in the documentation here: <a href="https://dagger.dev/hilt/components.html">https://dagger.dev/hilt/components.html</a>.</p>
			<p>Now that we've briefly covered components, it's time to add Hilt to our Restaurants app!</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor301"/>Setting up Hilt</h2>
			<p>Before injecting dependencies<a id="_idIndexMarker701"/> with Hilt, we must first set up Hilt. Let's begin!</p>
			<ol>
				<li>In the project-level <strong class="source-inline">build.gradle</strong> file, inside the <strong class="source-inline">dependencies</strong> block, add the Hilt-Android Gradle dependency:<p class="source-code">buildscript {</p><p class="source-code">    ...</p><p class="source-code">    dependencies {</p><p class="source-code">        ...</p><p class="source-code">        <strong class="bold">classpath 'com.google.dagger:hilt-android-</strong></p><p class="source-code"><strong class="bold">            gradle-plugin:2.40.5'</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Moving inside<a id="_idIndexMarker702"/> the application-level <strong class="source-inline">build.gradle</strong> file, add the Dagger Hilt plugin inside the <strong class="source-inline">plugins</strong> block:<p class="source-code">plugins {</p><p class="source-code">    […]</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    <strong class="bold">id 'dagger.hilt.android.plugin'</strong></p><p class="source-code">}</p></li>
				<li>Still inside the application-level <strong class="source-inline">build.gradle</strong>, inside the <strong class="source-inline">dependencies</strong> block, add the Android-Hilt dependencies:<p class="source-code">dependencies {</p><p class="source-code">    […]</p><p class="source-code">    <strong class="bold">implementation "com.google.dagger:hilt-</strong></p><p class="source-code"><strong class="bold">        android:2.40.5"</strong></p><p class="source-code">    <strong class="bold">kapt "com.google.dagger:hilt-compiler:2.40.5"</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">kapt</strong> keyword stands for <strong class="bold">Kotlin Annotation Processor Tool</strong> and is required by Dagger Hilt<a id="_idIndexMarker703"/> to generate code based on the annotations we will be using.</p>
			<p>After updating the <strong class="source-inline">build.gradle</strong> files, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="4">Annotate the <strong class="source-inline">RestaurantsApplication</strong> class with the <strong class="source-inline">@HiltAndroidApp</strong> annotation:<p class="source-code"><strong class="bold">@HiltAndroidApp</strong></p><p class="source-code">class RestaurantsApplication: Application() { […] }</p></li>
			</ol>
			<p>To make use of automated DI<a id="_idIndexMarker704"/> with Hilt, we must annotate our <strong class="source-inline">Application</strong> class with the <strong class="source-inline">HiltAndroidApp</strong> annotation. This annotation allows Hilt to generate DI-related boilerplate code, starting with the application-level dependency container.</p>
			<ol>
				<li value="5">Build the project to trigger Hilt's code generation.</li>
				<li>Optionally, if you want to check out the generated classes, first, expand the <strong class="bold">Project</strong> tab on the left, and then expand the package for the generated code. These classes are the proof that Hilt generates a lot of code behind the scenes so we can incorporate DI much easier:</li>
			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B17788_09_4.jpg" alt="Figure 9.4 – Automatically generated classes by Hilt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Automatically generated classes by Hilt</p>
			<p>Let's move on to the actual implementation!</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor302"/>Using Hilt for DI</h2>
			<p>In this sub-section, we will implement DI<a id="_idIndexMarker705"/> with Hilt for the first screen of our app where the list of restaurants<a id="_idIndexMarker706"/> is displayed. In other words, we want to inject all the dependencies that <strong class="source-inline">RestaurantsScreen()</strong> needs or depends on.</p>
			<p>To have a starting point, let's have a look inside the <strong class="source-inline">RestaurantsApp()</strong> composable for the <strong class="source-inline">RestaurantsScreen()</strong> destination and see what we have to inject first:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun RestaurantsApp() {</p>
			<p class="source-code">   val navController = rememberNavController()</p>
			<p class="source-code">   NavHost(navController, startDestination = "restaurants") {</p>
			<p class="source-code">      composable(route = "restaurants") {</p>
			<p class="source-code">         val <strong class="bold">viewModel: RestaurantsViewModel</strong> = viewModel()</p>
			<p class="source-code">         RestaurantsScreen(state = <strong class="bold">viewModel</strong>.state.value, […])</p>
			<p class="source-code">      }</p>
			<p class="source-code">      composable(…) { RestaurantDetailsScreen() }</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>It's clear that <strong class="source-inline">RestaurantsScreen()</strong> depends on <strong class="source-inline">RestaurantsViewModel</strong> to obtain its state and consume it.</p>
			<p>This means that we must first inject an instance of <strong class="source-inline">RestaurantsViewModel</strong> inside the <strong class="source-inline">composable()</strong> destination where the <strong class="source-inline">RestaurantsScreen()</strong> resides:</p>
			<ol>
				<li value="1">Since we cannot add the <strong class="source-inline">@Inject</strong> annotation inside a composable function, we must use a special composable function to inject a <strong class="source-inline">ViewModel</strong>. To do that, first, add the <strong class="source-inline">hilt-navigation-compose</strong> dependency inside the <strong class="source-inline">dependencies</strong> block of the app-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">dependencies {</p><p class="source-code">    […]</p><p class="source-code">    implementation "com.google.dagger:hilt-</p><p class="source-code">        android:2.40.5"</p><p class="source-code">    kapt "com.google.dagger:hilt-compiler:2.40.5"</p><p class="source-code">    <strong class="bold">implementation 'androidx.hilt:hilt-navigation-</strong></p><p class="source-code"><strong class="bold">        compose:1.0.0'</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project<a id="_idIndexMarker707"/> with its Gradle files. You can do that by pressing<a id="_idIndexMarker708"/> on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Then, going back inside the <strong class="source-inline">RestaurantsApp()</strong> composable, in the DSL <strong class="source-inline">composable()</strong> destination for our <strong class="source-inline">RestaurantsScreen()</strong> composable, replace the <strong class="source-inline">viewModel()</strong> constructor of <strong class="source-inline">RestaurantsViewModel</strong> with the <strong class="source-inline">hiltViewModel()</strong> composable:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantsApp() {</p><p class="source-code">   val navController = rememberNavController()</p><p class="source-code">   NavHost(navController, startDestination = </p><p class="source-code">           "restaurants") {</p><p class="source-code">      composable(route = "restaurants") {</p><p class="source-code">         val viewModel: RestaurantsViewModel <strong class="bold">= </strong></p><p class="source-code"><strong class="bold">             hiltViewModel()</strong></p><p class="source-code">         RestaurantsScreen(…)</p><p class="source-code">      }</p><p class="source-code">      composable(…) { RestaurantDetailsScreen() }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">hiltViewModel()</strong> function injects an instance of <strong class="source-inline">RestaurantsViewModel</strong> scoped to the lifetime of the <strong class="source-inline">RestaurantsScreen()</strong> navigation component destination.</p>
			<ol>
				<li value="3">Since now our composable hierarchy<a id="_idIndexMarker709"/> injects a <strong class="source-inline">ViewModel</strong> at some point with the help of Hilt, we must annotate<a id="_idIndexMarker710"/> the Android component that is the host of the <strong class="source-inline">RestaurantsApp()</strong> root composable with the <strong class="source-inline">@AndroidEntryPoint</strong> annotation. In our case, the <strong class="source-inline">RestaurantsApp()</strong> composable is hosted by the <strong class="source-inline">MainActivity</strong> class, so we must annotate it with the <strong class="source-inline">@AndroidEntryPoint</strong> annotation:<p class="source-code"><strong class="bold">@AndroidEntryPoint</strong></p><p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            RestaurantsAppTheme { RestaurantsApp() }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">@AndroidEntryPoint</strong> annotation generates another component for our <strong class="source-inline">Activity</strong> with a lifetime narrower than the lifetime of the application. More precisely, this component allows us to scope dependencies to the lifetime of our <strong class="source-inline">Activity</strong>. </p>
			<ol>
				<li value="4">In the <strong class="source-inline">RestaurantsViewModel</strong> class, first refactor it to explicitly declare its dependencies by moving them inside its constructor so that testability is promoted through constructor injection:<p class="source-code">class RestaurantsViewModel <strong class="bold">constructor</strong>(</p><p class="source-code">   <strong class="bold">private val getRestaurantsUseCase:</strong> </p><p class="source-code"><strong class="bold">       GetInitialRestaurantsUseCase</strong>,</p><p class="source-code">    <strong class="bold">private val toggleRestaurantsUseCase:</strong> </p><p class="source-code">        <strong class="bold">ToggleRestaurantUseCase</strong></p><p class="source-code"><strong class="bold">)</strong> : ViewModel() {</p><p class="source-code">    private val _state = mutableStateOf(...)</p><p class="source-code">    [...]</p><p class="source-code">}</p></li>
			</ol>
			<p>Notice that, while we extracted<a id="_idIndexMarker711"/> the two Use Case variables into the constructor, we're no longer<a id="_idIndexMarker712"/> instantiating them – we will leave that to Hilt.</p>
			<ol>
				<li value="5">To get Hilt to inject <strong class="source-inline">RestaurantsViewModel</strong> for us, mark the <strong class="source-inline">ViewModel</strong> with the <strong class="source-inline">@HiltViewModel</strong> annotation, while also annotating its constructor with the <strong class="source-inline">@Inject</strong> annotation so that Hilt understands which dependencies of the <strong class="source-inline">ViewModel</strong> must be provided:<p class="source-code"><strong class="bold">@HiltViewModel</strong></p><p class="source-code">class RestaurantsViewModel <strong class="bold">@Inject</strong> constructor(</p><p class="source-code">   private val getRestaurantsUseCase: […] ,</p><p class="source-code">   private val toggleRestaurantsUseCase: […]) : </p><p class="source-code">       ViewModel() {</p><p class="source-code">    [...]</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that our <strong class="source-inline">ViewModel</strong> is annotated with <strong class="source-inline">@HiltViewModel</strong>, instances of <strong class="source-inline">RestaurantsViewModel</strong> will be provided by <strong class="source-inline">ViewModelComponent</strong> that respects the lifecycle of a <strong class="source-inline">ViewModel</strong> (bound to the lifetime of the composable destination while also surviving configuration changes).</p>
			<ol>
				<li value="6">Now that we instructed Hilt how to provide <strong class="source-inline">RestaurantsViewModel</strong>, we might think we're done; yet, if we build the application, we will get this exception:</li>
			</ol>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B17788_09_5.jpg" alt="Figure 9.5 – Hilt compilation error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Hilt compilation error</p>
			<p>The issue lies in the fact that, while we instructed Hilt<a id="_idIndexMarker713"/> to inject <strong class="source-inline">RestaurantsViewModel</strong> and its dependencies, we never made sure that Hilt<a id="_idIndexMarker714"/> knows how to provide those dependencies: neither the <strong class="source-inline">GetInitialRestaurantsUseCase</strong> dependency nor the <strong class="source-inline">ToggleRestaurantsUseCase</strong> dependency.</p>
			<p>In other words, if we want <strong class="source-inline">RestaurantsViewModel</strong> to be injected, we need to make sure that its dependencies can be provided by Hilt, and their dependencies too, and so on.</p>
			<ol>
				<li value="7">Let's first make sure that Hilt knows how to provide <strong class="source-inline">GetInitialRestaurantsUseCase</strong> to <strong class="source-inline">RestaurantsViewModel</strong>. Inside the <strong class="source-inline">GetInitialRestaurantsUseCase</strong> class, move its dependencies inside the constructor and mark it with <strong class="source-inline">@Inject</strong>, just like we did with <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">class GetInitialRestaurantsUseCase <strong class="bold">@Inject constructor</strong>(</p><p class="source-code">    <strong class="bold">private val repository: RestaurantsRepository,</strong></p><p class="source-code">    <strong class="bold">private val getSortedRestaurantsUseCase: </strong></p><p class="source-code"><strong class="bold">        GetSortedRestaurantsUseCase</strong>) {</p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>After you add the <strong class="source-inline">repository</strong> and <strong class="source-inline">getSortedRestaurantsUseCase</strong> variables inside<a id="_idIndexMarker715"/> the constructor, remember to remove the old member variables<a id="_idIndexMarker716"/> as well as their instantiation code from the body of <strong class="source-inline">GetInitialRestaurantsUseCase</strong>.</p>
			<p>Note that we aren't annotating the <strong class="source-inline">GetInitialRestaurantsUseCase</strong> class with any Hilt scope annotations, simply because we don't want it to be tied to a certain lifetime scope.</p>
			<p>Now, Hilt knows how to inject the <strong class="source-inline">GetInitialRestaurantsUseCase</strong> class, yet we must also instruct Hilt how to provide its dependencies as well: <strong class="source-inline">RestaurantsRepository</strong> and <strong class="source-inline">GetSortedRestaurantsUseCase</strong>.</p>
			<p>We need to make sure that Hilt knows how to provide instances of  <strong class="source-inline">RestaurantsRepository</strong>. We can see that its dependencies are <strong class="source-inline">RestaurantsApiService</strong> (the Retrofit interface) and <strong class="source-inline">RestaurantsDao</strong> (the Room Data Access Object interface):</p>
			<p class="source-code">class RestaurantsRepository {</p>
			<p class="source-code">    private var restInterface: RestaurantsApiService =</p>
			<p class="source-code">        Retrofit.Builder()</p>
			<p class="source-code">        […]</p>
			<p class="source-code">        .create(RestaurantsApiService::class.java)</p>
			<p class="source-code">    private var restaurantsDao = RestaurantsDb</p>
			<p class="source-code">        .getDaoInstance(</p>
			<p class="source-code">            RestaurantsApplication.getAppContext()</p>
			<p class="source-code">        )</p>
			<p class="source-code">    […]</p>
			<p class="source-code">}</p>
			<p>The issue here is that once we place these dependencies inside the constructor and inject them, Hilt will have no idea how to provide them – simply because we cannot tap into the internal workings of Room or Retrofit and inject their dependencies too, like we did with <strong class="source-inline">RestaurantsViewModel</strong>, <strong class="source-inline">GetInitialRestaurantsUseCase</strong>, and now with <strong class="source-inline">RestaurantsRepository</strong>.</p>
			<p>For Hilt to know how to provide dependencies<a id="_idIndexMarker717"/> out of our reach, we must create a <strong class="source-inline">module</strong> class where we will instruct Hilt<a id="_idIndexMarker718"/> on how to provide us with instances of <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong>:</p>
			<ol>
				<li value="8">Expand the <strong class="source-inline">restaurants</strong> package, then right click on the <strong class="source-inline">data</strong> package, and create a new package called <strong class="source-inline">di</strong> (short for dependency injection). Inside this package, create a new <strong class="source-inline">object</strong> class called <strong class="source-inline">RestaurantsModule</strong> and add the following code inside:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object RestaurantsModule { }</p></li>
			</ol>
			<p><strong class="source-inline">RestaurantsModule</strong> will allow us to instruct Hilt on how to provide Room and Retrofit dependencies to <strong class="source-inline">RestaurantsRepository</strong>. Since this is a Hilt module, we have done the following:</p>
			<ul>
				<li>Annotated it with <strong class="source-inline">@Module</strong> so that Hilt recognizes it as a module that provides instances of dependencies.</li>
				<li>Annotated it with <strong class="source-inline">@InstallIn()</strong> and passed the predefined <strong class="source-inline">SingletonComponent</strong> component provided by Hilt. Since our module is installed in this component, the dependencies that are contained can be provided anywhere throughout the application since <strong class="source-inline">SingletonComponent</strong> is an application-level dependency container.</li>
			</ul>
			<ol>
				<li value="9">Next up, inside <strong class="source-inline">RestaurantsModule</strong>, we need to tell Hilt how to provide our dependencies, so we will start with <strong class="source-inline">RestaurantsDao</strong>. For us to obtain an instance to <strong class="source-inline">RestaurantsDao</strong>, we must first instruct Hilt on how to instantiate a <strong class="source-inline">RestaurantsDb</strong> class.</li>
			</ol>
			<p>Add a <strong class="source-inline">provideRoomDatabase</strong> method annotated<a id="_idIndexMarker719"/> with <strong class="source-inline">@Provides</strong> that will instruct Hilt<a id="_idIndexMarker720"/> how to provide an <strong class="source-inline">RestaurantsDb</strong> object by borrowing part of the instantiation code of the <strong class="source-inline">database</strong> class from the <strong class="source-inline">companion object</strong> of the <strong class="source-inline">RestaurantsDb</strong> class:</p>
			<p class="source-code">@Module</p>
			<p class="source-code">@InstallIn(SingletonComponent::class)</p>
			<p class="source-code">object RestaurantsModule {</p>
			<p class="source-code"><strong class="bold">    @Singleton</strong></p>
			<p class="source-code"><strong class="bold">    @Provides</strong></p>
			<p class="source-code"><strong class="bold">    fun provideRoomDatabase(</strong></p>
			<p class="source-code"><strong class="bold">        @ApplicationContext appContext: Context</strong></p>
			<p class="source-code"><strong class="bold">    ): RestaurantsDb {</strong></p>
			<p class="source-code"><strong class="bold">        return Room.databaseBuilder(</strong></p>
			<p class="source-code"><strong class="bold">            appContext,</strong></p>
			<p class="source-code"><strong class="bold">            RestaurantsDb::class.java,</strong></p>
			<p class="source-code"><strong class="bold">            "restaurants_database"</strong></p>
			<p class="source-code"><strong class="bold">        ).fallbackToDestructiveMigration().build()</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>First off, we've annotated the <strong class="source-inline">provideRoomDatabase()</strong> method with the <strong class="source-inline">@Singleton</strong> instance so that Hilt will create only one instance of <strong class="source-inline">RestaurantsDb</strong> for the whole application, allowing us to save memory.</p>
			<p>Then, we can see that the <strong class="source-inline">provideRoomDatabase()</strong> method builds a <strong class="source-inline">RestaurantsDb</strong> instance, yet for this to work, we needed to provide<a id="_idIndexMarker721"/> the application-wide context<a id="_idIndexMarker722"/> to the <strong class="source-inline">Room.databaseBuilder()</strong> method. To achieve this, we have passed a <strong class="source-inline">Context</strong> object as a parameter of <strong class="source-inline">provideRoomDatabase()</strong> and annotated it with <strong class="source-inline">@ApplicationContext</strong>.</p>
			<p>To understand how Hilt provides us with the application <strong class="source-inline">Context</strong> object, we must first note that each Hilt container comes with a set of default bindings that we can inject as dependencies. The <strong class="source-inline">SingletonComponent</strong> container provides us with the application-wide <strong class="source-inline">Context</strong> object wherever we need it by defining the <strong class="source-inline">@ApplicationContext</strong> annotation.</p>
			<ol>
				<li value="10">Now that Hilt knows to provide us with <strong class="source-inline">RestaurantsDb</strong>, we can create another <strong class="source-inline">@Provides</strong> method that takes in a <strong class="source-inline">RestaurantsDb</strong> variable (which Hilt will now know how to provide) and return a <strong class="source-inline">RestaurantsDao</strong> instance:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object RestaurantsModule {</p><p class="source-code"><strong class="bold">  @Provides</strong></p><p class="source-code"><strong class="bold">  fun provideRoomDao(database: RestaurantsDb): </strong></p><p class="source-code"><strong class="bold">      RestaurantsDao  {</strong></p><p class="source-code"><strong class="bold">        return database.dao</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">  @Singleton</p><p class="source-code">  @Provides</p><p class="source-code">  fun provideRoomDatabase(</p><p class="source-code">      @ApplicationContext appContext: Context</p><p class="source-code">  ): RestaurantsDb { ... }</p><p class="source-code">}</p></li>
				<li>Still inside <strong class="source-inline">RestaurantsModule</strong>, we now have<a id="_idIndexMarker723"/> to tell Hilt how to provide<a id="_idIndexMarker724"/> us with an instance of <strong class="source-inline">RestaurantsApiService</strong>. Do the same as before, but this time add a <strong class="source-inline">@Provides</strong> method for an instance of <strong class="source-inline">Retrofit</strong>, and one for an instance of <strong class="source-inline">RestaurantsApiService</strong>. Now, <strong class="source-inline">RestaurantsModule</strong> should look like this:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">object RestaurantsModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideRoomDao(database: RestaurantsDb): […] {</p><p class="source-code">        return database.dao</p><p class="source-code">    }</p><p class="source-code">    @Singleton</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideRoomDatabase(@ApplicationContext</p><p class="source-code">        appContext: Context): RestaurantsDb {  [...]  }</p><p class="source-code"><strong class="bold">    @Singleton</strong></p><p class="source-code"><strong class="bold">    @Provides</strong></p><p class="source-code"><strong class="bold">    fun provideRetrofit(): Retrofit {</strong></p><p class="source-code"><strong class="bold">        return Retrofit.Builder()</strong></p><p class="source-code"><strong class="bold">            .addConverterFactory([…])</strong></p><p class="source-code"><strong class="bold">            .baseUrl("[…]")</strong></p><p class="source-code"><strong class="bold">            .build()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">    @Provides</strong></p><p class="source-code"><strong class="bold">    fun provideRetrofitApi(retrofit: Retrofit):  </strong></p><p class="source-code"><strong class="bold">        RestaurantsApiService {</strong></p><p class="source-code"><strong class="bold">    return retrofit</strong></p><p class="source-code"><strong class="bold">        .create(RestaurantsApiService::class.java)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Remember that all this instantiation code resides in <strong class="source-inline">RestaurantsRepository</strong>, so you can get it from there.</p>
			<ol>
				<li value="12">Now that Hilt knows <a id="_idIndexMarker725"/>how to provide both dependencies of <strong class="source-inline">RestaurantsRepository</strong>, head back in the <strong class="source-inline">RestaurantsRepository</strong> class and apply constructor<a id="_idIndexMarker726"/> injection with Hilt by adding the <strong class="source-inline">@Inject</strong> annotation to the constructor while moving its <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RestaurantsDao</strong> dependencies inside the constructor:<p class="source-code"><strong class="bold">@Singleton</strong></p><p class="source-code">class RestaurantsRepository <strong class="bold">@Inject constructor</strong>(</p><p class="source-code">    <strong class="bold">private val restInterface: RestaurantsApiService,</strong></p><p class="source-code">    <strong class="bold">private val restaurantsDao: RestaurantsDao</strong></p><p class="source-code">) {</p><p class="source-code">    suspend fun toggleFavoriteRestaurant(…) = […]</p><p class="source-code">         […]  </p><p class="source-code">    }</p></li>
			</ol>
			<p>Usually, <strong class="source-inline">Repository</strong> classes have a static instance so that only one instance is re-used throughout the app. This is useful when different data is stored in memory globally in <strong class="source-inline">Repository</strong> classes (be cautious with system-initiated process death because that will wipe anything in memory!).</p>
			<p>Finally, to have only one instance of <strong class="source-inline">RestaurantsRepository</strong> that can then be reused across the app, we have annotated the class with the <strong class="source-inline">@Singleton</strong> annotation. This annotation<a id="_idIndexMarker727"/> is provided by the Hilt <strong class="source-inline">SingletonComponent</strong> container and allows<a id="_idIndexMarker728"/> us to scope instances of classes to the lifetime of the application.</p>
			<ol>
				<li value="13">Now that Hilt knows how to inject <strong class="source-inline">RestaurantsRepository</strong>, let's get back to the other remaining dependency of <strong class="source-inline">GetInitialRestaurantsUseCase</strong>: the <strong class="source-inline">GetSortedRestaurantsUseCase</strong> class. Head inside this class and make sure to inject its dependencies by moving the <strong class="source-inline">repository</strong> variable inside the constructor as we did before with other classes:<p class="source-code">class GetSortedRestaurantsUseCase <strong class="bold">@Inject constructor(</strong></p><p class="source-code">    <strong class="bold">private val repository: RestaurantsRepository</strong></p><p class="source-code"><strong class="bold">)</strong> {</p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; {</p><p class="source-code">        return repository.getRestaurants()</p><p class="source-code">            .sortedBy { it.title }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>While we have annotated <strong class="source-inline">RestaurantsRepository</strong> with a scope annotation, we haven't added any scope annotation for this Use Case class simply because we don't want the instance to be preserved across a specific lifetime.</p>
			<p>Now, we have instructed Hilt how to provide all the dependencies for the first dependency of <strong class="source-inline">RestaurantsViewModel</strong>, which is <strong class="source-inline">GetInitialRestaurantsUseCase</strong>!</p>
			<ol>
				<li value="14">Next up, let's tell Hilt how to provide the dependencies for the second and last dependency of <strong class="source-inline">RestaurantsViewModel</strong>, the <strong class="source-inline">ToggleRestaurantUseCase</strong> class. Head inside this class<a id="_idIndexMarker729"/> and make sure to inject its dependencies<a id="_idIndexMarker730"/> by moving the <strong class="source-inline">repository</strong> and <strong class="source-inline">getSortedRestaurantsUseCase</strong> variables inside the constructor as we did before with other classes:<p class="source-code">class ToggleRestaurantUseCase <strong class="bold">@Inject constructor(</strong></p><p class="source-code"><strong class="bold">    private val repository: RestaurantsRepository,</strong></p><p class="source-code"><strong class="bold">    private val getSortedRestaurantsUseCase: </strong></p><p class="source-code"><strong class="bold">        GetSortedRestaurantsUseCase</strong></p><p class="source-code"><strong class="bold">) </strong>{</p><p class="source-code">    suspend operator fun invoke(id: Int, oldValue: </p><p class="source-code">        Boolean): List&lt;Restaurant&gt; {</p><p class="source-code">        val newFav = oldValue.not()</p><p class="source-code">        repository.toggleFavoriteRestaurant(id, newFav)</p><p class="source-code">        return getSortedRestaurantsUseCase()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Optionally, you can head inside the <strong class="source-inline">RestaurantsDb</strong> class and delete the entire <strong class="source-inline">companion object</strong> that was in charge of providing a singleton instance for our <strong class="source-inline">RestaurantsDao</strong>. The <strong class="source-inline">RestaurantsDb</strong> class should now be much slimmer and look like this:<p class="source-code">@Database(</p><p class="source-code">    entities = [LocalRestaurant::class],</p><p class="source-code">    version = 3,</p><p class="source-code">    exportSchema = false</p><p class="source-code">)</p><p class="source-code">abstract class RestaurantsDb : RoomDatabase() {</p><p class="source-code">    abstract val dao: RestaurantsDao</p><p class="source-code">}</p></li>
			</ol>
			<p>It's safe to delete this instantiation code because from now on, Hilt will do that for us out of the box.</p>
			<ol>
				<li value="16">Also, if you followed the previous<a id="_idIndexMarker731"/> step of cleaning up the <strong class="source-inline">RestaurantsDb</strong> class, inside <strong class="source-inline">RestaurantsApplication</strong>, you can also remove all the logic inside<a id="_idIndexMarker732"/> this class that was related to obtaining the application-wide <strong class="source-inline">Context</strong> object. From now on, Hilt will do that for us out of the box.</li>
			</ol>
			<p>The <strong class="source-inline">RestaurantsApplication</strong> class should be much slimmer and look like this:</p>
			<p class="source-code">@HiltAndroidApp</p>
			<p class="source-code">class RestaurantsApplication: Application()</p>
			<ol>
				<li value="17">Build and run the application. Now, the build should be successful because Hilt is in charge of providing the dependencies that we required it to provide.</li>
			</ol>
			<p>With the help of DI, we have now promoted testability while also extracting the boilerplate associated with building class instances.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">We have integrated DI with Hilt for the first screen of <strong class="source-inline">RestaurantsApplication</strong>. However, the project is still not incorporating DI entirely because the second destination of our app (represented by the <strong class="source-inline">RestaurantDetailsScreen()</strong> composable) has neither its <strong class="source-inline">RestaurantDetailsViewModel</strong> injected nor this <strong class="source-inline">ViewModel</strong> class's dependencies injected. As a take-home assignment, incorporate DI in this second screen. This will allow you to get rid of the redundant Retrofit client instantiation inside <strong class="source-inline">RestaurantDetailsViewModel</strong> – remember that you can now inject a <strong class="source-inline">RestaurantsApiService</strong> instance directly with Hilt!</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor303"/>Summary</h1>
			<p>In this chapter, we improved the architecture of the Restaurants App by incorporating DI.</p>
			<p>We discussed what DI is and covered its basic concepts: dependency with its implicit or explicit types, injection, dependency containers, and manual injection.</p>
			<p>We then examined the main benefits that DI brings to our projects: testable classes and less boilerplate code.</p>
			<p>Finally, we covered how DI frameworks can help us with the injection of dependencies, and explored the Jetpack Hilt library as a viable solution for DI on Android. Afterward, we practiced what we learned as we incorporated DI with Hilt in our Restaurants app.</p>
			<p>Since we incorporated DI, it's a bit clearer that our classes can be easily tested, so it's time we start writing some tests in the next chapter!</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor304"/>Further reading</h1>
			<p>Knowing how to work with the basics of Hilt is usually enough for most projects. However, sometimes you might need to use more advanced features of Hilt or Dagger. To learn more about Dagger and how the framework automatically creates the dependencies for you by building a dependency graph, check this article: <a href="https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82">https://medium.com/android-news/dagger-2-part-i-basic-principles-graph-dependencies-scopes-3dfd032ccd82</a>.</p>
			<p>On the same note, apart from the <strong class="source-inline">@Singleton</strong> scope that was the most used scope throughout our app, Dagger Hilt exposes a broader variety of predefined components and scopes that allow you to scope different classes to various lifecycles. Check out more about components and their scopes in the official documentation: <a href="https://dagger.dev/hilt/components.html">https://dagger.dev/hilt/components.html</a>.</p>
			<p>Leaving components and their scopes aside, in some projects, you might need to allow injection of dependencies in other Android classes than <strong class="source-inline">Activity</strong>. To see which Android classes can be annotated with <strong class="source-inline">@AndroidEntryPoint</strong>, check out the documentation: https://dagger.dev/hilt/android-entry-point.</p>
		</div>
	</body></html>