["```swift\nclass Person {\n  var firstName: String\n  var lastName: String\n\n  init (firstName: String, lastName: String) {\n    self.firstName = firstName\n    self.lastName = lastName\n  }\n }\n\nclass JournalEntry {\n  var title: String\n  var text: String\n  var date: NSDate\n\n  init (title: String, text: String) {\n    self.title = title\n    self.text = text\n    date = NSDate()\n  }\n}\n```", "```swift\n    var name = \"Sara\"\n    ```", "```swift\n    let name = \"Sara\"\n    ```", "```swift\nvar name = \"Sam\"\nname = \"Jon\"\n\nlet lastName = \"Peterson\"\nlastName = \"Jakson\" //Error, can't change constant after assigning\n```", "```swift\nclass Person {\n  let name: String\n  let lastName: String\n...\n}\n\nclass JournalEntry {\n  let title: String\n  let text: String\n  let date: NSDate\n...\n}\n```", "```swift\nlet person = Person(firstName: \"Jon\", lastName: \"Bosh\")\nlet man = true\n\nvar fullName: String\nif man {\n  fullName = \"Mr \"\n} else {\n  fullName = \"Mrs \"\n}\n\nfullName += person.firstName\nfullName += \" \"\nfullName += person.lastName\n```", "```swift\nlet person = Person(firstName: \"Jon\", lastName: \"Bosh\")\nlet man = true\n\nlet gender: String = man ? \"Mr\": \"Mrs\"\nlet fullName = \"\\(gender) \\(person.firstName) \\(person.lastName)\"\n```", "```swift\nvar person = Person(firstName: \"Jon\", lastName: \"Bosh\")\np.firstName = \"Sam\" // Error\n```", "```swift\nclass Person {\n  let nickName: String\n…\n\nfunc changeNickName(nickName: String) -> Person  {\n    return Person(firstName: firstName, lastName: lastName,\n                   nickName: nickName)\n  }\n}\n\nlet sam = Person(firstName: \"Sam\", lastName: \"Bosh\", \n  nickName:\"sam\")\nlet rockky = sam.changeNickName(\"Rockky\")\n```", "```swift\nvar sam = Person(firstName: \"Sam\", lastName: \"Bosh\", \n  nickName:\"BigSam\")\nsam = sam.changeNickName(\"Rockky\")\n```", "```swift\nclass DangerousWorker {\n  var entries: [JournalEntry]\n\n  init() {\n    //Add test entries\n    let entry = JournalEntry(title: \"Walking\", text: \"I was \n      walking in the loop\")\n    entries = Array(count: 100, repeatedValue: entry)\n  }\n\n  func dangerousMultithreading() {\n\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {\n      sleep(1) //emulate work\n      self.entries.removeAll()\n    }\n\n    print(\"Start Main\")\n    for _ in 0..<entries.endIndex {\n      entries.removeLast() //Crash\n      sleep(1) //emulate work\n    }\n  }\n}\n\nlet worker = DangerousWorker()\nworker.dangerousMultithreading()\n```", "```swift\nlet entries: [JournalEntry]\n\nlet entry = JournalEntry(title: \"Walking\", text: \"I was walking\")\nentries = Array(count: 100, repeatedValue: entry)\n// entries is immutable now, read-only\n\ndispatch_async(dispatch_get_global_queue(\n              DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)) {\n\n  for entry in self.entries {\n    print(\"\\(entry) in BG\")\n  }\n}\n\nfor entry in self.entries {\n  print(\"\\(entry) in BG\")\n}\n```", "```swift\nlet person = Person(firstName: \"Sam\", lastName: \"Jakson\")\nlet a = person, b = person, c = person\n```", "```swift\na.firstName = \"Jaky\"\nb.firstName // Jaky\n```", "```swift\nlet person = Person(firstName: \"Sam\", lastName: \"Jakson\")\nlet a = person, b = person, c = person\n```", "```swift\nstruct Person {\n  let firstName: String\n  let lastName: String\n  let nickName: String\n\n  func changeNickName(nickName: String) -> Person  {\n    return Person(firstName: firstName, lastName: lastName,nickName: nickName)\n  }\n}\n\nextension Person {\n\n  init(firstName: String, lastName: String) {\n    self.init(firstName: firstName, lastName: lastName,       nickName:\"\")\n  }\n}\n```", "```swift\n  Person(firstName: \"Sam\", lastName:\"Niklson\", nickName: \"Bigsam\")\n  Person(firstName: \"Petter\", lastName: \"Hanson\")\n```", "```swift\n    struct Journal {\n      let owner: Person\n      var entries: [JournalEntry]\n\n      mutating func addEntry(title: String, text: String) {\n        let entry = JournalEntry(title: title, text: text)\n        entries.append(entry)\n      }\n    }\n\n    extension Journal {\n      init(owner: Person) {\n        self.owner = owner\n        self.entries = []\n      }\n    }\n    ```", "```swift\n    class JournalController  {\n      var journal: Journal\n\n      init(owner: Person) {\n        self.journal = Journal(owner: owner)\n      }\n\n      func addEntry(title: String, text: String) {\n        journal.addEntry(title, text: text);\n      }\n    }\n    ```", "```swift\nvar view: Optional<UIView>\nvar index: Int?\n\nview = nil\nview = UIView()\n\nindex = 10\nindex = nil\n```", "```swift\n- (NSUInteger)indexOfObject:(id)anObject;\n+ (instancetype)stringWithString:(NSString *)string;\n```", "```swift\nvar index: Int?\nvar number: Int = 10\n\nindex = nil // Ok\nnumber = nil // Error\n\nfunc indexOfObject(object: Any) -> Int?\nfunc stringWithString(string: String?) -> String?\n```", "```swift\n[NSString initWithString: nil] – crash\n```", "```swift\nstruct Location {\n  let latitude: Double\n  let longitude: Double\n}\n\nstruct JournalEntry {\n  var location: Location?\n...\n}\nvar entry = JournalEntry(title: \"Walking\", text: \"I was walking in the loop\")\nlet location = Location(latitude: 37.331686, longitude: -122.030656)\nentry.location = location\n```", "```swift\nif entry.location != nil {\n  showLocation(entry.location!)\n} else {\n  //locationNotAvailable\n}\n```", "```swift\nlet location = entry.location\nif let location = location {\n  showLocation(location)\n} else {\n  //locationNotAvailable\n}\n```", "```swift\nif let location = maybeLocation {\n  showLocation(location)\n}\n```", "```swift\nvar name: String! = \"Jon\"\nprint(\"My name is\" + name)\n\nname = nil\nprint(\"My name is \" + name) // Crash\n```", "```swift\nfunc hello() {\n    print(\"Hello\")\n}\n\nfunc add(x: Int, y: Int) -> Int {\n    return x + y\n}\n\nfunc subtract(x: Int, y: Int) -> Int {\n    return x - y\n}\n\nvar hi: () -> () = hello\nvar mathOperation: (Int, Int) -> Int\n\nmathOperation = add \nmathOperation(10, 11) // 21\nmathOperation = subtract\nmathOperation(10, 11) // -1\n\nhi()\nmathOperation = hello // Error, wrong types\n```", "```swift\nlet numbers = [1, 2, 3]\n\nfunc doubleNumbers(array: [Int]) -> [Int] {\n\n  var result = [Int]()\n  for element in numbers {\n    result.append(element * 2)\n  }\n  return result\n}\n\nlet result = doubleNumbers(numbers) // [2, 4, 6]\n```", "```swift\nfunc transform(array: [Int], f: Int -> Int) -> [Int] {\n\n  var result = [Int]()\n  for element in array {\n    result.append(f(element))\n  }\n  return result\n}\n```", "```swift\nfunc double(x: Int) -> Int {\n    return x * 2\n}\n\nfunc triple(x: Int) -> Int {\n    return x * 3\n}\n\nlet result = transform(numbers, f: double)\nlet result = transform(numbers, f: triple)\n```", "```swift\n{ (parameter name: type) -> return type in  body }\n```", "```swift\ntransform(numbers, f: { (x: Int) -> Int in\n  return x * 2\n})\n```", "```swift\ntransform(numbers, f: { x in\n  return x * 2\n})\n```", "```swift\ntransform(numbers, f: { x in x * 2 })\n```", "```swift\ntransform(numbers, f: { x in\n  let result = x * 2\n  return result + 10 \n})\n```", "```swift\ntransform(numbers, f: { $0 * 2 })\n```", "```swift\ntransform(numbers) { $0 * 2 }\n```", "```swift\ntransform(numbers) { x in x * 2 }\n```", "```swift\nfunc map(function: Int -> Int) -> [Int] {\n  ...\n}\nmap() { $0 * 2 }\nmap { $0 * 2 }\n```", "```swift\nfunc map(transform: (Int) -> String) -> [String]\n```", "```swift\nfunc map<T>(@noescape transform: (Self.Generator.Element) -> T) -> [T]\n```", "```swift\nlet result = numbers.map(double)\nlet result = numbers.map { $0 * 2 }\n```", "```swift\nfunc map<U>(@noescape f: (Wrapped) -> U) -> U?\n```", "```swift\nfunc map(f: (Wrapped) -> Double) -> Double? {\n  switch self {\n    case .None: return nil\n    case .Some(let x): return f(x)\n  }\n} \n\nlet number: Int? = 10\nlet res = number.map { Double($0) * 2.3 }\n```", "```swift\n// Using the map function \nlet doubled = number.map(double)\n\n// Optional binding \nlet doubled: Int?\nif let number = number {\n  doubled = double(number)\n} else {\n  doubled = nil\n}\n```", "```swift\nfunc reduce(initial: Double, combine: (Double, Int) -> Double) -> Double\n```", "```swift\n{\n  var result = initial\n  for item in self {\n    result = combine(result, item)\n  }\n  return result\n}\n\nlet sum = numbers.reduce(0) { acc, number in acc + number }\n```", "```swift\nnumbers.reduce(0) { $0 + $1 }\nnumbers.reduce(0, combine: +)\n```", "```swift\ninfix operator + {\n    associativity left\n    precedence 140\n}\nfunc +(lhs: Int, rhs: Int) -> Int\n```", "```swift\nfunc filter(includeElement: (Int) -> Bool) -> [Int]\n```", "```swift\n{\n  var filtered = [Int]()\n  for item in self {\n    if includeElement(item) {\n      filtered.append(item)\n    }\n  }\n  return filtered\n}\n\nlet evenNumbers = numbers.filter { $0 % 2 == 0 }\n```", "```swift\nfunc printMe(x: Int) {\n  print(\"Me - \\(x)\")\n}\n```", "```swift\nfunc printMe<T>(x: T) {\n  print(\"Me - \\(x)\")\n}\n\nprintMe(10.0)\n```", "```swift\nfunc transform<T>(array: [T], function: T -> T) -> [T] {\n\n  var result = [T]()\n  for element in array {\n    result.append(function(element))\n  }\n  return result\n}\n```", "```swift\nlet numbers = [1, 2, 3]\nlet increasedNumbers = transform(numbers) { $0 + 1}\n\nlet names = [\"Jon\", \"Sara\", \"Sam\"]\nlet formattedNames = transform(names) { \"Name: \" + $0 }\n```", "```swift\nfunc minElem<T>(x: T, _ y: T) -> T {\n  return x < y ? x : y\n}\n```", "```swift\n<type parameter : constraint >\n\nfunc minElem<T : Comparable>(x: T, _ y: T) -> T {\n  return x < y ? x : y\n}\n```", "```swift\nminElem(10, 20)\nminElem(\"A\", \"B\")\n```", "```swift\nfunc ==(lhs: Self, rhs: Self) -> Bool\nfunc <(lhs: Self, rhs: Self) -> Bool\n```", "```swift\nextension JournalEntry : Comparable {\n}\n\nfunc == (lhs: JournalEntry, rhs: JournalEntry) -> Bool {\n\n  return lhs.title == rhs.title &&\n    lhs.text == rhs.text &&\n    lhs.date == rhs.date\n}\n\nfunc < (lhs: JournalEntry, rhs: JournalEntry) -> Bool {\n  return lhs.text < rhs.text\n}\n```", "```swift\nstruct JournalEntry : Comparable, Hashable, CustomStringConvertible { \n...\n}\n```", "```swift\nlet walking = JournalEntry(title: \"Walking\", text: \"It was a great weather\")\nlet goal = JournalEntry(title: \"Read\", text: \"Read a book\")\nlet smaller = minElem(walking, goal)\n```", "```swift\nstruct Array<T> ...\nstruct Dictionary<Key : Hashable, Value> ...\nstruct Set<T : Hashable> ...\n```", "```swift\nvar numbers = [1, 2, 3] // [Int]\nnumbers.append(10)\nnumbers.append(\"Name\") //Error, Can't add String to [Int] array\n```", "```swift\nstruct Stack<T> {\n  private var items: [T]\n\n  mutating func push(item: T) {\n    items.append(item)\n  }\n\n  mutating func pop() -> T {\n    return items.removeLast()\n  }\n\n  init() {\n    items = []\n  }\n}\n\nvar s = Stack<Int>()\ns.push(10) // 10\n//s.push(\"Name\") // Error\ns.push(4)  // 10, 4\ns.pop()    // 10\n```", "```swift\n    func increase(x: Int) -> Int {\n      return x + 1\n    }\n\n    let x = 10\n    let percent = 0.3\n    let name = \"Sara\"\n\n    x + name //Error, can't apply + operator for Int and String\n    x * percent //Error, can't apply * to Int and Double\n    Double(x) * percent // 3\n\n    increase(x) // 11\n    increase(percent) // Wrong type\n    increase(name) // Wrong type\n    ```", "```swift\n    var y: Int\n    //y + 10 //Error, variable 'y' used before being initialized\n    y = 1\n    y + 10\n    ```", "```swift\n    let z: Int\n\n    if y == 2 {\n      z = 10\n    } else {\n      z = 0\n    }\n    z + 10\n    ```", "```swift\n    var x: Int?\n    x! + 10 // Crash! Unwrapping optional that does not have value.\n\n    var y: Int!\n    y + 10 // Crash! Implicitly unwrapped optional has nil value.\n    ```", "```swift\n    var view: UIView = UIImageView()\n    if view is UIImageView {\n      print(\"yes\")\n    } else {\n      print(\"no\")\n    }\n    ```", "```swift\n    let imageView = view as! UIImageView\n    ```", "```swift\n    if let view = view as? UIImageView {\n      view.image = UIImage(named: \"image\")\n    }\n    ```", "```swift\n    int count(int *a); // C function\n    ```", "```swift\n    count(a: UnsafeMutablePointer<Int32>)\n    ```", "```swift\n    var x: Int32 = 10\n    count(&x)\n    ```", "```swift\n    let pointer = UnsafeMutablePointer<Int>.alloc(1)\n    pointer.memory = 10\n    pointer.memory // store Int value - 10\n    pointer.dealloc(1)\n    ```", "```swift\n    let numbers = [1, 2, 3]\n\n    numbers.count\n    numbers[1]\n    numbers[10] //Crash\n    ```", "```swift\n    if numbers.count > 10 {\n      numbers[10]\n    }\n    ```"]