<html><head></head><body>
        

            
                <h1 class="header-title">Converting Your Game from 2D to 3D</h1>
            

            
                
<p>Now, be aware that making a 3D game from scratch in Android Studio is a Herculean task. It isn't absolutely essential to make a game from scratch in 3D because there are plenty of tools and game engines available on the market, which eliminate the requirement of having to work on creating everything from scratch. However, an understanding of how the nuts and bolts operate behind the scenes will definitely help you in the long run.</p>
<p>We will learn the basics of some advanced concepts in this chapter, and by the end of this chapter, you will have an understanding of how to create a basic 3D object in Android Studio. For the purpose of this chapter, we will create a new Android Studio project since we will not continue in our previous game project folder. However, before we get started, let's take a look at the concepts that we will be learning in brief. We will learn the following concepts in this chapter:</p>
<ul>
<li>Introduction to OpenGL ES</li>
<li>Learning about the 3D coordinate system using OpenGL ES</li>
<li>Creating a scene using OpenGL ES
<ul>
<li>Project folder</li>
<li>Render class and main activity</li>
<li>Defining shapes</li>
</ul>
</li>
</ul>
<p>To create our 3D graphics, we will use OpenGL ES for rendering our graphics. Let's understand what OpenGL ES is.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Introduction to OpenGL ES</h1>
            

            
                
<p>High-performance 2D and 3D graphics are supported on Android with the OpenGL library. We have the OpenGL ES API, which is used for this. This API specifies the interface for 3D graphics processing hardware. OpenGL is a huge library and from that, a part of it is OpenGL ES which is specifically created for embedded devices.</p>
<p>The various versions of the OpenGL ES API supported on Android are as follows:</p>
<ul>
<li>1.0 and 1.1: Supported by Android 1.0 and higher</li>
<li>2.0: Supported by Android 2.2 (API level 8) and higher</li>
<li>3.0: Supported by Android 4.3 (API level 18) and higher</li>
<li>3.1: Supported by Android 5.0 (API level 21) and higher</li>
</ul>
<p>You can read more general information about this on the official website for Android here at <a href="https://developer.android.com/guide/topics/graphics/opengl.html">https://developer.android.com/guide/topics/graphics/opengl.html</a>.</p>
<p>Using OpenGL ES, you can create 3D graphics on Android. Since we will be creating 3D objects, we will need to understand the coordinate system. Let's take a quick look at the 3D coordinates system that we will use for our examples.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Learning about the 3D coordinate system</h1>
            

            
                
<p>While making our 2D game, we were only dealing with <em>x</em> and <em>y</em> axis values. However, when you are making a 3D game, you have to deal with three axis values: <em>x</em>, <em>y</em>, and <em>z</em>. We're pretty much clear how our <em>x</em> and <em>y</em> axis values work by now. In a similar way, our <em>z</em> axis is projected on the front and back of our mobile device. The following image will explain the three axes in our 3D coordinate system better:</p>
<div><img class="image-border" height="156" src="img/B05066_09_01.png" width="277"/></div>
<p>The positive x, y, and z axis on phone</p>
<p>The axes you see in the preceding image are positive directions. If you take their opposite sides, you will get negative values. The origin point starts from (0,0,0), and your values can be float values that will denote your object's location in 3D space.</p>
<p>Here's a classic problem that you might encounter while dealing with OpenGL in terms of device screen sizes. The grid in OpenGL assumes a screen, which is square and has a uniform coordinate system. However, if your screen size varies, then a non-square screen is considered as if it is a perfectly square screen. In order to understand this, take a look at the following figure:</p>
<div><img class="image-border" height="217" src="img/B05066_09_02.jpg" width="546"/></div>
<p>Understanding the default OpenGL coordinate system</p>
<p>As you can see in the preceding figure, we have two different screens, one is square shaped and the other is a rectangle. Now, what happens here is that even though your screen is a rectangle, it is considered a square and because of that, your graphics get stretched. To tackle this issue, you need to apply OpenGL projection modes and camera views to transform the coordinates in order to get a proper proportion on any display.</p>
<p>To do so, we create a projection matrix and a camera view matrix, and then apply that to our OpenGL rendering pipeline. The projection matrix helps us to process the coordinates by recalculating the matrix of our graphics so that they are mapped correctly onto our device screens. The camera view matrix helps create a transformation that renders the object from a specific eye position.</p>
<p>You can read up more about OpenGL ES over at <a href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a>.</p>
<p>Now that we have learned about these basic concepts, we can get started with creating our 3D game scene using OpenGL ES in Android; let's begin!</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a 3D scene with OpenGL ES</h1>
            

            
                
<p>Just as we did in our 2D game example, most of our draw mechanism is going to remain the same. You will see that there are many similarities between both procedures. We will be working on a new project folder for this example, so let's go ahead and create a new project as we did in <a href="1942c8c2-08a2-4c18-8740-8b7e9103bc6e.xhtml" target="_blank">Chapter 8</a>, <em>Adding Explosion and Creating a UI</em>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating our project folder</h1>
            

            
                
<p>We will follow the steps we did in <a href="9563ed54-bb46-4d59-9225-ed418d3e0b29.xhtml" target="_blank">Chapter 2</a>, <em>Getting Familiar with Android Studio</em>. First, we will create a new project from our top menu.</p>
<p>To create a new project, perform the following steps:</p>
<ol>
<li>Go to File | New | New Project..., as shown in the following screenshot:</li>
</ol>
<div><img class="image-border" height="394" src="img/B05066_09_03.png" width="360"/></div>
<ol start="2">
<li>Fill in your Application name, Company domain, and Package name details; then click on Next:</li>
</ol>
<div><img class="image-border" height="408" src="img/B05066_09_04.png" width="698"/></div>
<ol start="3">
<li>Select your target devices and click on Next:</li>
</ol>
<div><img class="image-border" height="405" src="img/B05066_09_05.png" width="703"/></div>
<ol start="4">
<li>Select Empty Activity and click on Next:</li>
</ol>
<div><img class="image-border" height="399" src="img/B05066_09_06.png" width="686"/></div>
<ol start="5">
<li>Fill in your Activity Name, Layout Name, and click on Finish:</li>
</ol>
<div><img class="image-border" height="408" src="img/B05066_09_07.png" width="708"/></div>
<p class="CDPAlignLeft CDPAlign">Okay then, we are now set with our new project folder. Also, we will use the landscape mode orientation for this project, so we will define it in our <kbd>AndroidManifest.xml</kbd> file. Open up your manifest file from the <kbd>app/manifests/AndroidManifest.xml</kbd> file and make the following change that is marked in bold:</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br/>    package="com.nikmlnkr.my3Dgame"&gt;<br/><br/>    &lt;application<br/>        android:allowBackup="true"<br/>        android:icon="@mipmap/ic_launcher"<br/>        android:label="@string/app_name"<br/>        android:roundIcon="@mipmap/ic_launcher_round"<br/>        android:supportsRtl="true"<br/>        android:theme="@style/AppTheme"&gt;<br/><strong>&lt;activity android:name=".MainActivity" <br/>        android:screenOrientation="landscape"&gt;</strong><br/>            &lt;intent-filter&gt;<br/>                &lt;action android:name="android.intent.action.MAIN" /&gt;<br/><br/>                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>            &lt;/intent-filter&gt;<br/>        &lt;/activity&gt;<br/>    &lt;/application&gt;<br/><br/>&lt;/manifest&gt;
</pre>
<p>Let's now define our main activity and create a render class for our 3D game view.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a render class and defining a main activity</h1>
            

            
                
<p>In order to see anything on the screen, we have to render it on screen. Therefore, we need to create a render class that will handle the rendering part of our functioning. Rendering is the process of generating an image from a 2D or 3D model by means of computer programs. We will name our render class as <kbd>MyGLRenderer</kbd>, but before we do that, let's define our main activity. So, open up your <kbd>MainActivity.java</kbd> file, and we will create three default methods there. Remove everything you see on screen, except for the first line that's your package name. We will have three methods:</p>
<ul>
<li><kbd>onCreate()</kbd>: This initializes our main activity</li>
<li><kbd>onPause()</kbd>: This handles the app if it goes into background</li>
<li><kbd>onResume()</kbd>: After the user resumes back to the app, this method is called</li>
</ul>
<p>Also, we are dealing with OpenGL graphics here, and for that reason, we will need a <kbd>GLSurfaceView</kbd>, just as we worked in our 2D game wherein we had a surface view for our game.</p>
<p>So, let's create them in our <kbd>MainActivity.java</kbd> file, as follows:</p>
<pre>
package com.nikmlnkr.my3Dgame;<br/><br/>import android.app.Activity;<br/>import android.opengl.GLSurfaceView;<br/>import android.os.Bundle;<br/><br/>public class MainActivity extends Activity {<br/><br/>    private GLSurfaceView gv;<br/><br/>    //Our onCreate method<br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        gv = new GLSurfaceView(this);<br/>        gv.setRenderer(new MyGLRenderer(this));<br/>        this.setContentView(gv);<br/>    }<br/><br/>    //Resume method<br/>    @Override<br/>    protected void onResume() {<br/>        super.onResume();<br/>        gv.onResume();<br/>    }<br/><br/>    //Pause method<br/>    @Override<br/>    protected void onPause() {<br/>    super.onPause();<br/>        gv.onPause();<br/>    }<br/>}
</pre>
<p>Okay, that seems sorted, but now we are getting an error on our <kbd>MyGLRenderer</kbd> line. That's because we still haven't made our renderer class yet. Let's make our renderer class now. Create a new Java class file named <kbd>MyGLRenderer.java</kbd>, and let's get started with writing our renderer class.</p>
<p>The <kbd>Renderer</kbd> class is where you will do most of your object displaying part.</p>
<p>The interface <kbd>GLSurfaceView.Renderer</kbd> is responsible for making OpenGL render a frame, hence we will need to implement it as an interface in our code; so we will start with our very first line, which will do the same. We will extend our class to the <kbd>GLSurfaceView.Renderer</kbd> interface and write a default constructor, as follows:</p>
<pre>
public class MyGLRenderer implements GLSurfaceView.Renderer {<br/>    Context ct;    //Context variable<br/><br/>    //Constructor of our renderer class<br/>    public MyGLRenderer(Context ct) {<br/>        this.ct = ct;<br/>    }<br/>}
</pre>
<p>Now, inside this class, as we had in our 2D sprite example game, we will need three methods to draw on the screen; they are <kbd>onSurfaceCreated()</kbd>, <kbd>onSurfaceChanged()</kbd>, and <kbd>onDraw()</kbd>. However, in OpenGL, the <kbd>onDraw()</kbd> method is actually <kbd>onDrawFrame()</kbd>, so let's define those three methods one by one.</p>
<p>First, we will start with our <kbd>onSurfaceChanged()</kbd> method. In this method, we will create our surface. This method is for the initialization of our scene. Here, we will create a simple black screen drawn on the screen. In order to set our color, we will use RGBA values. For a black color, we will need (0,0,0,1) RGBA values. We will also add in some more initialization factors here:</p>
<pre>
    @Override<br/>    public void onSurfaceCreated(GL10 gles, EGLConfig c) {<br/>        gles.glClearColor(0.0f, 0.0f, 0.0f, 1.0f); <br/>        //Clear color and set to black<br/>    <br/>        gles.glClearDepthf(1.0f); <br/>        //Clear depth<br/>    <br/>        gles.glEnable(GL10.GL_DEPTH_TEST);<br/>        //Enable depth test<br/>    <br/>        gles.glDepthFunc(GL10.GL_LEQUAL); <br/>        //Set depth function<br/><br/>        gles.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, <br/>        GL10.GL_NICEST);<br/>        //set gl to nicest<br/><br/>        gles.glShadeModel(GL10.GL_SMOOTH); <br/>        //set shade model to smooth<br/>    <br/>        gles.glDisable(GL10.GL_DITHER); <br/>        //disable dither<br/>    }
</pre>
<p>These parameters are basically required to set various aspects in an OpenGL ES environment. You can read up more about these specific methods and more through <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/">https://www.khronos.org/registry/OpenGL-Refpages/es3.0/</a>.</p>
<p>This method gets called after the <kbd>onSurfaceCreated()</kbd> method and also every time our screen resolution changes. Basically, this method is responsible for creating the display matrix that we saw earlier in the chapter, which in turn creates a uniform shape on any screen:</p>
<pre>
    @Override<br/>    public void onSurfaceChanged(GL10 gles, int w, int h) {<br/>        if (h == 0) h = 1;<br/>        float aspect = (float)w / h;<br/><br/>        gles.glViewport(0, 0, w, h); <br/>        //dynamically set the width and height of our viewport as per screen <br/>        resolution<br/><br/>        gles.glMatrixMode(GL10.GL_PROJECTION); <br/>        //set our matrix mode projection<br/>    <br/>        gles.glLoadIdentity();<br/>        GLU.gluPerspective(gles, 45, aspect, 0.1f, 100.f);<br/><br/>        gles.glMatrixMode(GL10.GL_MODELVIEW); <br/>        //set our camera view matrix mode<br/><br/>        gles.glLoadIdentity();<br/>    }
</pre>
<p>Finally, we have our <kbd>onDrawFrame()</kbd> function, which is used to draw the current frame. After every frame, we need to clear the previous screen drawn, and for that reason, we call <kbd>glClear()</kbd> in this before we render any code further. Right now, we will just write our clear code and when we will draw our object shapes in this function after our clear code:</p>
<pre>
    @Override<br/>    public void onDrawFrame(GL10 gles) {<br/>        gles.glClear(GL10.GL_COLOR_BUFFER_BIT | <br/>        GL10.GL_DEPTH_BUFFER_BIT);    <br/>        //clear depth buffer<br/>    }
</pre>
<p>Finally, this is how your entire code will look like for your <kbd>Renderer</kbd> class:</p>
<pre>
package com.nikmlnkr.my3Dgame;<br/><br/>/**<br/> * Created by nikhilmalankar on 05/03/17.<br/> */<br/>import javax.microedition.khronos.egl.EGLConfig;<br/>import javax.microedition.khronos.opengles.GL10;<br/>import android.content.Context;<br/>import android.opengl.GLSurfaceView;<br/>import android.opengl.GLU;<br/><br/>public class MyGLRenderer implements GLSurfaceView.Renderer {<br/>    Context ct;    //Our context variable<br/><br/>    // Constructor of our renderer<br/>    public MyGLRenderer(Context ct) {<br/>        this.ct = ct;<br/>    }<br/><br/>    // Call back when the surface is first created or re-created<br/>    @Override<br/>    public void onSurfaceCreated(GL10 gles, EGLConfig c) {<br/>        gles.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);<br/>        gles.glClearDepthf(1.0f);<br/>        gles.glEnable(GL10.GL_DEPTH_TEST);<br/>        gles.glDepthFunc(GL10.GL_LEQUAL);<br/>        gles.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, <br/>        GL10.GL_NICEST);<br/>        gles.glShadeModel(GL10.GL_SMOOTH);<br/>        gles.glDisable(GL10.GL_DITHER);<br/>    }<br/><br/>    @Override<br/>    public void onSurfaceChanged(GL10 gles, int w, int h) {<br/>        if (h == 0) h = 1;<br/>        float aspect = (float)w / h;<br/><br/>        gles.glViewport(0, 0, w, h);<br/><br/>        gles.glMatrixMode(GL10.GL_PROJECTION);<br/><br/>        gles.glLoadIdentity();<br/>        GLU.gluPerspective(gles, 45, aspect, 0.1f, 100.f);<br/><br/>        gles.glMatrixMode(GL10.GL_MODELVIEW);<br/>        gles.glLoadIdentity();<br/>    }<br/><br/>    @Override<br/>    public void onDrawFrame(GL10 gles) {<br/>        gles.glClear(GL10.GL_COLOR_BUFFER_BIT | <br/>        GL10.GL_DEPTH_BUFFER_BIT);    <br/>        //clear our depth buffer<br/>    }<br/>}
</pre>
<p>Now, we will learn how to define and draw, or in proper terms <em>render</em>, our 3D objects on the screen. First, we will start with a basic triangle shape and then we will draw a pyramid, then we will make both of them rotate on the screen.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Defining shapes</h1>
            

            
                
<p>In order to draw something on the screen, we first need to define its shape and then render it. So we won't define our shape in our render class. We will create a new class in order to define our shape. As discussed, we will first create a basic triangle.</p>
<p>In order to create our triangle, we need to first define its vertices. So, let's create a new class named <kbd>Triangle.java</kbd> and start writing our logic to define the shape of our 3D triangle. Before we start writing our code, let's try to understand what we are actually going to do.</p>
<p>We will take vertices and plot them on our screen. Also, as you saw previously how OpenGL coordinates work, we will plot our vertices in all three directions. For our triangle, we require three points to be plotted. So, we will plot one point on the positive <strong>y-axis</strong> and the other two points on the positive and negative x-axis:</p>
<div><img class="image-border" height="247" src="img/B05066_09_08.jpg" width="246"/></div>
<p>Plotting our triangle</p>
<p>For this purpose, we will take a three-dimensional array of our vertices and define them as a variable in our class:</p>
<pre>
package com.nikmlnkr.my3Dgame;<br/><br/>/**<br/> * Created by nikhilmalankar on 05/03/17.<br/> */<br/>public class Triangle {<br/>    private float[] v = {  // Vertices of our triangle<br/>        0.0f,  1.0f, 0.0f, // 0. top vertices<br/>        -1.0f, -1.0f, 0.0f, // 1. left-bottom vertices<br/>        1.0f, -1.0f, 0.0f  // 2. right-bottom vertices<br/>    };<br/>}
</pre>
<p>That takes care of our vertices, and we have defined its shape, well somewhat, but of course, there's more to it. We also need to define a vertex buffer and transfer this data into it. To do so, we will define our vertex buffer variable as nio's buffer, as they are placed on the native heap and are not garbage collected. We will do the same for our index buffer, which will arrange our triangle in a counter-clockwise (CCW) direction with positive <em>z</em> direction facing toward the screen. So, first we will define our <kbd>vertexBuffer</kbd> and <kbd>indexBuffer</kbd> variables, and then in our default constructor, we will set up our <kbd>vertexBuffer</kbd> and <kbd>indexBuffer</kbd>:</p>
<pre>
    private FloatBuffer vb;<br/>    private ByteBuffer ib<br/><br/>    private byte[] ind = { 0, 1, 2 };<br/><br/>    public Triangle() {<br/>        ByteBuffer vbb = ByteBuffer.allocateDirect(v.length * 4);<br/>        vbb.order(ByteOrder.nativeOrder());<br/>        vb = vbb.asFloatBuffer();<br/>        vb.put(v);<br/>        vb.position(0);<br/><br/>        ib = ByteBuffer.allocateDirect(ind.length);<br/>        ib.put(ind);<br/>        ib.position(0);<br/>    }
</pre>
<p>Alright, now that's taken care of, we also have to actually draw our triangle on screen; for this, we will use our <kbd>draw()</kbd> method. To do so, we will go through the following four simple steps:</p>
<ol>
<li>We enable vertex array client states.</li>
<li>We specify the location of the buffers.</li>
<li>We render our primitive shapes using <kbd>glDrayElements()</kbd> that uses index array to reference the vertex array.</li>
<li>We disable our vertex array client state.</li>
</ol>
<p>Now that we have understood the working of its theory, let's go ahead and do this in practice by writing it out in our code:</p>
<pre>
public void draw(GL10 gles) {<br/>    gles.glEnableClientState(GL10.GL_VERTEX_ARRAY);<br/>    gles.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);<br/><br/>    gles.glDrawElements(GL10.GL_TRIANGLES, ind.length,<br/>    GL10.GL_UNSIGNED_BYTE, ib);<br/>    gles.glDisableClientState(GL10.GL_VERTEX_ARRAY);<br/>}
</pre>
<p>Our shape is defined perfectly, and our entire code block for the <kbd>Triangle.java</kbd> file will look like this:</p>
<pre>
package com.nikmlnkr.my3Dgame;<br/><br/>/**<br/> * Created by nikhilmalankar on 05/03/17.<br/> */<br/><br/>import java.nio.ByteBuffer;<br/>import java.nio.ByteOrder;<br/>import java.nio.FloatBuffer;<br/>import javax.microedition.khronos.opengles.GL10;<br/><br/>public class Triangle {<br/>    private FloatBuffer vb;<br/>    private ByteBuffer ib;<br/><br/>    private float[] v = {  // Vertices of our triangle<br/>        0.0f,  1.0f, 0.0f, // 0. top vertices<br/>        -1.0f, -1.0f, 0.0f, // 1. left-bottom vertices<br/>        1.0f, -1.0f, 0.0f  // 2. right-bottom vertices<br/>    };<br/>    private byte[] indices = { 0, 1, 2 };<br/><br/>    public Triangle() {<br/>        ByteBuffer vbb = ByteBuffer.allocateDirect(v.length * 4);<br/>        vbb.order(ByteOrder.nativeOrder());<br/>        vb = vbb.asFloatBuffer();<br/>        vb.put(v);<br/>        vb.position(0);<br/><br/>        ib = ByteBuffer.allocateDirect(ind.length);<br/>        ib.put(ind);<br/>        ib.position(0);<br/>    }<br/><br/>    public void draw(GL10 gles) {<br/>        gles.glEnableClientState(GL10.GL_VERTEX_ARRAY);<br/>        gles.glVertexPointer(3, GL10.GL_FLOAT, 0, vb);<br/><br/>        gles.glDrawElements(GL10.GL_TRIANGLES, ind.length,<br/>        GL10.GL_UNSIGNED_BYTE, ib);<br/>        gles.glDisableClientState(GL10.GL_VERTEX_ARRAY);<br/>    }<br/>}
</pre>
<p>However, if you deploy this to your device, you won't be able to see your triangle on the screen. This is because we still haven't rendered it on our screen yet. Remember how we discussed rendering all our objects using the help of the <kbd>MyGLRenderer</kbd> file? We haven't told that file to use our triangle to be rendered, but that's it for this chapter. We will cover the rendering of our object in the next chapter.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>In this chapter, we learned about how to transition from a 2D to a 3D game along with concepts of OpenGL. We also learned how to create our main activity along with our own renderer. After this, we learned how to define a basic shape.</p>
<p>To summarize, we covered the following topics in this chapter. We got introduced to OpenGL ES and took a look at the coordinates system in the same. We learned how to create a blank scene and the process of rendering. We then created our basic renderer and defined our triangle shape.</p>
<p>In our next chapter, we will learn how to render our defined shape on the screen and rotate it. We will also learn how to create a 3D pyramid in the next chapter, and by the end of the next chapter, you will complete this book and  also have a foundation for creating a 2D and 3D game.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>