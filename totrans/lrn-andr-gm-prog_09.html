<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Converting Your Game from 2D to 3D</h1>
            </header>

            <article>
                
<p>Now, be aware that making a 3D game from scratch in Android Studio is a Herculean task. It isn't absolutely essential to make a game from scratch in 3D because there are plenty of tools and game engines available on the market, which eliminate the requirement of having to work on creating everything from scratch. However, an understanding of how the nuts and bolts operate behind the scenes will definitely help you in the long run.</p>
<p>We will learn the basics of some advanced concepts in this chapter, and by the end of this chapter, you will have an understanding of how to create a basic 3D object in Android Studio. For the purpose of this chapter, we will create a new Android Studio project since we will not continue in our previous game project folder. However, before we get started, let's take a look at the concepts that we will be learning in brief. We will learn the following concepts in this chapter:</p>
<ul>
<li>Introduction to OpenGL ES</li>
<li>Learning about the 3D coordinate system using OpenGL ES</li>
<li>Creating a scene using OpenGL ES
<ul>
<li>Project folder</li>
<li>Render class and main activity</li>
<li>Defining shapes</li>
</ul>
</li>
</ul>
<p>To create our 3D graphics, we will use OpenGL ES for rendering our graphics. Let's understand what OpenGL ES is.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction to OpenGL ES</h1>
            </header>

            <article>
                
<p>High-performance 2D and 3D graphics are supported on Android with the OpenGL library. We have the OpenGL ES API, which is used for this. This API specifies the interface for 3D graphics processing hardware. OpenGL is a huge library and from that, a part of it is OpenGL ES which is specifically created for embedded devices.</p>
<p>The various versions of the OpenGL ES API supported on Android are as follows:</p>
<ul>
<li>1.0 and 1.1: Supported by Android 1.0 and higher</li>
<li>2.0: Supported by Android 2.2 (API level 8) and higher</li>
<li>3.0: Supported by Android 4.3 (API level 18) and higher</li>
<li>3.1: Supported by Android 5.0 (API level 21) and higher</li>
</ul>
<p>You can read more general information about this on the official website for Android here at <a href="https://developer.android.com/guide/topics/graphics/opengl.html">https://developer.android.com/guide/topics/graphics/opengl.html</a>.</p>
<p>Using OpenGL ES, you can create 3D graphics on Android. Since we will be creating 3D objects, we will need to understand the coordinate system. Let's take a quick look at the 3D coordinates system that we will use for our examples.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Learning about the 3D coordinate system</h1>
            </header>

            <article>
                
<p>While making our 2D game, we were only dealing with <em>x</em> and <em>y</em> axis values. However, when you are making a 3D game, you have to deal with three axis values: <em>x</em>, <em>y</em>, and <em>z</em>. We're pretty much clear how our <em>x</em> and <em>y</em> axis values work by now. In a similar way, our <em>z</em> axis is projected on the front and back of our mobile device. The following image will explain the three axes in our 3D coordinate system better:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="156" src="assets/B05066_09_01.png" width="277"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The positive x, y, and z axis on phone</div>
<p>The axes you see in the preceding image are positive directions. If you take their opposite sides, you will get negative values. The origin point starts from (0,0,0), and your values can be float values that will denote your object's location in 3D space.</p>
<p>Here's a classic problem that you might encounter while dealing with OpenGL in terms of device screen sizes. The grid in OpenGL assumes a screen, which is square and has a uniform coordinate system. However, if your screen size varies, then a non-square screen is considered as if it is a perfectly square screen. In order to understand this, take a look at the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="217" src="assets/B05066_09_02.jpg" width="546"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Understanding the default OpenGL coordinate system</div>
<p>As you can see in the preceding figure, we have two different screens, one is square shaped and the other is a rectangle. Now, what happens here is that even though your screen is a rectangle, it is considered a square and because of that, your graphics get stretched. To tackle this issue, you need to apply OpenGL projection modes and camera views to transform the coordinates in order to get a proper proportion on any display.</p>
<p>To do so, we create a projection matrix and a camera view matrix, and then apply that to our OpenGL rendering pipeline. The projection matrix helps us to process the coordinates by recalculating the matrix of our graphics so that they are mapped correctly onto our device screens. The camera view matrix helps create a transformation that renders the object from a specific eye position.</p>
<p>You can read up more about OpenGL ES over at <a href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a>.</p>
<p>Now that we have learned about these basic concepts, we can get started with creating our 3D game scene using OpenGL ES in Android; let's begin!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a 3D scene with OpenGL ES</h1>
            </header>

            <article>
                
<p>Just as we did in our 2D game example, most of our draw mechanism is going to remain the same. You will see that there are many similarities between both procedures. We will be working on a new project folder for this example, so let's go ahead and create a new project as we did in <a href="1942c8c2-08a2-4c18-8740-8b7e9103bc6e.xhtml" target="_blank">Chapter 8</a>, <em>Adding Explosion and Creating a UI</em>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating our project folder</h1>
            </header>

            <article>
                
<p>We will follow the steps we did in <a href="9563ed54-bb46-4d59-9225-ed418d3e0b29.xhtml" target="_blank">Chapter 2</a>, <em>Getting Familiar with Android Studio</em>. First, we will create a new project from our top menu.</p>
<p>To create a new project, perform the following steps:</p>
<ol>
<li>Go to <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">New Project...</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="394" src="assets/B05066_09_03.png" width="360"/></div>
<ol start="2">
<li>Fill in your <span class="packt_screen">Application name</span>, <span class="packt_screen">Company domain</span>, and <span class="packt_screen">Package name</span> details; then click on <span class="packt_screen">Next</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="408" src="assets/B05066_09_04.png" width="698"/></div>
<ol start="3">
<li>Select your target devices and click on <span class="packt_screen">Next</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="405" src="assets/B05066_09_05.png" width="703"/></div>
<ol start="4">
<li>Select <span class="packt_screen">Empty Activity</span> and click on <span class="packt_screen">Next</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="399" src="assets/B05066_09_06.png" width="686"/></div>
<ol start="5">
<li>Fill in your <span class="packt_screen">Activity Name</span>, <span class="packt_screen">Layout Name</span>, and click on <span class="packt_screen">Finish</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="408" src="assets/B05066_09_07.png" width="708"/></div>
<p class="CDPAlignLeft CDPAlign">Okay then, we are now set with our new project folder. Also, we will use the landscape mode orientation for this project, so we will define it in our <kbd>AndroidManifest.xml</kbd> file. Open up your manifest file from the <kbd>app/manifests/AndroidManifest.xml</kbd> file and make the following change that is marked in bold:</p>
<pre>
<span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span>&lt;<span>manifest </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>package=</span><span>"com.nikmlnkr.my3Dgame"</span>&gt;<br/><br/>    &lt;<span>application<br/></span><span>        </span><span>android</span><span>:allowBackup=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:icon=</span><span>"@mipmap/ic_launcher"<br/></span><span>        </span><span>android</span><span>:label=</span><span>"@string/app_name"<br/></span><span>        </span><span>android</span><span>:roundIcon=</span><span>"@mipmap/ic_launcher_round"<br/></span><span>        </span><span>android</span><span>:supportsRtl=</span><span>"true"<br/></span><span>        </span><span>android</span><span>:theme=</span><span>"@style/AppTheme"</span>&gt;<br/><strong>&lt;activity android:name=".MainActivity" <br/>        android:screenOrientation="landscape"&gt;</strong><br/>            &lt;<span>intent-filter</span>&gt;<br/>                &lt;<span>action </span><span>android</span><span>:name=</span><span>"android.intent.action.MAIN" </span>/&gt;<br/><br/>                &lt;<span>category </span><span>android</span><span>:name=</span><span>"android.intent.category.LAUNCHER" </span>/&gt;<br/>            &lt;/<span>intent-filter</span>&gt;<br/>        &lt;/<span>activity</span>&gt;<br/>    &lt;/<span>application</span>&gt;<br/><br/>&lt;/<span>manifest</span>&gt;
</pre>
<p>Let's now define our main activity and create a render class for our 3D game view.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a render class and defining a main activity</h1>
            </header>

            <article>
                
<p>In order to see anything on the screen, we have to render it on screen. Therefore, we need to create a render class that will handle the rendering part of our functioning. Rendering is the process of generating an image from a 2D or 3D model by means of computer programs. We will name our render class as <kbd>MyGLRenderer</kbd>, but before we do that, let's define our main activity. So, open up your <kbd>MainActivity.java</kbd> file, and we will create three default methods there. Remove everything you see on screen, except for the first line that's your package name. We will have three methods:</p>
<ul>
<li><kbd>onCreate()</kbd>: This initializes our main activity</li>
<li><kbd>onPause()</kbd>: This handles the app if it goes into background</li>
<li><kbd>onResume()</kbd>: After the user resumes back to the app, this method is called</li>
</ul>
<p>Also, we are dealing with OpenGL graphics here, and for that reason, we will need a <kbd>GLSurfaceView</kbd>, just as we worked in our 2D game wherein we had a surface view for our game.</p>
<p>So, let's create them in our <kbd>MainActivity.java</kbd> file, as follows:</p>
<pre>
<span>package </span>com.nikmlnkr.my3Dgame;<br/><br/><span>import </span>android.app.Activity;<br/><span>import </span>android.opengl.GLSurfaceView;<br/><span>import </span>android.os.Bundle;<br/><br/><span>public class </span>MainActivity <span>extends </span>Activity {<br/><span><br/>    private </span>GLSurfaceView <span>gv</span>;<span><br/><br/>    //Our onCreate method<br/></span><span>    @Override<br/></span><span>    protected void </span>onCreate(Bundle savedInstanceState) {<br/><span>        super</span>.onCreate(savedInstanceState);<br/><span>        gv </span>= <span>new </span>GLSurfaceView(<span>this</span>);<br/><span>        gv</span>.setRenderer(<span>new </span>MyGLRenderer(<span>this</span>));<br/><span>        this</span>.setContentView(<span>gv</span>);<br/>    }<br/><br/>    //Resume method<br/>    @Override<br/>    protected void onResume() {<br/>        super.onResume();<br/>        gv.onResume();<br/>    }<br/><br/>    //Pause method<br/><span>    @Override<br/></span><span>    protected void </span>onPause() {<br/><span>    super</span>.onPause();<br/><span>        gv</span>.onPause();<br/>    }<br/>}
</pre>
<p>Okay, that seems sorted, but now we are getting an error on our <kbd>MyGLRenderer</kbd> line. That's because we still haven't made our renderer class yet. Let's make our renderer class now. Create a new Java class file named <kbd>MyGLRenderer.java</kbd>, and let's get started with writing our renderer class.</p>
<div class="packt_infobox">The <kbd>Renderer</kbd> class is where you will do most of your object displaying part.</div>
<p>The interface <kbd>GLSurfaceView.Renderer</kbd> is responsible for making OpenGL render a frame, hence we will need to implement it as an interface in our code; so we will start with our very first line, which will do the same. We will extend our class to the <kbd>GLSurfaceView.Renderer</kbd> interface and write a default constructor, as follows:</p>
<pre>
<span>public class </span>MyGLRenderer <span>implements </span>GLSurfaceView.Renderer {<br/>    Context <span>ct</span>;    //Context variable<span><br/></span><span><br/>    //Constructor of our renderer class<br/></span><span>    public </span>MyGLRenderer(Context ct) {<br/><span>        this</span>.<span>ct </span>= ct;<br/>    }<br/>}
</pre>
<p>Now, inside this class, as we had in our 2D sprite example game, we will need three methods to draw on the screen; they are <kbd>onSurfaceCreated()</kbd>, <kbd>onSurfaceChanged()</kbd>, and <kbd>onDraw()</kbd>. However, in OpenGL, the <kbd>onDraw()</kbd> method is actually <kbd>onDrawFrame()</kbd>, so let's define those three methods one by one.</p>
<p>First, we will start with our <kbd>onSurfaceChanged()</kbd> method. In this method, we will create our surface. This method is for the initialization of our scene. Here, we will create a simple black screen drawn on the screen. In order to set our color, we will use RGBA values. For a black color, we will need (0,0,0,1) RGBA values. We will also add in some more initialization factors here:</p>
<pre>
<span>    @Override<br/>    public void </span>onSurfaceCreated(GL10 gles, EGLConfig c) {<br/>        gles.glClearColor(<span>0.0f</span>, <span>0.0f</span>, <span>0.0f</span>, <span>1.0f</span>); <br/>        //Clear color and set to black<span><br/></span><span>    <br/></span>        gles.glClearDepthf(<span>1.0f</span>); <br/>        //Clear depth<span><br/></span><span>    <br/></span>        gles.glEnable(GL10.<span>GL_DEPTH_TEST</span>);<br/>        //Enable depth test<span><br/></span><span>    <br/></span>        gles.glDepthFunc(GL10.<span>GL_LEQUAL</span>); <br/>        //Set depth function<br/><br/>        gles.glHint(GL10.<span>GL_PERSPECTIVE_CORRECTION_HINT</span>, <br/>        GL10.<span>GL_NICEST</span>);<br/>        //set gl to nicest<br/><br/>        gles.glShadeModel(GL10.<span>GL_SMOOTH</span>); <br/>        //set shade model to smooth<span><br/></span><span>    <br/></span>        gles.glDisable(GL10.<span>GL_DITHER</span>); <br/>        //disable dither<br/>    }
</pre>
<p>These parameters are basically required to set various aspects in an OpenGL ES environment. You can read up more about these specific methods and more through <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/">https://www.khronos.org/registry/OpenGL-Refpages/es3.0/</a>.</p>
<p>This method gets called after the <kbd>onSurfaceCreated()</kbd> method and also every time our screen resolution changes. Basically, this method is responsible for creating the display matrix that we saw earlier in the chapter, which in turn creates a uniform shape on any screen:</p>
<pre>
<span>    @Override<br/></span><span>    public void </span>onSurfaceChanged(GL10 gles, <span>int </span>w, <span>int </span>h) {<br/><span>        if </span>(h == <span>0</span>) h = <span>1</span>;<br/><span>        float </span>aspect = (<span>float</span>)w / h;<br/><br/>        gles.glViewport(<span>0</span>, <span>0</span>, w, h); <br/>        //dynamically set the width and height of our viewport as per screen <br/>        resolution<br/><br/>        gles.glMatrixMode(GL10.<span>GL_PROJECTION</span>); <br/>        //set our matrix mode projection<span><br/></span><span>    <br/></span>        gles.glLoadIdentity();<br/>        GLU.<span>gluPerspective</span>(gles, <span>45</span>, aspect, <span>0.1f</span>, <span>100.f</span>);<br/><br/>        gles.glMatrixMode(GL10.<span>GL_MODELVIEW</span>); <br/>        //set our camera view matrix mode<br/><br/>        gles.glLoadIdentity();<br/>    }
</pre>
<p>Finally, we have our <kbd>onDrawFrame()</kbd> function, which is used to draw the current frame. After every frame, we need to clear the previous screen drawn, and for that reason, we call <kbd>glClear()</kbd> in this before we render any code further. Right now, we will just write our clear code and when we will draw our object shapes in this function after our clear code:</p>
<pre>
<span>    @Override<br/></span><span>    public void </span>onDrawFrame(GL10 gles) {<br/>        gles.glClear(GL10.<span>GL_COLOR_BUFFER_BIT </span>| <br/>        GL10.<span>GL_DEPTH_BUFFER_BIT</span>);    <br/>        //clear depth buffer<br/>    }
</pre>
<p>Finally, this is how your entire code will look like for your <kbd>Renderer</kbd> class:</p>
<pre>
<span>package </span>com.nikmlnkr.my3Dgame;<br/><br/><span>/**<br/></span><span> * Created by nikhilmalankar on 05/03/17.<br/></span><span> */<br/></span><span>import </span>javax.microedition.khronos.egl.EGLConfig;<br/><span>import </span>javax.microedition.khronos.opengles.GL10;<br/><span>import </span>android.content.Context;<br/><span>import </span>android.opengl.GLSurfaceView;<br/><span>import </span>android.opengl.GLU;<br/><span><br/></span><span>public class </span>MyGLRenderer <span>implements </span>GLSurfaceView.Renderer {<br/>    Context <span>ct</span>;    //Our context variable<span><br/></span><span><br/>    // Constructor of our renderer<br/></span><span>    public </span>MyGLRenderer(Context ct) {<br/><span>        this</span>.<span>ct </span>= ct;<br/>    }<br/><span><br/>    // Call back when the surface is first created or re-created<br/></span><span>    @Override<br/></span><span>    public void </span>onSurfaceCreated(GL10 gles, EGLConfig c) {<br/>        gles.glClearColor(<span>0.0f</span>, <span>0.0f</span>, <span>0.0f</span>, <span>1.0f</span>);<br/>        gles.glClearDepthf(<span>1.0f</span>);<br/>        gles.glEnable(GL10.<span>GL_DEPTH_TEST</span>);<br/>        gles.glDepthFunc(GL10.<span>GL_LEQUAL</span>);<br/>        gles.glHint(GL10.<span>GL_PERSPECTIVE_CORRECTION_HINT</span>, <br/>        GL10.<span>GL_NICEST</span>);<br/>        gles.glShadeModel(GL10.<span>GL_SMOOTH</span>);<br/>        gles.glDisable(GL10.<span>GL_DITHER</span>);<br/>    }<br/><span><br/>    @Override<br/></span><span>    public void </span>onSurfaceChanged(GL10 gles, <span>int </span>w, <span>int </span>h) {<br/><span>        if </span>(h == <span>0</span>) h = <span>1</span>;<br/><span>        float </span>aspect = (<span>float</span>)w / h;<br/><br/>        gles.glViewport(<span>0</span>, <span>0</span>, w, h);<br/><br/>        gles.glMatrixMode(GL10.<span>GL_PROJECTION</span>);<br/><br/>        gles.glLoadIdentity();<br/>        GLU.<span>gluPerspective</span>(gles, <span>45</span>, aspect, <span>0.1f</span>, <span>100.f</span>);<br/><br/>        gles.glMatrixMode(GL10.<span>GL_MODELVIEW</span>);<br/>        gles.glLoadIdentity();<br/>    }<br/><span><br/>    @Override<br/></span><span>    public void </span>onDrawFrame(GL10 gles) {<br/>        gles.glClear(GL10.<span>GL_COLOR_BUFFER_BIT </span>| <br/>        GL10.<span>GL_DEPTH_BUFFER_BIT</span>);    <br/>        //clear our depth buffer<br/>    }<br/>}
</pre>
<p>Now, we will learn how to define and draw, or in proper terms <em>render</em>, our 3D objects on the screen. First, we will start with a basic triangle shape and then we will draw a pyramid, then we will make both of them rotate on the screen.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Defining shapes</h1>
            </header>

            <article>
                
<p>In order to draw something on the screen, we first need to define its shape and then render it. So we won't define our shape in our render class. We will create a new class in order to define our shape. As discussed, we will first create a basic triangle.</p>
<p>In order to create our triangle, we need to first define its vertices. So, let's create a new class named <kbd>Triangle.java</kbd> and start writing our logic to define the shape of our 3D triangle. Before we start writing our code, let's try to understand what we are actually going to do.</p>
<p>We will take vertices and plot them on our screen. Also, as you saw previously how OpenGL coordinates work, we will plot our vertices in all three directions. For our triangle, we require three points to be plotted. So, we will plot one point on the positive <strong>y-axis</strong> and the other two points on the positive and negative x-axis:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="247" src="assets/B05066_09_08.jpg" width="246"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Plotting our triangle</div>
<p>For this purpose, we will take a three-dimensional array of our vertices and define them as a variable in our class:</p>
<pre>
<span>package </span>com.nikmlnkr.my3Dgame;<br/><br/><span>/**<br/></span><span> * Created by nikhilmalankar on 05/03/17.<br/></span><span> */</span><span><br/></span><span>public class </span>Triangle {<br/><span>    private float</span>[] <span>v </span>= {  <span>// Vertices of our triangle<br/></span><span>        0.0f</span>,  <span>1.0f</span>, <span>0.0f</span>, <span>// 0. top vertices<br/></span>        -<span>1.0f</span>, -<span>1.0f</span>, <span>0.0f</span>, <span>// 1. left-bottom vertices<br/></span><span>        1.0f</span>, -<span>1.0f</span>, <span>0.0f  </span><span>// 2. right-bottom vertices<br/></span>    };<br/>}
</pre>
<p>That takes care of our vertices, and we have defined its shape, well somewhat, but of course, there's more to it. We also need to define a vertex buffer and transfer this data into it. To do so, we will define our vertex buffer variable as nio's buffer, as they are placed on the native heap and are not garbage collected. We will do the same for our index buffer, which will arrange our triangle in a counter-clockwise (CCW) direction with positive <em>z</em> direction facing toward the screen. So, first we will define our <kbd>vertexBuffer</kbd> and <kbd>indexBuffer</kbd> variables, and then in our default constructor, we will set up our <kbd>vertexBuffer</kbd> and <kbd>indexBuffer</kbd>:</p>
<pre>
<span>    private </span>FloatBuffer <span>vb</span>;<br/><span>    private </span>ByteBuffer <span>ib</span><span><br/></span><span><br/>    private byte</span>[] <span>ind </span>= { <span>0</span>, <span>1</span>, <span>2 </span>};<span><br/></span><span><br/>    public </span>Triangle() {<br/>        ByteBuffer vbb = ByteBuffer.<span>allocateDirect</span>(<span>v</span>.<span>length </span>* <span>4</span>);<br/>        vbb.order(ByteOrder.<span>nativeOrder</span>());<br/><span>        vb </span>= vbb.asFloatBuffer();<br/><span>        vb</span>.put(<span>v</span>);<br/><span>        vb</span>.position(<span>0</span>);<span><br/></span><span><br/>        ib </span>= ByteBuffer.<span>allocateDirect</span>(<span>ind</span>.<span>length</span>);<br/><span>        ib</span>.put(<span>ind</span>);<br/><span>        ib</span>.position(<span>0</span>);<br/>    }
</pre>
<p>Alright, now that's taken care of, we also have to actually draw our triangle on screen; for this, we will use our <kbd>draw()</kbd> method. To do so, we will go through the following four simple steps:</p>
<ol>
<li>We enable vertex array client states.</li>
<li>We specify the location of the buffers.</li>
<li>We render our primitive shapes using <kbd>glDrayElements()</kbd> that uses index array to reference the vertex array.</li>
<li>We disable our vertex array client state.</li>
</ol>
<p>Now that we have understood the working of its theory, let's go ahead and do this in practice by writing it out in our code:</p>
<pre>
<span>public void </span>draw(GL10 gles) {<br/>    gles.glEnableClientState(GL10.<span>GL_VERTEX_ARRAY</span>);<br/>    gles.glVertexPointer(<span>3</span>, GL10.<span>GL_FLOAT</span>, <span>0</span>, <span>vb</span>);<br/><br/>    gles.glDrawElements(GL10.<span>GL_TRIANGLES</span>, <span>ind</span>.<span>length</span>,<br/>    GL10.<span>GL_UNSIGNED_BYTE</span>, <span>ib</span>);<br/>    gles.glDisableClientState(GL10.<span>GL_VERTEX_ARRAY</span>);<br/>}
</pre>
<p>Our shape is defined perfectly, and our entire code block for the <kbd>Triangle.java</kbd> file will look like this:</p>
<pre>
<span>package </span>com.nikmlnkr.my3Dgame;<br/><br/><span>/**<br/></span><span> * Created by nikhilmalankar on 05/03/17.<br/></span><span> */<br/></span><span><br/></span><span>import </span>java.nio.ByteBuffer;<br/><span>import </span>java.nio.ByteOrder;<br/><span>import </span>java.nio.FloatBuffer;<br/><span>import </span>javax.microedition.khronos.opengles.GL10;<br/><span><br/></span><span>public class </span>Triangle {<br/><span>    private </span>FloatBuffer <span>vb</span>;<br/><span>    private </span>ByteBuffer <span>ib</span>;<span><br/></span><span><br/>    private float</span>[] <span>v </span>= {  <span>// Vertices of our triangle<br/></span><span>        0.0f</span>,  <span>1.0f</span>, <span>0.0f</span>, <span>// 0. top vertices<br/></span>        -<span>1.0f</span>, -<span>1.0f</span>, <span>0.0f</span>, <span>// 1. left-bottom vertices<br/></span><span>        1.0f</span>, -<span>1.0f</span>, <span>0.0f  </span><span>// 2. right-bottom vertices<br/></span>    };<br/><span>    private byte</span>[] <span>indices </span>= { <span>0</span>, <span>1</span>, <span>2 </span>};<span><br/></span><span><br/>    public </span>Triangle() {<br/>        ByteBuffer vbb = ByteBuffer.<span>allocateDirect</span>(<span>v</span>.<span>length </span>* <span>4</span>);<br/>        vbb.order(ByteOrder.<span>nativeOrder</span>());<br/><span>        vb </span>= vbb.asFloatBuffer();<br/><span>        vb</span>.put(<span>v</span>);<br/><span>        vb</span>.position(<span>0</span>);<span><br/></span><span><br/>        ib </span>= ByteBuffer.<span>allocateDirect</span>(<span>ind</span>.<span>length</span>);<br/><span>        ib</span>.put(<span>ind</span>);<br/><span>        ib</span>.position(<span>0</span>);<br/>    }<br/><span><br/>    public void </span>draw(GL10 gles) {<br/>        gles.glEnableClientState(GL10.<span>GL_VERTEX_ARRAY</span>);<br/>        gles.glVertexPointer(<span>3</span>, GL10.<span>GL_FLOAT</span>, <span>0</span>, <span>vb</span>);<br/><br/>        gles.glDrawElements(GL10.<span>GL_TRIANGLES</span>, <span>ind</span>.<span>length</span>,<br/>        GL10.<span>GL_UNSIGNED_BYTE</span>, <span>ib</span>);<br/>        gles.glDisableClientState(GL10.<span>GL_VERTEX_ARRAY</span>);<br/>    }<br/>}
</pre>
<p>However, if you deploy this to your device, you won't be able to see your triangle on the screen. This is because we still haven't rendered it on our screen yet. Remember how we discussed rendering all our objects using the help of the <kbd>MyGLRenderer</kbd> file? We haven't told that file to use our triangle to be rendered, but that's it for this chapter. We will cover the rendering of our object in the next chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we learned about how to transition from a 2D to a 3D game along with concepts of OpenGL. We also learned how to create our main activity along with our own renderer. After this, we learned how to define a basic shape.</p>
<p>To summarize, we covered the following topics in this chapter. We got introduced to OpenGL ES and took a look at the coordinates system in the same. We learned how to create a blank scene and the process of rendering. We then created our basic renderer and defined our triangle shape.</p>
<p>In our next chapter, we will learn how to render our defined shape on the screen and rotate it. We will also learn how to create a 3D pyramid in the next chapter, and by the end of the next chapter, you will complete this book and  also have a foundation for creating a 2D and 3D game.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>