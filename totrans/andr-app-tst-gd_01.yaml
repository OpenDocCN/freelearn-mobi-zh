- en: Chapter 1. Getting Started with Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the different types of testing and their applicability
    to software development projects in general and to **Android** in particular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will avoid introductions to Android and the **Open Handset Alliance** ([http://www.openhandsetalliance.com](http://www.openhandsetalliance.com))
    as they are covered in many books already and I am inclined to believe that if
    you are reading a book covering this more advanced topic you will have started
    with Android development before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: However, we will be reviewing the main concepts behind testing and the techniques,
    frameworks, and tools available to deploy your testing strategy on Android.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Brief history
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, when Android was introduced by the end of 2007, there was very little
    support for testing on the platform, and for some of us very accustomed to using
    testing as a component intimately coupled with the development process, it was
    time to start developing some frameworks and tools to permit this approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: By that time Android had some rudimentary support for unit testing using JUnit
    ([http://www.JUnit.org](http://www.JUnit.org)), but it was not fully supported
    and even less documented.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In the process of writing my own library and tools, I discovered Phil Smith's
    **Positron** (originally at [http://code.google.com/p/android-positron](http://code.google.com/p/android-positron)
    and now renamed and moved to [http://code.google.com/p/autoandroid)](http://code.google.com/p/autoandroid)),
    an Open Source library and a very suitable alternative to support testing on Android,
    so I decided to extend his excellent work and bring some new and missing pieces
    to the table.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Some aspects of test automation were not included and I started a complementary
    project to fill that gap, it was consequently named **Electron**. And although
    positron is the anti-particle of the electron, and they annihilate if they collide,
    take for granted that that was not the idea, but more the conservation of energy
    and the generation of some visible light and waves.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Later on, Electron entered the first **Android Development Challenge** (**ADC1**)
    in early 2008 and though it obtained a rather good score in some categories, frameworks
    had no place in that competition. Should you be interested in the origin of testing
    on Android, please find some articles and videos that were published in my personal
    blog ([http://dtmilano.blogspot.com/search/label/electron](http://dtmilano.blogspot.com/search/label/electron)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: By that time Unit Tests could be run on Eclipse. However, testing was not done
    on the real target but on a JVM on the local development computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Google also provided application instrumentation code through the `Instrumentation`
    class. When running an application with instrumentation turned on, this class
    is instantiated for you before any of the application code, allowing you to monitor
    all of the interaction the system has with the application. An Instrumentation
    implementation is described to the system through an `AndroidManifest.xml` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: During those early stages in the Android development evolution, I started writing
    some articles in my blog filling the gaps on testing. This book is the evolution
    and completion of that work in an orderly and understandable manner to paradoxically
    let you be bitten by the Android testing bug.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Software bugs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't matter how hard you try and how much time you invest in design and
    even how careful you are when programming, mistakes are inevitable and bugs will
    appear.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Bugs and software development are intimately related. However, the term **bugs**
    to describe flaws, mistakes, or errors has been used in hardware engineering many
    decades before even computers were invented. Notwithstanding the story about the
    term ''bug'' coined by Mark II operators at Harvard University, Thomas Edison
    wrote this in 1878 in a letter to Puskás Tivadar showing the early adoption of
    the term:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '"It has been just so in all of my inventions. The first step is an intuition,
    and comes with a burst, then difficulties arise—this thing gives out and [it is]
    then that ''Bugs''—as such little faults and difficulties are called—show themselves
    and months of intense watching, study and labor are requisite before commercial
    success or failure is certainly reached."'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How bugs severely affect your projects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bugs affect many aspects of your software development project and it is clearly
    understood that the sooner in the process you find and *squash* them, the better.
    It doesn't matter if you are developing a simple application to publish on the
    Android Market, re-branding the Android experience for an operator, or creating
    a customized version of Android for a device manufacturer, bugs will delay your
    shipment and will cost you money.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: From all of the software development methodologies and techniques, **Test Driven
    Development**, an agile component of the software development process, is likely
    the one that forces you to face your bugs earlier in the development process and
    thus it is also likely that you will solve more problems up front.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the increase in productivity can be clearly appreciated in a project
    where a software development team uses this technique versus one that is, in the
    best of cases, writing tests at the end of the development cycle. If you have
    been involved in software development for the mobile industry, you will have reasons
    to believe that with all the rush this stage never occurs. It's funny because,
    usually, this rush is to solve problems that could have been avoided.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In a study conducted by the **National Institute of Standards and Technology**
    (**USA**) in 2002, it was reported that software bugs cost the economy $59.5 billion
    annually. More than a third of this cost could be avoided if better software testing
    was performed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: But please, don't misunderstand this message. There are no *silver bullets*
    in software development and what will lead you to an increase in productivity
    and manageability of your project is discipline in applying these methodologies
    and techniques to stay in control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Why, what, how, and when to test
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should understand that early bug detection saves a huge amount of project
    resources and reduces software maintenance costs. This is the best known reason
    to write software tests for your development project. Increased productivity will
    soon be evident.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, writing the tests will give you a deeper understanding of the
    requirements and the problem to be solved. You will not be able to write tests
    for a piece of software you don't understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason behind the approach of writing tests to clearly understand
    legacy or third party code and having the ability to confidently change or update
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The more the code covered by your tests, the higher would be your expectations
    of discovering the hidden bugs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If during this coverage analysis you find that some areas of your code are not
    exercised, additional tests should be added to cover this code as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: This technique requires a special instrumented Android build to collect probe
    data and must be disabled for any release code because the impact on performance
    could severely affect application behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill this gap, enter EMMA ([http://emma.sourceforge.net/](http://emma.sourceforge.net/)),
    an open-source toolkit for measuring and reporting Java code coverage, that can
    offline instrument classes for coverage. It supports various coverage types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: method
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: line
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: basic block
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage reports can also be obtained in different output formats. EMMA is supported
    to some degree by the Android framework and it is possible to build an EMMA instrumented
    version of Android.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We will be analyzing the use of EMMA on Android to guide us to full test coverage
    of our code in [Chapter 10](ch10.html "Chapter 10. Alternative Testing Tactics"),
    *Alternative Testing Tactics.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows how an EMMA code coverage report is displayed in the Eclipse
    editor, showing green lines where the code has been tested, provided the corresponding
    plugin is installed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Why, what, how, and when to test](img/3500_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, the plugin doesn't support Android tests yet, so right now you
    can only use it for your JUnit tests. An Android coverage analysis report is only
    available through HTML.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tests should be automated, and you should run some or all of them every time
    you introduce a change or addition to your code, in order to ensure that all the
    previous conditions are still met and that the new code still satisfies the tests
    as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the introduction of **Continuous Integration**, which will
    be discussed in detail in [Chapter 8](ch08.html "Chapter 8. Continuous Integration"),
    *Continuous Integration*. This relies on the automation of tests and building
    processes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use automated testing, it is practically impossible to adopt Continuous
    Integration as part of the development process and it is very difficult to ensure
    that changes do not break existing code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strictly speaking you should test every statement in your code but this also
    depends on different criteria and can be reduced to test the path of execution
    or just some methods. Usually there is no need to test something that can't be
    broken, for example it usually makes no sense to test getters and setters as you
    probably won't be testing the Java compiler on your own code and the compiler
    would have already performed its own tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the functional areas you should test, there are some specific
    areas of Android applications that you should consider. We will be looking at
    these in the following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Activity lifecycle events
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should test that your activities handle lifecycle events correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If your activity should save its state during `onPause()` or `onDestroy()` events
    and later restore it in `onCreate(Bundle savedInstanceState)`, you should be able
    to reproduce and test these conditions and verify that the state was correctly
    saved and restored.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Configuration-changed events should also be tested as some of these events cause
    the current Activity to be recreated, and you should test for correct handling
    of the event and that the newly created Activity preserves the previous state.
    Configuration changes are triggered even by rotation events, so you should test
    your application's ability to handle these situations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Database and filesystem operations
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Database and filesystem operations should be tested to ensure that they are
    handled correctly. These operations should be tested in isolation at the lower
    system level, at a higher level through `ContentProviders`, and from the application
    itself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: To test these components in isolation, Android provides some mock objects in
    the `android.test.mock` package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Physical characteristics of the device
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well before delivering your application you should be sure that all of the different
    devices it can be run on are supported or at the least you should detect the situation
    and take appropriate measures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Among other characteristics of the devices, you may find that you should test:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Network capabilities
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen densities
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen resolutions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen sizes
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of sensors
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard and other input devices
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPS
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External storage
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this respect Android Virtual Devices play an important role because it is
    practically impossible to have access to all possible devices with all of the
    possible combinations of features but you can configure AVD for almost every situation.
    However, as was mentioned before, save your final testing for actual devices where
    real users will run the application to understand its behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing can be implemented at any time in the development process, depending
    on the method employed. However, we will be promoting testing at an early stage
    of the development effort, even before the full set of requirements have been
    defined and the coding process has been started.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of test available depending on the object being tested.
    Regardless of its type, a test should verify a condition and return the result
    of this evaluation as a single Boolean value indicating success or failure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are software tests written by programmers for programmers in a programming
    language and they should isolate the component under test and be able to test
    it in a repeatable way. That's why unit tests and mock objects are usually placed
    together. You use mock objects to isolate the unit from its dependencies, to monitor
    interactions, and also to be able to repeat the test any number of times. For
    example, if your test deletes some data from a database you probably don't want
    the data to be actually deleted and not found the next time the test is run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: JUnit is the de-facto standard for unit tests on Android. It's a simple open
    source framework for automating unit testing, originally written by Erich Gamma
    and Kent Beck.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Android (up to Android 2.3 Gingerbread) uses JUnit 3\. This version doesn't
    use annotations and uses introspection to detect the tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical JUnit test would look something like this (the actual tests are highlighted):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain in detail the components that build up our test
    case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The test fixture
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A test fixture is the well known state defined as a baseline to run the tests
    and is shared by all the test cases, and thus plays a fundamental role in the
    design of the tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Generally it is implemented as a set of member variables and, following Android
    conventions, they will have names starting with `m`, for example `mActivity`.
    However, it can also contain external data, as specific entries in a database
    or files present in the filesystem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The setUp() method
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is called to initialize the fixture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Overriding it you have the opportunity to create objects and initialize fields
    that will be used by tests. It's worth noting that this setup occurs *before*
    every test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The tearDown() method
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is called to finalize the fixture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Overriding it you can release resources used by the initialization or tests.
    Again, this method is invoked *after* every test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can release a database or a network connection here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: JUnit is designed in such a way that the entire tree of test instances is built
    in one pass, and then the tests are executed in a second pass. Therefore, the
    test runner holds strong references to all Test instances for the duration of
    the test execution. This means that for very large and very long test runs with
    many Test instances, none of the tests may be garbage collected until the end
    of the entire test run. This is particularly important in Android and when testing
    on limited devices as some tests may fail not because of an intrinsic problem
    but because of the amount of memory needed to run the application plus its tests
    exceeding the device limits.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you allocate external or limited resources in a test, such as
    `Services` or `ContentProviders`, you are responsible for freeing those resources.
    Explicitly setting an object to null in the `tearDown()` method, for example,
    allows it to be garbage collected before the end of the entire test run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Test preconditions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually there is no way to test for preconditions as the tests are discovered
    using introspection and their order could vary. So it's customary to create a
    `testPreconditions()` method to test for preconditions. Though there is no assurance
    that this test will be called in any specific order, it is good practice to keep
    this and the preconditions together for organizational purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The actual tests
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All `public void` methods whose names start with `test` will be considered as
    a test. JUnit 3, as opposed to JUnit 4, doesn't use annotations to discover the
    tests but introspection to find their names. There are some annotations available
    on the Android test framework such as `@SmallTest, @MediumTest`, and `@LargeTest`,
    but they don't turn a simple method into a test. Instead they organize them in
    different categories. Ultimately you will have the ability to run tests for a
    single category using the test runner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, name your tests in a descriptive way using nouns and the
    condition being tested.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: `testValues(), testConversionError(), testConversionToString()`
    are all valid test names.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Test for exceptions and wrong values instead of just testing for positive cases.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: During the execution of the test some conditions, side effects, or method returns
    should be compared against the expectations. To ease these operations, JUnit provides
    a full set of `assert*` methods to compare the expected results from the test
    to the actual results after running with them throwing exceptions if conditions
    are not met. Then the test runner handles these exceptions and presents the results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods, which are overloaded to support different arguments, include:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`assertEquals()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFalse()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotNull()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotSame()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNull()`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertSame()`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertTrue()`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail()`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these JUnit assert methods, Android extends Assert in two specialized
    classes providing additional tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`MoreAsserts`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewAsserts`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock objects
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mock objects are mimic objects used instead of calling the real domain objects
    to enable testing units in isolation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Generally, this is done to ensure that correct methods are called but they can
    also be of help, as mentioned, to isolate your tests from the surrounding universe
    and enable you to run them independently and repeatably.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The Android testing framework supports several mock objects that you will find
    very useful when writing your tests but you will need to provide some dependencies
    to be able to compile the tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Several classes are provided by the Android testing framework in the `android.test.mock`
    package:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`MockApplication`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockContentProvider`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockContentResolver`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockContext`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockCursor`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockDialogInterface`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockPackageManager`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MockResources`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost any component of the platform that could interact with your Activity
    can be created by instantiating one of these classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: However, they are not real implementations but stubs where every method generates
    an `UnsupportedOperationException` and that you can extend to create real mock
    objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: UI tests
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, special consideration should be taken if your tests involve UI components.
    As you may have already known, only the main thread is allowed to alter the UI
    in Android. Thus a special annotation `@UIThreadTest` is used to indicate that
    a particular test should be run on that thread and would have the ability to alter
    the UI. On the other hand, if you only want to run parts of your test on the UI
    thread, you may use the `Activity.runOnUiThread(Runnable r)` method providing
    the corresponding `Runnable` containing testing instructions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'A helper class `TouchUtils` is also provided to aid in the UI test creation
    allowing the generation of events to send to the Views, such as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: click
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: drag
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: long click
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scroll
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tap
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: touch
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By these means you can actually remote control you application from the tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse and other IDE support
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JUnit is fully supported by Eclipse and the Android ADT plugin lets you create
    Android testing projects. Furthermore, you can run the tests and analyze the results
    without leaving the IDE.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This also provides a more subtle advantage; being able to run the tests from
    Eclipse allows you to debug the tests that are not behaving correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, we can see how Eclipse runs **18 tests** taking 20.008 seconds,
    where **0 Errors** and **0 Failures** were detected. The name of each test and
    its duration is also displayed. If there was a failure, the **Failure Trace**
    would show the related information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Eclipse and other IDE support](img/3500_01_02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Other IDEs like ItelliJ and Netbeans have plugins integrating Android development
    to some degree but they are not officially supported.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you are not developing in an IDE, you can find support to run the tests
    with **ant** (check [http://ant.apache.org](http://ant.apache.org) if you are
    not familiar with this tool). This setup is done by the `android` command using
    the subcommand `create test-project` as described by this help text:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As indicated by the help you should provide at least the path to the project
    (--path) and the path to the main project or the project under test (--main).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration tests are designed to test the way individual components work jointly.
    Modules that have been unit tested independently are now combined together to
    test the integration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Usually Android Activities require some integration with the system infrastructure
    to be able to run. They need the Activity lifecycle provided by the `ActivityManager`,
    and access to resources, filesystem, and databases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The same criteria apply to other Android components like `Services` or `ContentProviders`
    that need to interact with other parts of the system to achieve their function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases there are specialized tests provided by the Android testing
    framework that facilitate the creation of tests for these components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Functional or acceptance tests
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In agile software development, functional or acceptance tests are usually created
    by business and Quality Assurance (QA) people and expressed in a business domain
    language. These are high level tests to test the completeness and correctness
    of a user requirement or feature. They are created ideally through collaboration
    between business customers, business analysts, QA, testers, and developers. However
    the business customers (product owners) are the primary owners of these tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Some frameworks and tools can help in this field, most notably FitNesse ([http://www.fitnesse.org](http://www.fitnesse.org)),
    which can be easily integrated, up to a point, into the Android development process
    and will let you create acceptance tests and check their results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Also check Fit, [http://fit.c2.com](http://fit.c2.com) and Slim (Simple List
    Invocation Method), [http://fitnesse.org/FitNesse.UserGuide.SliM](http://fitnesse.org/FitNesse.UserGuide.SliM),
    as an alternative to Fit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional or acceptance tests](img/3500_01_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: Lately, a new trend named **Behavior Driven Development** has gained some popularity
    and in a very brief description can be understood as the evolution of Test Driven
    Development. It aims to provide a common vocabulary between business and technology
    people in order to increase mutual understanding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Driven Development can be expressed as a framework of activities based
    on three principles (more information can be found at [http://behaviour-driven.org):](http://behaviour-driven.org))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Business and technology should refer to the same system in the same way
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any system should have an identified, verifiable value to the business
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upfront analysis, design, and planning all have a diminishing return
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To apply these principles, business people are usually involved in writing test
    case scenarios in a high level language and use some tool, such as **jbehave**
    ([http://jbehave.org](http://jbehave.org)). In the following example, these scenarios
    are translated into code that expresses the same test scenario in a programming
    language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Test case scenario
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an illustration of this technique here is an oversimplified example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'This scenario is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It would be translated into something similar to:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performance tests
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance tests measure performance characteristics of the components in a
    repeatable way. If performance improvements are required by some part of the application,
    the best approach is to measure performance before and after some change is introduced.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: As is widely known, premature optimization does more harm than good, so it is
    better to clearly understand the impact of your changes on the overall performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of the **Dalvik JIT** compiler in Android 2.2 changed some
    optimization patterns that were widely used in Android development. Nowadays,
    every recommendation about performance improvements on the Android developer's
    site is backed up by performance tests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: System tests
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The system is tested as a whole and the interaction between the components,
    software and hardware, is exercised. Normally, system tests include additional
    classes of tests like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: GUI tests
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke tests
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tests
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation tests
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android testing framework
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android provides a very advanced testing framework extending the industry standard
    JUnit with specific features suitable for implementing all of the testing strategies
    and types we mentioned before. In some cases, additional tools are needed but
    the integration of these tools is in most cases simple and straightforward.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of the Android testing environment include:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Android extensions to the JUnit framework that provide access to Android system
    objects.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instrumentation framework that lets tests control and examine the application.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock versions of commonly used Android system objects.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for running single tests or test suites, with or without instrumentation.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for managing tests and test projects in the ADT Plugin for Eclipse and
    at the command line.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumentation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instrumentation framework is the foundation of the testing framework. Instrumentation
    controls the application under test and permits the injection of mock components
    required by the application to run. For example, you can create mock Contexts
    before the application starts and let the application use them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: All interaction of the application with the surrounding environment can be controlled
    using this approach. You can also isolate your application in a restricted environment
    to be able to predict the results, forcing the values returned by some methods
    or mocking persistent and unchanged data for `ContentProvider`, databases, or
    even the filesystem content.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: A standard Android project has its tests in a correlated project that usually
    has the same project name but ends with **Test**. Inside this Test project, the
    `AndroidManifest.xml` declares the Instrumentation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustrative example, assume your project has a manifest like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the correlated Test project will have the following `AndroidManifest.xml:`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the Instrumentation package is the same package as the main application
    with the `.test` suffix added.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Then the Instrumentation is declared specifying the target package and the test
    runner, in this case the default custom runner `android.test.InstrumentationTestRunner`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that both, the application under test and the tests are Android
    applications with their corresponding APKs installed. Internally, they will be
    sharing the same process and thus have access to the same set of features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: When you run a test application, the **Activity Manager** ([http://developer.android.com/intl/de/reference/android/app/ActivityManager.html](http://developer.android.com/intl/de/reference/android/app/ActivityManager.html))
    uses the instrumentation framework to start and control the test runner, which
    in turn uses instrumentation to shut down any running instances of the main application,
    starts the test application, and then starts the main application in the same
    process. This allows various aspects of the test application to work directly
    with the main application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Test targets
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the evolution of your development project your tests would be targeted
    to different devices. From the simplicity, flexibility, and speed of testing on
    an emulator to the unavoidable final testing on the specific devices you intend
    your application to be run on, you should be able to run on all of them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: There are also some intermediate cases like running your tests on a local **JVM**
    virtual machine on the development computer or on a **Dalvik** virtual machine
    or `Activity`, depending on the case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Every case has its pros and cons, but the good news is that you have all of
    these alternatives available to run your tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The emulator is probably the most powerful target as you can modify almost every
    parameter from its configuration to simulate different conditions for your tests.
    Ultimately, your application should be able to handle all of these situations,
    so it is much better to discover the problems upfront than when the application
    has been delivered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器可能是最强大的目标，因为你可以从其配置中修改几乎每一个参数来模拟不同的测试条件。最终，你的应用程序应该能够处理所有这些情况，因此提前发现问题比应用程序交付后发现问题要好得多。
- en: The real devices are a requirement for performance tests, as it is somewhat
    difficult to extrapolate performance measurements from a simulated device. You
    will discover the real user experience only when using the real device. Rendering,
    scrolling, flinging, and other cases should be tested before delivering the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 真实设备对于性能测试是必需的，因为从模拟设备中推断性能测量值有些困难。你只有在使用真实设备时才能发现真实用户体验。在交付应用程序之前，应该测试渲染、滚动、抛掷和其他情况。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have reviewed the main concepts behind testing in general and Android in
    particular. Having acquired this knowledge will let us start our journey and start
    exploiting the benefits of testing in our software development projects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了测试的一般概念，特别是Android的测试。掌握这些知识将使我们开始我们的旅程，并开始在我们软件开发项目中利用测试的好处。
- en: 'So far, we have visited the following subjects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经访问了以下主题：
- en: We reviewed the early stages of testing on Android and mentioned some of the
    frameworks that created the current alternatives.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了Android测试的早期阶段，并提到了一些创建了当前替代方案的框架。
- en: We briefly analyzed the reasons behind testing and the whys, whats, hows, and
    whens of it. Furthermore, from now on we will concentrate on exploring the hows,
    as we can assume that you are convinced by the arguments presented.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要分析了测试背后的原因以及为什么、是什么、如何和何时进行测试。此外，从现在开始，我们将专注于探索如何进行测试，因为我们假设你已经被提出的论点所说服。
- en: We enumerated the different and most common types of tests you would need in
    your projects, described some of the tools we can count on our testing toolbox,
    and provided an introductory example of a JUnit unit test to better understand
    what we are discussing.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们列举了你在项目中可能需要的不同和最常见的测试类型，描述了一些我们可以依赖的测试工具，并提供了一个JUnit单元测试的入门示例，以便更好地理解我们在讨论的内容。
- en: We also analyzed these techniques from the Android perspective and mentioned
    the use of Instrumentation to run our Android tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从Android的角度分析了这些技术，并提到了使用Instrumentation来运行我们的Android测试。
- en: Now we will start analyzing the mentioned techniques, frameworks, and tools
    in detail, along with examples of their usage.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始详细分析所提到的技术、框架和工具，以及它们的使用示例。
