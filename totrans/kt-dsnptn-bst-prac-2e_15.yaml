- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Getting Started with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between `var` and `val` in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `val` keyword declares an immutable value that cannot be modified once assigned.
    The `var` keyword declares a mutable variable that can be assigned multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you extend a class in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To extend a class, you can specify its name and constructor after a semicolon.
    If it's a regular class, it must be declared `open` for your code to be able to
    extend it.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you add functionality to a `final` class?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add functionality to a class that we cannot inherit from, we can use an extension
    function. The extension function will have access only to the class itself and
    to its public fields and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2, Working with Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name two uses for the `object` keyword we learned about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `object` keyword is used to declare a singleton if it's used in a global
    scope or as a collection of static methods if it's used in a conjunction with
    the `companion` keyword inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the `apply()` function used for?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `apply()` function is used when we want to change the state of an object
    and then return it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provide one example of a static factory method that we discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JVM `valueOf()` method on the `Long` objects is a static factory method.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3, Understanding Structural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What differences are there between the implementations of the Decorator and
    Proxy design patterns?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Decorator and Proxy design patterns could be implemented in the same manner.
    The only difference is in their intent â€“ the Decorator design pattern adds functionality
    to an object, while the Proxy design pattern may change an object's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main goal of the Flyweight design pattern?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the Flyweight design pattern is to conserve memory by reusing the
    same immutable state across multiple lightweight objects.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the Facade and Adapter design patterns?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Facade design pattern creates a new interface to simplify working with complex
    code, while the Adapter design pattern allows one interface to substitute another
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4, Getting Familiar with Behavioral Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between Mediator and Observer design patterns?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both serve a similar purpose. Mediator introduces tight coupling between components
    that may serve different purposes, while Observer operates on similar components
    that are loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a **Domain-Specific Language** (**DSL**)?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DSL is a language that focuses on solving problems in a specific domain. This
    is different from a general-purpose language, such as Kotlin, that can be applied
    to different domains. Kotlin encourages developers to create DSLs for their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of using a sealed class or interface?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since all types of a sealed class are known at compile time, Kotlin compiler
    can verify that the `when` statement covers all cases or, in other words, is exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Introducing Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are higher order functions?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A higher order function is any function that either receives another function
    as input or returns a function as output.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the `tailrec` keyword in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the `tailrec` keyword is to allow the Kotlin compiler to optimize
    tail recursion and avoid stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are pure functions?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are functions that don't have any side effects, such as I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6, Threads and Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different ways to start a coroutine in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A coroutine in Kotlin could be started with either the `launch()` or `async()`
    functions. The difference is that `async()` also returns a value, while `launch()`
    doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With structured concurrency, if one of the coroutines fails, all the siblings
    will be canceled as well. How can we prevent that behavior?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can prevent canceling siblings by using `supervisorScope` instead of `coroutineScope`.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `yield()` function?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `yield()` function returns a value and suspends the coroutine until it has
    been resumed.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7, Controlling the Data Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between higher order functions on collections and on
    concurrent data structures?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher order functions on collections will process the entire collection, creating
    a copy of it, before proceeding to the next step. Higher order functions on concurrent
    data structures are reactive, processing one element after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between cold and hot streams of data?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cold stream repeats itself for each new consumer, while the hot stream will
    only send the available data to the new consumer from the time of subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When should a conflated channel/flow be used?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A conflated flow can be used in situations when the consumer is slower than
    the producer and some of the messages could be dropped, leaving only the most
    recent message for consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8, Designing for Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does it mean when we say that the `select` expression in Kotlin is biased?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A biased `select` expression means that in case of a *draw* between two channels,
    the first channel listed in the `select` expression will always be picked.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When should you use a mutex instead of a channel?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutexes are used to protect a resource shared between multiple coroutines. Channels
    are used to pass data between coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the concurrent design patterns could help you implement **MapReduce**
    or a **divide and conquer** algorithm efficiently?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For divide and conquer algorithms, the fan-out design pattern could be used
    to split the data and a fan-in design pattern could be used to combine the results.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9, Idioms and Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the alternative to Java's `try`-with-resources in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, the `use()` function works on the `Closeable` interface to make sure
    that resources are released after use.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different options for handling nulls in Kotlin?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple options to handle nulls: the Elvis operator, smart casts,
    and the `let` and `run` scope functions can help with that.'
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which problem can be solved by reified generics?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On JVM, types are erased at runtime. By inlining the generic function body into
    the call site, it allows preservation of the actual types used by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10, Concurrent Microservices with Ktor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are the Ktor applications structured and what are their benefits?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ktor applications are divided into modules, each module being an extension function
    on the `Application` object. Modularizing our application allows us to test different
    aspects of it separately.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are plugins in Ktor and what are they used for?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are a way Ktor addresses cross-cutting concerns. They are used for serializing
    and deserializing requests and responses, and setting headers, and even routing
    itself is a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main problem that the `Exposed` library solves?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Exposed` library provides a higher-level API for working with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11, Reactive Microservices with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's a verticle in Vert.x?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A verticle is a lightweight actor that allows us to separate our business logic
    into small reactive units.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the goal of the Event Bus in Vert.x?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Event Bus allows verticles to communicate with each other indirectly by
    sending and consuming messages.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why shouldn't we block the event loop?
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event loop uses a limited number of threads to process many requests concurrently.
    If even one of the threads is blocked, it reduces the performance of a Vert.x
    app.
  prefs: []
  type: TYPE_NORMAL
