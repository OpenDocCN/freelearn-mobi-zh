- en: Chapter 2. Working with Local and Remote Data Sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from remote XML through HTTPClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying data using a TableView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing your TableView with custom rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering your TableView with the SearchBar control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up your remote data access using JSON and Yahoo! YQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data locally using an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a "pull and release" refresh mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fully understanding the methods available to you in Titanium Studio when it
    comes to reading, parsing, and saving data, is fundamental to the success of the
    apps you will build. Titanium provides you with all of the tools that you will
    need to make everything from simple XML calls over HTTP, implementing JSON for
    improved network speeds, to complex applications running a localized relational
    database (SQLite) for offline storage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will not only cover the fundamental methods of implementing
    remote data access over HTTP, but also how to store and present that data effectively
    using TableViews, TableRows, and other customized user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-requisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have a basic understanding of both the XML and JSON data formats,
    which are widely-used standardized methods of transporting data across the Web.
    Additionally, you should also understand what **SQL** (**Structured Query Language**)
    is and how to create basic SQL statements such as CREATE, SELECT, DELETE, and
    INSERT. There is a great beginners introduction to SQL at [http://sqlzoo.net](http://sqlzoo.net)
    if you need to refer to tutorials on how to perform common types of database queries.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from remote XML through HTTPClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to consume and display feed data from the Internet, through RSS
    feeds or alternate APIs, is the cornerstone of many mobile applications. More
    importantly, many services that you may wish to integrate into your app will probably
    require you to do this at some point or another, such as Twitter or Wikipedia,
    so it is vital to understand and be able to implement remote data feeds and XML.
    Our first recipe for this chapter introduces some new functionality within Titanium
    to help address this need.
  prefs: []
  type: TYPE_NORMAL
- en: If you are intending to follow the entire chapter and build the MyRecipes app,
    then pay careful attention to the first *Getting Ready* section for this recipe,
    as it will guide you through setting up the project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter **MyRecipes**
    as the name of the app, and fill in the rest of the details with your own information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is `com.packtpub.myrecipes`). This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  prefs: []
  type: TYPE_NORMAL
- en: Complete source code for this entire chapter can be found in the `/Chapter 2/RecipeFinder`
    folder, while source code for this recipe can be found in the `/Chapter 2/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now our project shell is set up, so let's get down to business! First, open
    your `app.js` file, and two more JavaScript files called `recipes.js` and `favorites.js`.
    In your `app.js`, reference `recipes.js` and `favorites.js` to `win1` and `win2`
    respectively, and give each window a meaningful title (for example, "Recipes").
    We'll also change the tab icons from their defaults to the two icons 'fork-and-knife.png'
    and 'heart.png' respectively. Both of these icons are available in the accompanying
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `recipes.js` file in your IDE. This is the file that will hold our
    code for retrieving and displaying recipes from a RSS feed. Type in the following
    code at the top of your `recipes.js` file. This code will create an `HTTPClient`
    and read in the feed XML from the recipes website.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Try running the emulator now for either Android or iPhone. You should have two
    tabs appear on the screen as shown next, and, after a few seconds, a stack of
    XML data printed out to your Titanium Studio console log.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are already familiar with JavaScript for the web, this should make a
    lot of sense to you. Here we are creating an `HTTPClient` using the `Titanium.Network`
    namespace, and opening a `GET` connection on the URL of the feed from the recipes
    website, using an object called `xhr`.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the `onload` event listener, we can capture the XML data that
    has been retrieved by the `xhr` object. In the source code you will note that
    we have used `Ti.API.info()` to echo information to the Titanium Studio screen,
    which is a great way to debug and follow events in your app. If your connection
    and `GET` request was successful, you should see a large XML string outputted
    in the Titanium Studio info log. The final piece of the recipe is small but very
    important—calling the `xhr` object's `send()` method. This kicks off the `GET`
    request. Without it, your app would never load any data. It is important to note
    that you will not receive any errors or warnings if you forget to implement `xhr.send()`.
    If your app is not receiving any data, this is the first place to check.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having trouble parsing your XML, always check if it is valid first!
    Opening up the XML feed in your browser will normally provide you with enough
    information to determine whether your feed is valid, or if it has broken elements.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data using a TableView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TableViews are the most used components in the entire iPhone and Android SDKs,
    almost all of the native apps on your device will utilize tables in some shape
    or form. They are used to display large lists of data in an effective manner,
    allowing for scrolling lists that can be customized visually, searched upon, or
    drilled to expose child views. With so many available properties and options,
    it's easy to get lost in the functionality and ability of these components. Luckily
    for us, Titanium makes it easy to implement TableViews into your application.
    In this recipe, we will implement a TableView and use our XML data feed from the
    previous recipe to populate it with a list of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have connected our app to a data feed and we''re retrieving XML data
    via the XHR object, we need to be able to manipulate that data and display it
    into a TableView component. Firstly, create an array object called `data` at the
    top of your `recipes.js` file. This array will hold all of the information for
    our TableView in a global context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to disseminate the XML and read in the required elements to
    our `data` array object, before finally creating a TableView and assigning its
    `data` property to our `data object:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the Table view with the titles of our recipes
    from the XML feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you will notice is that we are using the `Ti.XML` namespace
    to assign the list of elements to a new object called `items`. This allows us
    to use a `for` loop construct in order to loop through the items and assign each
    individual item to the `data` array object we created and gave a global scope.
  prefs: []
  type: TYPE_NORMAL
- en: From there we are creating our TableView by implementing the `Titanium.UI.createTableView()`
    function. You should notice almost immediately that many of our regular properties
    are also used by tables, including width, height, and positioning. However, a
    TableView has one extra and important property data. The data property accepts
    an array of data, the values of which can either be used dynamically (as we have
    done here with the title property) or can be assigned to sub-component children
    of a TableRow. As you begin to build more complex applications you will learn
    to fully understand just how flexible table-based layouts can be.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing your TableViews with custom rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have created a TableView, which while being totally usable and showing
    the names of our recipes from the XML feed, is a bit bland. To customize our table
    we will need to create and add custom TableRow objects to an array of rows, which
    we can then assign to our TableView object. Each of these TableRow objects is
    essentially a type of View, to which we can add any number of components, such
    as Labels, ImageViews, and Buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create our TableRow objects and add to each one of them the name
    of the recipe from our XML feed, a short description, and a thumbnail image (which
    we will get from the `images` folder in our `Resources` directory) to each one
    of them. If you do not already have an images directory, create one now and copy
    the images from the source code for this recipe, which can be found in the `/Chapter
    2/Recipe 3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your `recipe.js` file and type in the following code. If you have been
    following along with the previous recipe, then the following code will extend
    what you have already written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing that should be immediately obvious is that a **TableRow** object can
    contain any number of components which you can define and add in the standard
    way (see [Chapter 1](ch01.html "Chapter 1. Building Apps using Native UI Components"),
    *Building Apps Using Native UI Components*, for examples of implementing different
    UI components).
  prefs: []
  type: TYPE_NORMAL
- en: What is the `className` property used for then? When rows are rendered on your
    device it all happens on request, that is, only those rows which are visible are
    actually rendered by the OS, which can be seen in the following screenshots. The
    reasons for this are two-fold. First, to conserve memory, of which most devices
    have precious little in comparison to desktop computers. Second, to help speed
    up your application by only performing those CPU tasks which are absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For a few rows, the memory usage without using a `className` will not be too
    high, but for many rows, depending on how many and what interface components you
    are using within the row, your app will load very slowly or may even crash.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3968EXP_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Filtering the TableView using a SearchBar component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what happens when your user wants to search all data in your TableView? By
    far the easiest way is to use the **SearchBar** component. This is a standard
    control that consists of a searchable text field with an optional cancel button,
    and attaches to the top of your table view using the table view's `searchBar`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: In this next recipe, we will implement a search bar into our **MyRecipes** app
    that filters our recipes based on the `title` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a `searchBar` component before your `tableView` is defined,
    and then create the event listener's for the `searchBar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now set the search property of our tableView to our searchBar component, and
    then set the `filterAttribute` of our tableView to`'filter'`. We will define this
    custom property called`'filter'` within each of our row objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside each row that you define when looping through our xml data, add
    a custom property called`''filter''` and set it''s value to the title text from
    the XML feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Run your project and you should now have a search bar attached to
    your table view as shown in the following screenshot. Tap it and type in any part
    of a recipe's title to see the results filtered in your table.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first block of code, we are simply defining our **SearchBar** object
    like any other UI component, before attaching it to the `searchBar` property of
    our TableView in the second block of code. The event listeners for the `searchBar`
    simply ensure that when the user taps either one of the '**Search**' or '**Cancel**'
    buttons, the focus on the text input is lost and the keyboard will therefore become
    hidden.
  prefs: []
  type: TYPE_NORMAL
- en: The final block of code defines just what data we are searching for, in this
    case, our `filter` property has been set to the title of the recipes. This property
    needs to be added to each row that we define before it is bound to our TableView.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up your remote data access using JSON and Yahoo! YQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are already familiar with using JavaScript heavily for the web, particularly
    when using popular libraries such as jQuery or Prototype, then you may already
    be aware of the benefits of using JSON instead of XML. The JSON data format is
    much less verbose than XML, meaning the file size is smaller and data transfer
    much faster. This is particularly important when a user on a mobile device may
    be limited in data speed due to network access and bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: If you have never seen Yahoo's YQL console, or heard of the YQL language web
    service, it is essentially a free web service that allows developers and applications
    to query, filter, and combine separate data sources from across the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to use the Yahoo! YQL console and web service to
    obtain data from our recipes data feed and transform that data into a JSON object,
    which we will then bind to our TableView.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, go to Yahoo's YQL console page by opening up [http://developer.yahoo.com/yql/console](http://developer.yahoo.com/yql/console)
    in your browser. On the right-hand side of the browser window you should notice
    a section called '**Data Tables**'. Select '**data**' and then '**feed**' from
    the data tables list. Your SQL statement should automatically change to a simple
    data feed from the Yahoo! News Network. Now, replace the URL value in the YQL
    statement to our recipe's feed, which is [http://www.cuisine.com.au/feed/all-recipes](http://www.cuisine.com.au/feed/all-recipes),
    select '**JSON**' instead of **XML** from the radio buttons below, and click on
    '**Test**' as shown in the following screenshot. You should see a formatted set
    of data return in the results window in JSON format!
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3968EXP_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use this data we need to copy and paste the full REST query from the YQL
    console. This is right at the bottom of the browser and is a single-line textbox.
    Copy and paste the entire URL into your `xhr.open()` method, replacing the existing
    recipes feed URL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure when you paste the string in, it hasn't broken due to any apostrophes.
    If it has, you will need to escape any apostrophe characters by replacing**'**
    with **\'**. You may also want to remove the`&callback=cbfunc` parameter from
    the URL as it can sometimes cause the JSON to stop parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in the `xhr.onload()` function, let''s replace all of the XML parsing
    code with code to parse our data in JSON format instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see in this recipe, accessing the YQL web service is simply a matter
    of passing an HTTP GET query to the YQL service URL, using a YQL statement as
    a URL parameter. When it processes a query, the Yahoo! YQL service obtains and
    transforms the requested data and returns in your specified format (in our case,
    JSON).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the properties of the JSON data object is also different, and arguably
    much simpler, as compared to XML. In JSON we use simple dot notation to navigate
    the data tree hierarchy and select the property we want to use. If you already
    understand the array syntax in PHP, Javascript, and a number of other C-Style
    languages, this should be pretty familiar to you!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this chapter we have only been using a single RSS feed source, but
    what if you have multiple RSS feeds that you wish to read in simultaneously?
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiple RSS feeds…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The answer to the previous question is to use Yahoo! Pipes—a free service provided
    by Yahoo! that let's you create a "pipe" consisting of one or more RSS, JSON,
    or data feeds which can be filtered and sorted before allowing you to output the
    data to a single feed. Give it a try by signing up for free at [http://pipes.yahoo.com](http://pipes.yahoo.com).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many reasons why SQLite has become the relational database of choice
    for mobile handsets—it is scalable, fast, written in native C, and very portable,
    and has the added bonus of an exceptionally small footprint. We need local databases
    on our devices in order to store data when devices are offline, or even to store
    data that is only required locally (high scores in a game, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the caching of remote data can help speed up data access times
    in our applications—particularly important when mobile devices may have limited
    connectivity and bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to create SQLite databases in your application, one—create
    the database in code using SQL and two—copy and attach an existing database to
    your app via the 'install' method. In this recipe we will explain how to create
    a database via SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 1/Recipe
    6` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new JavaScript file called `database.js`, and type in the following
    code at the top of your new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now add the following line to the top of each Window that we need to reference
    our database functions from. Do this to both your `recipes.js` and `favorites.js`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great things about SQLite is the simplicity of its creation. In the
    previous example code, you can see we are not even performing a "create database"
    query anywhere. Simply attempting to open a database that does not exist, in this
    case `mydb`, tells the SQLite engine to create it automatically!
  prefs: []
  type: TYPE_NORMAL
- en: From there we can create our SQL table using standard SQL syntax. In our case,
    we have created a table with an ID that is both the primary key and an auto-incrementing
    number, a title, link, and description. The latter three fields match the data
    being returned from our recipes data source. In the next recipe we can use this
    table to locally store our recipe data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at attaching a pre-populated database file.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a pre-populated database file…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Should you wish to create your database separately and attach it to your application
    at runtime, there is a method called `Titanium.Database.install().Implementing`
    this method is very easy, as it just accepts two parameters—the database file
    and the database name. As an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are also numerous free SQLite applications for creating and managing SQLite
    databases. The open source **SQLite Database Browser** tool is freely available
    from [http://sqlitebrowser.sourceforge.net](http://sqlitebrowser.sourceforge.net)
    and runs on Windows, Linux, and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data locally using an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving and updating data to your SQLite database is just a matter of creating
    a function for each CRUD operation you need, and forming the SQL statement before
    executing it against the local database (our '`db`' object).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will edit the `database.js` file to contain two new functions,
    one for inserting a record in our favorites table and one for deleting a record.
    We will also capture the click events on our Table Rows to allow the user to view
    the record in a detailed sub-window, and add a button for creating the favorite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your JavaScript file called `database.js`, and type in the following code
    at the top of your new file, after your table creation script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, back in our `recipes.js` file, we are going to capture the click event
    of the `tblRecipes` TableView in order to get the tapped row''s data and save
    it to our `favorites` table in SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we are creating functions that will accept the parameters to insert a
    favorite record, creating an SQL statement, and then executing that SQL query
    statement against our SQLite database. This is just a basic SQL query, although
    take note that just as you would with a desktop application or website, any input
    parameters should be escaped properly to avoid SQL injection! We're using a simple
    mechanism to do this in our recipe by simply replacing any occurrences of the
    apostrophe characters with a double apostrophe.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of our code defines a new Window and adds to it a couple of
    buttons and a label for displaying the full text of our recipe. You should refer
    to [Chapter 1](ch01.html "Chapter 1. Building Apps using Native UI Components"),
    *Building Apps Using Native UI Components*, for more details on opening Windows,
    and adding and customizing UI components to them. One final point of interest,
    and a method we haven't come across before, is `Ti.Platform.openURL().` This method
    simply takes a valid URL and launches the Safari browser (or Android browser)
    on your phone. In our recipe, we're passing the "link" property from our data
    so the user can view the recipe in full from it's original website.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android users can always press their back button on the device to return to
    the app after the browser is launched, but it's worth noting that iPhone users
    would need to close Safari and re-launch the application from their home screen
    after the link button has been pressed. To avoid this, you could create another
    sub-window containing a WebView component, opening this through the `Titanium.UI.currentTab.open()`
    method, just as we did for our detail view in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshots show the detail view window for our recipe, before
    and after we insert a favorite record into the SQLite database table.
  prefs: []
  type: TYPE_NORMAL
- en: '*For an iPhone:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/3968EXP_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*For an Android phone:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/3968EXP_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving data from an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to create a table and insert data into it is not of much use if
    we don't know how to retrieve that data and present it in some useful way to the
    user! We'll now introduce the concept of a **resultSet** (or recordSet if you
    prefer) in SQLite and how to retrieve data via this resultSet object that can
    be collected and returned to an array format suitable for usage within a TableView.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    8` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your `database.js` file, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `favorites.js` file for the first time, and type in the following
    code. Much of this code should be pretty familiar to you by now, including defining
    and adding a TableView to our Window, plus including the `database.js` file through
    our `Ti.include()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first block of code is really just an extension of our previous recipe.
    But instead of creating or removing records, we are selecting them into a database
    recordset called "resultSet", and then looping through this resultSet object adding
    the data we require from each record into our `results` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `results` array can then be added to our TableView's data property just
    like any other data source such as you obtained at the start of the chapter from
    an external XML feed. One thing to note is that you must *always* iterate to the
    new record in the resultSet using `resultSet.next()`, and when finished, *always
    close* the resultSet using `resultSet.close()`. A failure to do either of these
    actions can cause your application to record invalid data, leak memory badly,
    and in the worst case, fatally crash!
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3968EXP_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows the TableView in our **Favorites** tab displaying
    the records we have added as 'favorites' to our local SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a "pull and release" refresh mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if you want the user to be able to refresh the feed data in our
    table? You could create a regular button, or possibly check for new data at arbitrary
    time intervals. Alternatively, you could implement a cool 'pull and release' refresh
    mechanism made very popular by Twitter applications such as Tweetie and Twitter
    for Android.
  prefs: []
  type: TYPE_NORMAL
- en: In the final recipe for our **Recipe Finder** app, we will implement the very
    same type of refresh mechanism for our recipes feed, using the table view's `headerPullView`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    9` folder, while the complete source code for this entire chapter can be found
    in the `/Chapter 2/RecipeFinder` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your `recipes.js` file and type in the following code under the "`Ti.include`"
    statements. This is where will be creating the pull view and adding our user interface
    components to it, before creating the event listeners that will perform the data
    request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in your `xhr.open()` method, we will do a check to see if this is the
    first time we're loading data or whether this is a reload call made by our "pull
    and release" mechanism. If it's the latter, we'll hide the header pull view and
    reset the contents of it back to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are doing here can really be broken up into two main components. First,
    we're creating a header view using standard UI components. Second, we're using
    events to know when our header view has been 'pulled' down far enough so that
    we can perform a refresh on our recipes data from the XML/JSON feed.
  prefs: []
  type: TYPE_NORMAL
- en: We know how far the header view has been pulled down via the `contentOffset`
    property of our TableView. In this case, we are executing the refresh of the data
    when the content offset hits 80px, which is the height of both the header view
    and also the height of the TableView's data rows from the top of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the two variables called `pulling` and `reloading` are used in conjunction
    so we can determine the series of steps in our "pull and release" refresh mechanism
    programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: When the TableView is being pulled down by the user, using a tap and hold gesture
    (`pulling = true`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the TableView has finished pulling but has not yet started to reload the
    data from our remote data source (`pulling = true` and `reloading = false`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When our pulling has completed but we are waiting for the data to finish being
    returned from our remote data source (`pulling = false` and `reloading = true`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, when our remote data source has finished streaming the required data
    and the header pull view can be closed, and the scrolling offset of our table
    can return to normal (`pulling = false` and `reloading = false`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
