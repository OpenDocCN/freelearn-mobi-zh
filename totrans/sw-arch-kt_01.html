<html><head></head><body><div><div><div><h1 id="_idParaDest-14" class="chapter-number"><a id="_idTextAnchor013"/>1</h1>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>The Essence of Software Architecture</h1>
			<p><strong class="bold">Software architecture</strong> is the blueprint of a software system. It may not contain a single line of code but it describes how different structures work together so that systematic behaviors emerge from these structures, and thus the system serves its intended functions.</p>
			<p>This is a book for those who wish to boost their architectural knowledge and mindset to solve daily engineering problems. In this chapter, we will discuss the essential values of software architecture and its position in an organization. We are going to cover the following topics:</p>
			<ul>
				<li>The importance of software architecture</li>
				<li>The role of an architect</li>
				<li>Conway’s law</li>
				<li>Choosing a framework</li>
				<li>Documentation and diagrams</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The importance of software architecture</h1>
			<p>Why should we bother<a id="_idIndexMarker000"/> with software architecture? In theory, a good engineer can simply jump into coding. Given time and effort, a software system can be produced to start functioning. This is a typical example of jumping to the result without extracting the value from the process.</p>
			<p>A software system is a living entity that needs to adapt to the changes in the environment. Let us use a real-life example to illustrate this concept.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Real-life use case – community service exchange as a contract</h2>
			<p>In a village community, every<a id="_idIndexMarker001"/> household offers help to each other. One household’s members have certain skills lacking in another household. A member in household A is good at plumbing but not good at making clothes, while a member in household B is a tailor but the household needs pipes fixing.</p>
			<p>So, household A offers to fix the pipes of household B in exchange for household B making clothes for a newborn baby in household A.</p>
			<p>Each household uses bookkeeping software to keep records of the exchange of services in each household’s file. Each copy of the software in each household does not communicate with the other.</p>
			<p>It works well for a while until some households have a dispute over what was agreed in their exchange of services. Both households claimed their records were correct in the software; however, the records in each copy of the software are slightly different. Since each copy of software does not communicate with the other, the dispute cannot be easily resolved.</p>
			<p>One of the possible enhancements of the bookkeeping software would be to keep the records in a central data store so that households can view and agree on the details of the exchange of services before carrying out their services.</p>
			<p>However, the bookkeeping software was written without architecture. All we have are lines and lines of codes, scattered in multiple files, and with some duplicated logic in multiple places. The code itself may be well-written and organized, but the original engineer has left the village, and the new engineer does not understand the rationale behind the code.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Software architecture as a means of communication</h2>
			<p>Software architecture<a id="_idIndexMarker002"/> is fundamentally a way of communication. Firstly, it defines what problems it solves in an abstract manner that stakeholders from non-engineering backgrounds can understand and reason about the software system.</p>
			<p>Stakeholders use specific terms in describing the problem. Sometimes, different stakeholders use different terms that mean the same thing, or they might use the same term but mean different things. Engineers will also need to align with the terms and usage in the engineering structures. Software architecture acts as a common language and understanding so that all stakeholders and engineers can communicate with well-defined terms.</p>
			<p>Usually, stakeholders make use of software architecture to integrate with their operation workflows. They may have other systems to interact with, or they need teams of people to work in various parts of the system. Software architecture becomes a visualization of the<a id="_idIndexMarker003"/> automated part of the workflow.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Software architecture as training materials</h2>
			<p>Secondly, software<a id="_idIndexMarker004"/> architecture provides an abstract view of how different structures work together and focuses on certain concerns at a time. A new engineer joining the team usually has a lot to learn to understand how the current system works. Source code is the ultimate source of truth; however, it could be laborious and time-consuming to read it all. Source code is usually cluttered with language syntax and layers of function invocations. Building up an understanding of the system from the code bottom-up is certainly possible, but it would take a long time.</p>
			<p>Learning is much more effective with architectural documents that guide new members directly to the areas they care about. It is less overwhelming than source code, and it avoids engineers treating the bugs in code as the correct behaviors. New engineers can learn one aspect of the system at a time, with the aid of architectural documents.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Software architecture to manifest system quality attributes</h2>
			<p>System quality <a id="_idIndexMarker005"/>attributes, also known as system non-functional attributes, are the characteristics of a software system that define its overall behaviors, and operational and performance aspects. They are non-functional in that they are agnostic to the functional or business problems the system solves.</p>
			<p>System quality attributes, such as availability, scalability, security, testability, extendability, and maintainability, are difficult to measure with only code. Software architecture provides at least one view to manifest each of these attributes so we can tune the system accordingly.</p>
			<p>In the given example, the software could be lacking redundancy in the sense that each copy of the software stores the data in its own local storage and does not communicate with any other. If a copy has stopped working, the household would lose all data. Also, because each copy does not communicate with the other, there is no reliable way to guarantee that two households who exchanged services have the same records in their own software copies.</p>
			<p>By having software architecture to describe the system attributes, engineers will be able to identify the issue and design a change to improve the given attributes. Moreover, it enables us to measure and monitor how these attributes change over time and correlate them with <a id="_idIndexMarker006"/>software changes. We are even able to project and predict these attributes when we plan a change to the current software architecture.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Software architecture as a change management tool</h2>
			<p>Usually, problems <a id="_idIndexMarker007"/>change and evolve over time. In the example, separated records of the exchange of services in each copy of the software were sufficient, as there was not a dispute. Software architecture provides a foundation for changes and enhancements. In many cases, different stakeholders have different priorities in their minds. Software architecture facilitates the discussion of how the system could evolve and at what cost, so the enhancement can be prioritized in order.</p>
			<p>Also, with system attributes being described in software architecture, we can identify and mitigate risks since we understand which part of the architecture is being changed.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Software architecture as records of reusable solutions</h2>
			<p>Software <a id="_idIndexMarker008"/>architecture documents a series of concerns raised and decisions made. In the example of the bookkeeping software, since the original engineer has left the village, no one really knows the thinking process and why certain design choices were made at the time. It becomes very risky to enhance the system as no one knows the impact of changing one line of code. The idea of a central data store was planned and we are just one step behind it, or it was never designed to share data. We simply do not know.</p>
			<p>This leaves us unable to safely improve the software, or even just to fix a bug. We might end up making the same mistake. We might misunderstand the original intent of the software and even create a bug. It becomes difficult to continue using the software if the problem evolves like the given example.</p>
			<p>Software architecture acts as a set of records of decisions made to solve the problem. It explains the rationale of what drove the decisions and what factors were considered to make the choice. It also records any alternatives considered and why they were not eventually chosen.</p>
			<p>Software architecture also identifies any constraint the system is bound to. It is important to include constraints because any new technological advancement may eliminate such constraints, such as new frameworks, and thus create new opportunities for improvement.</p>
			<p>All this information provides solid ground if, one day, we decide to start a new system from scratch to solve the problem. We will not need to start from zero. We can start from what we have learned and the journey behind it. We can reuse a lot of the concepts from <a id="_idIndexMarker009"/>previous architecture if the context is applicable. We can significantly improve the next system with fewer constraints imposed on the previous system.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>The role of a software architect</h1>
			<p>It may seem obvious <a id="_idIndexMarker010"/>that a software architect (the <em class="italic">architect</em>) is someone who creates software architecture. However, software architecture is the result of multi-dimensional thought processes that involve a lot of people. There is no single architect who would produce architecture alone and require no input from others.</p>
			<p>It is important to point out that, although a software architect can be a job title in some organizations, the role of a software architect is not restricted to only someone who has the title.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Interface between engineers and stakeholders</h2>
			<p>Software <a id="_idIndexMarker011"/>architects align and translate the language used by engineers and non-technical people (the <em class="italic">stakeholders</em>). They facilitate communication using documentation and diagrams to illustrate key topics in the software system for discussion. There are variations in how the interface works between engineers and different stakeholders with the facilitation of software <a id="_idIndexMarker012"/>architects. We are going to explore these variations now.</p>
			<h3>Engineers and product managers</h3>
			<p>Software architects<a id="_idIndexMarker013"/> translate product requirements into technical designs. Engineers can do the same, but software architects apply a broader view in the sense of how certain implementations may impact system quality attributes. Software architects do not dictate the choice of implementation; however, they define non-functional requirements that predict system quality attributes. The non-functional requirements provide directions and constraints on the implementation.</p>
			<p>In the example given previously, if a software architect were involved in the technical design process, they could have required the records of the exchange of service between neighbors to be replicated in both software copies and thus could have avoided the dispute of inconsistent records.</p>
			<p>Software architects also take part in translating technical constraints, bugs, and implementations into information that product managers can digest and engage in. Software architects provide an abstract view of the code implementation to facilitate communication with product managers.</p>
			<p>Imagine there is a new framework that facilitates two software copies to synchronize records of service exchange between neighbors, which permanently solves the dispute problem. Software architects can document this new approach and abstract the interaction to provide a foundation to discuss with product managers how this improves user experience.</p>
			<h3>Engineers and delivery managers</h3>
			<p>There is often tension when it comes to engineers developing features and delivery managers managing the timeline for when those features can be released. It is common for engineers to not deliver the full features in time. Software architects can facilitate the discussion of how the features may be delivered in phases and still be operational. In each phase, software architects determine the impact on system quality attributes and how users can operate in the meantime.</p>
			<p>This is just an example of how software architects are involved when full features will not be available in time.</p>
			<h3>Regulators and compliance</h3>
			<p>Software systems, particularly in regulated industries, must address compliance concerns. The range is wide, and it may include the processing of personal data, auditing of persisted data, or complying with regulatory procedures.</p>
			<p>Software architects are not only involved in designing an architecture that complies with regulations but also in illustrating how it was implemented. Regulatory bodies will examine technical documents, including architecture diagrams, as part of their due diligence process.</p>
			<h3>Security professionals</h3>
			<p>People who specialize in the fields of information security or cybersecurity work with software architects in multiple areas.</p>
			<p>They provide security requirements in line with security policies, procedures, and guidelines. The requirements might include authentication, access control, and even the choice of encryption algorithms.</p>
			<p>Software architects work with security analysts to perform threat modeling and risk assessment. They analyze the system architecture, identify vulnerabilities and risks, and discover potential attacks. The likeliness and impact of threats drive architectural choices.</p>
			<p>Software architects may also work with penetration testers or ethical hackers to discover security holes and potential fixes.</p>
			<p>Security architects <a id="_idIndexMarker014"/>collaborate with software architects to identify and choose the approach to address identified risks and meet security requirements.</p>
			<h3>Stakeholders</h3>
			<p>Stakeholders usually come from multiple departments of the organization, and they are likely to have different requirements and priorities for how the system is required to work. Software architects can navigate these tangled requirements and ensure that the system can fulfill these requirements in an agreed priority order.</p>
			<p>Software architects also play the part of extracting common terms from multiple domain experts and<a id="_idIndexMarker015"/> stakeholders so the terms can be used in the architecture documents in a clear and unambiguous manner.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Balancing appropriate architecture and budget</h2>
			<p>While some software<a id="_idIndexMarker016"/> architects might be keen on having the most state-of-the-art technology and the latest and the fastest, realistically, they are more balanced with the budget the organization can afford.</p>
			<p>Financial constraints on technology choice do not necessarily result in bad architecture; on the contrary, they encourage software architects to find more cost-effective ways to solve problems, and they could lead to a leaner and simpler architecture. If two architectures can address an identical set of concerns, the simpler and cheaper one is always better.</p>
			<p>The decision of whether to buy or build is often affected by multiple factors, and the technical factor is only one of them. Although software architects may not have the power to decide which way to go, they provide technical and operational analysis so the organization can make an informed choice.</p>
			<p>When the organization cannot afford the most technically sound system or service, software architects are there to bring out compromise, trade-offs, and impact analysis for the “second-class solution.” It may seem not ideal initially, but software architects can design the system in a way that leaves room for enhancement and expansion in the future.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Vision and roadmap to technical evolution</h2>
			<p><strong class="bold">Legacy systems</strong> are<a id="_idIndexMarker017"/> outdated <a id="_idIndexMarker018"/>software systems that are still in use by the organization. They are legacy because their technology has very little room for improvement, and it is likely at least a few years backward.</p>
			<p>There are systems that became legacy due to external factors such as discontinued technology support and severe limitations. And there are no feasible or cost-effective ways to evolve.</p>
			<p>Legacy systems can also be the result of the lack of technical vision and roadmaps, in which software architects are heavily involved. Some small start-ups may not have someone taking the role of software architect, or there is no one championing software architecture continuously. These can all be reasons for systems to become legacy.</p>
			<p>However, software architects can still jump in at any point to modernize the current architecture. They start by understanding what the current system does and what the organization really needs. Then, they decompose the system into autonomous parts, modernize them individually, and recombine them in a separate way so the whole technical ecosystem can be<a id="_idTextAnchor026"/> up to date again.</p>
			<p>Usually, a technical vision includes inspiration in achieving a software architecture that manifests certain system quality a<a id="_idTextAnchor027"/>ttributes, such as highly available and scalable systems. While a technical roadmap includes small steps to achieve short- to medium-term goals, and some more dramatic changes to long-term goals, it requires meticulous planning and thought toward how the system evolves. Also, the technical roadmap must interact with the<a id="_idIndexMarker019"/> external technological evolution to pivot and adapt to a better alternative.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Cross-cutting concerns in a technical ecosystem</h2>
			<p>Cross-cutting <a id="_idIndexMarker020"/>concerns <a id="_idIndexMarker021"/>are typically the concerns that require multiple software components to work together to derive the desired outcome.</p>
			<p>One example can be standardizing logging messages so they can facilitate cross-service log searches.</p>
			<p>Engineers are often divided into teams and each team looks after a certain area of business. They do not necessarily have the bandwidth to ensure that services in other teams conform to the same convention to achieve cross-cutting outcomes.</p>
			<p>Software architects engage these cross-cutting concerns in a holistic manner. They consult, engage, and discuss with multiple teams to form a consensus or convention so cross-cutting concerns can be addressed.</p>
			<p>Software architects also drive common infrastructures, frameworks, and tooling to address these cross-cutting concerns. These concerns are closely related to the system quality attributes.</p>
			<p>Let us say there are multiple services that need to communicate with each other, and REST endpoints are chosen to be the way of communication. However, without establishing standards among teams, the system quickly falls into a collection of inconsistent APIs. The URI resource hierarchy can be inconsistent, as can the error response payload. All these impact the maintainability and reusability of the system.</p>
			<p>Software architects can be involved in understanding each team’s requirements and their concerns about using REST endpoints. Then, a guideline of REST endpoints can be created so that there is a pattern that engineers align with. A typical example would be to define a general payload structure for error responses to contain information in addition to the HTTP response status:</p>
			<pre class="source-code">
{
     "resource": "/users/32039/address/0",
     "shortMessage": "first line of address must be present",
     "longMessage": "A valid address must contain the first line",
     "details": {
           "addressLine1": null,
           "city": "London",
           "postCode": "EC12 10ED",
     }
}</pre>			<p>This sample payload<a id="_idIndexMarker022"/> represents <a id="_idIndexMarker023"/>an error of an address input; it contains general fields such as <code>resource</code>, <code>shortMessage</code>, and <code>longMessage</code> that every service can conform to, while also having a <code>details</code> section to be customized by each service.</p>
			<p>By having this standard, we can achieve overall observability of these errors and persist them in a universal format for audit purposes. Engineers can reuse this structure to reduce the time needed to develop a new REST endpoint. Engineers will also find it easier to maintain a REST endpoint even if it was developed by other engineers.</p>
			<p>In a sense, standardizing the REST error payload has addressed the cross-cutting concerns of <a id="_idIndexMarker024"/>observability, auditability, maintainability, and <a id="_idIndexMarker025"/>reusability in the whole technical ecosystem.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor029"/>Conway’s law</h1>
			<p><strong class="bold">Conway’s law</strong> is an <a id="_idIndexMarker026"/>observation that the system design of an organization mirrors the organizational structure. A computer programmer called Melvin Conway introduced this idea in 1967, and his original wording is as follows:</p>
			<p class="author-quote">“Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure.”</p>
			<p>In the context of software systems, software architecture mirrors the organization structure. The classic example can be illustrated in this diagram:</p>
			<div><div><img src="img/1.1.jpg" alt="Figure 1.1 – A company organized by skill set" width="800" height="813"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A company organized by skill set</p>
			<p>The company<a id="_idIndexMarker027"/> has a <strong class="bold">backend engineering</strong> (<strong class="bold">BE</strong>) team, a <strong class="bold">frontend engineering</strong> (<strong class="bold">BE</strong>) team, and a <strong class="bold">database engineering</strong> (<strong class="bold">DE</strong>) team. This <a id="_idIndexMarker028"/>organization<a id="_idIndexMarker029"/> groups people by their skill set. Everyone in a team is responsible for all business functions. This structure is likely to produce a monolithic system, which usually manifests in a single source code repository or one single logical process.</p>
			<div><div><img src="img/1.2.jpg" alt="Figure 1.2 – A company organized by business functions" width="999" height="628"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A company organized by business functions</p>
			<p>The organization in <em class="italic">Figure 1</em><em class="italic">.2</em> groups people by their business functions. So, everyone in a team is responsible for a designated business function, but each member may not have the same skill set. This structure is likely to produce a modular system, which contains multiple logical processes that interact with each other. Usually, there are dedicated source code repositories for each team.</p>
			<p>Systems scale better <a id="_idIndexMarker030"/>when the team size is small because the number of communication channels required for people to talk to each other is <em class="italic">n (n – 1) / 2</em> so it is exponentially scaled up. Jeff Bezos from Amazon proposed his two-pizza rule:</p>
			<p class="author-quote">“If you can’t feed your team with two large pizzas in a meeting, you’re in trouble.”</p>
			<p>So, if teams cannot be too big to scale the organization as well as the system, then it usually ends up with many teams. This resonates a lot with the architectural concepts we will cover very soon.</p>
			<p>On the other hand, despite best efforts in modernizing the architecture of a legacy system, if the organization structure refuses to align with it, it is likely that the new architecture will eventually fall back to its old habitual structure.</p>
			<p>This is something that should be solved by engineering management and upward. It is beyond what software architects can solve. However, it is worth understanding this phenomenon so the issue can be escalated as soon as possible.</p>
			<p>Some big organizations found it extremely difficult to change their structures. And they even created start-up<a id="_idIndexMarker031"/> companies to run with modern organization structures alongside modern software architecture.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Choosing a software framework</h1>
			<p>A software framework (a <em class="italic">framework</em>), or <a id="_idIndexMarker032"/>a software development framework, is a standardized set of tools that aim to solve certain problems by consistent approaches.</p>
			<p>A software system typically needs quite a few frameworks, so that they can focus on the business functions instead of lower-level concerns such as logging, JSON transformation, and configuration management. These frameworks provide a proven way to achieve the target software architecture. Choosing a framework is a part of architectural decision-making.</p>
			<p>It is rare that organizations build every framework themselves these days. The major reason is that most of the frameworks are open-sourced and supported by the community. It would take a lot of justifications for an organization to decide to develop its own framework while there are similar competing frameworks that can be used for free.</p>
			<p>Some technology companies develop their own frameworks when there are no existing ones that suit their needs. Some companies develop their own frameworks with the intent to compete with the other frameworks, and to potentially monetize from consulting business or to cross-sell their other products. It would take a lot of research effort and talent to achieve that.</p>
			<p>The other option would be to choose a framework that already exists in the market, commercial or<a id="_idIndexMarker033"/> open-sourced.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>The new framework paradox</h2>
			<p>New frameworks <a id="_idIndexMarker034"/>are released every month with the intent to solve the age-old problems of existing frameworks. Usually, there are one or two popular frameworks on the market, and the new frameworks advertise that they solved the old ones with an approach that everyone has always wanted.</p>
			<p>Of course, there are true paradigm-shifting new frameworks that made engineers more productive and really have moved the industry forward with an innovative approach. For example, <strong class="bold">Ruby on Rails</strong> has transformed the repetitive and boilerplate code configuration of web development into inference and conventions, hence vastly reducing the number of lines of code.</p>
			<p>But there are also a lot of cases where the new frameworks started with innovative approaches that did not go too well. And here comes the new framework paradox.</p>
			<p>If a new framework aims to replace a framework that has been around for many years, the new framework will need to cover a lot of areas and keep the “new approach” in each area. This is a huge undertaking for the contributors.</p>
			<p>For example, the <strong class="bold">Spring frameworks</strong> were created in 2002 to simplify dependencies of code by using <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) and <strong class="bold">Inversion of Control</strong> (<strong class="bold">IOC</strong>). But now, the frameworks have evolved to cover an extensive range of features, such as web, messaging, security, persistence, and so on. A next-generation framework to replace Spring frameworks would have to cover over 20 years of development, with a very comprehensive coverage of technical areas.</p>
			<p>The most significant risk is that the new framework may have solved one of the longest-standing problems of a framework but it falls short of the areas that are fundamental and essential. It traps the engineers who adopt the new framework and makes them face the dilemma of whether to fix the new framework or return to the old one.</p>
			<p>Another risk is that the community may not agree on what the “new approach” should be, and therefore, multiple new frameworks are created to solve the same age-old problem of the old framework. Engineers who want to try a new framework face the choice overload problem. And sometimes, it becomes a choice paralysis as there is no single definitively better choice to choose from.</p>
			<p>Let us say your team has chosen a framework and everyone is quite happy with it. However, for whatever reason, the major contributor has decided to not work on this project anymore. Then, your team is at risk of the framework not being kept up to date with the fixes and planned enhancements. Not to mention that most open-sourced frameworks are<a id="_idIndexMarker035"/> contributed by normal engineers who spend their personal time for free on this.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>How to compare and decide between software frameworks</h2>
			<p>However, in a<a id="_idIndexMarker036"/> real situation, the team would still need to choose some frameworks to move forward. An example situation would be a framework for logging messages for a Java application. Do we use the <strong class="bold">Java Logging</strong> framework<a id="_idIndexMarker037"/> that comes with the<a id="_idIndexMarker038"/> standard <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>), <strong class="bold">Apache Log4J</strong>, or <strong class="bold">Logback</strong>? How<a id="_idIndexMarker039"/> could <a id="_idIndexMarker040"/>we make the most sensible choice? Unfortunately, there are no golden rules that guarantee the best choice, but there are several aspects that the team should consider before making the decision.</p>
			<h3>Community</h3>
			<p><strong class="bold">Community</strong> is the most crucial factor in your consideration. People are the reasons the framework is created, used, and maintained. Without people, the framework will not continue. There are at least three areas of the community for the framework to look for:</p>
			<ul>
				<li>Firstly, the bigger the community, the more likely the framework will have someone to continuously support and enhance the framework. A framework should be like a living being, powered by the people in the community. Also, reasons for having a large community for a framework are likely that the framework is universally applicable and of acceptable quality for general usage.</li>
				<li>Secondly, we need to look at how well the framework is supported by the community. It could be as simple as getting help from another user on how to use the framework. It could also be the quality and quantity of technical blogs written by the members of the community to share their tips on how to apply the framework to problems. It could be measured by suggestions the community made for new features and enhancements.</li>
				<li>Thirdly, we need to see how the members of the community communicate with each other. Do they have a Slack channel, a Discord server, an email distribution list, or any instant messaging platform? How responsive are the members of the community when people post their questions out there? Are the people helpful and positive in receiving feedback?</li>
			</ul>
			<h3>Contribution</h3>
			<p>Every commit to the source code repository made up the framework the way it is now. It is worth checking some statistics to understand how actively the framework is being maintained.</p>
			<p>When was the last commit? Was it recently updated? How many commits have been made so far? Also, we can check the number of commits in the last month, the last 6 months, or the last year. Moreover, we can look at the variety of contributors. A good sign is that the commits are done by a variety of contributors, not only the usual ones. It indicates a diverse <a id="_idIndexMarker041"/>and healthy growth from contributors putting their efforts into the framework.</p>
			<p>How many forks and branches are there? Bigger numbers usually indicate healthy growth that either some members of the community are working on a change or there could be a variant of the framework soon. It is likely that there are useful features already in the code base that people are willing to spend their effort on.</p>
			<p>The number of tags indicates historical releases and may give a hint about the evolution and growth of the framework. However, be careful of versions under 1.0 (e.g., 0.67), or simply just build numbers. The contributors in this case may not want to commit to the current shape of the framework, and there may be breaking changes in the future.</p>
			<p>Versions under 1.0 also could mean contributors may not have confirmed their commitment to keep the framework running for long yet. Extra caution must be taken if you intend to put a <em class="italic">0.x</em> library dependency in your production system. It is going to be difficult if the library discontinues or introduces breaking changes.</p>
			<p>We should also look at the source code and get an impression of the code’s quality and test cases. We should glance at the test coverage to understand how deep and broad the code was tested. This would help us predict the reliability and stability of the framework.</p>
			<h3>Tooling and documentation</h3>
			<p>We should also consider whether the framework uses mature tooling to manage itself. It may include an issue tracking system that members of the community can submit bugs and track how long it takes for a bug to go from reported to fixed.</p>
			<p>The framework may also use an<a id="_idIndexMarker042"/> established <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) system. This is also a good sign of a healthy, long-running, and mature framework since there is a need to automate builds to handle the number of commits, control the quality, and release the framework.</p>
			<p><strong class="bold">Documentation</strong> is a key factor to consider since this is where engineers learn how to use the framework. The documentation does not necessarily need to be polished or automatically generated. It is the quality of the content that matters. And diagrams would be nice if they help engineers understand the concepts.</p>
			<h3>Interoperability with other frameworks</h3>
			<p>Many frameworks were designed to work with other frameworks, and some of them have innate dependencies on other frameworks. This is common and not a bad sign; however, caution must be taken on the impact.</p>
			<p>Adopting a framework that uses or works with another framework implies we are also indirectly adopting the other framework. Is the other framework compatible with the engineering approach the team has taken? Do we allow engineers in the team to use the trans<a id="_idTextAnchor033"/>itive dependencies directly in the code?</p>
			<p>Even if we are OK with the other framework, we still need to ensure that the versions are compatible. For example, framework A may have used the Apache Commons IO library, version 2.14.0, and our project currently uses 1.4. Importing framework A to our project would bring version 2.14.0 as a dependency to the project. Luckily, build frameworks such as<a id="_idIndexMarker043"/> Gradle and Maven provide a graceful way to explicitly specify a version and exclude a particular version from the transitive dependency. In this example, we will upgrade our dependency on Apache Commons IO to 2.14.0 from 1.4 to use framework A.</p>
			<h3>Building instead of choosing a framework</h3>
			<p>Engineers might want to build their own framework instead of choosing an existing one. Under certain conditions, this could be beneficial.</p>
			<p>If the software has unique requirements that cannot be met by existing frameworks, then it would justify building a bespoke framework. It could be a very specific domain, or it could have very strict non-functional requirements. For instance, engineers for <strong class="bold">High-Frequency Trading</strong> (<strong class="bold">HFT</strong>) software <a id="_idIndexMarker044"/>might write their own framework to meet ultra-low-latency requirements.</p>
			<p>Building a bespoke proprietary framework might also be justified if the organization treats it as a competitive advantage in the market with cutting-edge technology.</p>
			<p>It may also be the start of a new open-sourced framework in the community if no such framework has <a id="_idIndexMarker045"/>existed before. In this case, it may be beneficial to gather engineering talents among the communities and collaborate.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor034"/>What if we made the wrong choice?</h2>
			<p>Despite all our best <a id="_idIndexMarker046"/>efforts, we might still have chosen the wrong framework. The framework may not have delivered the intended behaviors. The contributors may have given up on the project. The framework may have taken a novel approach that no longer suits our needs.</p>
			<p>The adoption of the wrong framework becomes technical debt. Unfortunately, we need to source a replacement framework and plan the refactoring works to remove this dependency.</p>
			<p>The technique of refactoring is beyond the scope of this book, though. And it is not always possible to avoid choosing the wrong framework. All we can do is exercise our due diligence in the process of decision. If appropriate, we can also create interfaces so that only minimal classes in the code base have direct reference to the framework, while the framework usage to the rest of the code base is transparent.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor035"/>Documentation and diagrams</h1>
			<p>Software architecture <a id="_idIndexMarker047"/>as a blueprint of the system is captured in documentation and diagrams. Some of them could be captured in configuration files and templates, but when software architects need to present the system or communicate with stakeholders, documentation and diagrams are still the most used formats. Some of these diagrams will be used in upcoming chapters.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/>Business Process Model and Notation</h2>
			<p>Software systems, at <a id="_idIndexMarker048"/>a high level, can <a id="_idIndexMarker049"/>be seen as automated business processes that can be visualized in diagrams. <strong class="bold">Business Process Model and Notation</strong> (<strong class="bold">BPMN</strong>) standardizes graphical notations and provides a common language for modeling business processes. It is commonly used among engineers and stakeholders for communication and documentation purposes.</p>
			<p>Taking the example of two households coming to a mutual agreement on the contract of services they exchange (the <em class="italic">service contract</em>), the business process could be modeled as follows:</p>
			<div><div><img src="img/1.3.jpg" alt="Figure 1.3 – Example of a BPMN diagram" width="1650" height="642"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Example of a BPMN diagram</p>
			<p><strong class="bold">Household A</strong> and <strong class="bold">Household B</strong> have their own swimlanes to illustrate the process on each side. <strong class="bold">Household A</strong> submits a draft of the service contract and <strong class="bold">Household B</strong> receives it. <strong class="bold">Household B</strong> reviews the draft and submits its decision. If <strong class="bold">Household B</strong> rejects the service contract, then both processes at <strong class="bold">Household A</strong> and <strong class="bold">Household B</strong> end. Otherwise, <strong class="bold">Household B</strong> waits for <strong class="bold">Household A</strong>’s response; meanwhile, <strong class="bold">Household A</strong> records the service contract, and the process ends. Finally, <strong class="bold">Household B</strong> receives the service contract from <strong class="bold">Household A</strong> and records the service contract, and the process ends.</p>
			<p>BPMN has a rich collection of notations to describe business processes. They can be categorized into four groups.</p>
			<h3>Flow objects – activities, events, and gateways</h3>
			<p><strong class="bold">Activities</strong> can be<a id="_idIndexMarker050"/> tasks<a id="_idIndexMarker051"/> and <a id="_idIndexMarker052"/>sub-processes<a id="_idIndexMarker053"/> that happen in the business process. <strong class="bold">Events</strong> are outcomes that have happened. <strong class="bold">Gateways</strong> are the points where a decision is made or the process splits into branches.</p>
			<h3>Connecting objects – sequences and associations</h3>
			<p><strong class="bold">Sequences</strong> illustrate the<a id="_idIndexMarker054"/> flow of <a id="_idIndexMarker055"/>control<a id="_idIndexMarker056"/> and the messages communicated among flow objects. <strong class="bold">Associations</strong> describe the relationship among objects, such as inputs, outputs, or dependencies.</p>
			<h3>Swimlanes</h3>
			<p><strong class="bold">Swimlanes</strong> are the <a id="_idIndexMarker057"/>groupings of<a id="_idIndexMarker058"/> flow and connecting objects based on the roles and responsibilities of participants involved in the business process.</p>
			<h3>Artifacts</h3>
			<p><strong class="bold">Artifacts</strong> are additiona<a id="_idIndexMarker059"/>l information to<a id="_idIndexMarker060"/> the diagrams, and they provide context such as the data objects involved or simply free-text annotations.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor037"/>Architecture decision record</h2>
			<p>Software <a id="_idIndexMarker061"/>architecture <a id="_idIndexMarker062"/>can be seen as a journey from problem discovery to solution implementation. Along the journey, there are a lot of decisions made to move the system forward. An <strong class="bold">Architecture Decision Record</strong> (<strong class="bold">ADR</strong>) is a document that captures the decision made based on the context at that time and the consequences coming with it.</p>
			<p>There are many ADR templates available on the internet, which conceptually cover the following sections.</p>
			<h3>Status</h3>
			<p>This is typically just a <a id="_idIndexMarker063"/>single word to describe the current state of the ADR in the process. Here is an example of the ADR process:</p>
			<div><div><img src="img/1.4.jpg" alt="Figure 1.4 – An example of the ADR process" width="1235" height="1365"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – An example of the ADR process</p>
			<p>The basic possible states are <strong class="bold">Proposed</strong>, <strong class="bold">Accepted</strong>, and <strong class="bold">Rejected</strong>. In this example, there are other<a id="_idIndexMarker064"/> states, such as <strong class="bold">Under Review</strong> and <strong class="bold">Changes Required</strong>. It varies from one organization to another.</p>
			<h3>Context</h3>
			<p>This section should <a id="_idIndexMarker065"/>introduce the background where the discussions started. A good introduction would bring the needs of the change to the current situation e.g., pain points of the current operations, organization restructuring, business expansion, etc.).</p>
			<p>It also introduces the terms that are used throughout the discussion so they can be easily referred to without ambiguity. A bit of the current organizational structure and technical infrastructure would also be helpful.</p>
			<p>If applicable, this section can mention the current system quality attributes and why we want to change them. For instance, if our system can only handle 100 concurrent logins and the company wants to support 10,000 in the new technical design, then scalability is the system attribute this ADR proposes to change.</p>
			<p>It should also mention the desired outcomes. This sets up a target state we want our change to achieve. The motivation here should refer to the problems mentioned previously and elaborate on how the outcome could improve business results.</p>
			<h3>Decision</h3>
			<p>This section describes<a id="_idIndexMarker066"/> the proposed change in detail. It should focus on how the change would produce the desired outcome described in the previous section. It may also mention the concerns raised and how the decision was driven by the discussion.</p>
			<p>In some cases, alternative changes are mentioned. If they are mentioned, there should be a comparison between the proposed change and the alternatives. One way to compare is to list the pros and cons of each option. Another way could be to compare each option against a list of factors and conclude why an option is proposed.</p>
			<h3>Consequences</h3>
			<p>This section describes<a id="_idIndexMarker067"/> the impact of choosing the proposed change. Does it change the way the team operates? Which system attribute would it change and how? Does it optimize one aspect of the system but sacrifice another aspect? Which part of the system may become obsolete?</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor038"/>Request for Comments</h2>
			<p><strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) is a<a id="_idIndexMarker068"/> series<a id="_idIndexMarker069"/> of documents in which standards, protocols, procedures, and guidelines are <a id="_idIndexMarker070"/>proposed, discussed, agreed, and defined. <strong class="bold">Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>), a <strong class="bold">standard development organization</strong> (<strong class="bold">SDO</strong>), defined the numerous significant <a id="_idIndexMarker071"/>standards for the internet via the RFC<a id="_idIndexMarker072"/> processes, such<a id="_idIndexMarker073"/> as <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) version 4 (RFC 791) and 6 (RFC 2460), and <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) version 1.1 (RFC 2616).</p>
			<p>RFCs can be submitted by anyone, and anyone is allowed to comment on existing RFCs. They go through an iterative review and feedback process in an open and transparent manner. They are usually initiated by subject experts but are maintained by the wider community. The outcome of an RFC can be standards and protocols adopted by the industry, which are useful for framework extension, further research, or the basis for the next RFC.</p>
			<p>The format of an<a id="_idIndexMarker074"/> RFC document varies among organizations. In general, the document should cover the following sections.</p>
			<h3>Status</h3>
			<p>There are <a id="_idIndexMarker075"/>several possible statuses: <strong class="bold">Drafted</strong>, <strong class="bold">Collecting Feedback</strong>, <strong class="bold">Accepted</strong>, <strong class="bold">Rejected</strong>, and <strong class="bold">Abandoned</strong>.</p>
			<div><div><img src="img/1.5.jpg" alt="Figure 1.5 – An example of the RFC process" width="1512" height="1392"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – An example of the RFC process</p>
			<p>Once an RFC is drafted, it goes through a review and feedback iterative process. The RFC exits the iteration <a id="_idIndexMarker076"/>when it is either accepted, rejected, or abandoned.</p>
			<h3>Context</h3>
			<p>This section explains <a id="_idIndexMarker077"/>the need to submit this RFC. An example may be presented to illustrate the need for standardization or the problems caused by the lack of consistent protocols.</p>
			<h3>Approach</h3>
			<p>This section explains <a id="_idIndexMarker078"/>the approach agreed with the community after the review-feedback process. It should be as detailed as possible to capture the consensus of the approach.</p>
			<h3>Pros and cons</h3>
			<p>The benefits and <a id="_idIndexMarker079"/>drawbacks of the approach should be covered in detail so that it is clear to the community whether there should be another round of feedback collection, or at least the community is informed about the consequences of the approach.</p>
			<h3>Alternatives</h3>
			<p>This section<a id="_idIndexMarker080"/> mentions any alternative approach that was considered and discussed, but not adopted.</p>
			<h3>References</h3>
			<p>This section <a id="_idIndexMarker081"/>includes any previous RFCs mentioned, an academic paper, or any additional materials that give more context to the discussion.</p>
			<h3>Update log</h3>
			<p>As an RFC is likely to<a id="_idIndexMarker082"/> result in a lengthy review-feedback process, an update log is useful in keeping each meaningful change of the RFC in chronological order.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>RFC and ADR</h2>
			<p>RFC and ADR <a id="_idIndexMarker083"/>share many<a id="_idIndexMarker084"/> similarities in their document formats, but they are also different in terms of usage. RFC focuses on industry standards and protocols among large communities, while ADR focuses on conventions within an organization. RFC tends to be closer to best practices, while ADR tends to be closer to solutions and code.</p>
			<p>Despite the difference, RFC and ADR can work in collaboration. For topics that require consensus, expect long discussion, or have significant impacts, an RFC can be written first to come to an agreement on the approach. Then, an ADR can be written as a record of the decision and as <a id="_idIndexMarker085"/>a detailed technical specification of the approach.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>UML diagrams</h2>
			<p><strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) is a <a id="_idIndexMarker086"/>software <a id="_idIndexMarker087"/>modeling language standardized from different modeling languages and notations since 1994. UML 1.0 was adopted as a standard by an international standards consortium called <a id="_idIndexMarker088"/>the <strong class="bold">Object Management Group</strong> (<strong class="bold">OMG</strong>) in 1997.</p>
			<p>UML has a diverse collection of well-defined software elements that can form various diagrams that help engineers model business problems in a structural and visual manner. There are 14 UML diagrams, grouped into two categories.</p>
			<h3>Structural diagrams</h3>
			<p>Structural diagrams<a id="_idIndexMarker089"/> represent the static structure of a system. They focus on elements such as classes, objects, components, and packages. They emphasize how these elements are organized and connected with each other in a system. The following diagram is an example of a class diagram:</p>
			<div><div><img src="img/1.6.jpg" alt="Figure 1.6 – An example of a UML class diagram" width="1587" height="943"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – An example of a UML class diagram</p>
			<p>A class diagram usually contains classes and interfaces. Each class can contain a few attributes and a few functions. For example, the <code>ServiceContract</code> class has three attributes: <code>agreedDate</code>, <code>received</code>, and <code>provided</code>. The class also has one function, <code>isContractConcluded</code>, that returns a <code>boolean</code> value. The <code>received</code> and <code>provided</code> fields of the <code>ServiceContract</code> class references the other class, <code>Service</code>. We could say the multiplicity of the <code>ServiceContract</code> class to the <code>Service</code> class is one-to-two, as depicted in the diagram.</p>
			<p>From the business perspective, a <code>ServiceContract</code> class is a contract of exchanged services modeled as two instances of the <code>Service</code> class: one is a <code>received</code> service and the other is a <code>provided</code> service. If the contract is mutually agreed, then the <code>agreedDate</code> field should capture the time when it was agreed.</p>
			<p>There are seven UML<a id="_idIndexMarker090"/> structural diagrams, and there is a specific use for each, depending on which element is under the spotlight:</p>
			<ul>
				<li><strong class="bold">Class diagrams</strong>, as illustrated, depict the static structure of classes, and their attributes, functions, and relationships with other classes.</li>
				<li><strong class="bold">Object diagrams</strong> visualize the instances of classes and their relationships at a point in time, usually from a real-life example, to represent a snapshot of the system runtime structure.</li>
				<li><strong class="bold">Package diagrams</strong> show how classes and components are organized into packages and the relationship among packages.</li>
				<li><strong class="bold">Component diagrams</strong> represent the high-level logical or physical components that make up a system and their relationships.</li>
				<li><strong class="bold">Deployment diagrams</strong> depict the software components physically deployed to hardware infrastructure and their connections to other physical nodes.</li>
				<li><strong class="bold">Composite structure diagrams</strong> describe the internal structure of a class or a component, with a focus on how the internal fields and functions collaborate.</li>
				<li><strong class="bold">Profile diagrams</strong> are extensible and customized diagrams that combine other UML diagrams. They<a id="_idIndexMarker091"/> facilitate UML language being extended to be domain-specific.</li>
			</ul>
			<h3>Behavioral diagrams</h3>
			<p>Behavioral diagrams<a id="_idIndexMarker092"/> represent the dynamic interactions of a system. They include elements such as actors, messages, activities, states, and transitions. The key focus in these diagrams is how the system’s behavior emerges from the flow of control, interactions, or state transitions. The following is an example of a state diagram:</p>
			<p class="IMG---Figure">,</p>
			<div><div><img src="img/1.7.jpg" alt="Figure 1.7 – Example of a UML state machine diagram" width="940" height="1100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Example of a UML state machine diagram</p>
			<p>This state machine diagram describes the life cycle of a service contract between two households. It begins with the submission of a service contract drafted by one household. Then, while the service contract is under review, the service contract can be amended by either household, until it is either rejected or mutually agreed. Afterward, the service contract may still be withdrawn. Otherwise, the households involved exercise the services in the contract until both services are exercised and the service contract reaches the end of the life cycle.</p>
			<p>There are seven UML behavioral diagrams. It is technically possible to use any of them to describe the same system behavior. The difference is the aspect of the behaviors shown in the diagram:</p>
			<ul>
				<li><strong class="bold">State machine diagrams</strong>, as visualized, model how the system responds differently in each state and how the state transitions from one to another.</li>
				<li><strong class="bold">Communication diagrams</strong>, also known<a id="_idIndexMarker093"/> as <strong class="bold">collaboration diagrams</strong>, emphasize the messages exchanged between objects or components.</li>
				<li><strong class="bold">Activity diagrams</strong> represent a business or operational workflow of a component in a system as a sequence.</li>
				<li><strong class="bold">Interaction overview diagrams</strong> represent a business or operational workflow of a component in a system, with a focus on interactions among components in a system.</li>
				<li><strong class="bold">Sequence diagrams</strong> visualize the messages exchanged between objects and components in chronological order.</li>
				<li><strong class="bold">Timing diagrams</strong> visualize the messages exchanged between objects and components within a period with a focus on time constraints and the ordering of events.</li>
				<li><strong class="bold">Use case diagrams</strong> capture the interactions between actors and the system. Actors can be users or external system<a id="_idTextAnchor041"/>s, so a<a id="_idTextAnchor042"/>ctors can achieve their goals through the <a id="_idIndexMarker094"/>functions of the system.</li>
			</ul>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor043"/>The C4 model</h2>
			<p><strong class="bold">The C4 model</strong> is a visual <a id="_idIndexMarker095"/>modeling<a id="_idIndexMarker096"/> approach developed in the 2010s. This approach originated from the observation that many software architecture diagrams were either lacking details (too high level) or overwhelmed with details (too low level). This approach aims to provide a set of guidelines and conventions to document architectures at the right level of abstraction.</p>
			<p>It gained popularity over time among software architects and engineers who wanted a simple and effective way to document their systems. The <strong class="bold">Structurizr</strong> tool was developed <a id="_idIndexMarker097"/>by the C4 model creator, Simon Brown, to allow the creation of architecture models as code.</p>
			<p>The C4 model can be described using the metaphor of maps: from a street view, where we could see pedestrians and cars on the roads, then zoom out to see a city map of how the main roads are connected in the city, then zoom out to see a country map, where we see the main cities and towns of the country, then to the world map, where we see the Earth.</p>
			<p>The C4 model has four levels of abstraction. Each level helps different people to communicate and collaborate with the subject in question highlighted. It is helpful to bring up the right <a id="_idIndexMarker098"/>diagram in a meeting or workshop to start a conversation.</p>
			<h3>Level 1 – System context diagram</h3>
			<p>The <strong class="bold">system context diagram</strong> is the “big picture” diagram, and<a id="_idIndexMarker099"/> the major focus is the “system.” The <a id="_idIndexMarker100"/>diagram should be centered around the system, and it interacts with actors, business operations, and external systems. This diagram is particularly useful for communication with non-technical stakeholders and external organizations.</p>
			<div><div><img src="img/1.8.jpg" alt="Figure 1.8 – An example of a system context diagram (C4 level 1)" width="730" height="628"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – An example of a system context diagram (C4 level 1)</p>
			<p>The Community Service Exchange software is a standalone software installed as an isolated copy in each <a id="_idIndexMarker101"/>household. The copies of the software do <a id="_idIndexMarker102"/>not communicate with each other.</p>
			<h3>Level 2 – Container diagram</h3>
			<p>The <strong class="bold">container diagram</strong> zooms <a id="_idIndexMarker103"/>in on the “system” and focuses on how <a id="_idIndexMarker104"/>multiple containers inside the system work together. Each container here refers to a deployable process and has its own role, responsibility, and boundary in the system.</p>
			<p>The container diagram can also be used to illustrate any middleware or infrastructure used in the system, such as messaging brokers, data stores, or filesystems.</p>
			<p>This diagram is useful for communication with technical stakeholders such as platform engineers, database administrators, network engineers, or security engineers.</p>
			<div><div><img src="img/1.9.jpg" alt="Figure 1.9 – An example of a container diagram (C4 level 2)" width="1131" height="629"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – An example of a container diagram (C4 level 2)</p>
			<p>The Community Service Exchange software contains a module to organize all the static content such as images and fonts. There is an application module to validate data and run checks. The application module uses the relational database to persist the data required. The application module also retrieves report data from the relational database and exports it to the <a id="_idIndexMarker105"/>filesystem. The household can read the report file<a id="_idIndexMarker106"/> from the filesystem.</p>
			<h3>Level 3 – Component diagram</h3>
			<p>The <strong class="bold">component diagram</strong> zooms <a id="_idIndexMarker107"/>in a container and provides a<a id="_idIndexMarker108"/> view of how different components constitute a container.</p>
			<p>It describes the input to the component (e.g., REST endpoints, message consumers, or a scheduler) and the output from the component (e.g., events, response to a request, etc.).</p>
			<p>Another important function of this diagram is to demonstrate the logical packages inside the container that serve business operations. They typically load, transform, combine, and compute functions on multiple representations of entities modeled for the business purpose.</p>
			<p>This diagram is closer to the software engineers, so they understand the context where they write code and scripts.</p>
			<div><div><img src="img/1.10.jpg" alt="Figure 1.10 – An example of a component diagram (C4 level 3)" width="850" height="673"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – An example of a component diagram (C4 level 3)</p>
			<p>The application module of the Community Service Exchange software has a service exchange controller that operates a service contract (the “contract”) between two households. It is business logic that manages the life cycle of a contract from the beginning till the end. It passes the contracts to the service exchange repository for persistence logic such as translating the contract entities into database tables and columns.</p>
			<p>On the other hand, the file export controller serves a request from the household to generate a report of the contracts the household was involved in. The file export controller <a id="_idIndexMarker109"/>validates<a id="_idIndexMarker110"/> the request and generates the file ready to be available in the filesystem, which is outside of this application module. There is part of the statistical data on the contracts, and the calculations are done by the service statistic calculator.</p>
			<h3>Level 4 – Code diagram</h3>
			<p>Finally, we come<a id="_idIndexMarker111"/> to the lowest level of abstraction – the <strong class="bold">code diagram</strong>. This is a <a id="_idIndexMarker112"/>microscopic view of a component for engineers to understand the design patterns used, and how source code is represented in an abstract view in relation to other source files.</p>
			<p>We could describe the entities modeled in the component and the relationship among them. That can be translated into a relational database schema.</p>
			<p>We could be describing a process that involves multiple classes in the object-oriented style. We could demonstrate the fields captured in each class and how classes interact with each other.</p>
			<p>It is not mandatory to have a code diagram for every part of the system because simple logic can be expressed directly in the source code. Typically, code diagrams are used to capture more complex interactions so engineers can be mindful when they are coding. This is also where you will see UML diagrams.</p>
			<div><div><img src="img/1.11.jpg" alt="Figure 1.11 – An example of a code diagram (C4 level 4)" width="1557" height="924"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – An example of a code diagram (C4 level 4)</p>
			<p>Inside <code>ServiceExchangeController</code>, there is a data class called <code>Household</code> that contains a list of <code>HouseholdMember</code> objects. The <code>HouseholdMember</code> data class models a household member who has the skills to execute a contract.</p>
			<p>There is a <code>Service</code> class that captures the execution details of a contract from a household. It provides an <code>isExecuted</code> function that returns a Boolean value of <code>true</code> if its <code>executedBy</code> and <code>executedAt</code> fields are both not null.</p>
			<p>The <code>ServiceContract</code> class models a service contract between two <code>Service</code> objects. It captures the date when the contract was agreed by both households. The receiver and the provider of the contract is a <code>Service</code> object. It provides an <code>isContractConcluded</code> function that returns a Boolean value of <code>true</code> if the result of the <code>isExecuted</code> function <a id="_idIndexMarker113"/>from <a id="_idIndexMarker114"/>both objects returns <code>true</code>.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor044"/>Summary</h1>
			<p>We have covered the importance of software architecture with a real-world example. We discussed how software architecture plays a role in communication, training, budgeting, defining visions, and addressing cross-cutting concerns in the technology ecosystems.</p>
			<p>We have discussed Conway’s law and how the structure of an organization affects the architecture of systems.</p>
			<p>We have navigated the topic of choosing a software framework in multiple scenarios with pros and cons.</p>
			<p>We have also covered the documentation and diagrams that are often used in software architecture, such as ADRs, RFC, UML diagrams, and the C4 model.</p>
			<p>In the next chapter, we will introduce some fundamental architectural principles that drive modern software architecture. We will break down and combine multiple concepts and illustrate them with the same real-world example.</p>
		</div>
	</div></div></body></html>