<html><head></head><body>
		<div><h1 id="_idParaDest-154"><em class="italic"><a id="_idTextAnchor327"/>Chapter 12</em>: Exploring the Jetpack Lifecycle Components</h1>
			<p>In this chapter, we're adding a countdown timer component to our Repositories app from <a href="B17788_11_ePub.xhtml#_idTextAnchor317"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating Infinite Lists with Jetpack Paging and Kotlin Flow</em>, while also exploring the Jetpack Lifecycle components.</p>
			<p>In the first section, <em class="italic">Introducing the Jetpack Lifecycle components</em>, we want to explore how the lifecycle events and states are tied to Android components such as <code>Activity</code> or <code>Fragment</code>, and then how predefined components from the <code>Lifecycle</code> package can react to them.</p>
			<p>Next, in the <em class="italic">Adding a countdown component in the Repositories app</em> section, we will be creating and adding a countdown timer component to the Repositories app. When a 60-second countdown finishes, we will award users with a fictional prize.</p>
			<p>However, we will want the countdown to run as long as the timer is visible on the screen; otherwise, users could cheat by minimizing the application and having the countdown run in background. In the <em class="italic">Creating your own lifecycle-aware component</em> section, we will prevent users from cheating by making our timer component aware of the different lifecycle events and states that our Android components traverse.</p>
			<p>In the <em class="italic">Making our countdown component aware of the lifecycle of composables</em> section, we will realize that users can also cheat on the countdown contest by scrolling and hiding the timer countdown UI element. To prevent them from doing that, we will also make sure that our countdown component knows how to react to composition cycles that our Compose UI features.</p>
			<p>To summarize, in this chapter, we will be covering the following sections:</p>
			<ul>
				<li>Introducing the Jetpack Lifecycle components</li>
				<li>Adding a countdown component in the Repositories app</li>
				<li>Creating your own lifecycle-aware component</li>
				<li>Making our countdown component aware of the lifecycle of composables </li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor328"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along with this chapter smoothly, make sure that you also have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>A Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The existing Repositories app from the GitHub repository of the book.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Repositories app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_11</code> directory of the repository and importing the Android project entitled <code>repositories_app_solution_ch11</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_12</code> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12</a>.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor329"/>Introducing the Jetpack Lifecycle components</h1>
			<p>It's no <a id="_idIndexMarker1045"/>secret by now that components within the Android framework have certain lifecycles that we must respect when we need to interact with them. The<a id="_idIndexMarker1046"/> most common components that own a<a id="_idIndexMarker1047"/> lifecycle are <code>Activity</code> and <code>Fragment</code>.</p>
			<p>As programmers, we cannot control the lifecycle of Android components because their lifecycle is defined and controlled by the system or the way Android works.</p>
			<p>Going back to Lifecycle components, a very good example is the entry point to our Android application, represented by the <code>Activity</code> component, which, as we know, possesses a lifecycle. This means that in order to create a screen in our Android application, we need to create an <code>Activity</code> component – from this point on, all our components must be aware of its lifecycle to not leak any memory.</p>
			<p>Now, when<a id="_idIndexMarker1048"/> we say that <code>Activity</code> has a system-defined lifecycle, this actually translates into our <code>Activity</code> class inheriting from <code>ComponentActivity()</code>, which in turn contains a <code>Lifecycle</code> object. If we have a look at our <code>MainActivity</code> class from the Repositories app, we can see that it inherits from <code>ComponentActivity()</code>:</p>
			<pre>class MainActivity <strong class="bold">: ComponentActivity()</strong> {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        […]
    }
}</pre>
			<p>Now, if we dig into the source code of the <code>ComponentActivity.java</code> class, we can see that it implements the <code>LifecycleOwner</code> interface:</p>
			<div><div><img src="img/B17788_12_01.jpg" alt="Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner interface</p>
			<p>In other words, the <code>ComponentActivity</code> class is an owner of a lifecycle. If we check out the implementation of the <code>LifecycleOwner</code> interface a few hundreds of lines downward in the source code, we can see that the <code>LifecycleOwner</code> interface contains a single method called <code>getLifecycle()</code> that returns a <code>Lifecycle</code> object:</p>
			<div><div><img src="img/B17788_12_02.jpg" alt="Figure 12.2 – Observing the implementation of the LifecycleOwner interface method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2 – Observing the implementation of the LifecycleOwner interface method</p>
			<p>From these findings, we can deduct that our <code>Activity</code> classes have a system-defined lifecycle, as they implement the <code>LifecycleOwner</code> interface, which in turn means that they own a <code>Lifecycle</code> object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are several other components in Android that have a lifecycle. In the context of the <code>Activity</code> classes, there are other classes inheriting directly or indirectly from <code>ComponentActivity</code>, therefore owning a <code>Lifecycle</code> object – se<a id="_idTextAnchor330"/>e <code>AppCompatActivity</code> o<a id="_idTextAnchor331"/>r <code>FragmentActivity</code>. Alternatively, just as <code>Activity</code> classes have a lifecycle, so do <code>Fragment</code> components. If you check out the source code of the <code>Fragment</code> class, you will notice that it also implements the <code>LifecycleOwner</code> interface, and so it also contains a <code>Lifecycle</code> object.</p>
			<p>Simply put, the concept of a component having a lifecycle boils down to the idea of it providing a concrete implementation of the <code>Lifecycle</code> interface. This brings the idea that components <a id="_idIndexMarker1049"/>with a lifecycle, such as <code>Activity</code>, expose information related to their lifecycle.</p>
			<p>To better understand what we can find out about a component's lifecycle, we must explore the source code of the <code>Lifecycle</code> abstract class. If we do that, we will learn that the <code>Lifecycle</code> class contains information about the lifecycle state of the component that it's bound to, such as <code>Activity</code> or <code>Fragment</code>. The <code>Lifecycle</code> class features two main tracking pieces of information in the form of enumerations:</p>
			<ul>
				<li><code>onCreate()</code>, <code>onStart()</code>, <code>onResume()</code>, <code>onPause()</code>, <code>onStop()</code>, and <code>onDestroy()</code>).</li>
				<li><code>INITIALIZED</code>, <code>DESTROYED</code>, <code>CREATED</code>, <code>STARTED</code>, and <code>RESUMED</code>. If our <code>Activity</code> just received the <code>onResume()</code> callback, it means that until a new event arrives, it will stay in the <code>RESUMED</code> state. Upon every new event (the lifecycle callback), the state changes.</li>
			</ul>
			<p>While we were already pretty familiar with the lifecycle events (callbacks), we might need to better understand how lifecycle states are defined.</p>
			<p>Let's take a practical example and <a id="_idIndexMarker1052"/>explore what information a <code>Lifecycle</code> object can provide about an <code>Activity</code> component. As previously mentioned, the information is structured in the form of events and states:</p>
			<div><div><img src="img/B17788_12_03.jpg" alt="Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events and states&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events and states</p>
			<p>In the preceding diagram, we were able to dissect the lifecycle of an <code>Activity</code> component by its events and states. We also now have a better overview of how lifecycle events trigger transitions between lifecycle states.</p>
			<p>But why do all these events and states matter to us?</p>
			<p>In fact, most of our code is driven with respect to lifecycle information. To avoid potential crashes, memory leaks, or wasting resources, it's essential to perform actions only in the correct state or on the correct lifecycle event.</p>
			<p>When we think of <a id="_idIndexMarker1053"/>lifecycle events, we can say that different types of functionalities can and should only be executed at appropriate times, or after certain lifecycle callbacks. For example, we wouldn't want to update our UI components with data after the <code>onDestroy()</code> callback in our <code>Activity</code>, as it's very likely that our app would crash simply because the UI has been scrapped by this time. Another example would be that when the <code>onResume()</code> event is called in our <code>Activity</code>, we would know that our <code>Activity</code> has gained (or regained) focus, so we can perform certain actions in our code such as initializing our camera component.</p>
			<p>When we think of lifecycle states, we can say that different continuous actions can and should be running only during certain lifecycle periods – for example, we would want to start observing database changes if the state is <code>RESUMED</code> because that's when the user can interact with the screen and mutate data. When this state transitions to a different one, such as <code>CREATED</code> or <code>DESTROYED</code>, we might want to stop observing database changes so that we avoid memory leaks and don't waste resources.</p>
			<p>From the previous examples, it's clear that our code should be aware of the lifecycle of Android components. When we write code based on lifecycle events or states, we're writing code that is aware of the lifecycle of a specific component.</p>
			<p>Let's take an example and use our imagination a bit – the <code>Presenter</code> class features<a id="_idIndexMarker1054"/> a data stream produced by several network requests. That data stream is observed and passed to the UI. However, any ongoing network requests must be canceled in the <code>cancelOngoingNetworkRequests()</code> method, as our UI no longer needs to consume their response:</p>
			<pre>class Presenter() {
    // observe data and pass it to the UI
    fun cancelOngoingNetworkRequests() {
        // stop observing data
    }
}</pre>
			<p>Let's say that an instance of our <code>Presenter</code> class is used inside <code>MainActivity.</code> Naturally, it must respect the lifecycle of the <code>MainActivity</code> class. That's <a id="_idIndexMarker1055"/>why we should stop any ongoing network requests from within the <code>Presenter</code> class by calling the <code>cancelOngoingNetworkRequests()</code> method of the <code>Presenter</code> class inside the <code>onDestroyed()</code> lifecycle callback of the <code>MainActivity</code> class:</p>
			<pre>class MainActivity : ComponentActivity() {
    val presenter = Presenter()
    override fun onStart() {
        super.onStart()
        //consume data from presenter
    }
    override fun onDestroy() {
        super.onDestroy()
<strong class="bold">        presenter.cancelOngoingNetworkRequests(<a id="_idTextAnchor332"/>)</strong>
    }
}</pre>
			<p>We can say that our <code>Presenter</code> is aware of the lifecycle of its host, <code>MainActivity</code>.</p>
			<p>If a component respects the lifecycle of an Android component such as <code>Activity</code>, then we can consider that component to<a id="_idIndexMarker1056"/> be <strong class="bold">lifecycle-aware</strong>.</p>
			<p>However, we manually made our <code>Presenter</code> class be lifecycle-aware by manually calling a certain cleanup method from the <code>MainActivity</code> lifecycle callback. In other words, we had our <code>MainActivity</code> manually tell <code>Presenter</code> that it must stop its ongoing work.</p>
			<p>Also, whenever we need to use our <code>Presenter</code> in some other <code>Activity</code> or <code>Fragment</code> classes, that component will need to remember to call the <code>cancelOngoingNetworkRequests()</code> method of <code>Presenter</code> on a certain lifecycle callback, therefore producing boilerplate code. If <code>Presenter</code> needed multiple actions on certain lifecycle callbacks, then that boilerplate code would have multiplied.</p>
			<p>With the <code>Activity</code> or <code>Fragment</code> components manually <a id="_idIndexMarker1057"/>inform our classes that a certain lifecycle event was triggered, or a certain state was reached – the <code>Lifecycle</code> package will help us receive the callbacks directly inside our components in a more efficient manner.</p>
			<p>The Jetpack <code>Lifecycle</code> package provides us with the following:</p>
			<ul>
				<li>Predefined lifecycle-aware components<a id="_idIndexMarker1058"/> with different purposes that require less boilerplate or work from our side. Such components are two Jetpack libraries:<ul><li><code>ViewModel</code></li><li><code>LiveData</code></li></ul></li>
				<li>A Lifecycle API <a id="_idIndexMarker1059"/>that allows us to create a custom lifecycle-aware component much easier with less boilerplate code.</li>
			</ul>
			<p>Before creating our own lifecycle-aware component, we should briefly cover the two predefined lifecycle-aware components that the Jetpack <code>Lifecycle</code> package provides us with. Let's begin with <code>ViewModel</code>.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor333"/>ViewModel</h2>
			<p>In this <a id="_idIndexMarker1060"/>book, we have already covered Jetpack's <code>ViewModel</code> as a <a id="_idIndexMarker1061"/>class where our UI state resides and where most of the presentation logic is found. However, we also learned that in order to properly cancel data streams or ongoing network requests, <code>ViewModel</code> is aware of the lifecycle of its host <code>Activity</code>, <code>Fragment</code>, and even its composable destination (in conjunction with the Jetpack Navigation component).</p>
			<p>In contrast to our <code>Presenter</code> class, whose lifecycle we have manually tied to the lifecycle of a host <code>Activity</code>, Jetpack's <code>ViewModel</code> is a lifecycle-aware component that we can use to eliminate any boilerplate calls from <code>Activity</code> or <code>Fragmen</code>t components.</p>
			<p>To be more <a id="_idIndexMarker1062"/>precise, <code>ViewModel</code> knows when its host component with a lifecycle reaches the end of its lifecycle and provides us with a callback method that we can use by overriding the <code>onCleared()</code> method. Inside this callback, we can cancel any pending work whose result we're no longer interested in to avoid memory leaks or wasting resources.</p>
			<p>As an example, if <a id="_idIndexMarker1063"/>our <code>ViewModel</code> is hosted by an  <code>Activity</code>, then it knows when in the lifecycle of that <code>Activity</code> the <code>onDestroy()</code> event was called, and so it automatically triggers the <code>onCleared()</code> callback:</p>
			<div><div><img src="img/B17788_12_04.jpg" alt="Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity</p>
			<p>This basically means that instead of manually having our <code>Activity</code> inform the <code>ViewModel</code> that its lifecycle has ended so that it can stop its work, <code>ViewModel</code> is a lifecycle-aware component that does that out of the box for you by providing a handle for that event – that is, the <code>onCleared()</code> callback:</p>
			<pre>class MyViewModel(): ViewModel() {
<strong class="bold">    override fun onCleared() {</strong>
        super.onCleared()
        // Cancel work
    }
}</pre>
			<p>Additionally, in the <a id="_idIndexMarker1064"/>context of an <code>Activity</code> host, the <code>ViewModel</code> component is also aware of any lifecycle callbacks caused by events<a id="_idIndexMarker1065"/> such as a configuration change, so it knows how to outlive those and helps us maintain the UI state, even after a configuration change.</p>
			<p>But how does <code>ViewModel</code> know about the lifecycle callbacks of an <code>Activity </code>component? To answer that, we can look at a traditional way of instantiating a <code>ViewModel</code> inside an <code>Activity</code> by using the <code>ViewModelProvider</code> API and specifying the type of <code>ViewModel</code>  that must be retrieved – that is, <code>MyViewModel</code>:</p>
			<pre>class MyActivity: ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val vm = 
          <strong class="bold">ViewModelProvider(this)[MyViewModel::class.java]</strong>
         // Perform operations
    }
}</pre>
			<p>To get an instance of <code>MyViewModel</code>, we used the <code>ViewModelProvider()</code> constructor and passed the <code>this</code> instance of the <code>MyActivity</code> class to the <code>owner</code> parameter that expected a <code>ViewModelStoreOwner</code> object. <code>MyActivity</code> indirectly implements the <code>ViewModelStoreOwner</code> interface because <code>ComponentActivity</code> does so.</p>
			<p>To control the<a id="_idIndexMarker1066"/> lifetime of the instance of our <code>ViewModel</code>, <code>ViewModelProvider</code> needs an instance of <code>ViewModelStoreOwner</code> because when it instantiates our <code>MyViewModel</code>, it will <em class="italic">link</em> the lifetime of this instance to the lifetime of the <code>ViewModelStoreOwner</code> – that is, <code>MyActivity</code>.</p>
			<p>But how does <code>ViewModel</code> know <a id="_idIndexMarker1067"/>when it must be cleared? In other words, what triggers the <code>onCleared()</code> method of the <code>MyViewModel</code> class?</p>
			<p><code>ComponentActivity</code> will wait for its <code>onDestroy()</code> lifecycle callback, and when that event is triggered, it will call the <code>getViewModelStore()</code> method of the <code>ViewModelStoreOwner</code> interface and obtain a <code>ViewModelStore</code> object. On this object, it will then call the <code>clear()</code> method to clear the <code>ViewModel</code> instance that was linked to <code>ComponentActivity</code> – in our case, the <code>MyViewModel</code> instance.</p>
			<p>If you check out the source code of the <code>ComponentActivity</code> class, you will find the following implementation, which proves the previous points we're trying to express:</p>
			<div><div><img src="img/B17788_12_05.jpg" alt="Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity</p>
			<p>Now, the <code>ViewModel</code> lifecycle-aware component is helpful because it allows us to easily stop pending work and also persist UI state across configuration changes.</p>
			<p>However, there is another important lifecycle-aware component that we haven't covered in this book and that we should briefly mention, and that is <code>LiveData</code>.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor334"/>LiveData</h2>
			<p><code>LiveData</code> is<a id="_idIndexMarker1068"/> an observable data holder class that <a id="_idIndexMarker1069"/>allows us to get data updates in a lifecycle-aware manner inside our Android components, such as <code>Activity</code> and <code>Fragment</code>. While specific implementations of Kotlin Flow data streams are similar to <code>LiveData</code> because both allow us to receive multiple data events over time, <code>LiveData</code> presents the advantage of being a lifecycle-aware component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this section, we won't cover <code>LiveData</code> extensively to understand its API. Instead, we will try to highlight its lifecycle-aware character. Right now, you don't have to code along.</p>
			<p>Without going into too much detail, let's see a simple usage of a <code>LiveData</code> object kept inside a <code>ViewModel</code> class and consumed from an <code>Activity</code> component.</p>
			<p>Inside <code>ViewModel</code>, we instantiated a <code>MutableLiveData</code> object that will hold values of type <code>Int</code>, passed an initial value of <code>0</code>, and then in the <code>init{}</code> block launched a coroutine, where we've set the value to <code>100</code> after a <code>5000</code>-millisecond delay:</p>
			<pre>class MyViewModel(): ViewModel() {
    val numberLiveData: MutableLiveData&lt;Int&gt; = 
        MutableLiveData(0)
    init {
        viewModelScope.launch {
            delay(5000)
            numberLiveData.value = 100
        }
    }
}</pre>
			<p><code>numberLiveData</code> is now a data holder that will first notify any components observing it of the value <code>0</code> and, after 5 seconds, the value <code>100</code>.</p>
			<p>Now, an  <code>Activity</code> can <a id="_idIndexMarker1070"/>be observing these values by first obtaining an instance of <code>MyViewModel</code>, tapping into its <code>numberLiveData</code> object, and then starting to observe the changes<a id="_idIndexMarker1071"/> through the <code>observe()</code> method:</p>
			<pre>class MyActivity: ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val vm = 
          ViewModelProvider(this)[MyViewModel::class.java]
<strong class="bold">        vm.numberLiveData.observe(this, object: Observer&lt;Int&gt; {</strong>
<strong class="bold">            override fun onChanged(t: Int?) {</strong>
<strong class="bold">                // Consume values</strong>
<strong class="bold">            }</strong>
<strong class="bold">        })</strong>
    }
}</pre>
			<p>Now, to the <code>observe()</code> method, we've passed the following:</p>
			<ul>
				<li>First, the <code>this</code> instance of the <code>MyActivity</code> class to the <code>owner</code> parameter that expected a <code>LifecycleOwner</code> object. This worked because <code>MyActivity</code> indirectly implements (through <code>ComponentActivity</code>) the <code>LifecycleOwner</code> interface and therefore owns a <code>Lifecycle</code> object. The <code>observe()</code> method expected a <code>LifecycleOwner</code> as its first parameter, so that the observing feature is lifecycle-aware of the lifecycle of <code>MainActivity</code>.</li>
				<li>An <code>Observer&lt;Int&gt;</code> Kotlin inner <code>object</code> that allows us to receive the data events (holding the <code>Int</code> values) from the <code>MutableLiveData</code> object inside the <code>onChanged()</code> callback. Each time a new value is propagated, this callback will be triggered, and we will receive the latest value.</li>
			</ul>
			<p>Now that<a id="_idIndexMarker1072"/> we <a id="_idIndexMarker1073"/>have briefly covered how to use <code>LiveData</code>, let's better understand the whole reason why we are talking about <code>LiveData</code>. As we've mentioned, <code>LiveData</code> is a lifecycle-aware component, but how does it achieve that?</p>
			<p>When we passed our <code>MainActivity</code> as <code>LifecycleOwner</code> to the <code>owner</code> parameter of the <code>observe()</code> method, behind the scenes, <code>LiveData</code> started an observing process dependent on the <code>Lifecycle</code> object of the provided <code>owner</code>.</p>
			<p>More precisely, the <code>Observer</code> object provided as the second parameter to the <code>observe()</code> method will only receive updates if the owner – that is, <code>MainActivity</code> – is in the <code>STARTED</code> or <code>RESUMED</code> lifecycle state. </p>
			<p><em class="italic">This behavior is essential, as it allows Activity components to only receive UI updates from ViewModel components when they are visible or in focus</em>, therefore making sure that the UI can safely handle the data events and not waste resources.</p>
			<p>If, however, updates would have occurred in other states when the UI would not have been initialized, our app could have misbehaved or, even worse, crashed or introduced memory leaks. To be sure that such behavior doesn't occur, if the owner moves to the <code>DESTROYED</code> state, the <code>Observer</code> object will be automatically removed.</p>
			<p>In the following diagram, you will be able to visualize how <code>LiveData</code> updates only come when the <code>Activity</code> component is in the <code>RESUMED</code> or <code>STARTED</code> state, while also automatically removing the <code>Observer</code> object when the state becomes <code>DESTROYED</code>:</p>
			<div><div><img src="img/B17788_12_06.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6 – Lifecycle states and events when LiveData updates are received and the LiveData Observer is removed</p>
			<p>With such <a id="_idIndexMarker1074"/>behavior, <code>LiveData</code> becomes a lifecycle-aware component in the sense that any <code>LifecycleOwner</code> must be in an active lifecycle state to be receiving updates from it.</p>
			<p>Now that we <a id="_idIndexMarker1075"/>have covered the two predefined lifecycle-aware components (<code>ViewModel</code> and <code>LiveData</code>) that are part of the <code>Lifecycle</code> package, it's time to add a countdown timer component in our Repositories app so that later on, we can transform it into a custom lifecycle-aware component with the help of the Lifecycle APIs.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor335"/>Adding a countdown component in the Repositories app</h1>
			<p>Our plan is to learn how<a id="_idIndexMarker1076"/> to create our own lifecycle-aware component. However, before we can do that, we must first create a normal component that, by default, is not aware of the lifecycle of any Android component.</p>
			<p>To do that, we<a id="_idIndexMarker1077"/> can create a countdown timer component inside our Repositories app that will track whether the user has spent at least 60 seconds on the app, and if so, we will award the user with a fictional prize.</p>
			<p>More precisely, our plan is to create a countdown timer widget inside the <code>RepositoriesScreen()</code> that will award the user with a prize upon a 60-second countdown. However, for the countdown to work and the prize to be awarde<a id="_idTextAnchor336"/>d, the user must be inside <code>RepositoriesScreen()</code> and have the countdown composable visible.</p>
			<p>The countdown will behave like so:</p>
			<ul>
				<li>It will start from 60 and finish when the countdown reaches 0. Upon every second, the timer will decrease by 1 unit.</li>
				<li>When the countdown has finished, a prize message will be displayed.</li>
				<li>It will be paused if the countdown composable is not visible. In other words, if the user is not inside the <code>RepositoriesScreen()</code> composable or the timer composable is not visible or hidden within <code>RepositoriesScreen()</code>, then the countdown should be paused.</li>
			</ul>
			<p>Now that we have a plan, let's implement a countdown timer component:</p>
			<ol>
				<li value="1">Inside the root package, create a new class called <code>CustomCountdown</code> and define its constructor to feature two function parameters that will be called as the countd<a id="_idTextAnchor337"/>own timer functions:<pre>class CustomCountdown(
    private val onTick: ((currentValue: Int) -&gt; Unit),
    private val o<a id="_idTextAnchor338"/>nFinish: (() -&gt; Unit),
) {
}</pre></li>
			</ol>
			<p>We will have to call the <code>onTick()</code> function after every second has passed and the <code>onFinish()</code> function when the countdown has ended.</p>
			<ol>
				<li value="2">Now, inside<a id="_idIndexMarker1078"/> the <code>CustomCountdown</code> class, let's create an inner class called <code>InternalTimer</code> that will inherit <a id="_idIndexMarker1079"/>from the built-in Android <code>android.os.CountDownTimer</code> class and handle the actual countdown sequence:<pre>class CustomCountdown(
    private val onTick: ((currentValue: Int) -&gt; Unit),
    private val onF<a id="_idTextAnchor339"/>inish: (() -&gt; Unit),
) {
<strong class="bold">    class InternalTimer(</strong>
<strong class="bold">        private val onTick: ((currentValue: Int) -&gt; Unit),</strong>
<strong class="bold">        private val onFinish: (() -&gt; Unit),</strong>
<strong class="bold">        millisInFuture: Long,</strong>
<strong class="bold">        countDownInterval: Long</strong>
<strong class="bold">    ) : CountDownTimer(millisInFuture, </strong>
<strong class="bold">                       count<a id="_idTextAnchor340"/>DownInterval){</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>While the constructor of <code>InternalTimer</code> also accepts two identical function parameters, as <code>CustomCountdown</code> does, it's essential to note its <code>millisInFuture</code> and <code>countDownInterval</code> parameters that it forwards to the built-in Android <code>CountDownTimer</code> class. These two parameters will configure the core functionality of the timer – the countdown starting point in time and the time period that passes between timer ticks.</p>
			<ol>
				<li value="3">Next up, let's<a id="_idIndexMarker1080"/> finish the implementation <a id="_idIndexMarker1081"/>of the <code>InternalTimer</code> class: <pre>class CustomCountdown(
    private val onTick: ((currentValue: Int) -&gt; Unit),
    private val onFinish: (() -&gt; Unit),
) {
    class InternalTimer(
        private val onTick: ((currentValue: Int) -&gt; Unit),
        private val onFinish: (() -&gt; Unit),
        millisInFuture: Long,
        countDownInterval: Long
    ) : CountDownTimer(millisInFuture, 
        countDownInterval) {
<strong class="bold">        init {</strong>
<strong class="bold">            this.start()</strong>
<strong class="bold">        }</strong>
<strong class="bold">        override fun onFinish() {</strong>
<strong class="bold">            onFinish.invoke()</strong>
<strong class="bold">        }</strong>
<strong class="bold">        override fun onTick(millisUntilFinished: Long) {</strong>
<strong class="bold">            onTick(millis<a id="_idTextAnchor341"/>UntilFinished.toInt())</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>To make sure the timer works as expected, we have done the following:</p>
			<ul>
				<li>Called the <code>start()</code> method provided by the inherited parent, <code>CountDownTimer</code>, inside the <code>init{}</code> block. This should automatically start the timer upon inception.</li>
				<li>Implemented <a id="_idIndexMarker1082"/>the two <a id="_idIndexMarker1083"/>mandatory <code>onFinish()</code> and <code>onTick()</code> methods of the inherited parent, <code>CountDownTimer</code>, and propagated the events to the caller of <code>InternalTimer</code> by calling its <code>onFinish()</code> and <code>onTick()</code> function parameters.</li>
			</ul>
			<ol>
				<li value="4">Then, back in the <code>CustomCountdown</code> class, let's create an instance of <code>InternalTimer</code> and configure it to work like a 60-second countdown timer that starts from <code>60</code> and finishes at <code>0</code>.</li>
			</ol>
			<p>To do that, let's pass to its constructor not only the <code>onFinish</code> and <code>onTick</code> function parameters but also 60 seconds (as <code>60000</code> milliseconds) to the <code>millisInFuture</code> parameter and 1 second (as <code>1000</code> milliseconds) to the <code>countDownInterval</code> parameter:</p>
			<pre>class CustomCountdown(
    private val onTick: ((currentValue: Int) -&gt; Unit),
    private val<a id="_idTextAnchor342"/> onFinish: (() -&gt; Unit),
) {
<strong class="bold">    var timer: InternalTimer = InternalTimer(</strong>
<strong class="bold">        onTick = onTick,</strong>
<strong class="bold">        onFinish = onFinish,</strong>
<strong class="bold">        millisInFuture = 60000,</strong>
<strong class="bold">        countDownInterval = 1000)</strong>
    class InternalTimer(
        private val onTick: ((currentValue: Int) -&gt; Unit),
        private val onFinish: (() -&gt; Unit),
        millisInFuture: Long,
        countDownInterval: Long
    ): CountDownTimer(millisInFuture, countDownInterval)
    { … }
}</pre>
			<ol>
				<li value="5">Still<a id="_idIndexMarker1084"/> inside <code>CustomCountdown</code>, to <a id="_idIndexMarker1085"/>provide a way for canceling the countdown, add a <code>stop()</code> method that will allow us to call the <code>cancel()</code> method inherited by <code>InternalTimer</code> from the Android <code>CountDownTimer</code> class:<pre>class CustomCountdown(…) {
    var timer: InternalTimer = InternalTimer(…)
<strong class="bold">    fun s<a id="_idTextAnchor343"/>top() {</strong>
<strong class="bold">        timer.cancel()</strong>
<strong class="bold">    }</strong>
    class InternalTimer(
        […]
    ): CountDownTimer(millisInFuture, c<a id="_idTextAnchor344"/>ountDownInterval)
    { … }
}</pre></li>
				<li>Then, in <code>RepositoriesViewModel</code>, add not only a <code>timerState</code> variable that will hold<a id="_idIndexMarker1086"/> the text state displayed <a id="_idIndexMarker1087"/>by our countdown composable but also a <code>timer</code> variable that will hold a <code>CustomCountdown</code> object:<pre>class RepositoriesViewModel(…) : ViewModel() {
    val repositories: Fl<a id="_idTextAnchor345"/>ow&lt;PagingData&lt;Repository&gt;&gt; = […]
<strong class="bold">    val timerState = mutableStateOf("")</strong>
<strong class="bold">    var timer: CustomCountdown = CustomCountdown(</strong>
<strong class="bold">        onTick = { msLeft -&gt;</strong>
<strong class="bold">            timerState.value =</strong>
<strong class="bold">               (msLeft / 1000).toString() + </strong>
<strong class="bold">                   " seconds left"</strong>
<strong class="bold">        },</strong>
<strong class="bold">        onFinish = {</strong>
<strong class="bold">            timerState.value = "You won a prize!"</strong>
<strong class="bold">        })</strong>
}</pre></li>
			</ol>
			<p>Inside the <code>onTick</code> callback, we are computing the remaining seconds and setting a <code>String</code> message about our countdown to <code>timerState</code>. Then, in the <code>onFinish</code> callback, we're setting a prize message to <code>timerState</code>.</p>
			<ol>
				<li value="7">As a good practice, inside <code>RepositoriesViewModel</code>, make sure to stop the timer inside the <code>onCleared()</code> callback if the user moves to a different screen. This <a id="_idIndexMarker1088"/>would mean that <code>RepositoriesScreen()</code> wouldn't be composed anymore, so this <code>ViewModel</code> would be cleared and the countdown should be stopped so that it doesn't send events and waste resources:<pre>class RepositoriesViewModel(…) : ViewModel() {
    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; = […]
    val timerState = mutableStateOf("")
    var timer: CustomCountdown = CustomCountdown(…)
<strong class="bold">    override fun onCleared() {</strong>
<strong class="bold">        super<a id="_idTextAnchor346"/>.onCleared()</strong>
<strong class="bold">        timer.stop()</strong>
<strong class="bold">    }</strong>
}</pre></li>
				<li>Now, move to <code>MainActivity</code> and make sure that just as the repositories are consumed <a id="_idIndexMarker1089"/>and passed to the <code>RepositoriesScreen()</code> composable, the countdown timer text produced by <code>ViewModel</code> is also consumed and passed to <code>RepositoriesScreen()</code>:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                val viewModel: RepositoriesViewModel = …
                val reposFlow = <a id="_idTextAnchor347"/>viewModel.repositories
<strong class="bold">                val timerText = </strong>
<strong class="bold">                    viewModel.timerState.value</strong>
                val lazyRepoItems: […] = […]
                RepositoriesScreen(
                    lazyRepoItems,
                    <strong class="bold">timerText</strong>
                )
            }
        }
    }
}</pre></li>
				<li>Then, at <a id="_idIndexMarker1090"/>the end of the <code>RepositoriesScreen.kt</code> file, create a simple <code>CountdownItem()</code> composable function that takes in a <code>timerText: String</code> parameter and sets its value to a <code>Text</code> composable:<pre>@Composable
private fun CountdownItem(t<a id="_idTextAnchor348"/>imerText: String) {
    Text(timerText)
}</pre></li>
				<li>Next, in the <code>RepositoriesScreen()</code> composable, add a new parameter for the <a id="_idIndexMarker1091"/>countdown text called <code>timerText</code>, and inside the <code>LazyColumn</code> scope, before the <code>itemsIndexed()</code> call, add a singular <code>item()</code> <code>CountdownItem()</code> composable while passing the <code>timerText</code> variable to it:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;,
    <strong class="bold">timerText: String</strong>
) {
    LazyColumn(…) {
        <strong class="bold">item {</strong>
<strong class="bold">            CountdownItem(timerText)</strong>
<strong class="bold">        }</strong>
        itemsIndexed(repos) { index, repo -&gt; […] }
        […]
    }
}</pre></li>
			</ol>
			<p>By <a id="_idIndexMarker1093"/>doing so, we make sure that the countdown timer is displayed at the top of the screen as the first item within the list of repositories.</p>
			<ol>
				<li value="11">Build <a id="_idIndexMarker1094"/>and run the application. You should first see the countdown timer telling you how much time you need to wait, and after approximately 1 minute, you should see the prize message displayed:</li>
			</ol>
			<div><div><img src="img/B17788_12_07.jpg" alt="Figure 12.7 – Observing how the countdown timer works&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7 – Observing how the countdown timer works</p>
			<p>We have <a id="_idIndexMarker1095"/>now finished incorporating the<a id="_idIndexMarker1096"/> countdown timer that ends by awarding the user with a fictional prize.</p>
			<p>However, there is a scenario where our timer doesn't work as expected. Let's identify it:</p>
			<ol>
				<li value="1">Restart the application. You can do that by closing the current instance of the app and reopening it.</li>
			</ol>
			<p>The countdown should have started from 60 again at this point.</p>
			<ol>
				<li value="2">Before the countdown finishes, remember or write down somewhere the current countdown value and then put the app in background.</li>
				<li>Wait for a few seconds and then bring the app back to the foreground.</li>
			</ol>
			<p>You should notice that while the app was in the background, the countdown kept going. We wanted the timer to be paused when the app was put in the background and then resumed when the app was brought back to the foreground – this would have allowed us to award the prize to users that actively use the app and have the countdown timer visible. This behavior didn't occur, as the timer kept on counting while the app was not visible or in focus.</p>
			<p>This is happening because we didn't do anything to pause the timer when the app goes into <a id="_idIndexMarker1097"/>the background or resume it when the<a id="_idIndexMarker1098"/> app comes back to the foreground. In other words, our countdown timer is not lifecycle-aware, so it doesn't get notified and can't react to the lifecycle events of the <code>Activity</code> host.</p>
			<p>Next, let's make our countdown timer a lifecycle-aware component.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor349"/>Creating your own lifecycle-aware component</h1>
			<p>We need<a id="_idIndexMarker1099"/> to make our <code>CustomCountdown</code> aware of the lifecycle of <code>MainActivity</code>. In other words, our countdown logic should observe and react to the lifecycle events of our <code>LifecycleOwner</code> – that is, <code>MainActivity</code>. </p>
			<p>To make our <code>CustomCountdown</code> lifecycle-aware, we must force it to implement the <code>DefaultLifecycleObserver</code> interface. By doing so, the <code>CustomCountdown</code> will be observing the lifecycle events or states defined by the <code>Lifecycle</code> object that <code>LifecycleOwner</code> provides.</p>
			<p>Our main goal is to pause the countdown when the app is put in the background and to resume it when the app is brought back into the foreground. More precisely, our <code>CustomCountdown</code> must react to the following lifecycle events of <code>MainActivity</code>:</p>
			<ul>
				<li><code>onPause()</code>: When the <code>onPause()</code> callback comes in <code>MainActivity</code>, <code>CustomCountdown</code> must pause its countdown.</li>
				<li><code>onResume()</code>: When the <code>onResume()</code> callback comes in <code>MainActivity</code>, <code>CustomCountdown</code> must resume its countdown.</li>
			</ul>
			<p>With this behavior, we can award the prize to users that actively use the app and have the countdown timer visible and in focus.</p>
			<p>Now that we have a plan, let's start coding.</p>
			<ol>
				<li value="1">Make the <code>CustomCountdown</code> class implement the <code>DefaultLifecycleObserver</code> interface and then override the two lifecycle callbacks we're interested in, <code>onResume()<a id="_idTextAnchor350"/></code> and <code>onPause()</code>:<pre>class CustomCountdown(
    […]
): <strong class="bold">DefaultLifecycleObserver</strong> {
    var timer: InternalTimer = InternalTimer(
        onTick = onTick,
        onFinish = onFinish,
        millisInFuture = 60000,
        countDownInterval = 1000)
<strong class="bold">    override fun onResume(owner: LifecycleOwner) {</strong>
<strong class="bold">        super.onResume(owner)</strong>
<strong class="bold">    }</strong>
<strong class="bold">    override fun onPause(owner: Lif<a id="_idTextAnchor351"/>ecycleOwner) {</strong>
<strong class="bold">        super.onPause(owner)</strong>
<strong class="bold">    }</strong>
    fun stop() { timer.cancel() }
    class InternalTimer(…) {…}
}</pre></li>
			</ol>
			<p>Once <a id="_idIndexMarker1100"/>we make our <code>CustomCountdown</code> observe the lifecycle of <code>MainActivity</code>, its <code>onResume(owner: LifecycleOwner)</code> callback will be called when the <code>onResume()</code> callback of <code>MainActivity</code> is called, and similarly, its <code>onPause(owner: LifecycleOwner)</code> callback will be called when the <code>onPause()</code> callback of <code>MainActivity</code> is called.</p>
			<ol>
				<li value="2">Now that we know when to pause and resume our countdown timer, we need to find ways to actually pause and resume it.</li>
			</ol>
			<p>First, let's pause the countdown in the <code>onPause()</code> callback by calling the <code>cancel()</code> method of the <code>timer</code> variable:</p>
			<pre>class CustomCountdown(
    […]
): DefaultLifecycleObserver {
    var timer: InternalTimer = InternalTimer(…)
    override fun onResume(owner: LifecycleOwner) {
        super.onResume(owner)
    }
    override fun onPause(owner: Lifecy<a id="_idTextAnchor352"/>cleOwner) {
        super.onPause(owner)
<strong class="bold">        timer.cancel()</strong>
    }
    fun stop() { timer.cancel() }
    class InternalTimer(…) : CountDownTimer(…) {…}
}</pre>
			<p>With<a id="_idIndexMarker1101"/> this behavior, when <code>MainActivity</code> is paused, we are stopping the countdown run by the <code>InternalTime</code> instance held inside the <code>timer</code> variable.</p>
			<ol>
				<li value="3">Next up, we need to resume the <code>timer</code> in the <code>onResume()</code> callback. However, to resume it, we need to know the value of the last countdown before the <code>onPause()</code> callback was triggered and the timer was canceled. With that last known countdown value, we can reinitiate our timer in the <code>onResume()</code> callback.</li>
			</ol>
			<p>Inside the inner <code>InternalTimer</code> class, create a <code>lastKnownTime</code> variable, initiate it with the value of <code>millisInFuture</code>, and then make sure to update it in the <code>onFinish()</code> and <code>onTick()</code> timer callbacks:</p>
			<pre>class CustomCountdown(
    […]
): DefaultLifecycleObserver {
    var timer: InternalTimer = InternalTimer(
        […]
        millisInFuture = 60000,
        countDownInterval = 1000)
    override fun onResume(owner: LifecycleOwner) { … }
    override fun onPause(owner: LifecycleOwner) { … }
    fun stop() { timer.cancel() }
    cla<a id="_idTextAnchor353"/>ss InternalTimer(…) : CountDownTimer(…) {
<strong class="bold">        var lastKnownTime: Long = millisInFuture</strong>
        init { this.start(<a id="_idTextAnchor354"/>) }
        override fun onFinish() {
<strong class="bold">            lastKnownTime = 0</strong>
            onFinish.invoke()
        }
        override fu<a id="_idTextAnchor355"/>n onTick(millisUntilFinished: Long) {
<strong class="bold">            lastKnownTime = millisUntilFinished</strong>
            onTick(millisUntilFinished.toInt())
        }
    }
}</pre>
			<p>While in the <code>onFinish()</code> callback, we've set <code>lastKnownTime</code> to <code>0</code> because the countdown has finished, in the <code>onTick()</code> callback, we've made sure to save inside the <code>lastKnownTime</code> variable the latest value received from the <code>onTick()</code> callback – that is, <code>millisUntilFinished</code>.</p>
			<ol>
				<li value="4">Now, going<a id="_idIndexMarker1102"/> back in the parent <code>CustomCountdown</code> class, resume the countdown in the <code>onResume()</code> callback of <code>CustomCountdown</code> by first canceling the countdown of the previous timer and then by storing inside the <code>timer</code> variable another instance of <code>InternalTimer</code>, which now starts the countdown from the <code>lastKnownTime</code> value of the previous <code>InternalTimer</code> instance:<pre>class CustomCountdown(
    […]
): DefaultLifecycleObserver {
    var timer: InternalTimer = InternalTimer(
        onTick = onTick,
        onFinish = onFinish,
        millisInFuture = 60000,
        countDownInterval = 1000)
    override fun onResume(owner: LifecycleOwner) {
        super.onResume(owner)
<strong class="bold">        if (timer.lastKnownTime &gt; 0) {</strong>
<strong class="bold">            timer.cancel()</strong>
<strong class="bold">            timer = InternalTimer(</strong>
<strong class="bold">                onTick = onTick,</strong>
<strong class="bold">                onFinish = onFinish,</strong>
<strong class="bold">                millisInFuture = timer.lastKnownTime,<a id="_idTextAnchor356"/></strong>
<strong class="bold">                countDownInterval = 1000)</strong>
<strong class="bold">        }</strong>
    }
    override fun onPause(owner: LifecycleOwner) { […] }
    fun stop() { timer.cancel() }
    class InternalTimer(…) : CountDownTimer(…) {…}
}</pre></li>
			</ol>
			<p>With<a id="_idIndexMarker1103"/> this behavior, when <code>MainActivity</code> is resumed, we are creating a new <code>InternalTimer</code> instance that starts off the countdown from the value that the previous timer recorded before being paused. Also, note that the new instance of <code>InternalTimer</code> receives the same parameters as the first initialization of the <code>timer</code> variable – the same <code>onTick()</code> and <code>onFinish()</code> callbacks and the same <code>countDownInterval</code> – the only difference is the starting point of the countdown, which should now be less than 60 seconds.</p>
			<p>For the <code>onPause()</code> and <code>onResume()</code> callbacks of the <code>CustomCountdown</code> class to be called when their corresponding lifecycle events are called inside <code>MainActivity</code>, we must effectively bind our <code>DefaultLifecycleObserver</code> – that is, the <code>CustomCountdown</code> instance – to the lifecycle of our <code>LifecycleOwner</code> – that is, <code>MainActivity</code>.</p>
			<p>Let's do that next.</p>
			<ol>
				<li value="5">Go back in<a id="_idTextAnchor357"/>side the <code>RepositoriesScreen.kt</code> file, and inside the <code>CountdownItem()</code> composable, first obtain the <code>LifecycleOwner</code> instance that the composable function belongs to by tapping into the <code>LocalLifeCycleOwner</code> API and then get the owner by accessing its <code>current</code> variable:<pre>@Composable
<a id="_idTextAnchor358"/>private fun CountdownItem (timerText: String) {
<strong class="bold">    val lifecycleOwner: LifecycleOwner  = </strong>
<strong class="bold">        LocalLifecycleOwner.current</strong>
    Text(timerText)
}</pre></li>
			</ol>
			<p>Finally, we've stored the <code>LifecycleOwner</code> instance into the <code>lifecycleOwner</code> variable.</p>
			<p>It's<a id="_idIndexMarker1104"/> important to mention that since the parent composable of <code>CountdownItem()</code> – that is, <code>RepositoriesScreen()</code> – is hosted by <code>MainActivity</code>, it's only natural that the <code>LifecycleOwner</code> instance that we have obtained is in fact <code>MainActivity</code>.</p>
			<ol>
				<li value="6">Then, we need to make sure that the <code>Lifecycle</code> instance of our <code>lifecycleOwner</code> adds and removes our <code>DefaultLifecycleObserver</code> timer.</li>
			</ol>
			<p>To achieve that, we need to first create a composition side effect that allows us to know when the <code>CountdownItem()</code> composable first entered composition so that we can add the observer, and then when it was removed from composition so that we can remove the observer.</p>
			<p>For such a case, we can use the <code>DisposableEffect()</code> composable, which provides us with a block of code where we can perform actions when the composable enters composition, and then perform other actions when the composable leaves composition through its inner <code>onDispose()</code> block:</p>
			<pre>@Composable
private fun CountdownItem (timerText: String) {
    val lifecycleOwner: LifecycleOwner = 
        LocalLifecycleOwner.current
<strong class="bold">    DisposableEffect(key1 = lifecycleOwn<a id="_idTextAnchor359"/>er) {</strong>
<strong class="bold">        onDispose {</strong>
            
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    Text(timerText)
}</pre>
			<p>Since <a id="_idIndexMarker1105"/>this is a side effect, anything we add inside the block of code exposed by the <code>DisposableEffect</code> function will not be re-executed upon recomposition. However, this effect will be restarted if the value provided to the <code>key1</code> parameter changes. In our case, we want this effect to be restarted if the value of <code>lifecycleOwner</code> changes - this will allow us to have access to the correct <code>lifecycleOwner</code> instance inside this side-effect composable.</p>
			<ol>
				<li value="7">Now that we know when and where we can add and then remove the observer, let's first obtain the <code>Lifecycle</code> object from the <code>lifecycleOwner</code> variable so that we can store it inside the <code>lifecycle</code> variable:<pre>@Composable
private fun CountdownItem(timerText: String) {
    val lifecycleOwner: Life<a id="_idTextAnchor360"/>cycleOwner = 
        LocalLifecycleOwner.current
<strong class="bold">    val lifecycle = lifecycleOwner.lifecycle</strong>
    DisposableEffect(key1 = lifecycleOwner) {
        onDispose {
        
        }
    }
    Text(timerText)
}</pre></li>
			</ol>
			<p>Next, on the <code>Lifecycle</code> object from within the <code>lifecycle</code> variable, we will add and remove the observer.</p>
			<ol>
				<li value="8">Inside the<a id="_idIndexMarker1106"/> block of code exposed by the <code>DisposableEffect()</code> composable, add the observer on the <code>lifecycle</code> variable by calling its <code>addObserver()</code> method, and then inside its exposed <code>onDispose()</code> callback, remove it with the <code>removeObserver()</code> method:<pre>@Composable
private fun CountdownItem(timerText: String) {
    val lifecycleOwner: LifecycleOwner 
        = LocalLifecycleOwner.current
    val lifecycle = lifecycleOwner.lifecycle<a id="_idTextAnchor361"/>
    DisposableEffect(key1 = lifecycleOwner) {
<strong class="bold">        l<a id="_idTextAnchor362"/>ifecycle.addObserver()</strong>
        onDispose {
<strong class="bold">            lifecycle.removeObserver()</strong>
        }
    }
    Text(timerText)
}</pre></li>
			</ol>
			<p>With this approach, when the <code>CountdownItem()</code> composable is first composed, we will make our countdown component observe the lifecycle events of <code>MainActivity</code>. Then, when the <code>CountdownItem()</code> leaves composition, our countdown component will no longer observe such events.</p>
			<p>However, you might have noticed that both the <code>addObserver()</code> and <code>removeObserver()</code> methods expect a <code>LifecycleObserver</code> object, but we didn't provide any.</p>
			<p>In fact, we should have passed the <code>CustomCountdown</code> instance to the <code>addObserver()</code> and <code>removeObserver()</code> methods because <code>CustomCountdown</code> is the component that implements <code>DefaultLifecycleObserver</code> and that we want to react to the lifecycle changes of our <code>MainActivity</code>.</p>
			<p>Next, let's obtain the <code>CustomCountdown</code> instance.</p>
			<ol>
				<li value="9">Update<a id="_idIndexMarker1107"/> the <code>CountdownItem()</code> function definition to receive a <code>getTimer()</code> function parameter that returns a <code>CustomCountdown</code> timer. This callback method should be called to provide the <code>addObserver()</code> and <code>removeObserver()</code> methods with a <code>LifecycleObserver</code> instance:<pre>@Composable
private fun Coun<a id="_idTextAnchor363"/>tdownItem(timerText: String, 
    <strong class="bold">getTimer: () -&gt; CustomCountdown</strong>) {
    val lifecycleOwner: LifecycleOwner 
        = LocalLifecycleOwner.current
    val lifecycle = lifecycleOwner.lifecycle
    DisposableEffect(key1 = lifecycleOwner) {
        lifecycle.addObserver(<strong class="bold">getTimer())</strong>
        onDispose {
            lifecycle.removeObserver(<strong class="bold">getTimer())</strong>
        }
    }
    Text(timerText)
}</pre></li>
			</ol>
			<p>Since the <code>CustomCountdown</code> class implements <code>DefaultLifecycleObserver</code>, which extends <code>FullLifecycleObserver</code>, which in turn extends <code>LifecycleObserver</code>, the <code>addObserver()</code> and <code>removeObserver()</code> methods accept our <code>CustomCountdown</code> instance as an observer to the <code>Lifecycle</code> object of our <code>lifecycleOwner</code> – that is, <code>MainActivity</code>.</p>
			<ol>
				<li value="10">Since <code>CountdownItem()</code> now expects a <code>getTimer: ()-&gt; CustomCountdown</code> callback<a id="_idIndexMarker1108"/> function, we must also force our <code>RepositoriesScreen()</code> composable to accept such a callback function as well and then pass it to our <code>CountdownItem()</code> composable:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;,
    timerText: String,
    <strong class="bold">getTimer: () -&gt; CustomCountdown</strong>
) {
    LazyColumn(…) {
        item {
            CountdownItem(timerText, <strong class="bold">getTimer</strong>)
        }
        itemsIndexed(repos) { … }
        […]
    }
}</pre></li>
				<li>Lastly, inside <code>MainActivity</code>, update the <code>RepositoriesScreen()</code> composable<a id="_idIndexMarker1109"/> call to provide a <code>getTimer()</code> function implementation, where we will get the <code>CustomCountdown</code> instance from the <code>viewModel</code> variable through its <code>timer</code> field:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                […]
                RepositoriesScreen(
                    lazyRepoItems, 
                    timerText<strong class="bold">,</strong>
<strong class="bold">          <a id="_idTextAnchor364"/>          getTimer = {viewModel.timer}</strong>
                <strong class="bold">)</strong>
            }
        }
    }
}</pre></li>
			</ol>
			<p>We have finally tied our <code>DefaultLifecycleObserver</code> – that is, the <code>CustomCountdown</code> instance – to the lifecycle of our <code>LifecycleOwner</code> – that is, <code>MainActivity</code>. Now that the <code>CustomCountdown</code> class should react to the lifecycle events of our <code>MainActivity</code>, let's test our problematic scenario from before.</p>
			<ol>
				<li value="12">Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and put the app in background.</li>
				<li>Wait for a few seconds and then bring the app back to foreground.</li>
			</ol>
			<p>You <a id="_idIndexMarker1110"/>should now notice that while the app was in background, the countdown was paused. We wanted the timer to be paused when the app was put in background and then resumed when the app was brought back to foreground – and now this is happening! We can now award the prize to users that actively use the app.</p>
			<p>However, there is still an edge case that we haven't covered. Let's discover it:</p>
			<ol>
				<li value="1">Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and then quickly scroll down past four or five repositories within the list until the countdown is not visible anymore.</li>
				<li>Wait for a few seconds and then scroll back up to the top of the list so that the countdown is visible again.</li>
			</ol>
			<p>Note that after we scrolled down, while the timer wasn't visible, the countdown kept going. We wanted the timer to be paused when the timer isn't visible anymore and then resumed when the timer is visible again – this would have allowed us to award the prize to users that have the countdown timer visible so that they didn't cheat on our contest. This behavior didn't occur, as the timer kept on counting while the timer wasn't visible.</p>
			<p>This is happening because we didn't do anything to pause the timer when the timer composable leaves <a id="_idIndexMarker1111"/>composition or resume it when the timer composable is composed again. In other words, our countdown timer is not aware of the lifecycle of our timer composable.</p>
			<p>Next, let's make our countdown timer aware of Compose composition cycles so that users don't cheat in our contest.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor365"/>Making our countdown component aware of the lifecycle of composables</h1>
			<p>The main issue is that our <code>CustomCountdown</code> component still runs its countdown even after the <code>CountdownItem()</code> composable leaves composition. We want to pause the timer when its corresponding composable is not visible anymore. With such an approach, we<a id="_idIndexMarker1112"/> can prevent users from cheating, and we can award the prize only to users that have had the countdown timer visible for the full amount of time. Basically, if the timer is not visible anymore, the countdown should stop.</p>
			<p>To pause the timer when its corresponding composable function leaves composition, we must somehow call the <code>stop()</code> function exposed by <code>CustomCountdown</code>. But when should we do that?</p>
			<p>If you look inside the body of the <code>CountdownItem()</code> composable, you will notice that we have already registered a <code>DisposableEffect()</code> composable that notifies us when the <code>CountdownItem()</code> composable leaves composition by exposing the <code>onDispose()</code> callback:</p>
			<pre>@Composable
private fun CountdownItem(…) {
    val lifecycleOwner: […] = LocalLifecycleOwner.current
    val lifecycle = lifecycleOwner.lifecycle
    DisposableEffect(key1 = lifecycleOwner) {
        lifecycle.addObserver(getTimer())
<strong class="bold">        onDispose {</strong>
            lifecycle.removeObserver(getTimer())
<strong class="bold">        }</strong>
    }
    Text(timerText)
}</pre>
			<p>When the <a id="_idIndexMarker1113"/>composable leaves composition, inside the <code>onDispose()</code> callback, we are already removing the <code>CustomCountdown</code> as an observer to the lifecycle of our <code>MainActivity</code>. Exactly at this point, we can also pause the timer because the composable leaves composition:</p>
			<ol>
				<li value="1">Update the <code>CountdownItem()</code> function definition to accept a new <code>onPauseTimer()</code> callback function and then make sure to call it inside the <code>onDispose()</code> callback of <code>DisposableEffect()</code>:<pre>@Composable
private fun CountdownItem(timerText: String,
    getTimer: () -&gt; CustomCountdown,
    <strong class="bold">onPauseTimer: () -&gt; Unit</strong>) {
    val lifecycleOwner: […] = LocalLifecycleOwner.current
    val lifecycle = lifecycleOwner.lifecycle
    DisposableEffect(key1 = lifecycleOwner) {
        life<a id="_idTextAnchor366"/>cycle.addObserver(getTimer())
        onDispose {
<strong class="bold">            onPauseTimer()</strong>
            lifecycle.removeObserver(getTimer())
        }
    }
    Text(timerText)
}</pre></li>
				<li>Since <code>CountdownItem()</code> now expects an <code>onPauseTimer: () -&gt; Unit</code> callback function, we must also force our <code>RepositoriesScreen()</code> composable to <a id="_idIndexMarker1114"/>accept such a callback function and then pass it to our <code>CountdownItem()</code> composable:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;,
    timerText: String,
    getTimer: () -&gt; CustomCountdown,
    <strong class="bold">onPauseTimer: () -&gt; Unit</strong>
) {
    LazyColumn(…) {
        item {
            CountdownItem(
                timerText, 
                getTimer,
                <strong class="bold">onPauseTimer</strong>
            )
        }
        itemsIndexed(repos) { … }
        […]
    }
}</pre></li>
				<li>Lastly, inside <code>MainActivity</code>, update the <code>RepositoriesScreen()</code> composable call to provide an <code>onPauseTimer()</code> function implementation, where we will pause<a id="_idIndexMarker1115"/> the timer by calling the <code>stop()</code> method of the <code>CustomCountdown</code> instance obtained from the <code>viewModel</code> variable through its <code>timer</code> field:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                […]
                RepositoriesScreen(lazyRepoItems, 
                    timerText,
        <a id="_idTextAnchor367"/>            getTimer = { viewModel.timer }<strong class="bold">,</strong>
<strong class="bold">                    onPauseTimer = </strong>
<strong class="bold">                        { viewModel.timer.stop() }</strong>
<strong class="bold">                )</strong>
            }
        }
    }
}</pre></li>
				<li>Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and then quickly scroll down past four or five repositories within the list until the countdown is not visible anymore. Make sure to scroll past a few repositories so that Compose removes the node of the timer composable – if you scroll just a bit, the node of the timer won't be removed.</li>
				<li>Wait for a<a id="_idIndexMarker1116"/> few seconds and then scroll back up to the top of the list so that the countdown is visible again.</li>
			</ol>
			<p>Note that the timer was now paused while the <code>CountdownItem()</code> composable was not visible. We have now achieved the desired effect!</p>
			<p>But how come the countdown is resumed when the composable becomes visible again? We didn't do anything to cover that case – we only stopped the timer when the <code>CountdownItem()</code> composable left composition, but we didn't resume it when it became visible again as it re-entered composition.</p>
			<p>Fortunately, the timer is resumed out of the box when the <code>CountdownItem()</code> composable re-enters composition – but why is this happening?</p>
			<p>This behavior is exhibited because of an interesting side effect provided by the Lifecycle APIs. More precisely, as soon as we're binding the <code>LifecycleObserver</code> instance to the <code>Lifecycle</code> instance of our <code>LifecycleOwner</code>, the observer instantly receives as a first event the event corresponding to the current state of <code>LifecycleOwner</code>.</p>
			<p>Let's have a look inside the <code>CountdownItem()</code> composable and see how this could be happening:</p>
			<pre>@Composable
private fun CountdownItem(timerText: String,
    getTimer: () -&gt; CustomCountdown,
    onPauseTimer: () -&gt; Unit) {
    val lifecycleOwner: LifecycleOwner
                = LocalLifecycleOwner.current
    val lifecycle = lifecycleOwner.lifecycle
    DisposableEffect(key1 = lifecycleOwner) {
<strong class="bold">        lifecycle.addObserver(getTimer())</strong>
        onDispose {
            onPauseTimer()
            lifecycle.removeObserver(getTimer())
        }
    }
    Text(timerText)
}</pre>
			<p>In our case, as soon as we're binding the <code>DefaultLifecycleObserver</code> instance – that is, <code>CustomCountdown</code> – to the <code>Lifecycle</code> of the <code>LifecycleOwner</code> instance – that is, <code>MainActivity</code> – the observer receives as a first event the event corresponding to the current state.</p>
			<p>In other <a id="_idIndexMarker1117"/>words, as soon as our timer composable is visible, we're adding the timer as an observer to the lifecycle of our <code>MainActivity</code> class. At that point, the <code>RESUMED</code> state is the current state of <code>MainActivity</code>, so the <code>onResume()</code> callback is triggered inside the <code>CustomCountdown</code> component, which effectively resumes the timer countdown in our specific scenario:</p>
			<pre>class CustomCountdown([…]): DefaultLifecycleObserver {
    var timer: InternalTimer = InternalTimer(…)
<strong class="bold">    override fun onResume(owner: LifecycleOwner) {</strong>
<strong class="bold">        super.onResume(owner)</strong>
<strong class="bold">        if (timer.lastKnownTime &gt; 0) {</strong>
<strong class="bold">            timer.cancel()</strong>
<strong class="bold">            timer = InternalTimer(</strong>
<strong class="bold">                onTick = onTick,</strong>
<strong class="bold">                onFinish = onFinish,</strong>
<strong class="bold">                millisInFuture = timer.lastKnownTime,</strong>
<strong class="bold">                countDownInterval = 1000)</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    override fun onPause(owner: LifecycleOwner) { […] }
    fun stop() { timer.cancel() }
    class InternalTimer(…) : CountDownTimer(…) {…}
}</pre>
			<p>We have now <a id="_idIndexMarker1118"/>made our countdown timer aware of the Compose composition cycles as well.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor368"/>Summary</h1>
			<p>In this chapter, we understood what a lifecycle-aware component is and how we can create one.</p>
			<p>We first explored how the lifecycle events and states are tied to Android components, such as <code>Activity</code> or <code>Fragment</code>, and then how predefined components from the <code>Lifecycle</code> package can react to them. Then, we created and added a countdown timer component to the Repositories app.</p>
			<p>Finally, we prevented users from cheating by making our timer component aware not only of the different lifecycle events and states of <code>Activity</code> components but also of the lifecycle of composables.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor369"/>Further reading</h1>
			<p>In this chapter, we briefly covered how to create a lifecycle-aware component by making our <code>CustomCountdown</code> component aware of the lifecycle events that <code>MainActivity</code> exhibits. However, when needed, we can also tap into the lifecycle states of <code>LifecycleOwner</code>. To understand how you can do that, check out the official docs for an example: <a href="https://developer.android.com/topic/libraries/architecture/lifecycle#lco">https://developer.android.com/topic/libraries/architecture/lifecycle#lco</a>.</p>
		</div>
	</body></html>