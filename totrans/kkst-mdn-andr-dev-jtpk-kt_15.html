<html><head></head><body>
		<div id="_idContainer127">
			<h1 id="_idParaDest-154"><em class="italic"><a id="_idTextAnchor327"/>Chapter 12</em>: Exploring the Jetpack Lifecycle Components</h1>
			<p>In this chapter, we're adding a countdown timer component to our Repositories app from <a href="B17788_11_ePub.xhtml#_idTextAnchor317"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating Infinite Lists with Jetpack Paging and Kotlin Flow</em>, while also exploring the Jetpack Lifecycle components.</p>
			<p>In the first section, <em class="italic">Introducing the Jetpack Lifecycle components</em>, we want to explore how the lifecycle events and states are tied to Android components such as <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong>, and then how predefined components from the <strong class="source-inline">Lifecycle</strong> package can react to them.</p>
			<p>Next, in the <em class="italic">Adding a countdown component in the Repositories app</em> section, we will be creating and adding a countdown timer component to the Repositories app. When a 60-second countdown finishes, we will award users with a fictional prize.</p>
			<p>However, we will want the countdown to run as long as the timer is visible on the screen; otherwise, users could cheat by minimizing the application and having the countdown run in background. In the <em class="italic">Creating your own lifecycle-aware component</em> section, we will prevent users from cheating by making our timer component aware of the different lifecycle events and states that our Android components traverse.</p>
			<p>In the <em class="italic">Making our countdown component aware of the lifecycle of composables</em> section, we will realize that users can also cheat on the countdown contest by scrolling and hiding the timer countdown UI element. To prevent them from doing that, we will also make sure that our countdown component knows how to react to composition cycles that our Compose UI features.</p>
			<p>To summarize, in this chapter, we will be covering the following sections:</p>
			<ul>
				<li>Introducing the Jetpack Lifecycle components</li>
				<li>Adding a countdown component in the Repositories app</li>
				<li>Creating your own lifecycle-aware component</li>
				<li>Making our countdown component aware of the lifecycle of composables </li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor328"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along with this chapter smoothly, make sure that you also have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>A Kotlin 1.6.10 or newer plugin installed in Android Studio.</li>
				<li>The existing Repositories app from the GitHub repository of the book.</li>
			</ul>
			<p>The starting point for this chapter is represented by the Repositories app developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_11</strong> directory of the repository and importing the Android project entitled <strong class="source-inline">repositories_app_solution_ch11</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_12</strong> directory: <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12</a>.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor329"/>Introducing the Jetpack Lifecycle components</h1>
			<p>It's no <a id="_idIndexMarker1045"/>secret by now that components within the Android framework have certain lifecycles that we must respect when we need to interact with them. The<a id="_idIndexMarker1046"/> most common components that own a<a id="_idIndexMarker1047"/> lifecycle are <strong class="source-inline">Activity</strong> and <strong class="source-inline">Fragment</strong>.</p>
			<p>As programmers, we cannot control the lifecycle of Android components because their lifecycle is defined and controlled by the system or the way Android works.</p>
			<p>Going back to Lifecycle components, a very good example is the entry point to our Android application, represented by the <strong class="source-inline">Activity</strong> component, which, as we know, possesses a lifecycle. This means that in order to create a screen in our Android application, we need to create an <strong class="source-inline">Activity</strong> component – from this point on, all our components must be aware of its lifecycle to not leak any memory.</p>
			<p>Now, when<a id="_idIndexMarker1048"/> we say that <strong class="source-inline">Activity</strong> has a system-defined lifecycle, this actually translates into our <strong class="source-inline">Activity</strong> class inheriting from <strong class="source-inline">ComponentActivity()</strong>, which in turn contains a <strong class="source-inline">Lifecycle</strong> object. If we have a look at our <strong class="source-inline">MainActivity</strong> class from the Repositories app, we can see that it inherits from <strong class="source-inline">ComponentActivity()</strong>:</p>
			<p class="source-code">class MainActivity <strong class="bold">: ComponentActivity()</strong> {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        […]</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, if we dig into the source code of the <strong class="source-inline">ComponentActivity.java</strong> class, we can see that it implements the <strong class="source-inline">LifecycleOwner</strong> interface:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B17788_12_01.jpg" alt="Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner interface</p>
			<p>In other words, the <strong class="source-inline">ComponentActivity</strong> class is an owner of a lifecycle. If we check out the implementation of the <strong class="source-inline">LifecycleOwner</strong> interface a few hundreds of lines downward in the source code, we can see that the <strong class="source-inline">LifecycleOwner</strong> interface contains a single method called <strong class="source-inline">getLifecycle()</strong> that returns a <strong class="source-inline">Lifecycle</strong> object:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B17788_12_02.jpg" alt="Figure 12.2 – Observing the implementation of the LifecycleOwner interface method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2 – Observing the implementation of the LifecycleOwner interface method</p>
			<p>From these findings, we can deduct that our <strong class="source-inline">Activity</strong> classes have a system-defined lifecycle, as they implement the <strong class="source-inline">LifecycleOwner</strong> interface, which in turn means that they own a <strong class="source-inline">Lifecycle</strong> object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are several other components in Android that have a lifecycle. In the context of the <strong class="source-inline">Activity</strong> classes, there are other classes inheriting directly or indirectly from <strong class="source-inline">ComponentActivity</strong>, therefore owning a <strong class="source-inline">Lifecycle</strong> object – se<a id="_idTextAnchor330"/>e <strong class="source-inline">AppCompatActivity</strong> o<a id="_idTextAnchor331"/>r <strong class="source-inline">FragmentActivity</strong>. Alternatively, just as <strong class="source-inline">Activity</strong> classes have a lifecycle, so do <strong class="source-inline">Fragment</strong> components. If you check out the source code of the <strong class="source-inline">Fragment</strong> class, you will notice that it also implements the <strong class="source-inline">LifecycleOwner</strong> interface, and so it also contains a <strong class="source-inline">Lifecycle</strong> object.</p>
			<p>Simply put, the concept of a component having a lifecycle boils down to the idea of it providing a concrete implementation of the <strong class="source-inline">Lifecycle</strong> interface. This brings the idea that components <a id="_idIndexMarker1049"/>with a lifecycle, such as <strong class="source-inline">Activity</strong>, expose information related to their lifecycle.</p>
			<p>To better understand what we can find out about a component's lifecycle, we must explore the source code of the <strong class="source-inline">Lifecycle</strong> abstract class. If we do that, we will learn that the <strong class="source-inline">Lifecycle</strong> class contains information about the lifecycle state of the component that it's bound to, such as <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong>. The <strong class="source-inline">Lifecycle</strong> class features two main tracking pieces of information in the form of enumerations:</p>
			<ul>
				<li><strong class="bold">Event</strong>: The<a id="_idIndexMarker1050"/> events represented by the lifecycle callbacks that are triggered by the system and that we are all familiar with by now (<strong class="source-inline">onCreate()</strong>, <strong class="source-inline">onStart()</strong>, <strong class="source-inline">onResume()</strong>, <strong class="source-inline">onPause()</strong>, <strong class="source-inline">onStop()</strong>, and <strong class="source-inline">onDestroy()</strong>).</li>
				<li><strong class="bold">State</strong>: The<a id="_idIndexMarker1051"/> current state of the component tracked – <strong class="source-inline">INITIALIZED</strong>, <strong class="source-inline">DESTROYED</strong>, <strong class="source-inline">CREATED</strong>, <strong class="source-inline">STARTED</strong>, and <strong class="source-inline">RESUMED</strong>. If our <strong class="source-inline">Activity</strong> just received the <strong class="source-inline">onResume()</strong> callback, it means that until a new event arrives, it will stay in the <strong class="source-inline">RESUMED</strong> state. Upon every new event (the lifecycle callback), the state changes.</li>
			</ul>
			<p>While we were already pretty familiar with the lifecycle events (callbacks), we might need to better understand how lifecycle states are defined.</p>
			<p>Let's take a practical example and <a id="_idIndexMarker1052"/>explore what information a <strong class="source-inline">Lifecycle</strong> object can provide about an <strong class="source-inline">Activity</strong> component. As previously mentioned, the information is structured in the form of events and states:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B17788_12_03.jpg" alt="Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events and states&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events and states</p>
			<p>In the preceding diagram, we were able to dissect the lifecycle of an <strong class="source-inline">Activity</strong> component by its events and states. We also now have a better overview of how lifecycle events trigger transitions between lifecycle states.</p>
			<p>But why do all these events and states matter to us?</p>
			<p>In fact, most of our code is driven with respect to lifecycle information. To avoid potential crashes, memory leaks, or wasting resources, it's essential to perform actions only in the correct state or on the correct lifecycle event.</p>
			<p>When we think of <a id="_idIndexMarker1053"/>lifecycle events, we can say that different types of functionalities can and should only be executed at appropriate times, or after certain lifecycle callbacks. For example, we wouldn't want to update our UI components with data after the <strong class="source-inline">onDestroy()</strong> callback in our <strong class="source-inline">Activity</strong>, as it's very likely that our app would crash simply because the UI has been scrapped by this time. Another example would be that when the <strong class="source-inline">onResume()</strong> event is called in our <strong class="source-inline">Activity</strong>, we would know that our <strong class="source-inline">Activity</strong> has gained (or regained) focus, so we can perform certain actions in our code such as initializing our camera component.</p>
			<p>When we think of lifecycle states, we can say that different continuous actions can and should be running only during certain lifecycle periods – for example, we would want to start observing database changes if the state is <strong class="source-inline">RESUMED</strong> because that's when the user can interact with the screen and mutate data. When this state transitions to a different one, such as <strong class="source-inline">CREATED</strong> or <strong class="source-inline">DESTROYED</strong>, we might want to stop observing database changes so that we avoid memory leaks and don't waste resources.</p>
			<p>From the previous examples, it's clear that our code should be aware of the lifecycle of Android components. When we write code based on lifecycle events or states, we're writing code that is aware of the lifecycle of a specific component.</p>
			<p>Let's take an example and use our imagination a bit – the <strong class="source-inline">Presenter</strong> class features<a id="_idIndexMarker1054"/> a data stream produced by several network requests. That data stream is observed and passed to the UI. However, any ongoing network requests must be canceled in the <strong class="source-inline">cancelOngoingNetworkRequests()</strong> method, as our UI no longer needs to consume their response:</p>
			<p class="source-code">class Presenter() {</p>
			<p class="source-code">    // observe data and pass it to the UI</p>
			<p class="source-code">    fun cancelOngoingNetworkRequests() {</p>
			<p class="source-code">        // stop observing data</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's say that an instance of our <strong class="source-inline">Presenter</strong> class is used inside <strong class="source-inline">MainActivity.</strong> Naturally, it must respect the lifecycle of the <strong class="source-inline">MainActivity</strong> class. That's <a id="_idIndexMarker1055"/>why we should stop any ongoing network requests from within the <strong class="source-inline">Presenter</strong> class by calling the <strong class="source-inline">cancelOngoingNetworkRequests()</strong> method of the <strong class="source-inline">Presenter</strong> class inside the <strong class="source-inline">onDestroyed()</strong> lifecycle callback of the <strong class="source-inline">MainActivity</strong> class:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    val presenter = Presenter()</p>
			<p class="source-code">    override fun onStart() {</p>
			<p class="source-code">        super.onStart()</p>
			<p class="source-code">        //consume data from presenter</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onDestroy() {</p>
			<p class="source-code">        super.onDestroy()</p>
			<p class="source-code"><strong class="bold">        presenter.cancelOngoingNetworkRequests(<a id="_idTextAnchor332"/>)</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can say that our <strong class="source-inline">Presenter</strong> is aware of the lifecycle of its host, <strong class="source-inline">MainActivity</strong>.</p>
			<p>If a component respects the lifecycle of an Android component such as <strong class="source-inline">Activity</strong>, then we can consider that component to<a id="_idIndexMarker1056"/> be <strong class="bold">lifecycle-aware</strong>.</p>
			<p>However, we manually made our <strong class="source-inline">Presenter</strong> class be lifecycle-aware by manually calling a certain cleanup method from the <strong class="source-inline">MainActivity</strong> lifecycle callback. In other words, we had our <strong class="source-inline">MainActivity</strong> manually tell <strong class="source-inline">Presenter</strong> that it must stop its ongoing work.</p>
			<p>Also, whenever we need to use our <strong class="source-inline">Presenter</strong> in some other <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> classes, that component will need to remember to call the <strong class="source-inline">cancelOngoingNetworkRequests()</strong> method of <strong class="source-inline">Presenter</strong> on a certain lifecycle callback, therefore producing boilerplate code. If <strong class="source-inline">Presenter</strong> needed multiple actions on certain lifecycle callbacks, then that boilerplate code would have multiplied.</p>
			<p>With the <strong class="bold">Jetpack Lifecycle package</strong>, we no longer need to manually force our Android components to call methods on every other class that cares about their lifecycle events or states. We can create lifecycle-aware components without having <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong> components manually <a id="_idIndexMarker1057"/>inform our classes that a certain lifecycle event was triggered, or a certain state was reached – the <strong class="source-inline">Lifecycle</strong> package will help us receive the callbacks directly inside our components in a more efficient manner.</p>
			<p>The Jetpack <strong class="source-inline">Lifecycle</strong> package provides us with the following:</p>
			<ul>
				<li>Predefined lifecycle-aware components<a id="_idIndexMarker1058"/> with different purposes that require less boilerplate or work from our side. Such components are two Jetpack libraries:<ul><li><strong class="source-inline">ViewModel</strong></li><li><strong class="source-inline">LiveData</strong></li></ul></li>
				<li>A Lifecycle API <a id="_idIndexMarker1059"/>that allows us to create a custom lifecycle-aware component much easier with less boilerplate code.</li>
			</ul>
			<p>Before creating our own lifecycle-aware component, we should briefly cover the two predefined lifecycle-aware components that the Jetpack <strong class="source-inline">Lifecycle</strong> package provides us with. Let's begin with <strong class="source-inline">ViewModel</strong>.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor333"/>ViewModel</h2>
			<p>In this <a id="_idIndexMarker1060"/>book, we have already covered Jetpack's <strong class="source-inline">ViewModel</strong> as a <a id="_idIndexMarker1061"/>class where our UI state resides and where most of the presentation logic is found. However, we also learned that in order to properly cancel data streams or ongoing network requests, <strong class="source-inline">ViewModel</strong> is aware of the lifecycle of its host <strong class="source-inline">Activity</strong>, <strong class="source-inline">Fragment</strong>, and even its composable destination (in conjunction with the Jetpack Navigation component).</p>
			<p>In contrast to our <strong class="source-inline">Presenter</strong> class, whose lifecycle we have manually tied to the lifecycle of a host <strong class="source-inline">Activity</strong>, Jetpack's <strong class="source-inline">ViewModel</strong> is a lifecycle-aware component that we can use to eliminate any boilerplate calls from <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragmen</strong>t components.</p>
			<p>To be more <a id="_idIndexMarker1062"/>precise, <strong class="source-inline">ViewModel</strong> knows when its host component with a lifecycle reaches the end of its lifecycle and provides us with a callback method that we can use by overriding the <strong class="source-inline">onCleared()</strong> method. Inside this callback, we can cancel any pending work whose result we're no longer interested in to avoid memory leaks or wasting resources.</p>
			<p>As an example, if <a id="_idIndexMarker1063"/>our <strong class="source-inline">ViewModel</strong> is hosted by an  <strong class="source-inline">Activity</strong>, then it knows when in the lifecycle of that <strong class="source-inline">Activity</strong> the <strong class="source-inline">onDestroy()</strong> event was called, and so it automatically triggers the <strong class="source-inline">onCleared()</strong> callback:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B17788_12_04.jpg" alt="Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity</p>
			<p>This basically means that instead of manually having our <strong class="source-inline">Activity</strong> inform the <strong class="source-inline">ViewModel</strong> that its lifecycle has ended so that it can stop its work, <strong class="source-inline">ViewModel</strong> is a lifecycle-aware component that does that out of the box for you by providing a handle for that event – that is, the <strong class="source-inline">onCleared()</strong> callback:</p>
			<p class="source-code">class MyViewModel(): ViewModel() {</p>
			<p class="source-code"><strong class="bold">    override fun onCleared() {</strong></p>
			<p class="source-code">        super.onCleared()</p>
			<p class="source-code">        // Cancel work</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Additionally, in the <a id="_idIndexMarker1064"/>context of an <strong class="source-inline">Activity</strong> host, the <strong class="source-inline">ViewModel</strong> component is also aware of any lifecycle callbacks caused by events<a id="_idIndexMarker1065"/> such as a configuration change, so it knows how to outlive those and helps us maintain the UI state, even after a configuration change.</p>
			<p>But how does <strong class="source-inline">ViewModel</strong> know about the lifecycle callbacks of an <strong class="source-inline">Activity </strong>component? To answer that, we can look at a traditional way of instantiating a <strong class="source-inline">ViewModel</strong> inside an <strong class="source-inline">Activity</strong> by using the <strong class="source-inline">ViewModelProvider</strong> API and specifying the type of <strong class="source-inline">ViewModel</strong>  that must be retrieved – that is, <strong class="source-inline">MyViewModel</strong>:</p>
			<p class="source-code">class MyActivity: ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        val vm = </p>
			<p class="source-code">          <strong class="bold">ViewModelProvider(this)[MyViewModel::class.java]</strong></p>
			<p class="source-code">         // Perform operations</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>To get an instance of <strong class="source-inline">MyViewModel</strong>, we used the <strong class="source-inline">ViewModelProvider()</strong> constructor and passed the <strong class="source-inline">this</strong> instance of the <strong class="source-inline">MyActivity</strong> class to the <strong class="source-inline">owner</strong> parameter that expected a <strong class="source-inline">ViewModelStoreOwner</strong> object. <strong class="source-inline">MyActivity</strong> indirectly implements the <strong class="source-inline">ViewModelStoreOwner</strong> interface because <strong class="source-inline">ComponentActivity</strong> does so.</p>
			<p>To control the<a id="_idIndexMarker1066"/> lifetime of the instance of our <strong class="source-inline">ViewModel</strong>, <strong class="source-inline">ViewModelProvider</strong> needs an instance of <strong class="source-inline">ViewModelStoreOwner</strong> because when it instantiates our <strong class="source-inline">MyViewModel</strong>, it will <em class="italic">link</em> the lifetime of this instance to the lifetime of the <strong class="source-inline">ViewModelStoreOwner</strong> – that is, <strong class="source-inline">MyActivity</strong>.</p>
			<p>But how does <strong class="source-inline">ViewModel</strong> know <a id="_idIndexMarker1067"/>when it must be cleared? In other words, what triggers the <strong class="source-inline">onCleared()</strong> method of the <strong class="source-inline">MyViewModel</strong> class?</p>
			<p><strong class="source-inline">ComponentActivity</strong> will wait for its <strong class="source-inline">onDestroy()</strong> lifecycle callback, and when that event is triggered, it will call the <strong class="source-inline">getViewModelStore()</strong> method of the <strong class="source-inline">ViewModelStoreOwner</strong> interface and obtain a <strong class="source-inline">ViewModelStore</strong> object. On this object, it will then call the <strong class="source-inline">clear()</strong> method to clear the <strong class="source-inline">ViewModel</strong> instance that was linked to <strong class="source-inline">ComponentActivity</strong> – in our case, the <strong class="source-inline">MyViewModel</strong> instance.</p>
			<p>If you check out the source code of the <strong class="source-inline">ComponentActivity</strong> class, you will find the following implementation, which proves the previous points we're trying to express:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B17788_12_05.jpg" alt="Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity</p>
			<p>Now, the <strong class="source-inline">ViewModel</strong> lifecycle-aware component is helpful because it allows us to easily stop pending work and also persist UI state across configuration changes.</p>
			<p>However, there is another important lifecycle-aware component that we haven't covered in this book and that we should briefly mention, and that is <strong class="source-inline">LiveData</strong>.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor334"/>LiveData</h2>
			<p><strong class="source-inline">LiveData</strong> is<a id="_idIndexMarker1068"/> an observable data holder class that <a id="_idIndexMarker1069"/>allows us to get data updates in a lifecycle-aware manner inside our Android components, such as <strong class="source-inline">Activity</strong> and <strong class="source-inline">Fragment</strong>. While specific implementations of Kotlin Flow data streams are similar to <strong class="source-inline">LiveData</strong> because both allow us to receive multiple data events over time, <strong class="source-inline">LiveData</strong> presents the advantage of being a lifecycle-aware component.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this section, we won't cover <strong class="source-inline">LiveData</strong> extensively to understand its API. Instead, we will try to highlight its lifecycle-aware character. Right now, you don't have to code along.</p>
			<p>Without going into too much detail, let's see a simple usage of a <strong class="source-inline">LiveData</strong> object kept inside a <strong class="source-inline">ViewModel</strong> class and consumed from an <strong class="source-inline">Activity</strong> component.</p>
			<p>Inside <strong class="source-inline">ViewModel</strong>, we instantiated a <strong class="source-inline">MutableLiveData</strong> object that will hold values of type <strong class="source-inline">Int</strong>, passed an initial value of <strong class="source-inline">0</strong>, and then in the <strong class="source-inline">init{}</strong> block launched a coroutine, where we've set the value to <strong class="source-inline">100</strong> after a <strong class="source-inline">5000</strong>-millisecond delay:</p>
			<p class="source-code">class MyViewModel(): ViewModel() {</p>
			<p class="source-code">    val numberLiveData: MutableLiveData&lt;Int&gt; = </p>
			<p class="source-code">        MutableLiveData(0)</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            delay(5000)</p>
			<p class="source-code">            numberLiveData.value = 100</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">numberLiveData</strong> is now a data holder that will first notify any components observing it of the value <strong class="source-inline">0</strong> and, after 5 seconds, the value <strong class="source-inline">100</strong>.</p>
			<p>Now, an  <strong class="source-inline">Activity</strong> can <a id="_idIndexMarker1070"/>be observing these values by first obtaining an instance of <strong class="source-inline">MyViewModel</strong>, tapping into its <strong class="source-inline">numberLiveData</strong> object, and then starting to observe the changes<a id="_idIndexMarker1071"/> through the <strong class="source-inline">observe()</strong> method:</p>
			<p class="source-code">class MyActivity: ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        val vm = </p>
			<p class="source-code">          ViewModelProvider(this)[MyViewModel::class.java]</p>
			<p class="source-code"><strong class="bold">        vm.numberLiveData.observe(this, object: Observer&lt;Int&gt; {</strong></p>
			<p class="source-code"><strong class="bold">            override fun onChanged(t: Int?) {</strong></p>
			<p class="source-code"><strong class="bold">                // Consume values</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        })</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, to the <strong class="source-inline">observe()</strong> method, we've passed the following:</p>
			<ul>
				<li>First, the <strong class="source-inline">this</strong> instance of the <strong class="source-inline">MyActivity</strong> class to the <strong class="source-inline">owner</strong> parameter that expected a <strong class="source-inline">LifecycleOwner</strong> object. This worked because <strong class="source-inline">MyActivity</strong> indirectly implements (through <strong class="source-inline">ComponentActivity</strong>) the <strong class="source-inline">LifecycleOwner</strong> interface and therefore owns a <strong class="source-inline">Lifecycle</strong> object. The <strong class="source-inline">observe()</strong> method expected a <strong class="source-inline">LifecycleOwner</strong> as its first parameter, so that the observing feature is lifecycle-aware of the lifecycle of <strong class="source-inline">MainActivity</strong>.</li>
				<li>An <strong class="source-inline">Observer&lt;Int&gt;</strong> Kotlin inner <strong class="source-inline">object</strong> that allows us to receive the data events (holding the <strong class="source-inline">Int</strong> values) from the <strong class="source-inline">MutableLiveData</strong> object inside the <strong class="source-inline">onChanged()</strong> callback. Each time a new value is propagated, this callback will be triggered, and we will receive the latest value.</li>
			</ul>
			<p>Now that<a id="_idIndexMarker1072"/> we <a id="_idIndexMarker1073"/>have briefly covered how to use <strong class="source-inline">LiveData</strong>, let's better understand the whole reason why we are talking about <strong class="source-inline">LiveData</strong>. As we've mentioned, <strong class="source-inline">LiveData</strong> is a lifecycle-aware component, but how does it achieve that?</p>
			<p>When we passed our <strong class="source-inline">MainActivity</strong> as <strong class="source-inline">LifecycleOwner</strong> to the <strong class="source-inline">owner</strong> parameter of the <strong class="source-inline">observe()</strong> method, behind the scenes, <strong class="source-inline">LiveData</strong> started an observing process dependent on the <strong class="source-inline">Lifecycle</strong> object of the provided <strong class="source-inline">owner</strong>.</p>
			<p>More precisely, the <strong class="source-inline">Observer</strong> object provided as the second parameter to the <strong class="source-inline">observe()</strong> method will only receive updates if the owner – that is, <strong class="source-inline">MainActivity</strong> – is in the <strong class="source-inline">STARTED</strong> or <strong class="source-inline">RESUMED</strong> lifecycle state. </p>
			<p><em class="italic">This behavior is essential, as it allows Activity components to only receive UI updates from ViewModel components when they are visible or in focus</em>, therefore making sure that the UI can safely handle the data events and not waste resources.</p>
			<p>If, however, updates would have occurred in other states when the UI would not have been initialized, our app could have misbehaved or, even worse, crashed or introduced memory leaks. To be sure that such behavior doesn't occur, if the owner moves to the <strong class="source-inline">DESTROYED</strong> state, the <strong class="source-inline">Observer</strong> object will be automatically removed.</p>
			<p>In the following diagram, you will be able to visualize how <strong class="source-inline">LiveData</strong> updates only come when the <strong class="source-inline">Activity</strong> component is in the <strong class="source-inline">RESUMED</strong> or <strong class="source-inline">STARTED</strong> state, while also automatically removing the <strong class="source-inline">Observer</strong> object when the state becomes <strong class="source-inline">DESTROYED</strong>:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B17788_12_06.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6 – Lifecycle states and events when LiveData updates are received and the LiveData Observer is removed</p>
			<p>With such <a id="_idIndexMarker1074"/>behavior, <strong class="source-inline">LiveData</strong> becomes a lifecycle-aware component in the sense that any <strong class="source-inline">LifecycleOwner</strong> must be in an active lifecycle state to be receiving updates from it.</p>
			<p>Now that we <a id="_idIndexMarker1075"/>have covered the two predefined lifecycle-aware components (<strong class="source-inline">ViewModel</strong> and <strong class="source-inline">LiveData</strong>) that are part of the <strong class="source-inline">Lifecycle</strong> package, it's time to add a countdown timer component in our Repositories app so that later on, we can transform it into a custom lifecycle-aware component with the help of the Lifecycle APIs.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor335"/>Adding a countdown component in the Repositories app</h1>
			<p>Our plan is to learn how<a id="_idIndexMarker1076"/> to create our own lifecycle-aware component. However, before we can do that, we must first create a normal component that, by default, is not aware of the lifecycle of any Android component.</p>
			<p>To do that, we<a id="_idIndexMarker1077"/> can create a countdown timer component inside our Repositories app that will track whether the user has spent at least 60 seconds on the app, and if so, we will award the user with a fictional prize.</p>
			<p>More precisely, our plan is to create a countdown timer widget inside the <strong class="source-inline">RepositoriesScreen()</strong> that will award the user with a prize upon a 60-second countdown. However, for the countdown to work and the prize to be awarde<a id="_idTextAnchor336"/>d, the user must be inside <strong class="source-inline">RepositoriesScreen()</strong> and have the countdown composable visible.</p>
			<p>The countdown will behave like so:</p>
			<ul>
				<li>It will start from 60 and finish when the countdown reaches 0. Upon every second, the timer will decrease by 1 unit.</li>
				<li>When the countdown has finished, a prize message will be displayed.</li>
				<li>It will be paused if the countdown composable is not visible. In other words, if the user is not inside the <strong class="source-inline">RepositoriesScreen()</strong> composable or the timer composable is not visible or hidden within <strong class="source-inline">RepositoriesScreen()</strong>, then the countdown should be paused.</li>
			</ul>
			<p>Now that we have a plan, let's implement a countdown timer component:</p>
			<ol>
				<li value="1">Inside the root package, create a new class called <strong class="source-inline">CustomCountdown</strong> and define its constructor to feature two function parameters that will be called as the countd<a id="_idTextAnchor337"/>own timer functions:<p class="source-code">class CustomCountdown(</p><p class="source-code">    private val onTick: ((currentValue: Int) -&gt; Unit),</p><p class="source-code">    private val o<a id="_idTextAnchor338"/>nFinish: (() -&gt; Unit),</p><p class="source-code">) {</p><p class="source-code">}</p></li>
			</ol>
			<p>We will have to call the <strong class="source-inline">onTick()</strong> function after every second has passed and the <strong class="source-inline">onFinish()</strong> function when the countdown has ended.</p>
			<ol>
				<li value="2">Now, inside<a id="_idIndexMarker1078"/> the <strong class="source-inline">CustomCountdown</strong> class, let's create an inner class called <strong class="source-inline">InternalTimer</strong> that will inherit <a id="_idIndexMarker1079"/>from the built-in Android <strong class="source-inline">android.os.CountDownTimer</strong> class and handle the actual countdown sequence:<p class="source-code">class CustomCountdown(</p><p class="source-code">    private val onTick: ((currentValue: Int) -&gt; Unit),</p><p class="source-code">    private val onF<a id="_idTextAnchor339"/>inish: (() -&gt; Unit),</p><p class="source-code">) {</p><p class="source-code"><strong class="bold">    class InternalTimer(</strong></p><p class="source-code"><strong class="bold">        private val onTick: ((currentValue: Int) -&gt; Unit),</strong></p><p class="source-code"><strong class="bold">        private val onFinish: (() -&gt; Unit),</strong></p><p class="source-code"><strong class="bold">        millisInFuture: Long,</strong></p><p class="source-code"><strong class="bold">        countDownInterval: Long</strong></p><p class="source-code"><strong class="bold">    ) : CountDownTimer(millisInFuture, </strong></p><p class="source-code"><strong class="bold">                       count<a id="_idTextAnchor340"/>DownInterval){</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>While the constructor of <strong class="source-inline">InternalTimer</strong> also accepts two identical function parameters, as <strong class="source-inline">CustomCountdown</strong> does, it's essential to note its <strong class="source-inline">millisInFuture</strong> and <strong class="source-inline">countDownInterval</strong> parameters that it forwards to the built-in Android <strong class="source-inline">CountDownTimer</strong> class. These two parameters will configure the core functionality of the timer – the countdown starting point in time and the time period that passes between timer ticks.</p>
			<ol>
				<li value="3">Next up, let's<a id="_idIndexMarker1080"/> finish the implementation <a id="_idIndexMarker1081"/>of the <strong class="source-inline">InternalTimer</strong> class: <p class="source-code">class CustomCountdown(</p><p class="source-code">    private val onTick: ((currentValue: Int) -&gt; Unit),</p><p class="source-code">    private val onFinish: (() -&gt; Unit),</p><p class="source-code">) {</p><p class="source-code">    class InternalTimer(</p><p class="source-code">        private val onTick: ((currentValue: Int) -&gt; Unit),</p><p class="source-code">        private val onFinish: (() -&gt; Unit),</p><p class="source-code">        millisInFuture: Long,</p><p class="source-code">        countDownInterval: Long</p><p class="source-code">    ) : CountDownTimer(millisInFuture, </p><p class="source-code">        countDownInterval) {</p><p class="source-code"><strong class="bold">        init {</strong></p><p class="source-code"><strong class="bold">            this.start()</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">        override fun onFinish() {</strong></p><p class="source-code"><strong class="bold">            onFinish.invoke()</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">        override fun onTick(millisUntilFinished: Long) {</strong></p><p class="source-code"><strong class="bold">            onTick(millis<a id="_idTextAnchor341"/>UntilFinished.toInt())</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>To make sure the timer works as expected, we have done the following:</p>
			<ul>
				<li>Called the <strong class="source-inline">start()</strong> method provided by the inherited parent, <strong class="source-inline">CountDownTimer</strong>, inside the <strong class="source-inline">init{}</strong> block. This should automatically start the timer upon inception.</li>
				<li>Implemented <a id="_idIndexMarker1082"/>the two <a id="_idIndexMarker1083"/>mandatory <strong class="source-inline">onFinish()</strong> and <strong class="source-inline">onTick()</strong> methods of the inherited parent, <strong class="source-inline">CountDownTimer</strong>, and propagated the events to the caller of <strong class="source-inline">InternalTimer</strong> by calling its <strong class="source-inline">onFinish()</strong> and <strong class="source-inline">onTick()</strong> function parameters.</li>
			</ul>
			<ol>
				<li value="4">Then, back in the <strong class="source-inline">CustomCountdown</strong> class, let's create an instance of <strong class="source-inline">InternalTimer</strong> and configure it to work like a 60-second countdown timer that starts from <strong class="source-inline">60</strong> and finishes at <strong class="source-inline">0</strong>.</li>
			</ol>
			<p>To do that, let's pass to its constructor not only the <strong class="source-inline">onFinish</strong> and <strong class="source-inline">onTick</strong> function parameters but also 60 seconds (as <strong class="source-inline">60000</strong> milliseconds) to the <strong class="source-inline">millisInFuture</strong> parameter and 1 second (as <strong class="source-inline">1000</strong> milliseconds) to the <strong class="source-inline">countDownInterval</strong> parameter:</p>
			<p class="source-code">class CustomCountdown(</p>
			<p class="source-code">    private val onTick: ((currentValue: Int) -&gt; Unit),</p>
			<p class="source-code">    private val<a id="_idTextAnchor342"/> onFinish: (() -&gt; Unit),</p>
			<p class="source-code">) {</p>
			<p class="source-code"><strong class="bold">    var timer: InternalTimer = InternalTimer(</strong></p>
			<p class="source-code"><strong class="bold">        onTick = onTick,</strong></p>
			<p class="source-code"><strong class="bold">        onFinish = onFinish,</strong></p>
			<p class="source-code"><strong class="bold">        millisInFuture = 60000,</strong></p>
			<p class="source-code"><strong class="bold">        countDownInterval = 1000)</strong></p>
			<p class="source-code">    class InternalTimer(</p>
			<p class="source-code">        private val onTick: ((currentValue: Int) -&gt; Unit),</p>
			<p class="source-code">        private val onFinish: (() -&gt; Unit),</p>
			<p class="source-code">        millisInFuture: Long,</p>
			<p class="source-code">        countDownInterval: Long</p>
			<p class="source-code">    ): CountDownTimer(millisInFuture, countDownInterval)</p>
			<p class="source-code">    { … }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="5">Still<a id="_idIndexMarker1084"/> inside <strong class="source-inline">CustomCountdown</strong>, to <a id="_idIndexMarker1085"/>provide a way for canceling the countdown, add a <strong class="source-inline">stop()</strong> method that will allow us to call the <strong class="source-inline">cancel()</strong> method inherited by <strong class="source-inline">InternalTimer</strong> from the Android <strong class="source-inline">CountDownTimer</strong> class:<p class="source-code">class CustomCountdown(…) {</p><p class="source-code">    var timer: InternalTimer = InternalTimer(…)</p><p class="source-code"><strong class="bold">    fun s<a id="_idTextAnchor343"/>top() {</strong></p><p class="source-code"><strong class="bold">        timer.cancel()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    class InternalTimer(</p><p class="source-code">        […]</p><p class="source-code">    ): CountDownTimer(millisInFuture, c<a id="_idTextAnchor344"/>ountDownInterval)</p><p class="source-code">    { … }</p><p class="source-code">}</p></li>
				<li>Then, in <strong class="source-inline">RepositoriesViewModel</strong>, add not only a <strong class="source-inline">timerState</strong> variable that will hold<a id="_idIndexMarker1086"/> the text state displayed <a id="_idIndexMarker1087"/>by our countdown composable but also a <strong class="source-inline">timer</strong> variable that will hold a <strong class="source-inline">CustomCountdown</strong> object:<p class="source-code">class RepositoriesViewModel(…) : ViewModel() {</p><p class="source-code">    val repositories: Fl<a id="_idTextAnchor345"/>ow&lt;PagingData&lt;Repository&gt;&gt; = […]</p><p class="source-code"><strong class="bold">    val timerState = mutableStateOf("")</strong></p><p class="source-code"><strong class="bold">    var timer: CustomCountdown = CustomCountdown(</strong></p><p class="source-code"><strong class="bold">        onTick = { msLeft -&gt;</strong></p><p class="source-code"><strong class="bold">            timerState.value =</strong></p><p class="source-code"><strong class="bold">               (msLeft / 1000).toString() + </strong></p><p class="source-code"><strong class="bold">                   " seconds left"</strong></p><p class="source-code"><strong class="bold">        },</strong></p><p class="source-code"><strong class="bold">        onFinish = {</strong></p><p class="source-code"><strong class="bold">            timerState.value = "You won a prize!"</strong></p><p class="source-code"><strong class="bold">        })</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">onTick</strong> callback, we are computing the remaining seconds and setting a <strong class="source-inline">String</strong> message about our countdown to <strong class="source-inline">timerState</strong>. Then, in the <strong class="source-inline">onFinish</strong> callback, we're setting a prize message to <strong class="source-inline">timerState</strong>.</p>
			<ol>
				<li value="7">As a good practice, inside <strong class="source-inline">RepositoriesViewModel</strong>, make sure to stop the timer inside the <strong class="source-inline">onCleared()</strong> callback if the user moves to a different screen. This <a id="_idIndexMarker1088"/>would mean that <strong class="source-inline">RepositoriesScreen()</strong> wouldn't be composed anymore, so this <strong class="source-inline">ViewModel</strong> would be cleared and the countdown should be stopped so that it doesn't send events and waste resources:<p class="source-code">class RepositoriesViewModel(…) : ViewModel() {</p><p class="source-code">    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; = […]</p><p class="source-code">    val timerState = mutableStateOf("")</p><p class="source-code">    var timer: CustomCountdown = CustomCountdown(…)</p><p class="source-code"><strong class="bold">    override fun onCleared() {</strong></p><p class="source-code"><strong class="bold">        super<a id="_idTextAnchor346"/>.onCleared()</strong></p><p class="source-code"><strong class="bold">        timer.stop()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
				<li>Now, move to <strong class="source-inline">MainActivity</strong> and make sure that just as the repositories are consumed <a id="_idIndexMarker1089"/>and passed to the <strong class="source-inline">RepositoriesScreen()</strong> composable, the countdown timer text produced by <strong class="source-inline">ViewModel</strong> is also consumed and passed to <strong class="source-inline">RepositoriesScreen()</strong>:<p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            RepositoriesAppTheme {</p><p class="source-code">                val viewModel: RepositoriesViewModel = …</p><p class="source-code">                val reposFlow = <a id="_idTextAnchor347"/>viewModel.repositories</p><p class="source-code"><strong class="bold">                val timerText = </strong></p><p class="source-code"><strong class="bold">                    viewModel.timerState.value</strong></p><p class="source-code">                val lazyRepoItems: […] = […]</p><p class="source-code">                RepositoriesScreen(</p><p class="source-code">                    lazyRepoItems,</p><p class="source-code">                    <strong class="bold">timerText</strong></p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Then, at <a id="_idIndexMarker1090"/>the end of the <strong class="source-inline">RepositoriesScreen.kt</strong> file, create a simple <strong class="source-inline">CountdownItem()</strong> composable function that takes in a <strong class="source-inline">timerText: String</strong> parameter and sets its value to a <strong class="source-inline">Text</strong> composable:<p class="source-code">@Composable</p><p class="source-code">private fun CountdownItem(t<a id="_idTextAnchor348"/>imerText: String) {</p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
				<li>Next, in the <strong class="source-inline">RepositoriesScreen()</strong> composable, add a new parameter for the <a id="_idIndexMarker1091"/>countdown text called <strong class="source-inline">timerText</strong>, and inside the <strong class="source-inline">LazyColumn</strong> scope, before the <strong class="source-inline">itemsIndexed()</strong> call, add a singular <strong class="source-inline">item()</strong> <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) function call <a id="_idIndexMarker1092"/>where you should add the <strong class="source-inline">CountdownItem()</strong> composable while passing the <strong class="source-inline">timerText</strong> variable to it:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;,</p><p class="source-code">    <strong class="bold">timerText: String</strong></p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        <strong class="bold">item {</strong></p><p class="source-code"><strong class="bold">            CountdownItem(timerText)</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">        itemsIndexed(repos) { index, repo -&gt; […] }</p><p class="source-code">        […]</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>By <a id="_idIndexMarker1093"/>doing so, we make sure that the countdown timer is displayed at the top of the screen as the first item within the list of repositories.</p>
			<ol>
				<li value="11">Build <a id="_idIndexMarker1094"/>and run the application. You should first see the countdown timer telling you how much time you need to wait, and after approximately 1 minute, you should see the prize message displayed:</li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B17788_12_07.jpg" alt="Figure 12.7 – Observing how the countdown timer works&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7 – Observing how the countdown timer works</p>
			<p>We have <a id="_idIndexMarker1095"/>now finished incorporating the<a id="_idIndexMarker1096"/> countdown timer that ends by awarding the user with a fictional prize.</p>
			<p>However, there is a scenario where our timer doesn't work as expected. Let's identify it:</p>
			<ol>
				<li value="1">Restart the application. You can do that by closing the current instance of the app and reopening it.</li>
			</ol>
			<p>The countdown should have started from 60 again at this point.</p>
			<ol>
				<li value="2">Before the countdown finishes, remember or write down somewhere the current countdown value and then put the app in background.</li>
				<li>Wait for a few seconds and then bring the app back to the foreground.</li>
			</ol>
			<p>You should notice that while the app was in the background, the countdown kept going. We wanted the timer to be paused when the app was put in the background and then resumed when the app was brought back to the foreground – this would have allowed us to award the prize to users that actively use the app and have the countdown timer visible. This behavior didn't occur, as the timer kept on counting while the app was not visible or in focus.</p>
			<p>This is happening because we didn't do anything to pause the timer when the app goes into <a id="_idIndexMarker1097"/>the background or resume it when the<a id="_idIndexMarker1098"/> app comes back to the foreground. In other words, our countdown timer is not lifecycle-aware, so it doesn't get notified and can't react to the lifecycle events of the <strong class="source-inline">Activity</strong> host.</p>
			<p>Next, let's make our countdown timer a lifecycle-aware component.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor349"/>Creating your own lifecycle-aware component</h1>
			<p>We need<a id="_idIndexMarker1099"/> to make our <strong class="source-inline">CustomCountdown</strong> aware of the lifecycle of <strong class="source-inline">MainActivity</strong>. In other words, our countdown logic should observe and react to the lifecycle events of our <strong class="source-inline">LifecycleOwner</strong> – that is, <strong class="source-inline">MainActivity</strong>. </p>
			<p>To make our <strong class="source-inline">CustomCountdown</strong> lifecycle-aware, we must force it to implement the <strong class="source-inline">DefaultLifecycleObserver</strong> interface. By doing so, the <strong class="source-inline">CustomCountdown</strong> will be observing the lifecycle events or states defined by the <strong class="source-inline">Lifecycle</strong> object that <strong class="source-inline">LifecycleOwner</strong> provides.</p>
			<p>Our main goal is to pause the countdown when the app is put in the background and to resume it when the app is brought back into the foreground. More precisely, our <strong class="source-inline">CustomCountdown</strong> must react to the following lifecycle events of <strong class="source-inline">MainActivity</strong>:</p>
			<ul>
				<li><strong class="source-inline">onPause()</strong>: When the <strong class="source-inline">onPause()</strong> callback comes in <strong class="source-inline">MainActivity</strong>, <strong class="source-inline">CustomCountdown</strong> must pause its countdown.</li>
				<li><strong class="source-inline">onResume()</strong>: When the <strong class="source-inline">onResume()</strong> callback comes in <strong class="source-inline">MainActivity</strong>, <strong class="source-inline">CustomCountdown</strong> must resume its countdown.</li>
			</ul>
			<p>With this behavior, we can award the prize to users that actively use the app and have the countdown timer visible and in focus.</p>
			<p>Now that we have a plan, let's start coding.</p>
			<ol>
				<li value="1">Make the <strong class="source-inline">CustomCountdown</strong> class implement the <strong class="source-inline">DefaultLifecycleObserver</strong> interface and then override the two lifecycle callbacks we're interested in, <strong class="source-inline">onResume()<a id="_idTextAnchor350"/></strong> and <strong class="source-inline">onPause()</strong>:<p class="source-code">class CustomCountdown(</p><p class="source-code">    […]</p><p class="source-code">): <strong class="bold">DefaultLifecycleObserver</strong> {</p><p class="source-code">    var timer: InternalTimer = InternalTimer(</p><p class="source-code">        onTick = onTick,</p><p class="source-code">        onFinish = onFinish,</p><p class="source-code">        millisInFuture = 60000,</p><p class="source-code">        countDownInterval = 1000)</p><p class="source-code"><strong class="bold">    override fun onResume(owner: LifecycleOwner) {</strong></p><p class="source-code"><strong class="bold">        super.onResume(owner)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">    override fun onPause(owner: Lif<a id="_idTextAnchor351"/>ecycleOwner) {</strong></p><p class="source-code"><strong class="bold">        super.onPause(owner)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    fun stop() { timer.cancel() }</p><p class="source-code">    class InternalTimer(…) {…}</p><p class="source-code">}</p></li>
			</ol>
			<p>Once <a id="_idIndexMarker1100"/>we make our <strong class="source-inline">CustomCountdown</strong> observe the lifecycle of <strong class="source-inline">MainActivity</strong>, its <strong class="source-inline">onResume(owner: LifecycleOwner)</strong> callback will be called when the <strong class="source-inline">onResume()</strong> callback of <strong class="source-inline">MainActivity</strong> is called, and similarly, its <strong class="source-inline">onPause(owner: LifecycleOwner)</strong> callback will be called when the <strong class="source-inline">onPause()</strong> callback of <strong class="source-inline">MainActivity</strong> is called.</p>
			<ol>
				<li value="2">Now that we know when to pause and resume our countdown timer, we need to find ways to actually pause and resume it.</li>
			</ol>
			<p>First, let's pause the countdown in the <strong class="source-inline">onPause()</strong> callback by calling the <strong class="source-inline">cancel()</strong> method of the <strong class="source-inline">timer</strong> variable:</p>
			<p class="source-code">class CustomCountdown(</p>
			<p class="source-code">    […]</p>
			<p class="source-code">): DefaultLifecycleObserver {</p>
			<p class="source-code">    var timer: InternalTimer = InternalTimer(…)</p>
			<p class="source-code">    override fun onResume(owner: LifecycleOwner) {</p>
			<p class="source-code">        super.onResume(owner)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun onPause(owner: Lifecy<a id="_idTextAnchor352"/>cleOwner) {</p>
			<p class="source-code">        super.onPause(owner)</p>
			<p class="source-code"><strong class="bold">        timer.cancel()</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    fun stop() { timer.cancel() }</p>
			<p class="source-code">    class InternalTimer(…) : CountDownTimer(…) {…}</p>
			<p class="source-code">}</p>
			<p>With<a id="_idIndexMarker1101"/> this behavior, when <strong class="source-inline">MainActivity</strong> is paused, we are stopping the countdown run by the <strong class="source-inline">InternalTime</strong> instance held inside the <strong class="source-inline">timer</strong> variable.</p>
			<ol>
				<li value="3">Next up, we need to resume the <strong class="source-inline">timer</strong> in the <strong class="source-inline">onResume()</strong> callback. However, to resume it, we need to know the value of the last countdown before the <strong class="source-inline">onPause()</strong> callback was triggered and the timer was canceled. With that last known countdown value, we can reinitiate our timer in the <strong class="source-inline">onResume()</strong> callback.</li>
			</ol>
			<p>Inside the inner <strong class="source-inline">InternalTimer</strong> class, create a <strong class="source-inline">lastKnownTime</strong> variable, initiate it with the value of <strong class="source-inline">millisInFuture</strong>, and then make sure to update it in the <strong class="source-inline">onFinish()</strong> and <strong class="source-inline">onTick()</strong> timer callbacks:</p>
			<p class="source-code">class CustomCountdown(</p>
			<p class="source-code">    […]</p>
			<p class="source-code">): DefaultLifecycleObserver {</p>
			<p class="source-code">    var timer: InternalTimer = InternalTimer(</p>
			<p class="source-code">        […]</p>
			<p class="source-code">        millisInFuture = 60000,</p>
			<p class="source-code">        countDownInterval = 1000)</p>
			<p class="source-code">    override fun onResume(owner: LifecycleOwner) { … }</p>
			<p class="source-code">    override fun onPause(owner: LifecycleOwner) { … }</p>
			<p class="source-code">    fun stop() { timer.cancel() }</p>
			<p class="source-code">    cla<a id="_idTextAnchor353"/>ss InternalTimer(…) : CountDownTimer(…) {</p>
			<p class="source-code"><strong class="bold">        var lastKnownTime: Long = millisInFuture</strong></p>
			<p class="source-code">        init { this.start(<a id="_idTextAnchor354"/>) }</p>
			<p class="source-code">        override fun onFinish() {</p>
			<p class="source-code"><strong class="bold">            lastKnownTime = 0</strong></p>
			<p class="source-code">            onFinish.invoke()</p>
			<p class="source-code">        }</p>
			<p class="source-code">        override fu<a id="_idTextAnchor355"/>n onTick(millisUntilFinished: Long) {</p>
			<p class="source-code"><strong class="bold">            lastKnownTime = millisUntilFinished</strong></p>
			<p class="source-code">            onTick(millisUntilFinished.toInt())</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>While in the <strong class="source-inline">onFinish()</strong> callback, we've set <strong class="source-inline">lastKnownTime</strong> to <strong class="source-inline">0</strong> because the countdown has finished, in the <strong class="source-inline">onTick()</strong> callback, we've made sure to save inside the <strong class="source-inline">lastKnownTime</strong> variable the latest value received from the <strong class="source-inline">onTick()</strong> callback – that is, <strong class="source-inline">millisUntilFinished</strong>.</p>
			<ol>
				<li value="4">Now, going<a id="_idIndexMarker1102"/> back in the parent <strong class="source-inline">CustomCountdown</strong> class, resume the countdown in the <strong class="source-inline">onResume()</strong> callback of <strong class="source-inline">CustomCountdown</strong> by first canceling the countdown of the previous timer and then by storing inside the <strong class="source-inline">timer</strong> variable another instance of <strong class="source-inline">InternalTimer</strong>, which now starts the countdown from the <strong class="source-inline">lastKnownTime</strong> value of the previous <strong class="source-inline">InternalTimer</strong> instance:<p class="source-code">class CustomCountdown(</p><p class="source-code">    […]</p><p class="source-code">): DefaultLifecycleObserver {</p><p class="source-code">    var timer: InternalTimer = InternalTimer(</p><p class="source-code">        onTick = onTick,</p><p class="source-code">        onFinish = onFinish,</p><p class="source-code">        millisInFuture = 60000,</p><p class="source-code">        countDownInterval = 1000)</p><p class="source-code">    override fun onResume(owner: LifecycleOwner) {</p><p class="source-code">        super.onResume(owner)</p><p class="source-code"><strong class="bold">        if (timer.lastKnownTime &gt; 0) {</strong></p><p class="source-code"><strong class="bold">            timer.cancel()</strong></p><p class="source-code"><strong class="bold">            timer = InternalTimer(</strong></p><p class="source-code"><strong class="bold">                onTick = onTick,</strong></p><p class="source-code"><strong class="bold">                onFinish = onFinish,</strong></p><p class="source-code"><strong class="bold">                millisInFuture = timer.lastKnownTime,<a id="_idTextAnchor356"/></strong></p><p class="source-code"><strong class="bold">                countDownInterval = 1000)</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">    override fun onPause(owner: LifecycleOwner) { […] }</p><p class="source-code">    fun stop() { timer.cancel() }</p><p class="source-code">    class InternalTimer(…) : CountDownTimer(…) {…}</p><p class="source-code">}</p></li>
			</ol>
			<p>With<a id="_idIndexMarker1103"/> this behavior, when <strong class="source-inline">MainActivity</strong> is resumed, we are creating a new <strong class="source-inline">InternalTimer</strong> instance that starts off the countdown from the value that the previous timer recorded before being paused. Also, note that the new instance of <strong class="source-inline">InternalTimer</strong> receives the same parameters as the first initialization of the <strong class="source-inline">timer</strong> variable – the same <strong class="source-inline">onTick()</strong> and <strong class="source-inline">onFinish()</strong> callbacks and the same <strong class="source-inline">countDownInterval</strong> – the only difference is the starting point of the countdown, which should now be less than 60 seconds.</p>
			<p>For the <strong class="source-inline">onPause()</strong> and <strong class="source-inline">onResume()</strong> callbacks of the <strong class="source-inline">CustomCountdown</strong> class to be called when their corresponding lifecycle events are called inside <strong class="source-inline">MainActivity</strong>, we must effectively bind our <strong class="source-inline">DefaultLifecycleObserver</strong> – that is, the <strong class="source-inline">CustomCountdown</strong> instance – to the lifecycle of our <strong class="source-inline">LifecycleOwner</strong> – that is, <strong class="source-inline">MainActivity</strong>.</p>
			<p>Let's do that next.</p>
			<ol>
				<li value="5">Go back in<a id="_idTextAnchor357"/>side the <strong class="source-inline">RepositoriesScreen.kt</strong> file, and inside the <strong class="source-inline">CountdownItem()</strong> composable, first obtain the <strong class="source-inline">LifecycleOwner</strong> instance that the composable function belongs to by tapping into the <strong class="source-inline">LocalLifeCycleOwner</strong> API and then get the owner by accessing its <strong class="source-inline">current</strong> variable:<p class="source-code">@Composable</p><p class="source-code"><a id="_idTextAnchor358"/>private fun CountdownItem (timerText: String) {</p><p class="source-code"><strong class="bold">    val lifecycleOwner: LifecycleOwner  = </strong></p><p class="source-code"><strong class="bold">        LocalLifecycleOwner.current</strong></p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
			</ol>
			<p>Finally, we've stored the <strong class="source-inline">LifecycleOwner</strong> instance into the <strong class="source-inline">lifecycleOwner</strong> variable.</p>
			<p>It's<a id="_idIndexMarker1104"/> important to mention that since the parent composable of <strong class="source-inline">CountdownItem()</strong> – that is, <strong class="source-inline">RepositoriesScreen()</strong> – is hosted by <strong class="source-inline">MainActivity</strong>, it's only natural that the <strong class="source-inline">LifecycleOwner</strong> instance that we have obtained is in fact <strong class="source-inline">MainActivity</strong>.</p>
			<ol>
				<li value="6">Then, we need to make sure that the <strong class="source-inline">Lifecycle</strong> instance of our <strong class="source-inline">lifecycleOwner</strong> adds and removes our <strong class="source-inline">DefaultLifecycleObserver</strong> timer.</li>
			</ol>
			<p>To achieve that, we need to first create a composition side effect that allows us to know when the <strong class="source-inline">CountdownItem()</strong> composable first entered composition so that we can add the observer, and then when it was removed from composition so that we can remove the observer.</p>
			<p>For such a case, we can use the <strong class="source-inline">DisposableEffect()</strong> composable, which provides us with a block of code where we can perform actions when the composable enters composition, and then perform other actions when the composable leaves composition through its inner <strong class="source-inline">onDispose()</strong> block:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun CountdownItem (timerText: String) {</p>
			<p class="source-code">    val lifecycleOwner: LifecycleOwner = </p>
			<p class="source-code">        LocalLifecycleOwner.current</p>
			<p class="source-code"><strong class="bold">    DisposableEffect(key1 = lifecycleOwn<a id="_idTextAnchor359"/>er) {</strong></p>
			<p class="source-code"><strong class="bold">        onDispose {</strong></p>
			<p class="source-code">            </p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    Text(timerText)</p>
			<p class="source-code">}</p>
			<p>Since <a id="_idIndexMarker1105"/>this is a side effect, anything we add inside the block of code exposed by the <strong class="source-inline">DisposableEffect</strong> function will not be re-executed upon recomposition. However, this effect will be restarted if the value provided to the <strong class="source-inline">key1</strong> parameter changes. In our case, we want this effect to be restarted if the value of <strong class="source-inline">lifecycleOwner</strong> changes - this will allow us to have access to the correct <strong class="source-inline">lifecycleOwner</strong> instance inside this side-effect composable.</p>
			<ol>
				<li value="7">Now that we know when and where we can add and then remove the observer, let's first obtain the <strong class="source-inline">Lifecycle</strong> object from the <strong class="source-inline">lifecycleOwner</strong> variable so that we can store it inside the <strong class="source-inline">lifecycle</strong> variable:<p class="source-code">@Composable</p><p class="source-code">private fun CountdownItem(timerText: String) {</p><p class="source-code">    val lifecycleOwner: Life<a id="_idTextAnchor360"/>cycleOwner = </p><p class="source-code">        LocalLifecycleOwner.current</p><p class="source-code"><strong class="bold">    val lifecycle = lifecycleOwner.lifecycle</strong></p><p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p><p class="source-code">        onDispose {</p><p class="source-code">        </p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
			</ol>
			<p>Next, on the <strong class="source-inline">Lifecycle</strong> object from within the <strong class="source-inline">lifecycle</strong> variable, we will add and remove the observer.</p>
			<ol>
				<li value="8">Inside the<a id="_idIndexMarker1106"/> block of code exposed by the <strong class="source-inline">DisposableEffect()</strong> composable, add the observer on the <strong class="source-inline">lifecycle</strong> variable by calling its <strong class="source-inline">addObserver()</strong> method, and then inside its exposed <strong class="source-inline">onDispose()</strong> callback, remove it with the <strong class="source-inline">removeObserver()</strong> method:<p class="source-code">@Composable</p><p class="source-code">private fun CountdownItem(timerText: String) {</p><p class="source-code">    val lifecycleOwner: LifecycleOwner </p><p class="source-code">        = LocalLifecycleOwner.current</p><p class="source-code">    val lifecycle = lifecycleOwner.lifecycle<a id="_idTextAnchor361"/></p><p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p><p class="source-code"><strong class="bold">        l<a id="_idTextAnchor362"/>ifecycle.addObserver()</strong></p><p class="source-code">        onDispose {</p><p class="source-code"><strong class="bold">            lifecycle.removeObserver()</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
			</ol>
			<p>With this approach, when the <strong class="source-inline">CountdownItem()</strong> composable is first composed, we will make our countdown component observe the lifecycle events of <strong class="source-inline">MainActivity</strong>. Then, when the <strong class="source-inline">CountdownItem()</strong> leaves composition, our countdown component will no longer observe such events.</p>
			<p>However, you might have noticed that both the <strong class="source-inline">addObserver()</strong> and <strong class="source-inline">removeObserver()</strong> methods expect a <strong class="source-inline">LifecycleObserver</strong> object, but we didn't provide any.</p>
			<p>In fact, we should have passed the <strong class="source-inline">CustomCountdown</strong> instance to the <strong class="source-inline">addObserver()</strong> and <strong class="source-inline">removeObserver()</strong> methods because <strong class="source-inline">CustomCountdown</strong> is the component that implements <strong class="source-inline">DefaultLifecycleObserver</strong> and that we want to react to the lifecycle changes of our <strong class="source-inline">MainActivity</strong>.</p>
			<p>Next, let's obtain the <strong class="source-inline">CustomCountdown</strong> instance.</p>
			<ol>
				<li value="9">Update<a id="_idIndexMarker1107"/> the <strong class="source-inline">CountdownItem()</strong> function definition to receive a <strong class="source-inline">getTimer()</strong> function parameter that returns a <strong class="source-inline">CustomCountdown</strong> timer. This callback method should be called to provide the <strong class="source-inline">addObserver()</strong> and <strong class="source-inline">removeObserver()</strong> methods with a <strong class="source-inline">LifecycleObserver</strong> instance:<p class="source-code">@Composable</p><p class="source-code">private fun Coun<a id="_idTextAnchor363"/>tdownItem(timerText: String, </p><p class="source-code">    <strong class="bold">getTimer: () -&gt; CustomCountdown</strong>) {</p><p class="source-code">    val lifecycleOwner: LifecycleOwner </p><p class="source-code">        = LocalLifecycleOwner.current</p><p class="source-code">    val lifecycle = lifecycleOwner.lifecycle</p><p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p><p class="source-code">        lifecycle.addObserver(<strong class="bold">getTimer())</strong></p><p class="source-code">        onDispose {</p><p class="source-code">            lifecycle.removeObserver(<strong class="bold">getTimer())</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
			</ol>
			<p>Since the <strong class="source-inline">CustomCountdown</strong> class implements <strong class="source-inline">DefaultLifecycleObserver</strong>, which extends <strong class="source-inline">FullLifecycleObserver</strong>, which in turn extends <strong class="source-inline">LifecycleObserver</strong>, the <strong class="source-inline">addObserver()</strong> and <strong class="source-inline">removeObserver()</strong> methods accept our <strong class="source-inline">CustomCountdown</strong> instance as an observer to the <strong class="source-inline">Lifecycle</strong> object of our <strong class="source-inline">lifecycleOwner</strong> – that is, <strong class="source-inline">MainActivity</strong>.</p>
			<ol>
				<li value="10">Since <strong class="source-inline">CountdownItem()</strong> now expects a <strong class="source-inline">getTimer: ()-&gt; CustomCountdown</strong> callback<a id="_idIndexMarker1108"/> function, we must also force our <strong class="source-inline">RepositoriesScreen()</strong> composable to accept such a callback function as well and then pass it to our <strong class="source-inline">CountdownItem()</strong> composable:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;,</p><p class="source-code">    timerText: String,</p><p class="source-code">    <strong class="bold">getTimer: () -&gt; CustomCountdown</strong></p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        item {</p><p class="source-code">            CountdownItem(timerText, <strong class="bold">getTimer</strong>)</p><p class="source-code">        }</p><p class="source-code">        itemsIndexed(repos) { … }</p><p class="source-code">        […]</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Lastly, inside <strong class="source-inline">MainActivity</strong>, update the <strong class="source-inline">RepositoriesScreen()</strong> composable<a id="_idIndexMarker1109"/> call to provide a <strong class="source-inline">getTimer()</strong> function implementation, where we will get the <strong class="source-inline">CustomCountdown</strong> instance from the <strong class="source-inline">viewModel</strong> variable through its <strong class="source-inline">timer</strong> field:<p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            RepositoriesAppTheme {</p><p class="source-code">                […]</p><p class="source-code">                RepositoriesScreen(</p><p class="source-code">                    lazyRepoItems, </p><p class="source-code">                    timerText<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">          <a id="_idTextAnchor364"/>          getTimer = {viewModel.timer}</strong></p><p class="source-code">                <strong class="bold">)</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>We have finally tied our <strong class="source-inline">DefaultLifecycleObserver</strong> – that is, the <strong class="source-inline">CustomCountdown</strong> instance – to the lifecycle of our <strong class="source-inline">LifecycleOwner</strong> – that is, <strong class="source-inline">MainActivity</strong>. Now that the <strong class="source-inline">CustomCountdown</strong> class should react to the lifecycle events of our <strong class="source-inline">MainActivity</strong>, let's test our problematic scenario from before.</p>
			<ol>
				<li value="12">Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and put the app in background.</li>
				<li>Wait for a few seconds and then bring the app back to foreground.</li>
			</ol>
			<p>You <a id="_idIndexMarker1110"/>should now notice that while the app was in background, the countdown was paused. We wanted the timer to be paused when the app was put in background and then resumed when the app was brought back to foreground – and now this is happening! We can now award the prize to users that actively use the app.</p>
			<p>However, there is still an edge case that we haven't covered. Let's discover it:</p>
			<ol>
				<li value="1">Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and then quickly scroll down past four or five repositories within the list until the countdown is not visible anymore.</li>
				<li>Wait for a few seconds and then scroll back up to the top of the list so that the countdown is visible again.</li>
			</ol>
			<p>Note that after we scrolled down, while the timer wasn't visible, the countdown kept going. We wanted the timer to be paused when the timer isn't visible anymore and then resumed when the timer is visible again – this would have allowed us to award the prize to users that have the countdown timer visible so that they didn't cheat on our contest. This behavior didn't occur, as the timer kept on counting while the timer wasn't visible.</p>
			<p>This is happening because we didn't do anything to pause the timer when the timer composable leaves <a id="_idIndexMarker1111"/>composition or resume it when the timer composable is composed again. In other words, our countdown timer is not aware of the lifecycle of our timer composable.</p>
			<p>Next, let's make our countdown timer aware of Compose composition cycles so that users don't cheat in our contest.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor365"/>Making our countdown component aware of the lifecycle of composables</h1>
			<p>The main issue is that our <strong class="source-inline">CustomCountdown</strong> component still runs its countdown even after the <strong class="source-inline">CountdownItem()</strong> composable leaves composition. We want to pause the timer when its corresponding composable is not visible anymore. With such an approach, we<a id="_idIndexMarker1112"/> can prevent users from cheating, and we can award the prize only to users that have had the countdown timer visible for the full amount of time. Basically, if the timer is not visible anymore, the countdown should stop.</p>
			<p>To pause the timer when its corresponding composable function leaves composition, we must somehow call the <strong class="source-inline">stop()</strong> function exposed by <strong class="source-inline">CustomCountdown</strong>. But when should we do that?</p>
			<p>If you look inside the body of the <strong class="source-inline">CountdownItem()</strong> composable, you will notice that we have already registered a <strong class="source-inline">DisposableEffect()</strong> composable that notifies us when the <strong class="source-inline">CountdownItem()</strong> composable leaves composition by exposing the <strong class="source-inline">onDispose()</strong> callback:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun CountdownItem(…) {</p>
			<p class="source-code">    val lifecycleOwner: […] = LocalLifecycleOwner.current</p>
			<p class="source-code">    val lifecycle = lifecycleOwner.lifecycle</p>
			<p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p>
			<p class="source-code">        lifecycle.addObserver(getTimer())</p>
			<p class="source-code"><strong class="bold">        onDispose {</strong></p>
			<p class="source-code">            lifecycle.removeObserver(getTimer())</p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    Text(timerText)</p>
			<p class="source-code">}</p>
			<p>When the <a id="_idIndexMarker1113"/>composable leaves composition, inside the <strong class="source-inline">onDispose()</strong> callback, we are already removing the <strong class="source-inline">CustomCountdown</strong> as an observer to the lifecycle of our <strong class="source-inline">MainActivity</strong>. Exactly at this point, we can also pause the timer because the composable leaves composition:</p>
			<ol>
				<li value="1">Update the <strong class="source-inline">CountdownItem()</strong> function definition to accept a new <strong class="source-inline">onPauseTimer()</strong> callback function and then make sure to call it inside the <strong class="source-inline">onDispose()</strong> callback of <strong class="source-inline">DisposableEffect()</strong>:<p class="source-code">@Composable</p><p class="source-code">private fun CountdownItem(timerText: String,</p><p class="source-code">    getTimer: () -&gt; CustomCountdown,</p><p class="source-code">    <strong class="bold">onPauseTimer: () -&gt; Unit</strong>) {</p><p class="source-code">    val lifecycleOwner: […] = LocalLifecycleOwner.current</p><p class="source-code">    val lifecycle = lifecycleOwner.lifecycle</p><p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p><p class="source-code">        life<a id="_idTextAnchor366"/>cycle.addObserver(getTimer())</p><p class="source-code">        onDispose {</p><p class="source-code"><strong class="bold">            onPauseTimer()</strong></p><p class="source-code">            lifecycle.removeObserver(getTimer())</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    Text(timerText)</p><p class="source-code">}</p></li>
				<li>Since <strong class="source-inline">CountdownItem()</strong> now expects an <strong class="source-inline">onPauseTimer: () -&gt; Unit</strong> callback function, we must also force our <strong class="source-inline">RepositoriesScreen()</strong> composable to <a id="_idIndexMarker1114"/>accept such a callback function and then pass it to our <strong class="source-inline">CountdownItem()</strong> composable:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;,</p><p class="source-code">    timerText: String,</p><p class="source-code">    getTimer: () -&gt; CustomCountdown,</p><p class="source-code">    <strong class="bold">onPauseTimer: () -&gt; Unit</strong></p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        item {</p><p class="source-code">            CountdownItem(</p><p class="source-code">                timerText, </p><p class="source-code">                getTimer,</p><p class="source-code">                <strong class="bold">onPauseTimer</strong></p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">        itemsIndexed(repos) { … }</p><p class="source-code">        […]</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Lastly, inside <strong class="source-inline">MainActivity</strong>, update the <strong class="source-inline">RepositoriesScreen()</strong> composable call to provide an <strong class="source-inline">onPauseTimer()</strong> function implementation, where we will pause<a id="_idIndexMarker1115"/> the timer by calling the <strong class="source-inline">stop()</strong> method of the <strong class="source-inline">CustomCountdown</strong> instance obtained from the <strong class="source-inline">viewModel</strong> variable through its <strong class="source-inline">timer</strong> field:<p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            RepositoriesAppTheme {</p><p class="source-code">                […]</p><p class="source-code">                RepositoriesScreen(lazyRepoItems, </p><p class="source-code">                    timerText,</p><p class="source-code">        <a id="_idTextAnchor367"/>            getTimer = { viewModel.timer }<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">                    onPauseTimer = </strong></p><p class="source-code"><strong class="bold">                        { viewModel.timer.stop() }</strong></p><p class="source-code"><strong class="bold">                )</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Build and run the app. The countdown should have started from 60 again at this point.</li>
				<li>Before the countdown finishes, remember or write down somewhere the current countdown value and then quickly scroll down past four or five repositories within the list until the countdown is not visible anymore. Make sure to scroll past a few repositories so that Compose removes the node of the timer composable – if you scroll just a bit, the node of the timer won't be removed.</li>
				<li>Wait for a<a id="_idIndexMarker1116"/> few seconds and then scroll back up to the top of the list so that the countdown is visible again.</li>
			</ol>
			<p>Note that the timer was now paused while the <strong class="source-inline">CountdownItem()</strong> composable was not visible. We have now achieved the desired effect!</p>
			<p>But how come the countdown is resumed when the composable becomes visible again? We didn't do anything to cover that case – we only stopped the timer when the <strong class="source-inline">CountdownItem()</strong> composable left composition, but we didn't resume it when it became visible again as it re-entered composition.</p>
			<p>Fortunately, the timer is resumed out of the box when the <strong class="source-inline">CountdownItem()</strong> composable re-enters composition – but why is this happening?</p>
			<p>This behavior is exhibited because of an interesting side effect provided by the Lifecycle APIs. More precisely, as soon as we're binding the <strong class="source-inline">LifecycleObserver</strong> instance to the <strong class="source-inline">Lifecycle</strong> instance of our <strong class="source-inline">LifecycleOwner</strong>, the observer instantly receives as a first event the event corresponding to the current state of <strong class="source-inline">LifecycleOwner</strong>.</p>
			<p>Let's have a look inside the <strong class="source-inline">CountdownItem()</strong> composable and see how this could be happening:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">private fun CountdownItem(timerText: String,</p>
			<p class="source-code">    getTimer: () -&gt; CustomCountdown,</p>
			<p class="source-code">    onPauseTimer: () -&gt; Unit) {</p>
			<p class="source-code">    val lifecycleOwner: LifecycleOwner</p>
			<p class="source-code">                = LocalLifecycleOwner.current</p>
			<p class="source-code">    val lifecycle = lifecycleOwner.lifecycle</p>
			<p class="source-code">    DisposableEffect(key1 = lifecycleOwner) {</p>
			<p class="source-code"><strong class="bold">        lifecycle.addObserver(getTimer())</strong></p>
			<p class="source-code">        onDispose {</p>
			<p class="source-code">            onPauseTimer()</p>
			<p class="source-code">            lifecycle.removeObserver(getTimer())</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Text(timerText)</p>
			<p class="source-code">}</p>
			<p>In our case, as soon as we're binding the <strong class="source-inline">DefaultLifecycleObserver</strong> instance – that is, <strong class="source-inline">CustomCountdown</strong> – to the <strong class="source-inline">Lifecycle</strong> of the <strong class="source-inline">LifecycleOwner</strong> instance – that is, <strong class="source-inline">MainActivity</strong> – the observer receives as a first event the event corresponding to the current state.</p>
			<p>In other <a id="_idIndexMarker1117"/>words, as soon as our timer composable is visible, we're adding the timer as an observer to the lifecycle of our <strong class="source-inline">MainActivity</strong> class. At that point, the <strong class="source-inline">RESUMED</strong> state is the current state of <strong class="source-inline">MainActivity</strong>, so the <strong class="source-inline">onResume()</strong> callback is triggered inside the <strong class="source-inline">CustomCountdown</strong> component, which effectively resumes the timer countdown in our specific scenario:</p>
			<p class="source-code">class CustomCountdown([…]): DefaultLifecycleObserver {</p>
			<p class="source-code">    var timer: InternalTimer = InternalTimer(…)</p>
			<p class="source-code"><strong class="bold">    override fun onResume(owner: LifecycleOwner) {</strong></p>
			<p class="source-code"><strong class="bold">        super.onResume(owner)</strong></p>
			<p class="source-code"><strong class="bold">        if (timer.lastKnownTime &gt; 0) {</strong></p>
			<p class="source-code"><strong class="bold">            timer.cancel()</strong></p>
			<p class="source-code"><strong class="bold">            timer = InternalTimer(</strong></p>
			<p class="source-code"><strong class="bold">                onTick = onTick,</strong></p>
			<p class="source-code"><strong class="bold">                onFinish = onFinish,</strong></p>
			<p class="source-code"><strong class="bold">                millisInFuture = timer.lastKnownTime,</strong></p>
			<p class="source-code"><strong class="bold">                countDownInterval = 1000)</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    override fun onPause(owner: LifecycleOwner) { […] }</p>
			<p class="source-code">    fun stop() { timer.cancel() }</p>
			<p class="source-code">    class InternalTimer(…) : CountDownTimer(…) {…}</p>
			<p class="source-code">}</p>
			<p>We have now <a id="_idIndexMarker1118"/>made our countdown timer aware of the Compose composition cycles as well.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor368"/>Summary</h1>
			<p>In this chapter, we understood what a lifecycle-aware component is and how we can create one.</p>
			<p>We first explored how the lifecycle events and states are tied to Android components, such as <strong class="source-inline">Activity</strong> or <strong class="source-inline">Fragment</strong>, and then how predefined components from the <strong class="source-inline">Lifecycle</strong> package can react to them. Then, we created and added a countdown timer component to the Repositories app.</p>
			<p>Finally, we prevented users from cheating by making our timer component aware not only of the different lifecycle events and states of <strong class="source-inline">Activity</strong> components but also of the lifecycle of composables.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor369"/>Further reading</h1>
			<p>In this chapter, we briefly covered how to create a lifecycle-aware component by making our <strong class="source-inline">CustomCountdown</strong> component aware of the lifecycle events that <strong class="source-inline">MainActivity</strong> exhibits. However, when needed, we can also tap into the lifecycle states of <strong class="source-inline">LifecycleOwner</strong>. To understand how you can do that, check out the official docs for an example: <a href="https://developer.android.com/topic/libraries/architecture/lifecycle#lco">https://developer.android.com/topic/libraries/architecture/lifecycle#lco</a>.</p>
		</div>
	</body></html>