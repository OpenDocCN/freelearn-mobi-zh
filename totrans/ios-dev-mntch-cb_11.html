<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Graphics and Animation</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating views</li><li class="listitem" style="list-style-type: disc">Transforming views</li><li class="listitem" style="list-style-type: disc">Animation with images</li><li class="listitem" style="list-style-type: disc">Animating layers</li><li class="listitem" style="list-style-type: disc">Drawing lines and curves</li><li class="listitem" style="list-style-type: disc">Drawing shapes</li><li class="listitem" style="list-style-type: disc">Drawing text</li><li class="listitem" style="list-style-type: disc">A simple drawing application</li><li class="listitem" style="list-style-type: disc">Creating an image context</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec01"/>Introduction</h1></div></div></div><p>In this chapter, we are going to discuss about custom drawing and animations. The iOS SDK contains two very useful frameworks for these tasks: Core Graphics and Core Animation.<a id="id845" class="indexterm"/>
</p><p>These two frameworks simplify the process of animating UI elements and drawing 2D graphics on them. The effective usage of these two frameworks will make a difference between a dull and a stunning application. After all, these two frameworks play a very important role in making the iOS platform unique in its kind.</p><p>We will learn how to provide simple or even more complicated animations for controls to provide a unique user experience. We will also see how to custom draw lines, curves, shapes, and text on the screen. Finally, with all the examples provided, we will create two drawing applications.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec02"/>Animating Views</h1></div></div></div><p>In this recipe, we will learn how to take advantage of<code class="literal"> UIKit</code> animations to move a<code class="literal"> UILabel</code> on the screen.<a id="id846" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec01"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> ViewAnimationApp</code>. Add a label and a button on the view of<code class="literal"> MainController</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the<code class="literal"> MonoTouch.ObjCRuntime</code> namespace, and enter the following<code class="literal"> ViewDidLoad</code> override:<a id="id847" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.lblOutput.BackgroundColor = UIColor.Green;
this.buttonAnimate.TouchUpInside += delegate {
RectangleF labelFrame = this.lblOutput.Frame;
labelFrame.Y = 380f;
UIView.BeginAnimations("LabelPositionAnimation");
UIView.SetAnimationDuration(1);
UIView.SetAnimationCurve(UIViewAnimationCurve.EaseInOut);
UIView.SetAnimationDelegate(this);
UIView.SetAnimationDidStopSelector(new Selector("LabelPositionAnimationStopped"));
this.lblOutput.Frame = labelFrame;
UIView.CommitAnimations();
};
}
</pre></div></li><li class="listitem"> Add the following method:<div><pre class="programlisting">[Export("LabelPositionAnimationStopped")]
public void LabelAnimationStopped(){
this.lblOutput.Text = "Animation ended!";
this.lblOutput.BackgroundColor = UIColor.Red;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap on the<strong> Animate!</strong> button, and watch the label move to the lower part of the view.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec03"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIView</code> class contains a number of various static methods that are targeted to animations. In this example, we simply change the position of a label with an animation.<a id="id848" class="indexterm"/>
</p><p>To animate the change of position, we need to apply the changes after a call to the<code class="literal"> BeginAnimations</code> method:<a id="id849" class="indexterm"/>
</p><div><pre class="programlisting">UIView.BeginAnimations("LabelPositionAnimation");
</pre></div><p>It accepts one string parameter, which declares the name of the animation. Changes we make to views after this call will be animated. But, we can also adjust various animation parameters:</p><div><pre class="programlisting">UIView.SetAnimationDuration(1);
UIView.SetAnimationCurve(UIViewAnimationCurve.EaseInOut);
</pre></div><p>The<code class="literal"> SetAnimationDuration</code> method defines the duration of the animation in seconds. The<code class="literal"> SetAnimationCurve</code> method defines the default easing functions that will be applied to the animation at its start point and/or its end point.<a id="id850" class="indexterm"/>
</p><p>We have the option of executing code when the animation completes. To do this, we first need to set the animation delegate object with the<code class="literal"> SetAnimationDelegate</code> method:<a id="id851" class="indexterm"/>
</p><div><pre class="programlisting">UIView.SetAnimationDelegate(this);
</pre></div><p>In this example, we set our controller object,<code class="literal"> MainController</code>, as the animation delegate object. After setting the delegate object, we need to set the selector that will be called when the animation completes:</p><div><pre class="programlisting">UIView.SetAnimationDidStopSelector(new Selector("LabelPositionAnimationStopped"));
</pre></div><p>To create a<code class="literal"> Selector</code> instance, we need to use the<code class="literal"> MonoTouch.ObjCRuntime</code> namespace:<a id="id852" class="indexterm"/>
</p><div><pre class="programlisting">using MonoTouch.ObjCRuntime;
</pre></div><p>After making all the adjustments for our animation, we set the new value to the object that will be animated and call the<code class="literal"> CommitAnimations</code> method:<a id="id853" class="indexterm"/>
</p><div><pre class="programlisting">this.lblOutput.Frame = labelFrame;
UIView.CommitAnimations();
</pre></div><p>Note that the code below the<code class="literal"> BeginAnimations</code> call will be executed at the<code class="literal"> CommitAnimations</code> line. Also, every animation started with the<code class="literal"> BeginAnimations</code> method should have a corresponding call to the<code class="literal"> CommitAnimations</code> method, or unexpected results will occur; for example, every change that is made to UI elements will be animated.<a id="id854" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec04"/>There's more...</h2></div></div></div><p>The<code class="literal"> UIView</code> class also contains an overloaded<code class="literal"> Animate</code> method. This method basically wraps all the methods we used here in one. The previous example, with the<code class="literal"> Animate</code> method, is represented with the following code:<a id="id855" class="indexterm"/>
</p><div><pre class="programlisting">UIView.Animate(1, 0, UIViewAnimationOptions.CurveEaseInOut, delegate { this.lblOutput.Frame = labelFrame; }, delegate { this.LabelAnimationStopped(); } );
</pre></div><p>The second parameter of this overload is the delay after which the animation will start.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec01"/>UIKit animations and iOS versions</h3></div></div></div><p>The<code class="literal"> Animate</code> method was introduced on iOS version 4.0. When targeting an iOS version prior to 4, use the animation block, as defined by the<code class="literal"> BeginAnimations</code> and<code class="literal"> CommitAnimations</code> methods.<a id="id856" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec02"/>Animatable properties</h3></div></div></div><p>
<code class="literal">UIKit</code> animations support a specific set of<code class="literal"> UIView</code> properties. These properties are called<strong> animatable</strong> properties. Following is a list of<code class="literal"> UIView</code> properties that can be animated:<a id="id857" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Frame</code><a id="id858" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Bounds</code><a id="id859" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Center</code><a id="id860" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Transform</code><a id="id861" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Alpha</code><a id="id862" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">BackgroundColor</code><a id="id863" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContentStretch</code><a id="id864" class="indexterm"/></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec03"/>Transforming views</h1></div></div></div><p>In this recipe, we will rotate a<code class="literal"> UILabel</code> by applying a transformation. Furthermore, the rotation will be animated.<a id="id865" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec05"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> TransformViewApp</code>. Add a label and a button on the view of<code class="literal"> MainController</code>.<a id="id866" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec06"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the<code class="literal"> MonoTouch.CoreGraphics</code> namespace:<div><pre class="programlisting">using MonoTouch.CoreGraphics;
</pre></div></li><li class="listitem"> Enter the following code in the<code class="literal"> MainController</code> class:<div><pre class="programlisting">private double rotationAngle;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.buttonRotate.TouchUpInside += delegate {
this.rotationAngle += 90;
CGAffineTransform transform = CGAffineTransform.MakeRotation( (float)this.DegreesToRadians(this.rotationAngle));
UIView.BeginAnimations("RotateLabelAnimation");
UIView.SetAnimationDuration(0.5f);
this.lblOutput.Transform = transform;
UIView.CommitAnimations();
this.lblOutput.Text = string.Format("Rotated to {0} degrees.", this.rotationAngle);
if (this.rotationAngle &gt;= 360){
this.rotationAngle = 0;
this.lblOutput.Transform = CGAffineTransform.MakeIdentity();
}
};
}
public double DegreesToRadians (double degrees){
return (degrees * Math.PI / 180);
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap the button and watch the label rotate.</li></ol></div><div><img src="img/1468EXP_11_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec07"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.CoreGraphics</code> namespace is a wrapper around the<code class="literal"> CoreGraphics</code> framework. This framework is the basic graphics framework of iOS.<a id="id867" class="indexterm"/>
</p><p>To rotate a view, we need a transformation object that will be applied to the view through its<code class="literal"> Transform</code> property:</p><div><pre class="programlisting">CGAffineTransform transform = CGAffineTransform.MakeRotation( (float)this.DegreesToRadians(this.rotationAngle));
</pre></div><p>The transformation object is an instance of the class<code class="literal"> CGAffineTransform</code> and is initialized through the<code class="literal"> MakeRotation</code> static method. This method accepts a float value of the angle of rotation that we want to be applied, in radians. The<code class="literal"> DegreesToRadians</code> method can be used to convert degrees to radians. After creating the transformation object, we assign it to the label's<code class="literal"> Transform</code> property inside an animation block:<a id="id868" class="indexterm"/>
</p><div><pre class="programlisting">UIView.BeginAnimations("RotateLabelAnimation");
UIView.SetAnimationDuration(0.5f);
this.lblOutput.Transform = transform;
UIView.CommitAnimations();
</pre></div><p>Note that we need to increment the rotation angle each time the button is pressed, because the transformation we apply is not being auto-incremented. If we apply another rotation transformation object with the same angle, there will be no effect since it is basically the same transformation.</p><p>When the label has been rotated to a full circle (=360 degrees), we reset the<code class="literal"> rotationAngle</code> value and the transformation object:</p><div><pre class="programlisting">this.rotationAngle = 0;
this.lblOutput.Transform = CGAffineTransform.MakeIdentity();
</pre></div><p>The<code class="literal"> MakeIdentity</code> static method creates an identity transformation object, which is the default transformation of all views, before applying transformation objects to them.<a id="id869" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec08"/>There's more...</h2></div></div></div><p>The<code class="literal"> CGAffineTransform</code> class contains various static methods for creating transformation objects. These are:<a id="id870" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CGAffineTransformInvert:</code> This method inverts a current transformation and returns the result<a id="id871" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeIdentity:</code> This method creates an identity transformation<a id="id872" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeRotation:</code> This method creates a rotation transformation<a id="id873" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeScale:</code> This method creates a scale transformation<a id="id874" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeTranslation:</code> This method creates a translation transformation<a id="id875" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">Multiply:</code> This method multiplies two transformations and returns the result<a id="id876" class="indexterm"/></li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec03"/>Transformation and frame</h3></div></div></div><p>After applying transformations on a view, its<code class="literal"> Frame</code> property must not be taken into account. If there is a need for altering the view's size or position after a transformation has been applied, use the<code class="literal"> Bounds</code> and<code class="literal"> Center</code> properties, respectively.<a id="id877" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec09"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Animating views</em></li><li class="listitem" style="list-style-type: disc"><em>Animating layers</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec04"/>Animation with images</h1></div></div></div><p>In this recipe, we will create a simple slideshow of images using the built-in animation feature of<code class="literal"> UIImageView</code>.<a id="id878" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec10"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> ImageAnimationApp</code>. Add a<code class="literal"> UIImageView</code> and two buttons on the view of<code class="literal"> MainController</code>. The sample project for this task contains three images. Add two or more images to the project, and set their<strong> Build Action</strong> to<strong> Content</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec11"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Enter the following<code class="literal"> ViewDidLoad</code> override:<a id="id879" class="indexterm"/><div><pre class="programlisting">public override void ViewDidLoad (){
base.ViewDidLoad ();
this.imageView.ContentMode = UIViewContentMode.ScaleAspectFit;
this.imageView.AnimationImages = new UIImage[] {
UIImage.FromFile("images/Kastoria.jpg"),
UIImage.FromFile("images/Parga02.jpg"),
UIImage.FromFile("images/Toroni.jpg")
} ;
this.imageView.AnimationDuration = 3;
this.imageView.AnimationRepeatCount = 10;
this.buttonAnimate.TouchUpInside += delegate {
if (!this.imageView.IsAnimating){
this.imageView.StartAnimating();
}
};
this.buttonStop.TouchUpInside += delegate {
if (this.imageView.IsAnimating){
this.imageView.StopAnimating();
}
};
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap the<strong> Animate images</strong> button to start the animation.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec12"/>How it works...</h2></div></div></div><p>The<code class="literal"> UIImageView</code> can accept an array of<code class="literal"> UIImage</code> objects and automatically display them in a sequence.</p><p>To load the images that the view will animate, assign an array of the images to its<code class="literal"> AnimationImages</code> property:<a id="id880" class="indexterm"/>
</p><div><pre class="programlisting">this.imageView.AnimationImages = new UIImage[] {
UIImage.FromFile("images/Kastoria.jpg"),
UIImage.FromFile("images/Parga02.jpg"),
UIImage.FromFile("images/Toroni.jpg")
} ;
</pre></div><p>The sequence in which the images will be displayed is defined by their order in the array. After setting the images that will be animated, we set the duration of the animation in seconds and the number of times it will occur:</p><div><pre class="programlisting">this.imageView.AnimationDuration = 3;
this.imageView.AnimationRepeatCount = 10;
</pre></div><p>To start or stop the animation, call the<code class="literal"> StartAnimating</code> or<code class="literal"> StopAnimating</code> methods, respectively.<a id="id881" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec13"/>There's more...</h2></div></div></div><p>There is no relation between the<code class="literal"> AnimationImages</code> and<code class="literal"> Image</code> properties of the<code class="literal"> UIImageView</code> class. Set an image to be displayed to the<code class="literal"> Image</code> property before or after an animation, if one needs to be displayed when no animation takes place.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec04"/>Checking for animation</h3></div></div></div><p>To determine if an animation takes place, check the<code class="literal"> IsAnimating</code> property of<code class="literal"> UIImageView</code>.<a id="id882" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec14"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Animating views</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>, User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Displaying images</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec05"/>Animating layers</h1></div></div></div><p>In this recipe, we will learn how to use the<code class="literal"> Core Animation</code> framework to copy a<code class="literal"> UILabel</code> on the screen, by animating its layer.<a id="id883" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec15"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> LayerAnimation</code>. Add two labels and a button on the view of<code class="literal"> MainController</code>. Set text and background color for the first view and a different background color for the second view.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec16"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add<code class="literal"> MonoTouch.CoreAnimation</code> namespace:<div><pre class="programlisting">using MonoTouch.CoreAnimation;
</pre></div></li><li class="listitem"> Add a field of the type<code class="literal"> CALayer</code> in the class:<div><pre class="programlisting">private CALayer copyLayer;
</pre></div></li><li class="listitem"> Add the following code in the<code class="literal"> ViewDidLoad</code> override:<a id="id884" class="indexterm"/><div><pre class="programlisting">this.buttonCopy.TouchUpInside += delegate {
this.lblTarget.Text = string.Empty;
this.lblTarget.BackgroundColor = UIColor.Blue;
this.copyLayer = new CALayer();
this.copyLayer.Frame = this.lblSource.Frame;
this.copyLayer.Contents = this.lblSource.Layer.Contents;
this.View.Layer.AddSublayer(this.copyLayer);
<strong>
CABasicAnimation positionAnimation = CABasicAnimation.FromKeyPath("position");
positionAnimation.To = NSValue.FromPointF(this.lblTarget.Center);
positionAnimation.Duration = 1;
positionAnimation.RemovedOnCompletion = true;
positionAnimation.TimingFunction = CAMediaTimingFunction.FromName( CAMediaTimingFunction.EaseInEaseOut);
positionAnimation.AnimationStopped += delegate {
this.lblTarget.BackgroundColor = this.lblSource.BackgroundColor;
this.lblTarget.Text = this.lblSource.Text;
this.lblTarget.TextColor = this.lblSource.TextColor;
this.copyLayer.RemoveFromSuperLayer();
};
CABasicAnimation sizeAnimation = CABasicAnimation.FromKeyPath("bounds");
sizeAnimation.To = NSValue.FromRectangleF(new RectangleF(0f, 0f, this.lblSource.Bounds.Width * 2f, this.lblSource.Bounds.Height * 2));
sizeAnimation.Duration = positionAnimation.Duration / 2;
sizeAnimation.RemovedOnCompletion = true;
sizeAnimation.AutoReverses = true;
</strong>
this.copyLayer.AddAnimation(positionAnimation, "PositionAnimation");
this.copyLayer.AddAnimation(sizeAnimation, "SizeAnimation");
} ;
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Tap the<strong> Copy</strong> button to copy the contents of the first label to the second label with animation.</li></ol></div><div><img src="img/1468EXP_11_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec17"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.CoreAnimation</code> namespace is a wrapper around the<code class="literal"> Core Animation</code> framework.<a id="id885" class="indexterm"/>
</p><p>Every view has a<code class="literal"> Layer</code> property, which returns the view's<code class="literal"> CALayer</code> object. In this task, we are creating an animation that graphically displays copying label contents from one label to another.</p><p>Instead of creating another label and moving it with<code class="literal"> UIView</code> animation, we will create a layer and move that instead. We create the layer by setting its<code class="literal"> Frame</code> and<code class="literal"> Contents</code> property, the latter from the source label's layer. We then add the layer to the main view's layer with the<code class="literal"> AddSublayer</code> method. After this point, the main view contains a layer, which displays the same contents and is on top of the source label.<a id="id886" class="indexterm"/>
</p><div><pre class="programlisting">this.copyLayer = new CALayer();
this.copyLayer.Frame = this.lblSource.Frame;
this.copyLayer.Contents = this.lblSource.Layer.Contents;
this.View.Layer.AddSublayer(this.copyLayer);
</pre></div><p>To animate the transition from the source label to the target label, we will use the<code class="literal"> CABasicAnimation</code> class. The previous highlighted code shows how to initialize and set up the instances of the class. The<code class="literal"> FromKeyPath</code> static method creates a new instance, accepting as a parameter the name of the layer's property that will be animated. The<code class="literal"> To</code> property represents the value the property will be animated to. The<code class="literal"> Duration</code> property represents the duration of the animation in seconds, while the<code class="literal"> RemovedOnCompletion</code> property declares that the animation object should be removed from the layer when the animation finishes. The<code class="literal"> TimingFunction</code> property sets the behavior of the animation. The<code class="literal"> AnimationStopped</code> event is triggered when the animation finishes. Inside the handler we assign to it, we set the contents of the source label to the target label, thus completing the copy. The<code class="literal"> AutoReverses</code> property states that when the value of the<code class="literal"> To</code> property has been reached, the animation should be reversed. It is this property that gives the effect of the label getting bigger and subsequently smaller when it reaches its final position.<a id="id887" class="indexterm"/>
</p><p>The animations start when they are added to the layer:</p><div><pre class="programlisting">this.copyLayer.AddAnimation(positionAnimation, "PositionAnimation");
this.copyLayer.AddAnimation(sizeAnimation, "SizeAnimation");
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec18"/>There's more...</h2></div></div></div><p>A list of strings that the<code class="literal"> FromKeyPath</code> method accepts can be found in the following link:<code class="literal"> http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CoreAnimation_guide/Articles/KVCAdditions.html#//apple_ref/doc/uid/TP40005299</code>.<a id="id888" class="indexterm"/>
</p><p>Apart from the<code class="literal"> To</code> property, the<code class="literal"> CABasicAnimation</code> class has two more properties for defining the animation:<code class="literal"> From</code> and<code class="literal"> By</code>. They are all of the type<code class="literal"> NSObject</code>, but the actual values that should be assigned to them should be of the type<code class="literal"> NSValue</code>. The<code class="literal"> NSValue</code> class contains various static methods for creating instances of it.<a id="id889" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec05"/>Layers</h3></div></div></div><p>
<strong>Layers</strong> are very powerful and efficient objects that can be used for both drawing and animations. Using layers to perform animations on views, instead of the actual views themselves, is strongly suggested.<a id="id890" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec19"/>See also</h2></div></div></div><p>In this chapter</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Animating Views</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec06"/>Drawing lines and curves</h1></div></div></div><p>In this recipe, we will implement custom drawing to draw two lines on a<code class="literal"> UIView</code>.<a id="id891" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec20"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DrawLineApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec21"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add a new class to the project, and name it<code class="literal"> DrawingView</code>. Derive it from<code class="literal"> UIView:</code><div><pre class="programlisting">public class DrawingView : UIView
</pre></div></li><li class="listitem"> Add the following<code class="literal"> using</code> directive in the<code class="literal"> DrawingView.cs</code> file:<div><pre class="programlisting">using MonoTouch.CoreGraphics;
</pre></div></li><li class="listitem"> Override the<code class="literal"> Draw</code> method of<code class="literal"> UIView</code>, and implement it with the following code:<div><pre class="programlisting">public override void Draw (RectangleF rect){
base.Draw (rect);
Console.WriteLine("DrawingView draw!");
using (CGContext context = UIGraphics.GetCurrentContext()){
context.SetLineWidth(5f);
context.SetStrokeColorWithColor(UIColor.Green.CGColor);
context.AddLines(new PointF[] {
new PointF(0f, this.Bounds.Height),
new PointF(this.Bounds.Width, 0f)
} );
context.StrokePath();
context.SetStrokeColorWithColor(UIColor.Red.CGColor);
<strong>
context.MoveTo(0, this.Bounds.Height);
context.AddCurveToPoint(0f, this.Bounds.Height, 50f, this.Bounds.Height / 2f, this.Bounds.Width, 0f);
</strong>
context.StrokePath();
}
}
</pre></div></li><li class="listitem"> In the<code class="literal"> ViewDidLoad</code> override of the<code class="literal"> MainController</code>, initialize and add the view:<a id="id892" class="indexterm"/><div><pre class="programlisting">DrawingView drawingView = new DrawingView(this.View.Bounds);
drawingView.BackgroundColor = UIColor.Gray;
this.View.AddSubview(this.drawingView);
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. The result should be similar to the following:<div><img src="img/1468EXP_11_03a.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec22"/>How it works...</h2></div></div></div><p>The<code class="literal"> MonoTouch.CoreGraphics</code> namespace is a wrapper around the native<code class="literal"> Core Graphics</code> framework. The<code class="literal"> Core Graphics</code> framework contains the necessary objects for custom drawing on views.<a id="id893" class="indexterm"/>
</p><p>To draw on a view, we have to override its<code class="literal"> Draw(RectangleF)</code> method:<a id="id894" class="indexterm"/>
</p><div><pre class="programlisting">public override void Draw (RectangleF rect)
</pre></div><p>Inside the<code class="literal"> Draw</code> method, we need an instance of the current graphics context:</p><div><pre class="programlisting">using (CGContext context = UIGraphics.GetCurrentContext())
</pre></div><p>A graphics context is represented by the<code class="literal"> CGContext</code> class. The<code class="literal"> UIGraphics.GetCurrentContext</code> static method returns an instance of the current context.</p><p>The<code class="literal"> CGContext</code> class contains various methods that allows us to draw on the view. We need to set the line width, the color, and then add the type of drawing:<a id="id895" class="indexterm"/>
</p><div><pre class="programlisting">context.SetLineWidth(5f);
context.SetStrokeColorWithColor(UIColor.Green.CGColor);
context.AddLines(new PointF[] {
new PointF(0f, this.Bounds.Height),
new PointF(this.Bounds.Width, 0f)
} );
</pre></div><p>To add a line, we use the<code class="literal"> AddLines</code> method that accepts an array of<code class="literal"> PointF structs</code> containing the start and end points of each line. Just adding the lines to the context is not enough. To present the drawing on the view, we call the<code class="literal"> StrokePath</code> method:<a id="id896" class="indexterm"/>
</p><div><pre class="programlisting">context.StrokePath();
</pre></div><p>To add another item to the drawing, we repeat the steps accordingly. The<code class="literal"> MoveTo</code> method moves the current point so that the additional item will have a starting point for the curve.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec23"/>There's more...</h2></div></div></div><p>The<code class="literal"> Draw</code> method is being called by the runtime when it needs to draw the contents of a view. We can only get the instance of the current graphics context inside the<code class="literal"> Draw</code> method. We should not call it directly, since the<code class="literal"> UIGraphics.GetCurrentContext</code> method will return<code class="literal"> null</code> if we do. If we need to force the runtime to call the<code class="literal"> Draw</code> method, we need to call<code class="literal"> SetNeedsDisplay()</code>. Care should be taken when calling it, since drawing operations are expensive in terms of CPU usage.<a id="id897" class="indexterm"/>
</p><p>When there is no need for causing the entire view area to be redrawn, we can call the<code class="literal"> SetNeedsDisplayInRect</code> method, passing the<code class="literal"> RectangleF</code> in the view's coordinate system of the area that we want to be updated.<a id="id898" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec06"/>Graphics context on a UIImageView</h3></div></div></div><p>The current graphics context of a<code class="literal"> UIImageView</code> is reserved for drawing the contents of the image. Calling<code class="literal"> SetNeedsDisplay</code> on a custom view deriving from<code class="literal"> UIImageView</code> has the same effect as calling the<code class="literal"> Draw</code> method directly. If we need to draw on a custom image view, we have to either add another view on top of it and draw on that, or draw on a custom layer and add it to the view's main layer.<a id="id899" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec24"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Drawing text</em></li></ul></div><p>In this book:</p><p>
<a class="link" href="ch02.html" title="Chapter 2. User Interface: Views">Chapter 2</a>, User Interface: Views:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating</em> a<em> custom view</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec07"/>Drawing shapes</h1></div></div></div><p>Following the example in the previous recipe, we will draw a circle and a square on the screen.<a id="id900" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec25"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DrawShapeApp</code>. Add a custom view like in the previous task, and name it<code class="literal"> DrawingView</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec26"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add the following code in the<code class="literal"> Draw</code> method override:<div><pre class="programlisting">using (CGContext context = UIGraphics.GetCurrentContext()){
context.SetFillColorWithColor(UIColor.Blue.CGColor);
context.SetShadow(new SizeF(10f, 10f), 5f);
context.AddEllipseInRect(new RectangleF(100f, 100f, 100f, 100f));
context.FillPath();
context.SetFillColorWithColor(UIColor.Red.CGColor);
context.AddRect(new RectangleF(150f, 150f, 100f, 100f));
context.FillPath();
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. The result on the screen should be similar to the following:</li></ol></div><div><img src="img/1468EXP_11_04.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec27"/>How it works...</h2></div></div></div><p>To draw shapes on a view, we need to call the appropriate method. We first set the fill color of the<code class="literal"> CGContext</code> instance:<a id="id901" class="indexterm"/>
</p><div><pre class="programlisting">context.SetFillColorWithColor(UIColor.Blue.CGColor);
</pre></div><p>To draw a circle, we call the<code class="literal"> AddEllipseInRect</code> method, passing a<code class="literal"> RectangleF</code> object containing the bounding rectangle of the circle:<a id="id902" class="indexterm"/>
</p><div><pre class="programlisting">context.AddEllipseInRect(new RectangleF(100f, 100f, 100f, 100f));
</pre></div><p>Whether the shape will be an ellipse or an absolute circle is defined through the bounding rectangle's size. We then call the<code class="literal"> FillPath</code> method:<a id="id903" class="indexterm"/>
</p><div><pre class="programlisting">context.FillPath();
</pre></div><p>The shadow effect is defined by the<code class="literal"> SetShadow</code> method:<a id="id904" class="indexterm"/>
</p><div><pre class="programlisting">context.SetShadow(new SizeF(10f, 10f), 5f);
</pre></div><p>The first parameter, which is of the type<code class="literal"> SizeF</code>, defines the offset of the shadow, while the second parameter defines the amount of blur.<a id="id905" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec28"/>There's more...</h2></div></div></div><p>When the<code class="literal"> SetShadow</code> method is called, all objects that are added to the context are displayed with a shadow. To remove the shadow, call the<code class="literal"> SetShadowWithColor</code> method, passing either a fully transparent color or<code class="literal"> null</code> for the color parameter.<a id="id906" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec07"/>Transparent colors</h3></div></div></div><p>To fill a shape with a transparent color, create a<code class="literal"> CGColor</code> instance with the appropriate values:<a id="id907" class="indexterm"/>
</p><div><pre class="programlisting">context.SetFillColorWithColor(new CGColor(1f, 0f, 0f, 0.5f));
</pre></div><p>This will create a red color with its alpha set to 50 percent.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec29"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Drawing lines and curves</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec08"/>Drawing text</h1></div></div></div><p>In this recipe, we will learn how to draw styled text with an outline.<a id="id908" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec30"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> DrawTextApp</code>. Add the<code class="literal"> DrawingView</code> class that we created in the previous tasks to the project.<a id="id909" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec31"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Implement the following<code class="literal"> Draw</code> method override in the<code class="literal"> DrawingView</code> class:<a id="id910" class="indexterm"/><div><pre class="programlisting">using (CGContext context = UIGraphics.GetCurrentContext()){
context.SetFillColorWithColor(UIColor.Yellow.CGColor);
context.SetTextDrawingMode(CGTextDrawingMode.FillStroke);
NSString drawText = new NSString("This text is drawn!");
drawText.DrawString(new PointF(10f, 100f), UIFont.FromName("Verdana-Bold", 28f));
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator. The text will be displayed on the screen. The result should be similar to the following:</li></ol></div><div><img src="img/1468EXP_11_05.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec32"/>How it works...</h2></div></div></div><p>The<code class="literal"> NSString</code> class contains the very useful method<code class="literal"> DrawString</code>, which draws the text it contains to the current context. To provide the outline effect, we call the<code class="literal"> SetTextDrawingMode</code> method:<a id="id911" class="indexterm"/>
</p><div><pre class="programlisting">context.SetTextDrawingMode(CGTextDrawingMode.FillStroke);
</pre></div><p>We pass the<code class="literal"> CGTextDrawingMode.FillStroke</code> value. Since we have not set a stroke color to the context, it defaults to black.</p><p>Finally, the<code class="literal"> DrawString</code> method is called:<a id="id912" class="indexterm"/>
</p><div><pre class="programlisting">drawText.DrawString(new PointF(10f, 100f), UIFont.FromName( "Verdana-Bold", 28f));
</pre></div><p>This method is overloaded. The overload we use here accepts a<code class="literal"> PointF struct</code>, which represents the location of the string in the view's coordinate system, and a<code class="literal"> UIFont</code> instance that represents the font by which the text will be rendered on the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec33"/>There's more...</h2></div></div></div><p>The<code class="literal"> CGContext</code> class contains the method for drawing text. We first need to call<code class="literal"> SelectFont</code> method to assign the font:<a id="id913" class="indexterm"/>
</p><div><pre class="programlisting">context.SelectFont("Verdana-Bold", 28f, CGTextEncoding.MacRoman);
</pre></div><p>We then call the<code class="literal"> ShowTextAtPoint</code> method to draw the text:<a id="id914" class="indexterm"/>
</p><div><pre class="programlisting">context.ShowTextAtPoint(10, 100, drawText.ToString());
</pre></div><p>This will give the following result:</p><div><img src="img/1468EXP_11_06.jpg" alt="There's more..."/></div><p>The text will be displayed at the correct position, but reversed. To correct this, we need to set a transformation matrix to the<code class="literal"> TextMatrix</code> property:<a id="id915" class="indexterm"/>
</p><div><pre class="programlisting">context.TextMatrix = new CGAffineTransform(1, 0, 0, -1, 0, 0);
</pre></div><p>The biggest advantage in using the<code class="literal"> CGContext</code> class' methods is that we can easily transform the text appearance. For example, by applying a slightly different transformation matrix, we can easily display skewed text:</p><div><pre class="programlisting">context.TextMatrix = new CGAffineTransform(1, 1, 0, -1, 0, 0);
</pre></div><div><img src="img/1468EXP_11_07.jpg" alt="There's more..."/></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec08"/>Size of drawn text</h3></div></div></div><p>The<code class="literal"> DrawString</code> method of the<code class="literal"> NSString</code> class returns the size of the bounding rectangle of the text. We can, however, get the size of the text before drawing through the<code class="literal"> StringSize</code> method:<a id="id916" class="indexterm"/>
</p><div><pre class="programlisting">Console.WriteLine("Text size: {0}", drawText.StringSize(UIFont.FromName("Verdana-Bold", 28f)));
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec34"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Drawing lines and curves</em></li><li class="listitem" style="list-style-type: disc"><em>Drawing shapes</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec09"/>A simple drawing application</h1></div></div></div><p>In this recipe, we will use the techniques that we learned to create a drawing application.<a id="id917" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec35"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> FingerDrawingApp</code>. Once again, we will need a custom view. Add a class deriving from<code class="literal"> UIView</code>, and name it<code class="literal"> CanvasView</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec36"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Implement the<code class="literal"> CanvasView</code> class with the following code:<a id="id918" class="indexterm"/><div><pre class="programlisting">public class CanvasView : UIView{
public CanvasView (RectangleF frame) : base(frame){
this.drawPath = new CGPath();
}
private PointF touchLocation;
private PointF previousTouchLocation;
private CGPath drawPath;
private bool fingerDraw;
public override void TouchesBegan (NSSet touches, UIEvent evt){
base.TouchesBegan (touches, evt);
UITouch touch = touches.AnyObject as UITouch;
this.fingerDraw = true;
this.touchLocation = touch.LocationInView(this);
this.previousTouchLocation = touch.PreviousLocationInView(this);
this.SetNeedsDisplay();
}
public override void TouchesMoved (NSSet touches, UIEvent evt){
base.TouchesMoved (touches, evt);
UITouch touch = touches.AnyObject as UITouch;
this.touchLocation = touch.LocationInView(this);
this.previousTouchLocation = touch.PreviousLocationInView(this);
this.SetNeedsDisplay();
}
public override void Draw (RectangleF rect){
base.Draw (rect);
if (this.fingerDraw){
using (CGContext context = UIGraphics.GetCurrentContext()){
context.SetStrokeColorWithColor(UIColor.Blue.CGColor);
context.SetLineWidth(5f);
<strong>
context.SetLineJoin(CGLineJoin.Round);
context.SetLineCap(CGLineCap.Round);
</strong>
this.drawPath.MoveToPoint(this.previousTouchLocation);
this.drawPath.AddLineToPoint(this.touchLocation);
context.AddPath(this.drawPath);
context.DrawPath(CGPathDrawingMode.Stroke);
}
}
}
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator or on the device.<a id="id919" class="indexterm"/></li><li class="listitem"> Touch and drag your finger (or click-and-drag with the cursor) and start drawing!</li></ol></div><div><img src="img/1468EXP_11_08.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec37"/>How it works...</h2></div></div></div><p>In this task, we are combining touch events and custom drawing to create a simple drawing application. When the user touches and moves the finger on the screen, we keep the touch location points information and use them in the<code class="literal"> Draw</code> method to draw lines.<a id="id920" class="indexterm"/>
</p><p>After setting the touch locations to the class fields, we call<code class="literal"> SetNeedsDisplay</code> to force the<code class="literal"> Draw</code> method to be called. The<code class="literal"> fingerDraw</code> field is used to determine if the<code class="literal"> Draw</code> method was called by a touch on the screen and not by the runtime when the view is first loaded.</p><p>Every time we call a method to draw something to a graphics context, the previous drawings in that context are cleared. To avoid this behavior, we use a<code class="literal"> CGPath</code> object. We can add various drawing objects in a<code class="literal"> CGPath</code> and display these objects on the screen by adding them to the graphics context. So, every time the user moves the finger on the screen, the new lines defined by the touch location points are added to the path, and the path is drawn on the current context.</p><p>Note that we need to hold information of both the current touch location and the previous one. This is because the<code class="literal"> AddLineToPoint</code> method accepts one point, which defines the end point of the line, assuming there already is a point in the path. The starting point of each line is defined by calling<code class="literal"> MoveToPoint</code>, passing the previous touch location point.<a id="id921" class="indexterm"/>
</p><p>The path that is drawn on the screen by sliding the finger on it is basically comprised of a series of consecutive straight lines. The result, however, is a smooth path that follows the finger movement, because the<code class="literal"> TouchesMoved</code> method is triggered every time there is a single movement of the finger on the screen.<a id="id922" class="indexterm"/>
</p><p>After adding the line to the path, we add it to the context and draw it:</p><div><pre class="programlisting">context.AddPath(this.drawPath);
context.DrawPath(CGPathDrawingMode.Stroke);
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec38"/>There's more...</h2></div></div></div><p>Two new<code class="literal"> CGContext</code> methods are introduced in this task:<code class="literal"> SetLineJoin</code> and<code class="literal"> SetLineCap</code>. The<code class="literal"> SetLineJoin</code> method sets how each line will be joined to the previous one, while the<code class="literal"> SetLineCap</code> sets the appearance of the endpoint of a line.<a id="id923" class="indexterm"/>
</p><p>The values they accept are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SetLineJoin</code><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineJoin.Miter:</code> Joins two lines with an angled corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineJoin.Round:</code> Joins two lines with a rounded end</li><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineJoin.Bevel:</code> Joins two lines with a squared end</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">SetLineCap</code><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineCap.Butt:</code> The line will end with a squared edge on the endpoint</li><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineCap.Round:</code> The line will end with a rounded edge that expands beyond the endpoint</li><li class="listitem" style="list-style-type: disc"><code class="literal">CGLineCap.Square:</code> The line will end with a squared edge that expands beyond the endpoint</li></ul></div></li></ul></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec09"/>Clear the drawing</h3></div></div></div><p>To clear the drawing, we simply have to set the<code class="literal"> fingerDraw</code> variable to<code class="literal"> false</code> and call<code class="literal"> SetNeedsDisplay</code>. This way, the<code class="literal"> Draw</code> method will be called without our custom drawing code, clearing the current context.<a id="id924" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec39"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Drawing lines and curves</em></li><li class="listitem" style="list-style-type: disc"><em>Drawing shapes</em></li><li class="listitem" style="list-style-type: disc"><em>Drawing text</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec10"/>Creating an image context</h1></div></div></div><p>In this recipe, we will expand the finger drawing application that we created previously by providing the user with the feature of saving the created drawings.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec40"/>Getting ready</h2></div></div></div><p>Create a new project in MonoDevelop, and name it<code class="literal"> ImageContextApp</code>. Add the<code class="literal"> CanvasView</code> class that we created in the previous task to the project.<a id="id925" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec41"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"> Add two buttons on the view of<code class="literal"> MainController</code>. One will be used for saving the image and the other for clearing the current drawing.</li><li class="listitem"> Add the following methods in the<code class="literal"> CanvasView</code> class:<div><pre class="programlisting">public UIImage GetDrawingImage(){
UIImage toReturn = null;
UIGraphics.BeginImageContext(this.Bounds.Size);
using (CGContext context = UIGraphics.GetCurrentContext()){
context.SetStrokeColorWithColor(UIColor.Blue.CGColor);
context.SetLineWidth(10f);
context.SetLineJoin(CGLineJoin.Round);
context.SetLineCap(CGLineCap.Round);
context.AddPath(this.drawPath);
context.DrawPath(CGPathDrawingMode.Stroke);
toReturn = UIGraphics.GetImageFromCurrentImageContext();
}
UIGraphics.EndImageContext();
return toReturn;
}
public void ClearDrawing(){
this.fingerDraw = false;
this.drawPath.Dispose();
this.drawPath = new CGPath();
this.SetNeedsDisplay();
}
</pre></div></li><li class="listitem"> Add the following code in the<code class="literal"> MainController</code> class:<a id="id926" class="indexterm"/><div><pre class="programlisting">private CanvasView canvasView;
public override void ViewDidLoad (){
base.ViewDidLoad ();
this.canvasView = new CanvasView(new RectangleF( this.View.Bounds.Location, new SizeF(this.View.Bounds.Width, this.buttonClear.Frame.Top - 10f)));
this.canvasView.BackgroundColor = UIColor.Gray;
this.View.AddSubview(this.canvasView);
this.buttonSave.TouchUpInside += delegate {
UIImage drawingImage = this.canvasView.GetDrawingImage();
drawingImage.SaveToPhotosAlbum(delegate( UIImage image, NSError error) {
if (error != null){
Console.WriteLine("Error saving image! {0}", error.LocalizedDescription);
}
} );
} ;
this.buttonClear.TouchUpInside += delegate {
this.canvasView.ClearDrawing();
} ;
}
</pre></div></li><li class="listitem"> Compile and run the application on the simulator.</li><li class="listitem"> Draw something on the canvas, and tap the<strong> Save drawing</strong> button to save your drawing.</li><li class="listitem"> Tap on the<strong> Clear</strong> drawing button to clear the canvas. You can then check the simulator's photo albums for your drawing.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec42"/>How it works...</h2></div></div></div><p>Using the<code class="literal"> UIGraphics</code> class, we can create an image context through which we can retrieve our drawing in a<code class="literal"> UIImage</code> object.<a id="id927" class="indexterm"/>
</p><p>To create an image context, inside the<code class="literal"> GetDrawingImage</code> method we call the<code class="literal"> BeginImageContext</code> static method, passing the size we want the image context to have:<a id="id928" class="indexterm"/>
</p><div><pre class="programlisting">UIGraphics.BeginImageContext(this.Bounds.Size);
</pre></div><p>The current context is now the image context that we created with the<code class="literal"> BeginImageContext</code> call. We then repeat the code we have in the<code class="literal"> Draw</code> method, only this time there is no need to add new lines to the path. We simply add the path we already have to the context and draw it.<a id="id929" class="indexterm"/>
</p><p>After adding the path, we get the context image by calling the<code class="literal"> GetImageFromCurrentContext</code> method:<a id="id930" class="indexterm"/>
</p><div><pre class="programlisting">toReturn = UIGraphics.GetImageFromCurrentImageContext();
</pre></div><p>Finally, we have to end the image context block and return the<code class="literal"> UIImage</code> object:</p><div><pre class="programlisting">UIGraphics.EndImageContext();
return toReturn;
</pre></div><p>To clear the drawing from the screen, we simply have to set the<code class="literal"> fingerDraw</code> variable to<code class="literal"> false</code> and dispose and prepare our<code class="literal"> CGPath</code> object for re-use, inside the<code class="literal"> ClearDrawing</code> method:</p><div><pre class="programlisting">this.fingerDraw = false;
this.drawPath.Dispose();
this.drawPath = new CGPath();
</pre></div><p>To reflect the clearing on the screen immediately, we call the<code class="literal"> SetNeedsDisplay</code> method:<a id="id931" class="indexterm"/>
</p><div><pre class="programlisting">this.SetNeedsDisplay();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec43"/>There's more...</h2></div></div></div><p>We cannot create an image context inside the<code class="literal"> Draw</code> method. That is because when we call the<code class="literal"> BeginImageContext</code> method, a context is actually created, but the view's default context remains as the current context. Hence, the<code class="literal"> GetImageFromCurrentImageContext</code> method would return<code class="literal"> null</code>.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec10"/>Drawing on UIImageView</h3></div></div></div><p>The technique discussed here can be used to draw on custom<code class="literal"> UIImageViews</code>. To display the drawing when the finger slides on the screen, we would simply have to set its<code class="literal"> Image</code> property to the image we get from the image context.<a id="id932" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec11"/>Background on saved drawings</h3></div></div></div><p>You will notice that although we are setting the<code class="literal"> CanvasView</code> background to gray, the saved drawings are with a white background. This is because the view's background color is not included in the drawing. To include it, we would just have to draw a rectangle with the same color as the background color to the graphics context.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec44"/>See also</h2></div></div></div><p>In this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Drawing lines and curves</em></li><li class="listitem" style="list-style-type: disc"><em>Drawing shapes</em></li><li class="listitem" style="list-style-type: disc"><em>Drawing text</em></li><li class="listitem" style="list-style-type: disc"><em>A simple drawing</em></li></ul></div></div></div></body></html>