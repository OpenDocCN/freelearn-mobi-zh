<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Getting your app ready for the Play Store</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new Android 6.0 Run-Time permission model</li><li class="listitem" style="list-style-type: disc">How to schedule an alarm</li><li class="listitem" style="list-style-type: disc">Receive notification of device boot</li><li class="listitem" style="list-style-type: disc">Using AsyncTask for background work</li><li class="listitem" style="list-style-type: disc">Adding speech recognition to your app</li><li class="listitem" style="list-style-type: disc">Push Notification using Google Cloud Messaging</li><li class="listitem" style="list-style-type: disc">How to add Google sign-in to your app</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec108"/>Introduction</h1></div></div></div><p>As we approach the end of this book, it's time to add the finishing touches to your application before releasing it to the Play Store. The recipes in this chapter cover the topics that can make a difference between users keeping your app or removing it.</p><p>Our first recipe, <em>The new Android 6.0 Run-Time permission model</em>, is certainly an important topic, possibly being the primary reason Android went from version 5.x to version 6! Changes to the Android permission model have been requested for some time, so this new model is a welcome change, at least for users.</p><p>Next, we'll take a look at using alarms in Android. One of the primary benefits of alarms is that the OS is responsible for maintaining the alarm, even when your application is not running. Since alarms do not persist after rebooting the device, we'll also look at how to detect a device reboot so you can recreate your alarms in <em>Receive notification of device boot</em>.</p><p>Almost any serious Android application will need a way to perform potentially blocking tasks off the main thread. Otherwise, your app runs the risk of being perceived as sluggish, or worse, completely nonresponsive. <code class="literal">AsyncTask</code> was designed to make it easier to create a background worker task as we'll demonstrate in the <em>Using the AsyncTask for background work</em> recipe.</p><p>If you want your app to benefit from hands-free typing or voice recognition, take a look at the <em>Adding Speech Recognition to your app</em> recipe in which we'll explore the Google Speech API.</p><p>Possibly one of the most interesting features for communicating with your users is Push Notification or<a id="id880" class="indexterm"/> <strong>Google Cloud Messaging</strong> (<strong>GCM</strong>) as Google calls it. The <em>Push Notification using Google Cloud Messaging</em> recipe will walk you through the adding of GCM to your application as well as explain the bigger picture.</p><p>Finally, we'll end the chapter with a recipe showing how to make your app more comfortable and encourage users to log in with the <em>How to add Google Sign-In to your app</em> recipe</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec109"/>The new Android 6.0 Run-Time permission model</h1></div></div></div><p>The <a id="id881" class="indexterm"/>old security model was a sore point for many in Android. It's common to see reviews commenting on the permissions an app requires. Sometimes, permissions were out of the line (like a Flashlight app requiring internet permission), but other times, the developer had good reasons to request certain permissions. The main problem was that it was an all-or-nothing prospect.</p><p>This finally changed with the Android 6 Marshmallow (API 23) release. The new permission model still declares permissions in the manifest as before, but users have the option of selectively accepting or denying each permission. Users can even revoke a previously granted permission.</p><p>Although this is a welcome change for many; however, for a developer, it has the potential to break the code that was working before. We've talked about this permission change in the previous recipes, as it has far reaching implications. This recipe will put it all together to serve as a single point of reference when implementing this change in your own apps.</p><p>One important point to remember is that this change only affects users of Android 6.0 (API 23) and above.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec407"/>Getting ready</h2></div></div></div><p>Create a new <a id="id882" class="indexterm"/>project in Android Studio and call it <code class="literal">RuntimePermission</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p><p>The sample source code sets the minimum API to 23, but this is not required. If your <code class="literal">compileSdkVersion</code> is API 23 or above, the compiler will flag your code for the new security model.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec408"/>How to do it...</h2></div></div></div><p>We need to start by adding our required permission to the manifest, then we'll add a button to call our check permission code. Open the Android Manifest and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following permission:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the existing <code class="literal">TextView</code> with this button:<div><pre class="programlisting">&lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Do Something"
    android:layout_centerInParent="true"
    android:onClick="doSomething"/&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following constant to the class:<div><pre class="programlisting">private final int REQUEST_PERMISSION_SEND_SMS=1;</pre></div></li><li class="listitem">Add this method for permission check:<div><pre class="programlisting">private boolean checkPermission(String permission) {
    int permissionCheck = ContextCompat.checkSelfPermission(
            this, permission);
    return (permissionCheck == PackageManager.PERMISSION_GRANTED);
}</pre></div></li><li class="listitem">Add this method to show the explanation dialog:<div><pre class="programlisting">private void showExplanation(String title,
    String message, final String permission, final int permissionRequestCode) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(title).setMessage(message).setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int id) {
            requestPermission(permission, permissionRequestCode);
        }
    });
    builder.create().show();
}</pre></div></li><li class="listitem">Add this method to request the permission:<div><pre class="programlisting">private void requestPermission(String permissionName, int permissionRequestCode) {
    ActivityCompat.requestPermissions(this, new String[]{permissionName}, permissionRequestCode);
}</pre></div></li><li class="listitem">Add the <a id="id883" class="indexterm"/>method for button click:<div><pre class="programlisting">public void doSomething(View view) {
    if (!checkPermission(Manifest.permission.SEND_SMS)) {
        if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.SEND_SMS)) {
            showExplanation("Permission Needed", "Rationale", Manifest.permission.SEND_SMS, REQUEST_PERMISSION_SEND_SMS);
        } else {
            requestPermission(Manifest.permission.SEND_SMS, REQUEST_PERMISSION_SEND_SMS);
        }
    } else {
        Toast.makeText(MainActivity.this, "Permission (already) Granted!", Toast.LENGTH_SHORT).show();
    }
}</pre></div></li><li class="listitem">Override <code class="literal">onRequestPermissionsResult()</code> as follows:<div><pre class="programlisting">@Override
public void onRequestPermissionsResult(
    int requestCode,
    String permissions[],
    int[] grantResults) {
    switch (requestCode) {
        case REQUEST_PERMISSION_SEND_SMS: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(MainActivity.this, "Permission Granted!", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(MainActivity.this, "Permission Denied!", Toast.LENGTH_SHORT).show();
            }
            return;
        }
    }
}</pre></div></li><li class="listitem">Now, you're<a id="id884" class="indexterm"/> ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec409"/>How it works...</h2></div></div></div><p>Using the new runtime permission model involves the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Check to see whether you have the desired permissions.</li><li class="listitem">If not, check whether we should display the rationale (meaning, the request was previously denied).</li><li class="listitem">Request the permission; only the OS can display the permission request.</li><li class="listitem">Handle the request response.</li></ol></div><p>Here are the corresponding methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ContextCompat.checkSelfPermission</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ActivityCompat.requestPermissions</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ActivityCompat.shouldShowRequestPermissionRationale</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onRequestPermissionsResult</code><div><div><h3 class="title"><a id="note22"/>Note</h3><p>Even though you are requesting permissions at runtime, the desired permission must be listed in the Android Manifest. If the permission is not specified, the OS will automatically deny the request.</p></div></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec410"/>There's more...</h2></div></div></div><p>You can<a id="id885" class="indexterm"/> grant/revoke <a id="id886" class="indexterm"/>permissions through the ADB <a id="id887" class="indexterm"/>with the following:</p><div><pre class="programlisting">adb shell pm [grant|revoke] &lt;package&gt; &lt;permission-name&gt;</pre></div><p>Here's an example to grant the SEND_SMS permission for our test app:</p><div><pre class="programlisting">adb shell pm grant com.packtpub.androidcookbook.runtimepermissions android.permission.SEND_SMS</pre></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec411"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: System Permissions</strong><a id="id888" class="indexterm"/> at <a class="ulink" href="https://developer.android.com/guide/topics/security/permissions.html">https://developer.android.com/guide/topics/security/permissions.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec110"/>How to schedule an alarm</h1></div></div></div><p>Android provides <code class="literal">AlarmManager</code> to create and schedule alarms. Alarms offer the following <a id="id889" class="indexterm"/>features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Schedule alarms for a set time or interval</li><li class="listitem" style="list-style-type: disc">Maintained by the OS, not your application, so alarms are triggered even if your application is not running, or the device is asleep</li><li class="listitem" style="list-style-type: disc">Can be used to trigger periodic tasks (such as an hourly news update), even if your application is not running</li><li class="listitem" style="list-style-type: disc">Your app does not use resources (such as timers or background services), since the OS manages the scheduling</li></ul></div><p>Alarms are not the best solution if you need a simple delay while your application is running, for example, a short delay for a UI event. For short delays, it's easier and more efficient to use a Handler, as we've done in several previous recipes.</p><p>When using alarms, keep these best practices in mind:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use as infrequent<a id="id890" class="indexterm"/> alarm timing as possible</li><li class="listitem" style="list-style-type: disc">Avoid waking up the device</li><li class="listitem" style="list-style-type: disc">Use as imprecise timing as possible—the more precise the timing, the more resources required</li><li class="listitem" style="list-style-type: disc">Avoid setting alarm times based on clock time (such as 12:00); add random adjustments if possible to avoid congestion on servers (especially important when checking<a id="id891" class="indexterm"/> for new content, such as weather or news)</li></ul></div><p>Alarms have three properties, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Alarm type (see in the following list)</li><li class="listitem" style="list-style-type: disc">Trigger time (if the time has already passed, the alarm is triggered immediately)</li><li class="listitem" style="list-style-type: disc">Pending Intent</li></ul></div><p>A repeating alarm has the same three properties, plus an Interval:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Alarm type (see in the following list)</li><li class="listitem" style="list-style-type: disc">Trigger <a id="id892" class="indexterm"/>time (if the time has already passed, it triggers immediately)</li><li class="listitem" style="list-style-type: disc">Interval</li><li class="listitem" style="list-style-type: disc">Pending Intent</li></ul></div><p>There are four alarm types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RTC</code> (<strong>Real Time Clock</strong>): This is<a id="id893" class="indexterm"/> based on the wall clock time. This does not wake the device.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RTC_WAKEUP</code>: This is <a id="id894" class="indexterm"/>based on the wall clock time. This wakes the device if it is sleeping.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ELAPSED_REALTIME</code>: This<a id="id895" class="indexterm"/> is based on the time elapsed since the device boot. This does not wake the device.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ELAPSED_REALTIME_WAKEUP</code>: This is<a id="id896" class="indexterm"/> based on the time elapsed since the device boot. This wakes the device if it is sleeping.</li></ul></div><p>Elapsed Real Time is better for time interval alarms—such as every 30 minutes.</p><div><div><h3 class="title"><a id="tip36"/>Tip</h3><p>Alarms do not persist after device reboots. All alarms are cancelled when a device shuts down, so it is your app's responsibility to reset the alarms on device boot. (See <em>Receive notification of device boot</em> for more information.)</p></div></div><p>The following recipe will demonstrate how to create alarms with <code class="literal">AlarmManager</code>.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec412"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">Alarms</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec413"/>How to do it...</h2></div></div></div><p>Setting an alarm requires a Pending Intent, which Android sends when the alarm is triggered. Therefore, we need to set up a Broadcast Receiving to capture the alarm intent. Our UI will consist of just a simple button to set the alarm. To start, open the Android Manifest and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <a id="id897" class="indexterm"/>following <code class="literal">&lt;receiver&gt; </code>to the <code class="literal">&lt;application&gt;</code> element at the same level as the existing <code class="literal">&lt;activity&gt;</code> element:<div><pre class="programlisting">&lt;receiver android:name=".AlarmBroadcastReceiver"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.packtpub.androidcookbook.alarms.ACTION_ALARM" /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div></li><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the existing TextView with the following button:<div><pre class="programlisting">&lt;Button
    android:id="@+id/button"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Set Alarm"
    android:layout_centerInParent="true"
    android:onClick="setAlarm"/&gt;</pre></div></li><li class="listitem">Create a new Java class called <code class="literal">AlarmBroadcastReceiver</code> using the following code:<div><pre class="programlisting">public class AlarmBroadcastReceiver extends BroadcastReceiver {

    public static final String ACTION_ALARM="com.packtpub.androidcookbook.alarms.ACTION_ALARM";

    @Override
    public void onReceive(Context context, Intent intent) {
        if (ACTION_ALARM.equals(intent.getAction())) {
            Toast.makeText(context, ACTION_ALARM, Toast.LENGTH_SHORT).show();
        }
    }
}</pre></div></li><li class="listitem">Open <code class="literal">ActivityMain.java</code> and add the method for the button click:<div><pre class="programlisting">public void setAlarm(View view) {
    Intent intentToFire = new Intent(getApplicationContext(), AlarmBroadcastReceiver.class);
    intentToFire.setAction(AlarmBroadcastReceiver.ACTION_ALARM);
    PendingIntent alarmIntent = PendingIntent.getBroadcast(getApplicationContext(), 0, intentToFire, 0);
    AlarmManager alarmManager = (AlarmManager)getApplicationContext().getSystemService(Context.ALARM_SERVICE);
    long thirtyMinutes=SystemClock.elapsedRealtime() + 30 * 60 * 1000;
    alarmManager.set(AlarmManager.ELAPSED_REALTIME, thirtyMinutes, alarmIntent);
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec414"/>How it works...</h2></div></div></div><p>Creating the <a id="id898" class="indexterm"/>alarm is done with this line of code:</p><div><pre class="programlisting">alarmManager.set(AlarmManager.ELAPSED_REALTIME, thirtyMinutes, alarmIntent);</pre></div><p>Here's the method signature:</p><div><pre class="programlisting">set(AlarmType, Time, PendingIntent);</pre></div><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Prior to Android 4.4 KitKat (API 19), this was the method to request an exact time. Android 4.4 and later will consider this as an inexact time for efficiency, but will not deliver the intent prior to the requested time. (See <code class="literal">setExact()</code> as follows if you need an exact time.)</p></div></div><p>To set the alarm, we create a Pending Intent with our previously defined alarm action:</p><div><pre class="programlisting">public static final String ACTION_ALARM="com.packtpub.androidcookbook.alarms.ACTION_ALARM";</pre></div><p>(This is an arbitrary string and could be anything we want, but it needs to be unique, so we prepend our package name.) We check for this action in the Broadcast Receiver's <code class="literal">onReceive()</code> callback.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec415"/>There's more...</h2></div></div></div><p>If you click the <strong>Set Alarm</strong> button and wait for thirty minutes, you will see the Toast when the alarm triggers. If you are too impatient to wait and click the <strong>Set Alarm</strong> button again before the first alarm is triggered, you wouldn't get two alarms. Instead, the OS will replace the first alarm with the new alarm, since they both use the same Pending Intent. (If you need multiple alarms, you need to create different Pending Intents, such as using different Actions.)</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec56"/>Cancel the alarm</h3></div></div></div><p>If you want to<a id="id899" class="indexterm"/> cancel the alarm, call the <code class="literal">cancel()</code> method by passing the same Pending Intent you have used to create the alarm. If we continue with our recipe, this is how it would look:</p><div><pre class="programlisting">alarmManager.cancel(alarmIntent);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec57"/>Repeating alarm</h3></div></div></div><p>If you want to create a repeating<a id="id900" class="indexterm"/> alarm, use the <code class="literal">setRepeating()</code> method. The Signature is similar to the <code class="literal">set()</code> method, but with an interval. This is shown as follows:</p><div><pre class="programlisting">setRepeating(AlarmType, Time (in milliseconds), Interval, PendingIntent);</pre></div><p>For the Interval, you can specify the interval time in milliseconds or use one of the predefined <code class="literal">AlarmManager</code> constants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">INTERVAL_DAY</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INTERVAL_FIFTEEN_MINUTES</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INTERVAL_HALF_DAY</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INTERVAL_HALF_HOUR</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INTERVAL_HOUR</code></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec416"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: AlarmManager</strong><a id="id901" class="indexterm"/> at <a class="ulink" href="https://developer.android.com/reference/android/app/AlarmManager.html">https://developer.android.com/reference/android/app/AlarmManager.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec111"/>Receive notification of device boot</h1></div></div></div><p>Android sends out<a id="id902" class="indexterm"/> many intents during its lifetime. One of the<a id="id903" class="indexterm"/> first intents sent is <code class="literal">ACTION_BOOT_COMPLETED</code>. If your application needs to know when the device boots, you need to capture this intent.</p><p>This recipe will walk you through the steps required to be notified when the device boots.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec417"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">DeviceBoot</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec418"/>How to do it...</h2></div></div></div><p>To start, open the Android Manifest and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the following permission:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;</pre></div></li><li class="listitem">Add the <a id="id904" class="indexterm"/>following <code class="literal">&lt;receiver&gt;</code>  to <a id="id905" class="indexterm"/>the <code class="literal">&lt;application&gt;</code> element, at the same level as the existing <code class="literal">&lt;activity&gt;</code> element:<div><pre class="programlisting">&lt;receiver android:name=".BootBroadcastReceiver"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div></li><li class="listitem">Create a new Java class called <code class="literal">BootBroadcastReceiver</code> using the following code:<div><pre class="programlisting">public class BootBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")) {
            Toast.makeText(context, "BOOT_COMPLETED", Toast.LENGTH_SHORT).show();
        }
    }
}</pre></div></li><li class="listitem">Reboot the device to see the Toast.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec419"/>How it works...</h2></div></div></div><p>When the device boots, Android will send the <code class="literal">BOOT_COMPLETED</code> intent. As long as our application has the permission to receive the intent, we will receive notifications in our Broadcast Receiver.</p><p>There are three aspects to make this work:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A permission for <code class="literal">RECEIVE_BOOT_COMPLETED</code></li><li class="listitem" style="list-style-type: disc">Adding <code class="literal">BOOT_COMPLETED</code> to the receiver intent filter</li><li class="listitem" style="list-style-type: disc">Checking for the <code class="literal">BOOT_COMPLETED</code> action in the Broadcast Receiver</li></ul></div><p>Obviously, you'll <a id="id906" class="indexterm"/>want to replace the Toast message with your own <a id="id907" class="indexterm"/>code, such as for recreating any alarms you might need.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec420"/>There's more...</h2></div></div></div><p>If you followed the previous recipe, then you already have a Broadcast Receiver. You don't need a separate <code class="literal">BroadcastReceiver</code> for each action, just check for each action as needed. Here's an example if we need to handle another action:</p><div><pre class="programlisting">public void onReceive(Context context, Intent intent) {
    if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")) {
        Toast.makeText(context, "BOOT_COMPLETED", Toast.LENGTH_SHORT).show();
    } else if (intent.getAction().equals("&lt;another_action&gt;")) {
        //handle another action
    }
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec421"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: Intent</strong><a id="id908" class="indexterm"/> at <a class="ulink" href="https://developer.android.com/reference/android/content/Intent.html">https://developer.android.com/reference/android/content/Intent.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec112"/>Using the AsyncTask for background work</h1></div></div></div><p>Throughout this<a id="id909" class="indexterm"/> book, we have mentioned the <a id="id910" class="indexterm"/>importance of not blocking the main thread. Performing long running operations on the main thread can cause your application to appear sluggish, or worse, hang. If your application doesn't respond within about 5 seconds, the system will likely display the <strong>Application Not Responding</strong> (<strong>ANR</strong>)<a id="id911" class="indexterm"/> dialog with the option to terminate your app. (This is something you will want to avoid as it's a good way to get your app uninstalled.)</p><p>Android applications use a single thread model with two simple rules, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't block the main thread</li><li class="listitem" style="list-style-type: disc">Perform all UI operations <em>on</em> the main thread</li></ul></div><p>When Android starts your application, it automatically creates the main (or UI) thread. This is the thread from which all UI operations must be called. The first rule is "Don't block the main thread". This means that you need to create a background, or a worker, thread for any long-running or potentially-blocking task. This is why all network based tasks should be performed off the main thread.</p><p>Android offers the following options when working with background threads:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Activity.runOnUiThread()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">View.post()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">View.postDelayed()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Handler</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AsyncTask</code></li></ul></div><p>This recipe will <a id="id912" class="indexterm"/>explore the <code class="literal">AsyncTask</code> class; since it was <a id="id913" class="indexterm"/>created previously, you wouldn't have to use the Handler or post methods directly.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec422"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">AsyncTask</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec423"/>How to do it...</h2></div></div></div><p>We only need a single button for this example. Open <code class="literal">activity_main.xml</code> and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the existing TextView with the following button:<div><pre class="programlisting">&lt;Button
    android:id="@+id/buttonStart"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Start"
    android:layout_centerInParent="true"
    android:onClick="start" /&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following global variable:<div><pre class="programlisting">Button mButtonStart;</pre></div></li><li class="listitem">Add the <code class="literal">AsyncTask</code> class:<div><pre class="programlisting">private class CountingTask extends AsyncTask&lt;Integer, Integer, Integer&gt; {
    @Override
    protected Integer doInBackground(Integer... params) {
        int count = params[0];
        for (int x=0;x&lt;=count; x++){
            //Nothing to do
        }
        return count;
    }
    @Override
    protected void onPostExecute(Integer integer) {
        super.onPostExecute(integer);
        mButtonStart.setEnabled(true);
    }
}</pre></div></li><li class="listitem">Add the following code to the <code class="literal">onCreate()</code> to initialize the button:<div><pre class="programlisting">mButtonStart=(Button)findViewById(R.id.buttonStart);</pre></div></li><li class="listitem">Add the method for the button click:<div><pre class="programlisting">public void start(View view){
    mButtonStart.setEnabled(false);
    new CountingTask().execute(10000000);
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec424"/>How it works...</h2></div></div></div><p>This is a <a id="id914" class="indexterm"/>very simple example of the <code class="literal">AsyncTask</code> just<a id="id915" class="indexterm"/> to get it working. Technically, only <code class="literal">doInBackground()</code> is required, but usually, you may want to receive notifications via <code class="literal">onPostExecute()</code> when it finishes.</p><p>The <code class="literal">AsyncTask</code> works by creating a worker thread for the <code class="literal">doInBackground()</code> method, then responds back on the UI thread in the <code class="literal">onPostExecute()</code> callback.</p><p>Notice how we have waited until <code class="literal">onPostExecute()</code> is called before we do any UI actions such as enabling the button. If we attempt to modify the UI in the worker thread, it would either not compile or throw a runtime exception. You should also note how we instantiated a new <code class="literal">CountingTask</code> object on each button click. This is because an <code class="literal">AsyncTask</code> can only execute once. Attempting to call execute again will also throw an exception.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec425"/>There's more...</h2></div></div></div><p>At its minimum, the <code class="literal">AsyncTask</code> can be very simple but it is still very flexible with more options available if you need them. When using an <code class="literal">AsyncTask</code> with an Activity, it's important to understand whether the Activity is destroyed and recreated (such as during an orientation change), or the <code class="literal">AsyncTask</code> continues to run. This can leave your <code class="literal">AsyncTask</code> orphaned and it might respond back to the now destroyed activity (causing a <code class="literal">NullPointer</code> exception). For this reason, it's common to use the <code class="literal">AysncTask</code> with a Fragment (which is not destroyed on screen rotation), or use a Loader instead. (See the link for Loaders in the following section.)</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec58"/>Parameter types</h3></div></div></div><p>For many people, the<a id="id916" class="indexterm"/> most confusing aspect of the <code class="literal">AsyncTask</code> is the parameters when creating their own class. If you look at our class declaration, there are three parameters for the <code class="literal">AsyncTask</code>; they are defined as follows:</p><div><pre class="programlisting">AsyncTask&lt;Params, Progress, Result &gt;</pre></div><p>The parameters are generic types and used as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Params</strong>: This is the parameter type to call <code class="literal">doInBackground()</code></li><li class="listitem" style="list-style-type: disc"><strong>Progress</strong>: This is the parameter type to post updates</li><li class="listitem" style="list-style-type: disc"><strong>Result</strong>: This is the parameter type to post results</li></ul></div><p>When you declare your own class, substitute the parameters with the variable type you need.</p><p>Here's the process flow<a id="id917" class="indexterm"/> for the <code class="literal">AsyncTask</code> and how the preceding parameters are used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onPreExecute()</code>: This is called before <code class="literal">doInBackground()</code> begins</li><li class="listitem" style="list-style-type: disc"><code class="literal">doInBackground(Params)</code>: This executes in a background thread</li><li class="listitem" style="list-style-type: disc"><code class="literal">onProgressUpdate(Progress)</code>: This is called (on the UI thread) in response to the calling <code class="literal">publishProgress(Progress)</code> in the worker thread</li><li class="listitem" style="list-style-type: disc"><code class="literal">onPostExecute(Result)</code>: This is called (on the UI thread) when the worker thread finishes</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec59"/>Cancel the task</h3></div></div></div><p>To cancel the<a id="id918" class="indexterm"/> task, call the cancel method on the object as follows:</p><div><pre class="programlisting">&lt;<code class="literal"> AsyncTask</code>&gt;.cancel(true);</pre></div><p>You will need to have the object instance to access the <code class="literal">cancel() </code>method. (We did not save the object in our previous example.) After setting <code class="literal">cancel(true)</code>, the calling <code class="literal">isCancelled()</code> in <code class="literal">doInBackground()</code> will return <code class="literal">true</code>, allowing you to exit a loop. If cancelled, <code class="literal">onCancelled()</code> will be called instead of <code class="literal">onPostExecute()</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec426"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Access data in the background using a Loader</em> recipe, in <a class="link" href="ch06.html" title="Chapter 6. Working with Data">Chapter 6</a>, <em>Working with Data</em></li><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: AsyncTask</strong><a id="id919" class="indexterm"/> at <a class="ulink" href="http://developer.android.com/reference/android/os/AsyncTask.html">http://developer.android.com/reference/android/os/AsyncTask.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec113"/>Adding speech recognition to your app</h1></div></div></div><p>Android 2.2 (API 8) introduced speech recognition<a id="id920" class="indexterm"/> in Android, and <a id="id921" class="indexterm"/>it continues to improve with almost every new major Android release. This recipe will demonstrate how to add speech recognition to your app using the Google Speech service.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec427"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">SpeechRecognition</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec428"/>How to do it...</h2></div></div></div><p>We'll start by adding a Speak Now (or microphone) button to the layout, then we'll add the necessary code to call the speech recognizer. Open <code class="literal">activity_main.xml</code> and follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the existing <code class="literal">TextView</code> with the following XML:<div><pre class="programlisting">&lt;TextView
    android:id="@+id/textView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentTop="true"
    android:layout_alignParentLeft="true"
    android:layout_alignParentStart="true" /&gt;
&lt;ImageButton
    android:id="@+id/imageButton"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:layout_centerHorizontal="true"
    android:src="img/ic_btn_speak_now"
    android:onClick="speakNow"/&gt;</pre></div></li><li class="listitem">Define the <code class="literal">REQUEST_SPEECH</code> constant:<div><pre class="programlisting">private final int REQUEST_SPEECH=1;</pre></div></li><li class="listitem">Add the following code to the existing <code class="literal">onCreate()</code> callback:<div><pre class="programlisting">PackageManager pm = getPackageManager();
List&lt;ResolveInfo&gt; activities = pm.queryIntentActivities(
    new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH), 0);
if (activities.size() == 0) {
    findViewById(R.id.imageButton).setEnabled(false);
    Toast.makeText(this, "Speech Recognition Not Supported", Toast.LENGTH_LONG).show();
}</pre></div></li><li class="listitem">Add the<a id="id922" class="indexterm"/> button <a id="id923" class="indexterm"/>click method:<div><pre class="programlisting">public void speakNow(View view) {
    Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
    intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
        RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
    startActivityForResult(intent, REQUEST_SPEECH);
}</pre></div></li><li class="listitem">Add the following code to override the <code class="literal">onActivityResult()</code> callback:<div><pre class="programlisting">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode==REQUEST_SPEECH &amp;&amp; resultCode == RESULT_OK &amp;&amp; data!=null) {
        ArrayList&lt;String&gt; result = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);
        TextView textView = (TextView)findViewById(R.id.textView);
        if (result.size()&gt;0){
            textView.setText("");
            for (String item : result ) {
                textView.append(item+"\n");
            }
        }
    }
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec429"/>How it works...</h2></div></div></div><p>The work here is done by the Google Speech Recognizer included in Android. To make sure the service is available on the device, we call <code class="literal">PackageManager</code> in <code class="literal">onCreate()</code>. If at least one activity is registered to handle the <code class="literal">RecognizerIntent.ACTION_RECOGNIZE_SPEECH</code> intent, then we know it's available. If no activities are available, we display a Toast indicating speech recognition is not available and disable the mic button.</p><p>The button click starts the recognition process by calling an intent created with <code class="literal">RecognizerIntent.ACTION_RECOGNIZE_SPEECH</code>.</p><p>The <code class="literal">EXTRA_LANGUAGE_MODEL</code> parameter is required and has the following two choices:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LANGUAGE_MODEL_FREE_FORM</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LANGUAGE_MODEL_WEB_SEARCH</code></li></ul></div><p>We get the <a id="id924" class="indexterm"/>result back in the <code class="literal">onActivityResult()</code> callback. If <a id="id925" class="indexterm"/>we get back <code class="literal">RESULT_OK</code>, then we should have a list of words recognized, which we can retrieve using <code class="literal">getStringArrayListExtra()</code>. The array list will be ordered starting with the highest recognition confidence.</p><p>If you want to retrieve the confidence rating, retrieve the float array using <code class="literal">EXTRA_CONFIDENCE_SCORES</code>. Here's an example:</p><div><pre class="programlisting">float[] confidence = data.getFloatArrayExtra(RecognizerIntent.EXTRA_CONFIDENCE_SCORES);</pre></div><p>The confidence rating is optional and may not be present. A score of 1.0 indicates highest confidence, while 0.0 indicates lowest confidence.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec430"/>There's more...</h2></div></div></div><p>Using the intent is a quick and easy way to get speech recognition; however,  if you would prefer not to use the default Google activity, you can call the <code class="literal">SpeechRecognizer</code> class directly. Here's an example of how to instantiate the class:</p><div><pre class="programlisting">SpeechRecognizer speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this);</pre></div><p>You will need to add the <code class="literal">RECORD_AUDIO</code> permission and implement the <code class="literal">RecognitionListener</code> class to handle the speech events. (See the following links for more information.)</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec431"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: RecognizerIntent</strong> <a id="id926" class="indexterm"/>at <a class="ulink" href="http://developer.android.com/reference/android/speech/RecognizerIntent.html">http://developer.android.com/reference/android/speech/RecognizerIntent.html</a></li><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: SpeechRecognizer</strong> <a id="id927" class="indexterm"/>at <a class="ulink" href="http://developer.android.com/reference/android/speech/SpeechRecognizer.html">http://developer.android.com/reference/android/speech/SpeechRecognizer.html</a></li><li class="listitem" style="list-style-type: disc"><strong>Developer Docs: RecognitionListener</strong> <a id="id928" class="indexterm"/>at <a class="ulink" href="http://developer.android.com/reference/android/speech/RecognitionListener.html">http://developer.android.com/reference/android/speech/RecognitionListener.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec114"/>Push Notification using GCM</h1></div></div></div><p>GCM, Google's version of Push Notification, allows your application to receive messages. The idea is similar to SMS messages, but much more flexible. There are three components to <a id="id929" class="indexterm"/>GCM:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Your server (this is where you initiate the message)</li><li class="listitem" style="list-style-type: disc">Google's GCM server</li><li class="listitem" style="list-style-type: disc">Android device (although GCM is also available on other platforms)</li></ul></div><p>When the user starts your <a id="id930" class="indexterm"/>application, your code needs to connect to the GCM server and obtain a device token, then send that token to your server. Your server is responsible for initiating the message and passing it to the GCM server. Your server needs to track the device tokens that have to be sent when initiating the message. (Your server tells the GCM server which device tokens needs to be sent.)</p><p>You can implement your own server or choose to use one of many services available. The next chapter, <em>Backend Service Options</em>, will look at several BaaS options, many of which also offer Push Notification. (The <em>Simple Testing Option</em> section offers an option to verify that your code is working.)</p><p>This recipe will walk you through the steps to add GCM using the current (Version 8.3) Google Services library. Before getting to the steps, it's worth noting that GCM is supported all the way back to API 8, as long as the user has a Google account. A Google account is not required after Android 4.0.4.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec432"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it <code class="literal">GCM</code>. Use the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p><p>GCM uses the Google Services plugin, which requires a Google Services configuration file available from the Google Developer Console. To create the configuration file, you will need the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Your application<a id="id931" class="indexterm"/> package name</li><li class="listitem" style="list-style-type: disc">When you have the information, log in to this Google link and follow the wizard to enable GCM for your app: <a class="ulink" href="https://developers.google.com/mobile/add">https://developers.google.com/mobile/add</a></li></ul></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>If you download the source files, you will need to create a new package name when following the preceding steps, as the existing package name has already been registered.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec433"/>How to do it...</h2></div></div></div><p>After completing the preceding Getting Ready section, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the <code class="literal">google-services.json</code> file, which you downloaded in the <em>Getting Ready</em> section, to your app folder (&lt;project folder&gt;\<code class="literal">GCM\app</code>).</li><li class="listitem">Open the project Gradle build file: <code class="literal">build.gradle (Project: GCM)</code>, and add the following to the <code class="literal">buildscript dependencies</code> sections:<div><pre class="programlisting">classpath 'com.google.gms:google-services:1.5.0-beta2'</pre></div></li><li class="listitem">Open the app module Gradle build file: <code class="literal">build.gradle (Module: app)</code>, and add the following statement to the beginning of the file (above the <code class="literal">android</code> section):<div><pre class="programlisting">apply plugin: 'com.google.gms.google-services'</pre></div></li><li class="listitem">In the same module build file as step 3, add the following statement to the dependencies section:<div><pre class="programlisting">compile 'com.google.android.gms:play-services-auth:8.3.0'</pre></div></li><li class="listitem">Open the Android Manifest and add the following permissions:<div><pre class="programlisting">&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
&lt;permission android:name="&lt; packageName &gt;.permission.C2D_MESSAGE"
    android:protectionLevel="signature" /&gt;
&lt;uses-permission android:name="&lt; packageName &gt;.permission.C2D_MESSAGE" /&gt;</pre></div></li><li class="listitem">Within the <code class="literal">&lt;application&gt;</code> element, add the following <code class="literal">&lt;receiver&gt;</code> and <code class="literal">&lt;service&gt;</code> <a id="id932" class="indexterm"/>declarations (these should be at the same level as the <code class="literal">&lt;activity&gt;</code>):<div><pre class="programlisting">&lt;receiver
    android:name="com.google.android.gms.gcm.GcmReceiver"
    android:exported="true"
    android:permission="com.google.android.c2dm.permission.SEND" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.android.c2dm.intent.RECEIVE" /&gt;
        &lt;category android:name="&lt;packageName&gt;" /&gt;
        &lt;action android:name="com.google.android.c2dm.intent.REGISTRATION" /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
&lt;service
    android:name=".GCMService"
    android:exported="false" &gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.android.c2dm.intent.GCM_RECEIVED_ACTION"/&gt;
        &lt;action android:name="com.google.android.c2dm.intent.RECEIVE" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
&lt;service
    android:name=".GCMInstanceService"
    android:exported="false"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.google.android.gms.iid.InstanceID" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
&lt;service
    android:name=".GCMRegistrationService"
    android:exported="false"&gt;
&lt;/service&gt;</pre></div></li><li class="listitem">Create a new Java class called <code class="literal">GCMRegistrationService</code> that extends <code class="literal">IntentService</code>, as follows:<div><pre class="programlisting">public class GCMRegistrationService extends IntentService {

    private final String SENT_TOKEN="SENT_TOKEN";

    public GCMRegistrationService() {
        super("GCMRegistrationService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        super.onCreate();
        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
        try {
            InstanceID instanceID = InstanceID.getInstance(this);
            String token = instanceID.getToken(getString(R.string.gcm_defaultSenderId), GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
            Log.i("GCMRegistrationService", "GCM Registration Token: " + token);
            //sendTokenToServer(token);
            sharedPreferences.edit().putBoolean(SENT_TOKEN, true).apply();
        } catch (Exception e) {
            sharedPreferences.edit().putBoolean(SENT_TOKEN, false).apply();
        }
    }
}</pre></div></li><li class="listitem">Create a new Java <a id="id933" class="indexterm"/>class called <code class="literal">GCMInstanceService</code> that extends <code class="literal">InstanceIDListenerService</code>, as follows:<div><pre class="programlisting">public class GCMInstanceService extends InstanceIDListenerService {
    @Override
         public void onTokenRefresh() {
        Intent intent = new Intent(this, GCMRegistrationService.class);
        startService(intent);
    }
}</pre></div></li><li class="listitem">Create a new Java class called <code class="literal">GCMService</code> that extends <code class="literal">GcmListenerService, </code>as follows:<div><pre class="programlisting">public class GCMService extends GcmListenerService {

    @Override
    public void onMessageReceived(String from, Bundle data) {
        super.onMessageReceived(from, data);
        Log.i("GCMService", "onMessageReceived(): " + data.toString());
    }
}</pre></div></li><li class="listitem">Add the following code to the existing <code class="literal">onCreate()</code> callback:<div><pre class="programlisting">Intent intent = new Intent(this, GCMRegistrationService.class);
startService(intent);</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec434"/>How it works...</h2></div></div></div><p>Most of the actual GCM code is encapsulated within the Google APIs, simplifying the implementation. We just have to set up the project to include Google Services, and give our app the required permissions.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>
<strong>Important</strong>! When adding the permissions in Steps 5 and 6, replace the <code class="literal">&lt;packageName&gt;</code> placeholder with your application's package name.</p></div></div><p>The most complicated<a id="id934" class="indexterm"/> aspect of GCM is probably the multiple services required. Even though the code in each service is minimal, each service has a specific task. There are two main aspects of GCM:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Registering the app with the GCM server</li><li class="listitem" style="list-style-type: disc">Receiving messages</li></ul></div><p>This is the code to register with the GCM server:</p><div><pre class="programlisting">String token = instanceID.getToken(getString(R.string.gcm_defaultSenderId), GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);</pre></div><p>We don't call <code class="literal">getToken()</code> in the Activity, because it could block the UI thread. Instead, we call the <code class="literal">GCMRegistrationService</code>, which handles the call in a background thread. After you receive the device token, you need to send it to your server, as it is needed when initiating a message.</p><p>The process of receiving a GCM message is handled in <code class="literal">GCMService</code>, which extends <code class="literal">GcmListenerService</code>. Since the Google API already handles most of the work, all we have to do is respond to the <code class="literal">onMessageReceived()</code> callback.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec435"/>There's more...</h2></div></div></div><p>To make it easier to type, we left out an<a id="id935" class="indexterm"/> important Google Services API verification that should be included in any production application. Instead of calling <code class="literal">GCMRegistrationService</code> directly, as we did in  <code class="literal">onCreate()</code> in the preceding section, first check whether the Google API Service is available. Here's an example showing how to call the <code class="literal">isGooglePlayServicesAvailable()</code> method:</p><div><pre class="programlisting">private boolean isGooglePlayServicesAvailable() {
    GoogleApiAvailability googleApiAvailability = GoogleApiAvailability.getInstance();
    int resultCode = googleApiAvailability.isGooglePlayServicesAvailable(this);
    if (resultCode != ConnectionResult.SUCCESS) {
        if (googleApiAvailability.isUserResolvableError(resultCode)) {
            googleApiAvailability.getErrorDialog(this, resultCode, PLAY_SERVICES_RESOLUTION_REQUEST).show();
        } else {
            Toast.makeText(MainActivity.this, "Unsupported Device", Toast.LENGTH_SHORT).show();
            finish();
        }
        return false;
    }
    return true;
}</pre></div><p>Then, change the <code class="literal">onCreate()</code> code to call this method first:</p><div><pre class="programlisting">if (isGooglePlayServicesAvailable()) {
    Intent intent = new Intent(this, GCMRegistrationService.class);
    startService(intent);
}</pre></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec60"/>Simple testing option</h3></div></div></div><p>To help to verify that your code is <a id="id936" class="indexterm"/>working correctly, a testing application was created and posted on Google Play. This app will run on both a physical device and an emulator. The Google Play listing also includes a link to download the source code and run the project directly, making it easier to enter the required fields.</p><div><div><h3 class="title"><a id="tip37"/>Tip</h3><p>
<strong>GCM (Push Notification) Tester</strong>: Refer to the following link for more information:</p><p>
<a class="ulink" href="https://play.google.com/store/apps/details?id=com.eboyer.gcmtester">https://play.google.com/store/apps/details?id=com.eboyer.gcmtester</a>
</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec436"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the Google Cloud Messaging web page<a id="id937" class="indexterm"/> at <a class="ulink" href="https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging">https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging</a></li><li class="listitem" style="list-style-type: disc">Refer to the About the GCM Connection server web page<a id="id938" class="indexterm"/> at <a class="ulink" href="https://developers.google.com/cloud-messaging/server">https://developers.google.com/cloud-messaging/server</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch14lvl1sec115"/>How to add Google sign-in to your app</h1></div></div></div><p>A Google sign-in<a id="id939" class="indexterm"/> allows your users to sign in to your application <a id="id940" class="indexterm"/>using their Google credentials. This recipe will walk you through the process of adding a Google sign-in to your application. Here's a screenshot showing the Google sign-in button in the application that we'll create in the recipe:</p><div><img src="img/B05057_14_1.jpg" alt="How to add Google sign-in to your app"/></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec437"/>Getting ready</h2></div></div></div><p>Create a new project in <a id="id941" class="indexterm"/>Android Studio and call it <code class="literal">GoogleSignIn</code>. Use <a id="id942" class="indexterm"/>the default <strong>Phone &amp; Tablet </strong>option and select <strong>Empty Activity</strong> when prompted for <strong>Activity Type</strong>.</p><p>The Google sign-in uses the Google Services plugin, which requires a Google Services Configuration file, which is available from the Google Developer Console. To create the configuration file, you will need the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Your application package name</li><li class="listitem" style="list-style-type: disc">Your signing certificate's SHA-1 hash code (see the <em>Authenticating Your Client</em> link at the end of the recipe for more information)</li></ul></div><p>When you have the information, log in to this Google link and follow the wizard to enable sign-in:</p><p>
<a class="ulink" href="https://developers.google.com/mobile/add">https://developers.google.com/mobile/add</a>
</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>If you are downloading the source files, you will need to create a new package name when following the preceding steps, as the existing package name has already been registered.</p></div></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec438"/>How to do it...</h2></div></div></div><p>After completing<a id="id943" class="indexterm"/> the preceding <em>Getting Ready</em> section, follow <a id="id944" class="indexterm"/>these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the <code class="literal">google-services.json</code> file you downloaded in the <em>Getting Ready</em> section to your app folder (<code class="literal">&lt;project folder&gt;\GoogleSignIn\app</code>)</li><li class="listitem">Open the project Gradle build file: <code class="literal">build.gradle (Project: GoogleSignIn)</code>, and add the following to the <code class="literal">buildscript dependencies</code> section:<div><pre class="programlisting">classpath 'com.google.gms:google-services:1.5.0-beta2'</pre></div></li><li class="listitem">Open the app module Gradle build file: <code class="literal">build.gradle (Module: app)</code>, and add the following statement to the beginning of the file (above the <code class="literal">android</code> section):<div><pre class="programlisting">apply plugin: 'com.google.gms.google-services'</pre></div></li><li class="listitem">In the same module build file as Step 3, add the following statement to the dependencies section:<div><pre class="programlisting">compile 'com.google.android.gms:play-services-auth:8.3.0'</pre></div></li><li class="listitem">Open <code class="literal">activity_main.xml</code> and replace the existing <code class="literal">TextView</code> with the following XML:<div><pre class="programlisting">&lt;TextView
    android:id="@+id/textView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_alignParentTop="true" /&gt;

&lt;com.google.android.gms.common.SignInButton
    android:id="@+id/signInButton"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_centerInParent="true" /&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following global declarations:<div><pre class="programlisting">private final int REQUEST_SIGN_IN=1;
GoogleApiClient mGoogleApiClient;</pre></div></li><li class="listitem">Add the following <code class="literal">OnConnectionFailedListener</code>:<div><pre class="programlisting">GoogleApiClient.OnConnectionFailedListener mOnConnectionFailedListener = new GoogleApiClient.OnConnectionFailedListener() {
    @Override
    public void onConnectionFailed(ConnectionResult connectionResult) {
        Toast.makeText(MainActivity.this, "connectionResult="+connectionResult.getErrorMessage(), Toast.LENGTH_SHORT).show();
    }
};</pre></div></li><li class="listitem">Add the <a id="id945" class="indexterm"/>following <a id="id946" class="indexterm"/>code to the existing <code class="literal">onCreate()</code>:<div><pre class="programlisting">GoogleSignInOptions googleSignInOptions = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
    .requestEmail()
    .build();
mGoogleApiClient = new GoogleApiClient.Builder(this)
    .addOnConnectionFailedListener(mOnConnectionFailedListener)
    .addConnectionCallbacks(mConnectionCallbacks)
    .addApi(Auth.GOOGLE_SIGN_IN_API, googleSignInOptions)
    .build();
findViewById(R.id.signInButton).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        signIn();
    }
});</pre></div></li><li class="listitem">Create an override for the <code class="literal">onActivityResult()</code> callback as follows:<div><pre class="programlisting">@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode == REQUEST_SIGN_IN) {
        GoogleSignInResult googleSignInResult = Auth.GoogleSignInApi.getSignInResultFromIntent(data);
        if (googleSignInResult.isSuccess()) {
            GoogleSignInAccount googleSignInAccount = googleSignInResult.getSignInAccount();
            TextView textView = (TextView)findViewById(R.id.textView);
            textView.setText("Signed in: " + googleSignInAccount.getDisplayName());
            findViewById(R.id.signInButton).setVisibility(View.GONE);
        }
    }
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec439"/>How it works...</h2></div></div></div><p>Google has made<a id="id947" class="indexterm"/> it relatively simple to add a Google sign-in with <a id="id948" class="indexterm"/>their <code class="literal">GoogleApiClient</code> and <code class="literal">GoogleSignInOptions</code> APIs. First, we create a <code class="literal">GoogleSignInOptions</code> object with the builder. This is where we specify the sign-in options we want, such as requesting e-mail ID. Then, we pass it to the <code class="literal">GoogleApiClient</code> builder.</p><p>When the user clicks on the Google sign-in button (created with the <code class="literal">com.google.android.gms.common.SignInButton</code> class), we send an Intent for <code class="literal">GoogleSignInApi</code> to the handle. We process the result in <code class="literal">onActivityResult()</code>. If the sign-in was successful, we can get the account details. In our example, we just get the e-mail, but additional information is available such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getDisplayName()</code>: This is the display name</li><li class="listitem" style="list-style-type: disc"><code class="literal">getEmail(</code><code class="literal">)</code>: The e-mail address</li><li class="listitem" style="list-style-type: disc"><code class="literal">getId()</code>: The unique ID for the Google account</li><li class="listitem" style="list-style-type: disc"><code class="literal">getPhotoUrl()</code>: The display photo</li><li class="listitem" style="list-style-type: disc"><code class="literal">getIdToken()</code>: This is for the backend authentication</li></ul></div><p>See the <em>GoogleSignInAccount</em> link in the <em>See also</em> section for a complete list.</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec440"/>There's more...</h2></div></div></div><p>If you want your application to be available to a wider audience, you'll want to think about localization.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec61"/>Localization resources</h3></div></div></div><p>Google provides many localized strings in the<a id="id949" class="indexterm"/> SDK, located at this link: <code class="literal">&lt;SDK install folder&gt;/sdk/extras/google/google_play_services/libproject/google-play-services_lib/res/</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec441"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the web page <a id="id950" class="indexterm"/>talking about authenticating your client at <a class="ulink" href="https://developers.google.com/android/guides/client-auth">https://developers.google.com/android/guides/client-auth</a></li><li class="listitem" style="list-style-type: disc">Visit GoogleSignInAccount<a id="id951" class="indexterm"/> at <a class="ulink" href="https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount">https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount</a></li></ul></div></div></div></body></html>