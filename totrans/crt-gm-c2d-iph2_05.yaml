- en: Chapter 5. Brick Breaking Balls with Box2D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用Box2D的砖块破碎球
- en: There is a lot you can do with cocos2d by itself. However, when you combine
    it with a true physics engine, such as Box2D or Chipmunk, you can do so much more.
    There is a steep learning curve, so this chapter will be both a new project and
    a basic primer on Box2D for the beginner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用cocos2d本身，你可以做很多事情。然而，当你将其与真正的物理引擎（如Box2D或Chipmunk）结合时，你可以做更多的事情。学习曲线很陡峭，所以本章将是一个新项目，也是对Box2D的入门级基本指南。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Box2D basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Box2D基础
- en: Building Box2D objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Box2D对象
- en: Using mouse joints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标关节
- en: Singleton classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例类
- en: Separate HUD layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离的HUD层
- en: Using plists to store level data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用plists存储关卡数据
- en: Changing game physics during play
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏过程中更改游戏物理
- en: The project is…
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目状态…
- en: In this chapter we will discuss the classic brick breaking game. Dating back
    to the early days of Atari, this game is a wonderful way to start exploring physics
    engines, because there aren't too many objects moving at the same time. If you
    are not familiar with this game, it is fairly easy to explain. The player controls
    a paddle at the bottom of the screen that can move side-to-side. The top portion
    of the screen has a number of bricks in fixed positions. There is a small ball
    bouncing around, and the player's job is to break all of the bricks without letting
    the ball past the paddle. Of course, the ball bounces around everywhere, so there
    are actually quite a lot of physics-based calculations needed to make it work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论经典的砖块破碎游戏。追溯到雅达利游戏的早期，这款游戏是探索物理引擎的一个美妙方式，因为同时移动的物体并不多。如果你不熟悉这款游戏，解释起来相当简单。玩家控制屏幕底部的球拍，可以左右移动。屏幕顶部有固定位置的砖块。有一个小球在四处弹跳，玩家的任务是打破所有砖块，不让球穿过球拍。当然，球到处弹跳，所以实际上需要很多基于物理的计算才能使其工作。
- en: 'Let''s take a look at the final game:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最终的游戏：
- en: '![The project is…](img/9007_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![项目状态…](img/9007_05_01.jpg)'
- en: Box2D – a primer
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Box2D – 入门指南
- en: Before we can even begin to think about our project, we need to review the basics
    of Box2D. There is a lot of depth to the Box2D engine, and we will only be scratching
    the surface in this book. This section aims to give an overview of the parts of
    the engine that we will need to interact with for this game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们甚至开始考虑我们的项目之前，我们需要回顾Box2D的基本知识。Box2D引擎有很多深度，在这本书中我们只会触及表面。本节旨在概述我们将需要与游戏交互的引擎部分。
- en: Box2D – what is it?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Box2D – 它是什么？
- en: To quote the manual, "Box2D is a 2D rigid body simulation library for games.
    Programmers can use it in their games to make objects move in believable ways
    and make the game world more interactive." That's a pretty straightforward description
    of what Box2D is, except for the "rigid body" term. What does that mean? Rigid
    body means that Box2D is built to simulate hard objects such as balls, walls,
    stone, metal, and so on. Box2D was not built to simulate "soft body" objects such
    as pillows, jelly, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引用手册中的话，“Box2D是一个用于游戏的2D刚体模拟库。程序员可以在他们的游戏中使用它来使物体以可信的方式移动，并使游戏世界更加互动。”这是对Box2D的相当直接描述，除了“刚体”这个术语。这是什么意思？刚体意味着Box2D被构建来模拟像球、墙壁、石头、金属等硬物体。Box2D并不是为了模拟像枕头、果冻等“软体”物体。
- en: 'We will briefly go through the basic terms of the Box2D environment here, and
    we will deal with everything in more detail when we build the game. The official
    documentation for Box2D is available at: [http://box2d.org/documentation.html](http://box2d.org/documentation.html)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里简要介绍Box2D环境的基本术语，当我们构建游戏时，我们将更详细地处理所有内容。Box2D的官方文档可在[http://box2d.org/documentation.html](http://box2d.org/documentation.html)找到。
- en: One important aspect of Box2D to be pointed out here is that it is written in
    C++, so there is a little bit of a language translation aspect when using Box2D
    with a game written primarily in Objective-C. For the most part, the two play
    together nicely, but you will have to gain some familiarity with C++ notation
    to make sense out of the Box2D-specific code. (If the C++ notation looks alien
    to you, we would advise consulting your favorite search engine to learn the basics
    of C++.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要指出Box2D的一个重要方面是它是用C++编写的，所以当使用Box2D与主要用Objective-C编写的游戏结合时，会有一些语言翻译方面的问题。大部分情况下，两者配合得很好，但你将需要熟悉一些C++符号，以便理解Box2D特定的代码。（如果C++符号对你来说很陌生，我们建议咨询你最喜欢的搜索引擎来学习C++的基础知识。）
- en: Basic parts of Box2D
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Box2D的基本部分
- en: The widest-reaching component of the Box2D environment is called a **world**.
    All objects created in Box2D will be contained in the world. This is where all
    movement, collisions, and so on take place. The world is also where we set the
    gravity of the environment. Normally, a given simulation will have only one Box2D
    world.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D环境中最广泛使用的组件被称为**世界**。Box2D中创建的所有对象都将包含在世界中。所有运动、碰撞等等都发生在这里。世界也是我们设置环境重力的地方。通常，一个给定的模拟只有一个Box2D世界。
- en: The next object that we have is called a **body**. A body represents a thing
    of some sort in the world. The body controls the position of the object, as well
    as other attributes necessary for the simulation, such as the body type. The body
    type lets you identify whether it is a static (non-moving) or dynamic (movable)
    body. A body does not directly "know" how big it is, how dense it is, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的对象被称为**身体**。身体代表世界中的某种事物。身体控制物体的位置，以及模拟所需的其它属性，例如身体类型。身体类型允许你识别它是一个静态（非移动）还是动态（可移动）的身体。身体并不直接“知道”它有多大，有多密集等等。
- en: A **shape** describes the geometry of the object. There are several different
    types of shapes supported by Box2D. The most commonly used are the circle shape,
    the polygon shape, and the edge shape. For a complete list of supported shapes,
    please refer to the Box2D documentation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**形状**描述了物体的几何形状。Box2D支持多种不同的形状。最常用的有圆形形状、多边形形状和边缘形状。有关支持的形状的完整列表，请参阅Box2D文档。
- en: A **fixture** can be thought of as the "glue" between the shape and the body.
    However, it is more than that. A fixture also defines core attributes of the object,
    such as density, friction, and restitution (aka bounciness).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**固定装置**可以被认为是形状和身体之间的“胶水”。然而，它不仅仅是这样。固定装置还定义了物体的核心属性，如密度、摩擦和恢复（也称为弹性）。
- en: Box2D supports a wide variety of **joints** to connect bodies together. There
    are distance joints, pulley joints, revolute joints, and so on. The only joints
    we will be concerned with in this game are the mouse joint and the prismatic joint,
    both used in the paddle controls.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D支持多种**关节**来连接物体。这些关节包括距离关节、滑轮关节、旋转关节等等。在本游戏中，我们只关心鼠标关节和棱柱关节，它们都用于控制拍子。
- en: As you might imagine, there is also a collision handler. One of the core components
    we use is called a **contact listener**. This is a very complex piece of software,
    and the one that makes us dive into C++ the most. We will only scratch the surface
    with a basic collision handler in this game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，还有一个碰撞处理器。我们使用的核心组件之一被称为**接触监听器**。这是一块非常复杂的软件，也是让我们深入C++的原因之一。在本游戏中，我们只会用基本的碰撞处理器来触及表面。
- en: A very important value is the `PTM_RATIO`. This is the Points-To-Meters Ratio.
    Internally, Box2D represents everything as meters. The default value for this
    ratio is 32, which represents 32 points as 1 meter in the simulation world. For
    most games, this will work perfectly. In our code, we will have to apply this
    `PTM_RATIO` to many calculations when we are converting locations between the
    cocos2D layer and the Box2D world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的值是`PTM_RATIO`。这是点与米的比例。在内部，Box2D将所有东西都表示为米。这个比例的默认值是32，表示在模拟世界中32个点等于1米。对于大多数游戏来说，这将完美工作。在我们的代码中，当我们需要在cocos2D层和Box2D世界之间转换位置时，我们必须将这个`PTM_RATIO`应用到许多计算中。
- en: On to the game!
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是游戏！
- en: We start our game from the Cocos2D + Box2D template, so it has all the libraries
    we need. To prepare for this project, we still go through the same motions from
    the template, namely removing `HelloWorldLayer.h/.mm`, and changing the references
    in the `IntroLayer.mm` to our menu class. There are a couple of additional classes
    in the template, `GLES-Render` and `PhysicsSprite`. We will deal with them later.
    We also need to switch the supported orientation to portrait only, as we did in
    the previous chapter. (Don't forget to also remove the background rotation line
    in the `IntroLayer.mm` file.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Cocos2D + Box2D模板开始我们的游戏，因此它包含了我们需要的所有库。为了准备这个项目，我们仍然按照模板中的相同步骤进行，即删除`HelloWorldLayer.h/.mm`，并将`IntroLayer.mm`中的引用更改为我们的菜单类。模板中还有一些额外的类，`GLES-Render`和`PhysicsSprite`。我们将在稍后处理它们。我们还需要将支持的朝向更改为仅竖屏，就像我们在上一章中所做的那样。（别忘了在`IntroLayer.mm`文件中删除背景旋转行。）
- en: With a Box2D project, it is important to note that all our implementation classes
    will need names that end in `.mm` instead of `.m`. This tells the compiler that
    we will be using a mixture of Objective-C and C++. You must do this with Box2D,
    because Box2D is written in C++. So where do we start?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D项目中，需要注意的是，我们所有的实现类都需要以`.mm`结尾而不是`.m`的名称。这告诉编译器我们将使用Objective-C和C++的混合。你必须这样做，因为Box2D是用C++编写的。那么我们该从哪里开始呢？
- en: World building
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界构建
- en: We will start with building the Box2D world itself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建Box2D世界本身开始。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the world is pretty easy to set up. Here we are defining `gravity`
    as zero, as we don't want our ball to slow down and we don't want our bricks falling
    off the screen. We then set up the world, which is assigned to a variable called
    `world`, which is a `b2World` variable type . When you set up the `b2World`, you
    define the gravity for the world. We will allow objects to sleep. Sleeping means
    that objects that are at rest will "sleep", so the simulation won't spend a lot
    of time calculating movements of a body at rest. However, if something else interacts
    with it (that is, runs into it), the body will wake up immediately and react appropriately.
    We set the continuous physics to be `true`. This allows for a more accurate simulation,
    but requires more computing power. We also establish the contact listener we will
    use for this world. We won't get into the details here – we will save that for
    our discussion about the collision handler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构建世界相当简单。在这里，我们将`重力`设置为零，因为我们不希望我们的球减速，也不希望我们的砖块从屏幕上掉落。然后我们设置了世界，它被分配给一个名为`world`的变量，这是一个`b2World`变量类型。当你设置`b2World`时，你为世界定义了重力。我们将允许物体进入休眠状态。休眠意味着静止的物体会“休眠”，因此模拟不会花费大量时间计算静止物体的运动。然而，如果其他物体与之交互（即，撞到它），该物体将立即醒来并做出适当的反应。我们将连续物理设置为`true`。这允许更精确的模拟，但需要更多的计算能力。我们还为这个世界建立了我们将使用的接触监听器。这里我们不会深入细节——我们将把那留给关于碰撞处理器的讨论。
- en: If you're confused by the C++ syntax here, it is helpful to know that the lines
    with the arrow (->) symbol are calling functions from the object to the left-hand
    side of the arrow. So the line `world->SetContactListener(contactListener);` would
    look like `[world setContactListener:contactListener];`, if Box2D was written
    in Objective-C.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里对C++语法感到困惑，了解以下信息可能会有所帮助：带有箭头（->）符号的行是从箭头左侧的对象调用函数。所以，如果Box2D是用Objective-C编写的，那么`world->SetContactListener(contactListener);`这一行将看起来像`[world
    setContactListener:contactListener];`。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although there are some wrappers that allow you to use Box2D with Objective-C
    syntax, as of this writing none of the projects are mature enough to be recommended
    here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些包装器允许你使用Objective-C语法使用Box2D，但截至本文写作，没有哪个项目足够成熟可以在这里推荐。
- en: On the edge
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在边缘
- en: 'Now that we have a world, we can start defining "stuff" to go in our world.
    Let''s start with some edges for the screen:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了世界，我们可以开始定义要放入我们世界中的“东西”。让我们从屏幕的一些边缘开始：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've written quite a bit of new code here, so let's break it down. First we
    defined a new body definition (`b2BodyDef`), called `wallBodyDef`. It is an extremely
    basic body. We then tell the `world` to create a `body` using the `b2BodyDef`
    we just created, and we keep a reference to it. Our world now has one formless,
    shapeless body in it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里编写了很多新的代码，所以让我们来分解一下。首先，我们定义了一个新的身体定义（`b2BodyDef`），称为`wallBodyDef`。这是一个极其简单的身体。然后我们告诉`world`使用我们刚刚创建的`b2BodyDef`来创建一个`body`，并保留对其的引用。我们的世界现在有一个无形无状的物体。
- en: We fix the "shapeless" problem next. We begin by defining the positions for
    each of the four corners of our playing area, using a shorthand naming pattern
    (that is, bl = bottom left, br = bottom right, and so on). There are two important
    things we need to point out here. For all non-zero positions, we divide the "normal"
    screen position by the `PTM_RATIO`. This is the standard way we can convert the
    `ccp` value we normally would use into a Box2D-friendly coordinate. As you recall,
    PTM means Points-To-Meters, so 32 screen points equals 1 meter in the simulation
    world. Doing this conversion keeps our display and our Box2D simulation in sync.
    You may also notice we are using the `maxY` value of `424`, rather than the top
    of the screen. Our game has a Heads-Up Display covering the top portion of the
    screen, and a `y` value of 424 places this top edge at the bottom of that display
    HUD. We really don't want our player losing their ball under the Heads-Up Display,
    do we?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来解决“无形状”的问题。我们首先使用简写命名模式（即，bl = bottom left，br = bottom right 等）为游戏区域四个角的位置定义。这里有两件重要的事情需要指出。对于所有非零位置，我们将“正常”屏幕位置除以
    `PTM_RATIO`。这是我们可以将我们通常使用的 `ccp` 值转换为 Box2D 友好坐标的标准方式。如您所回忆，PTM 代表 Points-To-Meters，所以
    32 屏幕点等于模拟世界中的 1 米。进行这种转换可以保持我们的显示和 Box2D 模拟同步。您也可能注意到我们使用 `maxY` 值为 `424`，而不是屏幕的顶部。我们的游戏有一个覆盖屏幕顶部部分的抬头显示（Heads-Up
    Display），`y` 值为 424 将这个显示的顶部边缘放置在抬头显示的底部。我们真的不希望玩家在抬头显示下丢失他们的球，对吧？
- en: We then create four `b2EdgeShape` objects, for each side of the screen. We use
    our corner variables to define their positions, using the `Set` function. We then
    instruct the `wallBody` to create a fixture for each of these walls. You will
    notice that we set the variable `bottomGutter` to the returned value of the `CreateFixture`
    command. We will use this later in the collision handler to determine when the
    player lost his ball.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了四个 `b2EdgeShape` 对象，分别对应屏幕的每一侧。我们使用我们的角变量来定义它们的位置，通过使用 `Set` 函数。然后我们指示
    `wallBody` 为这些墙壁中的每一个创建一个固定装置。你会注意到我们将变量 `bottomGutter` 设置为 `CreateFixture` 命令返回的值。我们将在后面的碰撞处理程序中使用这个值来确定玩家何时失去了他的球。
- en: Having a ball
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥有一个球
- en: 'So far we have a world with walls, but we don''t have any moving parts yet.
    Let''s build a ball to bounce around:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个带有墙壁的世界，但我们还没有任何移动部件。让我们构建一个球来四处弹跳：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Building a dynamic object is a little more involved than building the edges,
    but the same basic concepts still apply. Because the ball will have a visible
    sprite associated with the body, we first build a `PhysicsSprite` object. `PhysicsSprite`
    is one of the classes in the cocos2d + Box2D template we used to create the project.
    It is a subclass of `CCSprite`, but includes a couple of extra methods that will
    automatically keep the sprite locked in position with the physics body connected
    to it. The only thing we need to do differently than a normal `CCSprite` is to
    call `setPhysicsBody` on it, which connects the Box2D body to the sprite. The
    end result is that we do not have to manually move (or rotate) the sprite. Without
    this "helper" class, we would be responsible for updating the position and rotation
    of the sprite ourselves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个动态对象比构建边缘稍微复杂一些，但基本概念仍然适用。因为球将有一个与身体关联的可见精灵，我们首先构建一个 `PhysicsSprite` 对象。`PhysicsSprite`
    是我们在创建项目时使用的 cocos2d + Box2D 模板中的一个类。它是 `CCSprite` 的一个子类，但包含了一些额外的函数，这些函数可以自动将精灵锁定在与其关联的物理身体的位置上。我们与一个正常的
    `CCSprite` 不同之处仅在于调用 `setPhysicsBody`，这会将 Box2D 身体连接到精灵。最终结果是，我们不需要手动移动（或旋转）精灵。如果没有这个“辅助”类，我们就需要自己更新精灵的位置和旋转。
- en: You will also notice that we assign a `tag` value to the ball. This will be
    useful later, when we are dealing with collisions. (The `tag` definitions are
    contained in `typedef enum` in the `BRDefinitions.h` file.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们给球分配了一个 `tag` 值。这将在我们处理碰撞时很有用。（`tag` 定义包含在 `BRDefinitions.h` 文件中的 `typedef
    enum` 中。）
- en: We then build a body for the ball. We assign it a type of `b2_dynamicBody`,
    to let Box2D know that this is a body that can move. We set the position of the
    body to correspond to the position of the sprite. A body is by default anchored
    in the middle, just like a `CCSprite`. We can use the same coordinates for the
    body (divided by the `PTM_RATIO`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为球构建一个身体。我们将其分配为 `b2_dynamicBody` 类型，以便让 Box2D 知道这是一个可以移动的身体。我们将身体的位子设置与精灵的位置相对应。一个身体默认情况下锚定在中间，就像一个
    `CCSprite`。我们可以使用相同的坐标来设置身体（除以 `PTM_RATIO`）。
- en: The `userData` is a flexible part of the body definition; `userData` can hold
    anything you want to store in it. `userData` is customarily used to hold a reference
    to the `CCSprite` object (or the `PhysicsSprite` object , in our case) that represents
    the actor. Following this convention makes it a trivial matter to get to the sprite
    from the body.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`userData`是身体定义中的一个灵活部分；`userData`可以存储你想要存储的任何内容。`userData`通常用来存储代表演员的`CCSprite`对象（或在我们的情况下是`PhysicsSprite`对象）的引用。遵循这个约定使得从身体获取精灵变得非常简单。'
- en: After we instruct the world to create a body with this definition, we define
    a shape. Since we are using a round ball, the `b2CircleShape` is perfect. We define
    the shape's radius by taking the radius of the ball (half the sprite width) and
    dividing by the `PTM_RATIO`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向世界指示使用这个定义来创建一个身体之后，我们定义了一个形状。由于我们使用的是一个圆形球体，所以`b2CircleShape`是完美的。我们通过取球体的半径（精灵宽度的一半）并除以`PTM_RATIO`来定义形状的半径。
- en: We then build the fixture to represent the "guts" that accompany the body. We
    assign the circle shape we just defined, and then we set the `density`, `friction`,
    and `restitution`. Density is used in the calculation of mass. The higher the
    density, the more massive the object is. Friction is used to control how the objects
    slide along each other. Friction is normally set between 0 and 1\. Higher friction
    values will slow objects down as they slide against each other. We don't want
    any friction on the ball to keep it moving nicely. The final parameter here is
    `restitution`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建一个固定装置来表示伴随身体的“内部结构”。我们分配了我们刚刚定义的圆形形状，然后设置了`密度`、`摩擦`和`恢复系数`。密度用于质量的计算。密度越高，物体越重。摩擦用于控制物体如何相互滑动。摩擦通常设置在0到1之间。较高的摩擦值会在物体相互滑动时减慢它们的速度。我们不希望球体有任何摩擦以保持其运动。这里的最后一个参数是`恢复系数`。
- en: The term restitution is less familiar than the other two, but you can think
    of it as how bouncy the object is. A value of zero means the object will not bounce
    at all. A value of 1 means the object is perfectly bouncy, and will not lose any
    of its velocity when it impacts another object. We don't want the ball to lose
    any velocity when it collides, so we use a value of 1 for the restitution of the
    ball.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “恢复系数”这个术语不如其他两个熟悉，但你可以将其视为物体的弹跳性。零值表示物体根本不会弹跳。1的值表示物体是完全弹性的，在撞击另一个物体时不会损失任何速度。我们不希望球体在碰撞时损失任何速度，因此我们为球体的恢复系数使用1。
- en: After we define the fixture, we create it with the `ballBody`. As a final step,
    we add a linear impulse to the ball, based on the message passed to this method.
    An impulse is basically a kick, with the strength and direction of the impulse
    controlled by the `b2Vec2` parameter, here called `impulse`. The second argument
    `ballBody->GetPosition()` returns the center of the `ballBody`. This will apply
    the impulse to the center of the body, so we get a straight application of the
    impulse.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了固定装置之后，我们使用`ballBody`创建它。作为最后的步骤，我们根据传递给这个方法的消息给球体添加一个线性冲量。冲量基本上是一个“踢”，冲量的强度和方向由`b2Vec2`参数控制，这里称为`impulse`。第二个参数`ballBody->GetPosition()`返回`ballBody`的中心。这将把冲量应用到身体的中心，因此我们得到冲量的直接应用。
- en: Now we need a `newBall` method that will always start the ball in the same position,
    and give it a decent impulse to set it in motion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个`newBall`方法，它将始终从相同的位置开始球体，并给它一个合理的冲量以使其运动。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we see from the `newBall` method, we give the ball a very slight "kick" with
    the initial impulse, down and to the right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从`newBall`方法中我们可以看到，我们给球体一个非常轻微的“踢”作为初始冲量，向下并向右。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `b2Vec2()` is equivalent to a `ccp()`, and uses the same bottom-left origin
    point.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2Vec2()`与`ccp()`等价，并使用相同的左下角原点。'
- en: Setting everything in motion
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切置于运动
- en: At this point we have a world, we have edges to hold everything in, and we have
    a ball. Now we need to get it all moving. As you might expect, we handle this
    in the `update` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个世界，我们有一些边缘来保持一切，我们有一个球体。现在我们需要让所有这些开始运动。正如你所期望的，我们在`update`方法中处理这个问题。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an abbreviated form of our final `update` method, with just the ball
    movement handling in place. We start by instructing the world to step forward
    in its simulation. The three parameters sent to the `Step` function are, in order,
    the **time step**, the **velocity iterations** , and the **position iterations**.
    In this game, we are using a variable time step (using the delta value `dt`),
    which works well in our case. More intensive and detailed simulations are better
    suited to use a fixed time step. (Point your favorite search engine to the topic
    to learn more about how to implement a fixed time step.) The velocity iterations
    and position iterations control how detailed the simulation is. A value of 10
    for both iteration values is a good starting point for most projects. Higher values
    will result in more accuracy, but the trade-off is more of a processor load to
    calculate the simulation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们最终`更新`方法的简化版，只实现了球体运动处理。我们首先指示世界在模拟中向前一步。发送给`Step`函数的三个参数依次是**时间步长**、**速度迭代**和**位置迭代**。在这个游戏中，我们使用可变时间步长（使用`dt`的增量值），在我们的情况下效果很好。更密集和详细的模拟更适合使用固定时间步长。（将您喜欢的搜索引擎指向该主题，了解更多关于如何实现固定时间步长的信息。）速度迭代和位置迭代控制模拟的详细程度。对于大多数项目来说，两个迭代值都为10是一个良好的起点。更高的值将导致更高的精度，但代价是计算模拟时的处理器负载更大。
- en: Now that we have made one step forward in time for the world, we evaluate all
    of the bodies in the world to determine what we should do with them. We iterate
    through the world's bodies with `world->GetBodyList()`, and advance to the next
    body with `b->GetNext()`. For each body we find, we evaluate whether or not it
    has a sprite attached by checking that `userData` is not null. When we find a
    body with a sprite, we get a sprite reference from that body's `userData`. (We
    already have the variable `b` to represent the body, from the `for` loop.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为世界向前推进了一步，我们评估世界中的所有物体，以确定我们应该如何处理它们。我们使用`world->GetBodyList()`遍历世界中的物体，并通过`b->GetNext()`前进到下一个物体。对于找到的每个物体，我们检查`userData`是否不为空，以确定它是否附有精灵。当我们找到一个带有精灵的物体时，我们从该物体的`userData`中获取精灵引用。（我们已经有变量`b`来表示物体，来自`for`循环。）
- en: Because the ball might pick up speed during the game, we put in a speed clamping
    check next. If the sprite is a ball, and the speed is over the set value of 15,
    the body has **linear damping** applied, which will affect the velocity of the
    ball on the next step of the simulation. Damping is essentially applying the brakes
    on the object. We use a value of 0.5, which will slow the ball down, but not stop
    it completely. This acts the same as tapping the brakes in a car, decreasing the
    forward velocity a little bit at a time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为球体在游戏中可能会加速，所以我们接下来加入了一个速度限制检查。如果精灵是球体，并且速度超过设定的15，则对物体应用**线性阻尼**，这将影响球体在模拟下一步的速度。阻尼本质上是在对象上施加制动。我们使用0.5的值，这将减慢球体的速度，但不会完全停止它。这和汽车轻踩刹车一样，每次都会稍微减少前向速度。
- en: You will notice that we don't actually move the ball sprite at all. Because
    we are using a `PhysicsSprite` object instead of a `CCSprite` object, it will
    automatically take care of that for us.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们实际上并没有移动球体精灵。因为我们使用的是`PhysicsSprite`对象而不是`CCSprite`对象，它会自动为我们处理这一点。
- en: Collision handling
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: 'The code we have reviewed so far will make the ball bounce around the screen,
    but nothing interesting will happen when the ball hits the wall, except it will
    bounce around. What we need is to add a way to take some action when certain objects
    collide with others. We do this by implementing a contact listener. A contact
    listener has four components: `BeginContact`, `EndContact`, `PreSolve`, and `PostSolve`.
    Going into detail on each of these is beyond the scope of this book. For our project,
    we will only be implementing a simplified contact listener with code for `BeginContact`
    and `EndContact` only. Let''s look at the header first:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止审查的代码将使球体在屏幕上弹跳，但当球体碰到墙壁时，除了弹跳外不会发生任何有趣的事情。我们需要添加一种方式，当某些物体与其他物体碰撞时执行某些操作。我们通过实现一个接触监听器来完成这个任务。接触监听器有四个组件：`BeginContact`、`EndContact`、`PreSolve`和`PostSolve`。详细说明每个组件超出了本书的范围。对于我们的项目，我们只将实现一个简化的接触监听器，只包含`BeginContact`和`EndContact`的代码。让我们首先看看头文件：
- en: '**Filename:** `BRContactListener.h`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRContactListener.h`'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can look at the implementation file for this class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看这个类的实现文件：
- en: '**Filename:** `BRContactListener.mm`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRContactListener.mm`'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the simplified contact listener published as part of a tutorial by Ray
    Wenderlich ([http://raywenderlich.com](http://raywenderlich.com)), so any credit
    for this approach belongs to Ray. The basic design of this contact listener is
    to get the fixtures that are in contact (that is, colliding), and copy them out
    to `_contacts`, so we can evaluate them in our `BRPlayfieldLayer` instead of here.
    This copying is done in the `BeginContact`. `EndContact` removes the contact from
    `_contacts`, so that we are not evaluating outdated contacts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是作为Ray Wenderlich教程的一部分发布的简化版接触监听器（[http://raywenderlich.com](http://raywenderlich.com)），因此任何关于这种方法的赞誉都应归功于Ray。这个接触监听器的基本设计是获取接触（即碰撞）的固定物，并将它们复制到`_contacts`中，这样我们就可以在我们的`BRPlayfieldLayer`中评估它们，而不是在这里。这种复制是在`BeginContact`中完成的。`EndContact`从`_contacts`中删除接触，这样我们就不会评估过时的接触。
- en: One nice aspect of this approach is that the contact listener itself is general-purpose
    enough to be used as it is in many projects. If you are less experienced with
    C++, having boilerplate code like this is always helpful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点之一是接触监听器本身足够通用，可以直接用于许多项目。如果你对C++不太熟悉，像这样的样板代码总是有帮助的。
- en: Losing your ball
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢失你的球
- en: At this point, we would expect our ball to be lost when it reaches the bottom
    edge of the screen. But instead, it will simply bounce off because we have not
    defined any custom behavior for when the ball and the fixture at the bottom of
    the screen collide. If you recall, when we defined the edges, we kept a variable,
    `bottomGutter`, for this purpose.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们预计当球到达屏幕底部边缘时，球会丢失。但相反，球会简单地弹起，因为我们没有为球和屏幕底部固定物相撞时定义任何自定义行为。如果你还记得，当我们定义边缘时，我们保留了一个变量，`bottomGutter`，用于此目的。
- en: We will be handling our collisions in our `update` method, directly after the
    `for` loop from earlier, where we controlled the ball's speed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`update`方法中处理碰撞，直接在之前的`for`循环之后，在那个循环中我们控制了球的速度。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code block we are mostly using C++ structures, but the concepts are
    straightforward. We begin by defining two vectors, which are a form of dynamic
    array. The `toDestroy` vector will house any objects that need to be destroyed.
    The vector `pos` is an iterator which, as the name suggests, is used to iterate
    over data elements. We then enter a `for` loop, which iterates over the contents
    of the `_contacts` variable that was populated in the contact listener. Inside
    the loop, we use the variable `contact` to represent the current contact/collision
    from `_contacts` that we are evaluating.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们主要使用C++结构，但概念很简单。我们首先定义了两个向量，这是一种动态数组的形式。`toDestroy`向量将存放需要销毁的任何对象。`pos`向量是一个迭代器，正如其名所示，用于遍历数据元素。然后我们进入一个`for`循环，该循环遍历在接触监听器中填充的`_contacts`变量的内容。在循环内部，我们使用变量`contact`来表示从`_contacts`中评估的当前接触/碰撞。
- en: As the contact contains the fixtures that are contacting one another, we use
    the `GetBody()` function of the fixtures to get the two bodies involved, naming
    them `bodyA` and `bodyB`. We will need to get the tags from the attached `CCSprite`
    objects, so we also create `spriteA` and `spriteB` to represent the sprites associated
    with those bodies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接触包含相互接触的固定物，我们使用固定物的`GetBody()`函数来获取涉及的两个身体，分别命名为`bodyA`和`bodyB`。我们需要从附加的`CCSprite`对象中获取标签，因此我们还创建了`spriteA`和`spriteB`来表示与这些身体关联的精灵。
- en: 'For now, we only have one type of collision that we need to address: the ball
    with the `bottomGutter` fixture. We identify the ball based on the sprite''s tag
    of `kBall`, and we can identify the `bottomGutter` fixture because we stored a
    reference when it was created. To determine if we had a collision, we simply have
    to evaluate both objects to determine if one is a ball and other is the `bottomGutter`
    fixture. You will see from the code that we evaluate the collision twice, once
    comparing the "A" object to the ball and the "B" to the fixture, and then we evaluate
    again, with "A" and "B" swapped. We do this because the contact listener does
    not provide the fixtures "A" and "B" in any particular order. The ball might be
    "A" this time, and "B" the next time. The only way to reliably evaluate this is
    to have two checks for each collision in this manner. (You could always create
    a helper function to evaluate both of these ways for you, but it only results
    in slightly more compact code, but not necessarily any better performance.)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要处理一种类型的碰撞：球与`bottomGutter`固定装置的碰撞。我们根据精灵的标签`kBall`来识别球，而我们可以通过创建时存储的引用来识别`bottomGutter`固定装置。为了确定是否发生了碰撞，我们只需评估这两个物体，以确定一个是否是球，另一个是否是`bottomGutter`固定装置。您将从代码中看到我们评估了两次碰撞，一次是将"A"对象与球比较，将"B"与装置比较，然后再次评估，这次是交换"A"和"B"。我们这样做是因为接触监听器不会以任何特定的顺序提供"A"和B这两个装置。这次球可能是"A"，下次可能是"B"。唯一可靠地评估这种碰撞的方法是在每次碰撞中对此类进行两次检查。（您始终可以创建一个辅助函数来为您评估这两种方式，但这只会使代码略微更紧凑，但不一定会有更好的性能。）
- en: In both cases, if we identified a collision between the ball and the `bottomGutter`,
    then the offending body is added to the `toDestroy` vector. The additional `if`
    statement wrapped around it is checking to make sure this body is not already
    in the `toDestroy` vector, because we won't be able to destroy the same body twice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，如果我们识别到球与`bottomGutter`的碰撞，那么违规的物体就会被添加到`toDestroy`向量中。围绕它包裹的额外`if`语句是用来确保这个物体尚未在`toDestroy`向量中，因为我们不能两次销毁同一个物体。
- en: Destruction
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁
- en: Now we have identified the objects to be destroyed, but we haven't actually
    destroyed anything. Just as with Objective-C, you should not attempt to remove
    objects from an array while iterating through it, and C++ vectors are no exception.
    As such, after we have evaluated all of our collisions, we add one more block
    of code at the bottom of the `update` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了要销毁的物体，但实际上还没有销毁任何东西。就像Objective-C一样，您不应该在遍历数组时尝试从数组中移除对象，C++向量也不例外。因此，在我们评估了所有的碰撞之后，我们在`update`方法的底部添加了一块额外的代码。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use a similar iterator to loop through the `toDestroy` vector. We retrieve
    each body, check if it has a sprite attached to it (in `userData`), and call the
    `spriteDestroy` method if it does. Then we instruct the world to destroy the body
    of this object. The `spriteDestroy` method is used for all of the sprite destructions
    in our game. An abbreviated form of it looks as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的迭代器来遍历`toDestroy`向量。我们检索每个物体，检查它是否附有精灵（在`userData`中），如果有的话，就调用`spriteDestroy`方法。然后我们指示世界销毁这个物体的身体。`spriteDestroy`方法用于我们游戏中所有的精灵销毁。它的简略形式如下：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the sprite tags here so that we can have custom destruction behavior
    for each type of object. We could have embedded this in the `update` method, but
    it will get pretty long by the end of this game. Separating the destruction code
    also keeps our Objective-C and C++ a little better separated in the code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用精灵标签，这样我们就可以为每种类型的对象提供自定义的销毁行为。我们本可以将这些嵌入到`update`方法中，但到游戏结束时，它将会变得相当长。将销毁代码分离出来也使得我们的Objective-C和C++代码在代码中保持更好的分离。
- en: Paddling around
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挡板运动
- en: 'Now we have our basic game world, we have walls, and a ball that will drop
    off of the bottom of the screen. We need to turn our attention to the only piece
    of the game the user directly controls: the paddle. Let''s look at how we build
    it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的游戏世界，有墙壁，还有一个会从屏幕底部掉落的球。我们需要将注意力转向用户直接控制的唯一游戏部件：挡板。让我们看看它是如何构建的：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Much of this is the same as when we built the ball. We create the `PhysicsSprite`
    first. Then we define the body at the same position, and attach the sprite to
    the body. You will notice that instead of building the fixture here, we call another
    method to define the fixture. This is because we will be using different fixtures
    for the paddle later, when we explore power-ups. We will get to the details of
    the fixture building in just a moment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与构建球时的许多步骤相同。我们首先创建`PhysicsSprite`。然后我们在相同的位置定义身体，并将精灵附加到身体上。您会注意到，我们在这里不是构建夹具，而是调用另一个方法来定义夹具。这是因为当我们探索增强功能时，我们将为桨使用不同的夹具。我们将在稍后详细说明夹具构建。
- en: One new item that we need to build is a prismatic joint for the paddle, which
    connects the `paddleBody` to the `wallBody`. A prismatic joint allows a body to
    travel along a specific axis only. In our case, we define the `worldAxis` as constraining
    the movement along the x axis only, based on the coordinates we defined. One important
    flag we set for the paddle is `collideConnected` to `true`. This allows collisions
    to be detected between bodies connected by the joint. Since we are creating a
    joint between the paddle and the `wallBody`, we need to set this to allow the
    paddle to collide with the side walls. Without this established, the paddle will
    pass through the sides of the playfield and leave the game. Just as with other
    Box2D elements, we create the joint by passing the `CreateJoint` request to the
    world itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的一个新项目是为桨创建一个棱柱关节，它将`paddleBody`与`wallBody`连接起来。棱柱关节允许一个物体只沿着特定轴移动。在我们的例子中，我们定义`worldAxis`为仅约束沿x轴的运动，基于我们定义的坐标。我们为桨设置的一个重要标志是`collideConnected`设置为`true`。这允许检测通过关节连接的物体之间的碰撞。由于我们正在创建桨和`wallBody`之间的关节，我们需要将其设置为允许桨与侧墙发生碰撞。如果没有这个设置，桨将穿过游戏场的侧面并离开游戏。就像其他Box2D元素一样，我们通过将`CreateJoint`请求传递给世界本身来创建关节。
- en: Paddle fixture
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桨夹具
- en: 'We will be implementing some power-ups later that will allow the paddle size
    to be changed. Because of this, we need the ability to change the paddle size.
    As we discussed earlier, the fixture handles the geometry and the physical properties
    of the body, so we have moved this fixture definition to its own method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后实现一些可以改变桨大小的增强功能。因此，我们需要能够改变桨的大小。正如我们之前讨论的，夹具处理身体的几何形状和物理属性，因此我们将这个夹具定义移动到它自己的方法中：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To build a normal paddle, we first define the `b2PolygonShape` that matches
    the paddle. Because we have created a paddle that is not a simple shape (circle
    or square), we have to define all of the points that define the boundary of the
    shape. It is important to remember that these coordinates are in points, not pixels.
    If you are only using non-Retina displays, this makes no difference. Since our
    project includes both Retina and non-Retina assets, these coordinates must be
    defined based on the non-Retina sprite. There are many tools to help you define
    what these points should be, but you can also use most graphics editing programs
    to identify the points that define the "corners" of the shape. It is important
    to define the points of the polygon in a counter-clockwise order. If you define
    them in the other direction, the program will crash, usually when Box2D is calculating
    the area of the shape.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个普通的桨，我们首先定义与桨匹配的`b2PolygonShape`。由于我们创建的桨不是一个简单的形状（圆形或正方形），我们必须定义定义形状边界的所有点。重要的是要记住，这些坐标是以点为单位，而不是像素。如果您只使用非Retina显示屏，这没有区别。由于我们的项目包括Retina和非Retina资源，这些坐标必须基于非Retina精灵来定义。有许多工具可以帮助您定义这些点应该是什么，但您也可以使用大多数图形编辑程序来识别定义形状“角落”的点。定义多边形的点时，必须按逆时针顺序。如果您以其他方向定义它们，程序将崩溃，通常是在Box2D计算形状面积时。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Box2D defaults to a maximum of eight vertices to define a shape. If you need
    more than that, you can easily change the setting in the `b2Settings.h` file.
    This maximum is defined as `b2_maxPolygonVertices`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D默认最多使用八个顶点来定义一个形状。如果您需要更多，您可以在`b2Settings.h`文件中轻松更改设置。这个最大值定义为`b2_maxPolygonVertices`。
- en: After the shape has been defined, we call out another method to actually build
    the fixture.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 形状定义完成后，我们调用另一种方法来实际构建夹具。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start this method with a check to make sure we don't already have a `paddleFixture`
    object defined. If we do, we destroy it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个方法开始，检查是否已经定义了一个 `paddleFixture` 对象。如果有，我们将其销毁。
- en: Most of the fixture definition follows the same pattern we used in the ball
    definition. We set the `density`, `friction`, and `restitution`, and we attach
    the shape to the fixture and the fixture to the body. You will notice that we
    set the `shape` to the variable shape that we passed to this method. The final
    line of this method is redundant and unnecessary the first time we build the paddle.
    We call `setDisplayFrame` to change the sprite frame attached to the paddle. This
    will come in handy when we add the power-ups later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数固定定义遵循我们在球定义中使用的相同模式。我们设置了 `density`、`friction` 和 `restitution`，并将形状附加到固定件和固定件附加到身体上。你会注意到我们将
    `shape` 设置为我们传递给此方法的变量形状。此方法的最后一行是冗余且不必要的，第一次构建桨叶时。我们调用 `setDisplayFrame` 来更改附加到桨叶的精灵帧。这在我们添加增强功能时将很有用。
- en: Touching the paddle
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸桨叶
- en: 'To interact with the paddle, we need to create a new type of joint: the mouse
    joint. The mouse joint tries to make the body move toward the target set for it.
    In our case, the target will be our touched point. This will allow us to drag
    the paddle around while it is still a part of the Box2D world.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要与桨叶交互，我们需要创建一种新的关节类型：鼠标关节。鼠标关节试图使身体移动到为其设置的目标。在我们的例子中，目标将是我们的触摸点。这将允许我们在它仍然是
    Box2D 世界的一部分时拖动桨叶。
- en: 'One approach for using the mouse joint is to detect touches on the paddle itself,
    and allow the player to move it directly. We will take an alternate approach,
    and detect any touches in the bottom portion of the screen as the target for the
    mouse joint. Naturally, we will begin with the `ccTouchesBegan` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标关节的一种方法是在桨叶本身检测触摸，并允许玩家直接移动它。我们将采取另一种方法，并将屏幕底部任何触摸作为鼠标关节的目标。自然地，我们将从 `ccTouchesBegan`
    方法开始：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin by checking if there is already a `mouseJoint` defined. If there is,
    that means there is already one touch "in play", and we don't want to interfere
    with the current touch.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否已经定义了一个 `mouseJoint`。如果有，这意味着已经有了一个触摸“正在进行”，我们不希望干扰当前的触摸。
- en: The next section uses fairly standard conversions from the touch to the OpenGL
    coordinates. However, here we also define the `locationWorld b2Vec2`, which is
    the Box2D version of the location variable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分使用了从触摸到 OpenGL 坐标的相当标准的转换。然而，在这里我们还定义了 `locationWorld b2Vec2`，这是位置变量的 Box2D
    版本。
- en: We then check for a touch in the bottom portion of the screen. If the touch
    is there, we create a new mouse joint, and attach it to the `wallBody` and the
    `paddleBody`. The attachment to the `wallBody` is basically an anchor, since a
    joint must connect two bodies. Only the `paddleBody` will be moved by this joint.
    We set the `maxForce` variable to 1,000 times the mass of the paddle, so the player's
    movements completely override any other forces that may be trying to influence
    the paddle. We create the joint, and then make sure the paddle is awake (in case
    it was sitting idle long enough to sleep).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查屏幕底部的触摸。如果那里有触摸，我们创建一个新的鼠标关节，并将其连接到 `wallBody` 和 `paddleBody`。连接到 `wallBody`
    实际上是一个锚点，因为关节必须连接两个身体。只有 `paddleBody` 将会被这个关节移动。我们将 `maxForce` 变量设置为桨叶质量的 1,000
    倍，这样玩家的移动将完全覆盖任何可能试图影响桨叶的其他力。我们创建了关节，并确保桨叶是激活的（以防它已经闲置足够长的时间而进入睡眠状态）。
- en: 'Now that we have the mouse joint instantiated, we need to make the mouse joint
    track the user''s movements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了鼠标关节，我们需要使鼠标关节跟踪用户的移动：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ccTouchesMoved` method is almost trivial. We determine the current location
    of the touch, and we set that as the new target for the mouse joint. That's all
    it takes to move the paddle around. There is one loose end, however. The final
    step of the touch handling is to handle the cancel and end events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccTouchesMoved` 方法几乎是微不足道的。我们确定触摸的当前位置，并将其设置为鼠标关节的新目标。这就是移动桨叶的全部过程。然而，还有一个悬而未决的问题。触摸处理过程的最后一步是处理取消和结束事件。'
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, both of these methods are identical. Because the touch handler
    is only concerned with moving around the paddle with the mouse joint, all we need
    to do to end (or cancel) the touch is to destroy the mouse joint. Now that we
    have completed the touch handler, the game now has enough components to move the
    paddle around and bounce the ball. Box2D will handle all of the collisions between
    the ball and paddle, without our code needing to do any collision handling of
    our own.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两种方法都是相同的。因为触摸处理程序只关心使用鼠标关节移动挡板，所以我们结束（或取消）触摸所需要做的就是销毁鼠标关节。现在我们已经完成了触摸处理程序，游戏现在有足够的组件来移动挡板并反弹球。Box2D将处理球和挡板之间的所有碰撞，而无需我们的代码进行任何自己的碰撞处理。
- en: Storing player data
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储玩家数据
- en: One of the challenges with a multi-level game is keeping the player's information
    between levels. There are two common approaches. One is to pass the player data
    (usually as a player object) from one scene to the next via the scene `init` methods.
    (We used this approach in the snake game in [Chapter 4](ch04.html "Chapter 4. Give
    a Snake a Snack…"), *Give a Snake a Snack*.) The other is to use a Singleton.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在多级游戏中，一个挑战是保持玩家信息在各个级别之间的连续性。有两种常见的方法。一种是将玩家数据（通常是一个玩家对象）通过场景的`init`方法从一个场景传递到下一个场景。（我们在[第4章](ch04.html
    "第4章. 给蛇一份小吃…")中的蛇游戏中使用了这种方法，*给蛇一份小吃*。）另一种方法是使用单例模式。
- en: A Singleton is a design pattern for a class of which there is only one instance
    allowed. Cocos2D is built on a foundation of Singletons like `CCDirector`, `CCSpriteFrameCache`,
    and so on. Pretty much anything where you reference a "sharedSomething" (for example,
    `[CCDirector sharedManager]`) is a Singleton. By design, there is a maximum of
    one "living" version of a Singleton class at any given time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一种设计模式，它允许一个类只有一个实例。Cocos2D建立在`CCDirector`、`CCSpriteFrameCache`等单例的基础上。几乎任何引用“sharedSomething”（例如，`[CCDirector
    sharedManager]`）的地方都是一个单例。按照设计，在任何给定时间，单例类只有一个“存活”的版本。
- en: 'We will be using a Singleton class to handle our game variables `currentLevel`,
    `currentLives`, and `currentScore`. Let''s take a look:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用单例类来处理我们的游戏变量`currentLevel`、`currentLives`和`currentScore`。让我们看看：
- en: '**Filename:** `BRGameHandler.mm`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRGameHandler.mm`'
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These are the general Singleton methods we will use. There are several methods
    that are not directly called in our game, but this is general enough to be used
    in many projects (other than the `@synthesize` statements). The `sharedManager`
    class method will check if there is a `gameHandler` already instantiated. If there
    is, it returns the existing instance. If not, it creates one. We are using **Grand
    Central Dispatch** (**GCD**) in the `sharedManager` method. It is beyond our scope
    here to go into detail on GCD, but this method is extremely lightweight and fast,
    compared to more traditional designs. (If you want to know more, check your favorite
    search engine for "Grand Central Dispatch Singleton" for further reading.) The
    first time you call `[BRGameHandler sharedManager]`, it will be created. This
    Singleton class will remain available for the life of the game, so you can rely
    on it to hold any variables you need to persist through your game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将使用的一般单例方法。有几个方法在我们的游戏中没有直接调用，但它们足够通用，可以在许多项目中使用（除了`@synthesize`语句）。`sharedManager`类方法将检查是否已经实例化了`gameHandler`。如果有，它将返回现有实例。如果没有，它将创建一个新实例。我们在`sharedManager`方法中使用**Grand
    Central Dispatch**（**GCD**）。在这里详细讲解GCD超出了我们的范围，但这种方法与更传统的设计相比，非常轻量级且快速。（如果你想了解更多，可以在你喜欢的搜索引擎中搜索“Grand
    Central Dispatch Singleton”以获取进一步阅读。）第一次调用`[BRGameHandler sharedManager]`时，它将被创建。这个单例类将在游戏的生命周期内保持可用，因此你可以依赖它来保存任何需要贯穿整个游戏的变量。
- en: 'Next we look at the game-specific methods we include in our Singleton:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看我们在单例中包含的游戏特定方法：
- en: '**Filename:** `BRGameHandler.mm`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRGameHandler.mm`'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a couple of helper methods here to make our main code simpler. The first
    time we instantiate the class, it will call `resetGame` to set the `currentLevel`,
    `currentLives` , and `currentScore` variables to their starting values. As the
    Singleton instance will not be released, we put the variable initializations in
    the `resetGame` method. In this way, a single call to that method will fully reset
    the Singleton to a "fresh" state for a new game. The `addToScore` and `loseLife`
    methods are for convenience, so we don't have to "bother" our main playfield class
    with calculating what the new values should be when we score points or lose a
    life.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有几个辅助方法，使我们的主要代码更简单。第一次实例化类时，它将调用`resetGame`来将`currentLevel`、`currentLives`和`currentScore`变量设置为它们的起始值。由于单例实例不会被释放，我们将变量初始化放在`resetGame`方法中。这样，对该方法的单个调用将完全将单例重置为“新鲜”状态，以开始新游戏。`addToScore`和`loseLife`方法是为了方便，这样我们就不必“麻烦”我们的主游戏场类去计算得分或失去生命时新值应该是什么。
- en: Displaying player data
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家数据
- en: 'We now have a place to store the player data, but we will also need a way to
    display this for the user. For this game, we are following "best practices" by
    separating the **Heads-Up Display** (**HUD**) layer from the main playfield layer.
    The HUD is a standard layer, with a background box, a place for the score, and
    a place for lives remaining. One item to be pointed out is that in the HUD interface,
    we have defined the following variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个地方可以存储玩家数据，但我们也需要一种方式来向用户显示这些数据。对于这款游戏，我们遵循“最佳实践”，将**抬头显示**（**HUD**）层与主游戏场层分开。HUD是一个标准层，包含一个背景框、一个用于显示分数的地方和一个显示剩余生命的地方。需要指出的一点是，在HUD界面中，我们定义了以下变量：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And in the `init` method of the HUD implementation, we have the paired line:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在HUD实现的`init`方法中，我们有配对的行：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From this point on in this class, any time we want to reference our `BRGameHandler`
    Singleton, we only have to use the variable `gh`. (Note: we also have this same
    variable defined in the `BRPlayfieldLayer` class.)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个类开始，任何时候我们想要引用我们的`BRGameHandler`单例，我们只需使用变量`gh`。（注意：我们也在`BRPlayfieldLayer`类中定义了这个相同的变量。）
- en: '**Filename:** `BRHUD.mm`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRHUD.mm`'
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The HUD acts as a "bridge" between the playfield layer and the game handler
    for scoring purposes. In the `addToScore` method, we first call out to the game
    handler to add points to the current score, and then the HUD calls the `setString`
    method on the `scoreDisplay` label to update the displayed score. By using a method
    like this, the playfield layer only has to pass one message to the HUD, and it
    takes care of the rest.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: HUD（抬头显示）在计分目的上充当了游戏场层和游戏处理器的“桥梁”。在`addToScore`方法中，我们首先调用游戏处理器来为当前分数添加分数，然后HUD调用`scoreDisplay`标签上的`setString`方法来更新显示的分数。通过使用这种方法，游戏场层只需向HUD传递一条消息，而它负责处理其余部分。
- en: We want to get a little fancier with the display of lives remaining, and use
    `CCSprite` images of a ball for each life remaining, and we want a nice animation
    in the HUD when the player loses a life.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使剩余生命的显示更加精致，并使用代表每个剩余生命的球体`CCSprite`图像，我们希望在玩家失去生命时在HUD中有一个漂亮的动画。
- en: '**Filename:** `BRHUD.mm`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRHUD.mm`'
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because we don't want to create a variable for each of the player's "life sprites",
    we instead opt to use an array to keep those sprites, called `livesArray`. When
    we call the `createLifeImages` method, it will generate the correct number of
    sprites, and space them out nicely in the display. It also stores them in the
    array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望为玩家的每个“生命精灵”创建一个变量，我们选择使用一个数组来保存这些精灵，称为`livesArray`。当我们调用`createLifeImages`方法时，它将生成正确数量的精灵，并在显示中均匀分布。它还将它们存储在数组中。
- en: '**Filename:** `BRHUD.mm`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRHUD.mm`'
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When the player loses a life, we handle it in the same way we handled the score
    updates. We send the message to the game handler (which will subtract one from
    the `currentLives` variable). Our next step is to add a reference to the last
    sprite in the array with the `lifeToRemove` variable. After a little animation,
    we use `CCCallFuncND` to trigger the `destroyLife:` method, passing the `CCSprite`
    instance of the "life sprite" we want to remove from the game. That method simply
    removes it and frees up that memory. At the end of the `loseLife` method, we remove
    the sprite from the `livesArray`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家失去生命时，我们以处理分数更新的相同方式处理它。我们向游戏处理器发送消息（这将从`currentLives`变量中减去一个）。我们的下一步是添加对数组中最后一个精灵的引用到`lifeToRemove`变量。经过一小段动画后，我们使用`CCCallFuncND`触发`destroyLife:`方法，传递我们想要从游戏中移除的“生命精灵”的`CCSprite`实例。该方法只是将其移除并释放该内存。在`loseLife`方法的末尾，我们从`livesArray`中移除精灵。
- en: By encapsulating these updates in the HUD, we don't have to clutter up our playfield
    with methods that don't have anything to do with the core gameplay. If we were
    to radically alter the appearance and general behavior of the HUD (assuming that
    `addToScore:` and `loseLife` were still present), the gameplay layer code would
    not change at all. This design also means that we could use a completely different
    playfield class with this same HUD. That is the flexibility that we strive for
    in our coding.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些更新封装在HUD中，我们不必在我们的游戏场中充斥着与核心游戏无关的方法。如果我们要对HUD的外观和一般行为进行根本性的改变（假设`addToScore:`和`loseLife`仍然存在），游戏层代码将完全不会改变。这种设计还意味着我们可以使用与这个相同的HUD的完全不同的游戏场类。这就是我们在编码中追求的灵活性。
- en: Building bricks
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建筑砖块
- en: 'We are missing one vital piece from our game: bricks to break. We want our
    game to be flexible enough that we will be able to define new levels without diving
    too deep into our source code, so we will be storing our levels as a **property
    list** (**plist**).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏缺少一个至关重要的部分：可破坏的砖块。我们希望我们的游戏足够灵活，以便我们可以在不深入研究源代码的情况下定义新关卡，因此我们将把我们的关卡存储为一个**属性列表**（**plist**）。
- en: For our game, we want to have unlimited play, so we will define a set number
    of brick patterns, and the game will loop through these in order. When you reach
    the end, it will go back to the first pattern and repeat the cycle.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们希望有无限的游戏时间，所以我们将定义一组砖块图案，游戏将按顺序循环这些图案。当你到达终点时，它将回到第一个图案并重复循环。
- en: We define the patterns in the plist as an array with the name in the format
    `P#`, so the patterns would be named `P1`, `P2`, `P3`, and so on. Inside each
    array are the strings representing each row of bricks. The rows begin at the bottom,
    so **Item 0** is the lowest row of bricks, and **Item 1** would be above it, and
    so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在plist中定义的图案是一个名为`P#`格式的数组，因此图案将被命名为`P1`、`P2`、`P3`等等。每个数组内部包含代表每行砖块的字符串。行从底部开始，所以**项目0**是最低的砖行，**项目1**在上面，以此类推。
- en: If we were to build a level editor for our game, we would be more likely to
    build a more robust plist structure. Because we are hand coding the level design,
    the easiest way to organize the data is in strings. For each row of each pattern,
    we define a string of 13 digits, each digit representing a brick. (Our screen
    size will only hold 13 bricks wide.) We will represent the bricks based on the
    numbering in their file names (`brick1.png`, `brick2.png`, and so on) as well
    as a zero, representing no brick in that position.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为我们的游戏构建一个关卡编辑器，我们更有可能构建一个更健壮的plist结构。因为我们手动编写关卡设计，组织数据的最简单方法是使用字符串。对于每个图案的每一行，我们定义一个13位的字符串，每个数字代表一个砖块。（我们的屏幕大小只能容纳13个砖块宽。）我们将根据文件名中的编号（`brick1.png`、`brick2.png`等等）以及一个零来表示该位置没有砖块。
- en: 'Let''s take a look at one pattern from the plist, and how it will be displayed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看plist中的一个图案，以及它将如何显示：
- en: '![Building bricks](img/9007_05_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![建筑砖块](img/9007_05_02.jpg)'
- en: 'In this example showing pattern **P2**, **Item 0** is the bottom-most row of
    the final grid of bricks, shown to the right. You can see how it translates: brick
    number 3 is green, 4 is grey, 5 is orange, and so on. As long as we keep in mind
    the "bottom first" nature of the pattern, it becomes very easy to "see" the patterns
    in the numbers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个显示图案**P2**的例子中，**项目0**是最终网格中砖块的最低行，显示在右侧。你可以看到它是如何转换的：砖块编号3是绿色，4是灰色，5是橙色，以此类推。只要我们记住图案的“从底部开始”的特性，就很容易在数字中“看到”图案。
- en: Loading a plist
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载plist
- en: So now we have a plist of pattern data, how do we load it? We have chosen to
    use an `NSDictionary` as the data structure that we want to hold the plist data
    once loaded. We add a plist loader into our `BRGameHandler` because it is a more
    general method, so we have it centralized if we decide we need to load a plist
    for some other part of the game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个模式数据的plist，我们如何加载它？我们选择使用`NSDictionary`作为我们想要在加载后存储plist数据的数据结构。我们在`BRGameHandler`中添加了一个plist加载器，因为它是一个更通用的方法，所以如果我们决定需要为游戏的某个其他部分加载plist，我们可以将其集中管理。
- en: '**Filename:** `BRGameHandler.mm`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRGameHandler.mm`'
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code is written with a couple of assumptions. One is that the passed filename
    will be without an extension (that is, we pass "patterns" if the filename is `patterns.plist`).
    The other assumption is that the plist file is in the main app bundle. You will
    notice that this method returns a value of type `id`. Since it was built as a
    general-purpose loader, we need one additional helper method to easily get the
    `NSDictionary` we desire for our data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基于几个假设。一个是传入的文件名将不带扩展名（也就是说，如果文件名是`patterns.plist`，我们传递的是"patterns"）。另一个假设是plist文件位于主应用程序包中。你会注意到这个方法返回一个`id`类型的值。由于它被构建为一个通用加载器，我们需要一个额外的辅助方法来轻松获取我们所需的数据`NSDictionary`。
- en: '**Filename:** `BRGameHandler.mm`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRGameHandler.mm`'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This simply passes the filename to the `readPlist` method, and casts the returned
    value as an `NSDictionary`. (We can also use the same `readPlist` method to return
    an `NSArray`, using the same casting approach.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将文件名传递给`readPlist`方法，并将返回值强制转换为`NSDictionary`。（我们也可以使用相同的`readPlist`方法返回`NSArray`，使用相同的强制转换方法。）
- en: Picking a pattern
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个模式
- en: 'Now that we know how to load the pattern data, let''s take a look at the code
    from the `init` method of the `BRPlayfieldLayer` where we load the patterns, and
    decide which pattern to use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何加载模式数据，让我们看看`BRPlayfieldLayer`的`init`方法中的代码，其中我们加载模式，并决定使用哪个模式：
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `init` method)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`（在`init`方法内部）'
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We load all of the pattern definitions into `patternDefs` using the `dictionaryFromDictionary`
    method. We then identify how many total patterns we have defined in the file.
    If we add new patterns to the plist, this is the only element of the actual code
    that needs to be modified.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dictionaryFromDictionary`方法将所有模式定义加载到`patternDefs`中。然后我们确定在文件中定义了多少个总模式。如果我们向plist添加新模式，这是实际代码中唯一需要修改的部分。
- en: The `newPattern` calculation uses a modulo operation to give us an endless repeating
    sequence of patterns. (We subtract one from the current level number because we
    start with Pattern P0 for Level 1.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`newPattern`的计算使用模运算来给我们一个无限重复的模式序列。（我们从当前等级数减去一，因为我们从Pattern P0开始Level 1。）'
- en: 'Now we move to the method that interprets the pattern data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向解释模式数据的方法：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we hold the array for the currently chosen pattern in the variable `tmpPattern`.
    Since each pattern is an array of strings, we then iterate through the `tmpPattern`
    array, and for each string in the array, we call the method to build the next
    row of bricks with this data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将当前选择的模式数组存储在变量`tmpPattern`中。由于每个模式都是一个字符串数组，因此我们遍历`tmpPattern`数组，并对数组中的每个字符串调用方法，使用这些数据构建下一行砖块：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because we are building an entire row of bricks, we approach this build method
    a little differently:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一整行砖块，我们对构建方法采取了一些不同的方法：
- en: We are passed the row number and the string representing this row of bricks
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传递行号和表示这一行砖块的字符串
- en: We iterate through all of the characters of the string, one at a time
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们逐个遍历字符串中的所有字符
- en: We call NSMakeRange to substring only one character at a time, and convert that
    character to an integer value
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`NSMakeRange`来只获取字符串中的一个子串，并将该字符转换为整数值
- en: If the value is zero, there is no brick in that position, and no further action
    is taken for this position
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值为零，该位置没有砖块，并且对该位置不采取任何进一步的操作
- en: If we need a brick here, we then proceed to build them in the same manner as
    the other objects. We build a sprite, body, shape, and fixture, and attach them
    together. When we define the shape of the fixture we use the `SetAsBox` function,
    so we can simply provide half the width of the sprite and half the height of the
    sprite, and Box2D builds the shape.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在这里放置砖块，我们就以与其他对象相同的方式构建它们。我们构建一个精灵、身体、形状和固定装置，并将它们连接在一起。当我们定义固定装置的形状时，我们使用`SetAsBox`函数，因此我们可以简单地提供精灵宽度的一半和高度的一半，Box2D就会构建形状。
- en: Breaking bricks, for real
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真正的打破砖块
- en: 'Now we have all the core elements of the game defined, we need to add collision
    handling for the ball hitting the bricks. If we were to stop here, the ball would
    hit the bricks, and the bricks would go flying off from the force of the impact.
    We really want the brick to be destroyed, so we will revisit the `update` method
    we described earlier in the *Losing Your Ball* section. Immediately after the
    `if…else` statement in the `update` method, we add a couple of clauses:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了游戏的所有核心元素，我们需要为球击中砖块添加碰撞处理。如果我们在这里停下来，球会击中砖块，砖块会因冲击力而飞出去。我们真正想要的是销毁砖块，所以我们将重新审视在*失去你的球*部分中描述的`update`方法。在`update`方法中的`if…else`语句之后，我们添加了几个子句：
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `init` method)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`（在`init`方法中）'
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The outer clause makes sure we have sprites for both bodies involved in the
    contact. We then check the `tag` value for both sprites. If one is the brick and
    the other is the ball, then we add the brick to the `toDestroy` vector. As you
    recall, this is exactly how we handled the ball versus `bottomGutter` collisions
    earlier. The only primary difference is that we are comparing two sprites this
    time, and we are destroying the brick, not the ball.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 外部子句确保我们有两个精灵分别对应于接触中的两个身体。然后我们检查两个精灵的`tag`值。如果一个精灵是砖块而另一个是球，那么我们将砖块添加到`toDestroy`向量中。如您所回忆的，这正是我们之前处理球与`bottomGutter`碰撞的方式。唯一的区别是我们这次比较的是两个精灵，并且我们销毁的是砖块，而不是球。
- en: 'Because we are using one common path of destruction for objects, we don''t
    have to add anything else to the `update` method to make this process work. We
    only need to add a new case statement in the `spriteDestroy` method. Let''s look
    at that method again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了一个通用的破坏路径来处理对象，所以我们不需要在`update`方法中添加任何其他内容来使这个过程工作。我们只需要在`spriteDestroy`方法中添加一个新的情况语句。让我们再次看看这个方法：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you may remember, we actually destroy the Box2D body itself at the end of
    the `update` method, so we clean up the sprites here and take care of any additional
    housekeeping items, such as incrementing the score, playing sound effects, and
    so forth.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，我们在`update`方法结束时实际上销毁了Box2D身体本身，因此我们在这里清理精灵并处理任何其他维护事项，例如增加分数、播放音效等等。
- en: 'We have included one method in the `case kBrick` section that leads us to our
    next (and final) topic for this game: implementing power-ups.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`case kBrick`部分包含了一个方法，它引导我们进入这个游戏的下一个（也是最后一个）主题：实现加分道具。
- en: Power-ups, good and bad
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加分道具，好与坏
- en: 'The idea of power-ups is core to the modern brick breaking experience. For
    our game, we will be implementing three types of power-ups: paddle expanding,
    paddle contracting, and multiball. As we just saw, when a brick is destroyed another
    method gets called to handle the power-ups.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 加分道具的想法是现代砖块游戏体验的核心。对于我们的游戏，我们将实现三种类型的加分道具：挡板扩大、挡板缩小和多球。正如我们刚才看到的，当一个砖块被销毁时，会调用另一个方法来处理加分道具。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `BRPlayfieldLayer.mm`'
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this method we randomize a number. If it is below 25 percent, we call another
    method to actually build a power-up. It is important to point out that in the
    `spriteDestroy` method, we must call this method before we `removeFromParentAndCleanup`
    because we will need to use the position of the brick that is being destroyed
    here. This allows the power-up to drop from "inside" the brick that was just destroyed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们随机生成一个数字。如果这个数字低于25%，我们就调用另一个方法来实际构建加分道具。重要的是要指出，在`spriteDestroy`方法中，我们必须在`removeFromParentAndCleanup`之前调用这个方法，因为我们需要使用这里被销毁的砖块的位置。这允许加分道具从“内部”刚刚被销毁的砖块中掉落。
- en: 'As we follow this code path, we now reach the point where we have decided to
    generate a power-up. This is another Box2D-enabled body, so let''s review the
    build method for the power-ups:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们沿着这个代码路径前进，我们现在到达了决定生成加分道具的点。这是一个Box2D启用的身体，所以让我们回顾一下加分道具的构建方法：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we call this method, we only have gotten as far as knowing we need to generate
    a power-up, but we have not yet identified which of the three available power-ups
    we will generate. To that end, we use `arc4random()` to randomly choose which
    of the power-ups we want to use. The only difference in this build method is different
    values for the sprite file name and for the sprite's `tag` property.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个方法时，我们只知道我们需要生成一个增强效果，但我们还没有确定将生成三种可用增强效果中的哪一种。为此，我们使用 `arc4random()`
    随机选择我们想要使用的增强效果。在这个构建方法中，唯一的区别是精灵文件名和精灵的 `tag` 属性的不同值。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For mathematical purists, none of the randomizing approaches used in this book
    are "true randomness". There will be some small imbalance in the frequency of
    numbers generated. However, this is just a game, so less than perfect randomness
    is perfectly acceptable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学纯粹主义者来说，本书中使用的所有随机化方法都不是“真正的随机性”。生成的数字频率将存在一些小的不平衡。然而，这只是一个游戏，所以不太完美的随机性是完全可以接受的。
- en: We continue to build the body, shape, and fixture much the same as we did for
    the paddle body, including defining the polygon shape by its eight points. We
    could have also gotten by with using a box shape instead, but we wanted to get
    "pixel-perfect" with the rounded corners on the power-up blocks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续构建身体、形状和固定件，与构建球拍身体的方式非常相似，包括通过其八个点定义多边形形状。我们也可以使用矩形形状来完成任务，但我们希望增强效果块上的圆角达到“像素级”精确。
- en: The fixture is a little different, however. We don't set the `density`, `friction`,
    or `restitution` for this fixture. Instead, we use a new property, `isSensor`.
    A sensor is a fixture that can take part in collisions, but doesn't actually cause
    things to impact it. A sensor can pass through another body without any hit-and-bounce-off
    actions. However, we can detect when a sensor and another fixture come in contact
    with each other. In our case, the power-ups will be picked up by the paddle, but
    they shouldn't bounce around and/or get hit by the ball or paddle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，固定件略有不同。我们不会为这个固定件设置 `密度`、`摩擦` 或 `恢复`。相反，我们使用一个新的属性，`isSensor`。传感器是一种可以参与碰撞但不会实际引起碰撞的固定件。传感器可以穿过另一个身体而不发生碰撞和反弹动作。然而，我们可以检测传感器和另一个固定件何时接触。在我们的案例中，增强效果将被球拍拾起，但它们不应该四处弹跳或被球或球拍击中。
- en: We finish off the building of the power-up by applying a downward linear impulse
    on the body, so it will drop straight down. This simulates the effect of gravity,
    even though we have zero gravity for our world.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在身体上施加向下的线性冲量来完成对增强效果的构建，这样它就会直接向下掉落。这模拟了重力的效果，尽管在我们的世界中重力为零。
- en: Picking up power-ups
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拾取增强效果
- en: Now we need to handle the collisions between the power-ups and the paddle. We
    have most of the pieces we need to make this happen already. Back in the `update`
    method, we add a few more checks directly after the brick versus ball checks.
    We need three more pairs of checks between the paddle and each type of power-up.
    (We only include the first pair for example – the other two are identical, just
    change the `tag` checked for the power-ups.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理增强效果与球拍之间的碰撞。我们已经拥有了实现这一功能的大部分组件。回到 `update` 方法，我们在砖块与球碰撞检查之后直接添加了一些额外的检查。我们需要在球拍和每种类型的增强效果之间进行三对额外的检查。（例如，我们只包括第一对——其他两对是相同的，只需更改增强效果的
    `tag` 检查即可。）
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm` (在 `update` 方法中)'
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is almost a direct copy-and-paste from the prior collision checking. Once
    again, when a power-up is "picked up", we simply add it to the `toDestroy` vector.
    As you have probably guessed, we handle the rest of the power-up triggering in
    the `spriteDestroy` method. In that method, we add three more case statements.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是从之前的碰撞检测中直接复制粘贴过来的。再次强调，当一个增强效果被“拾起”时，我们只是简单地将其添加到 `toDestroy` 向量中。正如你可能猜到的，我们将在
    `spriteDestroy` 方法中处理增强效果的其余触发。在那个方法中，我们添加了三个额外的案例语句。
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `spriteDestroy` method)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm` (在 `spriteDestroy` 方法中)'
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For the contract and expand power-ups, we remove the sprite and then call to
    build a new fixture. The `paddleTimer` and `isPaddleDeformed` variables will be
    used to control when the paddle goes back to normal size.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于收缩和扩展增强效果，我们移除精灵然后调用构建新的固定件。`paddleTimer` 和 `isPaddleDeformed` 变量将用于控制球拍何时恢复到正常大小。
- en: For the multiball, there is a little more substance to it, so here we simply
    set the flag `shouldStartMultiball` to `YES`, so we can deal with it on the next
    `update` loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多球模式，它有一些实质性的内容，所以我们在这里只是将标志 `shouldStartMultiball` 设置为 `YES`，这样我们就可以在下一个
    `update` 循环中处理它。
- en: Paddle deformation
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桨片变形
- en: 'As you recall when we first build the paddle, we build the fixture itself in
    a separate method, `buildPaddleFixtureNormal`. When the player catches a contract
    or expand power-up, we simply need to destroy the existing fixture and build a
    new one. Let''s look at the expansion:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当你回想起我们最初构建桨片时，我们是在一个单独的方法 `buildPaddleFixtureNormal` 中构建固定装置本身的。当玩家捕获收缩或扩展升级时，我们只需要销毁现有的固定装置并构建一个新的。让我们看看扩展的情况：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here we see why we divided the paddle fixture building into two methods. We
    can leverage all of the setup done by the `buildPaddleFixtureWithShape: andSpriteFrameName:`
    method we built earlier. The major differences are that we set a different `spriteFrameName`,
    and we define the `verts[]` with the coordinates that match the `paddle_wide.png`
    sprite''s geometry.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们可以看到为什么我们将桨片固定装置的构建分为两个方法。我们可以利用我们之前构建的 `buildPaddleFixtureWithShape:
    andSpriteFrameName:` 方法所做的所有设置。主要的不同之处在于我们设置了一个不同的 `spriteFrameName`，并且我们使用与 `paddle_wide.png`
    精灵的几何形状相匹配的坐标来定义 `verts[]`。'
- en: The method `buildPaddleFixtureShort` follows the same design, using the display
    frame `paddle_short.png` and an alternate set of `verts[]` values. All the other
    code is identical to the "long" method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPaddleFixtureShort` 方法遵循相同的设计，使用显示帧 `paddle_short.png` 和一组不同的 `verts[]`
    值。所有其他代码与“长”方法相同。'
- en: Restoring the paddle
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复桨片
- en: 'Now that we have either expanded or contracted the paddle, how do we go back
    to normal? We have set a 10 second timer value in the `spriteDestroy` method,
    but we need to actually do something with it. At the top of the `update` method,
    we add one simple `if` clause, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经扩展或收缩了桨片，我们如何回到正常状态？我们在 `spriteDestroy` 方法中设置了一个 10 秒的计时器值，但我们需要实际对它做些什么。在
    `update` 方法的顶部，我们添加了一个简单的 `if` 子句，如下所示：
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm` (在 `update` 方法内部)'
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We only enter this clause if the `isPaddleDeformed` variable is set to `YES`.
    We subtract the current delta from the `paddleTimer`, and then check if our time
    has run out. If it has run out, we set `isPaddleDeformed` to `NO`, and call to
    the `buildPaddleFixtureNormal` method to restore our original paddle sprite and
    fixture. Thus, we are back to normal gameplay.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `isPaddleDeformed` 变量设置为 `YES` 时，我们才会进入这个子句。我们从 `paddleTimer` 中减去当前的增量，然后检查我们的时间是否已用完。如果时间已用完，我们将
    `isPaddleDeformed` 设置为 `NO`，并调用 `buildPaddleFixtureNormal` 方法来恢复我们的原始桨片精灵和固定装置。因此，我们回到了正常游戏。
- en: Multiball
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多球模式
- en: Earlier we saw that the collision with the multiball power-up only sets the
    `shouldStartMultiball` variable to `YES`, and does not take any further action.
    Instead, we put the actual trigger at the end of the update method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到与多球升级的碰撞只会将 `shouldStartMultiball` 变量设置为 `YES`，并不会采取任何进一步的操作。相反，我们在更新方法的末尾放置了实际的触发器。
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm` (在 `update` 方法内部)'
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Why not simply call `startMutiball` directly? Because multiball involves the
    creation of new bodies, we want to make sure that the creation of those bodies
    does not happen while we are iterating through the world bodies (which we do at
    the top of the `update` method). To avoid this conflict, it is much safer to set
    triggers as we have done, and take action on them in a portion of the `update`
    method where you can be certain to be "in the clear".
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接调用 `startMutiball`？因为多球模式涉及到新实体的创建，我们希望确保这些实体的创建不会在我们遍历世界实体（我们在 `update`
    方法的顶部这样做）时发生。为了避免这种冲突，我们更安全地设置触发器，就像我们做的那样，并在 `update` 方法的某个部分对其采取行动，在那里你可以确信自己是“安全的”。
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The core of this method iterates over the bodies in the world, and looks for
    a sprite that has the tag `kBall`. It then calls the same `buildBall` method we
    used for the "normal" ball, and creates two new balls at the same position, but
    gives them a different impulse. This set of impulses gives a "popcorn" effect,
    so the two new balls go slightly up and to each side of the original ball.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的核心是遍历世界中的实体，并寻找具有标签 `kBall` 的精灵。然后它调用我们用于“正常”球的相同 `buildBall` 方法，并在相同的位置创建两个新的球，但给它们不同的冲量。这组冲量产生了一种“爆米花”效果，因此两个新球稍微向上和向原球的两侧移动。
- en: We also have some extra code to prevent "bad behavior". The check of the `isBallInPlay`
    variable is to prevent a situation where the player catches a multiball right
    as the only ball in play is destroyed. This can cause a crash, if the sprite and
    body are destroyed at the same time the multiball is trying to interact with it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些额外的代码来防止“不良行为”。检查`isBallInPlay`变量的目的是防止玩家在唯一的球在游戏中被摧毁时恰好接住一个多球的情况。如果精灵和身体在多球试图与之交互的同时被摧毁，这可能会导致崩溃。
- en: We also force a break after one ball has been "multiballed". If we were to allow
    the iterator to continue evaluating other bodies, there is a strong possibility
    (depending on timing) that the two newly created balls would also be "multiballed"
    (that is, creating two new balls for each of them), and then those balls would
    also be "multiballed", and so on. The screen would instantly fill up with dozens
    of balls, and the game is unplayable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强制在有一个球被“多球化”后暂停。如果我们允许迭代器继续评估其他物体，那么在时间上的强烈可能性（取决于时机）是，这两个新创建的球也会被“多球化”（即，为它们中的每一个都创建两个新球），然后这些球也会被“多球化”，以此类推。屏幕会瞬间充满几十个球，游戏将无法进行。
- en: Finally, we also keep track of how many "extra" balls we have in play, with
    the `multiballCounter` variable. This is important, so we don't accidentally trigger
    losing a life when the player still has balls in play.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还会跟踪游戏中有多少“额外”的球，通过`multiballCounter`变量。这很重要，这样我们就不至于在玩家仍有球在游戏中时意外触发生命值减少。
- en: Losing lives with multiball
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多球化时失去生命值
- en: 'Having more than one ball in play at a time makes detecting a lost ball a little
    more involved. Let''s take a look at the final `loseLife` method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同时有多个球在游戏中使得检测丢失的球变得更加复杂。让我们看一下最终的`loseLife`方法：
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `BRPlayfieldLayer.mm`'
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We start by evaluating the `multiballCounter` variable. If there are any multiballs
    in play, we will subtract from that variable first, and the player's lives are
    not affected. If there is no multiball, then we call the HUD to lose a life. As
    you recall, this updates the HUD as well as updating the `currentLives` variable
    in the `BRGameHandler` class. Because of this, we can then evaluate the `[gh currentLives]`
    variable to determine the new number of lives for the player. If there are lives
    left, we create a new ball, and continue on. Otherwise, we begin the Game Over
    sequence.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先评估`multiballCounter`变量。如果有任何多球在游戏中，我们首先从该变量中减去，玩家的生命值不会受到影响。如果没有多球，那么我们就调用HUD来减少一个生命值。如您所回忆的那样，这会更新HUD以及更新`BRGameHandler`类中的`currentLives`变量。正因为如此，我们才能评估`[gh
    currentLives]`变量以确定玩家新的生命值数量。如果还有生命值，我们就会创建一个新的球，并继续游戏。否则，我们开始游戏结束序列。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of (physics enabled) ground here. We have discussed the
    basics of Box2D, and we have built a pretty good brick breaker. We have focused
    on the core mechanics of the physics world, and how to translate between the Box2D
    and cocos2d positioning (using the `PTM_RATIO`). We have learned how to implement
    power-ups that affect the physics of the Box2D world during gameplay, and learned
    how to use a contact listener, and how to decide which collisions cause destruction.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里已经覆盖了很多（启用物理的）内容。我们讨论了Box2D的基础知识，并构建了一个相当不错的砖块破坏器。我们专注于物理世界的核心机制，以及如何将Box2D和cocos2d的位置（使用`PTM_RATIO`）进行转换。我们学习了如何在游戏过程中实现影响Box2D世界物理的加成，以及如何使用接触监听器，以及如何决定哪些碰撞会导致破坏。
- en: In the next chapter, we will explore head-to-head action gaming with two players
    on the same device as well as our first two device game. Let's roll!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨两个玩家在同一设备上的面对面动作游戏，以及我们的第一个设备游戏。让我们开始吧！
