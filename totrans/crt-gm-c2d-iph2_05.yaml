- en: Chapter 5. Brick Breaking Balls with Box2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a lot you can do with cocos2d by itself. However, when you combine
    it with a true physics engine, such as Box2D or Chipmunk, you can do so much more.
    There is a steep learning curve, so this chapter will be both a new project and
    a basic primer on Box2D for the beginner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Box2D basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Box2D objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mouse joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate HUD layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using plists to store level data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing game physics during play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project is…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will discuss the classic brick breaking game. Dating back
    to the early days of Atari, this game is a wonderful way to start exploring physics
    engines, because there aren't too many objects moving at the same time. If you
    are not familiar with this game, it is fairly easy to explain. The player controls
    a paddle at the bottom of the screen that can move side-to-side. The top portion
    of the screen has a number of bricks in fixed positions. There is a small ball
    bouncing around, and the player's job is to break all of the bricks without letting
    the ball past the paddle. Of course, the ball bounces around everywhere, so there
    are actually quite a lot of physics-based calculations needed to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the final game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The project is…](img/9007_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Box2D – a primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can even begin to think about our project, we need to review the basics
    of Box2D. There is a lot of depth to the Box2D engine, and we will only be scratching
    the surface in this book. This section aims to give an overview of the parts of
    the engine that we will need to interact with for this game.
  prefs: []
  type: TYPE_NORMAL
- en: Box2D – what is it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To quote the manual, "Box2D is a 2D rigid body simulation library for games.
    Programmers can use it in their games to make objects move in believable ways
    and make the game world more interactive." That's a pretty straightforward description
    of what Box2D is, except for the "rigid body" term. What does that mean? Rigid
    body means that Box2D is built to simulate hard objects such as balls, walls,
    stone, metal, and so on. Box2D was not built to simulate "soft body" objects such
    as pillows, jelly, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will briefly go through the basic terms of the Box2D environment here, and
    we will deal with everything in more detail when we build the game. The official
    documentation for Box2D is available at: [http://box2d.org/documentation.html](http://box2d.org/documentation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: One important aspect of Box2D to be pointed out here is that it is written in
    C++, so there is a little bit of a language translation aspect when using Box2D
    with a game written primarily in Objective-C. For the most part, the two play
    together nicely, but you will have to gain some familiarity with C++ notation
    to make sense out of the Box2D-specific code. (If the C++ notation looks alien
    to you, we would advise consulting your favorite search engine to learn the basics
    of C++.)
  prefs: []
  type: TYPE_NORMAL
- en: Basic parts of Box2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The widest-reaching component of the Box2D environment is called a **world**.
    All objects created in Box2D will be contained in the world. This is where all
    movement, collisions, and so on take place. The world is also where we set the
    gravity of the environment. Normally, a given simulation will have only one Box2D
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The next object that we have is called a **body**. A body represents a thing
    of some sort in the world. The body controls the position of the object, as well
    as other attributes necessary for the simulation, such as the body type. The body
    type lets you identify whether it is a static (non-moving) or dynamic (movable)
    body. A body does not directly "know" how big it is, how dense it is, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A **shape** describes the geometry of the object. There are several different
    types of shapes supported by Box2D. The most commonly used are the circle shape,
    the polygon shape, and the edge shape. For a complete list of supported shapes,
    please refer to the Box2D documentation.
  prefs: []
  type: TYPE_NORMAL
- en: A **fixture** can be thought of as the "glue" between the shape and the body.
    However, it is more than that. A fixture also defines core attributes of the object,
    such as density, friction, and restitution (aka bounciness).
  prefs: []
  type: TYPE_NORMAL
- en: Box2D supports a wide variety of **joints** to connect bodies together. There
    are distance joints, pulley joints, revolute joints, and so on. The only joints
    we will be concerned with in this game are the mouse joint and the prismatic joint,
    both used in the paddle controls.
  prefs: []
  type: TYPE_NORMAL
- en: As you might imagine, there is also a collision handler. One of the core components
    we use is called a **contact listener**. This is a very complex piece of software,
    and the one that makes us dive into C++ the most. We will only scratch the surface
    with a basic collision handler in this game.
  prefs: []
  type: TYPE_NORMAL
- en: A very important value is the `PTM_RATIO`. This is the Points-To-Meters Ratio.
    Internally, Box2D represents everything as meters. The default value for this
    ratio is 32, which represents 32 points as 1 meter in the simulation world. For
    most games, this will work perfectly. In our code, we will have to apply this
    `PTM_RATIO` to many calculations when we are converting locations between the
    cocos2D layer and the Box2D world.
  prefs: []
  type: TYPE_NORMAL
- en: On to the game!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start our game from the Cocos2D + Box2D template, so it has all the libraries
    we need. To prepare for this project, we still go through the same motions from
    the template, namely removing `HelloWorldLayer.h/.mm`, and changing the references
    in the `IntroLayer.mm` to our menu class. There are a couple of additional classes
    in the template, `GLES-Render` and `PhysicsSprite`. We will deal with them later.
    We also need to switch the supported orientation to portrait only, as we did in
    the previous chapter. (Don't forget to also remove the background rotation line
    in the `IntroLayer.mm` file.)
  prefs: []
  type: TYPE_NORMAL
- en: With a Box2D project, it is important to note that all our implementation classes
    will need names that end in `.mm` instead of `.m`. This tells the compiler that
    we will be using a mixture of Objective-C and C++. You must do this with Box2D,
    because Box2D is written in C++. So where do we start?
  prefs: []
  type: TYPE_NORMAL
- en: World building
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with building the Box2D world itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the world is pretty easy to set up. Here we are defining `gravity`
    as zero, as we don't want our ball to slow down and we don't want our bricks falling
    off the screen. We then set up the world, which is assigned to a variable called
    `world`, which is a `b2World` variable type . When you set up the `b2World`, you
    define the gravity for the world. We will allow objects to sleep. Sleeping means
    that objects that are at rest will "sleep", so the simulation won't spend a lot
    of time calculating movements of a body at rest. However, if something else interacts
    with it (that is, runs into it), the body will wake up immediately and react appropriately.
    We set the continuous physics to be `true`. This allows for a more accurate simulation,
    but requires more computing power. We also establish the contact listener we will
    use for this world. We won't get into the details here – we will save that for
    our discussion about the collision handler.
  prefs: []
  type: TYPE_NORMAL
- en: If you're confused by the C++ syntax here, it is helpful to know that the lines
    with the arrow (->) symbol are calling functions from the object to the left-hand
    side of the arrow. So the line `world->SetContactListener(contactListener);` would
    look like `[world setContactListener:contactListener];`, if Box2D was written
    in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although there are some wrappers that allow you to use Box2D with Objective-C
    syntax, as of this writing none of the projects are mature enough to be recommended
    here.
  prefs: []
  type: TYPE_NORMAL
- en: On the edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a world, we can start defining "stuff" to go in our world.
    Let''s start with some edges for the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've written quite a bit of new code here, so let's break it down. First we
    defined a new body definition (`b2BodyDef`), called `wallBodyDef`. It is an extremely
    basic body. We then tell the `world` to create a `body` using the `b2BodyDef`
    we just created, and we keep a reference to it. Our world now has one formless,
    shapeless body in it.
  prefs: []
  type: TYPE_NORMAL
- en: We fix the "shapeless" problem next. We begin by defining the positions for
    each of the four corners of our playing area, using a shorthand naming pattern
    (that is, bl = bottom left, br = bottom right, and so on). There are two important
    things we need to point out here. For all non-zero positions, we divide the "normal"
    screen position by the `PTM_RATIO`. This is the standard way we can convert the
    `ccp` value we normally would use into a Box2D-friendly coordinate. As you recall,
    PTM means Points-To-Meters, so 32 screen points equals 1 meter in the simulation
    world. Doing this conversion keeps our display and our Box2D simulation in sync.
    You may also notice we are using the `maxY` value of `424`, rather than the top
    of the screen. Our game has a Heads-Up Display covering the top portion of the
    screen, and a `y` value of 424 places this top edge at the bottom of that display
    HUD. We really don't want our player losing their ball under the Heads-Up Display,
    do we?
  prefs: []
  type: TYPE_NORMAL
- en: We then create four `b2EdgeShape` objects, for each side of the screen. We use
    our corner variables to define their positions, using the `Set` function. We then
    instruct the `wallBody` to create a fixture for each of these walls. You will
    notice that we set the variable `bottomGutter` to the returned value of the `CreateFixture`
    command. We will use this later in the collision handler to determine when the
    player lost his ball.
  prefs: []
  type: TYPE_NORMAL
- en: Having a ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have a world with walls, but we don''t have any moving parts yet.
    Let''s build a ball to bounce around:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Building a dynamic object is a little more involved than building the edges,
    but the same basic concepts still apply. Because the ball will have a visible
    sprite associated with the body, we first build a `PhysicsSprite` object. `PhysicsSprite`
    is one of the classes in the cocos2d + Box2D template we used to create the project.
    It is a subclass of `CCSprite`, but includes a couple of extra methods that will
    automatically keep the sprite locked in position with the physics body connected
    to it. The only thing we need to do differently than a normal `CCSprite` is to
    call `setPhysicsBody` on it, which connects the Box2D body to the sprite. The
    end result is that we do not have to manually move (or rotate) the sprite. Without
    this "helper" class, we would be responsible for updating the position and rotation
    of the sprite ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that we assign a `tag` value to the ball. This will be
    useful later, when we are dealing with collisions. (The `tag` definitions are
    contained in `typedef enum` in the `BRDefinitions.h` file.)
  prefs: []
  type: TYPE_NORMAL
- en: We then build a body for the ball. We assign it a type of `b2_dynamicBody`,
    to let Box2D know that this is a body that can move. We set the position of the
    body to correspond to the position of the sprite. A body is by default anchored
    in the middle, just like a `CCSprite`. We can use the same coordinates for the
    body (divided by the `PTM_RATIO`).
  prefs: []
  type: TYPE_NORMAL
- en: The `userData` is a flexible part of the body definition; `userData` can hold
    anything you want to store in it. `userData` is customarily used to hold a reference
    to the `CCSprite` object (or the `PhysicsSprite` object , in our case) that represents
    the actor. Following this convention makes it a trivial matter to get to the sprite
    from the body.
  prefs: []
  type: TYPE_NORMAL
- en: After we instruct the world to create a body with this definition, we define
    a shape. Since we are using a round ball, the `b2CircleShape` is perfect. We define
    the shape's radius by taking the radius of the ball (half the sprite width) and
    dividing by the `PTM_RATIO`.
  prefs: []
  type: TYPE_NORMAL
- en: We then build the fixture to represent the "guts" that accompany the body. We
    assign the circle shape we just defined, and then we set the `density`, `friction`,
    and `restitution`. Density is used in the calculation of mass. The higher the
    density, the more massive the object is. Friction is used to control how the objects
    slide along each other. Friction is normally set between 0 and 1\. Higher friction
    values will slow objects down as they slide against each other. We don't want
    any friction on the ball to keep it moving nicely. The final parameter here is
    `restitution`.
  prefs: []
  type: TYPE_NORMAL
- en: The term restitution is less familiar than the other two, but you can think
    of it as how bouncy the object is. A value of zero means the object will not bounce
    at all. A value of 1 means the object is perfectly bouncy, and will not lose any
    of its velocity when it impacts another object. We don't want the ball to lose
    any velocity when it collides, so we use a value of 1 for the restitution of the
    ball.
  prefs: []
  type: TYPE_NORMAL
- en: After we define the fixture, we create it with the `ballBody`. As a final step,
    we add a linear impulse to the ball, based on the message passed to this method.
    An impulse is basically a kick, with the strength and direction of the impulse
    controlled by the `b2Vec2` parameter, here called `impulse`. The second argument
    `ballBody->GetPosition()` returns the center of the `ballBody`. This will apply
    the impulse to the center of the body, so we get a straight application of the
    impulse.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need a `newBall` method that will always start the ball in the same position,
    and give it a decent impulse to set it in motion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we see from the `newBall` method, we give the ball a very slight "kick" with
    the initial impulse, down and to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `b2Vec2()` is equivalent to a `ccp()`, and uses the same bottom-left origin
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Setting everything in motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have a world, we have edges to hold everything in, and we have
    a ball. Now we need to get it all moving. As you might expect, we handle this
    in the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is an abbreviated form of our final `update` method, with just the ball
    movement handling in place. We start by instructing the world to step forward
    in its simulation. The three parameters sent to the `Step` function are, in order,
    the **time step**, the **velocity iterations** , and the **position iterations**.
    In this game, we are using a variable time step (using the delta value `dt`),
    which works well in our case. More intensive and detailed simulations are better
    suited to use a fixed time step. (Point your favorite search engine to the topic
    to learn more about how to implement a fixed time step.) The velocity iterations
    and position iterations control how detailed the simulation is. A value of 10
    for both iteration values is a good starting point for most projects. Higher values
    will result in more accuracy, but the trade-off is more of a processor load to
    calculate the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have made one step forward in time for the world, we evaluate all
    of the bodies in the world to determine what we should do with them. We iterate
    through the world's bodies with `world->GetBodyList()`, and advance to the next
    body with `b->GetNext()`. For each body we find, we evaluate whether or not it
    has a sprite attached by checking that `userData` is not null. When we find a
    body with a sprite, we get a sprite reference from that body's `userData`. (We
    already have the variable `b` to represent the body, from the `for` loop.)
  prefs: []
  type: TYPE_NORMAL
- en: Because the ball might pick up speed during the game, we put in a speed clamping
    check next. If the sprite is a ball, and the speed is over the set value of 15,
    the body has **linear damping** applied, which will affect the velocity of the
    ball on the next step of the simulation. Damping is essentially applying the brakes
    on the object. We use a value of 0.5, which will slow the ball down, but not stop
    it completely. This acts the same as tapping the brakes in a car, decreasing the
    forward velocity a little bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we don't actually move the ball sprite at all. Because
    we are using a `PhysicsSprite` object instead of a `CCSprite` object, it will
    automatically take care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Collision handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we have reviewed so far will make the ball bounce around the screen,
    but nothing interesting will happen when the ball hits the wall, except it will
    bounce around. What we need is to add a way to take some action when certain objects
    collide with others. We do this by implementing a contact listener. A contact
    listener has four components: `BeginContact`, `EndContact`, `PreSolve`, and `PostSolve`.
    Going into detail on each of these is beyond the scope of this book. For our project,
    we will only be implementing a simplified contact listener with code for `BeginContact`
    and `EndContact` only. Let''s look at the header first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRContactListener.h`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can look at the implementation file for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRContactListener.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplified contact listener published as part of a tutorial by Ray
    Wenderlich ([http://raywenderlich.com](http://raywenderlich.com)), so any credit
    for this approach belongs to Ray. The basic design of this contact listener is
    to get the fixtures that are in contact (that is, colliding), and copy them out
    to `_contacts`, so we can evaluate them in our `BRPlayfieldLayer` instead of here.
    This copying is done in the `BeginContact`. `EndContact` removes the contact from
    `_contacts`, so that we are not evaluating outdated contacts.
  prefs: []
  type: TYPE_NORMAL
- en: One nice aspect of this approach is that the contact listener itself is general-purpose
    enough to be used as it is in many projects. If you are less experienced with
    C++, having boilerplate code like this is always helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Losing your ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we would expect our ball to be lost when it reaches the bottom
    edge of the screen. But instead, it will simply bounce off because we have not
    defined any custom behavior for when the ball and the fixture at the bottom of
    the screen collide. If you recall, when we defined the edges, we kept a variable,
    `bottomGutter`, for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We will be handling our collisions in our `update` method, directly after the
    `for` loop from earlier, where we controlled the ball's speed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code block we are mostly using C++ structures, but the concepts are
    straightforward. We begin by defining two vectors, which are a form of dynamic
    array. The `toDestroy` vector will house any objects that need to be destroyed.
    The vector `pos` is an iterator which, as the name suggests, is used to iterate
    over data elements. We then enter a `for` loop, which iterates over the contents
    of the `_contacts` variable that was populated in the contact listener. Inside
    the loop, we use the variable `contact` to represent the current contact/collision
    from `_contacts` that we are evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: As the contact contains the fixtures that are contacting one another, we use
    the `GetBody()` function of the fixtures to get the two bodies involved, naming
    them `bodyA` and `bodyB`. We will need to get the tags from the attached `CCSprite`
    objects, so we also create `spriteA` and `spriteB` to represent the sprites associated
    with those bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we only have one type of collision that we need to address: the ball
    with the `bottomGutter` fixture. We identify the ball based on the sprite''s tag
    of `kBall`, and we can identify the `bottomGutter` fixture because we stored a
    reference when it was created. To determine if we had a collision, we simply have
    to evaluate both objects to determine if one is a ball and other is the `bottomGutter`
    fixture. You will see from the code that we evaluate the collision twice, once
    comparing the "A" object to the ball and the "B" to the fixture, and then we evaluate
    again, with "A" and "B" swapped. We do this because the contact listener does
    not provide the fixtures "A" and "B" in any particular order. The ball might be
    "A" this time, and "B" the next time. The only way to reliably evaluate this is
    to have two checks for each collision in this manner. (You could always create
    a helper function to evaluate both of these ways for you, but it only results
    in slightly more compact code, but not necessarily any better performance.)'
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, if we identified a collision between the ball and the `bottomGutter`,
    then the offending body is added to the `toDestroy` vector. The additional `if`
    statement wrapped around it is checking to make sure this body is not already
    in the `toDestroy` vector, because we won't be able to destroy the same body twice.
  prefs: []
  type: TYPE_NORMAL
- en: Destruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have identified the objects to be destroyed, but we haven't actually
    destroyed anything. Just as with Objective-C, you should not attempt to remove
    objects from an array while iterating through it, and C++ vectors are no exception.
    As such, after we have evaluated all of our collisions, we add one more block
    of code at the bottom of the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a similar iterator to loop through the `toDestroy` vector. We retrieve
    each body, check if it has a sprite attached to it (in `userData`), and call the
    `spriteDestroy` method if it does. Then we instruct the world to destroy the body
    of this object. The `spriteDestroy` method is used for all of the sprite destructions
    in our game. An abbreviated form of it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use the sprite tags here so that we can have custom destruction behavior
    for each type of object. We could have embedded this in the `update` method, but
    it will get pretty long by the end of this game. Separating the destruction code
    also keeps our Objective-C and C++ a little better separated in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Paddling around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have our basic game world, we have walls, and a ball that will drop
    off of the bottom of the screen. We need to turn our attention to the only piece
    of the game the user directly controls: the paddle. Let''s look at how we build
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Much of this is the same as when we built the ball. We create the `PhysicsSprite`
    first. Then we define the body at the same position, and attach the sprite to
    the body. You will notice that instead of building the fixture here, we call another
    method to define the fixture. This is because we will be using different fixtures
    for the paddle later, when we explore power-ups. We will get to the details of
    the fixture building in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: One new item that we need to build is a prismatic joint for the paddle, which
    connects the `paddleBody` to the `wallBody`. A prismatic joint allows a body to
    travel along a specific axis only. In our case, we define the `worldAxis` as constraining
    the movement along the x axis only, based on the coordinates we defined. One important
    flag we set for the paddle is `collideConnected` to `true`. This allows collisions
    to be detected between bodies connected by the joint. Since we are creating a
    joint between the paddle and the `wallBody`, we need to set this to allow the
    paddle to collide with the side walls. Without this established, the paddle will
    pass through the sides of the playfield and leave the game. Just as with other
    Box2D elements, we create the joint by passing the `CreateJoint` request to the
    world itself.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be implementing some power-ups later that will allow the paddle size
    to be changed. Because of this, we need the ability to change the paddle size.
    As we discussed earlier, the fixture handles the geometry and the physical properties
    of the body, so we have moved this fixture definition to its own method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To build a normal paddle, we first define the `b2PolygonShape` that matches
    the paddle. Because we have created a paddle that is not a simple shape (circle
    or square), we have to define all of the points that define the boundary of the
    shape. It is important to remember that these coordinates are in points, not pixels.
    If you are only using non-Retina displays, this makes no difference. Since our
    project includes both Retina and non-Retina assets, these coordinates must be
    defined based on the non-Retina sprite. There are many tools to help you define
    what these points should be, but you can also use most graphics editing programs
    to identify the points that define the "corners" of the shape. It is important
    to define the points of the polygon in a counter-clockwise order. If you define
    them in the other direction, the program will crash, usually when Box2D is calculating
    the area of the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Box2D defaults to a maximum of eight vertices to define a shape. If you need
    more than that, you can easily change the setting in the `b2Settings.h` file.
    This maximum is defined as `b2_maxPolygonVertices`.
  prefs: []
  type: TYPE_NORMAL
- en: After the shape has been defined, we call out another method to actually build
    the fixture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start this method with a check to make sure we don't already have a `paddleFixture`
    object defined. If we do, we destroy it.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the fixture definition follows the same pattern we used in the ball
    definition. We set the `density`, `friction`, and `restitution`, and we attach
    the shape to the fixture and the fixture to the body. You will notice that we
    set the `shape` to the variable shape that we passed to this method. The final
    line of this method is redundant and unnecessary the first time we build the paddle.
    We call `setDisplayFrame` to change the sprite frame attached to the paddle. This
    will come in handy when we add the power-ups later.
  prefs: []
  type: TYPE_NORMAL
- en: Touching the paddle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To interact with the paddle, we need to create a new type of joint: the mouse
    joint. The mouse joint tries to make the body move toward the target set for it.
    In our case, the target will be our touched point. This will allow us to drag
    the paddle around while it is still a part of the Box2D world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach for using the mouse joint is to detect touches on the paddle itself,
    and allow the player to move it directly. We will take an alternate approach,
    and detect any touches in the bottom portion of the screen as the target for the
    mouse joint. Naturally, we will begin with the `ccTouchesBegan` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We begin by checking if there is already a `mouseJoint` defined. If there is,
    that means there is already one touch "in play", and we don't want to interfere
    with the current touch.
  prefs: []
  type: TYPE_NORMAL
- en: The next section uses fairly standard conversions from the touch to the OpenGL
    coordinates. However, here we also define the `locationWorld b2Vec2`, which is
    the Box2D version of the location variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then check for a touch in the bottom portion of the screen. If the touch
    is there, we create a new mouse joint, and attach it to the `wallBody` and the
    `paddleBody`. The attachment to the `wallBody` is basically an anchor, since a
    joint must connect two bodies. Only the `paddleBody` will be moved by this joint.
    We set the `maxForce` variable to 1,000 times the mass of the paddle, so the player's
    movements completely override any other forces that may be trying to influence
    the paddle. We create the joint, and then make sure the paddle is awake (in case
    it was sitting idle long enough to sleep).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the mouse joint instantiated, we need to make the mouse joint
    track the user''s movements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `ccTouchesMoved` method is almost trivial. We determine the current location
    of the touch, and we set that as the new target for the mouse joint. That's all
    it takes to move the paddle around. There is one loose end, however. The final
    step of the touch handling is to handle the cancel and end events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both of these methods are identical. Because the touch handler
    is only concerned with moving around the paddle with the mouse joint, all we need
    to do to end (or cancel) the touch is to destroy the mouse joint. Now that we
    have completed the touch handler, the game now has enough components to move the
    paddle around and bounce the ball. Box2D will handle all of the collisions between
    the ball and paddle, without our code needing to do any collision handling of
    our own.
  prefs: []
  type: TYPE_NORMAL
- en: Storing player data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges with a multi-level game is keeping the player's information
    between levels. There are two common approaches. One is to pass the player data
    (usually as a player object) from one scene to the next via the scene `init` methods.
    (We used this approach in the snake game in [Chapter 4](ch04.html "Chapter 4. Give
    a Snake a Snack…"), *Give a Snake a Snack*.) The other is to use a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: A Singleton is a design pattern for a class of which there is only one instance
    allowed. Cocos2D is built on a foundation of Singletons like `CCDirector`, `CCSpriteFrameCache`,
    and so on. Pretty much anything where you reference a "sharedSomething" (for example,
    `[CCDirector sharedManager]`) is a Singleton. By design, there is a maximum of
    one "living" version of a Singleton class at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a Singleton class to handle our game variables `currentLevel`,
    `currentLives`, and `currentScore`. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRGameHandler.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These are the general Singleton methods we will use. There are several methods
    that are not directly called in our game, but this is general enough to be used
    in many projects (other than the `@synthesize` statements). The `sharedManager`
    class method will check if there is a `gameHandler` already instantiated. If there
    is, it returns the existing instance. If not, it creates one. We are using **Grand
    Central Dispatch** (**GCD**) in the `sharedManager` method. It is beyond our scope
    here to go into detail on GCD, but this method is extremely lightweight and fast,
    compared to more traditional designs. (If you want to know more, check your favorite
    search engine for "Grand Central Dispatch Singleton" for further reading.) The
    first time you call `[BRGameHandler sharedManager]`, it will be created. This
    Singleton class will remain available for the life of the game, so you can rely
    on it to hold any variables you need to persist through your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we look at the game-specific methods we include in our Singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRGameHandler.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have a couple of helper methods here to make our main code simpler. The first
    time we instantiate the class, it will call `resetGame` to set the `currentLevel`,
    `currentLives` , and `currentScore` variables to their starting values. As the
    Singleton instance will not be released, we put the variable initializations in
    the `resetGame` method. In this way, a single call to that method will fully reset
    the Singleton to a "fresh" state for a new game. The `addToScore` and `loseLife`
    methods are for convenience, so we don't have to "bother" our main playfield class
    with calculating what the new values should be when we score points or lose a
    life.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying player data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have a place to store the player data, but we will also need a way to
    display this for the user. For this game, we are following "best practices" by
    separating the **Heads-Up Display** (**HUD**) layer from the main playfield layer.
    The HUD is a standard layer, with a background box, a place for the score, and
    a place for lives remaining. One item to be pointed out is that in the HUD interface,
    we have defined the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `init` method of the HUD implementation, we have the paired line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point on in this class, any time we want to reference our `BRGameHandler`
    Singleton, we only have to use the variable `gh`. (Note: we also have this same
    variable defined in the `BRPlayfieldLayer` class.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRHUD.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The HUD acts as a "bridge" between the playfield layer and the game handler
    for scoring purposes. In the `addToScore` method, we first call out to the game
    handler to add points to the current score, and then the HUD calls the `setString`
    method on the `scoreDisplay` label to update the displayed score. By using a method
    like this, the playfield layer only has to pass one message to the HUD, and it
    takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: We want to get a little fancier with the display of lives remaining, and use
    `CCSprite` images of a ball for each life remaining, and we want a nice animation
    in the HUD when the player loses a life.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRHUD.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because we don't want to create a variable for each of the player's "life sprites",
    we instead opt to use an array to keep those sprites, called `livesArray`. When
    we call the `createLifeImages` method, it will generate the correct number of
    sprites, and space them out nicely in the display. It also stores them in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRHUD.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When the player loses a life, we handle it in the same way we handled the score
    updates. We send the message to the game handler (which will subtract one from
    the `currentLives` variable). Our next step is to add a reference to the last
    sprite in the array with the `lifeToRemove` variable. After a little animation,
    we use `CCCallFuncND` to trigger the `destroyLife:` method, passing the `CCSprite`
    instance of the "life sprite" we want to remove from the game. That method simply
    removes it and frees up that memory. At the end of the `loseLife` method, we remove
    the sprite from the `livesArray`.
  prefs: []
  type: TYPE_NORMAL
- en: By encapsulating these updates in the HUD, we don't have to clutter up our playfield
    with methods that don't have anything to do with the core gameplay. If we were
    to radically alter the appearance and general behavior of the HUD (assuming that
    `addToScore:` and `loseLife` were still present), the gameplay layer code would
    not change at all. This design also means that we could use a completely different
    playfield class with this same HUD. That is the flexibility that we strive for
    in our coding.
  prefs: []
  type: TYPE_NORMAL
- en: Building bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are missing one vital piece from our game: bricks to break. We want our
    game to be flexible enough that we will be able to define new levels without diving
    too deep into our source code, so we will be storing our levels as a **property
    list** (**plist**).'
  prefs: []
  type: TYPE_NORMAL
- en: For our game, we want to have unlimited play, so we will define a set number
    of brick patterns, and the game will loop through these in order. When you reach
    the end, it will go back to the first pattern and repeat the cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We define the patterns in the plist as an array with the name in the format
    `P#`, so the patterns would be named `P1`, `P2`, `P3`, and so on. Inside each
    array are the strings representing each row of bricks. The rows begin at the bottom,
    so **Item 0** is the lowest row of bricks, and **Item 1** would be above it, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to build a level editor for our game, we would be more likely to
    build a more robust plist structure. Because we are hand coding the level design,
    the easiest way to organize the data is in strings. For each row of each pattern,
    we define a string of 13 digits, each digit representing a brick. (Our screen
    size will only hold 13 bricks wide.) We will represent the bricks based on the
    numbering in their file names (`brick1.png`, `brick2.png`, and so on) as well
    as a zero, representing no brick in that position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at one pattern from the plist, and how it will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building bricks](img/9007_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example showing pattern **P2**, **Item 0** is the bottom-most row of
    the final grid of bricks, shown to the right. You can see how it translates: brick
    number 3 is green, 4 is grey, 5 is orange, and so on. As long as we keep in mind
    the "bottom first" nature of the pattern, it becomes very easy to "see" the patterns
    in the numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a plist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we have a plist of pattern data, how do we load it? We have chosen to
    use an `NSDictionary` as the data structure that we want to hold the plist data
    once loaded. We add a plist loader into our `BRGameHandler` because it is a more
    general method, so we have it centralized if we decide we need to load a plist
    for some other part of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRGameHandler.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code is written with a couple of assumptions. One is that the passed filename
    will be without an extension (that is, we pass "patterns" if the filename is `patterns.plist`).
    The other assumption is that the plist file is in the main app bundle. You will
    notice that this method returns a value of type `id`. Since it was built as a
    general-purpose loader, we need one additional helper method to easily get the
    `NSDictionary` we desire for our data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRGameHandler.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This simply passes the filename to the `readPlist` method, and casts the returned
    value as an `NSDictionary`. (We can also use the same `readPlist` method to return
    an `NSArray`, using the same casting approach.)
  prefs: []
  type: TYPE_NORMAL
- en: Picking a pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to load the pattern data, let''s take a look at the code
    from the `init` method of the `BRPlayfieldLayer` where we load the patterns, and
    decide which pattern to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `init` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We load all of the pattern definitions into `patternDefs` using the `dictionaryFromDictionary`
    method. We then identify how many total patterns we have defined in the file.
    If we add new patterns to the plist, this is the only element of the actual code
    that needs to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: The `newPattern` calculation uses a modulo operation to give us an endless repeating
    sequence of patterns. (We subtract one from the current level number because we
    start with Pattern P0 for Level 1.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we move to the method that interprets the pattern data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we hold the array for the currently chosen pattern in the variable `tmpPattern`.
    Since each pattern is an array of strings, we then iterate through the `tmpPattern`
    array, and for each string in the array, we call the method to build the next
    row of bricks with this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we are building an entire row of bricks, we approach this build method
    a little differently:'
  prefs: []
  type: TYPE_NORMAL
- en: We are passed the row number and the string representing this row of bricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We iterate through all of the characters of the string, one at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call NSMakeRange to substring only one character at a time, and convert that
    character to an integer value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is zero, there is no brick in that position, and no further action
    is taken for this position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need a brick here, we then proceed to build them in the same manner as
    the other objects. We build a sprite, body, shape, and fixture, and attach them
    together. When we define the shape of the fixture we use the `SetAsBox` function,
    so we can simply provide half the width of the sprite and half the height of the
    sprite, and Box2D builds the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking bricks, for real
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all the core elements of the game defined, we need to add collision
    handling for the ball hitting the bricks. If we were to stop here, the ball would
    hit the bricks, and the bricks would go flying off from the force of the impact.
    We really want the brick to be destroyed, so we will revisit the `update` method
    we described earlier in the *Losing Your Ball* section. Immediately after the
    `if…else` statement in the `update` method, we add a couple of clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `init` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The outer clause makes sure we have sprites for both bodies involved in the
    contact. We then check the `tag` value for both sprites. If one is the brick and
    the other is the ball, then we add the brick to the `toDestroy` vector. As you
    recall, this is exactly how we handled the ball versus `bottomGutter` collisions
    earlier. The only primary difference is that we are comparing two sprites this
    time, and we are destroying the brick, not the ball.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are using one common path of destruction for objects, we don''t
    have to add anything else to the `update` method to make this process work. We
    only need to add a new case statement in the `spriteDestroy` method. Let''s look
    at that method again:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you may remember, we actually destroy the Box2D body itself at the end of
    the `update` method, so we clean up the sprites here and take care of any additional
    housekeeping items, such as incrementing the score, playing sound effects, and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have included one method in the `case kBrick` section that leads us to our
    next (and final) topic for this game: implementing power-ups.'
  prefs: []
  type: TYPE_NORMAL
- en: Power-ups, good and bad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of power-ups is core to the modern brick breaking experience. For
    our game, we will be implementing three types of power-ups: paddle expanding,
    paddle contracting, and multiball. As we just saw, when a brick is destroyed another
    method gets called to handle the power-ups.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this method we randomize a number. If it is below 25 percent, we call another
    method to actually build a power-up. It is important to point out that in the
    `spriteDestroy` method, we must call this method before we `removeFromParentAndCleanup`
    because we will need to use the position of the brick that is being destroyed
    here. This allows the power-up to drop from "inside" the brick that was just destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we follow this code path, we now reach the point where we have decided to
    generate a power-up. This is another Box2D-enabled body, so let''s review the
    build method for the power-ups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we call this method, we only have gotten as far as knowing we need to generate
    a power-up, but we have not yet identified which of the three available power-ups
    we will generate. To that end, we use `arc4random()` to randomly choose which
    of the power-ups we want to use. The only difference in this build method is different
    values for the sprite file name and for the sprite's `tag` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For mathematical purists, none of the randomizing approaches used in this book
    are "true randomness". There will be some small imbalance in the frequency of
    numbers generated. However, this is just a game, so less than perfect randomness
    is perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: We continue to build the body, shape, and fixture much the same as we did for
    the paddle body, including defining the polygon shape by its eight points. We
    could have also gotten by with using a box shape instead, but we wanted to get
    "pixel-perfect" with the rounded corners on the power-up blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The fixture is a little different, however. We don't set the `density`, `friction`,
    or `restitution` for this fixture. Instead, we use a new property, `isSensor`.
    A sensor is a fixture that can take part in collisions, but doesn't actually cause
    things to impact it. A sensor can pass through another body without any hit-and-bounce-off
    actions. However, we can detect when a sensor and another fixture come in contact
    with each other. In our case, the power-ups will be picked up by the paddle, but
    they shouldn't bounce around and/or get hit by the ball or paddle.
  prefs: []
  type: TYPE_NORMAL
- en: We finish off the building of the power-up by applying a downward linear impulse
    on the body, so it will drop straight down. This simulates the effect of gravity,
    even though we have zero gravity for our world.
  prefs: []
  type: TYPE_NORMAL
- en: Picking up power-ups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to handle the collisions between the power-ups and the paddle. We
    have most of the pieces we need to make this happen already. Back in the `update`
    method, we add a few more checks directly after the brick versus ball checks.
    We need three more pairs of checks between the paddle and each type of power-up.
    (We only include the first pair for example – the other two are identical, just
    change the `tag` checked for the power-ups.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is almost a direct copy-and-paste from the prior collision checking. Once
    again, when a power-up is "picked up", we simply add it to the `toDestroy` vector.
    As you have probably guessed, we handle the rest of the power-up triggering in
    the `spriteDestroy` method. In that method, we add three more case statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `spriteDestroy` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For the contract and expand power-ups, we remove the sprite and then call to
    build a new fixture. The `paddleTimer` and `isPaddleDeformed` variables will be
    used to control when the paddle goes back to normal size.
  prefs: []
  type: TYPE_NORMAL
- en: For the multiball, there is a little more substance to it, so here we simply
    set the flag `shouldStartMultiball` to `YES`, so we can deal with it on the next
    `update` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle deformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you recall when we first build the paddle, we build the fixture itself in
    a separate method, `buildPaddleFixtureNormal`. When the player catches a contract
    or expand power-up, we simply need to destroy the existing fixture and build a
    new one. Let''s look at the expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see why we divided the paddle fixture building into two methods. We
    can leverage all of the setup done by the `buildPaddleFixtureWithShape: andSpriteFrameName:`
    method we built earlier. The major differences are that we set a different `spriteFrameName`,
    and we define the `verts[]` with the coordinates that match the `paddle_wide.png`
    sprite''s geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: The method `buildPaddleFixtureShort` follows the same design, using the display
    frame `paddle_short.png` and an alternate set of `verts[]` values. All the other
    code is identical to the "long" method.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring the paddle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have either expanded or contracted the paddle, how do we go back
    to normal? We have set a 10 second timer value in the `spriteDestroy` method,
    but we need to actually do something with it. At the top of the `update` method,
    we add one simple `if` clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We only enter this clause if the `isPaddleDeformed` variable is set to `YES`.
    We subtract the current delta from the `paddleTimer`, and then check if our time
    has run out. If it has run out, we set `isPaddleDeformed` to `NO`, and call to
    the `buildPaddleFixtureNormal` method to restore our original paddle sprite and
    fixture. Thus, we are back to normal gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Multiball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier we saw that the collision with the multiball power-up only sets the
    `shouldStartMultiball` variable to `YES`, and does not take any further action.
    Instead, we put the actual trigger at the end of the update method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm` (inside `update` method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Why not simply call `startMutiball` directly? Because multiball involves the
    creation of new bodies, we want to make sure that the creation of those bodies
    does not happen while we are iterating through the world bodies (which we do at
    the top of the `update` method). To avoid this conflict, it is much safer to set
    triggers as we have done, and take action on them in a portion of the `update`
    method where you can be certain to be "in the clear".
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The core of this method iterates over the bodies in the world, and looks for
    a sprite that has the tag `kBall`. It then calls the same `buildBall` method we
    used for the "normal" ball, and creates two new balls at the same position, but
    gives them a different impulse. This set of impulses gives a "popcorn" effect,
    so the two new balls go slightly up and to each side of the original ball.
  prefs: []
  type: TYPE_NORMAL
- en: We also have some extra code to prevent "bad behavior". The check of the `isBallInPlay`
    variable is to prevent a situation where the player catches a multiball right
    as the only ball in play is destroyed. This can cause a crash, if the sprite and
    body are destroyed at the same time the multiball is trying to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: We also force a break after one ball has been "multiballed". If we were to allow
    the iterator to continue evaluating other bodies, there is a strong possibility
    (depending on timing) that the two newly created balls would also be "multiballed"
    (that is, creating two new balls for each of them), and then those balls would
    also be "multiballed", and so on. The screen would instantly fill up with dozens
    of balls, and the game is unplayable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also keep track of how many "extra" balls we have in play, with
    the `multiballCounter` variable. This is important, so we don't accidentally trigger
    losing a life when the player still has balls in play.
  prefs: []
  type: TYPE_NORMAL
- en: Losing lives with multiball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having more than one ball in play at a time makes detecting a lost ball a little
    more involved. Let''s take a look at the final `loseLife` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filename:** `BRPlayfieldLayer.mm`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We start by evaluating the `multiballCounter` variable. If there are any multiballs
    in play, we will subtract from that variable first, and the player's lives are
    not affected. If there is no multiball, then we call the HUD to lose a life. As
    you recall, this updates the HUD as well as updating the `currentLives` variable
    in the `BRGameHandler` class. Because of this, we can then evaluate the `[gh currentLives]`
    variable to determine the new number of lives for the player. If there are lives
    left, we create a new ball, and continue on. Otherwise, we begin the Game Over
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of (physics enabled) ground here. We have discussed the
    basics of Box2D, and we have built a pretty good brick breaker. We have focused
    on the core mechanics of the physics world, and how to translate between the Box2D
    and cocos2d positioning (using the `PTM_RATIO`). We have learned how to implement
    power-ups that affect the physics of the Box2D world during gameplay, and learned
    how to use a contact listener, and how to decide which collisions cause destruction.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore head-to-head action gaming with two players
    on the same device as well as our first two device game. Let's roll!
  prefs: []
  type: TYPE_NORMAL
