<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor082"/>Chapter 7</em>: Building Data Sources</h1>
			<p>In this chapter, we will continue focusing on the data layer by discussing how we can implement local and remote data sources and the roles they play in clean architecture. First, we will look at how remote data sources can be built and how they can fetch data from the internet through calls to Retrofit. Then, we will look at implementing local data sources and how they can interact with Room and Data Store to persist data locally. In the chapter's exercises, we will continue the previous exercises and add the data sources discussed in the chapter, seeing how we can connect them to Room and Retrofit.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Building and using remote data sources</li>
				<li>Building and integrating local data sources</li>
			</ul>
			<p>By the end of the chapter, you will have learned the role of data sources, how to implement remote and local data sources that use Retrofit, Room, and Data Store to manage an application's data, and how we can separate these data sources in separate library modules.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio – Arctic Fox | 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter7">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter7</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3yOa7jE">https://bit.ly/3yOa7jE</a></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor084"/>Building and using remote data sources</h1>
			<p>In this <a id="_idIndexMarker474"/>section, we <a id="_idIndexMarker475"/>will look at how we can build remote data sources and how we can use them in combination with Retrofit to fetch and manipulate data from the internet.</p>
			<p>In the previous chapters, we defined abstractions for data sources that repositories depend on to manipulate data. This was because we wanted to avoid the repositories having dependencies on the data sources and instead have the data sources depend on the repositories. For remote data sources, this looks something like the following figure:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_7.01_B18320.jpg" alt="Figure 7.1 – A remote data source class diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A remote data source class diagram</p>
			<p>The implementation <a id="_idIndexMarker476"/>of the remote data source has two roles. It <a id="_idIndexMarker477"/>will invoke the networking layer to fetch and manipulate data, and it will convert the data to either the domain entity or, if necessary, intermediary data required by the repository.  </p>
			<p>Let's look at the entity defined in the previous chapters:</p>
			<p class="source-code">data class User(</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    val firstName: String,</p>
			<p class="source-code">    val lastName: String,</p>
			<p class="source-code">    val email: String</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getFullName() = "$firstName $lastName"</p>
			<p class="source-code">}</p>
			<p>Here, we have the same <strong class="source-inline">User</strong> data class that was defined as part of the domain. Now let's assume<a id="_idIndexMarker478"/> we <a id="_idIndexMarker479"/>are fetching the following data from the internet in JSON format:</p>
			<p class="source-code">data class UserApiModel(</p>
			<p class="source-code">    @Json(name = "id") val id: String,</p>
			<p class="source-code">    @Json(name = "first_name") val firstName: String,</p>
			<p class="source-code">    @Json(name = "last_name") val lastName: String,</p>
			<p class="source-code">    @Json(name = "email") val email: String</p>
			<p class="source-code">)</p>
			<p>Here, we have a <strong class="source-inline">UserApiModel</strong> class in which we define the same fields as the <strong class="source-inline">User</strong> class and annotate them with the <strong class="source-inline">@Json</strong> annotation, which is part of the Moshi library. </p>
			<p>The remote data source abstraction looks like the following:</p>
			<p class="source-code">interface UserRemoteDataSource {</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>This is the abstraction we defined in the previous chapter. Before we write the implementation of this class, we will first need to specify our Retrofit service:</p>
			<p class="source-code">interface UserService {</p>
			<p class="source-code">    @GET("/users/{userId}")</p>
			<p class="source-code">    suspend fun getUser(@Path("userId") userId: String): </p>
			<p class="source-code">        UserApiModel</p>
			<p class="source-code">}</p>
			<p>This is a typical Retrofit service class, which will fetch an <strong class="source-inline">UserApiModel</strong> class from the <strong class="source-inline">/users/{userId}</strong> endpoint. We can now create the implementation of the data source to<a id="_idIndexMarker480"/> fetch<a id="_idIndexMarker481"/> the user from <strong class="source-inline">UserService</strong>:</p>
			<p class="source-code">data class UserRemoteDataSourceImpl(private val userService: UserService) : UserRemoteDataSource {</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; {</p>
			<p class="source-code">        return flow {</p>
			<p class="source-code">            emit(userService.getUser(id))</p>
			<p class="source-code">        }.map {</p>
			<p class="source-code">            User(it.id, it.firstName, it.lastName,</p>
			<p class="source-code">                it.email)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we implement the <strong class="source-inline">UserRemoteDataSource</strong> interface, and in the <strong class="source-inline">getUser</strong> method, we invoke the <strong class="source-inline">getUser</strong> method from the <strong class="source-inline">UserService</strong> dependency. Once <strong class="source-inline">UserApiModel</strong> is obtained, we then convert it to the <strong class="source-inline">User</strong> class. </p>
			<p>In this section, we looked at how we can build a remote data source with the help of the Retrofit library to manipulate data from the internet. In the section that follows, we will look at an exercise that shows how we can implement a remote data source.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Exercise 07.01 – Building a remote data source  </h2>
			<p>Modify <em class="italic">Exercise 06.01 – Creating repositories</em> so that a new library module is created in <a id="_idIndexMarker482"/>Android Studio. Name the module <strong class="source-inline">data-remote</strong>. This module will depend on <strong class="source-inline">domain</strong> and <strong class="source-inline">data-repository</strong>. The module will be responsible for fetching users and posts as JSON from <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a>.</p>
			<p>The user will have the following JSON representation:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "id": 1,</p>
			<p class="source-code">    "name": "Leanne Graham",</p>
			<p class="source-code">    "username": "Bret",</p>
			<p class="source-code">    "email": "Sincere@april.biz"</p>
			<p class="source-code">}</p>
			<p>The post will have the following JSON representation:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "userId": 1,</p>
			<p class="source-code">    "id": 1,</p>
			<p class="source-code">    "title": "sunt aut facere repellat provident </p>
			<p class="source-code">        occaecati excepturi optio reprehenderit",</p>
			<p class="source-code">    "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"</p>
			<p class="source-code">}</p>
			<p>The module will need to implement the following:</p>
			<ul>
				<li><strong class="source-inline">UserApiModel</strong> and <strong class="source-inline">PostApiModel</strong>, which will hold the data from the JSON.</li>
				<li><strong class="source-inline">UserService</strong>, which will return a list of <strong class="source-inline">UserApiModel</strong> from the <strong class="source-inline">/users</strong> URL and <strong class="source-inline">UserApiModel</strong> based on the ID from the <strong class="source-inline">/users/{userId}</strong> URL.</li>
				<li><strong class="source-inline">PostService</strong>, which will return a list of <strong class="source-inline">PostApiModel</strong> from the <strong class="source-inline">/posts</strong> URL and <strong class="source-inline">PostApiModel</strong> based on the ID from the <strong class="source-inline">/post/{postId}</strong> URL.</li>
				<li><strong class="source-inline">RemoteUserDataSourceImpl</strong>, which will implement <strong class="source-inline">RemoteUserDataSource</strong>, call <strong class="source-inline">UserService</strong>, and return <strong class="source-inline">Flow</strong>, which emits a list of <strong class="source-inline">User</strong> objects or <strong class="source-inline">UseCaseException.UserException</strong> if there is an error in the call to <strong class="source-inline">UserService</strong>. The same approach will be taken for returning <strong class="source-inline">User</strong> based on the ID.</li>
				<li><strong class="source-inline">RemotePostDataSourceImpl</strong> which will implement <strong class="source-inline">RemotePostDataSource</strong>, call <strong class="source-inline">PostService</strong>, and return <strong class="source-inline">Flow</strong>, which emits a list<a id="_idIndexMarker483"/> of <strong class="source-inline">Post</strong> objects or <strong class="source-inline">UseCaseException.PostException</strong> if there is an error in the call to <strong class="source-inline">PostService</strong>. The same approach will be taken for returning a post based on the ID.</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li>Create the <strong class="source-inline">data-remote</strong> module.</li>
				<li>Create the <strong class="source-inline">UserApiModel</strong> and <strong class="source-inline">UserService</strong> classes.</li>
				<li>Create the <strong class="source-inline">PostApiModel</strong> and <strong class="source-inline">PostService</strong> classes.</li>
				<li>Create the remote data sources implementations for <strong class="source-inline">RemoteUserDataSource</strong> and <strong class="source-inline">RemotePostDataSource</strong>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create a new module named <strong class="source-inline">data-remote</strong>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <strong class="source-inline">build.gradle</strong> file, the following dependencies are set:<p class="source-code">buildscript {</p><p class="source-code">     …</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath gradlePlugins.android</p><p class="source-code">        classpath gradlePlugins.kotlin</p><p class="source-code">        classpath gradlePlugins.hilt</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add<a id="_idIndexMarker484"/> the networking libraries to the library mappings:<p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        versions = [</p><p class="source-code">                …</p><p class="source-code">                okHttp             : "4.9.0",</p><p class="source-code">                retrofit           : "2.9.0",</p><p class="source-code">                moshi              : "1.13.0",</p><p class="source-code">                …</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">        network = [</p><p class="source-code">                okHttp       : "com.squareup.okhttp3:</p><p class="source-code">                    okhttp:${versions.okHttp}",</p><p class="source-code">                retrofit     : "com.squareup.retrofit2</p><p class="source-code">                    :retrofit:${versions.retrofit}",</p><p class="source-code">                retrofitMoshi: "com.squareup.retrofit2</p><p class="source-code">                    :converter-moshi:$</p><p class="source-code">                        {versions.retrofit}",</p><p class="source-code">                moshi        : "com.squareup.moshi:</p><p class="source-code">                    moshi:${versions.moshi}",</p><p class="source-code">                moshiKotlin  : "com.squareup.moshi:</p><p class="source-code">                    moshi-kotlin:${versions.moshi}"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">    }</p></li>
				<li>In <a id="_idIndexMarker485"/>the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">data-remote</strong> module, make sure that the following plugins are present:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, change the configurations to the ones defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are making sure that the new module will use the same configurations with regards to<a id="_idIndexMarker486"/> compilation and the minimum and maximum Android version as the rest of the project, making it easier to change the configuration across all the modules.</p>
			<ol>
				<li value="6">In the same file, add the dependencies to the networking libraries and the <strong class="source-inline">data-repository</strong> and <strong class="source-inline">domain</strong> modules:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation(project(path: ":data-repository"))</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    implementation network.okHttp</p><p class="source-code">    implementation network.retrofit</p><p class="source-code">    implementation network.retrofitMoshi</p><p class="source-code">    implementation network.moshi</p><p class="source-code">    implementation network.moshiKotlin</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>In the top-level <strong class="source-inline">gradle.properties</strong>, add the following configuration for <strong class="source-inline">moshi</strong>:<p class="source-code">android.jetifier.ignorelist=moshi-1.13.0</p></li>
				<li>In the <strong class="source-inline">AndroidManifest.xml</strong> file in the <strong class="source-inline">data-remote</strong> module, add the internet <a id="_idIndexMarker487"/>permission:<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p><p class="source-code">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</p><p class="source-code">    package="com.clean.data_remote"&gt;</p><p class="source-code">    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;</p><p class="source-code">&lt;/manifest&gt;</p></li>
				<li>In the <strong class="source-inline">data-remote</strong> module, create a new package called <strong class="source-inline">networking</strong>.</li>
				<li>In the <strong class="source-inline">networking</strong> package, create a new package called <strong class="source-inline">user</strong>.</li>
				<li>In the <strong class="source-inline">user</strong> package, create a new class called <strong class="source-inline">UserApiModel</strong>:<p class="source-code">data class UserApiModel(</p><p class="source-code">    @Json(name = "id") val id: Long,</p><p class="source-code">    @Json(name = "name") val name: String,</p><p class="source-code">    @Json(name = "username") val username: String,</p><p class="source-code">    @Json(name = "email") val email: String</p><p class="source-code">)</p></li>
				<li>In the same package, create a new interface called <strong class="source-inline">UserService</strong>:<p class="source-code">interface UserService {</p><p class="source-code">    @GET("/users")</p><p class="source-code">    suspend fun getUsers(): List&lt;UserApiModel&gt;</p><p class="source-code">    @GET("/users/{userId}")</p><p class="source-code">    suspend fun getUser(@Path("userId") userId: Long): </p><p class="source-code">        UserApiModel</p><p class="source-code">}</p></li>
				<li>In <a id="_idIndexMarker488"/>the <strong class="source-inline">networking</strong> package, create a new package called <strong class="source-inline">post</strong>.</li>
				<li>In the <strong class="source-inline">post</strong> package, create a new class called <strong class="source-inline">PostApiModel</strong>:<p class="source-code">data class PostApiModel(</p><p class="source-code">    @Json(name = "id") val id: Long,</p><p class="source-code">    @Json(name = "userId") val userId: Long,</p><p class="source-code">    @Json(name = "title") val title: String,</p><p class="source-code">    @Json(name = "body") val body: String</p><p class="source-code">)</p></li>
				<li>In the same package, create a new interface called <strong class="source-inline">PostService</strong>:<p class="source-code">interface PostService {</p><p class="source-code">    @GET("/posts")</p><p class="source-code">    suspend fun getPosts(): List&lt;PostApiModel&gt;</p><p class="source-code">    @GET("/posts/{postId}")</p><p class="source-code">    suspend fun getPost(@Path("postId") id: Long): </p><p class="source-code">        PostApiModel</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">data-remote</strong> module, create a new package called <strong class="source-inline">source</strong>.</li>
				<li>In <a id="_idIndexMarker489"/>the <strong class="source-inline">source</strong> package, create a new class called <strong class="source-inline">RemoteUserDataSourceImpl</strong>:<p class="source-code">class RemoteUserDataSourceImpl @Inject constructor(private val userService: UserService) :</p><p class="source-code">    RemoteUserDataSource {</p><p class="source-code">    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = flow {</p><p class="source-code">        emit(userService.getUsers())</p><p class="source-code">    }.map { users -&gt;</p><p class="source-code">        users.map { userApiModel -&gt;</p><p class="source-code">            convert(userApiModel)</p><p class="source-code">        }</p><p class="source-code">    }.catch {</p><p class="source-code">        throw UseCaseException.UserException(it)</p><p class="source-code">    }</p><p class="source-code">    override fun getUser(id: Long): Flow&lt;User&gt; = flow {</p><p class="source-code">        emit(userService.getUser(id))</p><p class="source-code">    }.map {</p><p class="source-code">        convert(it)</p><p class="source-code">    }.catch {</p><p class="source-code">        throw UseCaseException.UserException(it)</p><p class="source-code">    }</p><p class="source-code">    </p><p class="source-code">    private fun convert(userApiModel: UserApiModel) =</p><p class="source-code">        User(userApiModel.id, userApiModel.name, </p><p class="source-code">            userApiModel.username, userApiModel.email)</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we invoke the <strong class="source-inline">getUsers</strong> and <strong class="source-inline">getUser</strong> methods from <strong class="source-inline">UserService</strong> and then convert the <strong class="source-inline">UserApiModel</strong> objects to <strong class="source-inline">User</strong> objects to avoid the other layers<a id="_idIndexMarker490"/> depending on the networking-related data. The same principle applies to error handling. If there is a network error, such as an <strong class="source-inline">HTTP 404</strong> code, the exception will be <strong class="source-inline">HttpException</strong>, which is part of the Retrofit library.</p>
			<ol>
				<li value="18">In the <strong class="source-inline">source</strong> package, create a new class called <strong class="source-inline">RemotePostDataSourceImpl</strong>:<p class="source-code">class RemotePostDataSourceImpl @Inject constructor(private val postService: PostService) :</p><p class="source-code">    RemotePostDataSource {</p><p class="source-code">    </p><p class="source-code">    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = flow {</p><p class="source-code">        emit(postService.getPosts())</p><p class="source-code">    }.map { posts -&gt;</p><p class="source-code">        posts.map { postApiModel -&gt;</p><p class="source-code">            convert(postApiModel)</p><p class="source-code">        }</p><p class="source-code">    }.catch {</p><p class="source-code">        throw UseCaseException.PostException(it)</p><p class="source-code">    }</p><p class="source-code">    override fun getPost(id: Long): Flow&lt;Post&gt; = flow {</p><p class="source-code">        emit(postService.getPost(id))</p><p class="source-code">    }.map {</p><p class="source-code">        convert(it)</p><p class="source-code">    }.catch {</p><p class="source-code">        throw UseCaseException.PostException(it)</p><p class="source-code">    }</p><p class="source-code">    private fun convert(postApiModel: PostApiModel) =</p><p class="source-code">        Post(postApiModel.id, postApiModel.userId, </p><p class="source-code">            postApiModel.title, postApiModel.body)</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we<a id="_idIndexMarker491"/> follow the same principle as with the <strong class="source-inline">RemoteUserDataSourceImpl</strong> class.</p>
			<ol>
				<li value="19">In the <strong class="source-inline">data-remote</strong> module, create a new package called <strong class="source-inline">injection</strong>:</li>
				<li>In the <strong class="source-inline">injection</strong> package, create a new class called <strong class="source-inline">NetworkModule</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class NetworkModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideOkHttpClient(): OkHttpClient = </p><p class="source-code">        OkHttpClient</p><p class="source-code">        .Builder()</p><p class="source-code">        .readTimeout(15, TimeUnit.SECONDS)</p><p class="source-code">        .connectTimeout(15, TimeUnit.SECONDS)</p><p class="source-code">        .build()</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideMoshi(): Moshi = Moshi.Builder().add</p><p class="source-code">        (KotlinJsonAdapterFactory()).build()</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideRetrofit(okHttpClient: OkHttpClient, </p><p class="source-code">        moshi: Moshi): Retrofit = Retrofit.Builder()</p><p class="source-code">        .baseUrl</p><p class="source-code">             ("https://jsonplaceholder.typicode.com/")</p><p class="source-code">        .client(okHttpClient)</p><p class="source-code">        .addConverterFactory</p><p class="source-code">            (MoshiConverterFactory.create(moshi))</p><p class="source-code">        .build()</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUserService(retrofit: Retrofit): </p><p class="source-code">        UserService =</p><p class="source-code">        retrofit.create(UserService::class.java)</p><p class="source-code">    @Provides</p><p class="source-code">    fun providePostService(retrofit: Retrofit): </p><p class="source-code">        PostService =</p><p class="source-code">        retrofit.create(PostService::class.java)</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we provide the Retrofit and <strong class="source-inline">OkHttp</strong> dependencies required for networking. </p>
			<ol>
				<li value="21">In <a id="_idIndexMarker492"/>the <strong class="source-inline">injection</strong> package, create a class named <strong class="source-inline">RemoteDataSourceModule</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class RemoteDataSourceModule {</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindPostDataSource(postDataSourceImpl: RemotePostDataSourceImpl): RemotePostDataSource</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindUserDataSource</p><p class="source-code">        (userDataSourceImpl: </p><p class="source-code">            RemoteUserDataSourceImpl):</p><p class="source-code"> RemoteUserDataSource</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we use Hilt to bind the implementations from this module with the abstractions defined in the <strong class="source-inline">data-repository</strong> module.</p>
			<ol>
				<li value="22">To unit-test the code, we now need to create a new folder called <strong class="source-inline">resources</strong> in the <strong class="source-inline">test</strong> folder of the <strong class="source-inline">data-remote</strong> module.</li>
				<li>Inside the <strong class="source-inline">resources</strong> folder, create a folder called <strong class="source-inline">mockito-extensions</strong>; inside this folder, create a file named <strong class="source-inline">org.mockito.plugins.MockMaker</strong>; and inside this file, add the following text – <strong class="source-inline">mock-maker-inline</strong>.</li>
				<li>Create a test class named <strong class="source-inline">RemoteUserDataSourceImplTest</strong>, which will test the <a id="_idIndexMarker493"/>success scenarios for the methods inside <strong class="source-inline">RemoteUserDataSourceImpl</strong>:<p class="source-code">class RemoteUserDataSourceImplTest {</p><p class="source-code">    private val userService = mock&lt;UserService&gt;()</p><p class="source-code">    private val userDataSource = </p><p class="source-code">        RemoteUserDataSourceImpl(userService)</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUsers() = runBlockingTest {</p><p class="source-code">        val remoteUsers = listOf(UserApiModel(1, </p><p class="source-code">            "name", "username", "email"))</p><p class="source-code">        val expectedUsers = listOf(User(1, "name", </p><p class="source-code">            "username", "email"))</p><p class="source-code">        whenever(userService.getUsers()).</p><p class="source-code">            thenReturn(remoteUsers)</p><p class="source-code">        val result = userDataSource.getUsers().first()</p><p class="source-code">        Assert.assertEquals(expectedUsers, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUser() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        val remoteUser = UserApiModel(id, "name", </p><p class="source-code">            "username", "email")</p><p class="source-code">        val user = User(id, "name", "username", </p><p class="source-code">            "email")</p><p class="source-code">        whenever(userService.getUser(id))</p><p class="source-code">            .thenReturn(remoteUser)</p><p class="source-code">        val result = userDataSource.getUser(id).</p><p class="source-code">            first()</p><p class="source-code">        Assert.assertEquals(user, result)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are <a id="_idIndexMarker494"/>mocking the <strong class="source-inline">UserService</strong> interface and providing mock user data, which will then be obtained and converted by <strong class="source-inline">RemoteDataSourceImpl</strong>.</p>
			<ol>
				<li value="25">In the same test class, add the error scenarios:<p class="source-code">class RemoteUserDataSourceImplTest {</p><p class="source-code">    …</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUsersThrowsError() = runBlockingTest {</p><p class="source-code">        whenever(userService.getUsers()).thenThrow</p><p class="source-code">            (RuntimeException())</p><p class="source-code">        userDataSource.getUsers().catch {</p><p class="source-code">            Assert.assertTrue(it is UseCaseException.</p><p class="source-code">                UserException)</p><p class="source-code">        }.collect()</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUserThrowsError() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        whenever(userService.getUser(id)).thenThrow</p><p class="source-code">            (RuntimeException())</p><p class="source-code">        userDataSource.getUser(id).catch {</p><p class="source-code">            Assert.assertTrue(it is UseCaseException.</p><p class="source-code">                UserException)</p><p class="source-code">        }.collect()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are mocking an error that is thrown by <strong class="source-inline">UserService</strong>, which will then be converted by <strong class="source-inline">RemoteUserDataSourceImpl</strong> into <strong class="source-inline">UseCaseException.UserException</strong>.</p>
			<ol>
				<li value="26">Create a test class named <strong class="source-inline">RemotePostDataSourceImplTest</strong>, which will have similar<a id="_idIndexMarker495"/> test methods as <strong class="source-inline">RemoteUserDataSourceImplTest</strong> for posts:<p class="source-code">class RemotePostDataSourceImplTest {</p><p class="source-code">    private val postService = mock&lt;PostService&gt;()</p><p class="source-code">    private val postDataSource = </p><p class="source-code">        RemotePostDataSourceImpl(postService)</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPosts() = runBlockingTest {</p><p class="source-code">        val remotePosts = listOf(PostApiModel(1, 1, </p><p class="source-code">            "title", "body"))</p><p class="source-code">        val expectedPosts = listOf(Post(1, 1, "title", </p><p class="source-code">            "body"))</p><p class="source-code">        whenever(postService.getPosts()).thenReturn</p><p class="source-code">            (remotePosts)</p><p class="source-code">        val result = postDataSource.getPosts().first()</p><p class="source-code">        Assert.assertEquals(expectedPosts, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPost() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        val remotePost = PostApiModel(id, 1, "title", </p><p class="source-code">            "body")</p><p class="source-code">        val expectedPost = Post(id, 1, "title", </p><p class="source-code">            "body")</p><p class="source-code">        whenever(postService.getPost(id)).thenReturn</p><p class="source-code">            (remotePost)</p><p class="source-code">        val result = postDataSource.getPost(id).</p><p class="source-code">            first()</p><p class="source-code">        Assert.assertEquals(expectedPost, result)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are doing for posts what we did for users in <strong class="source-inline">RemoteUserDataSourceImplTest</strong>.</p>
			<ol>
				<li value="27">Add the <a id="_idIndexMarker496"/>error scenarios in <strong class="source-inline">RemotePostDataSourceImplTest</strong>:<p class="source-code">class RemotePostDataSourceImplTest {</p><p class="source-code">    …</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPostsThrowsError() = runBlockingTest {</p><p class="source-code">        whenever(postService.getPosts()).thenThrow</p><p class="source-code">            (RuntimeException())</p><p class="source-code">        postDataSource.getPosts().catch {</p><p class="source-code">            Assert.assertTrue(it is UseCaseException.</p><p class="source-code">                PostException)</p><p class="source-code">        }.collect()</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPostThrowsError() = runBlockingTest {</p><p class="source-code">        val id = 1L</p><p class="source-code">        whenever(postService.getPost(id)).thenThrow</p><p class="source-code">            (RuntimeException())</p><p class="source-code">        postDataSource.getPost(id).catch {</p><p class="source-code">            Assert.assertTrue(it is UseCaseException.</p><p class="source-code">                PostException)</p><p class="source-code">        }.collect()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>If we run the <a id="_idIndexMarker497"/>tests, we should see something like the following figure:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_7.02_B18320.jpg" alt="Figure 7.2 – Output of the remote data source unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Output of the remote data source unit tests</p>
			<p>In this exercise, we have added a new module to the application, in which we can see how we can add a remote data source to the application. To fetch the data, we are using libraries such as OkHttp and Retrofit and combining them with the data source implementation <a id="_idIndexMarker498"/>for fetch users and posts. In the following section, we will expand the application to introduce local data sources, in which we will persist the data we are fetching here.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor086"/>Building and integrating local data sources</h1>
			<p>In this section, we<a id="_idIndexMarker499"/> will<a id="_idIndexMarker500"/> analyze how we can build local data sources and integrate them with libraries such as Room and Data Store.</p>
			<p>Local data sources have a similar structure to remote data sources. The abstractions are provided by the layers sitting above, and the implementations are responsible for invoking methods from persistence frameworks and converting data into entities, like the following figure:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_7.03_B18320.jpg" alt="Figure 7.3 – A local data source diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – A local data source diagram</p>
			<p>Let's assume <a id="_idIndexMarker501"/>we<a id="_idIndexMarker502"/> have the same <strong class="source-inline">UserEntity</strong> defined in the previous chapters:</p>
			<p class="source-code">data class User(</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    val firstName: String,</p>
			<p class="source-code">    val lastName: String,</p>
			<p class="source-code">    val email: String</p>
			<p class="source-code">) {</p>
			<p class="source-code">    fun getFullName() = "$firstName $lastName"</p>
			<p class="source-code">}</p>
			<p>Let's make <a id="_idIndexMarker503"/>the <a id="_idIndexMarker504"/>same assumption about <strong class="source-inline">UserLocalDataSource</strong>:</p>
			<p class="source-code">interface UserLocalDataSource {</p>
			<p class="source-code">    suspend fun insertUser(user: User)</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;User&gt;</p>
			<p class="source-code">}</p>
			<p>We now need to provide an implementation for this data source that will manipulate the data from Room. First, we need to define a user entity for Room:</p>
			<p class="source-code">@Entity(tableName = "user")</p>
			<p class="source-code">data class UserEntity(</p>
			<p class="source-code">    @PrimaryKey @ColumnInfo(name = "id") val id: String,</p>
			<p class="source-code">    @ColumnInfo(name = "first_name") val firstName: String,</p>
			<p class="source-code">    @ColumnInfo(name = "last_name") val lastName: String,</p>
			<p class="source-code">    @ColumnInfo(name = "email") val email: String</p>
			<p class="source-code">)</p>
			<p>Now, we can define <strong class="source-inline">UserDao</strong>, which queries a user by an ID and inserts a user:</p>
			<p class="source-code">@Dao</p>
			<p class="source-code">interface UserDao {</p>
			<p class="source-code">    @Query("SELECT * FROM user where id = :id")</p>
			<p class="source-code">    fun getUser(id: String): Flow&lt;UserEntity&gt;</p>
			<p class="source-code">    @Insert(onConflict = OnConflictStrategy.REPLACE)</p>
			<p class="source-code">    fun insertUser(users: UserEntity)</p>
			<p class="source-code">}</p>
			<p>Finally, the <a id="_idIndexMarker505"/>implementation of the data source looks like <a id="_idIndexMarker506"/>this:</p>
			<p class="source-code">class UserLocalDataSourceImpl(private val userDao: UserDao) : UserLocalDataSource {</p>
			<p class="source-code">    override suspend fun insertUser(user: User) {</p>
			<p class="source-code">        userDao.insertUser(UserEntity(user.id, </p>
			<p class="source-code">            user.firstName, user.lastName, user.email))</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; {</p>
			<p class="source-code">        return userDao.getUser(id).map {</p>
			<p class="source-code">            User(it.id, it.firstName, it.lastName, </p>
			<p class="source-code">                it.email)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, the local data source invokes <strong class="source-inline">UserDao</strong> to insert and retrieve a user and converts the domain entity into a Room entity. </p>
			<p>If we want to use Data Store instead of Room with a local data store implementation, we can<a id="_idIndexMarker507"/> have<a id="_idIndexMarker508"/> something like the following example:</p>
			<p class="source-code">private val KEY_ID = stringPreferencesKey("key_id")</p>
			<p class="source-code">private val KEY_FIRST_NAME = </p>
			<p class="source-code">    stringPreferencesKey("key_first_name")</p>
			<p class="source-code">private val KEY_LAST_NAME = </p>
			<p class="source-code">    stringPreferencesKey("key_last_name")</p>
			<p class="source-code">private val KEY_EMAIL = stringPreferencesKey("key_email")</p>
			<p class="source-code">class UserLocalDataSourceImpl(private val dataStore: </p>
			<p class="source-code">    DataStore&lt;Preferences&gt;) : UserLocalDataSource {</p>
			<p class="source-code">    override suspend fun insertUser(user: User) {</p>
			<p class="source-code">        dataStore.edit {</p>
			<p class="source-code">            it[KEY_ID] = user.id</p>
			<p class="source-code">            it[KEY_FIRST_NAME] = user.firstName</p>
			<p class="source-code">            it[KEY_LAST_NAME] = user.lastName</p>
			<p class="source-code">            it[KEY_EMAIL] = user.email</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun getUser(id: String): Flow&lt;User&gt; {</p>
			<p class="source-code">        return dataStore.data.map {</p>
			<p class="source-code">            User(</p>
			<p class="source-code">                it[KEY_ID].orEmpty(),</p>
			<p class="source-code">                it[KEY_FIRST_NAME].orEmpty(),</p>
			<p class="source-code">                it[KEY_LAST_NAME].orEmpty(),</p>
			<p class="source-code">                it[KEY_EMAIL].orEmpty()</p>
			<p class="source-code">            )</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we use a key for each of the fields of the <strong class="source-inline">User</strong> object to store the data. The <strong class="source-inline">getUser</strong> method doesn't use the ID to search for a user, which shows that for this particular use case, Room is the more appropriate method. </p>
			<p>In this section, we looked at how we can build a local data source with the help of the Room and<a id="_idIndexMarker509"/> Data<a id="_idIndexMarker510"/> Store libraries to be able to query and persist data locally on a device. Next, we will look at an exercise to show how we can implement a local data store.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/>Exercise 07.02 – Building a local data source</h2>
			<p>Modify <em class="italic">Exercise 07.01 – Building a remote data source</em> so that a new Android library module <a id="_idIndexMarker511"/>named <strong class="source-inline">data-local</strong> is created. This module will depend on <strong class="source-inline">domain</strong> and <strong class="source-inline">data-repository</strong>. </p>
			<p>The module will implement the following:</p>
			<ul>
				<li><strong class="source-inline">UserEntity</strong> and <strong class="source-inline">PostEntity</strong>, which will hold data to be persisted from <strong class="source-inline">User</strong> and <strong class="source-inline">Post</strong> using Room</li>
				<li><strong class="source-inline">UserDao</strong> and <strong class="source-inline">PostDao</strong>, which will be responsible for persisting and fetching a list of <strong class="source-inline">UserEntity</strong> and <strong class="source-inline">PostEntity</strong></li>
				<li><strong class="source-inline">LocalUserDataSourceImpl</strong> and <strong class="source-inline">LocalPostDataSourceImpl</strong>, which will be responsible for invoking the <strong class="source-inline">UserDao</strong> and <strong class="source-inline">PostDao</strong> objects to persist data and for converting data to <strong class="source-inline">User</strong> and <strong class="source-inline">Post</strong> objects</li>
				<li><strong class="source-inline">LocalInteractionDataSourceImpl</strong>, which will be responsible for persisting the <strong class="source-inline">Interaction</strong> object</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">data-local</strong> module.</li>
				<li>Create the <strong class="source-inline">UserEntity</strong> and <strong class="source-inline">PostEntity</strong> classes.</li>
				<li>Create the DAOs for users and posts.</li>
				<li>Create the data source implementations.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create <a id="_idIndexMarker512"/>a new module named <strong class="source-inline">data-local</strong>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <strong class="source-inline">build.gradle</strong> file, the following dependencies are set:<p class="source-code">buildscript {</p><p class="source-code">     …</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath gradlePlugins.android</p><p class="source-code">        classpath gradlePlugins.kotlin</p><p class="source-code">        classpath gradlePlugins.hilt</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add the persistence libraries to the library mappings:<p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        versions = [</p><p class="source-code">                …</p><p class="source-code">                room               : "2.4.0",</p><p class="source-code">                datastore          : "1.0.0",</p><p class="source-code">                …</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">        persistence = [</p><p class="source-code">                roomRuntime : "androidx.room:room-</p><p class="source-code">                    runtime:${versions.room}",</p><p class="source-code">                roomKtx     : "androidx.room:room-</p><p class="source-code">                     ktx:${versions.room}",</p><p class="source-code">                roomCompiler: "androidx.room:room-</p><p class="source-code">                    compiler:${versions.room}",</p><p class="source-code">                datastore   : "androidx.datastore:</p><p class="source-code">                    datastore-preferences:$</p><p class="source-code">                       {versions.datastore}"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">    }</p></li>
				<li>In <a id="_idIndexMarker513"/>the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">data-local</strong> module, make sure that the following plugins are present:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, change<a id="_idIndexMarker514"/> the configurations to the ones defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add the dependencies to the networking libraries and the <strong class="source-inline">data-repository</strong> and <strong class="source-inline">domain</strong> modules:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation(project(path: ":data-repository"))</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    implementation persistence.roomRuntime</p><p class="source-code">    implementation persistence.roomKtx</p><p class="source-code">    kapt persistence.roomCompiler</p><p class="source-code">    implementation persistence.datastore</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">data-local</strong> module, create a new package called <strong class="source-inline">db</strong>.</li>
				<li>In the <strong class="source-inline">db</strong> package, create<a id="_idIndexMarker515"/> a new package called <strong class="source-inline">user</strong>.</li>
				<li>In the <strong class="source-inline">user</strong> package, create the <strong class="source-inline">UserEntity</strong> class:<p class="source-code">@Entity(tableName = "user")</p><p class="source-code">data class UserEntity(</p><p class="source-code">    @PrimaryKey @ColumnInfo(name = "id") val id: Long,</p><p class="source-code">    @ColumnInfo(name = "name") val name: String,</p><p class="source-code">    @ColumnInfo(name = "username") val username: </p><p class="source-code">        String,</p><p class="source-code">    @ColumnInfo(name = "email") val email: String</p><p class="source-code">)</p></li>
				<li>In the same package, create the <strong class="source-inline">UserDao</strong> interface:<p class="source-code">@Dao</p><p class="source-code">interface UserDao {</p><p class="source-code">    @Query("SELECT * FROM user")</p><p class="source-code">    fun getUsers(): Flow&lt;List&lt;UserEntity&gt;&gt;</p><p class="source-code">    @Insert(onConflict = OnConflictStrategy.REPLACE)</p><p class="source-code">    fun insertUsers(users: List&lt;UserEntity&gt;)</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">db</strong> package, create a new package called <strong class="source-inline">post</strong>.</li>
				<li>In the <strong class="source-inline">post</strong> package, create<a id="_idIndexMarker516"/> a new class called <strong class="source-inline">PostEntity</strong>:<p class="source-code">@Entity(tableName = "post")</p><p class="source-code">data class PostEntity(</p><p class="source-code">    @PrimaryKey @ColumnInfo(name = "id") val id: Long,</p><p class="source-code">    @ColumnInfo(name = "userId") val userId: Long,</p><p class="source-code">    @ColumnInfo(name = "title") val title: String,</p><p class="source-code">    @ColumnInfo(name = "body") val body: String</p><p class="source-code">)</p></li>
				<li>In the same package, create a new interface called <strong class="source-inline">PostDao</strong>:<p class="source-code">@Dao</p><p class="source-code">interface PostDao {</p><p class="source-code">    @Query("SELECT * FROM post")</p><p class="source-code">    fun getPosts(): Flow&lt;List&lt;PostEntity&gt;&gt;</p><p class="source-code">    @Insert(onConflict = OnConflictStrategy.REPLACE)</p><p class="source-code">    fun insertPosts(users: List&lt;PostEntity&gt;)</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">db</strong> package, create the <strong class="source-inline">AppDatabase</strong> class:<p class="source-code">@Database(entities = [UserEntity::class, PostEntity::class], version = 1)</p><p class="source-code">abstract class AppDatabase : RoomDatabase() {</p><p class="source-code">    abstract fun userDao(): UserDao</p><p class="source-code">    abstract fun postDao(): PostDao</p><p class="source-code">}</p></li>
				<li>In<a id="_idIndexMarker517"/> the <strong class="source-inline">data-local</strong> module, create a new package called <strong class="source-inline">source</strong>.</li>
				<li>In the <strong class="source-inline">source</strong> package, create a new class called <strong class="source-inline">LocalUserDataSourceImpl</strong>:<p class="source-code">class LocalUserDataSourceImpl @Inject constructor(private val userDao: UserDao) :</p><p class="source-code">    LocalUserDataSource {</p><p class="source-code">    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = </p><p class="source-code">        userDao.getUsers().map { users -&gt;</p><p class="source-code">        users.map {</p><p class="source-code">            User(it.id, it.name, it.username, </p><p class="source-code">                it.email)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override suspend fun addUsers(users: List&lt;User&gt;) = </p><p class="source-code">        userDao.insertUsers(users.map {</p><p class="source-code">        UserEntity(it.id, it.name, it.username, </p><p class="source-code">            it.email)</p><p class="source-code">    })</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, in the <strong class="source-inline">getUsers</strong> method, we retrieve a list of <strong class="source-inline">UserEntity</strong> objects from <strong class="source-inline">UserDao</strong> and convert them into <strong class="source-inline">User</strong> objects. In the <strong class="source-inline">addUsers</strong> method, we do the opposite, by taking a list of <strong class="source-inline">User</strong> objects to be inserted and converting them into <strong class="source-inline">UserEntity</strong> objects.</p>
			<ol>
				<li value="17">In the same<a id="_idIndexMarker518"/> package, create the <strong class="source-inline">LocalPostDataSourceImpl</strong> class:<p class="source-code">class LocalPostDataSourceImpl @Inject constructor(private val postDao: PostDao) :</p><p class="source-code">    LocalPostDataSource {</p><p class="source-code">    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = </p><p class="source-code">       postDao.getPosts().map { posts -&gt;</p><p class="source-code">        posts.map {</p><p class="source-code">            Post(it.id, it.userId, it.title, it.body)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override suspend fun addPosts(posts: List&lt;Post&gt;) = </p><p class="source-code">        postDao.insertPosts(posts.map {</p><p class="source-code">        PostEntity(it.id, it.userId, it.title, </p><p class="source-code">            it.body)</p><p class="source-code">    })</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we follow the same approach we used for <strong class="source-inline">LocalUserDataSourceImpl</strong>.</p>
			<ol>
				<li value="18">In the same<a id="_idIndexMarker519"/> package, create the <strong class="source-inline">LocalInteractionDataSourceImpl</strong> class:<p class="source-code">internal val KEY_TOTAL_TAPS = intPreferencesKey("key_total_taps")</p><p class="source-code">class LocalInteractionDataSourceImpl @Inject constructor(private val dataStore: DataStore&lt;Preferences&gt;) :</p><p class="source-code">    LocalInteractionDataSource {</p><p class="source-code">    override fun getInteraction(): Flow&lt;Interaction&gt; {</p><p class="source-code">        return dataStore.data.map {</p><p class="source-code">            Interaction(it[KEY_TOTAL_TAPS] ?: 0)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override suspend fun saveInteraction(interaction: </p><p class="source-code">        Interaction) {</p><p class="source-code">        dataStore.edit {</p><p class="source-code">            it[KEY_TOTAL_TAPS] = </p><p class="source-code">                interaction.totalClicks</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we use the Preference Data Store library to persist the Interaction object, by holding different keys for each field in the <strong class="source-inline">Interaction</strong> class, and in this case, it will be just one key for the total clicks.</p>
			<ol>
				<li value="19">In the <strong class="source-inline">data-local</strong> module, create a new package named <strong class="source-inline">injection</strong>.</li>
				<li>In <a id="_idIndexMarker520"/>the <strong class="source-inline">injection</strong> package, create a new class named <strong class="source-inline">PersistenceModule</strong>:<p class="source-code">val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "my_preferences")</p><p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class PersistenceModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideAppDatabase(@ApplicationContext </p><p class="source-code">        context: Context): AppDatabase =</p><p class="source-code">        Room.databaseBuilder(</p><p class="source-code">            context,</p><p class="source-code">            AppDatabase::class.java, "my-database"</p><p class="source-code">        ).build()</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUserDao(appDatabase: AppDatabase): </p><p class="source-code">        UserDao = appDatabase.userDao()</p><p class="source-code">    @Provides</p><p class="source-code">    fun providePostDao(appDatabase: AppDatabase): </p><p class="source-code">        PostDao = appDatabase.postDao()</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideLocalInteractionDataSourceImpl</p><p class="source-code">        (@ApplicationContext context: Context) =</p><p class="source-code">        LocalInteractionDataSourceImpl(context.dataStore)</p><p class="source-code">} </p></li>
			</ol>
			<p>Here, we provide all the Data Store and Room dependencies.</p>
			<ol>
				<li value="21">In the same <a id="_idIndexMarker521"/>package, create a new class called <strong class="source-inline">LocalDataSourceModule</strong>, in which we connect the abstractions to the bindings:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class LocalDataSourceModule {</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindPostDataSource</p><p class="source-code">       (lostDataSourceImpl: LocalPostDataSourceImpl): </p><p class="source-code">           LocalPostDataSource</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindUserDataSource</p><p class="source-code">        (userDataSourceImpl: LocalUserDataSourceImpl): </p><p class="source-code">            LocalUserDataSource</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindInteractionDataStore</p><p class="source-code">        (interactionDataStore:LocalInteractionData</p><p class="source-code">            SourceImpl): LocalInteractionDataSource</p><p class="source-code">}</p></li>
				<li>To unit-test the code, we will now need to create a new folder called <strong class="source-inline">resources</strong> in the test folder of the <strong class="source-inline">data-local</strong> module.</li>
				<li>Inside the <strong class="source-inline">resources</strong> folder, create a folder called <strong class="source-inline">mockito-extensions</strong>; inside <a id="_idIndexMarker522"/>this folder, create a file named <strong class="source-inline">org.mockito.plugins.MockMaker</strong>; and inside this file, add the following text – <strong class="source-inline">mock-maker-inline</strong>.</li>
				<li>Create the <strong class="source-inline">LocalUserDataSourceImplTest</strong> test class:<p class="source-code">class LocalUserDataSourceImplTest {</p><p class="source-code">    private val userDao = mock&lt;UserDao&gt;()</p><p class="source-code">    private val userDataSource = </p><p class="source-code">        LocalUserDataSourceImpl(userDao)</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetUsers() = runBlockingTest {</p><p class="source-code">        val localUsers = listOf(UserEntity(1, "name", </p><p class="source-code">            "username", "email"))</p><p class="source-code">        val expectedUsers = listOf(User(1, "name", </p><p class="source-code">            "username", "email"))</p><p class="source-code">        whenever(userDao.getUsers()).thenReturn</p><p class="source-code">            (flowOf(localUsers))</p><p class="source-code">        val result = userDataSource.getUsers().first()</p><p class="source-code">        Assert.assertEquals(expectedUsers, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testAddUsers() = runBlockingTest {</p><p class="source-code">        val localUsers = listOf(UserEntity(1, "name", </p><p class="source-code">            "username", "email"))</p><p class="source-code">        val users = listOf(User(1, "name", "username", </p><p class="source-code">            "email"))</p><p class="source-code">        userDataSource.addUsers(users)</p><p class="source-code">        verify(userDao).insertUsers(localUsers)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are<a id="_idIndexMarker523"/> mocking the <strong class="source-inline">UserDao</strong> class and using it to provide mock data to <strong class="source-inline">LocalUserDataSourceImpl</strong>, which will then convert the data to and from the <strong class="source-inline">User</strong> objects.</p>
			<ol>
				<li value="25">Create the <strong class="source-inline">LocalPostDataSourceImplTest</strong> test class:<p class="source-code">class LocalPostDataSourceImplTest {</p><p class="source-code">    private val postDao = mock&lt;PostDao&gt;()</p><p class="source-code">    private val postDataSource = </p><p class="source-code">        LocalPostDataSourceImpl(postDao)</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetPosts() = runBlockingTest {</p><p class="source-code">        val localPosts = listOf(PostEntity(1, 1, </p><p class="source-code">            "title", "body"))</p><p class="source-code">        val expectedPosts = listOf(Post(1, 1, "title", </p><p class="source-code">            "body"))</p><p class="source-code">        whenever(postDao.getPosts()).thenReturn</p><p class="source-code">            (flowOf(localPosts))</p><p class="source-code">        val result = postDataSource.getPosts().first()</p><p class="source-code">        Assert.assertEquals(expectedPosts, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testAddUsers() = runBlockingTest {</p><p class="source-code">        val localPosts = listOf(PostEntity(1, 1, </p><p class="source-code">            "title", "body"))</p><p class="source-code">        val posts = listOf(Post(1, 1, "title", </p><p class="source-code">            "body"))</p><p class="source-code">        postDataSource.addPosts(posts)</p><p class="source-code">        verify(postDao).insertPosts(localPosts)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we perform the same type of tests for posts as we did in <strong class="source-inline">LocalUserDataSourceImplTest</strong> for users.</p>
			<ol>
				<li value="26">Create <a id="_idIndexMarker524"/>the <strong class="source-inline">LocalInteractionDataSourceImplTest</strong> test class:<p class="source-code">class LocalInteractionDataSourceImplTest {</p><p class="source-code">    private val dataStore = mock&lt;DataStore</p><p class="source-code">        &lt;Preferences&gt;&gt;()</p><p class="source-code">    private val interactionDataSource = </p><p class="source-code">        LocalInteractionDataSourceImpl(dataStore)</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testGetInteraction() = runBlockingTest {</p><p class="source-code">        val clicks = 10</p><p class="source-code">        val interaction = Interaction(clicks)</p><p class="source-code">        val preferences = mock&lt;Preferences&gt;()</p><p class="source-code">        whenever(preferences[KEY_TOTAL_TAPS]).</p><p class="source-code">            thenReturn(clicks)</p><p class="source-code">        whenever(dataStore.data).thenReturn</p><p class="source-code">            (flowOf(preferences))</p><p class="source-code">        val result = interactionDataSource.</p><p class="source-code">            getInteraction().first()</p><p class="source-code">        assertEquals(interaction, result)</p><p class="source-code">    }</p><p class="source-code">    @ExperimentalCoroutinesApi</p><p class="source-code">    @Test</p><p class="source-code">    fun testSaveInteraction() = runBlockingTest {</p><p class="source-code">        val clicks = 10</p><p class="source-code">        val interaction = Interaction(clicks)</p><p class="source-code">        val preferences = mock&lt;MutablePreferences&gt;()</p><p class="source-code">        whenever(preferences.toMutablePreferences())</p><p class="source-code">            .thenReturn(preferences)</p><p class="source-code">        whenever(dataStore.updateData(any())).</p><p class="source-code">            thenAnswer {</p><p class="source-code">            runBlocking {</p><p class="source-code">                it.getArgument&lt;suspend (Preferences) -</p><p class="source-code">                 &gt; Preferences&gt;(0).invoke(preferences)</p><p class="source-code">            }</p><p class="source-code">            preferences</p><p class="source-code">        }</p><p class="source-code">        interactionDataSource.saveInteraction(interaction)</p><p class="source-code">        verify(preferences)[KEY_TOTAL_TAPS] = clicks</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, in the <strong class="source-inline">testSaveInteraction</strong> method, we need to mock the <strong class="source-inline">updateData</strong> method instead of the <strong class="source-inline">edit</strong> method from the <strong class="source-inline">DataStore</strong> class. This is because the <strong class="source-inline">edit</strong> method is an extension function that can't be mocked with the current libraries we have and instead must rely on the method it invokes, which is <strong class="source-inline">updateData</strong>. </p>
			<p>If we run the tests, we <a id="_idIndexMarker525"/>should see something like the following figure:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_7.04_B18320.jpg" alt="Figure 7.4 – Output of the local data source unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Output of the local data source unit tests</p>
			<p>If we draw a diagram of the modules in the exercise, we will see something like the following figure:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_7.05_B18320.jpg" alt="Figure 7.5 – The exercise 07.02 module diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – The exercise 07.02 module diagram</p>
			<p>We can see<a id="_idIndexMarker526"/> that the <strong class="source-inline">:data-remote</strong> and <strong class="source-inline">:data-local</strong> modules are isolated from each other. The two modules have different responsibilities and deal with different dependencies. <strong class="source-inline">:data-remote</strong> deals with fetching data from the internet, while <strong class="source-inline">:data-local</strong> deals with persisting data locally into SQLite using Room and files using Data Store. This gives our code more flexibility because we are able to change how we fetch data – for example, without impacting how we persist the data.</p>
			<p>In this exercise, we have created a new module in the application in which we deal with local data sources. To persist data, we have used libraries such as Room and Data Store, and we have<a id="_idIndexMarker527"/> integrated them with the local data store.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor088"/>Summary </h1>
			<p>In this chapter, we looked at the concept of data sources and the different types of data sources we have available in an Android application. We started with remote data sources and saw some examples of how we can build a data source and combine it with libraries such as Retrofit and OkHttp. The local data source followed similar principles as the remote one, and here, we have used libraries such as Room and Data Store to implement this. </p>
			<p>In the exercises, we implemented the data sources as part of different modules. This was to avoid creating any unnecessary dependencies between the other layers of the application and the specific frameworks we have used for the data sources. In the next chapter, we will look at how we can build the presentation layer and show data to the user. We will also explore how we can split the presentation layer into separate modules and navigate from a screen in one module to a screen in another module, through the introduction of modules that can be shared by other presentation modules.</p>
		</div>
	</body></html>