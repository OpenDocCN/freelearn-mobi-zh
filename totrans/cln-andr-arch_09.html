<html><head></head><body>
		<div><h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor082"/>Chapter 7</em>: Building Data Sources</h1>
			<p>In this chapter, we will continue focusing on the data layer by discussing how we can implement local and remote data sources and the roles they play in clean architecture. First, we will look at how remote data sources can be built and how they can fetch data from the internet through calls to Retrofit. Then, we will look at implementing local data sources and how they can interact with Room and Data Store to persist data locally. In the chapter's exercises, we will continue the previous exercises and add the data sources discussed in the chapter, seeing how we can connect them to Room and Retrofit.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Building and using remote data sources</li>
				<li>Building and integrating local data sources</li>
			</ul>
			<p>By the end of the chapter, you will have learned the role of data sources, how to implement remote and local data sources that use Retrofit, Room, and Data Store to manage an application's data, and how we can separate these data sources in separate library modules.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio – Arctic Fox | 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter7">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter7</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3yOa7jE">https://bit.ly/3yOa7jE</a></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor084"/>Building and using remote data sources</h1>
			<p>In this <a id="_idIndexMarker474"/>section, we <a id="_idIndexMarker475"/>will look at how we can build remote data sources and how we can use them in combination with Retrofit to fetch and manipulate data from the internet.</p>
			<p>In the previous chapters, we defined abstractions for data sources that repositories depend on to manipulate data. This was because we wanted to avoid the repositories having dependencies on the data sources and instead have the data sources depend on the repositories. For remote data sources, this looks something like the following figure:</p>
			<div><div><img src="img/Figure_7.01_B18320.jpg" alt="Figure 7.1 – A remote data source class diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A remote data source class diagram</p>
			<p>The implementation <a id="_idIndexMarker476"/>of the remote data source has two roles. It <a id="_idIndexMarker477"/>will invoke the networking layer to fetch and manipulate data, and it will convert the data to either the domain entity or, if necessary, intermediary data required by the repository.  </p>
			<p>Let's look at the entity defined in the previous chapters:</p>
			<pre>data class User(
    val id: String,
    val firstName: String,
    val lastName: String,
    val email: String
) {
    fun getFullName() = "$firstName $lastName"
}</pre>
			<p>Here, we have the same <code>User</code> data class that was defined as part of the domain. Now let's assume<a id="_idIndexMarker478"/> we <a id="_idIndexMarker479"/>are fetching the following data from the internet in JSON format:</p>
			<pre>data class UserApiModel(
    @Json(name = "id") val id: String,
    @Json(name = "first_name") val firstName: String,
    @Json(name = "last_name") val lastName: String,
    @Json(name = "email") val email: String
)</pre>
			<p>Here, we have a <code>UserApiModel</code> class in which we define the same fields as the <code>User</code> class and annotate them with the <code>@Json</code> annotation, which is part of the Moshi library. </p>
			<p>The remote data source abstraction looks like the following:</p>
			<pre>interface UserRemoteDataSource {
    fun getUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>This is the abstraction we defined in the previous chapter. Before we write the implementation of this class, we will first need to specify our Retrofit service:</p>
			<pre>interface UserService {
    @GET("/users/{userId}")
    suspend fun getUser(@Path("userId") userId: String): 
        UserApiModel
}</pre>
			<p>This is a typical Retrofit service class, which will fetch an <code>UserApiModel</code> class from the <code>/users/{userId}</code> endpoint. We can now create the implementation of the data source to<a id="_idIndexMarker480"/> fetch<a id="_idIndexMarker481"/> the user from <code>UserService</code>:</p>
			<pre>data class UserRemoteDataSourceImpl(private val userService: UserService) : UserRemoteDataSource {
    override fun getUser(id: String): Flow&lt;User&gt; {
        return flow {
            emit(userService.getUser(id))
        }.map {
            User(it.id, it.firstName, it.lastName,
                it.email)
        }
    }
}</pre>
			<p>Here, we implement the <code>UserRemoteDataSource</code> interface, and in the <code>getUser</code> method, we invoke the <code>getUser</code> method from the <code>UserService</code> dependency. Once <code>UserApiModel</code> is obtained, we then convert it to the <code>User</code> class. </p>
			<p>In this section, we looked at how we can build a remote data source with the help of the Retrofit library to manipulate data from the internet. In the section that follows, we will look at an exercise that shows how we can implement a remote data source.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Exercise 07.01 – Building a remote data source  </h2>
			<p>Modify <em class="italic">Exercise 06.01 – Creating repositories</em> so that a new library module is created in <a id="_idIndexMarker482"/>Android Studio. Name the module <code>data-remote</code>. This module will depend on <code>domain</code> and <code>data-repository</code>. The module will be responsible for fetching users and posts as JSON from <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a>.</p>
			<p>The user will have the following JSON representation:</p>
			<pre>{
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz"
}</pre>
			<p>The post will have the following JSON representation:</p>
			<pre>{
    "userId": 1,
    "id": 1,
    "title": "sunt aut facere repellat provident 
        occaecati excepturi optio reprehenderit",
    "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
}</pre>
			<p>The module will need to implement the following:</p>
			<ul>
				<li><code>UserApiModel</code> and <code>PostApiModel</code>, which will hold the data from the JSON.</li>
				<li><code>UserService</code>, which will return a list of <code>UserApiModel</code> from the <code>/users</code> URL and <code>UserApiModel</code> based on the ID from the <code>/users/{userId}</code> URL.</li>
				<li><code>PostService</code>, which will return a list of <code>PostApiModel</code> from the <code>/posts</code> URL and <code>PostApiModel</code> based on the ID from the <code>/post/{postId}</code> URL.</li>
				<li><code>RemoteUserDataSourceImpl</code>, which will implement <code>RemoteUserDataSource</code>, call <code>UserService</code>, and return <code>Flow</code>, which emits a list of <code>User</code> objects or <code>UseCaseException.UserException</code> if there is an error in the call to <code>UserService</code>. The same approach will be taken for returning <code>User</code> based on the ID.</li>
				<li><code>RemotePostDataSourceImpl</code> which will implement <code>RemotePostDataSource</code>, call <code>PostService</code>, and return <code>Flow</code>, which emits a list<a id="_idIndexMarker483"/> of <code>Post</code> objects or <code>UseCaseException.PostException</code> if there is an error in the call to <code>PostService</code>. The same approach will be taken for returning a post based on the ID.</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li>Create the <code>data-remote</code> module.</li>
				<li>Create the <code>UserApiModel</code> and <code>UserService</code> classes.</li>
				<li>Create the <code>PostApiModel</code> and <code>PostService</code> classes.</li>
				<li>Create the remote data sources implementations for <code>RemoteUserDataSource</code> and <code>RemotePostDataSource</code>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create a new module named <code>data-remote</code>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <code>build.gradle</code> file, the following dependencies are set:<pre>buildscript {
     …
    dependencies {
        classpath gradlePlugins.android
        classpath gradlePlugins.kotlin
        classpath gradlePlugins.hilt
    }
}</pre></li>
				<li>In the same file, add<a id="_idIndexMarker484"/> the networking libraries to the library mappings:<pre>    ext {
        …
        versions = [
                …
                okHttp             : "4.9.0",
                retrofit           : "2.9.0",
                moshi              : "1.13.0",
                …
        ]
        …
        network = [
                okHttp       : "com.squareup.okhttp3:
                    okhttp:${versions.okHttp}",
                retrofit     : "com.squareup.retrofit2
                    :retrofit:${versions.retrofit}",
                retrofitMoshi: "com.squareup.retrofit2
                    :converter-moshi:$
                        {versions.retrofit}",
                moshi        : "com.squareup.moshi:
                    moshi:${versions.moshi}",
                moshiKotlin  : "com.squareup.moshi:
                    moshi-kotlin:${versions.moshi}"
        ]
        …
    }</pre></li>
				<li>In <a id="_idIndexMarker485"/>the <code>build.gradle</code> file of the <code>data-remote</code> module, make sure that the following plugins are present:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, change the configurations to the ones defined in the top-level <code>build.gradle</code> file:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        …
    }
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
    }
}</pre></li>
			</ol>
			<p>Here, we are making sure that the new module will use the same configurations with regards to<a id="_idIndexMarker486"/> compilation and the minimum and maximum Android version as the rest of the project, making it easier to change the configuration across all the modules.</p>
			<ol>
				<li value="6">In the same file, add the dependencies to the networking libraries and the <code>data-repository</code> and <code>domain</code> modules:<pre>dependencies {
    implementation(project(path: ":domain"))
    implementation(project(path: ":data-repository"))
    implementation coroutines.coroutinesAndroid
    implementation network.okHttp
    implementation network.retrofit
    implementation network.retrofitMoshi
    implementation network.moshi
    implementation network.moshiKotlin
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>In the top-level <code>gradle.properties</code>, add the following configuration for <code>moshi</code>:<pre>android.jetifier.ignorelist=moshi-1.13.0</pre></li>
				<li>In the <code>AndroidManifest.xml</code> file in the <code>data-remote</code> module, add the internet <a id="_idIndexMarker487"/>permission:<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.clean.data_remote"&gt;
    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;/manifest&gt;</pre></li>
				<li>In the <code>data-remote</code> module, create a new package called <code>networking</code>.</li>
				<li>In the <code>networking</code> package, create a new package called <code>user</code>.</li>
				<li>In the <code>user</code> package, create a new class called <code>UserApiModel</code>:<pre>data class UserApiModel(
    @Json(name = "id") val id: Long,
    @Json(name = "name") val name: String,
    @Json(name = "username") val username: String,
    @Json(name = "email") val email: String
)</pre></li>
				<li>In the same package, create a new interface called <code>UserService</code>:<pre>interface UserService {
    @GET("/users")
    suspend fun getUsers(): List&lt;UserApiModel&gt;
    @GET("/users/{userId}")
    suspend fun getUser(@Path("userId") userId: Long): 
        UserApiModel
}</pre></li>
				<li>In <a id="_idIndexMarker488"/>the <code>networking</code> package, create a new package called <code>post</code>.</li>
				<li>In the <code>post</code> package, create a new class called <code>PostApiModel</code>:<pre>data class PostApiModel(
    @Json(name = "id") val id: Long,
    @Json(name = "userId") val userId: Long,
    @Json(name = "title") val title: String,
    @Json(name = "body") val body: String
)</pre></li>
				<li>In the same package, create a new interface called <code>PostService</code>:<pre>interface PostService {
    @GET("/posts")
    suspend fun getPosts(): List&lt;PostApiModel&gt;
    @GET("/posts/{postId}")
    suspend fun getPost(@Path("postId") id: Long): 
        PostApiModel
}</pre></li>
				<li>In the <code>data-remote</code> module, create a new package called <code>source</code>.</li>
				<li>In <a id="_idIndexMarker489"/>the <code>source</code> package, create a new class called <code>RemoteUserDataSourceImpl</code>:<pre>class RemoteUserDataSourceImpl @Inject constructor(private val userService: UserService) :
    RemoteUserDataSource {
    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = flow {
        emit(userService.getUsers())
    }.map { users -&gt;
        users.map { userApiModel -&gt;
            convert(userApiModel)
        }
    }.catch {
        throw UseCaseException.UserException(it)
    }
    override fun getUser(id: Long): Flow&lt;User&gt; = flow {
        emit(userService.getUser(id))
    }.map {
        convert(it)
    }.catch {
        throw UseCaseException.UserException(it)
    }
    
    private fun convert(userApiModel: UserApiModel) =
        User(userApiModel.id, userApiModel.name, 
            userApiModel.username, userApiModel.email)
}</pre></li>
			</ol>
			<p>Here, we invoke the <code>getUsers</code> and <code>getUser</code> methods from <code>UserService</code> and then convert the <code>UserApiModel</code> objects to <code>User</code> objects to avoid the other layers<a id="_idIndexMarker490"/> depending on the networking-related data. The same principle applies to error handling. If there is a network error, such as an <code>HTTP 404</code> code, the exception will be <code>HttpException</code>, which is part of the Retrofit library.</p>
			<ol>
				<li value="18">In the <code>source</code> package, create a new class called <code>RemotePostDataSourceImpl</code>:<pre>class RemotePostDataSourceImpl @Inject constructor(private val postService: PostService) :
    RemotePostDataSource {
    
    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = flow {
        emit(postService.getPosts())
    }.map { posts -&gt;
        posts.map { postApiModel -&gt;
            convert(postApiModel)
        }
    }.catch {
        throw UseCaseException.PostException(it)
    }
    override fun getPost(id: Long): Flow&lt;Post&gt; = flow {
        emit(postService.getPost(id))
    }.map {
        convert(it)
    }.catch {
        throw UseCaseException.PostException(it)
    }
    private fun convert(postApiModel: PostApiModel) =
        Post(postApiModel.id, postApiModel.userId, 
            postApiModel.title, postApiModel.body)
}</pre></li>
			</ol>
			<p>Here, we<a id="_idIndexMarker491"/> follow the same principle as with the <code>RemoteUserDataSourceImpl</code> class.</p>
			<ol>
				<li value="19">In the <code>data-remote</code> module, create a new package called <code>injection</code>:</li>
				<li>In the <code>injection</code> package, create a new class called <code>NetworkModule</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class NetworkModule {
    @Provides
    fun provideOkHttpClient(): OkHttpClient = 
        OkHttpClient
        .Builder()
        .readTimeout(15, TimeUnit.SECONDS)
        .connectTimeout(15, TimeUnit.SECONDS)
        .build()
    @Provides
    fun provideMoshi(): Moshi = Moshi.Builder().add
        (KotlinJsonAdapterFactory()).build()
    @Provides
    fun provideRetrofit(okHttpClient: OkHttpClient, 
        moshi: Moshi): Retrofit = Retrofit.Builder()
        .baseUrl
             ("https://jsonplaceholder.typicode.com/")
        .client(okHttpClient)
        .addConverterFactory
            (MoshiConverterFactory.create(moshi))
        .build()
    @Provides
    fun provideUserService(retrofit: Retrofit): 
        UserService =
        retrofit.create(UserService::class.java)
    @Provides
    fun providePostService(retrofit: Retrofit): 
        PostService =
        retrofit.create(PostService::class.java)
}</pre></li>
			</ol>
			<p>Here, we provide the Retrofit and <code>OkHttp</code> dependencies required for networking. </p>
			<ol>
				<li value="21">In <a id="_idIndexMarker492"/>the <code>injection</code> package, create a class named <code>RemoteDataSourceModule</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class RemoteDataSourceModule {
    @Binds
    abstract fun bindPostDataSource(postDataSourceImpl: RemotePostDataSourceImpl): RemotePostDataSource
    @Binds
    abstract fun bindUserDataSource
        (userDataSourceImpl: 
            RemoteUserDataSourceImpl):
 RemoteUserDataSource
}</pre></li>
			</ol>
			<p>Here, we use Hilt to bind the implementations from this module with the abstractions defined in the <code>data-repository</code> module.</p>
			<ol>
				<li value="22">To unit-test the code, we now need to create a new folder called <code>resources</code> in the <code>test</code> folder of the <code>data-remote</code> module.</li>
				<li>Inside the <code>resources</code> folder, create a folder called <code>mockito-extensions</code>; inside this folder, create a file named <code>org.mockito.plugins.MockMaker</code>; and inside this file, add the following text – <code>mock-maker-inline</code>.</li>
				<li>Create a test class named <code>RemoteUserDataSourceImplTest</code>, which will test the <a id="_idIndexMarker493"/>success scenarios for the methods inside <code>RemoteUserDataSourceImpl</code>:<pre>class RemoteUserDataSourceImplTest {
    private val userService = mock&lt;UserService&gt;()
    private val userDataSource = 
        RemoteUserDataSourceImpl(userService)
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUsers() = runBlockingTest {
        val remoteUsers = listOf(UserApiModel(1, 
            "name", "username", "email"))
        val expectedUsers = listOf(User(1, "name", 
            "username", "email"))
        whenever(userService.getUsers()).
            thenReturn(remoteUsers)
        val result = userDataSource.getUsers().first()
        Assert.assertEquals(expectedUsers, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUser() = runBlockingTest {
        val id = 1L
        val remoteUser = UserApiModel(id, "name", 
            "username", "email")
        val user = User(id, "name", "username", 
            "email")
        whenever(userService.getUser(id))
            .thenReturn(remoteUser)
        val result = userDataSource.getUser(id).
            first()
        Assert.assertEquals(user, result)
    }
}</pre></li>
			</ol>
			<p>Here, we are <a id="_idIndexMarker494"/>mocking the <code>UserService</code> interface and providing mock user data, which will then be obtained and converted by <code>RemoteDataSourceImpl</code>.</p>
			<ol>
				<li value="25">In the same test class, add the error scenarios:<pre>class RemoteUserDataSourceImplTest {
    …
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUsersThrowsError() = runBlockingTest {
        whenever(userService.getUsers()).thenThrow
            (RuntimeException())
        userDataSource.getUsers().catch {
            Assert.assertTrue(it is UseCaseException.
                UserException)
        }.collect()
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUserThrowsError() = runBlockingTest {
        val id = 1L
        whenever(userService.getUser(id)).thenThrow
            (RuntimeException())
        userDataSource.getUser(id).catch {
            Assert.assertTrue(it is UseCaseException.
                UserException)
        }.collect()
    }
}</pre></li>
			</ol>
			<p>Here, we are mocking an error that is thrown by <code>UserService</code>, which will then be converted by <code>RemoteUserDataSourceImpl</code> into <code>UseCaseException.UserException</code>.</p>
			<ol>
				<li value="26">Create a test class named <code>RemotePostDataSourceImplTest</code>, which will have similar<a id="_idIndexMarker495"/> test methods as <code>RemoteUserDataSourceImplTest</code> for posts:<pre>class RemotePostDataSourceImplTest {
    private val postService = mock&lt;PostService&gt;()
    private val postDataSource = 
        RemotePostDataSourceImpl(postService)
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPosts() = runBlockingTest {
        val remotePosts = listOf(PostApiModel(1, 1, 
            "title", "body"))
        val expectedPosts = listOf(Post(1, 1, "title", 
            "body"))
        whenever(postService.getPosts()).thenReturn
            (remotePosts)
        val result = postDataSource.getPosts().first()
        Assert.assertEquals(expectedPosts, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPost() = runBlockingTest {
        val id = 1L
        val remotePost = PostApiModel(id, 1, "title", 
            "body")
        val expectedPost = Post(id, 1, "title", 
            "body")
        whenever(postService.getPost(id)).thenReturn
            (remotePost)
        val result = postDataSource.getPost(id).
            first()
        Assert.assertEquals(expectedPost, result)
    }
}</pre></li>
			</ol>
			<p>Here, we are doing for posts what we did for users in <code>RemoteUserDataSourceImplTest</code>.</p>
			<ol>
				<li value="27">Add the <a id="_idIndexMarker496"/>error scenarios in <code>RemotePostDataSourceImplTest</code>:<pre>class RemotePostDataSourceImplTest {
    …
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPostsThrowsError() = runBlockingTest {
        whenever(postService.getPosts()).thenThrow
            (RuntimeException())
        postDataSource.getPosts().catch {
            Assert.assertTrue(it is UseCaseException.
                PostException)
        }.collect()
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPostThrowsError() = runBlockingTest {
        val id = 1L
        whenever(postService.getPost(id)).thenThrow
            (RuntimeException())
        postDataSource.getPost(id).catch {
            Assert.assertTrue(it is UseCaseException.
                PostException)
        }.collect()
    }
}</pre></li>
			</ol>
			<p>If we run the <a id="_idIndexMarker497"/>tests, we should see something like the following figure:</p>
			<div><div><img src="img/Figure_7.02_B18320.jpg" alt="Figure 7.2 – Output of the remote data source unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Output of the remote data source unit tests</p>
			<p>In this exercise, we have added a new module to the application, in which we can see how we can add a remote data source to the application. To fetch the data, we are using libraries such as OkHttp and Retrofit and combining them with the data source implementation <a id="_idIndexMarker498"/>for fetch users and posts. In the following section, we will expand the application to introduce local data sources, in which we will persist the data we are fetching here.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor086"/>Building and integrating local data sources</h1>
			<p>In this section, we<a id="_idIndexMarker499"/> will<a id="_idIndexMarker500"/> analyze how we can build local data sources and integrate them with libraries such as Room and Data Store.</p>
			<p>Local data sources have a similar structure to remote data sources. The abstractions are provided by the layers sitting above, and the implementations are responsible for invoking methods from persistence frameworks and converting data into entities, like the following figure:</p>
			<div><div><img src="img/Figure_7.03_B18320.jpg" alt="Figure 7.3 – A local data source diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – A local data source diagram</p>
			<p>Let's assume <a id="_idIndexMarker501"/>we<a id="_idIndexMarker502"/> have the same <code>UserEntity</code> defined in the previous chapters:</p>
			<pre>data class User(
    val id: String,
    val firstName: String,
    val lastName: String,
    val email: String
) {
    fun getFullName() = "$firstName $lastName"
}</pre>
			<p>Let's make <a id="_idIndexMarker503"/>the <a id="_idIndexMarker504"/>same assumption about <code>UserLocalDataSource</code>:</p>
			<pre>interface UserLocalDataSource {
    suspend fun insertUser(user: User)
    fun getUser(id: String): Flow&lt;User&gt;
}</pre>
			<p>We now need to provide an implementation for this data source that will manipulate the data from Room. First, we need to define a user entity for Room:</p>
			<pre>@Entity(tableName = "user")
data class UserEntity(
    @PrimaryKey @ColumnInfo(name = "id") val id: String,
    @ColumnInfo(name = "first_name") val firstName: String,
    @ColumnInfo(name = "last_name") val lastName: String,
    @ColumnInfo(name = "email") val email: String
)</pre>
			<p>Now, we can define <code>UserDao</code>, which queries a user by an ID and inserts a user:</p>
			<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user where id = :id")
    fun getUser(id: String): Flow&lt;UserEntity&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(users: UserEntity)
}</pre>
			<p>Finally, the <a id="_idIndexMarker505"/>implementation of the data source looks like <a id="_idIndexMarker506"/>this:</p>
			<pre>class UserLocalDataSourceImpl(private val userDao: UserDao) : UserLocalDataSource {
    override suspend fun insertUser(user: User) {
        userDao.insertUser(UserEntity(user.id, 
            user.firstName, user.lastName, user.email))
    }
    override fun getUser(id: String): Flow&lt;User&gt; {
        return userDao.getUser(id).map {
            User(it.id, it.firstName, it.lastName, 
                it.email)
        }
    }
}</pre>
			<p>Here, the local data source invokes <code>UserDao</code> to insert and retrieve a user and converts the domain entity into a Room entity. </p>
			<p>If we want to use Data Store instead of Room with a local data store implementation, we can<a id="_idIndexMarker507"/> have<a id="_idIndexMarker508"/> something like the following example:</p>
			<pre>private val KEY_ID = stringPreferencesKey("key_id")
private val KEY_FIRST_NAME = 
    stringPreferencesKey("key_first_name")
private val KEY_LAST_NAME = 
    stringPreferencesKey("key_last_name")
private val KEY_EMAIL = stringPreferencesKey("key_email")
class UserLocalDataSourceImpl(private val dataStore: 
    DataStore&lt;Preferences&gt;) : UserLocalDataSource {
    override suspend fun insertUser(user: User) {
        dataStore.edit {
            it[KEY_ID] = user.id
            it[KEY_FIRST_NAME] = user.firstName
            it[KEY_LAST_NAME] = user.lastName
            it[KEY_EMAIL] = user.email
        }
    }
    override fun getUser(id: String): Flow&lt;User&gt; {
        return dataStore.data.map {
            User(
                it[KEY_ID].orEmpty(),
                it[KEY_FIRST_NAME].orEmpty(),
                it[KEY_LAST_NAME].orEmpty(),
                it[KEY_EMAIL].orEmpty()
            )
        }
    }
}</pre>
			<p>Here, we use a key for each of the fields of the <code>User</code> object to store the data. The <code>getUser</code> method doesn't use the ID to search for a user, which shows that for this particular use case, Room is the more appropriate method. </p>
			<p>In this section, we looked at how we can build a local data source with the help of the Room and<a id="_idIndexMarker509"/> Data<a id="_idIndexMarker510"/> Store libraries to be able to query and persist data locally on a device. Next, we will look at an exercise to show how we can implement a local data store.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/>Exercise 07.02 – Building a local data source</h2>
			<p>Modify <em class="italic">Exercise 07.01 – Building a remote data source</em> so that a new Android library module <a id="_idIndexMarker511"/>named <code>data-local</code> is created. This module will depend on <code>domain</code> and <code>data-repository</code>. </p>
			<p>The module will implement the following:</p>
			<ul>
				<li><code>UserEntity</code> and <code>PostEntity</code>, which will hold data to be persisted from <code>User</code> and <code>Post</code> using Room</li>
				<li><code>UserDao</code> and <code>PostDao</code>, which will be responsible for persisting and fetching a list of <code>UserEntity</code> and <code>PostEntity</code></li>
				<li><code>LocalUserDataSourceImpl</code> and <code>LocalPostDataSourceImpl</code>, which will be responsible for invoking the <code>UserDao</code> and <code>PostDao</code> objects to persist data and for converting data to <code>User</code> and <code>Post</code> objects</li>
				<li><code>LocalInteractionDataSourceImpl</code>, which will be responsible for persisting the <code>Interaction</code> object</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li value="1">Create the <code>data-local</code> module.</li>
				<li>Create the <code>UserEntity</code> and <code>PostEntity</code> classes.</li>
				<li>Create the DAOs for users and posts.</li>
				<li>Create the data source implementations.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create <a id="_idIndexMarker512"/>a new module named <code>data-local</code>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <code>build.gradle</code> file, the following dependencies are set:<pre>buildscript {
     …
    dependencies {
        classpath gradlePlugins.android
        classpath gradlePlugins.kotlin
        classpath gradlePlugins.hilt
    }
}</pre></li>
				<li>In the same file, add the persistence libraries to the library mappings:<pre>    ext {
        …
        versions = [
                …
                room               : "2.4.0",
                datastore          : "1.0.0",
                …
        ]
        …
        persistence = [
                roomRuntime : "androidx.room:room-
                    runtime:${versions.room}",
                roomKtx     : "androidx.room:room-
                     ktx:${versions.room}",
                roomCompiler: "androidx.room:room-
                    compiler:${versions.room}",
                datastore   : "androidx.datastore:
                    datastore-preferences:$
                       {versions.datastore}"
        ]
        …
    }</pre></li>
				<li>In <a id="_idIndexMarker513"/>the <code>build.gradle</code> file of the <code>data-local</code> module, make sure that the following plugins are present:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, change<a id="_idIndexMarker514"/> the configurations to the ones defined in the top-level <code>build.gradle</code> file:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        …
    }
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
    }
}</pre></li>
				<li>In the same file, add the dependencies to the networking libraries and the <code>data-repository</code> and <code>domain</code> modules:<pre>dependencies {
    implementation(project(path: ":domain"))
    implementation(project(path: ":data-repository"))
    implementation coroutines.coroutinesAndroid
    implementation persistence.roomRuntime
    implementation persistence.roomKtx
    kapt persistence.roomCompiler
    implementation persistence.datastore
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>In the <code>data-local</code> module, create a new package called <code>db</code>.</li>
				<li>In the <code>db</code> package, create<a id="_idIndexMarker515"/> a new package called <code>user</code>.</li>
				<li>In the <code>user</code> package, create the <code>UserEntity</code> class:<pre>@Entity(tableName = "user")
data class UserEntity(
    @PrimaryKey @ColumnInfo(name = "id") val id: Long,
    @ColumnInfo(name = "name") val name: String,
    @ColumnInfo(name = "username") val username: 
        String,
    @ColumnInfo(name = "email") val email: String
)</pre></li>
				<li>In the same package, create the <code>UserDao</code> interface:<pre>@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    fun getUsers(): Flow&lt;List&lt;UserEntity&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertUsers(users: List&lt;UserEntity&gt;)
}</pre></li>
				<li>In the <code>db</code> package, create a new package called <code>post</code>.</li>
				<li>In the <code>post</code> package, create<a id="_idIndexMarker516"/> a new class called <code>PostEntity</code>:<pre>@Entity(tableName = "post")
data class PostEntity(
    @PrimaryKey @ColumnInfo(name = "id") val id: Long,
    @ColumnInfo(name = "userId") val userId: Long,
    @ColumnInfo(name = "title") val title: String,
    @ColumnInfo(name = "body") val body: String
)</pre></li>
				<li>In the same package, create a new interface called <code>PostDao</code>:<pre>@Dao
interface PostDao {
    @Query("SELECT * FROM post")
    fun getPosts(): Flow&lt;List&lt;PostEntity&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertPosts(users: List&lt;PostEntity&gt;)
}</pre></li>
				<li>In the <code>db</code> package, create the <code>AppDatabase</code> class:<pre>@Database(entities = [UserEntity::class, PostEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    abstract fun postDao(): PostDao
}</pre></li>
				<li>In<a id="_idIndexMarker517"/> the <code>data-local</code> module, create a new package called <code>source</code>.</li>
				<li>In the <code>source</code> package, create a new class called <code>LocalUserDataSourceImpl</code>:<pre>class LocalUserDataSourceImpl @Inject constructor(private val userDao: UserDao) :
    LocalUserDataSource {
    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = 
        userDao.getUsers().map { users -&gt;
        users.map {
            User(it.id, it.name, it.username, 
                it.email)
        }
    }
    override suspend fun addUsers(users: List&lt;User&gt;) = 
        userDao.insertUsers(users.map {
        UserEntity(it.id, it.name, it.username, 
            it.email)
    })
}</pre></li>
			</ol>
			<p>Here, in the <code>getUsers</code> method, we retrieve a list of <code>UserEntity</code> objects from <code>UserDao</code> and convert them into <code>User</code> objects. In the <code>addUsers</code> method, we do the opposite, by taking a list of <code>User</code> objects to be inserted and converting them into <code>UserEntity</code> objects.</p>
			<ol>
				<li value="17">In the same<a id="_idIndexMarker518"/> package, create the <code>LocalPostDataSourceImpl</code> class:<pre>class LocalPostDataSourceImpl @Inject constructor(private val postDao: PostDao) :
    LocalPostDataSource {
    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = 
       postDao.getPosts().map { posts -&gt;
        posts.map {
            Post(it.id, it.userId, it.title, it.body)
        }
    }
    override suspend fun addPosts(posts: List&lt;Post&gt;) = 
        postDao.insertPosts(posts.map {
        PostEntity(it.id, it.userId, it.title, 
            it.body)
    })
}</pre></li>
			</ol>
			<p>Here, we follow the same approach we used for <code>LocalUserDataSourceImpl</code>.</p>
			<ol>
				<li value="18">In the same<a id="_idIndexMarker519"/> package, create the <code>LocalInteractionDataSourceImpl</code> class:<pre>internal val KEY_TOTAL_TAPS = intPreferencesKey("key_total_taps")
class LocalInteractionDataSourceImpl @Inject constructor(private val dataStore: DataStore&lt;Preferences&gt;) :
    LocalInteractionDataSource {
    override fun getInteraction(): Flow&lt;Interaction&gt; {
        return dataStore.data.map {
            Interaction(it[KEY_TOTAL_TAPS] ?: 0)
        }
    }
    override suspend fun saveInteraction(interaction: 
        Interaction) {
        dataStore.edit {
            it[KEY_TOTAL_TAPS] = 
                interaction.totalClicks
        }
    }
}</pre></li>
			</ol>
			<p>Here, we use the Preference Data Store library to persist the Interaction object, by holding different keys for each field in the <code>Interaction</code> class, and in this case, it will be just one key for the total clicks.</p>
			<ol>
				<li value="19">In the <code>data-local</code> module, create a new package named <code>injection</code>.</li>
				<li>In <a id="_idIndexMarker520"/>the <code>injection</code> package, create a new class named <code>PersistenceModule</code>:<pre>val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = "my_preferences")
@Module
@InstallIn(SingletonComponent::class)
class PersistenceModule {
    @Provides
    fun provideAppDatabase(@ApplicationContext 
        context: Context): AppDatabase =
        Room.databaseBuilder(
            context,
            AppDatabase::class.java, "my-database"
        ).build()
    @Provides
    fun provideUserDao(appDatabase: AppDatabase): 
        UserDao = appDatabase.userDao()
    @Provides
    fun providePostDao(appDatabase: AppDatabase): 
        PostDao = appDatabase.postDao()
    @Provides
    fun provideLocalInteractionDataSourceImpl
        (@ApplicationContext context: Context) =
        LocalInteractionDataSourceImpl(context.dataStore)
} </pre></li>
			</ol>
			<p>Here, we provide all the Data Store and Room dependencies.</p>
			<ol>
				<li value="21">In the same <a id="_idIndexMarker521"/>package, create a new class called <code>LocalDataSourceModule</code>, in which we connect the abstractions to the bindings:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class LocalDataSourceModule {
    @Binds
    abstract fun bindPostDataSource
       (lostDataSourceImpl: LocalPostDataSourceImpl): 
           LocalPostDataSource
    @Binds
    abstract fun bindUserDataSource
        (userDataSourceImpl: LocalUserDataSourceImpl): 
            LocalUserDataSource
    @Binds
    abstract fun bindInteractionDataStore
        (interactionDataStore:LocalInteractionData
            SourceImpl): LocalInteractionDataSource
}</pre></li>
				<li>To unit-test the code, we will now need to create a new folder called <code>resources</code> in the test folder of the <code>data-local</code> module.</li>
				<li>Inside the <code>resources</code> folder, create a folder called <code>mockito-extensions</code>; inside <a id="_idIndexMarker522"/>this folder, create a file named <code>org.mockito.plugins.MockMaker</code>; and inside this file, add the following text – <code>mock-maker-inline</code>.</li>
				<li>Create the <code>LocalUserDataSourceImplTest</code> test class:<pre>class LocalUserDataSourceImplTest {
    private val userDao = mock&lt;UserDao&gt;()
    private val userDataSource = 
        LocalUserDataSourceImpl(userDao)
    @ExperimentalCoroutinesApi
    @Test
    fun testGetUsers() = runBlockingTest {
        val localUsers = listOf(UserEntity(1, "name", 
            "username", "email"))
        val expectedUsers = listOf(User(1, "name", 
            "username", "email"))
        whenever(userDao.getUsers()).thenReturn
            (flowOf(localUsers))
        val result = userDataSource.getUsers().first()
        Assert.assertEquals(expectedUsers, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testAddUsers() = runBlockingTest {
        val localUsers = listOf(UserEntity(1, "name", 
            "username", "email"))
        val users = listOf(User(1, "name", "username", 
            "email"))
        userDataSource.addUsers(users)
        verify(userDao).insertUsers(localUsers)
    }
}</pre></li>
			</ol>
			<p>Here, we are<a id="_idIndexMarker523"/> mocking the <code>UserDao</code> class and using it to provide mock data to <code>LocalUserDataSourceImpl</code>, which will then convert the data to and from the <code>User</code> objects.</p>
			<ol>
				<li value="25">Create the <code>LocalPostDataSourceImplTest</code> test class:<pre>class LocalPostDataSourceImplTest {
    private val postDao = mock&lt;PostDao&gt;()
    private val postDataSource = 
        LocalPostDataSourceImpl(postDao)
    @ExperimentalCoroutinesApi
    @Test
    fun testGetPosts() = runBlockingTest {
        val localPosts = listOf(PostEntity(1, 1, 
            "title", "body"))
        val expectedPosts = listOf(Post(1, 1, "title", 
            "body"))
        whenever(postDao.getPosts()).thenReturn
            (flowOf(localPosts))
        val result = postDataSource.getPosts().first()
        Assert.assertEquals(expectedPosts, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testAddUsers() = runBlockingTest {
        val localPosts = listOf(PostEntity(1, 1, 
            "title", "body"))
        val posts = listOf(Post(1, 1, "title", 
            "body"))
        postDataSource.addPosts(posts)
        verify(postDao).insertPosts(localPosts)
    }
}</pre></li>
			</ol>
			<p>Here, we perform the same type of tests for posts as we did in <code>LocalUserDataSourceImplTest</code> for users.</p>
			<ol>
				<li value="26">Create <a id="_idIndexMarker524"/>the <code>LocalInteractionDataSourceImplTest</code> test class:<pre>class LocalInteractionDataSourceImplTest {
    private val dataStore = mock&lt;DataStore
        &lt;Preferences&gt;&gt;()
    private val interactionDataSource = 
        LocalInteractionDataSourceImpl(dataStore)
    @ExperimentalCoroutinesApi
    @Test
    fun testGetInteraction() = runBlockingTest {
        val clicks = 10
        val interaction = Interaction(clicks)
        val preferences = mock&lt;Preferences&gt;()
        whenever(preferences[KEY_TOTAL_TAPS]).
            thenReturn(clicks)
        whenever(dataStore.data).thenReturn
            (flowOf(preferences))
        val result = interactionDataSource.
            getInteraction().first()
        assertEquals(interaction, result)
    }
    @ExperimentalCoroutinesApi
    @Test
    fun testSaveInteraction() = runBlockingTest {
        val clicks = 10
        val interaction = Interaction(clicks)
        val preferences = mock&lt;MutablePreferences&gt;()
        whenever(preferences.toMutablePreferences())
            .thenReturn(preferences)
        whenever(dataStore.updateData(any())).
            thenAnswer {
            runBlocking {
                it.getArgument&lt;suspend (Preferences) -
                 &gt; Preferences&gt;(0).invoke(preferences)
            }
            preferences
        }
        interactionDataSource.saveInteraction(interaction)
        verify(preferences)[KEY_TOTAL_TAPS] = clicks
    }
}</pre></li>
			</ol>
			<p>Here, in the <code>testSaveInteraction</code> method, we need to mock the <code>updateData</code> method instead of the <code>edit</code> method from the <code>DataStore</code> class. This is because the <code>edit</code> method is an extension function that can't be mocked with the current libraries we have and instead must rely on the method it invokes, which is <code>updateData</code>. </p>
			<p>If we run the tests, we <a id="_idIndexMarker525"/>should see something like the following figure:</p>
			<div><div><img src="img/Figure_7.04_B18320.jpg" alt="Figure 7.4 – Output of the local data source unit tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Output of the local data source unit tests</p>
			<p>If we draw a diagram of the modules in the exercise, we will see something like the following figure:</p>
			<div><div><img src="img/Figure_7.05_B18320.jpg" alt="Figure 7.5 – The exercise 07.02 module diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – The exercise 07.02 module diagram</p>
			<p>We can see<a id="_idIndexMarker526"/> that the <code>:data-remote</code> and <code>:data-local</code> modules are isolated from each other. The two modules have different responsibilities and deal with different dependencies. <code>:data-remote</code> deals with fetching data from the internet, while <code>:data-local</code> deals with persisting data locally into SQLite using Room and files using Data Store. This gives our code more flexibility because we are able to change how we fetch data – for example, without impacting how we persist the data.</p>
			<p>In this exercise, we have created a new module in the application in which we deal with local data sources. To persist data, we have used libraries such as Room and Data Store, and we have<a id="_idIndexMarker527"/> integrated them with the local data store.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor088"/>Summary </h1>
			<p>In this chapter, we looked at the concept of data sources and the different types of data sources we have available in an Android application. We started with remote data sources and saw some examples of how we can build a data source and combine it with libraries such as Retrofit and OkHttp. The local data source followed similar principles as the remote one, and here, we have used libraries such as Room and Data Store to implement this. </p>
			<p>In the exercises, we implemented the data sources as part of different modules. This was to avoid creating any unnecessary dependencies between the other layers of the application and the specific frameworks we have used for the data sources. In the next chapter, we will look at how we can build the presentation layer and show data to the user. We will also explore how we can split the presentation layer into separate modules and navigate from a screen in one module to a screen in another module, through the introduction of modules that can be shared by other presentation modules.</p>
		</div>
	</body></html>