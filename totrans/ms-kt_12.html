<html><head></head><body><div><div><div><h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor157"/>12</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor158"/>Testing Your App</h1>
			<p>Testing Android apps is a crucial aspect of the development process, ensuring that our application functions as intended and meets user expectations. It helps us identify and fix bugs before they reach production and ensure that our app is stable and performs well. This chapter will equip you with the skills to write tests for the different layers of our app that we’ve created so far.</p>
			<p>In this chapter, we will learn how to add tests for the different layers in our <strong class="bold">MVVM</strong> (<strong class="bold">Model-View-ViewModel</strong>) architecture. We will learn the importance of adding tests to our apps and how to add unit tests, integration tests, and instrumentation tests.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Importance of testing</li>
				<li>Testing the network and database layers</li>
				<li>Testing our <code>ViewModels</code></li>
				<li>Adding UI tests to our composables</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor159"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve</a>.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor160"/>Importance of testing</h1>
			<p>Writing tests is a<a id="_idIndexMarker596"/> crucial aspect of app development. It has the following benefits:</p>
			<ul>
				<li>It helps us to <strong class="bold">identify and fix bugs</strong> before they reach production. When we write tests for our code, we can see issues at an early stage and quickly fix them before they reach our users, which is normally very costly.</li>
				<li><strong class="bold">Ensures code quality</strong>. When we write tests, we are forced to write code that can be tested. This means that we write code that is modular and loosely coupled. This makes our code base more maintainable and easier to work with. When we find a piece of code that is hard to test, it is a sign that the code is not well written and needs to be refactored.</li>
				<li>Writing tests results in <strong class="bold">improved documentation and code understanding</strong>. When we write tests, we are forced to think about how our code works and how it should be used. This makes it easier for other developers to understand our code. While tests can serve as a form of documentation, they should not replace proper code documentation.</li>
				<li>Tests help us to <strong class="bold">refactor our code with confidence</strong>. When we have tests in place, we can refactor our code and be sure that we have not broken the existing features in our app that were working well before the refactoring. This is because we can run our tests and see whether they pass or fail.</li>
				<li>Tests help us <strong class="bold">test regression</strong>, especially adding new features or modifying existing ones. Tests ensure that the existing functionality still works as before, and nothing has been broken.</li>
			</ul>
			<p>These are just to mention a few. There are many more benefits of writing tests, and the best way to realize them is to start writing tests for your code. One important thing to note is that we can also add tests to our <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines to ensure<a id="_idIndexMarker597"/> that our tests run automatically when we push our code to our repositories. This also ensures that as we collaborate with other people on our projects, we can be sure that our code is always in a good state and we can always deploy our code to production with confidence.</p>
			<p>In Android, we have a concept called the <strong class="bold">testing pyramid</strong> that helps us to understand the several types of tests that we can write for our <a id="_idIndexMarker598"/>applications and how they relate to each other. The testing <a id="_idIndexMarker599"/>pyramid is divided into three layers, as shown in the following figure:</p>
			<div><div><img src="img/B19779_12_01.jpg" alt="Figure 12.1 – Testing pyramid" width="1089" height="652"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Testing pyramid</p>
			<p>As shown in the preceding diagram, we have three layers of tests:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These tests sit at the bottom of the pyramid. These are tests that test a single unit of code in isolation. Unit tests are intended to test the smallest testable parts of an application – typically, methods and functions. They are the fastest to run and are the most reliable. They are also the easiest to write and maintain. Unit tests run on your local machine only. These tests are compiled to run locally on the <strong class="bold">Java Virtual Machine </strong>(<strong class="bold">JVM</strong>) to minimize execution time. For tests that depend on your own dependencies, we use mock objects to provide the external dependencies. <strong class="bold">MockK</strong> and <strong class="bold">Mockito</strong> are popular frameworks for mocking dependencies.</li>
				<li><strong class="bold">Integration tests</strong>: These tests<a id="_idIndexMarker600"/> sit in the<a id="_idIndexMarker601"/> middle of the pyramid. They<a id="_idIndexMarker602"/> test how different units of code <a id="_idIndexMarker603"/>work together. They are slower to run than<a id="_idIndexMarker604"/> unit tests. They are also hard to write as they require multiple components and dependencies to work and maintain. <strong class="bold">Roboletric</strong> is a popular framework for writing integration tests.</li>
				<li><strong class="bold">UI tests</strong>: These tests sit at the top of the <a id="_idIndexMarker605"/>pyramid. They test how the different components of our app work <a id="_idIndexMarker606"/>together. They are the slowest to run since they run on a real device or emulator and are the least reliable. They are also the <a id="_idIndexMarker607"/>most expensive to write and maintain. There are several frameworks for writing UI tests, including <strong class="bold">Espresso</strong>, <strong class="bold">UI Automator</strong>, and <strong class="bold">Appium</strong>.</li>
			</ul>
			<p>The testing pyramid presents a way to distribute the tests that we write on our code base. The ideal distribution percentages are <strong class="bold">70% for unit tests</strong>, <strong class="bold">20% for integration tests</strong>, and <strong class="bold">10% for UI tests</strong>. Notice as we go up the pyramid that the number of tests reduces. This is because as we go up the pyramid, the tests become more expensive to write and maintain. This is why<a id="_idIndexMarker608"/> we should strive to write more unit tests than integration tests and more integration tests than UI tests.</p>
			<p>Over the next few sections, we will write the tests for the different layers we have discussed. Let us start by testing our database and network layers in our app.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor161"/>Testing the network and database layers</h1>
			<p>In this section, we are going to learn how to write tests for our network and database layers step by step.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor162"/>Testing the network layer</h2>
			<p>To test our network layer, we will write <a id="_idIndexMarker609"/>unit tests. However, since we are using Retrofit to make our network requests, we will use <code>MockWebServer</code> to mock our network requests. The <code>MockWebServer </code>is a library that allows us to mock our network requests. Let us start by setting up the test dependencies in our version catalog:</p>
			<ol>
				<li>Open the <code>libs.version.toml</code> file and add the following versions in the versions section:<pre class="source-code">
mockWebServer = "5.0.0-alpha.2"
coroutinesTest = "1.7.3"
truth = "1.1.5"</pre><p class="list-inset">We are setting up the versions for <code>mockWebServer</code>, <code>coroutinesTest</code>, and <code>truth</code>.</p></li>				<li>Next, in the<a id="_idIndexMarker610"/> libraries section, add the following:<pre class="source-code">
test-mock-webserver = { module = "com.squareup.okhttp3:mockwebserver", version.ref = "mockWebServer" }
test-coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-test", version.ref = "coroutinesTest" }
test-truth = { module = "com.google.truth:truth", version.ref = "truth" }</pre><p class="list-inset">Here, we are adding the dependencies for these libraries.</p></li>				<li>Next, we will create a bundle so that it is easy to add all test dependencies at once. In the bundle section, add the following:<pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth"]</pre></li>				<li>Click on the <strong class="bold">Sync Now</strong> button at the top to add the dependencies.</li>
				<li>Lastly, let us head over to the app-level <code>build.gradle.kts</code> file and add the following:<pre class="source-code">
testImplementation(libs.bundles.test)</pre><p class="list-inset">This will add the test bundle to our test directory.</p></li>				<li>Click on the <strong class="bold">Sync Now</strong> button to add the dependencies to our app.</li>
			</ol>
			<p>Before we start writing our tests, we need to do several setup tasks. First, we need to create a JSON response for the request that our test will use:</p>
			<ol>
				<li>To do this, right-click on the <code>app</code> directory, select <strong class="bold">New</strong>, and at the bottom of the pop-up dialog, select <strong class="bold">Folder</strong>.</li>
				<li>From the options presented, select <code>resources</code>, as shown in the following figure:</li>
			</ol>
			<div><div><img src="img/B19779_12_02.jpg" alt="Figure 12.2 – The resources folder" width="538" height="409"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The resources folder</p>
			<ol>
				<li value="3">Inside this folder, let us create a new JSON file called <code>catsresponse.json</code> and add the following JSON:<pre class="source-code">
[
  {
    "_id": "eLjLV4oegWGFv9MH",
    "mimetype": "image/png",
    "size": 39927,
    "tags": [
      "cute",
      "pyret"
    ]
  },
  {
    "_id": "PA2gYEbMCzaiDrWv",
    "mimetype": "image/jpeg",
    "size": 59064,
    "tags": [
      "cute",
      "best",
      "siberian",
      "fluffy"
    ]
  },
  {
    "_id": "8PKU6iXscrogXrHm",
    "mimetype": "image/jpeg",
    "size": 60129,
    "tags": [
      "cute",
      "fat",
      "ragdoll",
      "beautiful",
      "sleeping"
    ]
  }
]</pre><p class="list-inset">Our app uses the Cat as a<a id="_idIndexMarker612"/> Service API, which returns a list of cats per the filter you have applied. The API returns this list of cats in a JSON response, as shown previously. When testing, especially with mocked data, the structure and data types of the JSON response should match those of the real API to ensure our tests are correct.</p></li>				<li>Now that we have our response ready, we have to create a class that utilizes this response along with our test class in the <code>com.packt.chaptertwelve (test)</code> directory shown in the following figure:</li>
			</ol>
			<div><div><img src="img/B19779_12_03.jpg" alt="Figure 12.3 – Test directory" width="424" height="261"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Test directory</p>
			<ol>
				<li value="5">Inside the <code>com.packt.chaptertwelve (test)</code> directory, let us create a new Kotlin file called <code>MockRequestDispatcher.kt</code> and add the following code:<pre class="source-code">
import com.google.common.io.Resources
import okhttp3.mockwebserver.Dispatcher
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.RecordedRequest
import java.io.File
import java.net.HttpURLConnection
class MockRequestDispatcher : Dispatcher() {
    override fun dispatch(request: RecordedRequest): MockResponse {
        return when (request.path) {
            "/cats?tag=cute" -&gt; {
                MockResponse()
                    .setResponseCode(HttpURLConnection.HTTP_OK)
                    .setBody(getJson("catsresponse.json"))
            }
            else -&gt; throw IllegalArgumentException("Unknown Request Path ${request.path}")
        }
    }
    private fun getJson(path: String): String {
        val uri = Resources.getResource(path)
        val file = File(uri.path)
        return String(file.readBytes())
    }
}</pre><p class="list-inset">Here is a breakdown <a id="_idIndexMarker613"/>of the preceding code:</p><ul><li>We have created a class called <code>MockRequestDispatcher</code> that extends <code>Dispatcher</code>. This class will be used to mock our network requests.</li><li>We override the <code>dispatch</code> function, which takes <code>RecordedRequest</code> and returns <code>MockResponse</code>. This function is called when a request is made to the server.</li><li>We check the path of the request, and if it matches the path of our request, we return <code>MockResponse</code> with a response code of <code>200</code> and a body of the <code>Json</code> response that we created earlier. For now, we have only mocked a successful response, but it’s important to handle all the different HTTP response codes and error cases to properly mimic real-world scenarios.</li><li>If the path does not match, we throw <code>IllegalArgumentException</code>.</li><li>Lastly, we create a <code>getJson</code> function that takes a path and returns a <code>String</code> instance type. This function is used to read the <code>Json</code> response from the file that we created earlier.</li></ul><p class="list-inset">We can add as many paths as we want to this class. Since our project only has one path, this is all we need.</p></li>				<li>Next, let us create our test class. Let us create a new Kotlin file called <code>CatsAPITest.kt</code> and add the following code:<pre class="source-code">
class CatsAPITest {
    private lateinit var mockWebServer: MockWebServer
    private lateinit var catsAPI: CatsAPI
    @Before
    fun setup() {
        // Setup MockWebServer
        mockWebServer = MockWebServer()
        mockWebServer.dispatcher = MockRequestDispatcher()
        mockWebServer.start()
        // Setup Retrofit
        val json = Json {
            ignoreUnknownKeys = true
            isLenient = true
        }
        val retrofit = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .addConverterFactory(
                json.asConverterFactory(
                    contentType = "application/json".toMediaType()
                )
            )
            .build()
        catsAPI = retrofit.create(CatsAPI::class.java)
    }
    @Test
    fun `fetchCats() returns a list of cats`() = runTest {
        val response = catsAPI.fetchCats("cute")
        assert(response.isSuccessful)
    }
    @After
    @Throws(IOException::class)
    fun tearDown() {
        mockWebServer.shutdown()
    }
}</pre><p class="list-inset">Here is a breakdown of the preceding code:</p><ul><li>We have created a class called <code>CatsAPITest</code>. This class will be used to test our network layer.</li><li>We have created two variables: <code>mockWebServer</code> and <code>catsAPI</code>. The <code>mockWebServer</code> variable will be used to mock our network requests. The <code>catsAPI</code> variable will be <a id="_idIndexMarker614"/>used to make our network reques<a id="_idTextAnchor163"/>ts.</li><li>We have the <code>setup()</code> function, which is annotated with the <code>@Before</code> annotation. This means that this function will run before our tests run. In this function, we have done the following:<ul><li>We have created a <code>MockWebServer</code> instance and assigned it to the <code>mockWebServer</code> variable. We then set the dispatcher of <code>mockWebServer</code> to an instance of <code>MockRequestDispatcher</code>. This is the class that we created earlier. We then start<a id="_idTextAnchor164"/> <code>mockWebServer</code>.</li><li>We have created a Retrofit instance and added the <code>kotlinx-serialization-converter</code> factory. We then assign the <code>catsAPI</code> variable to an instance of <code>CatsAPI</code>.</li></ul></li><li>We have our test function, which is annotated with the <code>@Test</code> annotation. This means that this function will be run as a test. In this function, we do the following:<ul><li>We wrap the test in the <code>runTest()</code> function. This is because we want to test suspending functions. <code>runTest</code> is a coroutine test builder designed for testing coroutines. It is part of the <code>kotlinx-coroutines-test</code> library that we added earlier.</li><li>We make a network <a id="_idIndexMarker615"/>request to <code>mockWebServer</code> using the <code>catsAPI</code> instance that we created earlier. We then assert that the response is successful.</li><li>We have the <code>tearDown()</code> function, which is annotated with the <code>@After</code> annotation. This means that this function will run after our tests run. This function is used to shut down our <code>mockWebServer</code> instance.</li></ul></li></ul></li>				<li>Press the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <strong class="bold">Run</strong> window:</li>
			</ol>
			<div><div><img src="img/B19779_12_04.jpg" alt="Figure 12.4 – Test passing" width="1157" height="528"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Test passing</p>
			<p>As seen in the preceding figure, our test runs successfully. This means that our network layer is working as expected. We <a id="_idIndexMarker616"/>can now move on to testing our database layer.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor165"/>Testing the database layer</h2>
			<p>We are using <code>androidTest</code> directory shown in the following figure:</p>
			<div><div><img src="img/B19779_12_05.jpg" alt="Figure 12.5 – Android test directory" width="418" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Android test directory</p>
			<p>Let us create a new file called <code>CatsDaoTest.kt</code> and add the following code:</p>
			<pre class="source-code">
@RunWith(AndroidJUnit4::class)
class CatDaoTest {
    private lateinit var database: CatDatabase
    private lateinit var catDao: CatDao
    @Before
    fun createDatabase() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            CatDatabase::class.java
        ).allowMainThreadQueries().build()
        catDao = database.catDao()
    }
    @After
    fun closeDatabase() {
        database.close()
    }
}</pre>			<p>Here is a breakdown of the preceding code:</p>
			<ul>
				<li>We have created two variables: <code>database</code> and <code>catDao</code>. The <code>database</code> variable will be used to create an instance of our database. The <code>catDao</code> variable will be <a id="_idIndexMarker619"/>used to create an instance of our <code>CatDao</code> interface.</li>
				<li>We have the <code>createDatabase()</code> function, which is annotated with the <code>@Before</code> annotation. This means that this function will run before our tests run. Inside the function, we create an instance of our database and assign it to the <code>database</code> variable. We are using the in-memory database.</li>
				<li>We have the <code>closeDatabase()</code> function, which is annotated with the <code>@After</code> annotation. This means that this function will run after our tests run. This function is used to close our database.</li>
			</ul>
			<p>With this done, we can now start <a id="_idIndexMarker620"/>writing our tests:</p>
			<ol>
				<li>In the <code>CatsDaoTest</code> class, add the following test function:<pre class="source-code">
@Test
fun testInsertAndReadCat() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Then the cat is in the database
    val cats = catDao.getCats()
    assert(cats.first().contains(cat))
}</pre><p class="list-inset">In this test, we have created a <code>CatEntity</code> object with the details of a cat. We then inserted the details of the cat into the database. Lastly, we assert that the details of the cat are in the database.</p></li>				<li>Click on the green <em class="italic">run</em> icon<a id="_idIndexMarker621"/> next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</li>
			</ol>
			<div><div><img src="img/B19779_12_06.jpg" alt="Figure 12.6 – Test to insert and read from the database" width="922" height="355"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Test to insert and read from the database</p>
			<p class="list-inset">Our test runs successfully. This means that our database layer is working as expected. Let us add another test that tests adding a cat to the favorites.</p>
			<ol>
				<li value="3">Still inside the <code>CatsDaoTest</code> class, let us add the following test function:<pre class="source-code">
@Test
fun testAddCatToFavorites() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Favorite the cat
    catDao.update(cat.copy(isFavorite = true))
    // Assert that the cat is in the favorite list
    val favoriteCats = catDao.getFavoriteCats()
    assert(favoriteCats.first().contains(cat.copy(isFavorite = true)))
}</pre><p class="list-inset">In this test, we have created a <code>CatEntity</code> object with the details of a cat. We then insert the cat into the<a id="_idIndexMarker622"/> database. We then update the <code>CatEntity</code> object, passing <code>isFavorite</code> as <code>true</code>. Lastly, we assert that the cat is on the favorite list.</p></li>				<li>Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</li>
			</ol>
			<div><div><img src="img/B19779_12_07.jpg" alt="Figure 12.7 – Favoriting a cat test" width="976" height="348"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Favoriting a cat test</p>
			<p>Our tests run successfully. This <a id="_idIndexMarker623"/>means that our functionality for adding cats to favorites is working properly.</p>
			<p>We have seen how to test our network and database layers. Next, let us test our ViewModel layer.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor166"/>Testing our ViewModels</h1>
			<p>Our <code>ViewModel</code> class fetches data<a id="_idIndexMarker624"/> from the repository and exposes it to the UI. To test our <code>ViewModel</code>, we will write unit tests. Let us start by setting up the test dependencies in our version catalog:</p>
			<ol>
				<li>Open the <code>libs.version.toml</code> file and add the following versions in the versions section:<pre class="source-code">
mockk = "1.13.3"</pre></li>				<li>Next, in the libraries section, add the following:<pre class="source-code">
test-mockk = { module = "io.mockk:mockk", version.ref = "mockk" }</pre></li>				<li>Add the <code>test-mockk</code> dependency to the <code>test</code> bundle. Our updated <code>test</code> bundle should now look like this:<pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth", "test-mockk"]</pre></li>				<li>Click on the <code>mockk</code> allows us to mock our dependencies.</li>
				<li>We are now ready to create our test class. Create a new Kotlin file called <code>CatsViewModelTest.kt</code> inside<a id="_idIndexMarker625"/> the test directory and add the following code:<pre class="source-code">
class PetsViewModelTest {
    private val petsRepository = mockk&lt;PetsRepository&gt;(relaxed = true)
    private lateinit var petsViewModel: PetsViewModel
    @Before
    fun setup() {
        Dispatchers.setMain(Dispatchers.Unconfined)
        petsViewModel = PetsViewModel(petsRepository)
    }
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
}</pre><p class="list-inset">Here is a breakdown of the preceding code:</p><ul><li>We have created two variables: <code>petsRepository</code> and <code>petsViewModel</code>. The <code>petsRepository</code> variable will be used to mock our <code>PetsRepository</code> interface. We used <code>mockk&lt;PetsRepository&gt;</code> to provide a mock instance of <code>PetsRepository</code>. The <code>petsViewModel</code> variable will be used to create an instance of <code>Pets<a id="_idTextAnchor167"/>ViewModel</code>.</li><li>We have the <code>setup()</code> function, which is annotated with the <code>@Before</code> annotation. This means that this function will run before our tests run. We set the main dispatcher to <code>Dispatchers.Unconfined</code>. This is because we are using coroutines in our ViewModel. We then assign the <code>petsViewModel</code> property to an instance of <code>PetsViewModel</code>.</li><li>We have the <code>tearDown()</code> function, which is annotated with the <code>@After</code> annotation. This means<a id="_idIndexMarker626"/> that this function will run after our tests run. This function is used to reset the main dispatcher.</li></ul></li>			</ol>
			<p>With this, we are ready to write our test. Below the <code>tearDown()</code> function, add the following test function:</p>
			<pre class="source-code">
@Test
fun testGetPets() = runTest {
    val cats = listOf(
        Cat(
            id = "1",
            owner = "John Doe",
            tags = listOf("cute", "fluffy"),
            createdAt = "2021-07-01T00:00:00.000Z",
            updatedAt = "2021-07-01T00:00:00.000Z",
            isFavorite = false
        )
    )
    // Given
    coEvery { petsRepository.getPets() } returns flowOf(cats)
    // When
    petsViewModel.getPets()
    coVerify { petsRepository.getPets() }
    // Then
    val uiState = petsViewModel.petsUIState.value
    assertEquals(cats, uiState.pets)
}</pre>			<p>In this test function, we have created a list of cats. We then mock the <code>getPets()</code> function of <code>PetsRepository</code> to return a flow of cats. It returns a flow of cats since our <code>getPets()</code> function in <code>PetsRepository</code> returns <code>Flow&lt;List&lt;Cat&gt;&gt;</code>; this way, we mock the correct behavior of this function. We then call the <code>getPets()</code> function of <code>PetsViewModel</code>. We<a id="_idIndexMarker627"/> then assert that the <code>getPets()</code> function of <code>PetsRepository</code> is called. Lastly, we assert that the list of cats that we created is the same as the list of cats that we get from <code>PetsViewModel</code>. Remember to remove the private marker in our <code>PetsViewModel</code> class in case you get an error when trying to access the <code>getPets()</code> function. Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <strong class="bold">Run</strong> window:</p>
			<div><div><img src="img/B19779_12_08.jpg" alt="Figure 12.8 – PetsViewModelTest" width="1085" height="253"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – PetsViewModelTest</p>
			<p>Our test runs successfully. This means that our <code>ViewModel</code> layer is working as expected. We can now move on to testing our UI layer. In the next section, we will learn how to write UI tests in Jetpack Compose.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor168"/>Adding UI tests to our composables</h1>
			<p>Writing UI tests has been made easier for us. Jetpack Compose <a id="_idIndexMarker628"/>provides a set of testing APIs to find elements, verify their attributes, and <a id="_idIndexMarker629"/>perform actions on these elements. Jetpack<a id="_idIndexMarker630"/> Compose uses <code>PetListItem</code> composable.</p>
			<p>Let us head over to the <code>PetListItem.kt</code> file. We need to add a <code>testTags</code> modifier to our composable. This is because we are using tags to identify our composables. In the <code>PetListItem</code> composable, modify the composable contents to be as follows:</p>
			<pre class="source-code">
ElevatedCard(
    modifier = Modifier
        .fillMaxWidth()
        .padding(6.dp)
        .testTag("PetListItemCard"),
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 10.dp)
            .testTag("PetListItemColumn")
            .clickable {
                onPetClicked(cat)
            }
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        Row(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
            Icon(
                modifier = Modifier
                    .testTag("PetListItemFavoriteIcon")
                    .clickable {
                        onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                    },
                imageVector = if (cat.isFavorite) {
                    Icons.Default.Favorite
                } else {
                    Icons.Default.FavoriteBorder
                },
                contentDescription = "Favorite",
                tint = if (cat.isFavorite) {
                    Color.Red
                } else {
                    Color.Gray
                }
            )
        }
    }
}</pre>			<p>Notice we have added the <code>testTag()</code> modifier to our components. With this, we are able to use the Finders APIs in Jetpack Compose to<a id="_idIndexMarker632"/> find our composables. Once we use the finders, we can<a id="_idIndexMarker633"/> perform actions and assert on our composables. Let us now create a new file in our <code>androidTest</code> directory called <code>PetListItemTest.kt</code> and add the following code:</p>
			<pre class="source-code">
class PetListItemTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    @Test
    fun testPetListItem() {
        with(composeTestRule) {
            setContent {
                PetListItem(
                    cat = Cat(
                        id = "1",
                        owner = "John Doe",
                        tags = listOf("cute", "fluffy"),
                        createdAt = "2021-07-01T00:00:00.000Z",
                        updatedAt = "2021-07-01T00:00:00.000Z",
                        isFavorite = false
                    ),
                    onPetClicked = { },
                    onFavoriteClicked = {})
            }
            // Assertions using tags
            onNodeWithTag("PetListItemCard").assertExists()
            onNodeWithTag("PetListItemColumn").assertExists()
            onNodeWithTag("PetListItemFavoriteIcon").assertExists()
            // Assertions using text
            onNodeWithText("fluffy").assertIsDisplayed()
            onNodeWithContentDescription("Favorite").assertIsDisplayed()
            onNodeWithContentDescription("Cute cat").assertIsDisplayed()
            // Actions
            onNodeWithTag("PetListItemFavoriteIcon").performClick()
        }
    }
}</pre>			<p>Here is a <a id="_idIndexMarker634"/>breakdown of the <a id="_idIndexMarker635"/>preceding code:</p>
			<ul>
				<li>We have created a class called <code>PetListItemTest</code>. We will use this class to test our <code>PetListItem</code> composable. Inside this class, we have created a rule called <code>composeTestRule</code>. This rule will be used to create our com<a id="_idTextAnchor171"/>posables. Through this rule, we can set Compose <a id="_idIndexMarker636"/>content or access our activity.</li>
				<li>We have the <code>testPetListItem()</code> function, which is annotated with the <code>@Test</code> annotation. Several<a id="_idIndexMarker637"/> things are happeni<a id="_idTextAnchor172"/>ng in this function:<ul><li>We have used the <code>with</code> scoping function to be able to use <code>composeTestRule</code>. We then set the content of our composable. In this case, it is the <code>PetListItem</code> composable that we want to test. We pass a <code>cat</code> object to our composable.</li><li>We are using the <code>onNodeWithTag()</code> function to find our composables. We then use the <code>assertExists()</code> function to assert that the composables exist. This will find our composables using the tags that we added earlier.</li><li>We are using the <code>onNodeWithText()</code> function to find our composables. We then use the <code>assertIsDisplayed()</code> function to assert that the composables exist. We have also used the <code>onNodeWithContentDescription()</code> function to find our composables. These two functions help us find composables whose text or content description matches the text or content description that we pass to the function.</li><li>Lastly, we are using the <code>performClick()</code> function to perform an action on our composables. In this case, we are performing a click action on our <code>PetListItemFavoriteIcon</code> composable.</li></ul></li>
			</ul>
			<p>Click on the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <strong class="bold">Run</strong> window:</p>
			<div><div><img src="img/B19779_12_09.jpg" alt="Figure 12.9 – Jetpack Compose UI tests" width="711" height="129"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Jetpack Compose UI tests</p>
			<p>Our test runs successfully. Additionally, the test is also run on the device that we are working on. We are also able to see the <a id="_idIndexMarker638"/>components being displayed and actions being performed.</p>
			<p>We have seen how to write <a id="_idIndexMarker639"/>UI tests in Jetpack Compose. To learn more about testing in Jetpack Compose, check out the official documentation (<a href="https://developer.android.com/jetpack/compose/testing">https://developer.android.com/jetpack/compose/testing</a>). With the knowledge that we have gained in this chapter, we can add more tests to the different layers of our app. You can try adding more tests to test your knowledge.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor173"/>Summary</h1>
			<p>In this chapter, we have learned how to add tests for the different layers in our MVVM architecture. We have learned about the importance of adding tests to our apps and how to add unit tests, integration tests, and instrumentation tests.</p>
			<p>In the next chapter, we will learn step-by-step how to publish a new app in the Google Play Store. We will walk through how to create a signed app bundle and the things required for us to publish our first app to the Play Store. Additionally, we will learn about some of the Google Play Store policies and how to always stay compliant to avoid our apps from being removed or accounts from being banned.</p>
		</div>
	</div></div>
<div><div><div><h1 id="_idParaDest-149" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor174"/>Part 4: Publishing Your App</h1>
			<p>Having successfully developed your app, the next phase unfolds in this part. You will discover the intricacies of publishing your app to the Google Play Store, navigating through crucial Google Play Store policies to ensure a seamless release. You will also dive into the realm of <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>), unlocking the potential to automate routine tasks integral to Android development. You will learn how to seamlessly integrate tests and code analysis tools from <em class="italic">Part 3</em> into your CI/CD pipelines, streamlining development workflows. To conclude this part, you will elevate your app’s performance by incorporating crash reporting tools and enhancing user engagement through the implementation of push notifications, and learn some useful tips on how to secure your app.</p>
			<p>This section contains the following chapters:</p>
			<ul>
				<li><a href="B19779_13.xhtml#_idTextAnchor175"><em class="italic">Chapter 13</em></a>, <em class="italic">Publishing Your App</em></li>
				<li><a href="B19779_14.xhtml#_idTextAnchor198"><em class="italic">Chapter 14</em></a>, <em class="italic">Continuous Integration and Continuous Deployment</em></li>
				<li><a href="B19779_15.xhtml#_idTextAnchor215"><em class="italic">Chapter 15</em></a>, <em class="italic">Improving Your App</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</div></div></body></html>