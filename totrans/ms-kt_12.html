<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer175">
			<h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor157"/>12</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor158"/>Testing Your App</h1>
			<p>Testing Android apps is a crucial aspect of the development process, ensuring that our application functions as intended and meets user expectations. It helps us identify and fix bugs before they reach production and ensure that our app is stable and performs well. This chapter will equip you with the skills to write tests for the different layers of our app that we’ve created <span class="No-Break">so far.</span></p>
			<p>In this chapter, we will learn how to add tests for the different layers in our <strong class="bold">MVVM</strong> (<strong class="bold">Model-View-ViewModel</strong>) architecture. We will learn the importance of adding tests to our apps and how to add unit tests, integration tests, and <span class="No-Break">instrumentation tests.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Importance <span class="No-Break">of testing</span></li>
				<li>Testing the network and <span class="No-Break">database layers</span></li>
				<li>Testing <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">ViewModels</strong></span></li>
				<li>Adding UI tests to <span class="No-Break">our composables</span></li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor159"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio"><span class="No-Break">https://developer.android.com/studio</span></a><span class="No-Break">) </span><span class="No-Break">downloaded</span><span class="No-Break">.</span></p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor160"/>Importance of testing</h1>
			<p>Writing tests is a<a id="_idIndexMarker596"/> crucial aspect of app development. It has the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li>It helps us to <strong class="bold">identify and fix bugs</strong> before they reach production. When we write tests for our code, we can see issues at an early stage and quickly fix them before they reach our users, which is normally <span class="No-Break">very costly.</span></li>
				<li><strong class="bold">Ensures code quality</strong>. When we write tests, we are forced to write code that can be tested. This means that we write code that is modular and loosely coupled. This makes our code base more maintainable and easier to work with. When we find a piece of code that is hard to test, it is a sign that the code is not well written and needs to <span class="No-Break">be refactored.</span></li>
				<li>Writing tests results in <strong class="bold">improved documentation and code understanding</strong>. When we write tests, we are forced to think about how our code works and how it should be used. This makes it easier for other developers to understand our code. While tests can serve as a form of documentation, they should not replace proper <span class="No-Break">code documentation.</span></li>
				<li>Tests help us to <strong class="bold">refactor our code with confidence</strong>. When we have tests in place, we can refactor our code and be sure that we have not broken the existing features in our app that were working well before the refactoring. This is because we can run our tests and see whether they pass <span class="No-Break">or fail.</span></li>
				<li>Tests help us <strong class="bold">test regression</strong>, especially adding new features or modifying existing ones. Tests ensure that the existing functionality still works as before, and nothing has <span class="No-Break">been broken.</span></li>
			</ul>
			<p>These are just to mention a few. There are many more benefits of writing tests, and the best way to realize them is to start writing tests for your code. One important thing to note is that we can also add tests to our <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines to ensure<a id="_idIndexMarker597"/> that our tests run automatically when we push our code to our repositories. This also ensures that as we collaborate with other people on our projects, we can be sure that our code is always in a good state and we can always deploy our code to production <span class="No-Break">with confidence.</span></p>
			<p>In Android, we have a concept called the <strong class="bold">testing pyramid</strong> that helps us to understand the several types of tests that we can write for our <a id="_idIndexMarker598"/>applications and how they relate to each other. The testing <a id="_idIndexMarker599"/>pyramid is divided into three layers, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B19779_12_01.jpg" alt="Figure 12.1 – Testing pyramid" width="1089" height="652"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Testing pyramid</p>
			<p>As shown in the preceding diagram, we have three layers <span class="No-Break">of tests:</span></p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These tests sit at the bottom of the pyramid. These are tests that test a single unit of code in isolation. Unit tests are intended to test the smallest testable parts of an application – typically, methods and functions. They are the fastest to run and are the most reliable. They are also the easiest to write and maintain. Unit tests run on your local machine only. These tests are compiled to run locally on the <strong class="bold">Java Virtual Machine </strong>(<strong class="bold">JVM</strong>) to minimize execution time. For tests that depend on your own dependencies, we use mock objects to provide the external dependencies. <strong class="bold">MockK</strong> and <strong class="bold">Mockito</strong> are popular frameworks for <span class="No-Break">mocking dependencies.</span></li>
				<li><strong class="bold">Integration tests</strong>: These tests<a id="_idIndexMarker600"/> sit in the<a id="_idIndexMarker601"/> middle of the pyramid. They<a id="_idIndexMarker602"/> test how different units of code <a id="_idIndexMarker603"/>work together. They are slower to run than<a id="_idIndexMarker604"/> unit tests. They are also hard to write as they require multiple components and dependencies to work and maintain. <strong class="bold">Roboletric</strong> is a popular framework for writing <span class="No-Break">integration tests.</span></li>
				<li><strong class="bold">UI tests</strong>: These tests sit at the top of the <a id="_idIndexMarker605"/>pyramid. They test how the different components of our app work <a id="_idIndexMarker606"/>together. They are the slowest to run since they run on a real device or emulator and are the least reliable. They are also the <a id="_idIndexMarker607"/>most expensive to write and maintain. There are several frameworks for writing UI tests, including <strong class="bold">Espresso</strong>, <strong class="bold">UI Automator</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Appium</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The testing pyramid presents a way to distribute the tests that we write on our code base. The ideal distribution percentages are <strong class="bold">70% for unit tests</strong>, <strong class="bold">20% for integration tests</strong>, and <strong class="bold">10% for UI tests</strong>. Notice as we go up the pyramid that the number of tests reduces. This is because as we go up the pyramid, the tests become more expensive to write and maintain. This is why<a id="_idIndexMarker608"/> we should strive to write more unit tests than integration tests and more integration tests than <span class="No-Break">UI tests.</span></p>
			<p>Over the next few sections, we will write the tests for the different layers we have discussed. Let us start by testing our database and network layers in <span class="No-Break">our app.</span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor161"/>Testing the network and database layers</h1>
			<p>In this section, we are going to learn how to write tests for our network and database layers step <span class="No-Break">by step.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor162"/>Testing the network layer</h2>
			<p>To test our network layer, we will write <a id="_idIndexMarker609"/>unit tests. However, since we are using Retrofit to make our network requests, we will use <strong class="source-inline">MockWebServer</strong> to mock our network requests. The <strong class="source-inline">MockWebServer </strong>is a library that allows us to mock our network requests. Let us start by setting up the test dependencies in our <span class="No-Break">version catalog:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">libs.version.toml</strong> file and add the following versions in the <span class="No-Break">versions section:</span><pre class="source-code">
mockWebServer = "5.0.0-alpha.2"
coroutinesTest = "1.7.3"
truth = "1.1.5"</pre><p class="list-inset">We are setting up the versions for <strong class="source-inline">mockWebServer</strong>, <strong class="source-inline">coroutinesTest</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">truth</strong></span><span class="No-Break">.</span></p></li>				<li>Next, in the<a id="_idIndexMarker610"/> libraries section, add <span class="No-Break">the following:</span><pre class="source-code">
test-mock-webserver = { module = "com.squareup.okhttp3:mockwebserver", version.ref = "mockWebServer" }
test-coroutines = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-test", version.ref = "coroutinesTest" }
test-truth = { module = "com.google.truth:truth", version.ref = "truth" }</pre><p class="list-inset">Here, we are adding the dependencies for <span class="No-Break">these libraries.</span></p></li>				<li>Next, we will create a bundle so that it is easy to add all test dependencies at once. In the bundle section, add <span class="No-Break">the following:</span><pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth"]</pre></li>				<li>Click on the <strong class="bold">Sync Now</strong> button at the top to add <span class="No-Break">the dependencies.</span></li>
				<li>Lastly, let us head over to the app-level <strong class="source-inline">build.gradle.kts</strong> file and add <span class="No-Break">the following:</span><pre class="source-code">
testImplementation(libs.bundles.test)</pre><p class="list-inset">This will add the test bundle to our <span class="No-Break">test directory.</span></p></li>				<li>Click on the <strong class="bold">Sync Now</strong> button to add the dependencies to <span class="No-Break">our app.</span></li>
			</ol>
			<p>Before we start writing our tests, we need to do several setup tasks. First, we need to create a JSON response for the request that our test <span class="No-Break">will use:</span></p>
			<ol>
				<li>To do this, right-click on the <strong class="source-inline">app</strong> directory, select <strong class="bold">New</strong>, and at the bottom of the pop-up dialog, <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Folder</strong></span><span class="No-Break">.</span></li>
				<li>From the options presented, select <strong class="bold">Java Resources Folder</strong>. This should create a new folder <a id="_idIndexMarker611"/>named <strong class="source-inline">resources</strong>, as shown in the <span class="No-Break">following figure:</span></li>
			</ol>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B19779_12_02.jpg" alt="Figure 12.2 – The resources folder" width="538" height="409"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The resources folder</p>
			<ol>
				<li value="3">Inside this folder, let us create a new JSON file called <strong class="source-inline">catsresponse.json</strong> and add the <span class="No-Break">following JSON:</span><pre class="source-code">
[
  {
    "_id": "eLjLV4oegWGFv9MH",
    "mimetype": "image/png",
    "size": 39927,
    "tags": [
      "cute",
      "pyret"
    ]
  },
  {
    "_id": "PA2gYEbMCzaiDrWv",
    "mimetype": "image/jpeg",
    "size": 59064,
    "tags": [
      "cute",
      "best",
      "siberian",
      "fluffy"
    ]
  },
  {
    "_id": "8PKU6iXscrogXrHm",
    "mimetype": "image/jpeg",
    "size": 60129,
    "tags": [
      "cute",
      "fat",
      "ragdoll",
      "beautiful",
      "sleeping"
    ]
  }
]</pre><p class="list-inset">Our app uses the Cat as a<a id="_idIndexMarker612"/> Service API, which returns a list of cats per the filter you have applied. The API returns this list of cats in a JSON response, as shown previously. When testing, especially with mocked data, the structure and data types of the JSON response should match those of the real API to ensure our tests <span class="No-Break">are correct.</span></p></li>				<li>Now that we have our response ready, we have to create a class that utilizes this response along with our test class in the <strong class="source-inline">com.packt.chaptertwelve (test)</strong> directory shown in the <span class="No-Break">following figure:</span></li>
			</ol>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B19779_12_03.jpg" alt="Figure 12.3 – Test directory" width="424" height="261"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Test directory</p>
			<ol>
				<li value="5">Inside the <strong class="source-inline">com.packt.chaptertwelve (test)</strong> directory, let us create a new Kotlin file called <strong class="source-inline">MockRequestDispatcher.kt</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
import com.google.common.io.Resources
import okhttp3.mockwebserver.Dispatcher
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.RecordedRequest
import java.io.File
import java.net.HttpURLConnection
class MockRequestDispatcher : Dispatcher() {
    override fun dispatch(request: RecordedRequest): MockResponse {
        return when (request.path) {
            "/cats?tag=cute" -&gt; {
                MockResponse()
                    .setResponseCode(HttpURLConnection.HTTP_OK)
                    .setBody(getJson("catsresponse.json"))
            }
            else -&gt; throw IllegalArgumentException("Unknown Request Path ${request.path}")
        }
    }
    private fun getJson(path: String): String {
        val uri = Resources.getResource(path)
        val file = File(uri.path)
        return String(file.readBytes())
    }
}</pre><p class="list-inset">Here is a breakdown <a id="_idIndexMarker613"/>of the <span class="No-Break">preceding code:</span></p><ul><li>We have created a class called <strong class="source-inline">MockRequestDispatcher</strong> that extends <strong class="source-inline">Dispatcher</strong>. This class will be used to mock our <span class="No-Break">network requests.</span></li><li>We override the <strong class="source-inline">dispatch</strong> function, which takes <strong class="source-inline">RecordedRequest</strong> and returns <strong class="source-inline">MockResponse</strong>. This function is called when a request is made to <span class="No-Break">the server.</span></li><li>We check the path of the request, and if it matches the path of our request, we return <strong class="source-inline">MockResponse</strong> with a response code of <strong class="source-inline">200</strong> and a body of the <strong class="source-inline">Json</strong> response that we created earlier. For now, we have only mocked a successful response, but it’s important to handle all the different HTTP response codes and error cases to properly mimic <span class="No-Break">real-world scenarios.</span></li><li>If the path does not match, we <span class="No-Break">throw </span><span class="No-Break"><strong class="source-inline">IllegalArgumentException</strong></span><span class="No-Break">.</span></li><li>Lastly, we create a <strong class="source-inline">getJson</strong> function that takes a path and returns a <strong class="source-inline">String</strong> instance type. This function is used to read the <strong class="source-inline">Json</strong> response from the file that we <span class="No-Break">created earlier.</span></li></ul><p class="list-inset">We can add as many paths as we want to this class. Since our project only has one path, this is all <span class="No-Break">we need.</span></p></li>				<li>Next, let us create our test class. Let us create a new Kotlin file called <strong class="source-inline">CatsAPITest.kt</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
class CatsAPITest {
    private lateinit var mockWebServer: MockWebServer
    private lateinit var catsAPI: CatsAPI
    @Before
    fun setup() {
        // Setup MockWebServer
        mockWebServer = MockWebServer()
        mockWebServer.dispatcher = MockRequestDispatcher()
        mockWebServer.start()
        // Setup Retrofit
        val json = Json {
            ignoreUnknownKeys = true
            isLenient = true
        }
        val retrofit = Retrofit.Builder()
            .baseUrl(mockWebServer.url("/"))
            .addConverterFactory(
                json.asConverterFactory(
                    contentType = "application/json".toMediaType()
                )
            )
            .build()
        catsAPI = retrofit.create(CatsAPI::class.java)
    }
    @Test
    fun `fetchCats() returns a list of cats`() = runTest {
        val response = catsAPI.fetchCats("cute")
        assert(response.isSuccessful)
    }
    @After
    @Throws(IOException::class)
    fun tearDown() {
        mockWebServer.shutdown()
    }
}</pre><p class="list-inset">Here is a breakdown of the <span class="No-Break">preceding code:</span></p><ul><li>We have created a class called <strong class="source-inline">CatsAPITest</strong>. This class will be used to test our <span class="No-Break">network layer.</span></li><li>We have created two variables: <strong class="source-inline">mockWebServer</strong> and <strong class="source-inline">catsAPI</strong>. The <strong class="source-inline">mockWebServer</strong> variable will be used to mock our network requests. The <strong class="source-inline">catsAPI</strong> variable will be <a id="_idIndexMarker614"/>used to make our <span class="No-Break">network reques<a id="_idTextAnchor163"/>ts.</span></li><li>We have the <strong class="source-inline">setup()</strong> function, which is annotated with the <strong class="source-inline">@Before</strong> annotation. This means that this function will run before our tests run. In this function, we have done <span class="No-Break">the following:</span><ul><li>We have created a <strong class="source-inline">MockWebServer</strong> instance and assigned it to the <strong class="source-inline">mockWebServer</strong> variable. We then set the dispatcher of <strong class="source-inline">mockWebServer</strong> to an instance of <strong class="source-inline">MockRequestDispatcher</strong>. This is the class that we created earlier. We then <span class="No-Break">start<a id="_idTextAnchor164"/> </span><span class="No-Break"><strong class="source-inline">mockWebServer</strong></span><span class="No-Break">.</span></li><li>We have created a Retrofit instance and added the <strong class="source-inline">kotlinx-serialization-converter</strong> factory. We then assign the <strong class="source-inline">catsAPI</strong> variable to an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">CatsAPI</strong></span><span class="No-Break">.</span></li></ul></li><li>We have our test function, which is annotated with the <strong class="source-inline">@Test</strong> annotation. This means that this function will be run as a test. In this function, we do <span class="No-Break">the following:</span><ul><li>We wrap the test in the <strong class="source-inline">runTest()</strong> function. This is because we want to test suspending functions. <strong class="source-inline">runTest</strong> is a coroutine test builder designed for testing coroutines. It is part of the <strong class="source-inline">kotlinx-coroutines-test</strong> library that we <span class="No-Break">added earlier.</span></li><li>We make a network <a id="_idIndexMarker615"/>request to <strong class="source-inline">mockWebServer</strong> using the <strong class="source-inline">catsAPI</strong> instance that we created earlier. We then assert that the response <span class="No-Break">is successful.</span></li><li>We have the <strong class="source-inline">tearDown()</strong> function, which is annotated with the <strong class="source-inline">@After</strong> annotation. This means that this function will run after our tests run. This function is used to shut down our <span class="No-Break"><strong class="source-inline">mockWebServer</strong></span><span class="No-Break"> instance.</span></li></ul></li></ul></li>				<li>Press the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <span class="No-Break"><strong class="bold">Run</strong></span><span class="No-Break"> window:</span></li>
			</ol>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B19779_12_04.jpg" alt="Figure 12.4 – Test passing" width="1157" height="528"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Test passing</p>
			<p>As seen in the preceding figure, our test runs successfully. This means that our network layer is working as expected. We <a id="_idIndexMarker616"/>can now move on to testing our <span class="No-Break">database layer.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor165"/>Testing the database layer</h2>
			<p>We are using <strong class="bold">Room</strong> for our<a id="_idIndexMarker617"/> database. To test our database layer, we will write JUnit tests that will run on an Android device. JUnit is <a id="_idIndexMarker618"/>a platform that serves as a foundation for launching testing frameworks. It also provides APIs for writing unit tests that run on the platform. The tests will execute faster than our UI tests since they do not require us to create an activity. This means our test will be in the <strong class="source-inline">androidTest</strong> directory shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B19779_12_05.jpg" alt="Figure 12.5 – Android test directory" width="418" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Android test directory</p>
			<p>Let us create a new file called <strong class="source-inline">CatsDaoTest.kt</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@RunWith(AndroidJUnit4::class)
class CatDaoTest {
    private lateinit var database: CatDatabase
    private lateinit var catDao: CatDao
    @Before
    fun createDatabase() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            CatDatabase::class.java
        ).allowMainThreadQueries().build()
        catDao = database.catDao()
    }
    @After
    fun closeDatabase() {
        database.close()
    }
}</pre>			<p>Here is a breakdown of the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>We have created two variables: <strong class="source-inline">database</strong> and <strong class="source-inline">catDao</strong>. The <strong class="source-inline">database</strong> variable will be used to create an instance of our database. The <strong class="source-inline">catDao</strong> variable will be <a id="_idIndexMarker619"/>used to create an instance of our <span class="No-Break"><strong class="source-inline">CatDao</strong></span><span class="No-Break"> interface.</span></li>
				<li>We have the <strong class="source-inline">createDatabase()</strong> function, which is annotated with the <strong class="source-inline">@Before</strong> annotation. This means that this function will run before our tests run. Inside the function, we create an instance of our database and assign it to the <strong class="source-inline">database</strong> variable. We are using the <span class="No-Break">in-memory database.</span></li>
				<li>We have the <strong class="source-inline">closeDatabase()</strong> function, which is annotated with the <strong class="source-inline">@After</strong> annotation. This means that this function will run after our tests run. This function is used to close <span class="No-Break">our database.</span></li>
			</ul>
			<p>With this done, we can now start <a id="_idIndexMarker620"/>writing <span class="No-Break">our tests:</span></p>
			<ol>
				<li>In the <strong class="source-inline">CatsDaoTest</strong> class, add the following <span class="No-Break">test function:</span><pre class="source-code">
@Test
fun testInsertAndReadCat() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Then the cat is in the database
    val cats = catDao.getCats()
    assert(cats.first().contains(cat))
}</pre><p class="list-inset">In this test, we have created a <strong class="source-inline">CatEntity</strong> object with the details of a cat. We then inserted the details of the cat into the database. Lastly, we assert that the details of the cat are in <span class="No-Break">the database.</span></p></li>				<li>Click on the green <em class="italic">run</em> icon<a id="_idIndexMarker621"/> next to our test class to run our tests. You should see the following output in the <span class="No-Break"><strong class="bold">Run</strong></span><span class="No-Break"> window:</span></li>
			</ol>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B19779_12_06.jpg" alt="Figure 12.6 – Test to insert and read from the database" width="922" height="355"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Test to insert and read from the database</p>
			<p class="list-inset">Our test runs successfully. This means that our database layer is working as expected. Let us add another test that tests adding a cat to <span class="No-Break">the favorites.</span></p>
			<ol>
				<li value="3">Still inside the <strong class="source-inline">CatsDaoTest</strong> class, let us add the following <span class="No-Break">test function:</span><pre class="source-code">
@Test
fun testAddCatToFavorites() = runTest {
    // Given a cat
    val cat = CatEntity(
        id = "1",
        owner = "John Doe",
        tags = listOf("cute", "fluffy"),
        createdAt = "2021-07-01T00:00:00.000Z",
        updatedAt = "2021-07-01T00:00:00.000Z",
        isFavorite = false
    )
    // Insert the cat to the database
    catDao.insert(cat)
    // Favorite the cat
    catDao.update(cat.copy(isFavorite = true))
    // Assert that the cat is in the favorite list
    val favoriteCats = catDao.getFavoriteCats()
    assert(favoriteCats.first().contains(cat.copy(isFavorite = true)))
}</pre><p class="list-inset">In this test, we have created a <strong class="source-inline">CatEntity</strong> object with the details of a cat. We then insert the cat into the<a id="_idIndexMarker622"/> database. We then update the <strong class="source-inline">CatEntity</strong> object, passing <strong class="source-inline">isFavorite</strong> as <strong class="source-inline">true</strong>. Lastly, we assert that the cat is on the <span class="No-Break">favorite list.</span></p></li>				<li>Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <span class="No-Break"><strong class="bold">Run</strong></span><span class="No-Break"> window:</span></li>
			</ol>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B19779_12_07.jpg" alt="Figure 12.7 – Favoriting a cat test" width="976" height="348"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Favoriting a cat test</p>
			<p>Our tests run successfully. This <a id="_idIndexMarker623"/>means that our functionality for adding cats to favorites is <span class="No-Break">working properly.</span></p>
			<p>We have seen how to test our network and database layers. Next, let us test our <span class="No-Break">ViewModel layer.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor166"/>Testing our ViewModels</h1>
			<p>Our <strong class="source-inline">ViewModel</strong> class fetches data<a id="_idIndexMarker624"/> from the repository and exposes it to the UI. To test our <strong class="source-inline">ViewModel</strong>, we will write unit tests. Let us start by setting up the test dependencies in our <span class="No-Break">version catalog:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">libs.version.toml</strong> file and add the following versions in the <span class="No-Break">versions section:</span><pre class="source-code">
mockk = "1.13.3"</pre></li>				<li>Next, in the libraries section, add <span class="No-Break">the following:</span><pre class="source-code">
test-mockk = { module = "io.mockk:mockk", version.ref = "mockk" }</pre></li>				<li>Add the <strong class="source-inline">test-mockk</strong> dependency to the <strong class="source-inline">test</strong> bundle. Our updated <strong class="source-inline">test</strong> bundle should now look <span class="No-Break">like this:</span><pre class="source-code">
test = ["test-mock-webserver", "test-coroutines", "test-truth", "test-mockk"]</pre></li>				<li>Click on the <strong class="bold">Sync Now</strong> button at the top to add the dependencies. Adding <strong class="source-inline">mockk</strong> allows us to mock <span class="No-Break">our dependencies.</span></li>
				<li>We are now ready to create our test class. Create a new Kotlin file called <strong class="source-inline">CatsViewModelTest.kt</strong> inside<a id="_idIndexMarker625"/> the test directory and add the <span class="No-Break">following code:</span><pre class="source-code">
class PetsViewModelTest {
    private val petsRepository = mockk&lt;PetsRepository&gt;(relaxed = true)
    private lateinit var petsViewModel: PetsViewModel
    @Before
    fun setup() {
        Dispatchers.setMain(Dispatchers.Unconfined)
        petsViewModel = PetsViewModel(petsRepository)
    }
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
}</pre><p class="list-inset">Here is a breakdown of the <span class="No-Break">preceding code:</span></p><ul><li>We have created two variables: <strong class="source-inline">petsRepository</strong> and <strong class="source-inline">petsViewModel</strong>. The <strong class="source-inline">petsRepository</strong> variable will be used to mock our <strong class="source-inline">PetsRepository</strong> interface. We used <strong class="source-inline">mockk&lt;PetsRepository&gt;</strong> to provide a mock instance of <strong class="source-inline">PetsRepository</strong>. The <strong class="source-inline">petsViewModel</strong> variable will be used to create an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Pets<a id="_idTextAnchor167"/>ViewModel</strong></span><span class="No-Break">.</span></li><li>We have the <strong class="source-inline">setup()</strong> function, which is annotated with the <strong class="source-inline">@Before</strong> annotation. This means that this function will run before our tests run. We set the main dispatcher to <strong class="source-inline">Dispatchers.Unconfined</strong>. This is because we are using coroutines in our ViewModel. We then assign the <strong class="source-inline">petsViewModel</strong> property to an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PetsViewModel</strong></span><span class="No-Break">.</span></li><li>We have the <strong class="source-inline">tearDown()</strong> function, which is annotated with the <strong class="source-inline">@After</strong> annotation. This means<a id="_idIndexMarker626"/> that this function will run after our tests run. This function is used to reset the <span class="No-Break">main dispatcher.</span></li></ul></li>			</ol>
			<p>With this, we are ready to write our test. Below the <strong class="source-inline">tearDown()</strong> function, add the following <span class="No-Break">test function:</span></p>
			<pre class="source-code">
@Test
fun testGetPets() = runTest {
    val cats = listOf(
        Cat(
            id = "1",
            owner = "John Doe",
            tags = listOf("cute", "fluffy"),
            createdAt = "2021-07-01T00:00:00.000Z",
            updatedAt = "2021-07-01T00:00:00.000Z",
            isFavorite = false
        )
    )
    // Given
    coEvery { petsRepository.getPets() } returns flowOf(cats)
    // When
    petsViewModel.getPets()
    coVerify { petsRepository.getPets() }
    // Then
    val uiState = petsViewModel.petsUIState.value
    assertEquals(cats, uiState.pets)
}</pre>			<p>In this test function, we have created a list of cats. We then mock the <strong class="source-inline">getPets()</strong> function of <strong class="source-inline">PetsRepository</strong> to return a flow of cats. It returns a flow of cats since our <strong class="source-inline">getPets()</strong> function in <strong class="source-inline">PetsRepository</strong> returns <strong class="source-inline">Flow&lt;List&lt;Cat&gt;&gt;</strong>; this way, we mock the correct behavior of this function. We then call the <strong class="source-inline">getPets()</strong> function of <strong class="source-inline">PetsViewModel</strong>. We<a id="_idIndexMarker627"/> then assert that the <strong class="source-inline">getPets()</strong> function of <strong class="source-inline">PetsRepository</strong> is called. Lastly, we assert that the list of cats that we created is the same as the list of cats that we get from <strong class="source-inline">PetsViewModel</strong>. Remember to remove the private marker in our <strong class="source-inline">PetsViewModel</strong> class in case you get an error when trying to access the <strong class="source-inline">getPets()</strong> function. Click on the green <em class="italic">run</em> icon next to our test class to run our tests. You should see the following output in the <span class="No-Break"><strong class="bold">Run</strong></span><span class="No-Break"> window:</span></p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B19779_12_08.jpg" alt="Figure 12.8 – PetsViewModelTest" width="1085" height="253"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – PetsViewModelTest</p>
			<p>Our test runs successfully. This means that our <strong class="source-inline">ViewModel</strong> layer is working as expected. We can now move on to testing our UI layer. In the next section, we will learn how to write UI tests in <span class="No-Break">Jetpack Compose.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor168"/>Adding UI tests to our composables</h1>
			<p>Writing UI tests has been made easier for us. Jetpack Compose <a id="_idIndexMarker628"/>provides a set of testing APIs to find elements, verify their attributes, and <a id="_idIndexMarker629"/>perform actions on these elements. Jetpack<a id="_idIndexMarker630"/> Compose uses <strong class="bold">semantics</strong> to identify<a id="_idIndexMarker631"/> elements in<a id="_idTextAnchor169"/> our composables. Semantics are a way to describe the UI elements in<a id="_idTextAnchor170"/> our composables. Semantics are used by accessibility services to make our apps accessible. Testing dependencies are already set up as we created our new project in <a href="B19779_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> so no need to add any dependencies. We have a number of composables on our project. For this chapter, we will write tests for the <span class="No-Break"><strong class="source-inline">PetListItem</strong></span><span class="No-Break"> composable.</span></p>
			<p>Let us head over to the <strong class="source-inline">PetListItem.kt</strong> file. We need to add a <strong class="source-inline">testTags</strong> modifier to our composable. This is because we are using tags to identify our composables. In the <strong class="source-inline">PetListItem</strong> composable, modify the composable contents to be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ElevatedCard(
    modifier = Modifier
        .fillMaxWidth()
        .padding(6.dp)
        .testTag("PetListItemCard"),
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 10.dp)
            .testTag("PetListItemColumn")
            .clickable {
                onPetClicked(cat)
            }
    ) {
        AsyncImage(
            model = "https://cataas.com/cat/${cat.id}",
            contentDescription = "Cute cat",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp),
            contentScale = ContentScale.FillWidth
        )
        Row(
            modifier = Modifier
                .padding(start = 6.dp, end = 6.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            FlowRow(
                modifier = Modifier
                    .padding(start = 6.dp, end = 6.dp)
            ) {
                repeat(cat.tags.size) {
                    SuggestionChip(
                        modifier = Modifier
                            .padding(start = 3.dp, end = 3.dp),
                        onClick = { },
                        label = {
                            Text(text = cat.tags[it])
                        }
                    )
                }
            }
            Icon(
                modifier = Modifier
                    .testTag("PetListItemFavoriteIcon")
                    .clickable {
                        onFavoriteClicked(cat.copy(isFavorite = !cat.isFavorite))
                    },
                imageVector = if (cat.isFavorite) {
                    Icons.Default.Favorite
                } else {
                    Icons.Default.FavoriteBorder
                },
                contentDescription = "Favorite",
                tint = if (cat.isFavorite) {
                    Color.Red
                } else {
                    Color.Gray
                }
            )
        }
    }
}</pre>			<p>Notice we have added the <strong class="source-inline">testTag()</strong> modifier to our components. With this, we are able to use the Finders APIs in Jetpack Compose to<a id="_idIndexMarker632"/> find our composables. Once we use the finders, we can<a id="_idIndexMarker633"/> perform actions and assert on our composables. Let us now create a new file in our <strong class="source-inline">androidTest</strong> directory called <strong class="source-inline">PetListItemTest.kt</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
class PetListItemTest {
    @get:Rule
    val composeTestRule = createComposeRule()
    @Test
    fun testPetListItem() {
        with(composeTestRule) {
            setContent {
                PetListItem(
                    cat = Cat(
                        id = "1",
                        owner = "John Doe",
                        tags = listOf("cute", "fluffy"),
                        createdAt = "2021-07-01T00:00:00.000Z",
                        updatedAt = "2021-07-01T00:00:00.000Z",
                        isFavorite = false
                    ),
                    onPetClicked = { },
                    onFavoriteClicked = {})
            }
            // Assertions using tags
            onNodeWithTag("PetListItemCard").assertExists()
            onNodeWithTag("PetListItemColumn").assertExists()
            onNodeWithTag("PetListItemFavoriteIcon").assertExists()
            // Assertions using text
            onNodeWithText("fluffy").assertIsDisplayed()
            onNodeWithContentDescription("Favorite").assertIsDisplayed()
            onNodeWithContentDescription("Cute cat").assertIsDisplayed()
            // Actions
            onNodeWithTag("PetListItemFavoriteIcon").performClick()
        }
    }
}</pre>			<p>Here is a <a id="_idIndexMarker634"/>breakdown of the <a id="_idIndexMarker635"/><span class="No-Break">preceding code:</span></p>
			<ul>
				<li>We have created a class called <strong class="source-inline">PetListItemTest</strong>. We will use this class to test our <strong class="source-inline">PetListItem</strong> composable. Inside this class, we have created a rule called <strong class="source-inline">composeTestRule</strong>. This rule will be used to create our com<a id="_idTextAnchor171"/>posables. Through this rule, we can set Compose <a id="_idIndexMarker636"/>content or access <span class="No-Break">our activity.</span></li>
				<li>We have the <strong class="source-inline">testPetListItem()</strong> function, which is annotated with the <strong class="source-inline">@Test</strong> annotation. Several<a id="_idIndexMarker637"/> things are happeni<a id="_idTextAnchor172"/>ng in <span class="No-Break">this function:</span><ul><li>We have used the <strong class="source-inline">with</strong> scoping function to be able to use <strong class="source-inline">composeTestRule</strong>. We then set the content of our composable. In this case, it is the <strong class="source-inline">PetListItem</strong> composable that we want to test. We pass a <strong class="source-inline">cat</strong> object to <span class="No-Break">our composable.</span></li><li>We are using the <strong class="source-inline">onNodeWithTag()</strong> function to find our composables. We then use the <strong class="source-inline">assertExists()</strong> function to assert that the composables exist. This will find our composables using the tags that we <span class="No-Break">added earlier.</span></li><li>We are using the <strong class="source-inline">onNodeWithText()</strong> function to find our composables. We then use the <strong class="source-inline">assertIsDisplayed()</strong> function to assert that the composables exist. We have also used the <strong class="source-inline">onNodeWithContentDescription()</strong> function to find our composables. These two functions help us find composables whose text or content description matches the text or content description that we pass to <span class="No-Break">the function.</span></li><li>Lastly, we are using the <strong class="source-inline">performClick()</strong> function to perform an action on our composables. In this case, we are performing a click action on our <span class="No-Break"><strong class="source-inline">PetListItemFavoriteIcon</strong></span><span class="No-Break"> composable.</span></li></ul></li>
			</ul>
			<p>Click on the green <em class="italic">run</em> icon next to our test class to run our tests. We should see the following output in the <span class="No-Break"><strong class="bold">Run</strong></span><span class="No-Break"> window:</span></p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B19779_12_09.jpg" alt="Figure 12.9 – Jetpack Compose UI tests" width="711" height="129"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Jetpack Compose UI tests</p>
			<p>Our test runs successfully. Additionally, the test is also run on the device that we are working on. We are also able to see the <a id="_idIndexMarker638"/>components being displayed and actions <span class="No-Break">being performed.</span></p>
			<p>We have seen how to write <a id="_idIndexMarker639"/>UI tests in Jetpack Compose. To learn more about testing in Jetpack Compose, check out the official documentation (<a href="https://developer.android.com/jetpack/compose/testing">https://developer.android.com/jetpack/compose/testing</a>). With the knowledge that we have gained in this chapter, we can add more tests to the different layers of our app. You can try adding more tests to test <span class="No-Break">your knowledge.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor173"/>Summary</h1>
			<p>In this chapter, we have learned how to add tests for the different layers in our MVVM architecture. We have learned about the importance of adding tests to our apps and how to add unit tests, integration tests, and <span class="No-Break">instrumentation tests.</span></p>
			<p>In the next chapter, we will learn step-by-step how to publish a new app in the Google Play Store. We will walk through how to create a signed app bundle and the things required for us to publish our first app to the Play Store. Additionally, we will learn about some of the Google Play Store policies and how to always stay compliant to avoid our apps from being removed or accounts from <span class="No-Break">being banned.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer176" class="Content">
			<h1 id="_idParaDest-149" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor174"/>Part 4: Publishing Your App</h1>
			<p>Having successfully developed your app, the next phase unfolds in this part. You will discover the intricacies of publishing your app to the Google Play Store, navigating through crucial Google Play Store policies to ensure a seamless release. You will also dive into the realm of <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>), unlocking the potential to automate routine tasks integral to Android development. You will learn how to seamlessly integrate tests and code analysis tools from <em class="italic">Part 3</em> into your CI/CD pipelines, streamlining development workflows. To conclude this part, you will elevate your app’s performance by incorporating crash reporting tools and enhancing user engagement through the implementation of push notifications, and learn some useful tips on how to secure <span class="No-Break">your app.</span></p>
			<p>This section contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19779_13.xhtml#_idTextAnchor175"><em class="italic">Chapter 13</em></a>, <em class="italic">Publishing Your App</em></li>
				<li><a href="B19779_14.xhtml#_idTextAnchor198"><em class="italic">Chapter 14</em></a>, <em class="italic">Continuous Integration and Continuous Deployment</em></li>
				<li><a href="B19779_15.xhtml#_idTextAnchor215"><em class="italic">Chapter 15</em></a>, <em class="italic">Improving Your App</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer177">
			</div>
		</div>
		<div>
			<div id="_idContainer178">
			</div>
		</div>
		<div>
			<div id="_idContainer179">
			</div>
		</div>
		<div>
			<div id="_idContainer180">
			</div>
		</div>
		<div>
			<div id="_idContainer181">
			</div>
		</div>
		<div>
			<div id="_idContainer182" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer183" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer184">
			</div>
		</div>
		<div>
			<div id="_idContainer185">
			</div>
		</div>
		<div>
			<div id="_idContainer186" class="Basic-Graphics-Frame">
			</div>
		</div>
	</div></div></body></html>