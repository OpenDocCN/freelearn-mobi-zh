- en: <st c="0">11</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 <st c="0">（此处内容为代码，无需翻译）</st>
- en: <st c="3">Creating Pipelines with Combine</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Combine中的管道 <st c="3">（此处内容为代码，无需翻译）</st>
- en: <st c="35">Data flow is a central programming topic, not just in iOS development.</st>
    <st c="107">Indeed, we have many solutions and design patterns to address data
    flow management.</st> <st c="191">It was only in 1997 that the computer science
    world introduced reactive programming – a programming paradigm focusing on data
    streams, enabling</st> <st c="335">declarative composition.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是编程的核心主题，不仅限于iOS开发。<st c="35">实际上，我们有许多解决方案和设计模式来处理数据流管理。</st> <st c="107">确实，直到1997年，计算机科学界才引入了响应式编程——一种关注数据流的编程范式，它使</st>
    <st c="191">（此处内容为代码，无需翻译）</st> <st c="335">（此处内容为代码，无需翻译）</st>
- en: <st c="359">Apple’s version of reactive programming is Combine, a framework
    that provides infrastructure for building data streams in our apps.</st> <st c="492">It
    is also the infrastructure of SwiftUI, enabling it to be a</st> <st c="554">declarative
    framework.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Apple的响应式编程版本是Combine，这是一个提供构建应用中数据流基础设施的框架。<st c="359">（此处内容为代码，无需翻译）</st>
    它也是SwiftUI的基础设施，使其成为一个声明式框架。<st c="492">（此处内容为代码，无需翻译）</st> <st c="554">（此处内容为代码，无需翻译）</st>
- en: <st c="576">In this chapter, we will do</st> <st c="605">the following:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下操作：<st c="576">（此处内容为代码，无需翻译）</st> <st c="605">（此处内容为代码，无需翻译）</st>
- en: <st c="619">Discuss the reasons to use Combine in</st> <st c="658">our projects</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论在项目中使用Combine的原因 <st c="619">（此处内容为代码，无需翻译）</st> <st c="658">（此处内容为代码，无需翻译）</st>
- en: <st c="670">Go over</st> <st c="679">the basics</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习基本知识 <st c="670">（此处内容为代码，无需翻译）</st> <st c="679">（此处内容为代码，无需翻译）</st>
- en: <st c="689">Delve</st> <st c="696">into Combine</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解Combine <st c="689">（此处内容为代码，无需翻译）</st> <st c="696">（此处内容为代码，无需翻译）</st>
- en: <st c="708">Learn about Combine</st> <st c="729">using examples</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例学习Combine <st c="708">（此处内容为代码，无需翻译）</st> <st c="729">（此处内容为代码，无需翻译）</st>
- en: <st c="743">Before we start going over the Combine framework, let’s understand
    why we should</st> <st c="825">use Combine.</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始介绍Combine框架之前，让我们了解为什么我们应该使用Combine。<st c="743">（此处内容为代码，无需翻译）</st> <st
    c="825">（此处内容为代码，无需翻译）</st>
- en: <st c="837">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求 <st c="837">（此处内容为代码，无需翻译）</st>
- en: <st c="860">For this chapter, it’s essential to download Xcode version 16.0
    or higher from the</st> <st c="944">App Store.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，从App Store下载Xcode版本16.0或更高版本是至关重要的。<st c="860">（此处内容为代码，无需翻译）</st> <st
    c="944">（此处内容为代码，无需翻译）</st>
- en: <st c="954">Ensure you’re operating on the most recent version of macOS (Ventura
    or newer).</st> <st c="1035">Just search for Xcode in the App Store, choose the
    latest version, and proceed with the download.</st> <st c="1133">Open Xcode and
    complete any further setup instructions that appear.</st> <st c="1201">After Xcode
    is completely up and running, you</st> <st c="1247">can begin.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您正在使用最新的macOS版本（Ventura或更高版本）。<st c="954">只需在App Store中搜索Xcode，选择最新版本，然后继续下载。</st>
    <st c="1035">打开Xcode并完成出现的任何进一步设置说明。</st> <st c="1133">在Xcode完全运行后，您</st> <st
    c="1201">可以开始。</st>
- en: <st c="1257">Download the sample code from the following GitHub</st> <st c="1309">link:</st>
    [<st c="1315">https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011</st>](https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：<st c="1257">（此处内容为代码，无需翻译）</st> <st c="1309">[Combine框架](https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011)</st>
    <st c="1315">（此处内容为代码，无需翻译）</st>
- en: <st c="1415">Why use Combine?</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Combine？<st c="1415">（此处内容为代码，无需翻译）</st>
- en: <st c="1432">Apple’s Combine framework</st> <st c="1458">is considered to have
    a steep learning curve, but not because it is technically complex.</st> <st c="1548">This
    is because many developers don’t understand why, how, and where they should use
    Combine in</st> <st c="1644">their apps.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Apple的Combine框架被认为学习曲线陡峭，但这并不是因为它在技术上复杂。<st c="1432">（此处内容为代码，无需翻译）</st> <st
    c="1458">（此处内容为代码，无需翻译）</st> 这是因为许多开发者不理解为什么、如何以及在哪里应该在他们的应用中使用Combine。<st c="1548">（此处内容为代码，无需翻译）</st>
    <st c="1644">（此处内容为代码，无需翻译）</st>
- en: <st c="1655">To answer these questions, let’s try to understand Combine.</st>
    <st c="1716">Combine is Apple’s reactive framework and provides a unified API
    for asynchronous events and</st> <st c="1809">data streams.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，让我们尝试了解Combine。<st c="1655">（此处内容为代码，无需翻译）</st> Combine是Apple的响应式框架，它提供了一个统一的API来处理异步事件和数据流。<st
    c="1716">（此处内容为代码，无需翻译）</st> <st c="1809">（此处内容为代码，无需翻译）</st>
- en: <st c="1822">But why do we need a reactive framework?</st> <st c="1864">Don’t
    we have everything</st> <st c="1889">we need?</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要一个响应式框架？<st c="1822">（此处内容为代码，无需翻译）</st> 我们不是已经拥有所有需要的东西了吗？<st c="1864">（此处内容为代码，无需翻译）</st>
    <st c="1889">（此处内容为代码，无需翻译）</st>
- en: <st c="1897">Let’s see what we have in our</st> <st c="1928">iOS SDK:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的iOS SDK中有哪些内容：<st c="1897">（此处内容为代码，无需翻译）</st> <st c="1928">（此处内容为代码，无需翻译）</st>
- en: '**<st c="1936">Notifications</st>** <st c="1950">allow us to send messages</st>
    <st c="1976">that any object</st> <st c="1993">can observe</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1936">通知</st>** <st c="1950">允许我们发送任何对象</st> <st c="1976">都可以观察到的消息</st>'
- en: '**<st c="2004">Delegates</st>** <st c="2014">allow objects to respond</st>
    <st c="2039">to events or changes triggered by</st> <st c="2074">other objects</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2004">代表</st>** <st c="2014">允许对象响应</st> <st c="2039">由其他对象触发的事件或变化</st>
    <st c="2074"></st>'
- en: '**<st c="2087">Closures</st>** <st c="2096">are self-contained functionality</st>
    <st c="2129">blocks we can pass around and call whenever</st> <st c="2174">we
    need</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2087">闭包</st>** <st c="2096">是自包含的功能</st> <st c="2129">块，我们可以传递并随时调用</st>
    <st c="2174"></st>'
- en: '**<st c="2181">Key-Value Observing</st>** <st c="2201">(</st>**<st c="2203">KVO</st>**<st
    c="2206">) allows us to observe value changes</st> <st c="2243">in</st> <st c="2247">object
    property</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2181">键值观察</st>** <st c="2201">(</st>**<st c="2203">KVO</st>**<st
    c="2206">) 允许我们观察对象属性中的值变化</st> <st c="2243"></st>'
- en: <st c="2262">That’s a powerful toolbox!</st> <st c="2290">But while we have
    a toolbox with so many options, these options have some drawbacks we need</st>
    <st c="2382">to discuss.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2262">这是一个强大的工具箱！</st> <st c="2290">但是，虽然我们有一个具有许多选项的工具箱，但这些选项也有一些我们需要</st>
    <st c="2382">讨论的缺点。</st>
- en: <st c="2393">For example, notifications might be considered to be an anti-pattern,
    mainly because they have implicit communication.</st> <st c="2513">Imagine a project
    based on notifications, with objects that mainly communicate with each other using
    the notification center.</st> <st c="2639">That project can take time to manage
    and understand the data flow</st> <st c="2705">and dependencies.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2393">例如，通知可能被认为是一种反模式，主要是因为它们具有隐式通信。</st> <st c="2513">想象一个基于通知的项目，其中对象主要使用通知中心相互通信。</st>
    <st c="2639">该项目可能需要时间来管理和理解数据流</st> <st c="2705">和依赖关系。</st>
- en: <st c="2722">Delegates help with some of these problems.</st> <st c="2767">But
    when we want to pass data between different objects continuously, they require
    us to create many protocols and require each object to call another, making it
    hard to understand</st> <st c="2948">what’s happening.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2722">代表有助于解决这些问题。</st> <st c="2767">但是，当我们想要在不同对象之间连续传递数据时，它们要求我们创建许多协议，并要求每个对象调用另一个对象，这使得理解</st>
    <st c="2948">正在发生的事情变得困难。</st>
- en: <st c="2965">Closures are actually significant progress compared to delegates,
    but they also create complexity when nested or captured by</st> <st c="3091">other
    closures.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2965">与代表相比，闭包实际上是一个显著的进步，但它们在嵌套或被其他闭包捕获时也会创建复杂性。</st>
- en: <st c="3106">Imagine we have a view controller with a view model.</st> <st c="3160">The
    view model has a</st> `<st c="3181">message</st>` <st c="3188">property, and we
    always want UILabel’s text to match the</st> `<st c="3246">message</st>` <st c="3253">property
    value.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3106">想象我们有一个带有视图模型的视图控制器。</st> <st c="3160">视图模型有一个</st> `<st c="3181">消息</st>`
    <st c="3188">属性，我们总是希望UILabel的文本与</st> `<st c="3246">消息</st>` <st c="3253">属性值匹配。</st>
- en: <st c="3269">With Combine, we would do</st> <st c="3296">the following:</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3269">使用Combine，我们会做</st> <st c="3296">以下事情：</st>
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3409">The</st> `<st c="3414">sink</st>` <st c="3418">operator receives
    an update of any change in the</st> `<st c="3468">message</st>` <st c="3475">property
    and has a closure with the new</st> `<st c="3516">message</st>` <st c="3523">property.</st>
    <st c="3534">We store the new</st> `<st c="3551">message</st>` <st c="3558">property
    directly in the label’s</st> <st c="3592">text value.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3409">`<st c="3414">sink</st>` <st c="3418">操作符接收</st> `<st c="3468">消息</st>`
    <st c="3475">属性中任何变化的更新，并有一个包含新</st> `<st c="3516">消息</st>` <st c="3523">属性的闭包。</st>
    <st c="3534">我们直接将新的</st> `<st c="3551">消息</st>` <st c="3558">属性存储在标签的</st> `<st
    c="3592">文本值</st>` 中。</st>
- en: <st c="3603">This example binds the label’s text property to the</st> `<st c="3656">viewModel</st>`
    <st c="3665">text property.</st> <st c="3681">There is no need to define a specific
    interface</st> <st c="3728">for delegating, observing, posting notifications,
    or defining</st> <st c="3791">a closure.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3603">这个例子将标签的文本属性绑定到</st> `<st c="3656">viewModel</st>` <st c="3665">文本属性。</st>
    <st c="3681">不需要定义特定的接口</st> <st c="3728">用于委托、观察、发布通知或定义</st> <st c="3791">闭包。</st>
- en: <st c="3801">Combine has much more to offer, but before we delve into additional
    practical examples, let’s understand</st> <st c="3907">the basics.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3801">Combine有很多东西可以提供，但在我们深入研究更多实际示例之前，让我们先了解</st> <st c="3907">基础知识。</st>
- en: <st c="3918">Going over the basics</st>
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3918">了解基础知识</st>
- en: <st c="3940">As a reactive framework, Combine is built upon components that
    publish updates (the publishers) and components that subscribe to updates (</st><st
    c="4079">the subscribers).</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3940">作为一个响应式框架，Combine建立在发布更新（发布者）和订阅更新（</st><st c="4079">订阅者）的组件之上。</st>
- en: <st c="4097">In between, we’ve got the operators, which can manipulate data
    and control the stream flow.</st> <st c="4190">Let’s get an overview of Combine
    by starting with</st> <st c="4240">the publisher.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4097">在这之间，我们有操作符，它们可以操作数据并控制流。</st> <st c="4190">让我们从</st> <st c="4240">发布者</st>开始，来了解一下Combine的概览。</st>
- en: <st c="4254">Starting with the publisher</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4254">从发布者开始</st>
- en: <st c="4282">The best way to explain</st> <st c="4306">how Combine works</st>
    <st c="4324">is by talking about publishers.</st> **<st c="4357">Publishers</st>**
    <st c="4367">are types that can deliver a sequence of values over time.</st> <st
    c="4427">We saw one example in</st> [*<st c="4449">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="4459">:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4282">解释Combine如何工作的最好方法是通过谈论发布者。</st> **<st c="4357">发布者</st>** <st
    c="4367">是可以随时间传递一系列值的类型。</st> <st c="4427">我们在</st> [*<st c="4449">第10章</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="4459">中看到了一个例子：</st>
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="4507">For a type to be a publisher, it needs to conform to the</st> `<st
    c="4565">Publisher</st>` <st c="4574">protocol, and</st> `<st c="4589">URLSession</st>`
    <st c="4599">is not the only type that does that.</st> `<st c="4637">Timer</st>`
    <st c="4642">and</st> `<st c="4647">NotificationCenter</st>` <st c="4665">are
    also types that have</st> <st c="4691">their publishers:</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4507">为了使一个类型成为发布者，它需要遵守</st> `<st c="4565">发布者</st>` <st c="4574">协议，并且</st>
    `<st c="4589">URLSession</st>` <st c="4599">并不是唯一一个这样做的类型。</st> `<st c="4637">计时器</st>`
    <st c="4642">和</st> `<st c="4647">通知中心</st>` <st c="4665">也是具有它们自己的发布者的类型：</st>
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4789">Or, it can be a</st> `<st c="4806">Timer</st>` <st c="4811">publisher:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4789">或者，它可以是</st> `<st c="4806">计时器</st>` <st c="4811">发布者：</st>
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="4909">For types that don’t have a publisher, we can add one as long as
    their property</st> <st c="4990">is KVO-compliant:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4909">对于没有发布者的类型，只要它们的属性</st> <st c="4990">符合KVO（键值观察）规范，我们就可以添加一个发布者：</st>
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="5184">We can also create a custom</st> <st c="5212">publisher, and we’ll
    learn how to</st> <st c="5246">do that shortly.</st> <st c="5264">The publisher
    emits values only if a subscriber wants to receive them.</st> <st c="5335">So
    next, let’s meet</st> <st c="5355">the subscriber.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5184">我们还可以创建一个自定义的</st> <st c="5212">发布者</st>，我们将在稍后学习如何</st> <st c="5246">做到这一点。</st>
    <st c="5264">发布者只有在订阅者想要接收它们时才会发出值。</st> <st c="5335">所以接下来，让我们来认识</st> <st c="5355">订阅者</st>。</st>
- en: <st c="5370">Setting up the subscriber</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5370">设置订阅者</st>
- en: <st c="5396">A</st> `<st c="5484">Subscriber</st>` <st c="5494">instance is
    located at the end of the stream and handles the incoming values.</st> <st c="5573">The
    Combine framework has two built-in subscribers,</st> `<st c="5625">sink</st>`
    <st c="5629">and</st> `<st c="5634">assign</st>`<st c="5640">; both simplify the
    use of Combine in</st> <st c="5679">most cases.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5396">一个</st> `<st c="5484">订阅者</st>` <st c="5494">实例位于流的末尾，并处理传入的值。</st>
    <st c="5573">Combine框架有两个内置的订阅者，</st> `<st c="5625">接收器</st>` <st c="5629">和</st>
    `<st c="5634">分配</st>`<st c="5640">；两者在大多数情况下都简化了Combine的使用。</st>
- en: <st c="5690">Let’s start</st> <st c="5703">with</st> `<st c="5708">sink</st>`<st
    c="5712">:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5690">让我们从</st> <st c="5703">以下内容</st> `<st c="5708">接收器</st>`<st c="5712">开始：</st>
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="5975">In this code example, we created a</st> `<st c="6011">Timer</st>`
    <st c="6016">publisher that sends a value every second.</st> <st c="6060">The
    value it sends is from the</st> `<st c="6091">date</st>` <st c="6095">type, but
    it doesn’t matter to us – the</st> `<st c="6136">sink</st>` <st c="6140">subscriber
    can receive</st> <st c="6164">any value.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5975">在这个代码示例中，我们创建了一个</st> `<st c="6011">计时器</st>` <st c="6016">发布者，每秒发送一个值。</st>
    <st c="6060">它发送的值来自</st> `<st c="6091">日期</st>` <st c="6095">类型，但这对我们来说并不重要——</st>
    `<st c="6136">接收器</st>` <st c="6140">订阅者可以接收任何值。</st>
- en: <st c="6174">The next thing we do is cancel the subscriber after five seconds.</st>
    <st c="6241">Once no subscriber is listening, the publisher stops sending values.</st>
    <st c="6310">That’s an essential</st> <st c="6329">concept of Combine, called
    a</st> **<st c="6359">demand-driven model</st>**<st c="6378">. With this approach,
    we ensure efficient resource management and avoid performing any work without</st>
    <st c="6478">a goal.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6174">接下来，我们在五秒后取消订阅者。</st> <st c="6241">一旦没有订阅者监听，发布者就停止发送值。</st> <st
    c="6310">这是Combine的一个基本</st> <st c="6329">概念，称为</st> **<st c="6359">需求驱动模型</st>**<st
    c="6378">。使用这种方法，我们确保有效的资源管理，并避免在没有</st> <st c="6478">目标的情况下执行任何工作。</st>
- en: <st c="6485">In this code example, we printed the received value to the console.</st>
    <st c="6554">However, in many cases, we want to assign it to a specific property.</st>
    <st c="6623">For example, we may download a file and receive an update on its
    progress.</st> <st c="6698">In this case, we want to update a progress property
    to show the</st> <st c="6762">download status.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们将接收到的值打印到了控制台。<st c="6554">然而，在许多情况下，我们希望将其分配给特定的属性。</st> <st c="6623">例如，我们可能下载一个文件并接收其进度的更新。</st>
    <st c="6698">在这种情况下，我们希望更新一个进度属性来显示</st> <st c="6762">下载状态。</st>
- en: <st c="6778">We could use the</st> `<st c="6796">sink</st>` <st c="6800">closure</st>
    <st c="6808">to receive the value</st> <st c="6829">and set it to the relevant
    property, but we’ve got a more elegant way, and that’s the</st> `<st c="6916">assign</st>`
    <st c="6922">subscriber:</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6778">我们可以使用</st> `<st c="6796">sink</st>` <st c="6800">闭包</st> <st c="6808">来接收值并将其设置到相关属性，但我们有一个更优雅的方法，那就是</st>
    `<st c="6916">assign</st>` <st c="6922">订阅者：</st>
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="7259">In this example, we have the same timer as the previous example.</st>
    <st c="7325">However, this time, we’ve got an instance of</st> `<st c="7370">DateContainer</st>`
    <st c="7383">with a</st> `<st c="7391">date</st>` <st c="7395">property.</st>
    <st c="7406">The</st> `<st c="7410">assign</st>` <st c="7416">subscriber at the
    end of the stream ensures that we take the received value and assign it to a specific
    property using a</st> <st c="7538">key path.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7259">在这个例子中，我们有一个与上一个例子相同的计时器。</st> <st c="7325">然而，这次我们有一个</st> `<st
    c="7370">DateContainer</st>` <st c="7383">的实例，它有一个</st> `<st c="7391">date</st>`
    <st c="7395">属性。</st> <st c="7406">流末尾的</st> `<st c="7410">assign</st>` <st c="7416">订阅者确保我们使用</st>
    `<st c="7538">键路径</st>` <st c="7542">将接收到的值分配给特定的属性。</st>
- en: <st c="7547">In this case, the</st> `<st c="7566">assign</st>` <st c="7572">subscriber
    input value</st> <st c="7595">must match the publisher</st> <st c="7620">output
    value.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7547">在这种情况下，</st> `<st c="7566">assign</st>` <st c="7572">订阅者输入值</st>
    <st c="7595">必须与发布者</st> <st c="7620">输出值</st>相匹配。
- en: <st c="7634">We obviously can achieve the same results using the</st> `<st c="7687">sink</st>`
    <st c="7691">closure:</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7634">显然，我们可以使用</st> `<st c="7687">sink</st>` <st c="7691">闭包</st> <st
    c="7695">来达到相同的结果：</st>
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="7757">However, using the</st> `<st c="7777">assign</st>` <st c="7783">subscriber
    is far more elegant and more than just semantic.</st> <st c="7844">Using key paths
    improves our code type safety and makes it more declarative</st> <st c="7920">and
    concise.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7757">然而，使用</st> `<st c="7777">assign</st>` <st c="7783">订阅者要优雅得多，而且不仅仅是语义上的。</st>
    <st c="7844">使用键路径提高了我们的代码类型安全性，并使其更加声明性和简洁。</st>
- en: <st c="7932">We’ve learned that the publisher’s output</st> <st c="7974">should
    match the</st> <st c="7992">subscriber’s input.</st> <st c="8012">But what do
    we do if we need to perform some transformations and processing to make that happen?</st>
    <st c="8109">That’s why we have</st> <st c="8128">the operators.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7932">我们已经了解到发布者的输出</st> <st c="7974">应该与</st> <st c="7992">订阅者的输入</st>相匹配。</st>
    <st c="8012">但如果我们需要执行一些转换和处理才能实现这一点怎么办呢？</st> <st c="8109">这就是为什么我们有</st> <st
    c="8128">操作符。</st>
- en: <st c="8142">Connecting operators</st>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8142">连接操作符</st>
- en: <st c="8163">The third part of Combine</st> <st c="8189">streams is the</st>
    **<st c="8205">operator</st>**<st c="8213">. The operator takes upstream</st>
    <st c="8242">data (the output from the previous step), processes it, and emits
    it downstream.</st> <st c="8324">Downstream means the next step – the subscriber
    or</st> <st c="8375">another operator.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8163">Combine流系列的第三部分是</st> **<st c="8205">操作符</st>**<st c="8213">。操作符接收上游</st>
    <st c="8242">数据（前一步骤的输出），对其进行处理，并将其发送到下游。</st> <st c="8324">下游意味着下一步——订阅者或</st>
    <st c="8375">另一个操作符。</st>
- en: <st c="8392">The operators are actually</st> <st c="8419">what helps</st> <st
    c="8430">us build what we call a</st> **<st c="8455">pipeline</st>** <st c="8463">or</st>
    **<st c="8467">Combine stream</st>**<st c="8481">.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8482">Let’s try to build a</st> <st c="8504">simple stream:</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="8691">This simple code example takes an array of numbers between</st>
    `<st c="8751">1</st>` <st c="8752">and</st> `<st c="8757">20</st>`<st c="8759">,
    making it a publisher using the</st> `<st c="8793">publisher</st>` <st c="8802">variable.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="8812">numbersPublisher</st>` <st c="8829">emits a new value from the
    array each time.</st> <st c="8874">The value goes downstream to the</st> `<st
    c="8907">filter</st>` <st c="8913">operator, which republishes the value only
    if it’s even.</st> <st c="8971">The filtered value moves to the</st> `<st c="9003">map</st>`
    <st c="9006">operator, which transforms it into a string message and republishes</st>
    <st c="9075">it again.</st>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9084">At the end of the stream, we have the</st> `<st c="9123">sink</st>`
    <st c="9127">subscriber, which prints the message to</st> <st c="9168">the console.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9180">Congratulations!</st> <st c="9198">We’ve created our first pipeline.</st>
    <st c="9232">Look at</st> *<st c="9240">Figure 11</st>**<st c="9249">.1</st>*<st
    c="9251">:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Our first Combine timeline](img/B21795_11_1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: '<st c="9325">Figure 11.1: Our first Combine timeline</st>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="9364">Figure 11</st>**<st c="9374">.1</st>* <st c="9376">shows the
    different pipeline operators, such as</st> `<st c="9425">filter</st>` <st c="9431">and</st>
    `<st c="9436">map</st>`<st c="9439">. I am highlighting the input and output for
    each operator here.</st> <st c="9504">We can see that the output of one timeline
    component is the input of the</st> <st c="9577">next element.</st>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9590">That leads us to something</st> <st c="9617">we haven’t discussed
    yet – what exactly are publishers</st> <st c="9672">and subscribers?</st> <st
    c="9690">How do they work under the hood?</st> <st c="9723">Let’s</st> <st c="9729">delve
    in.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9738">Delving into Combine components</st>
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="9770">Until now, we have created simple examples</st> <st c="9813">in
    Combine to warm up.</st> <st c="9837">However, if we want to use Combine in a
    more advanced way, we need to understand better what happens under</st> <st c="9944">the
    hood.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9953">The first thing we must understand is that Combine is not magic.</st>
    <st c="10019">Combine alone doesn’t include any sophisticated code.</st> <st c="10073">Ultimately,
    we are talking about a group of protocols that helps us subscribe to changes and
    create a pipeline</st> <st c="10184">of updates.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10195">To delve in, we will review the different protocols and build
    our own custom publishers, operators, and subscribers to understand how things</st>
    <st c="10337">work inside.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10349">Let’s start with</st> <st c="10367">the publisher.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10381">Creating a custom publisher</st>
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10381">创建自定义发布者</st>
- en: <st c="10409">I just mentioned that Combine</st> <st c="10439">is a set of protocols
    that speak with each other, and the publisher is the first protocol we</st> <st
    c="10533">will review.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10409">我刚刚提到，Combine 是一组相互通信的协议，发布者是我们要首先</st> <st c="10533">审查的第一个协议。</st>
- en: <st c="10545">Let’s see what we know up until now about</st> <st c="10588">the
    publisher:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10545">让我们看看到目前为止我们对</st> <st c="10588">发布者</st> <st c="10595">了解到了什么：</st>
- en: <st c="10602">The publisher</st> *<st c="10617">emits values</st>* <st c="10629">to
    one or</st> <st c="10640">more subscribers</st>
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10602">发布者</st> *<st c="10617">向一个或多个订阅者</st> <st c="10629">发出值</st>
- en: <st c="10656">The publisher output type</st> *<st c="10683">must match the</st>*
    *<st c="10698">subscriber’s input</st>*
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10656">发布者输出类型</st> *<st c="10683">必须与</st>* *<st c="10698">订阅者的输入</st>*
- en: <st c="10716">The publisher can also</st> *<st c="10740">deliver errors</st>*
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="10716">发布者还可以</st> *<st c="10740">传递错误</st>*
- en: <st c="10754">Based on that, let’s take our</st> `<st c="10785">Int</st>` <st
    c="10788">array publisher</st> <st c="10805">example and try to create our own
    publisher that</st> <st c="10854">delivers numbers:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10754">基于此，让我们以我们的</st> `<st c="10785">Int</st>` <st c="10788">数组发布者</st>
    <st c="10805">示例为例，尝试创建我们自己的发布者，该发布者</st> <st c="10854">传递数字：</st>
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="11230">The</st> `<st c="11235">CustomNumberPublisher</st>` <st c="11256">class
    has three</st> <st c="11273">essential parts:</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11230">`<st c="11235">CustomNumberPublisher</st>` <st c="11256">类有三个</st>
    <st c="11273">基本部分：</st>
- en: '`<st c="11289">Output</st>` <st c="11296">– This is where we define the publisher
    output type.</st> <st c="11350">In this case, it is an</st> `<st c="11373">Int</st>`
    <st c="11376">type.</st>'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="11289">输出</st>` <st c="11296">– 这是我们定义发布者输出类型的地方。</st> <st c="11350">在这种情况下，它是一个</st>
    `<st c="11373">Int</st>` <st c="11376">类型。</st>'
- en: '`<st c="11382">Failure</st>` <st c="11390">– This is where we define the publisher
    error type.</st> <st c="11443">In this case, the publisher never emits</st> <st
    c="11483">an error.</st>'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="11382">失败</st>` <st c="11390">– 这是我们定义发布者错误类型的地方。</st> <st c="11443">在这种情况下，发布者从不发出</st>
    <st c="11483">错误。</st>'
- en: '`<st c="11492">receive</st>` <st c="11500">– This is the main publisher method.</st>
    <st c="11538">Combine calls the</st> `<st c="11556">receive</st>` <st c="11563">method
    whenever a subscriber subscribes to the publisher.</st> <st c="11622">We can see
    that the</st> `<st c="11642">receive</st>` <st c="11649">function has the subscriber’s
    parameter, and it also verifies that the subscriber input type and error match
    the</st> <st c="11763">publisher definition.</st>'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="11492">receive</st>` <st c="11500">– 这是主要的发布者方法。</st> <st c="11538">Combine
    在订阅者订阅发布者时调用</st> `<st c="11556">receive</st>` <st c="11563">方法。</st> <st c="11622">我们可以看到，</st>
    `<st c="11642">receive</st>` <st c="11649">函数具有订阅者的参数，并且它还验证订阅者输入类型和错误是否与</st>
    <st c="11763">发布者定义匹配。</st>'
- en: <st c="11784">When the publisher wants to emit a new value, it calls the subscriber’s</st>
    `<st c="11857">receive</st>` <st c="11864">method with the new value.</st> <st
    c="11892">When the publisher completes sending values, it calls the subscriber’s</st>
    `<st c="11963">receive</st>` <st c="11970">function with the</st> `<st c="11989">completion</st>`
    <st c="11999">parameter.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11784">当发布者想要发出新值时，它将调用订阅者的</st> `<st c="11857">receive</st>` <st c="11864">方法，并传递新值。</st>
    <st c="11892">当发布者完成发送值时，它将调用订阅者的</st> `<st c="11963">receive</st>` <st c="11970">函数，并传递</st>
    `<st c="11989">completion</st>` <st c="11999">参数。</st>
- en: <st c="12010">Let’s see how we</st> <st c="12028">use</st> `<st c="12032">CustomNumberPublisher</st>`<st
    c="12053">:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12010">让我们看看我们</st> <st c="12028">如何使用</st> `<st c="12032">CustomNumberPublisher</st>`<st
    c="12053">：</st>
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="12152">Running this code will print</st> `<st c="12182">1,2,3,4,5</st>`
    <st c="12191">to the console</st> <st c="12207">as expected.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12152">运行此代码将在控制台打印</st> `<st c="12182">1,2,3,4,5</st>` <st c="12191">，正如预期的那样。</st>
- en: <st c="12219">The</st> `<st c="12224">CustomNumberPublisher</st>` <st c="12245">example
    explains how a publisher works.</st> <st c="12286">But sometimes, we want to send
    values imperatively.</st> <st c="12338">We may wish to implement Combine in an
    existing project code</st> <st c="12398">or</st> <st c="12402">simplify things.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12219">`<st c="12224">CustomNumberPublisher</st>` <st c="12245">示例解释了发布者是如何工作的。</st>
    <st c="12286">但有时，我们希望强制发送值。</st> <st c="12338">我们可能希望在一个现有的项目代码中实现 Combine</st>
    <st c="12398">或</st> <st c="12402">简化事情。</st>
- en: <st c="12418">So, let’s meet a special publisher type</st> <st c="12459">called</st>
    `<st c="12466">Subject</st>`<st c="12473">.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12418">因此，让我们认识一个特殊的发布者类型</st> <st c="12459">，称为</st> `<st c="12466">Subject</st>`<st
    c="12473">。</st>
- en: <st c="12474">Working with Subjects</st>
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12474">与Subjects一起工作</st>
- en: <st c="12496">A</st> `<st c="12597">send(_:)</st>` <st c="12605">method.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12496">一个</st> `<st c="12597">send(_:)</st>` <st c="12605">方法。</st>
- en: <st c="12613">Let’s start with the most basic Subject –</st> `<st c="12656">PassthroughSubject</st>`<st
    c="12674">.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12613">让我们从最基本的Subject——</st> `<st c="12656">PassthroughSubject</st>`<st
    c="12674">。</st>
- en: <st c="12675">Understanding PassthroughSubject</st>
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="12675">理解PassthroughSubject</st>
- en: <st c="12708">Let’s see a basic example</st> <st c="12734">of</st> <st c="12738">Subject
    usage:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12708">让我们看看一个基本的</st> <st c="12734">Subject</st> <st c="12738">使用示例</st>
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="12939">The code example is simple and</st> <st c="12970">easy to follow.</st>
    <st c="12987">We created a</st> `<st c="13000">Subject</st>` <st c="13007">instance
    (which is a publisher) of the</st> `<st c="13047">PassthroughSubject</st>` <st
    c="13065">type.</st> `<st c="13072">PassthroughSubject</st>` <st c="13090">can
    be initialized without any value, and the first time we open a stream is after
    we call its</st> `<st c="13186">send(_:)</st>` <st c="13194">function.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12939">代码示例简单且</st> <st c="12970">易于理解。</st> <st c="12987">我们创建了一个</st>
    `<st c="13000">Subject</st>` <st c="13007">实例（它是一个发布者），其类型为</st> `<st c="13047">PassthroughSubject</st>`
    <st c="13065">。</st> `<st c="13072">PassthroughSubject</st>` <st c="13090">可以不传递任何值进行初始化，并且第一次打开流是在我们调用其</st>
    `<st c="13186">send(_:)</st>` <st c="13194">函数之后。</st>
- en: <st c="13204">Notice that our</st> `<st c="13221">Subject</st>` <st c="13228">is
    just sending values</st> <st c="13251">but never closing the stream.</st> <st
    c="13282">However, we’ve learned from our custom publisher implementation that,
    sometimes, the publisher closes its streams and sends a completion to</st> <st
    c="13422">the subscriber.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13204">请注意，我们的</st> `<st c="13221">Subject</st>` <st c="13228">只是发送值</st>
    <st c="13251">但永远不会关闭流。</st> <st c="13282">然而，我们从自定义发布者实现中学到，有时，发布者会关闭其流并向</st>
    <st c="13422">订阅者发送完成信号。</st>
- en: <st c="13437">We can also use the</st> `<st c="13458">send(_:)</st>` <st c="13466">function
    to close the</st> <st c="13489">Combine stream:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13437">我们还可以使用</st> `<st c="13458">send(_:)</st>` <st c="13466">函数来关闭</st>
    <st c="13489">Combine流</st>：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="13588">In this code example, we use our Subject to send two values –</st>
    `<st c="13651">1</st>` <st c="13652">and</st> `<st c="13657">2</st>`<st c="13658">.
    After sending these values, we close the stream by calling the</st> `<st c="13723">send</st>`
    <st c="13727">function with the</st> `<st c="13746">.</st>``<st c="13747">finished</st>`
    <st c="13756">parameter.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13588">在这个代码示例中，我们使用我们的Subject发送两个值——</st> `<st c="13651">1</st>` <st
    c="13652">和</st> `<st c="13657">2</st>`<st c="13658">。发送这些值后，我们通过调用带有</st> `<st
    c="13723">send</st>` <st c="13727">函数的</st> `<st c="13746">.</st>``<st c="13747">finished</st>`
    <st c="13756">参数来关闭流。</st>
- en: <st c="13767">After that, the Subject tries to send another value (</st>`<st
    c="13821">3</st>`<st c="13823">), but the stream is already closed, and the subscriber
    won’t</st> <st c="13885">receive it.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13767">之后，Subject尝试发送另一个值（</st>`<st c="13821">3</st>`<st c="13823">），但流已经关闭，订阅者将不会</st>
    <st c="13885">收到它。</st>
- en: <st c="13896">The publisher life cycle is crucial to the Combine methodology
    and applies to</st> <st c="13975">our Subjects.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13896">发布者生命周期对于Combine方法至关重要，并且适用于</st> <st c="13975">我们的Subjects。</st>
- en: '`<st c="13988">PassthroughSubject</st>` <st c="14007">is excellent for sending
    values</st> <st c="14039">to subscribers.</st> <st c="14056">However, it’s not
    very good for holding a state.</st> <st c="14105">For example, imagine we want
    to store the current authentication login status or a file download progress.</st>
    <st c="14212">One solution is to store the received value in an instance variable.</st>
    <st c="14281">However, using an instance variable can be cumbersome, especially
    with</st> <st c="14352">several subscribers.</st>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="13988">PassthroughSubject</st>` <st c="14007">非常适合向订阅者发送值</st> <st
    c="14039">。</st> <st c="14056">然而，它并不适合保存状态。</st> <st c="14105">例如，假设我们想要存储当前的认证登录状态或文件下载进度。</st>
    <st c="14212">一个解决方案是将接收到的值存储在实例变量中。</st> <st c="14281">然而，使用实例变量可能会很麻烦，尤其是当有多个订阅者时。</st>'
- en: <st c="14372">Another option is to use another type of Subject</st> <st c="14422">called</st>
    `<st c="14429">CurrentValueSubject</st>`<st c="14448">.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14372">另一个选择是使用另一种类型的Subject</st> <st c="14422">，称为</st> `<st c="14429">CurrentValueSubject</st>`<st
    c="14448">。</st>
- en: <st c="14449">Preserving state with CurrentValueSubject Subject</st>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="14449">使用CurrentValueSubject Subject保持状态</st>
- en: <st c="14499">Unlike</st> `<st c="14507">PassthroughSubject</st>`<st c="14525">,</st>
    `<st c="14527">CurrentValueSubject</st>` <st c="14546">is excellent</st> <st c="14559">for
    holding a state.</st> <st c="14581">It has an initial state and a</st> `<st c="14611">value</st>`
    <st c="14616">property representing the</st> <st c="14643">current value.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与<st c="14499">PassthroughSubject</st><st c="14525">不同，<st c="14527">CurrentValueSubject</st>
    <st c="14546">非常适合用于保存状态。</st> <st c="14581">它有一个初始状态和一个表示当前值的<st c="14611">value</st>
    <st c="14616">属性。</st>
- en: <st c="14657">Let’s see a basic example of</st> `<st c="14687">CurrentValueSubject</st>`
    <st c="14706">usage:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看<st c="14657">CurrentValueSubject</st> <st c="14687">的基本用法示例：</st>
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="14970">In this code example, we create</st> `<st c="15003">CurrentValueSubject</st>`
    <st c="15022">and initialize it with a value (</st>`<st c="15055">"</st>``<st
    c="15057">Initial Value"</st>`<st c="15071">).</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14970">在这个代码示例中，我们创建了一个<st c="15003">CurrentValueSubject</st> <st c="15022">并用一个值（</st>`<st
    c="15055">"</st>``<st c="15057">Initial Value"</st>`<st c="15071">）初始化它。</st>
- en: <st c="15074">We then print the Subject’s current value into the console and
    subscribe to it using a simple</st> `<st c="15169">sink</st>` <st c="15173">function,
    printing each update</st> <st c="15205">as well.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将Subject的当前值打印到控制台，并使用一个简单的<st c="15169">sink</st> <st c="15173">函数订阅它，同时打印每个更新。</st>
    <st c="15205">as well.</st>
- en: <st c="15213">In the last line, we send a new value using</st> <st c="15258">our
    Subject.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们使用我们的Subject发送一个新的值。</st>
- en: <st c="15270">The console, in this case, will show</st> <st c="15308">the following:</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15270">在这种情况下，控制台将显示以下内容：</st>
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<st c="15407">At first glance, the console output looks weird.</st> <st c="15457">Why
    do we see</st> `<st c="15471">Received value: Initial Value</st>` <st c="15500">if
    we have not sent it using the</st> `<st c="15534">send(_:)</st>` <st c="15542">function?</st>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="15407">乍一看，控制台输出看起来很奇怪。</st> <st c="15457">为什么我们没有使用<st c="15471">Received
    value: Initial Value</st> <st c="15500">发送它时，会看到这个值？</st>'
- en: <st c="15552">The answer is that</st> `<st c="15572">CurrentValueSubject</st>`
    <st c="15591">already holds a value when we initialize it, and when we subscribe
    to it for the first time, we already receive the</st> <st c="15708">current value.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15552">答案是，当初始化时，<st c="15572">CurrentValueSubject</st> <st c="15591">已经包含了一个值，当我们第一次订阅它时，我们已经接收到了</st>
    <st c="15708">当前值。</st>
- en: <st c="15722">This is why</st> `<st c="15735">CurrentValueSubject</st>` <st
    c="15754">is excellent for state management.</st> <st c="15790">This behavior
    ensures that our subscribers always sync with the current</st> <st c="15862">Subject
    value.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15722">这就是为什么<st c="15735">CurrentValueSubject</st> <st c="15754">非常适合状态管理的原因。</st>
    <st c="15790">这种行为确保了我们的订阅者始终与当前的</st> <st c="15862">Subject值同步。</st>
- en: '`<st c="15876">PassthroughSubject</st>` <st c="15895">doesn’t have the</st>
    `<st c="15913">value</st>` <st c="15918">property, and we cannot read</st> <st
    c="15947">its current value.</st> <st c="15967">However, the fact that it doesn’t
    emit its values before we call the</st> `<st c="16036">send(_:)</st>` <st c="16044">function
    can be an advantage in</st> <st c="16077">some cases.</st>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15876">PassthroughSubject</st>` <st c="15895">没有<st c="15913">value</st>
    <st c="15918">属性，我们无法读取它的当前值。</st> <st c="15947">然而，它在调用<st c="16036">send(_:)</st>
    <st c="16044">函数之前不发出其值，在某些情况下这可能是一个优势。</st>'
- en: <st c="16088">Let’s see</st> <st c="16099">an example:</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16088">让我们看看</st> <st c="16099">一个例子：</st>
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="16379">In this example, we have two</st> `<st c="16409">PassthroughSubject</st>`
    <st c="16427">publishers and the</st> `<st c="16447">merge()</st>` <st c="16454">operator
    in our Combine stream.</st> <st c="16487">The</st> `<st c="16491">merge()</st>`
    <st c="16498">operator combines the values emitted by both publishers into a single
    stream.</st> <st c="16577">If one of the Subjects sends a value, the</st> `<st
    c="16619">merge()</st>` <st c="16626">operator moves it down</st> <st c="16650">the
    stream.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个<st c="16379">PassthroughSubject</st> <st c="16409">发布者和Combine流中的<st
    c="16427">merge()</st> <st c="16454">操作符。</st> <st c="16487">merge()</st> <st
    c="16498">操作符将两个发布者发出的值合并成一个单独的流。</st> <st c="16577">如果其中一个Subject发送了一个值，<st c="16619">merge()</st>
    <st c="16626">操作符就会将其移动到</st> <st c="16650">流的下方。</st>
- en: <st c="16661">So, in this case, the output will be</st> <st c="16699">as follows:</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16661">因此，在这种情况下，输出将是以下内容：</st>
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`<st c="16794">PassthroughSubject</st>` <st c="16813">can act as an intermediate
    step in the Combine pipeline, allowing us to combine multiple publishers and perform
    data transformations before it reaches the subscribers.</st> <st c="16982">This
    is something we cannot do</st> <st c="17013">with</st> `<st c="17018">CurrentValueSubject</st>`<st
    c="17037">.</st>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16794">PassthroughSubject</st>` <st c="16813">可以作为Combine管道中的中间步骤，允许我们组合多个发布者，并在它到达订阅者之前执行数据转换。</st>
    <st c="16982">这是我们不能使用</st> <st c="17013">`<st c="17018">CurrentValueSubject</st>`<st
    c="17037">`</st> <st c="17038">做到的。</st>'
- en: <st c="17038">Until now, we have used the built-in</st> `<st c="17076">sink</st>`
    <st c="17080">subscriber</st> <st c="17091">to handle the incoming value.</st>
    <st c="17122">But just like the publisher, we can also create a custom subscriber.</st>
    <st c="17191">Learning how to make a custom subscriber can enrich our knowledge
    of Combine.</st> <st c="17269">Let’s</st> <st c="17275">delve in!</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17038">到目前为止，我们一直使用内置的</st> `<st c="17076">sink</st>` <st c="17080">订阅者</st>
    <st c="17091">来处理传入的值。</st> <st c="17122">但就像发布者一样，我们也可以创建一个自定义订阅者。</st> <st c="17191">学习如何创建自定义订阅者可以丰富我们对Combine的了解。</st>
    <st c="17269">让我们</st> <st c="17275">深入探讨！</st>
- en: <st c="17284">Creating a custom subscriber</st>
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17284">创建自定义订阅者</st>
- en: <st c="17313">If the publisher is the element</st> <st c="17345">that delivers
    updates, the subscriber is the element that</st> <st c="17404">demands them.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17313">如果发布者是提供更新的元素，那么订阅者是需求这些更新的元素。</st>
- en: <st c="17417">We already understand that Combine works with a</st> *<st c="17466">supply-and-demand</st>*
    <st c="17483">model.</st> <st c="17491">This means the subscriber needs a mechanism
    to handle and request</st> <st c="17557">incoming values.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17417">我们已经理解Combine使用的是一个</st> *<st c="17466">供需</st> <st c="17483">模型。</st>
    <st c="17491">这意味着订阅者需要一个机制来处理和请求</st> <st c="17557">传入的值。</st>
- en: <st c="17573">Let’s build a subscriber</st> <st c="17599">for</st> `<st c="17603">CustomNumberPublisher</st>`<st
    c="17624">:</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17573">让我们为</st> `<st c="17603">CustomNumberPublisher</st>`<st c="17624">:</st>
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="18000">The subscriber protocol</st> <st c="18024">contains the publisher’s
    corresponding type aliases,</st> `<st c="18078">Input</st>` <st c="18083">and</st>
    `<st c="18088">Failure</st>`<st c="18095">. Both need to match the publisher’s</st>
    `<st c="18132">Output</st>` <st c="18138">and</st> `<st c="18143">Failure</st>`
    <st c="18150">data types.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18000">订阅者协议</st> <st c="18024">包含发布者对应的类型别名，</st> `<st c="18078">Input</st>`
    <st c="18083">和</st> `<st c="18088">Failure</st>`<st c="18095">。两者都需要匹配发布者的</st>
    `<st c="18132">Output</st>` <st c="18138">和</st> `<st c="18143">Failure</st>`
    <st c="18150">数据类型。</st>
- en: <st c="18162">Looking at the subscriber implementation, we can see three more</st>
    `<st c="18227">receive</st>` <st c="18234">functions, which we’ll look at in the</st>
    <st c="18273">next subsections.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18162">查看订阅者实现，我们可以看到三个额外的</st> `<st c="18227">接收</st>` <st c="18234">函数，我们将在</st>
    <st c="18273">下一小节中查看。</st>
- en: '<st c="18290">receive(subscription: Subscription)</st>'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '<st c="18290">接收（subscription: Subscription）</st>'
- en: '`<st c="18326">receive(subscription: Subscription)</st>` <st c="18362">is called
    when the subscriber</st> <st c="18392">subscribes successfully to the publisher.</st>
    <st c="18435">The</st> `<st c="18439">subscription</st>` <st c="18451">object
    handles the subscription, and it has one important method – to define the demand
    from the publisher.</st> <st c="18560">We do that by requesting</st> <st c="18585">unlimited
    values:</st>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18326">接收（subscription: Subscription）</st>` <st c="18362">在订阅者成功订阅发布者时被调用。</st>
    <st c="18392">`<st c="18439">subscription</st>` <st c="18451">对象处理订阅，并且它有一个重要的方法——定义从发布者的需求。</st>
    <st c="18560">我们通过请求</st> <st c="18585">无限值：</st>'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="18635">We can also limit the number of items we’re requesting.</st> <st
    c="18692">For example, let’s request a maximum of three</st> <st c="18738">additional
    items:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18635">我们还可以限制我们请求的项目数量。</st> <st c="18692">例如，让我们请求最多三个</st> <st c="18738">额外项目：</st>
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="18785">We can also request no items</st> <st c="18815">at all:</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18785">我们也可以完全不请求任何项目：</st>
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<st c="18850">Notice that the publisher needs to call the</st> `<st c="18895">receive(subscription:
    Subscription)</st>` <st c="18930">method explicitly.</st> <st c="18950">This means
    that if we build a custom publisher (as in the</st> *<st c="19008">Creating a
    custom publisher</st>* <st c="19035">section), we must ensure that we call that</st>
    <st c="19079">function ourselves.</st>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="18850">注意，发布者需要显式调用</st> `<st c="18895">receive(subscription: Subscription)</st>`
    <st c="18930">方法。</st> <st c="18950">这意味着如果我们构建一个自定义发布者（如</st> *<st c="19008">创建自定义发布者</st>*
    <st c="19035">部分中所述），我们必须确保我们亲自调用该</st> <st c="19079">函数。</st>'
- en: <st c="19098">We need to handle the incoming values now that we have established
    the subscription, and we do that with the</st> `<st c="19208">receive(_input:Int)</st>`
    <st c="19227">method.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19098">现在我们已经建立了订阅，我们需要处理传入的值，我们使用</st> `<st c="19208">receive(_input:Int)</st>`
    <st c="19227">方法来做到这一点。</st>
- en: '<st c="19235">receive(_ input: Int) -> Subscribers.Demand</st>'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '<st c="19235">receive(_ input: Int) -> Subscribers.Demand</st>'
- en: <st c="19279">If we look back</st> <st c="19295">at the</st> `<st c="19303">CustomNumberPublisher</st>`
    <st c="19324">subscriber we created in the</st> *<st c="19354">Creating a custom
    publisher</st>* <st c="19381">section, we can see that our publisher calls the</st>
    <st c="19431">subscriber directly:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19279">如果我们回顾</st> <st c="19295">在</st> `<st c="19303">CustomNumberPublisher</st>`
    <st c="19324">订阅者中创建的</st> *<st c="19354">创建自定义发布者</st>* <st c="19381">部分，我们可以看到我们的发布者直接调用</st>
    <st c="19431">订阅者：</st>
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="19482">That’s the</st> `<st c="19494">receive(_ input:Int)</st>` <st
    c="19514">method we need to implement as part of the subscriber protocol.</st>
    <st c="19579">This method handles the incoming updates, similar to the closure
    we saw in the</st> `<st c="19658">sink</st>` <st c="19662">function (in the</st>
    *<st c="19680">Setting up the</st>* *<st c="19695">Subscriber</st>* <st c="19705">section).</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19482">这就是我们需要作为订阅者协议的一部分实现的</st> `<st c="19494">receive(_ input:Int)</st>`
    <st c="19514">方法。</st> <st c="19579">此方法处理传入的更新，类似于我们在</st> `<st c="19658">sink</st>`
    <st c="19662">函数（在</st> *<st c="19680">设置订阅者</st>* *<st c="19695">部分）中看到的闭包。</st>
- en: <st c="19715">Notice that the</st> `<st c="19732">receive</st>` <st c="19739">function
    returns</st> `<st c="19757">Subscribers.Demand</st>`<st c="19775">. That’s the
    same demand type we discussed in the previous function.</st> <st c="19844">When
    the subscriber finishes handling the input, it must inform the publisher how many
    more items it demands.</st> <st c="19954">Demanding more items doesn’t replace
    the demand sent in the previous function when the subscriber first established
    its subscription to the publisher.</st> <st c="20105">The new demand request is
    an additive value that needs to be handled by</st> <st c="20177">the publisher.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19715">注意，该</st> `<st c="19732">receive</st>` <st c="19739">函数返回</st>
    `<st c="19757">Subscribers.Demand</st>`<st c="19775">。这与我们在上一个函数中讨论的相同的需求类型。</st>
    <st c="19844">当订阅者完成处理输入后，它必须通知发布者它还需要多少项。</st> <st c="19954">请求更多项不会替换订阅者首次向发布者建立订阅时发送的需求。</st>
    <st c="20105">新的需求请求是一个需要由</st> <st c="20177">发布者处理的附加值。</st>
- en: <st c="20191">Look at the</st> <st c="20204">following code:</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20191">查看以下</st> <st c="20204">代码：</st>
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="20390">Let’s try to follow the calls in this</st> <st c="20429">code
    example:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20390">让我们尝试跟随这个</st> <st c="20429">代码示例：</st>
- en: '<st c="20442">The subscriber subscribes to the publisher, and the</st> `<st
    c="20495">receive(subscription: Subscription)</st>` <st c="20530">function is
    called, returning a maximum of</st> `<st c="20574">1</st>`<st c="20575">. The
    total demand is</st> <st c="20597">now</st> `<st c="20601">1</st>`<st c="20602">.</st>'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="20442">订阅者订阅发布者，并调用</st> `<st c="20495">receive(subscription: Subscription)</st>`
    <st c="20530">函数，返回最大值为</st> `<st c="20574">1</st>`<st c="20575">。总需求现在是</st>
    <st c="20597">1</st>`<st c="20601">。</st>'
- en: <st c="20603">The publisher emits a value to the subscriber, and the</st> `<st
    c="20659">receive(_ input:Int)</st>` <st c="20679">function is called, returning
    a maximum of</st> `<st c="20723">3</st>`<st c="20724">. The total demand is</st>
    <st c="20746">now</st> `<st c="20750">4</st>`<st c="20751">.</st>
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20603">发布者向订阅者发出一个值，并调用</st> `<st c="20659">receive(_ input:Int)</st>`
    <st c="20679">函数，返回最大值为</st> `<st c="20723">3</st>`<st c="20724">。总需求现在是</st>
    <st c="20746">4</st>`<st c="20750">。</st>
- en: <st c="20752">As mentioned, it is the publisher’s responsibility</st> <st c="20803">to
    manage the subscriber demand.</st> <st c="20837">If we create our custom publisher,
    we need to</st> <st c="20883">consider that.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20752">如前所述，管理订阅者的需求是</st> <st c="20803">发布者的责任。</st> <st c="20837">如果我们创建自定义发布者，我们需要考虑这一点。</st>
    <st c="20883">。</st>
- en: <st c="20897">Now that we know how to start and manage a subscription, it’s
    no less important to understand how to</st> <st c="20999">complete it.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20897">既然我们知道如何启动和管理订阅，了解如何</st> <st c="20999">完成它同样重要。</st>
- en: '<st c="21011">receive(completion: Subscribers.Completion<Never>)</st>'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '<st c="21011">receive(completion: Subscribers.Completion<Never>)</st>'
- en: <st c="21062">The publisher calls</st> <st c="21082">the subscriber’s</st> `<st
    c="21100">receive(completion:)</st>` <st c="21120">function when it completes
    publishing.</st> <st c="21160">It can be either because the publisher has no updates
    or</st> <st c="21217">an error.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21062">发布者在完成发布时调用</st> <st c="21082">订阅者的</st> `<st c="21100">receive(completion:)</st>`
    <st c="21120">函数。</st> <st c="21160">这可能是因为发布者没有更新，或者</st> <st c="21217">发生了错误。</st>
- en: <st c="21226">That’s where the subscriber needs to perform cleanups, update
    UI or application state, or print logs, mainly when an</st> <st c="21344">error
    occurs.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21226">这就是订阅者需要执行清理、更新UI或应用程序状态或打印日志的地方，主要是在发生</st> <st c="21344">错误时。</st>
- en: <st c="21357">Here’s an example of the</st> `<st c="21383">receive(completion:)</st>`
    <st c="21403">function:</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21357">以下是</st> `<st c="21383">receive(completion:)</st>` <st c="21403">函数的例子：</st>
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="21633">That’s a basic implementation</st> <st c="21663">of the</st> `<st
    c="21671">receive(completion:)</st>` <st c="21691">function.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21633">这是</st> <st c="21663">`receive(completion:)</st>` <st c="21691">函数的基本实现。</st>
- en: <st c="21701">We now know how to create a custom publisher and a custom subscriber.</st>
    <st c="21772">Now, let’s see how to</st> <st c="21794">connect them.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21701">我们现在知道如何创建自定义发布者和自定义订阅者。</st> <st c="21772">现在，让我们看看如何</st> <st
    c="21794">将它们连接起来。</st>
- en: <st c="21807">Connecting the custom publisher and subscriber</st>
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21807">连接自定义发布者和订阅者</st>
- en: <st c="21854">To complete the picture</st> <st c="21878">of how the subscriber
    and the publisher work together, we must return to the publisher and respond to
    our subscriber</st> <st c="21996">demand requests.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21854">为了完整地了解订阅者和发布者如何协同工作，我们必须回到发布者那里，并响应我们的订阅者</st> <st c="21996">需求请求。</st>
- en: <st c="22012">Let’s see an example of how to implement a</st> `<st c="22056">receive</st>`
    <st c="22063">function on the</st> <st c="22080">publisher side:</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22012">让我们看看如何在</st> `<st c="22056">发布者</st>` <st c="22063">端实现一个</st>
    `<st c="22080">接收</st>` <st c="22091">函数的例子：</st>
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="22356">In the code example, the publisher keeps sending more updates
    to the subscriber as long as the subscriber keeps demanding them.</st> <st c="22485">When
    the subscriber stops demanding more updates, the publisher closes the stream and
    calls the subscriber</st> `<st c="22592">receive(completion:)</st>` <st c="22612">function.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22356">在代码示例中，只要订阅者继续要求更多更新，发布者就会继续向订阅者发送更多更新。</st> <st c="22485">当订阅者停止要求更多更新时，发布者关闭流并调用订阅者的</st>
    `<st c="22592">receive(completion:)</st>` <st c="22612">函数。</st>
- en: <st c="22622">At this point, we should be familiar</st> <st c="22659">with how
    subscribers and publishers work together.</st> <st c="22711">We created custom
    publishers and subscribers and performed basic subscriptions.</st> <st c="22791">Let’s
    improve these subscriptions with operators, something we have</st> <st c="22859">barely
    discussed.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22622">在这个阶段，我们应该熟悉</st> <st c="22659">订阅者和发布者如何协同工作。</st> <st c="22711">我们创建了自定义发布者和订阅者并执行了基本订阅。</st>
    <st c="22791">让我们通过操作符来改进这些订阅，这是我们</st> <st c="22859">几乎未讨论过的。</st>
- en: <st c="22876">Working with operators</st>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22876">使用操作符</st>
- en: <st c="22899">Subscriptions and publishers</st> <st c="22928">are great, but
    the true power of Combine comes</st> <st c="22976">from operators.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22899">订阅和发布者</st> <st c="22928">很棒，但Combine的真正力量来自于</st> <st c="22976">操作符。</st>
- en: <st c="22991">Unlike subscriptions and publishers, operators are not protocols
    or instances.</st> <st c="23071">Operators are just publisher methods that republish
    the update downstream and create a chain of data manipulations until the subscriber
    reaches the end of</st> <st c="23226">the pipeline.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22991">与订阅和发布者不同，操作符不是协议或实例。</st> <st c="23071">操作符只是发布者的方法，它们将更新重新发布到下游，并创建一系列数据操作链，直到订阅者到达管道的</st>
    <st c="23226">末端。</st>
- en: <st c="23239">Operators help us modify the updates, filter them, merge them,
    and perform many operations, which allows us to achieve an</st> <st c="23362">ideal
    result.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符帮助我们修改更新、过滤它们、合并它们，并执行许多操作，这使我们能够实现一个理想的结果。
- en: <st c="23375">The Combine framework</st> <st c="23397">comes with many built-in
    operators.</st> <st c="23434">We will go over only some of them now, but you can
    go over the full list at the Apple</st> <st c="23520">website:</st> [<st c="23529">https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators</st>](https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="23375">Combine 框架</st>` 内置了许多运算符。现在我们只介绍其中的一些，但您可以在 Apple 网站上查看完整列表：[<st
    c="23529">https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators</st>](https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators)'
- en: <st c="23615">Let’s start with some</st> <st c="23638">basic operators.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本运算符开始。
- en: <st c="23654">Starting with basic operators</st>
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从基本运算符开始
- en: <st c="23684">One of the most basic use cases for operators in Combine is to</st>
    *<st c="23748">filter</st>* <st c="23754">the updates that the</st> <st c="23776">publisher
    delivers.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Combine 中，运算符最基本的使用案例之一是用于 *<st c="23748">filter</st>* <st c="23754">过滤</st>
    发布者提供的更新。
- en: <st c="23795">For example, we can use the</st> `<st c="23824">filter</st>` <st
    c="23830">operator:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `<st c="23824">filter</st>` 运算符：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="23932">In this code example, we created a publisher that emits values
    from</st> `<st c="24001">1</st>` <st c="24002">to</st> `<st c="24006">10</st>`<st
    c="24008">. The</st> `<st c="24014">filter</st>` <st c="24020">operator ensures
    that only even numbers will continue downstream.</st> <st c="24087">This code
    will print</st> `<st c="24108">2</st>`<st c="24109">,</st> `<st c="24111">4</st>`<st
    c="24112">,</st> `<st c="24114">6</st>`<st c="24115">,</st> `<st c="24117">8</st>`<st
    c="24118">, and</st> `<st c="24124">10</st>` <st c="24126">to</st> <st c="24130">the
    console.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们创建了一个发布者，它会从 `<st c="24001">1</st>` 到 `<st c="24006">10</st>` 发出值。`<st
    c="24014">filter</st>` 运算符确保只有偶数会继续流向下游。这段代码将在控制台打印 `<st c="24108">2</st>`，《st
    c="24109">4</st>`，《st c="24111">6</st>`，《st c="24112">8</st>` 和 `<st c="24114">10</st>`。
- en: <st c="24142">Another example of a filtering operator</st> <st c="24183">is</st>
    `<st c="24186">removeDuplicates</st>`<st c="24202">:</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个过滤运算符的例子是 `<st c="24186">removeDuplicates</st>`：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="24301">The code example shows a publisher that emits duplicate values.</st>
    <st c="24366">The</st> `<st c="24370">removeDuplicates</st>` <st c="24386">operator
    filters out the values in case they were sent in the last update.</st> <st c="24462">The
    console will show</st> <st c="24484">the following:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例显示了一个发布者，它会发出重复的值。`<st c="24370">removeDuplicates</st>` 运算符会过滤掉在最后更新中发送的值。控制台将显示以下内容：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="24508">Let’s try to create a custom operator</st> <st c="24547">to understand
    how an operator</st> <st c="24577">works underneath.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个自定义运算符来了解运算符是如何在底层工作的。
- en: <st c="24594">Creating a custom operator</st>
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义运算符
- en: <st c="24621">When we try to examine</st> <st c="24644">the filter operator</st>
    <st c="24664">in Apple’s header files, we can see</st> <st c="24701">the following:</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试检查 Apple 的头文件中的 `<st c="24644">filter</st>` 运算符时，我们可以看到以下内容：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`<st c="24834">filter()</st>` <st c="24843">is a function that accepts a closure
    with a parameter of a generic type of</st> `<st c="24919">Output</st>` <st c="24925">and
    returns a publisher.</st> <st c="24951">This function extends the</st> `<st c="24977">Publisher</st>`
    <st c="24986">protocol we discussed earlier under</st> *<st c="25023">Creating
    a</st>* *<st c="25034">custom publisher</st>*<st c="25050">.</st>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="24834">filter()</st>` 是一个接受具有 `<st c="24919">Output</st>` 泛型类型参数的闭包并返回发布者的函数。这个函数扩展了我们在
    *<st c="25023">创建</st>* *<st c="25034">自定义发布者</st>* 中讨论的 `<st c="24977">Publisher</st>`
    协议。'
- en: <st c="25051">The important thing to notice here is that the</st> `<st c="25099">filter</st>`
    <st c="25105">function republishes the values and allows multiple operators to
    be chained together to create a complex data</st> <st c="25216">processing pipeline.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25051">这里需要注意的重要事情是，</st> `<st c="25099">过滤器</st>` <st c="25105">函数重新发布值，并允许多个运算符链接在一起以创建复杂的数据</st>
    <st c="25216">处理管道。</st>
- en: <st c="25236">This is similar to how view modifiers work with SwiftUI – they
    modify the current view and return a</st> <st c="25337">new view.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25236">这与 SwiftUI 中的视图修饰符的工作方式类似 – 它们修改当前视图并返回一个新的</st> <st c="25337">视图。</st>
- en: <st c="25346">To create our own custom</st> <st c="25371">operator, let’s try
    to do the same</st> <st c="25406">thing and create a</st> `<st c="25426">multiply</st>`
    <st c="25434">operator.</st> <st c="25445">Our</st> `<st c="25449">multiply</st>`
    <st c="25457">operator accepts an</st> `<st c="25478">Int</st>` <st c="25481">value
    and republishes it while multiplying with a</st> <st c="25532">certain factor:</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25346">要创建我们自己的自定义</st> `<st c="25371">运算符</st>`，让我们尝试做同样的事情并创建一个</st>
    `<st c="25426">乘法</st>` <st c="25434">运算符。</st> <st c="25445">我们的</st> `<st c="25449">乘法</st>`
    <st c="25457">运算符接受一个</st> `<st c="25478">Int</st>` <st c="25481">值，并在乘以一个</st>
    `<st c="25532">特定因子</st>` 的同时重新发布它：</st>
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="25705">In our code example, we also extended the</st> `<st c="25748">Publisher</st>`
    <st c="25757">protocol while ensuring the</st> `<st c="25786">Output</st>` <st
    c="25792">type needs to</st> <st c="25807">be</st> `<st c="25810">Int</st>`<st
    c="25813">.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25705">在我们的代码示例中，我们还扩展了</st> `<st c="25748">发布者</st>` <st c="25757">协议，同时确保</st>
    `<st c="25786">输出</st>` <st c="25792">类型需要是</st> `<st c="25807">Int</st>`<st c="25813">。</st>
- en: <st c="25814">We then create a</st> `<st c="25832">multiply</st>` <st c="25840">function
    that accepts a factor as a parameter and returns a</st> <st c="25901">new publisher.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25814">然后我们创建了一个接受一个因子作为参数并返回一个</st> `<st c="25832">乘法</st>` <st c="25840">函数的新发布者。</st>
- en: <st c="25915">In our implementation, we use a</st> `<st c="25948">map</st>`
    <st c="25951">operator to transform our value into a new one, which means we need
    to return a</st> `<st c="26032">Map</st>` <st c="26035">publisher.</st> <st c="26047">Let’s
    see how to use our</st> <st c="26072">new operator:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25915">在我们的实现中，我们使用了一个</st> `<st c="25948">map</st>` <st c="25951">运算符来将我们的值转换成一个新的值，这意味着我们需要返回一个</st>
    `<st c="26032">Map</st>` <st c="26035">发布者。</st> <st c="26047">让我们看看如何使用我们的</st>
    `<st c="26072">新运算符</st>`：</st>
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="26199">We added our new</st> `<st c="26217">multiply</st>` <st c="26225">operator
    to a Combine stream that starts with an array of five numbers.</st> <st c="26298">The
    output for this code would be</st> <st c="26332">as follows:</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26199">我们添加了我们的新</st> `<st c="26217">乘法</st>` <st c="26225">运算符到以五个数字数组开始的组合流。</st>
    <st c="26298">此代码的输出将如下所示：</st>
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="26434">We created our</st> <st c="26450">first operator!</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26434">我们创建了我们的</st> <st c="26450">第一个运算符！</st>
- en: <st c="26465">However, if you are like me, the return</st> <st c="26505">of
    a new Map publisher</st> <st c="26528">may bother you.</st> <st c="26545">Let’s
    try to understand why it happened and what we can do</st> <st c="26604">about
    it.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26465">然而，如果你像我一样，新地图发布者的返回</st> <st c="26505">可能会让你感到烦恼。</st> <st c="26528">让我们尝试理解为什么会发生这种情况以及我们可以做些什么</st>
    <st c="26604">来解决这个问题。</st>
- en: <st c="26613">Working with AnyPublisher</st>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="26613">与 AnyPublisher 一起工作</st>
- en: <st c="26639">Our intuition says</st> <st c="26658">that if</st> `<st c="26667">multiply</st>`
    <st c="26675">is a function that accepts an</st> `<st c="26706">Int</st>` <st
    c="26709">type and returns</st> <st c="26726">a new value, why do we need to use
    a</st> <st c="26764">Map publisher?</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26639">我们的直觉告诉我们</st> <st c="26658">，如果</st> `<st c="26667">乘法</st>`
    <st c="26675">是一个接受</st> `<st c="26706">Int</st>` <st c="26709">类型并返回新值的函数，为什么我们需要使用一个</st>
    `<st c="26764">Map 发布者</st>`？</st>
- en: <st c="26778">So, we need to remember that operators republish our values.</st>
    <st c="26840">The function doesn’t return a value but rather a publisher that
    publishes the new value.</st> <st c="26929">It might not sound obvious, but our
    goal is to create a chain of publishers and multiply, despite its name, which
    is part of</st> <st c="27054">this chain.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26778">因此，我们需要记住运算符会重新发布我们的值。</st> <st c="26840">函数不返回值，而是返回一个发布新值的发布者。</st>
    <st c="26929">这可能听起来并不明显，但我们的目标是创建一个发布者链，而乘法，尽管其名称如此，是这个链的一部分。</st>
- en: <st c="27065">So, our solution is to return some sort of a</st> *<st c="27111">generic
    publisher</st>*<st c="27128">, or what we call in Combine –</st> `<st c="27159">AnyPublisher</st>`<st
    c="27171">.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27065">因此，我们的解决方案是返回某种类型的</st> *<st c="27111">通用发布者</st>*<st c="27128">，或者在我们
    Combine 中所说的 –</st> `<st c="27159">AnyPublisher</st>`<st c="27171">。</st>
- en: '`<st c="27172">AnyPublisher</st>` <st c="27185">is a type-erased publisher,
    and we use it to present a more abstract interface to</st> <st c="27268">our publishers.</st>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27172">AnyPublisher</st>` <st c="27185">是一个类型擦除发布者，我们用它来向我们的发布者提供一个更抽象的接口。</st>'
- en: <st c="27283">Let’s see our</st> `<st c="27298">multiply</st>` <st c="27306">operator</st>
    <st c="27315">version, which now returns</st> `<st c="27343">AnyPublisher</st>`
    <st c="27355">instead</st> <st c="27363">of</st> `<st c="27367">Publisher.Map</st>`<st
    c="27380">:</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27283">让我们看看我们的</st> `<st c="27298">乘法</st>` <st c="27306">操作符</st> <st
    c="27315">版本，现在它返回</st> `<st c="27343">AnyPublisher</st>` <st c="27355">而不是</st>
    `<st c="27363">Publisher.Map</st>`<st c="27380">：</st>
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="27564">In this code example, we performed</st> <st c="27600">two changes:</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27564">在这个代码示例中，我们进行了</st> <st c="27600">两个更改：</st>
- en: <st c="27612">We changed the function’s return type to</st> `<st c="27654">AnyPublisher<Int,
    Failure></st>`<st c="27680">. In this way, we hide the implementation details
    and the fact that we used the</st> <st c="27760">Map publisher.</st>
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27612">我们将函数的返回类型更改为</st> `<st c="27654">AnyPublisher<Int, Failure></st>`<st
    c="27680">。这样，我们隐藏了实现细节以及我们使用了</st> <st c="27760">Map 发布者</st>的事实。
- en: <st c="27774">We erased the publisher type using the</st> `<st c="27814">eraseToAnyPublisher()</st>`
    <st c="27835">function, which erases the publisher type and</st> <st c="27882">returns</st>
    `<st c="27890">AnyPublisher</st>`<st c="27902">.</st>
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27774">我们使用</st> `<st c="27814">eraseToAnyPublisher()</st>` <st c="27835">函数擦除了发布者类型，该函数擦除发布者类型并</st>
    <st c="27882">返回</st> `<st c="27890">AnyPublisher</st>`<st c="27902">。</st>
- en: <st c="27903">At first glance, it looks like</st> `<st c="27935">AnyPublisher</st>`
    <st c="27947">is there only for semantic reasons.</st> <st c="27984">But when
    I said that returning a Map publisher</st> *<st c="28031">bothers</st>* <st c="28038">me,
    it wasn’t because it didn’t look nice.</st> <st c="28082">It’s because</st> `<st
    c="28095">AnyPublisher</st>` <st c="28107">has practical implications for how
    we build</st> <st c="28152">Combine streams.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27903">乍一看，它似乎</st> `<st c="27935">AnyPublisher</st>` <st c="27947">只是为了语义上的原因。</st>
    <st c="27984">但当我提到返回 Map 发布者</st> *<st c="28031">让我感到烦恼</st>* <st c="28038">时，并不是因为它看起来不漂亮。</st>
    <st c="28082">而是因为</st> `<st c="28095">AnyPublisher</st>` <st c="28107">对我们构建</st>
    <st c="28152">Combine 流的方式有实际的影响。</st>
- en: <st c="28168">One reason is</st> *<st c="28183">API design</st>*<st c="28193">.
    Using</st> `<st c="28201">AnyPublisher</st>` <st c="28213">allows us to design
    a more flexible and polymorphic API interface.</st> <st c="28281">Our previous
    version of the</st> `<st c="28309">multiply</st>` <st c="28317">function returned
    a specific type of publisher.</st> <st c="28366">Returning</st> `<st c="28376">AnyPublisher</st>`
    <st c="28388">makes it easier to chain publishers together because they are from
    the</st> <st c="28460">same type.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28168">一个原因是</st> *<st c="28183">API 设计</st>*<st c="28193">。使用</st> `<st
    c="28201">AnyPublisher</st>` <st c="28213">允许我们设计一个更灵活和多态的 API 接口。</st> <st c="28281">我们之前版本的</st>
    `<st c="28309">乘法</st>` <st c="28317">函数返回了一种特定的发布者类型。</st> <st c="28366">返回</st>
    `<st c="28376">AnyPublisher</st>` <st c="28388">使得将发布者链在一起更容易，因为它们属于同一类型。</st>
- en: <st c="28470">Another reason is</st> *<st c="28489">decoupling</st>* <st c="28499">–
    by returning publishers as</st> `<st c="28529">AnyPublisher</st>`<st c="28541">,
    we’re decoupling our publisher’s implementation from its usage.</st> <st c="28607">By
    that, we make our code more modular</st> <st c="28646">and maintainable.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28470">另一个原因是</st> *<st c="28489">解耦</st>* <st c="28499">– 通过返回</st>
    `<st c="28529">AnyPublisher</st>`<st c="28541">，我们解耦了发布者的实现与其使用。</st> <st c="28607">通过这种方式，我们使代码更加模块化和易于维护。</st>
- en: <st c="28663">The</st> `<st c="28668">filter</st>` <st c="28674">and</st> `<st
    c="28679">removeDuplicates</st>` <st c="28695">operators, along with</st> `<st
    c="28718">map</st>`<st c="28721">, are great for streamlining</st> <st c="28749">and
    manipulating values</st> <st c="28773">along the pipeline.</st> <st c="28794">We
    also reviewed the</st> `<st c="28815">merge</st>` <st c="28820">operator when
    we discussed Subjects in the</st> *<st c="28864">Working with Subjects</st>* <st
    c="28885">section.</st> <st c="28895">But Combine offers more advanced operators.</st>
    <st c="28939">Let’s go over some of</st> <st c="28961">them now.</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28663">The</st> `<st c="28668">filter</st>` <st c="28674">和</st> `<st
    c="28679">removeDuplicates</st>` <st c="28695">操作符，以及</st> `<st c="28718">map</st>`<st
    c="28721">，非常适合简化</st> <st c="28749">和操作管道中的值</st> <st c="28773">。</st> <st c="28794">我们还在讨论*<st
    c="28864">与Subjects一起工作</st>* <st c="28885">部分时回顾了</st> `<st c="28815">merge</st>`
    <st c="28820">操作符。</st> <st c="28895">但是Combine提供了更多高级的操作符。</st> <st c="28939">现在让我们回顾一些</st>
    <st c="28961">它们。</st>
- en: <st c="28970">Exploring advanced operators</st>
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="28970">探索高级操作符</st>
- en: <st c="28999">Let’s face it, up until now, we discussed operators</st> <st c="29051">that
    performed tasks that were easy to do even without Combine.</st> <st c="29116">Yes,
    using</st> `<st c="29127">map</st>` <st c="29130">and</st> `<st c="29135">filter</st>`
    <st c="29141">operators is extremely valuable, but they don’t reflect the real
    Combine</st> <st c="29215">added value.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28999">让我们面对现实，到目前为止，我们讨论了即使没有Combine也容易完成的任务的操作符。</st> <st c="29051">是的，使用</st>
    `<st c="29127">map</st>` `<st c="29130">和</st> `<st c="29135">filter</st>` `<st
    c="29141">操作符非常有价值，但它们并不反映Combine真正的附加价值。</st>
- en: <st c="29227">One of the Combine framework goals is to create much more sophisticated
    and complex streams that can be error-prone to do</st> <st c="29350">without it.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29227">Combine框架的一个目标之一是创建更加复杂和高级的流，这些流在没有它的情况下可能会出错。</st>
- en: <st c="29361">Let’s understand what I mean and explore the</st> `<st c="29407">zip</st>`
    <st c="29410">operator.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29361">让我们理解我的意思并探索</st> `<st c="29407">zip</st>` `<st c="29410">操作符。</st>`
- en: <st c="29420">Using the zip operator</st>
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="29420">使用zip操作符</st>
- en: <st c="29443">The</st> `<st c="29448">zip</st>` <st c="29451">operator combines
    values</st> <st c="29476">from two publishers and emits a tuple only after each
    publisher emits</st> <st c="29547">its value.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29443">The</st> `<st c="29448">zip</st>` <st c="29451">操作符将来自两个发布者的值组合起来，并且只有在每个发布者都发出其值之后才发出一个元组。</st>
- en: <st c="29557">Once the</st> `<st c="29567">zip</st>` <st c="29570">operator
    receives values from all publishers, it emits a tuple and</st> *<st c="29638">resets</st>*
    <st c="29644">itself.</st> <st c="29653">This means it waits again to receive
    values from all publishers before it emits a</st> <st c="29735">new tuple.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29557">一旦zip</st> `<st c="29567">操作符从所有发布者那里收到值，它就会发出一个元组并</st> *<st
    c="29638">重置</st> <st c="29644">自己。</st> <st c="29653">这意味着它再次等待从所有发布者那里接收值，然后才会发出一个新的元组。</st>
- en: <st c="29745">Let’s see a simple</st> <st c="29765">code example:</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29745">让我们看看一个简单的</st> `<st c="29765">代码示例：</st>`
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="30134">In this code example, we used two Subjects</st> <st c="30177">to
    send values to our subscriber.</st> <st c="30212">We zipped them together and
    printed</st> <st c="30248">the output.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30134">在这个代码示例中，我们使用了两个Subject</st> <st c="30177">向我们的订阅者发送值。</st> <st
    c="30212">我们将它们组合在一起并打印</st> <st c="30248">输出。</st>
- en: <st c="30259">We can see that after</st> `<st c="30282">publisher1</st>` <st
    c="30292">sends a value, the stream doesn’t continue and waits for</st> `<st c="30350">publisher2</st>`
    <st c="30360">to send its value.</st> <st c="30380">Only after</st> `<st c="30391">publisher2</st>`
    <st c="30401">sends a value does the stream continue and print</st> `<st c="30451">(1,10)</st>`
    <st c="30457">to the console.</st> <st c="30474">At this point, the</st> `<st
    c="30493">zip</st>` <st c="30496">operator is reset, and again, it waits for both
    publishers to</st> <st c="30559">emit values.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30259">我们可以看到，在</st> `<st c="30282">publisher1</st>` <st c="30292">发送一个值之后，流不会继续，而是等待</st>
    `<st c="30350">publisher2</st>` <st c="30360">发送其值。</st> <st c="30380">只有当</st>
    `<st c="30391">publisher2</st>` <st c="30401">发送一个值后，流才会继续并打印</st> `<st c="30451">(1,10)</st>`
    <st c="30457">到控制台。</st> <st c="30474">此时，</st> `<st c="30493">zip</st>` <st c="30496">操作符被重置，并且再次等待两个发布者都</st>
    <st c="30559">发出值。</st>
- en: <st c="30571">The</st> `<st c="30576">zip</st>` <st c="30579">operator is not
    limited to two publishers.</st> <st c="30623">We can also use</st> `<st c="30639">zip</st>`
    <st c="30642">for three publishers and receive a tuple</st> <st c="30684">of three.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30571">`<st c="30576">zip</st>`</st> <st c="30579">操作符不仅限于两个发布者。</st>
    <st c="30623">我们还可以使用</st> `<st c="30639">zip</st>` <st c="30642">为三个发布者，并接收一个包含三个元素的元组</st>
    <st c="30684">。</st>
- en: <st c="30693">The</st> `<st c="30698">zip</st>` <st c="30701">operator belongs
    to a group of Combine operators that handles multiple publishers together.</st>
    <st c="30794">We already saw the</st> `<st c="30813">merge</st>` <st c="30818">operator
    under the</st> *<st c="30838">Working with</st>* *<st c="30851">Subjec</st><st
    c="30857">ts</st>* <st c="30860">section.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30693">`<st c="30698">zip</st>`</st> <st c="30701">操作符属于一组处理多个发布者的组合操作符。</st>
    <st c="30794">我们已经在</st> `<st c="30813">merge</st>` <st c="30818">操作符下看到了</st>
    *<st c="30838">与</st>* *<st c="30851">主题</st><st c="30857">一起工作</st> <st c="30860">部分。</st>
- en: <st c="30869">Another operator that belongs to this category is</st> `<st c="30920">combineLatest</st>`<st
    c="30933">. Let’s go over</st> <st c="30949">it now.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30869">属于这一类别的另一个操作符是</st> `<st c="30920">combineLatest</st>`<st c="30933">。现在让我们来回顾一下</st>
    <st c="30949">它。</st>
- en: <st c="30956">Combining multiple values using combineLatest</st>
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="30956">使用 combineLatest 组合多个值</st>
- en: <st c="31002">The</st> `<st c="31007">zip</st>` <st c="31010">operator combines</st>
    <st c="31028">multiple publisher</st> <st c="31047">outputs into a tuple.</st>
    <st c="31070">However, it waits for all publishers to send values</st> <st c="31122">each
    time.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31002">`<st c="31007">zip</st>`</st> <st c="31010">操作符将多个发布者的输出组合成一个元组。</st>
    <st c="31070">然而，它每次都等待所有发布者发送值</st> <st c="31122">。</st>
- en: <st c="31132">The</st> `<st c="31137">combineLatest</st>` <st c="31150">operator
    only waits for the first time for all publishers to emit values, and from this
    point, it emits a new tuple each time one of the publishers sends a</st> <st c="31307">new
    value.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31132">`<st c="31137">combineLatest</st>`</st> <st c="31150">操作符只等待所有发布者第一次发出值，从这一点开始，每次其中一个发布者发送一个新值时，它都会发出一个新元组</st>
    <st c="31307">。</st>
- en: <st c="31317">Let’s see an example</st> <st c="31339">of</st> `<st c="31342">combineLatest</st>`<st
    c="31355">:</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31317">让我们看看</st> <st c="31339">`<st c="31342">combineLatest</st>`</st>
    <st c="31355">的一个例子：</st>
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="31726">In this code example, we also have two Subjects</st> <st c="31774">that
    send values.</st> <st c="31793">This time, we combined</st> <st c="31815">them</st>
    <st c="31821">using</st> `<st c="31827">combineLatest</st>`<st c="31840">.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们还有两个<st c="31726">发送值的主题</st> <st c="31774">。</st> <st c="31793">这次，我们使用</st>
    <st c="31815">它们</st> <st c="31821">结合</st> <st c="31827">使用</st> `<st c="31827">combineLatest</st>`<st
    c="31840">。</st>
- en: <st c="31841">After</st> `<st c="31848">publisher1</st>` <st c="31858">sends
    its first value,</st> `<st c="31882">combineLatest</st>` <st c="31895">halts the
    stream as it waits for</st> `<st c="31929">publisher2</st>` <st c="31939">to send</st>
    <st c="31948">a value.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31841">在</st> `<st c="31848">publisher1</st>` <st c="31858">发送了它的第一个值之后，</st>
    `<st c="31882">combineLatest</st>` <st c="31895">停止流，因为它等待</st> `<st c="31929">publisher2</st>`
    <st c="31939">发送一个值。</st>
- en: <st c="31956">Once</st> `<st c="31962">publisher2</st>` <st c="31972">sends
    its first value,</st> `<st c="31996">combineLatest</st>` <st c="32009">emits a
    tuple with the values</st> <st c="32040">of (</st>`<st c="32044">1,10</st>`<st
    c="32049">).</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31956">一旦</st> `<st c="31962">publisher2</st>` <st c="31972">发送了它的第一个值，</st>
    `<st c="31996">combineLatest</st>` <st c="32009">会发出一个包含值（</st>`<st c="32040">1,10</st>`<st
    c="32049">）的元组。</st>
- en: <st c="32052">Next,</st> `<st c="32059">publisher1</st>` <st c="32069">sends
    a new value –</st> `<st c="32090">2</st>`<st c="32091">. This time,</st> `<st
    c="32104">combineLatest</st>` <st c="32117">doesn’t wait for</st> `<st c="32135">publisher2</st>`
    <st c="32145">to send a new value and emits a new tuple – (</st>`<st c="32191">2,10</st>`<st
    c="32196">)</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32052">接下来，</st> `<st c="32059">publisher1</st>` <st c="32069">发送了一个新值——</st>
    `<st c="32090">2</st>`<st c="32091">。这次，</st> `<st c="32104">combineLatest</st>`
    <st c="32117">不需要等待</st> `<st c="32135">publisher2</st>` <st c="32145">发送新值，并发出一个新元组——（</st>`<st
    c="32191">2,10</st>`<st c="32196">）</st>
- en: <st c="32198">The behavior of emitting a new tuple each time one of the publishers
    sends a new value makes</st> `<st c="32291">combineLatest</st>` <st c="32304">a
    top-rated operator for handling</st> <st c="32339">asynchronized operations.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32198">每次其中一个发布者发送新值时，都会发出一个新元组的行为使</st> `<st c="32291">combineLatest</st>`
    <st c="32304">成为处理异步操作的首选操作符。</st>
- en: <st c="32364">Imagine you have a screen being updated by multiple sources, such
    as a search results screen of live sports updates, and each time we get a new
    update, we want our screen to refresh its UI to reflect the</st> <st c="32569">new
    state.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32364">想象一下，你有一个由多个来源更新的屏幕，例如实时体育更新的搜索结果屏幕，并且每次我们得到一个新的更新时，我们希望我们的屏幕刷新其UI以反映<st
    c="32569">新的状态。</st>
- en: '`<st c="32579">combineLatest</st>` <st c="32593">is ideal for such a case,
    as it creates a new tuple downstream whenever one of the publishers emits a</st>
    <st c="32696">new value.</st>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="32579">combineLatest</st>` <st c="32593">在这种情况下是理想的，因为它在任何一个发布者发出新值时都会在下游创建一个新的元组。</st>'
- en: <st c="32706">We can use many more useful</st> <st c="32734">operators; you
    can find</st> <st c="32758">them all on Apple’s website.</st> <st c="32788">However,
    the real challenge with adopting Combine in our projects is understanding how
    to implement them in real-life</st> <st c="32906">use cases.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32706">我们可以使用更多有用的<st c="32734">操作符；你可以在苹果的网站上找到它们。</st> <st c="32788">然而，将Combine应用于我们的项目中的真正挑战是理解如何在现实生活中的用例中实现它们。</st>
- en: <st c="32916">Learning about Combine using examples</st>
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32916">通过示例学习Combine</st>
- en: <st c="32954">Up until now, we have discussed several Combine</st> <st c="33002">components
    and delved into understanding how Combine works underneath by creating our custom
    publishers, subscribers,</st> <st c="33121">and operators.</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32954">到目前为止，我们已经讨论了几个Combine <st c="33002">组件，并通过创建我们的自定义发布者、订阅者和操作符来深入了解Combine是如何工作的。</st>
- en: <st c="33135">Despite that, many developers need help incorporating Combine
    frameworks in</st> <st c="33212">real-life scenarios.</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33135">尽管如此，许多开发者需要帮助将Combine框架整合到<st c="33212">现实场景中。</st>
- en: <st c="33232">The different publishers and operators are mostly clear in theory,
    but it can be difficult to imagine them as part of the central design patterns
    we use in</st> <st c="33389">our projects.</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33232">不同的发布者和操作符在理论上大多是清晰的，但想象它们作为我们项目中使用的中心设计模式的一部分可能会有困难。</st>
- en: <st c="33402">Let’s review some examples to help us understand how to implement
    Combine in our projects.</st> <st c="33494">We’ll start with a basic example of
    managing a UI state in a</st> <st c="33555">view model.</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33402">让我们回顾一些示例，以帮助我们了解如何在我们的项目中实现Combine。</st> <st c="33494">我们将从一个基本的示例开始，该示例在视图模型中管理UI状态。</st>
- en: <st c="33566">Managing UIKit-based view state in a view model</st>
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33566">在视图模型中管理基于UIKit的视图状态</st>
- en: <st c="33614">SwiftUI view states</st> <st c="33634">are naturally</st> <st
    c="33648">declarative.</st> <st c="33662">This means we can bind the view state,
    such as a list of items, to a UI component, such as a</st> `<st c="33755">List</st>`
    <st c="33759">view.</st> <st c="33766">That’s the only way to handle states</st>
    <st c="33803">in SwiftUI.</st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33614">SwiftUI视图状态</st> <st c="33634">自然是声明式的。</st> <st c="33648">这意味着我们可以将视图状态，例如项目列表，绑定到UI组件，例如一个<st
    c="33755">`List`</st> <st c="33759">视图。</st> <st c="33766">这是在SwiftUI中处理状态的唯一方法。</st>
- en: <st c="33814">However, achieving that design pattern in UIKit takes time</st>
    <st c="33874">and effort.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33814">然而，在UIKit中实现该设计模式需要时间和精力。</st>
- en: <st c="33885">Using Combine, we can create a publisher and bind our table view
    data source to reflect any changes coming from</st> <st c="33998">the server.</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33885">使用Combine，我们可以创建一个发布者并将我们的表格视图数据源绑定到反映来自<st c="33998">服务器的任何变化。</st>
- en: <st c="34009">Here’s a code example for such a</st> <st c="34043">view model:</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34009">以下是一个这样的<st c="34043">视图模型</st>的代码示例：</st>
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="34379">We have already discussed</st> <st c="34405">the</st> `<st c="34410">AnyPublisher</st>`
    <st c="34422">form, and that’s a great example</st> <st c="34455">of its usage.</st>
    <st c="34470">We create a publisher that starts with a URL request, extracts its
    data using the</st> `<st c="34552">map</st>` <st c="34555">operator, and decodes
    it into an array of Items.</st> <st c="34605">To hide the publisher implementation,
    we erase its type for</st> `<st c="34665">AnyPublisher</st>`<st c="34677">. Connecting
    the view model to the view controller is simple now that we have</st> <st c="34755">a
    publisher:</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了<st c="34379">`AnyPublisher`</st> <st c="34405">表单，那是一个其用法的好例子。</st>
    <st c="34470">我们创建了一个以URL请求开始的发布者，使用<st c="34552">`map`</st> <st c="34555">操作符提取其数据，并将其解码为Items数组。</st>
    <st c="34605">为了隐藏发布者的实现，我们擦除了`AnyPublisher`的类型。</st> <st c="34677">现在，由于我们有发布者，将视图模型连接到视图控制器变得简单了：</st>
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="34934">In this code example, we subscribe to our new</st> `<st c="34981">dataPublisher</st>`
    <st c="34994">and update our table view with</st> <st c="35026">the data.</st>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34934">在这个代码示例中，我们订阅了我们的新</st> `<st c="34981">dataPublisher</st>` <st
    c="34994">并使用</st> `<st c="35026">数据</st>` <st c="35026">更新我们的表格视图。</st>
- en: <st c="35035">To make our project</st> <st c="35055">even more modular, we can
    move</st> <st c="35086">the</st> `<st c="35091">URLSession</st>` `<st c="35101">dataTaskPublisher</st>`
    <st c="35119">function to a class of its own and keep the separation of</st> <st
    c="35178">concerns principle.</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35035">为了使我们的项目</st> <st c="35055">更加模块化，我们可以将</st> `<st c="35086">URLSession</st>`
    `<st c="35101">dataTaskPublisher</st>` <st c="35119">函数移动到它自己的类中，并保持关注点分离原则。</st>
- en: <st c="35197">Performing searches from multiple sources</st>
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="35197">从多个来源执行搜索</st>
- en: <st c="35239">One of the most popular</st> <st c="35263">use cases of iOS development
    is performing</st> <st c="35306">a search from the server and the</st> <st c="35340">local
    database.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35239">iOS 开发中最受欢迎的</st> <st c="35263">用例之一是从服务器和本地数据库执行搜索。</st>
- en: <st c="35355">The requirement for such a search is first to show results from
    the local data store and then go to the server and</st> <st c="35471">return results.</st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35355">此类搜索的要求首先是显示来自本地数据存储的结果，然后转到服务器并</st> <st c="35471">返回结果。</st>
- en: <st c="35486">This is a common requirement, and using Combine is also easy.</st>
    <st c="35549">Let’s see a simple example</st> <st c="35576">of that:</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35486">这是一个常见的要求，使用 Combine 也很容易。</st> <st c="35549">让我们看看一个简单的例子</st>
    <st c="35576">：</st>
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="36505">In this code</st> <st c="36518">example, we performed</st> <st
    c="36540">three</st> <st c="36547">primary steps:</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36505">在这个代码</st> <st c="36518">示例中，我们执行了</st> <st c="36540">三个</st>
    <st c="36547">主要步骤：</st>
- en: '`<st c="36901">Just</st>` <st c="36905">and</st> `<st c="36910">Future</st>`<st
    c="36916">. We can use</st> `<st c="36929">Just</st>` <st c="36933">to start a
    stream, and</st> `<st c="36957">Future</st>` <st c="36963">is a publisher we use
    to perform a task and emit the</st> <st c="37017">value asynchronously.</st>'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="36901">Just</st>` <st c="36905">和</st> `<st c="36910">Future</st>`<st
    c="36916">。我们可以使用</st> `<st c="36929">Just</st>` <st c="36933">来启动流，而</st> `<st
    c="36957">Future</st>` <st c="36963">是我们用来执行任务并异步发出值的发布者。</st>'
- en: '`<st c="37167">merge</st>` <st c="37172">operator.</st> <st c="37183">Remember
    that the</st> `<st c="37201">merge</st>` <st c="37206">operator emits an update
    if one of its sources emits a new value.</st> <st c="37273">We could also use</st>
    `<st c="37291">combineLatest</st>`<st c="37304">, but</st> `<st c="37310">combineLatest</st>`
    <st c="37323">waits for all the publishers to emit values before it emits the
    combined</st> <st c="37397">value downstream.</st>'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="37167">合并</st>` <st c="37172">操作符。</st> <st c="37183">记住，当其中一个来源发出新值时，<st
    c="37201">合并</st> <st c="37206">操作符会发出更新。</st> <st c="37273">我们也可以使用</st> `<st
    c="37291">combineLatest</st>`<st c="37304">，但</st> `<st c="37310">combineLatest</st>`
    <st c="37323">在发出组合值之前会等待所有发布者发出值。</st>'
- en: '`<st c="37510">totalResults</st>` <st c="37522">array.</st> <st c="37530">Our
    data flow doesn’t have to end here.</st> <st c="37570">We can make</st> `<st c="37582">totalResults</st>`
    <st c="37594">a</st> `<st c="37597">CurrentValueSubject</st>` <st c="37616">instance
    and deliver the results to the view model or the view itself.</st> <st c="37688">If
    we are working with SwiftUI, we can make</st> `<st c="37732">totalResults</st>`
    <st c="37744">a</st> `<st c="37747">@Published</st>` <st c="37757">variable to
    refresh the search results</st> <st c="37797">UI automatically.</st>'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="37510">totalResults</st>` <st c="37522">数组。</st> <st c="37530">我们的数据流不必在这里结束。</st>
    <st c="37570">我们可以将</st> `<st c="37582">totalResults</st>` <st c="37594">转换为</st>
    `<st c="37597">CurrentValueSubject</st>` <st c="37616">实例，并将结果传递给视图模型或视图本身。</st>
    <st c="37688">如果我们使用 SwiftUI，我们可以将</st> `<st c="37732">totalResults</st>` <st
    c="37744">转换为</st> `<st c="37747">@Published</st>` <st c="37757">变量以自动刷新搜索结果的
    UI。</st>'
- en: <st c="37814">There’s a nice lesson here related</st> <st c="37849">to using
    Combine</st> <st c="37866">in our projects.</st> <st c="37884">If we create publishers
    for different data sources and ensure they emit values, it becomes easy to create
    pipelines of updates and connect them to the rest of</st> <st c="38043">the project.</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37814">这里有一个很好的教训，与在我们的项目中使用 Combine 有关。</st> <st c="37849">如果我们为不同的数据源创建发布者并确保它们发出值，那么创建更新管道并将它们连接到项目的其余部分就变得容易了。</st>
- en: <st c="38055">The following example handles another everyday use case, which
    is</st> <st c="38122">form validation.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38055">以下示例处理另一个日常用例，即</st> <st c="38122">表单验证。</st>
- en: <st c="38138">Validating forms</st>
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="38138">表单验证</st>
- en: <st c="38155">Forms are common use cases</st> <st c="38182">in any user-facing
    platform, not just iOS.</st> <st c="38226">One of the most essential responsibilities
    of creating forms is the ability to validate</st> <st c="38314">their inputs.</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38155">表单是任何面向用户的平台中的常见用例，而不仅仅是iOS。</st> <st c="38182">创建表单的最基本责任之一是能够验证</st>
    <st c="38314">它们的输入。</st>
- en: <st c="38327">Let’s see how to use Combine to validate a simple</st> <st c="38378">sign-in
    form:</st>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38327">让我们看看如何使用组合来验证一个简单的</st> <st c="38378">登录表单：</st>
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="38893">Our form contains two text fields –</st> `<st c="38930">username</st>`
    <st c="38938">and</st> `<st c="38943">password</st>`<st c="38951">. We also have
    a view model attached to the view.</st> <st c="39001">The view model has several</st>
    `<st c="39028">@Published</st>` <st c="39038">variables, such as</st> `<st c="39058">username</st>`<st
    c="39066">,</st> `<st c="39068">password</st>`<st c="39076">, and</st> `<st c="39082">isFormValid</st>`<st
    c="39093">. The</st> `<st c="39099">username</st>` <st c="39107">and</st> `<st
    c="39112">password</st>` <st c="39120">variables are connected to the view</st>
    <st c="39157">text fields.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38893">我们的表单包含两个文本字段——</st> `<st c="38930">用户名</st>` <st c="38938">和</st>
    `<st c="38943">密码</st>`<st c="38951">。我们还有一个附加到视图的视图模型。</st> <st c="39001">视图模型有几个</st>
    `<st c="39028">@Published</st>` <st c="39038">变量，例如</st> `<st c="39058">用户名</st>`<st
    c="39066">、</st> `<st c="39068">密码</st>`<st c="39076">和</st> `<st c="39082">isFormValid</st>`<st
    c="39093">。`<st c="39099">用户名</st>` <st c="39107">和</st> `<st c="39112">密码</st>`
    <st c="39120">变量连接到视图</st> `<st c="39157">文本字段。</st>
- en: <st c="39169">Now, let’s see the</st> `<st c="39189">FormViewModel</st>` <st
    c="39202">class:</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39169">现在，让我们看看</st> `<st c="39189">FormViewModel</st>` <st c="39202">类：</st>
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="39606">When we initialize the view</st> <st c="39634">model, we create
    a Combine stream based on the</st> `<st c="39682">combineLatest</st>` <st c="39695">operator
    to observe changes in the</st> `<st c="39731">username</st>` <st c="39739">and</st>
    `<st c="39744">password</st>` <st c="39752">variables.</st> <st c="39764">The</st>
    `<st c="39768">map</st>` <st c="39771">operator ensures that both variables are
    not empty, and we assign the results (</st>`<st c="39851">Bool</st>`<st c="39856">)
    to the</st> `<st c="39866">isFormValid</st>` <st c="39877">variable.</st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39606">当我们初始化视图</st> <st c="39634">模型时</st>，我们基于</st> `<st c="39682">combineLatest</st>`
    <st c="39695">操作符创建一个组合流来观察</st> `<st c="39731">用户名</st>` <st c="39739">和</st>
    `<st c="39744">密码</st>` <st c="39752">变量</st>的变化。<st c="39764">`<st c="39768">map</st>`
    <st c="39771">操作符确保两个变量都不为空，并将结果（</st>`<st c="39851">Bool</st>`<st c="39856">）分配给</st>
    `<st c="39866">isFormValid</st>` <st c="39877">变量。</st>
- en: <st c="39887">The view observes the</st> `<st c="39910">isFormValid</st>` <st
    c="39921">value and uses it to turn the login button on</st> <st c="39968">and
    off.</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39887">视图观察</st> `<st c="39910">isFormValid</st>` <st c="39921">值，并使用它来打开和关闭</st>
    `<st c="39968">登录按钮。</st>
- en: <st c="39976">This stream is basic; we can achieve the same results without
    Combine.</st> <st c="40048">However, forms can become very complex at some point.</st>
    <st c="40102">The Combine pipeline we created is an excellent infrastructure for
    more</st> <st c="40174">complicated forms.</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39976">这个流是基本的；我们可以不使用组合来实现相同的结果。</st> <st c="40048">然而，表单在某些时候可能会变得非常复杂。</st>
    <st c="40102">我们创建的组合管道是更复杂表单的绝佳基础设施。</st>
- en: <st c="40192">Even simple rules for</st> `<st c="40215">username</st>` <st c="40223">and</st>
    `<st c="40228">password</st>` <st c="40236">can be easily enforced using our stream,
    as in</st> <st c="40284">this example:</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40192">即使对于</st> `<st c="40215">用户名</st>` <st c="40223">和</st> `<st c="40228">密码</st>`
    <st c="40236">的简单规则也可以很容易地使用我们的流来强制执行，就像在这个例子中一样：</st>
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="40652">In this code example, we used our Combine stream</st> <st c="40701">to
    enforce rules – the password needs at least eight characters including a number,
    and the username needs at least six characters.</st> <st c="40834">The</st> `<st
    c="40838">map</st>` <st c="40841">operator is great for centralizing this logic,
    outputting a Boolean value, and assigning it to the</st> `<st c="40941">isFormValid</st>`
    <st c="40952">value.</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40652">在这个代码示例中，我们使用我们的组合流</st> <st c="40701">来强制执行规则——密码需要至少包含一个数字的八个字符，用户名需要至少六个字符。</st>
    <st c="40834">`<st c="40838">map</st>` <st c="40841">操作符非常适合集中化这个逻辑，输出一个布尔值，并将其分配给</st>
    `<st c="40941">isFormValid</st>` <st c="40952">值。</st>
- en: <st c="40959">Summary</st>
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="40959">总结</st>
- en: <st c="40967">Combine makes our code reactive beyond SwiftUI views.</st> <st
    c="41022">It’s a framework that can help us handle complex tasks such as search,
    network requests, and</st> <st c="41115">state management.</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40967">Combine使我们的代码在SwiftUI视图之外变得响应式。</st> <st c="41022">它是一个可以帮助我们处理复杂任务，如搜索、网络请求和</st>
    <st c="41115">状态管理。</st>
- en: <st c="41132">This chapter reviewed the basic Combine components, such as the
    publisher, subscriber, and operator.</st> <st c="41234">We also delved in and
    created custom versions of each of the components.</st> <st c="41307">We learned
    how to create pipelines with data transforms and network requests.</st> <st c="41385">In
    the end, we learned how to incorporate Combine in common</st> <st c="41445">use
    cases.</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41132">本章回顾了基本Combine组件，例如发布者、订阅者和操作符。</st> <st c="41234">我们还深入研究了每个组件的定制版本。</st>
    <st c="41307">我们学习了如何创建具有数据转换和网络请求的管道。</st> <st c="41385">最后，我们学习了如何将Combine应用于常见的</st>
    <st c="41445">用例。</st>
- en: <st c="41455">By now, we should be able to start working with Combine on our</st>
    <st c="41519">existing projects.</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41455">到目前为止，我们应该能够开始在现有的</st> <st c="41519">项目中使用Combine。</st>
- en: <st c="41537">The next chapter touches on another topic many iOS developers
    feel irritated by –</st> <st c="41620">Core Data.</st>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41537">下一章将涉及许多iOS开发者感到烦恼的另一个主题——</st> <st c="41620">Core Data。</st>
