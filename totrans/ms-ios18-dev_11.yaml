- en: <st c="0">11</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Creating Pipelines with Combine</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="35">Data flow is a central programming topic, not just in iOS development.</st>
    <st c="107">Indeed, we have many solutions and design patterns to address data
    flow management.</st> <st c="191">It was only in 1997 that the computer science
    world introduced reactive programming – a programming paradigm focusing on data
    streams, enabling</st> <st c="335">declarative composition.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="359">Apple’s version of reactive programming is Combine, a framework
    that provides infrastructure for building data streams in our apps.</st> <st c="492">It
    is also the infrastructure of SwiftUI, enabling it to be a</st> <st c="554">declarative
    framework.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="576">In this chapter, we will do</st> <st c="605">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="619">Discuss the reasons to use Combine in</st> <st c="658">our projects</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="670">Go over</st> <st c="679">the basics</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="689">Delve</st> <st c="696">into Combine</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="708">Learn about Combine</st> <st c="729">using examples</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="743">Before we start going over the Combine framework, let’s understand
    why we should</st> <st c="825">use Combine.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="837">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="860">For this chapter, it’s essential to download Xcode version 16.0
    or higher from the</st> <st c="944">App Store.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="954">Ensure you’re operating on the most recent version of macOS (Ventura
    or newer).</st> <st c="1035">Just search for Xcode in the App Store, choose the
    latest version, and proceed with the download.</st> <st c="1133">Open Xcode and
    complete any further setup instructions that appear.</st> <st c="1201">After Xcode
    is completely up and running, you</st> <st c="1247">can begin.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1257">Download the sample code from the following GitHub</st> <st c="1309">link:</st>
    [<st c="1315">https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011</st>](https://github.com/PacktPublishing/Mastering-iOS-17-Programming-fifth-edition/tree/main/Chapter%2011)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1415">Why use Combine?</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1432">Apple’s Combine framework</st> <st c="1458">is considered to have
    a steep learning curve, but not because it is technically complex.</st> <st c="1548">This
    is because many developers don’t understand why, how, and where they should use
    Combine in</st> <st c="1644">their apps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1655">To answer these questions, let’s try to understand Combine.</st>
    <st c="1716">Combine is Apple’s reactive framework and provides a unified API
    for asynchronous events and</st> <st c="1809">data streams.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1822">But why do we need a reactive framework?</st> <st c="1864">Don’t
    we have everything</st> <st c="1889">we need?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1897">Let’s see what we have in our</st> <st c="1928">iOS SDK:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="1936">Notifications</st>** <st c="1950">allow us to send messages</st>
    <st c="1976">that any object</st> <st c="1993">can observe</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2004">Delegates</st>** <st c="2014">allow objects to respond</st>
    <st c="2039">to events or changes triggered by</st> <st c="2074">other objects</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2087">Closures</st>** <st c="2096">are self-contained functionality</st>
    <st c="2129">blocks we can pass around and call whenever</st> <st c="2174">we
    need</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2181">Key-Value Observing</st>** <st c="2201">(</st>**<st c="2203">KVO</st>**<st
    c="2206">) allows us to observe value changes</st> <st c="2243">in</st> <st c="2247">object
    property</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2262">That’s a powerful toolbox!</st> <st c="2290">But while we have
    a toolbox with so many options, these options have some drawbacks we need</st>
    <st c="2382">to discuss.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2393">For example, notifications might be considered to be an anti-pattern,
    mainly because they have implicit communication.</st> <st c="2513">Imagine a project
    based on notifications, with objects that mainly communicate with each other using
    the notification center.</st> <st c="2639">That project can take time to manage
    and understand the data flow</st> <st c="2705">and dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2722">Delegates help with some of these problems.</st> <st c="2767">But
    when we want to pass data between different objects continuously, they require
    us to create many protocols and require each object to call another, making it
    hard to understand</st> <st c="2948">what’s happening.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2965">Closures are actually significant progress compared to delegates,
    but they also create complexity when nested or captured by</st> <st c="3091">other
    closures.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3106">Imagine we have a view controller with a view model.</st> <st c="3160">The
    view model has a</st> `<st c="3181">message</st>` <st c="3188">property, and we
    always want UILabel’s text to match the</st> `<st c="3246">message</st>` <st c="3253">property
    value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3269">With Combine, we would do</st> <st c="3296">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3409">The</st> `<st c="3414">sink</st>` <st c="3418">operator receives
    an update of any change in the</st> `<st c="3468">message</st>` <st c="3475">property
    and has a closure with the new</st> `<st c="3516">message</st>` <st c="3523">property.</st>
    <st c="3534">We store the new</st> `<st c="3551">message</st>` <st c="3558">property
    directly in the label’s</st> <st c="3592">text value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3603">This example binds the label’s text property to the</st> `<st c="3656">viewModel</st>`
    <st c="3665">text property.</st> <st c="3681">There is no need to define a specific
    interface</st> <st c="3728">for delegating, observing, posting notifications,
    or defining</st> <st c="3791">a closure.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3801">Combine has much more to offer, but before we delve into additional
    practical examples, let’s understand</st> <st c="3907">the basics.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3918">Going over the basics</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3940">As a reactive framework, Combine is built upon components that
    publish updates (the publishers) and components that subscribe to updates (</st><st
    c="4079">the subscribers).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4097">In between, we’ve got the operators, which can manipulate data
    and control the stream flow.</st> <st c="4190">Let’s get an overview of Combine
    by starting with</st> <st c="4240">the publisher.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4254">Starting with the publisher</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4282">The best way to explain</st> <st c="4306">how Combine works</st>
    <st c="4324">is by talking about publishers.</st> **<st c="4357">Publishers</st>**
    <st c="4367">are types that can deliver a sequence of values over time.</st> <st
    c="4427">We saw one example in</st> [*<st c="4449">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)<st
    c="4459">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4507">For a type to be a publisher, it needs to conform to the</st> `<st
    c="4565">Publisher</st>` <st c="4574">protocol, and</st> `<st c="4589">URLSession</st>`
    <st c="4599">is not the only type that does that.</st> `<st c="4637">Timer</st>`
    <st c="4642">and</st> `<st c="4647">NotificationCenter</st>` <st c="4665">are
    also types that have</st> <st c="4691">their publishers:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4789">Or, it can be a</st> `<st c="4806">Timer</st>` <st c="4811">publisher:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4909">For types that don’t have a publisher, we can add one as long as
    their property</st> <st c="4990">is KVO-compliant:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5184">We can also create a custom</st> <st c="5212">publisher, and we’ll
    learn how to</st> <st c="5246">do that shortly.</st> <st c="5264">The publisher
    emits values only if a subscriber wants to receive them.</st> <st c="5335">So
    next, let’s meet</st> <st c="5355">the subscriber.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5370">Setting up the subscriber</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5396">A</st> `<st c="5484">Subscriber</st>` <st c="5494">instance is
    located at the end of the stream and handles the incoming values.</st> <st c="5573">The
    Combine framework has two built-in subscribers,</st> `<st c="5625">sink</st>`
    <st c="5629">and</st> `<st c="5634">assign</st>`<st c="5640">; both simplify the
    use of Combine in</st> <st c="5679">most cases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5690">Let’s start</st> <st c="5703">with</st> `<st c="5708">sink</st>`<st
    c="5712">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5975">In this code example, we created a</st> `<st c="6011">Timer</st>`
    <st c="6016">publisher that sends a value every second.</st> <st c="6060">The
    value it sends is from the</st> `<st c="6091">date</st>` <st c="6095">type, but
    it doesn’t matter to us – the</st> `<st c="6136">sink</st>` <st c="6140">subscriber
    can receive</st> <st c="6164">any value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6174">The next thing we do is cancel the subscriber after five seconds.</st>
    <st c="6241">Once no subscriber is listening, the publisher stops sending values.</st>
    <st c="6310">That’s an essential</st> <st c="6329">concept of Combine, called
    a</st> **<st c="6359">demand-driven model</st>**<st c="6378">. With this approach,
    we ensure efficient resource management and avoid performing any work without</st>
    <st c="6478">a goal.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6485">In this code example, we printed the received value to the console.</st>
    <st c="6554">However, in many cases, we want to assign it to a specific property.</st>
    <st c="6623">For example, we may download a file and receive an update on its
    progress.</st> <st c="6698">In this case, we want to update a progress property
    to show the</st> <st c="6762">download status.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6778">We could use the</st> `<st c="6796">sink</st>` <st c="6800">closure</st>
    <st c="6808">to receive the value</st> <st c="6829">and set it to the relevant
    property, but we’ve got a more elegant way, and that’s the</st> `<st c="6916">assign</st>`
    <st c="6922">subscriber:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7259">In this example, we have the same timer as the previous example.</st>
    <st c="7325">However, this time, we’ve got an instance of</st> `<st c="7370">DateContainer</st>`
    <st c="7383">with a</st> `<st c="7391">date</st>` <st c="7395">property.</st>
    <st c="7406">The</st> `<st c="7410">assign</st>` <st c="7416">subscriber at the
    end of the stream ensures that we take the received value and assign it to a specific
    property using a</st> <st c="7538">key path.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7547">In this case, the</st> `<st c="7566">assign</st>` <st c="7572">subscriber
    input value</st> <st c="7595">must match the publisher</st> <st c="7620">output
    value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7634">We obviously can achieve the same results using the</st> `<st c="7687">sink</st>`
    <st c="7691">closure:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7757">However, using the</st> `<st c="7777">assign</st>` <st c="7783">subscriber
    is far more elegant and more than just semantic.</st> <st c="7844">Using key paths
    improves our code type safety and makes it more declarative</st> <st c="7920">and
    concise.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7932">We’ve learned that the publisher’s output</st> <st c="7974">should
    match the</st> <st c="7992">subscriber’s input.</st> <st c="8012">But what do
    we do if we need to perform some transformations and processing to make that happen?</st>
    <st c="8109">That’s why we have</st> <st c="8128">the operators.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8142">Connecting operators</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="8163">The third part of Combine</st> <st c="8189">streams is the</st>
    **<st c="8205">operator</st>**<st c="8213">. The operator takes upstream</st>
    <st c="8242">data (the output from the previous step), processes it, and emits
    it downstream.</st> <st c="8324">Downstream means the next step – the subscriber
    or</st> <st c="8375">another operator.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8392">The operators are actually</st> <st c="8419">what helps</st> <st
    c="8430">us build what we call a</st> **<st c="8455">pipeline</st>** <st c="8463">or</st>
    **<st c="8467">Combine stream</st>**<st c="8481">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8482">Let’s try to build a</st> <st c="8504">simple stream:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8691">This simple code example takes an array of numbers between</st>
    `<st c="8751">1</st>` <st c="8752">and</st> `<st c="8757">20</st>`<st c="8759">,
    making it a publisher using the</st> `<st c="8793">publisher</st>` <st c="8802">variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="8812">numbersPublisher</st>` <st c="8829">emits a new value from the
    array each time.</st> <st c="8874">The value goes downstream to the</st> `<st
    c="8907">filter</st>` <st c="8913">operator, which republishes the value only
    if it’s even.</st> <st c="8971">The filtered value moves to the</st> `<st c="9003">map</st>`
    <st c="9006">operator, which transforms it into a string message and republishes</st>
    <st c="9075">it again.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9084">At the end of the stream, we have the</st> `<st c="9123">sink</st>`
    <st c="9127">subscriber, which prints the message to</st> <st c="9168">the console.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9180">Congratulations!</st> <st c="9198">We’ve created our first pipeline.</st>
    <st c="9232">Look at</st> *<st c="9240">Figure 11</st>**<st c="9249">.1</st>*<st
    c="9251">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Our first Combine timeline](img/B21795_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="9325">Figure 11.1: Our first Combine timeline</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="9364">Figure 11</st>**<st c="9374">.1</st>* <st c="9376">shows the
    different pipeline operators, such as</st> `<st c="9425">filter</st>` <st c="9431">and</st>
    `<st c="9436">map</st>`<st c="9439">. I am highlighting the input and output for
    each operator here.</st> <st c="9504">We can see that the output of one timeline
    component is the input of the</st> <st c="9577">next element.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9590">That leads us to something</st> <st c="9617">we haven’t discussed
    yet – what exactly are publishers</st> <st c="9672">and subscribers?</st> <st
    c="9690">How do they work under the hood?</st> <st c="9723">Let’s</st> <st c="9729">delve
    in.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9738">Delving into Combine components</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="9770">Until now, we have created simple examples</st> <st c="9813">in
    Combine to warm up.</st> <st c="9837">However, if we want to use Combine in a
    more advanced way, we need to understand better what happens under</st> <st c="9944">the
    hood.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9953">The first thing we must understand is that Combine is not magic.</st>
    <st c="10019">Combine alone doesn’t include any sophisticated code.</st> <st c="10073">Ultimately,
    we are talking about a group of protocols that helps us subscribe to changes and
    create a pipeline</st> <st c="10184">of updates.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10195">To delve in, we will review the different protocols and build
    our own custom publishers, operators, and subscribers to understand how things</st>
    <st c="10337">work inside.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10349">Let’s start with</st> <st c="10367">the publisher.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10381">Creating a custom publisher</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10409">I just mentioned that Combine</st> <st c="10439">is a set of protocols
    that speak with each other, and the publisher is the first protocol we</st> <st
    c="10533">will review.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10545">Let’s see what we know up until now about</st> <st c="10588">the
    publisher:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10602">The publisher</st> *<st c="10617">emits values</st>* <st c="10629">to
    one or</st> <st c="10640">more subscribers</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10656">The publisher output type</st> *<st c="10683">must match the</st>*
    *<st c="10698">subscriber’s input</st>*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10716">The publisher can also</st> *<st c="10740">deliver errors</st>*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10754">Based on that, let’s take our</st> `<st c="10785">Int</st>` <st
    c="10788">array publisher</st> <st c="10805">example and try to create our own
    publisher that</st> <st c="10854">delivers numbers:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="11230">The</st> `<st c="11235">CustomNumberPublisher</st>` <st c="11256">class
    has three</st> <st c="11273">essential parts:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="11289">Output</st>` <st c="11296">– This is where we define the publisher
    output type.</st> <st c="11350">In this case, it is an</st> `<st c="11373">Int</st>`
    <st c="11376">type.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="11382">Failure</st>` <st c="11390">– This is where we define the publisher
    error type.</st> <st c="11443">In this case, the publisher never emits</st> <st
    c="11483">an error.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="11492">receive</st>` <st c="11500">– This is the main publisher method.</st>
    <st c="11538">Combine calls the</st> `<st c="11556">receive</st>` <st c="11563">method
    whenever a subscriber subscribes to the publisher.</st> <st c="11622">We can see
    that the</st> `<st c="11642">receive</st>` <st c="11649">function has the subscriber’s
    parameter, and it also verifies that the subscriber input type and error match
    the</st> <st c="11763">publisher definition.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11784">When the publisher wants to emit a new value, it calls the subscriber’s</st>
    `<st c="11857">receive</st>` <st c="11864">method with the new value.</st> <st
    c="11892">When the publisher completes sending values, it calls the subscriber’s</st>
    `<st c="11963">receive</st>` <st c="11970">function with the</st> `<st c="11989">completion</st>`
    <st c="11999">parameter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12010">Let’s see how we</st> <st c="12028">use</st> `<st c="12032">CustomNumberPublisher</st>`<st
    c="12053">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12152">Running this code will print</st> `<st c="12182">1,2,3,4,5</st>`
    <st c="12191">to the console</st> <st c="12207">as expected.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12219">The</st> `<st c="12224">CustomNumberPublisher</st>` <st c="12245">example
    explains how a publisher works.</st> <st c="12286">But sometimes, we want to send
    values imperatively.</st> <st c="12338">We may wish to implement Combine in an
    existing project code</st> <st c="12398">or</st> <st c="12402">simplify things.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12418">So, let’s meet a special publisher type</st> <st c="12459">called</st>
    `<st c="12466">Subject</st>`<st c="12473">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12474">Working with Subjects</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="12496">A</st> `<st c="12597">send(_:)</st>` <st c="12605">method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12613">Let’s start with the most basic Subject –</st> `<st c="12656">PassthroughSubject</st>`<st
    c="12674">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12675">Understanding PassthroughSubject</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="12708">Let’s see a basic example</st> <st c="12734">of</st> <st c="12738">Subject
    usage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12939">The code example is simple and</st> <st c="12970">easy to follow.</st>
    <st c="12987">We created a</st> `<st c="13000">Subject</st>` <st c="13007">instance
    (which is a publisher) of the</st> `<st c="13047">PassthroughSubject</st>` <st
    c="13065">type.</st> `<st c="13072">PassthroughSubject</st>` <st c="13090">can
    be initialized without any value, and the first time we open a stream is after
    we call its</st> `<st c="13186">send(_:)</st>` <st c="13194">function.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13204">Notice that our</st> `<st c="13221">Subject</st>` <st c="13228">is
    just sending values</st> <st c="13251">but never closing the stream.</st> <st
    c="13282">However, we’ve learned from our custom publisher implementation that,
    sometimes, the publisher closes its streams and sends a completion to</st> <st
    c="13422">the subscriber.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13437">We can also use the</st> `<st c="13458">send(_:)</st>` <st c="13466">function
    to close the</st> <st c="13489">Combine stream:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13588">In this code example, we use our Subject to send two values –</st>
    `<st c="13651">1</st>` <st c="13652">and</st> `<st c="13657">2</st>`<st c="13658">.
    After sending these values, we close the stream by calling the</st> `<st c="13723">send</st>`
    <st c="13727">function with the</st> `<st c="13746">.</st>``<st c="13747">finished</st>`
    <st c="13756">parameter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13767">After that, the Subject tries to send another value (</st>`<st
    c="13821">3</st>`<st c="13823">), but the stream is already closed, and the subscriber
    won’t</st> <st c="13885">receive it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13896">The publisher life cycle is crucial to the Combine methodology
    and applies to</st> <st c="13975">our Subjects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="13988">PassthroughSubject</st>` <st c="14007">is excellent for sending
    values</st> <st c="14039">to subscribers.</st> <st c="14056">However, it’s not
    very good for holding a state.</st> <st c="14105">For example, imagine we want
    to store the current authentication login status or a file download progress.</st>
    <st c="14212">One solution is to store the received value in an instance variable.</st>
    <st c="14281">However, using an instance variable can be cumbersome, especially
    with</st> <st c="14352">several subscribers.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14372">Another option is to use another type of Subject</st> <st c="14422">called</st>
    `<st c="14429">CurrentValueSubject</st>`<st c="14448">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14449">Preserving state with CurrentValueSubject Subject</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="14499">Unlike</st> `<st c="14507">PassthroughSubject</st>`<st c="14525">,</st>
    `<st c="14527">CurrentValueSubject</st>` <st c="14546">is excellent</st> <st c="14559">for
    holding a state.</st> <st c="14581">It has an initial state and a</st> `<st c="14611">value</st>`
    <st c="14616">property representing the</st> <st c="14643">current value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14657">Let’s see a basic example of</st> `<st c="14687">CurrentValueSubject</st>`
    <st c="14706">usage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14970">In this code example, we create</st> `<st c="15003">CurrentValueSubject</st>`
    <st c="15022">and initialize it with a value (</st>`<st c="15055">"</st>``<st
    c="15057">Initial Value"</st>`<st c="15071">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15074">We then print the Subject’s current value into the console and
    subscribe to it using a simple</st> `<st c="15169">sink</st>` <st c="15173">function,
    printing each update</st> <st c="15205">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15213">In the last line, we send a new value using</st> <st c="15258">our
    Subject.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15270">The console, in this case, will show</st> <st c="15308">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="15407">At first glance, the console output looks weird.</st> <st c="15457">Why
    do we see</st> `<st c="15471">Received value: Initial Value</st>` <st c="15500">if
    we have not sent it using the</st> `<st c="15534">send(_:)</st>` <st c="15542">function?</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15552">The answer is that</st> `<st c="15572">CurrentValueSubject</st>`
    <st c="15591">already holds a value when we initialize it, and when we subscribe
    to it for the first time, we already receive the</st> <st c="15708">current value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15722">This is why</st> `<st c="15735">CurrentValueSubject</st>` <st
    c="15754">is excellent for state management.</st> <st c="15790">This behavior
    ensures that our subscribers always sync with the current</st> <st c="15862">Subject
    value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="15876">PassthroughSubject</st>` <st c="15895">doesn’t have the</st>
    `<st c="15913">value</st>` <st c="15918">property, and we cannot read</st> <st
    c="15947">its current value.</st> <st c="15967">However, the fact that it doesn’t
    emit its values before we call the</st> `<st c="16036">send(_:)</st>` <st c="16044">function
    can be an advantage in</st> <st c="16077">some cases.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16088">Let’s see</st> <st c="16099">an example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="16379">In this example, we have two</st> `<st c="16409">PassthroughSubject</st>`
    <st c="16427">publishers and the</st> `<st c="16447">merge()</st>` <st c="16454">operator
    in our Combine stream.</st> <st c="16487">The</st> `<st c="16491">merge()</st>`
    <st c="16498">operator combines the values emitted by both publishers into a single
    stream.</st> <st c="16577">If one of the Subjects sends a value, the</st> `<st
    c="16619">merge()</st>` <st c="16626">operator moves it down</st> <st c="16650">the
    stream.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16661">So, in this case, the output will be</st> <st c="16699">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="16794">PassthroughSubject</st>` <st c="16813">can act as an intermediate
    step in the Combine pipeline, allowing us to combine multiple publishers and perform
    data transformations before it reaches the subscribers.</st> <st c="16982">This
    is something we cannot do</st> <st c="17013">with</st> `<st c="17018">CurrentValueSubject</st>`<st
    c="17037">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17038">Until now, we have used the built-in</st> `<st c="17076">sink</st>`
    <st c="17080">subscriber</st> <st c="17091">to handle the incoming value.</st>
    <st c="17122">But just like the publisher, we can also create a custom subscriber.</st>
    <st c="17191">Learning how to make a custom subscriber can enrich our knowledge
    of Combine.</st> <st c="17269">Let’s</st> <st c="17275">delve in!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17284">Creating a custom subscriber</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17313">If the publisher is the element</st> <st c="17345">that delivers
    updates, the subscriber is the element that</st> <st c="17404">demands them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17417">We already understand that Combine works with a</st> *<st c="17466">supply-and-demand</st>*
    <st c="17483">model.</st> <st c="17491">This means the subscriber needs a mechanism
    to handle and request</st> <st c="17557">incoming values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17573">Let’s build a subscriber</st> <st c="17599">for</st> `<st c="17603">CustomNumberPublisher</st>`<st
    c="17624">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18000">The subscriber protocol</st> <st c="18024">contains the publisher’s
    corresponding type aliases,</st> `<st c="18078">Input</st>` <st c="18083">and</st>
    `<st c="18088">Failure</st>`<st c="18095">. Both need to match the publisher’s</st>
    `<st c="18132">Output</st>` <st c="18138">and</st> `<st c="18143">Failure</st>`
    <st c="18150">data types.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18162">Looking at the subscriber implementation, we can see three more</st>
    `<st c="18227">receive</st>` <st c="18234">functions, which we’ll look at in the</st>
    <st c="18273">next subsections.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="18290">receive(subscription: Subscription)</st>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<st c="18326">receive(subscription: Subscription)</st>` <st c="18362">is called
    when the subscriber</st> <st c="18392">subscribes successfully to the publisher.</st>
    <st c="18435">The</st> `<st c="18439">subscription</st>` <st c="18451">object
    handles the subscription, and it has one important method – to define the demand
    from the publisher.</st> <st c="18560">We do that by requesting</st> <st c="18585">unlimited
    values:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18635">We can also limit the number of items we’re requesting.</st> <st
    c="18692">For example, let’s request a maximum of three</st> <st c="18738">additional
    items:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18785">We can also request no items</st> <st c="18815">at all:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="18850">Notice that the publisher needs to call the</st> `<st c="18895">receive(subscription:
    Subscription)</st>` <st c="18930">method explicitly.</st> <st c="18950">This means
    that if we build a custom publisher (as in the</st> *<st c="19008">Creating a
    custom publisher</st>* <st c="19035">section), we must ensure that we call that</st>
    <st c="19079">function ourselves.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19098">We need to handle the incoming values now that we have established
    the subscription, and we do that with the</st> `<st c="19208">receive(_input:Int)</st>`
    <st c="19227">method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="19235">receive(_ input: Int) -> Subscribers.Demand</st>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="19279">If we look back</st> <st c="19295">at the</st> `<st c="19303">CustomNumberPublisher</st>`
    <st c="19324">subscriber we created in the</st> *<st c="19354">Creating a custom
    publisher</st>* <st c="19381">section, we can see that our publisher calls the</st>
    <st c="19431">subscriber directly:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19482">That’s the</st> `<st c="19494">receive(_ input:Int)</st>` <st
    c="19514">method we need to implement as part of the subscriber protocol.</st>
    <st c="19579">This method handles the incoming updates, similar to the closure
    we saw in the</st> `<st c="19658">sink</st>` <st c="19662">function (in the</st>
    *<st c="19680">Setting up the</st>* *<st c="19695">Subscriber</st>* <st c="19705">section).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19715">Notice that the</st> `<st c="19732">receive</st>` <st c="19739">function
    returns</st> `<st c="19757">Subscribers.Demand</st>`<st c="19775">. That’s the
    same demand type we discussed in the previous function.</st> <st c="19844">When
    the subscriber finishes handling the input, it must inform the publisher how many
    more items it demands.</st> <st c="19954">Demanding more items doesn’t replace
    the demand sent in the previous function when the subscriber first established
    its subscription to the publisher.</st> <st c="20105">The new demand request is
    an additive value that needs to be handled by</st> <st c="20177">the publisher.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20191">Look at the</st> <st c="20204">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20390">Let’s try to follow the calls in this</st> <st c="20429">code
    example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="20442">The subscriber subscribes to the publisher, and the</st> `<st
    c="20495">receive(subscription: Subscription)</st>` <st c="20530">function is
    called, returning a maximum of</st> `<st c="20574">1</st>`<st c="20575">. The
    total demand is</st> <st c="20597">now</st> `<st c="20601">1</st>`<st c="20602">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20603">The publisher emits a value to the subscriber, and the</st> `<st
    c="20659">receive(_ input:Int)</st>` <st c="20679">function is called, returning
    a maximum of</st> `<st c="20723">3</st>`<st c="20724">. The total demand is</st>
    <st c="20746">now</st> `<st c="20750">4</st>`<st c="20751">.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20752">As mentioned, it is the publisher’s responsibility</st> <st c="20803">to
    manage the subscriber demand.</st> <st c="20837">If we create our custom publisher,
    we need to</st> <st c="20883">consider that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20897">Now that we know how to start and manage a subscription, it’s
    no less important to understand how to</st> <st c="20999">complete it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="21011">receive(completion: Subscribers.Completion<Never>)</st>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="21062">The publisher calls</st> <st c="21082">the subscriber’s</st> `<st
    c="21100">receive(completion:)</st>` <st c="21120">function when it completes
    publishing.</st> <st c="21160">It can be either because the publisher has no updates
    or</st> <st c="21217">an error.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21226">That’s where the subscriber needs to perform cleanups, update
    UI or application state, or print logs, mainly when an</st> <st c="21344">error
    occurs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21357">Here’s an example of the</st> `<st c="21383">receive(completion:)</st>`
    <st c="21403">function:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21633">That’s a basic implementation</st> <st c="21663">of the</st> `<st
    c="21671">receive(completion:)</st>` <st c="21691">function.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21701">We now know how to create a custom publisher and a custom subscriber.</st>
    <st c="21772">Now, let’s see how to</st> <st c="21794">connect them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21807">Connecting the custom publisher and subscriber</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21854">To complete the picture</st> <st c="21878">of how the subscriber
    and the publisher work together, we must return to the publisher and respond to
    our subscriber</st> <st c="21996">demand requests.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22012">Let’s see an example of how to implement a</st> `<st c="22056">receive</st>`
    <st c="22063">function on the</st> <st c="22080">publisher side:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="22356">In the code example, the publisher keeps sending more updates
    to the subscriber as long as the subscriber keeps demanding them.</st> <st c="22485">When
    the subscriber stops demanding more updates, the publisher closes the stream and
    calls the subscriber</st> `<st c="22592">receive(completion:)</st>` <st c="22612">function.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22622">At this point, we should be familiar</st> <st c="22659">with how
    subscribers and publishers work together.</st> <st c="22711">We created custom
    publishers and subscribers and performed basic subscriptions.</st> <st c="22791">Let’s
    improve these subscriptions with operators, something we have</st> <st c="22859">barely
    discussed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22876">Working with operators</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="22899">Subscriptions and publishers</st> <st c="22928">are great, but
    the true power of Combine comes</st> <st c="22976">from operators.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22991">Unlike subscriptions and publishers, operators are not protocols
    or instances.</st> <st c="23071">Operators are just publisher methods that republish
    the update downstream and create a chain of data manipulations until the subscriber
    reaches the end of</st> <st c="23226">the pipeline.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23239">Operators help us modify the updates, filter them, merge them,
    and perform many operations, which allows us to achieve an</st> <st c="23362">ideal
    result.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23375">The Combine framework</st> <st c="23397">comes with many built-in
    operators.</st> <st c="23434">We will go over only some of them now, but you can
    go over the full list at the Apple</st> <st c="23520">website:</st> [<st c="23529">https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators</st>](https://developer.apple.com/documentation/combine/publishers-catch-publisher-operators)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23615">Let’s start with some</st> <st c="23638">basic operators.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23654">Starting with basic operators</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="23684">One of the most basic use cases for operators in Combine is to</st>
    *<st c="23748">filter</st>* <st c="23754">the updates that the</st> <st c="23776">publisher
    delivers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23795">For example, we can use the</st> `<st c="23824">filter</st>` <st
    c="23830">operator:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23932">In this code example, we created a publisher that emits values
    from</st> `<st c="24001">1</st>` <st c="24002">to</st> `<st c="24006">10</st>`<st
    c="24008">. The</st> `<st c="24014">filter</st>` <st c="24020">operator ensures
    that only even numbers will continue downstream.</st> <st c="24087">This code
    will print</st> `<st c="24108">2</st>`<st c="24109">,</st> `<st c="24111">4</st>`<st
    c="24112">,</st> `<st c="24114">6</st>`<st c="24115">,</st> `<st c="24117">8</st>`<st
    c="24118">, and</st> `<st c="24124">10</st>` <st c="24126">to</st> <st c="24130">the
    console.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24142">Another example of a filtering operator</st> <st c="24183">is</st>
    `<st c="24186">removeDuplicates</st>`<st c="24202">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24301">The code example shows a publisher that emits duplicate values.</st>
    <st c="24366">The</st> `<st c="24370">removeDuplicates</st>` <st c="24386">operator
    filters out the values in case they were sent in the last update.</st> <st c="24462">The
    console will show</st> <st c="24484">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="24508">Let’s try to create a custom operator</st> <st c="24547">to understand
    how an operator</st> <st c="24577">works underneath.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24594">Creating a custom operator</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="24621">When we try to examine</st> <st c="24644">the filter operator</st>
    <st c="24664">in Apple’s header files, we can see</st> <st c="24701">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="24834">filter()</st>` <st c="24843">is a function that accepts a closure
    with a parameter of a generic type of</st> `<st c="24919">Output</st>` <st c="24925">and
    returns a publisher.</st> <st c="24951">This function extends the</st> `<st c="24977">Publisher</st>`
    <st c="24986">protocol we discussed earlier under</st> *<st c="25023">Creating
    a</st>* *<st c="25034">custom publisher</st>*<st c="25050">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25051">The important thing to notice here is that the</st> `<st c="25099">filter</st>`
    <st c="25105">function republishes the values and allows multiple operators to
    be chained together to create a complex data</st> <st c="25216">processing pipeline.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25236">This is similar to how view modifiers work with SwiftUI – they
    modify the current view and return a</st> <st c="25337">new view.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25346">To create our own custom</st> <st c="25371">operator, let’s try
    to do the same</st> <st c="25406">thing and create a</st> `<st c="25426">multiply</st>`
    <st c="25434">operator.</st> <st c="25445">Our</st> `<st c="25449">multiply</st>`
    <st c="25457">operator accepts an</st> `<st c="25478">Int</st>` <st c="25481">value
    and republishes it while multiplying with a</st> <st c="25532">certain factor:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25705">In our code example, we also extended the</st> `<st c="25748">Publisher</st>`
    <st c="25757">protocol while ensuring the</st> `<st c="25786">Output</st>` <st
    c="25792">type needs to</st> <st c="25807">be</st> `<st c="25810">Int</st>`<st
    c="25813">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25814">We then create a</st> `<st c="25832">multiply</st>` <st c="25840">function
    that accepts a factor as a parameter and returns a</st> <st c="25901">new publisher.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25915">In our implementation, we use a</st> `<st c="25948">map</st>`
    <st c="25951">operator to transform our value into a new one, which means we need
    to return a</st> `<st c="26032">Map</st>` <st c="26035">publisher.</st> <st c="26047">Let’s
    see how to use our</st> <st c="26072">new operator:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26199">We added our new</st> `<st c="26217">multiply</st>` <st c="26225">operator
    to a Combine stream that starts with an array of five numbers.</st> <st c="26298">The
    output for this code would be</st> <st c="26332">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26434">We created our</st> <st c="26450">first operator!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26465">However, if you are like me, the return</st> <st c="26505">of
    a new Map publisher</st> <st c="26528">may bother you.</st> <st c="26545">Let’s
    try to understand why it happened and what we can do</st> <st c="26604">about
    it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26613">Working with AnyPublisher</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="26639">Our intuition says</st> <st c="26658">that if</st> `<st c="26667">multiply</st>`
    <st c="26675">is a function that accepts an</st> `<st c="26706">Int</st>` <st
    c="26709">type and returns</st> <st c="26726">a new value, why do we need to use
    a</st> <st c="26764">Map publisher?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26778">So, we need to remember that operators republish our values.</st>
    <st c="26840">The function doesn’t return a value but rather a publisher that
    publishes the new value.</st> <st c="26929">It might not sound obvious, but our
    goal is to create a chain of publishers and multiply, despite its name, which
    is part of</st> <st c="27054">this chain.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27065">So, our solution is to return some sort of a</st> *<st c="27111">generic
    publisher</st>*<st c="27128">, or what we call in Combine –</st> `<st c="27159">AnyPublisher</st>`<st
    c="27171">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="27172">AnyPublisher</st>` <st c="27185">is a type-erased publisher,
    and we use it to present a more abstract interface to</st> <st c="27268">our publishers.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27283">Let’s see our</st> `<st c="27298">multiply</st>` <st c="27306">operator</st>
    <st c="27315">version, which now returns</st> `<st c="27343">AnyPublisher</st>`
    <st c="27355">instead</st> <st c="27363">of</st> `<st c="27367">Publisher.Map</st>`<st
    c="27380">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="27564">In this code example, we performed</st> <st c="27600">two changes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27612">We changed the function’s return type to</st> `<st c="27654">AnyPublisher<Int,
    Failure></st>`<st c="27680">. In this way, we hide the implementation details
    and the fact that we used the</st> <st c="27760">Map publisher.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27774">We erased the publisher type using the</st> `<st c="27814">eraseToAnyPublisher()</st>`
    <st c="27835">function, which erases the publisher type and</st> <st c="27882">returns</st>
    `<st c="27890">AnyPublisher</st>`<st c="27902">.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27903">At first glance, it looks like</st> `<st c="27935">AnyPublisher</st>`
    <st c="27947">is there only for semantic reasons.</st> <st c="27984">But when
    I said that returning a Map publisher</st> *<st c="28031">bothers</st>* <st c="28038">me,
    it wasn’t because it didn’t look nice.</st> <st c="28082">It’s because</st> `<st
    c="28095">AnyPublisher</st>` <st c="28107">has practical implications for how
    we build</st> <st c="28152">Combine streams.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28168">One reason is</st> *<st c="28183">API design</st>*<st c="28193">.
    Using</st> `<st c="28201">AnyPublisher</st>` <st c="28213">allows us to design
    a more flexible and polymorphic API interface.</st> <st c="28281">Our previous
    version of the</st> `<st c="28309">multiply</st>` <st c="28317">function returned
    a specific type of publisher.</st> <st c="28366">Returning</st> `<st c="28376">AnyPublisher</st>`
    <st c="28388">makes it easier to chain publishers together because they are from
    the</st> <st c="28460">same type.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28470">Another reason is</st> *<st c="28489">decoupling</st>* <st c="28499">–
    by returning publishers as</st> `<st c="28529">AnyPublisher</st>`<st c="28541">,
    we’re decoupling our publisher’s implementation from its usage.</st> <st c="28607">By
    that, we make our code more modular</st> <st c="28646">and maintainable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28663">The</st> `<st c="28668">filter</st>` <st c="28674">and</st> `<st
    c="28679">removeDuplicates</st>` <st c="28695">operators, along with</st> `<st
    c="28718">map</st>`<st c="28721">, are great for streamlining</st> <st c="28749">and
    manipulating values</st> <st c="28773">along the pipeline.</st> <st c="28794">We
    also reviewed the</st> `<st c="28815">merge</st>` <st c="28820">operator when
    we discussed Subjects in the</st> *<st c="28864">Working with Subjects</st>* <st
    c="28885">section.</st> <st c="28895">But Combine offers more advanced operators.</st>
    <st c="28939">Let’s go over some of</st> <st c="28961">them now.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28970">Exploring advanced operators</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="28999">Let’s face it, up until now, we discussed operators</st> <st c="29051">that
    performed tasks that were easy to do even without Combine.</st> <st c="29116">Yes,
    using</st> `<st c="29127">map</st>` <st c="29130">and</st> `<st c="29135">filter</st>`
    <st c="29141">operators is extremely valuable, but they don’t reflect the real
    Combine</st> <st c="29215">added value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29227">One of the Combine framework goals is to create much more sophisticated
    and complex streams that can be error-prone to do</st> <st c="29350">without it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29361">Let’s understand what I mean and explore the</st> `<st c="29407">zip</st>`
    <st c="29410">operator.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29420">Using the zip operator</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="29443">The</st> `<st c="29448">zip</st>` <st c="29451">operator combines
    values</st> <st c="29476">from two publishers and emits a tuple only after each
    publisher emits</st> <st c="29547">its value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29557">Once the</st> `<st c="29567">zip</st>` <st c="29570">operator
    receives values from all publishers, it emits a tuple and</st> *<st c="29638">resets</st>*
    <st c="29644">itself.</st> <st c="29653">This means it waits again to receive
    values from all publishers before it emits a</st> <st c="29735">new tuple.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29745">Let’s see a simple</st> <st c="29765">code example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30134">In this code example, we used two Subjects</st> <st c="30177">to
    send values to our subscriber.</st> <st c="30212">We zipped them together and
    printed</st> <st c="30248">the output.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30259">We can see that after</st> `<st c="30282">publisher1</st>` <st
    c="30292">sends a value, the stream doesn’t continue and waits for</st> `<st c="30350">publisher2</st>`
    <st c="30360">to send its value.</st> <st c="30380">Only after</st> `<st c="30391">publisher2</st>`
    <st c="30401">sends a value does the stream continue and print</st> `<st c="30451">(1,10)</st>`
    <st c="30457">to the console.</st> <st c="30474">At this point, the</st> `<st
    c="30493">zip</st>` <st c="30496">operator is reset, and again, it waits for both
    publishers to</st> <st c="30559">emit values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30571">The</st> `<st c="30576">zip</st>` <st c="30579">operator is not
    limited to two publishers.</st> <st c="30623">We can also use</st> `<st c="30639">zip</st>`
    <st c="30642">for three publishers and receive a tuple</st> <st c="30684">of three.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30693">The</st> `<st c="30698">zip</st>` <st c="30701">operator belongs
    to a group of Combine operators that handles multiple publishers together.</st>
    <st c="30794">We already saw the</st> `<st c="30813">merge</st>` <st c="30818">operator
    under the</st> *<st c="30838">Working with</st>* *<st c="30851">Subjec</st><st
    c="30857">ts</st>* <st c="30860">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30869">Another operator that belongs to this category is</st> `<st c="30920">combineLatest</st>`<st
    c="30933">. Let’s go over</st> <st c="30949">it now.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30956">Combining multiple values using combineLatest</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="31002">The</st> `<st c="31007">zip</st>` <st c="31010">operator combines</st>
    <st c="31028">multiple publisher</st> <st c="31047">outputs into a tuple.</st>
    <st c="31070">However, it waits for all publishers to send values</st> <st c="31122">each
    time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31132">The</st> `<st c="31137">combineLatest</st>` <st c="31150">operator
    only waits for the first time for all publishers to emit values, and from this
    point, it emits a new tuple each time one of the publishers sends a</st> <st c="31307">new
    value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31317">Let’s see an example</st> <st c="31339">of</st> `<st c="31342">combineLatest</st>`<st
    c="31355">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31726">In this code example, we also have two Subjects</st> <st c="31774">that
    send values.</st> <st c="31793">This time, we combined</st> <st c="31815">them</st>
    <st c="31821">using</st> `<st c="31827">combineLatest</st>`<st c="31840">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31841">After</st> `<st c="31848">publisher1</st>` <st c="31858">sends
    its first value,</st> `<st c="31882">combineLatest</st>` <st c="31895">halts the
    stream as it waits for</st> `<st c="31929">publisher2</st>` <st c="31939">to send</st>
    <st c="31948">a value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31956">Once</st> `<st c="31962">publisher2</st>` <st c="31972">sends
    its first value,</st> `<st c="31996">combineLatest</st>` <st c="32009">emits a
    tuple with the values</st> <st c="32040">of (</st>`<st c="32044">1,10</st>`<st
    c="32049">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32052">Next,</st> `<st c="32059">publisher1</st>` <st c="32069">sends
    a new value –</st> `<st c="32090">2</st>`<st c="32091">. This time,</st> `<st
    c="32104">combineLatest</st>` <st c="32117">doesn’t wait for</st> `<st c="32135">publisher2</st>`
    <st c="32145">to send a new value and emits a new tuple – (</st>`<st c="32191">2,10</st>`<st
    c="32196">)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32198">The behavior of emitting a new tuple each time one of the publishers
    sends a new value makes</st> `<st c="32291">combineLatest</st>` <st c="32304">a
    top-rated operator for handling</st> <st c="32339">asynchronized operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32364">Imagine you have a screen being updated by multiple sources, such
    as a search results screen of live sports updates, and each time we get a new
    update, we want our screen to refresh its UI to reflect the</st> <st c="32569">new
    state.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="32579">combineLatest</st>` <st c="32593">is ideal for such a case,
    as it creates a new tuple downstream whenever one of the publishers emits a</st>
    <st c="32696">new value.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32706">We can use many more useful</st> <st c="32734">operators; you
    can find</st> <st c="32758">them all on Apple’s website.</st> <st c="32788">However,
    the real challenge with adopting Combine in our projects is understanding how
    to implement them in real-life</st> <st c="32906">use cases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32916">Learning about Combine using examples</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32954">Up until now, we have discussed several Combine</st> <st c="33002">components
    and delved into understanding how Combine works underneath by creating our custom
    publishers, subscribers,</st> <st c="33121">and operators.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33135">Despite that, many developers need help incorporating Combine
    frameworks in</st> <st c="33212">real-life scenarios.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33232">The different publishers and operators are mostly clear in theory,
    but it can be difficult to imagine them as part of the central design patterns
    we use in</st> <st c="33389">our projects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33402">Let’s review some examples to help us understand how to implement
    Combine in our projects.</st> <st c="33494">We’ll start with a basic example of
    managing a UI state in a</st> <st c="33555">view model.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33566">Managing UIKit-based view state in a view model</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="33614">SwiftUI view states</st> <st c="33634">are naturally</st> <st
    c="33648">declarative.</st> <st c="33662">This means we can bind the view state,
    such as a list of items, to a UI component, such as a</st> `<st c="33755">List</st>`
    <st c="33759">view.</st> <st c="33766">That’s the only way to handle states</st>
    <st c="33803">in SwiftUI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33814">However, achieving that design pattern in UIKit takes time</st>
    <st c="33874">and effort.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33885">Using Combine, we can create a publisher and bind our table view
    data source to reflect any changes coming from</st> <st c="33998">the server.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34009">Here’s a code example for such a</st> <st c="34043">view model:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34379">We have already discussed</st> <st c="34405">the</st> `<st c="34410">AnyPublisher</st>`
    <st c="34422">form, and that’s a great example</st> <st c="34455">of its usage.</st>
    <st c="34470">We create a publisher that starts with a URL request, extracts its
    data using the</st> `<st c="34552">map</st>` <st c="34555">operator, and decodes
    it into an array of Items.</st> <st c="34605">To hide the publisher implementation,
    we erase its type for</st> `<st c="34665">AnyPublisher</st>`<st c="34677">. Connecting
    the view model to the view controller is simple now that we have</st> <st c="34755">a
    publisher:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34934">In this code example, we subscribe to our new</st> `<st c="34981">dataPublisher</st>`
    <st c="34994">and update our table view with</st> <st c="35026">the data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35035">To make our project</st> <st c="35055">even more modular, we can
    move</st> <st c="35086">the</st> `<st c="35091">URLSession</st>` `<st c="35101">dataTaskPublisher</st>`
    <st c="35119">function to a class of its own and keep the separation of</st> <st
    c="35178">concerns principle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35197">Performing searches from multiple sources</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="35239">One of the most popular</st> <st c="35263">use cases of iOS development
    is performing</st> <st c="35306">a search from the server and the</st> <st c="35340">local
    database.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35355">The requirement for such a search is first to show results from
    the local data store and then go to the server and</st> <st c="35471">return results.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35486">This is a common requirement, and using Combine is also easy.</st>
    <st c="35549">Let’s see a simple example</st> <st c="35576">of that:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36505">In this code</st> <st c="36518">example, we performed</st> <st
    c="36540">three</st> <st c="36547">primary steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="36901">Just</st>` <st c="36905">and</st> `<st c="36910">Future</st>`<st
    c="36916">. We can use</st> `<st c="36929">Just</st>` <st c="36933">to start a
    stream, and</st> `<st c="36957">Future</st>` <st c="36963">is a publisher we use
    to perform a task and emit the</st> <st c="37017">value asynchronously.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="37167">merge</st>` <st c="37172">operator.</st> <st c="37183">Remember
    that the</st> `<st c="37201">merge</st>` <st c="37206">operator emits an update
    if one of its sources emits a new value.</st> <st c="37273">We could also use</st>
    `<st c="37291">combineLatest</st>`<st c="37304">, but</st> `<st c="37310">combineLatest</st>`
    <st c="37323">waits for all the publishers to emit values before it emits the
    combined</st> <st c="37397">value downstream.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="37510">totalResults</st>` <st c="37522">array.</st> <st c="37530">Our
    data flow doesn’t have to end here.</st> <st c="37570">We can make</st> `<st c="37582">totalResults</st>`
    <st c="37594">a</st> `<st c="37597">CurrentValueSubject</st>` <st c="37616">instance
    and deliver the results to the view model or the view itself.</st> <st c="37688">If
    we are working with SwiftUI, we can make</st> `<st c="37732">totalResults</st>`
    <st c="37744">a</st> `<st c="37747">@Published</st>` <st c="37757">variable to
    refresh the search results</st> <st c="37797">UI automatically.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="37814">There’s a nice lesson here related</st> <st c="37849">to using
    Combine</st> <st c="37866">in our projects.</st> <st c="37884">If we create publishers
    for different data sources and ensure they emit values, it becomes easy to create
    pipelines of updates and connect them to the rest of</st> <st c="38043">the project.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38055">The following example handles another everyday use case, which
    is</st> <st c="38122">form validation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38138">Validating forms</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="38155">Forms are common use cases</st> <st c="38182">in any user-facing
    platform, not just iOS.</st> <st c="38226">One of the most essential responsibilities
    of creating forms is the ability to validate</st> <st c="38314">their inputs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38327">Let’s see how to use Combine to validate a simple</st> <st c="38378">sign-in
    form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: <st c="38893">Our form contains two text fields –</st> `<st c="38930">username</st>`
    <st c="38938">and</st> `<st c="38943">password</st>`<st c="38951">. We also have
    a view model attached to the view.</st> <st c="39001">The view model has several</st>
    `<st c="39028">@Published</st>` <st c="39038">variables, such as</st> `<st c="39058">username</st>`<st
    c="39066">,</st> `<st c="39068">password</st>`<st c="39076">, and</st> `<st c="39082">isFormValid</st>`<st
    c="39093">. The</st> `<st c="39099">username</st>` <st c="39107">and</st> `<st
    c="39112">password</st>` <st c="39120">variables are connected to the view</st>
    <st c="39157">text fields.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39169">Now, let’s see the</st> `<st c="39189">FormViewModel</st>` <st
    c="39202">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39606">When we initialize the view</st> <st c="39634">model, we create
    a Combine stream based on the</st> `<st c="39682">combineLatest</st>` <st c="39695">operator
    to observe changes in the</st> `<st c="39731">username</st>` <st c="39739">and</st>
    `<st c="39744">password</st>` <st c="39752">variables.</st> <st c="39764">The</st>
    `<st c="39768">map</st>` <st c="39771">operator ensures that both variables are
    not empty, and we assign the results (</st>`<st c="39851">Bool</st>`<st c="39856">)
    to the</st> `<st c="39866">isFormValid</st>` <st c="39877">variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39887">The view observes the</st> `<st c="39910">isFormValid</st>` <st
    c="39921">value and uses it to turn the login button on</st> <st c="39968">and
    off.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39976">This stream is basic; we can achieve the same results without
    Combine.</st> <st c="40048">However, forms can become very complex at some point.</st>
    <st c="40102">The Combine pipeline we created is an excellent infrastructure for
    more</st> <st c="40174">complicated forms.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40192">Even simple rules for</st> `<st c="40215">username</st>` <st c="40223">and</st>
    `<st c="40228">password</st>` <st c="40236">can be easily enforced using our stream,
    as in</st> <st c="40284">this example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40652">In this code example, we used our Combine stream</st> <st c="40701">to
    enforce rules – the password needs at least eight characters including a number,
    and the username needs at least six characters.</st> <st c="40834">The</st> `<st
    c="40838">map</st>` <st c="40841">operator is great for centralizing this logic,
    outputting a Boolean value, and assigning it to the</st> `<st c="40941">isFormValid</st>`
    <st c="40952">value.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40959">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="40967">Combine makes our code reactive beyond SwiftUI views.</st> <st
    c="41022">It’s a framework that can help us handle complex tasks such as search,
    network requests, and</st> <st c="41115">state management.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41132">This chapter reviewed the basic Combine components, such as the
    publisher, subscriber, and operator.</st> <st c="41234">We also delved in and
    created custom versions of each of the components.</st> <st c="41307">We learned
    how to create pipelines with data transforms and network requests.</st> <st c="41385">In
    the end, we learned how to incorporate Combine in common</st> <st c="41445">use
    cases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41455">By now, we should be able to start working with Combine on our</st>
    <st c="41519">existing projects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41537">The next chapter touches on another topic many iOS developers
    feel irritated by –</st> <st c="41620">Core Data.</st>
  prefs: []
  type: TYPE_NORMAL
