<html><head></head><body>
		<div id="_idContainer093">
			<h1 id="_idParaDest-112"><em class="italic"><a id="_idTextAnchor285"/>Chapter 8</em>: Getting Started with Clean Architecture in Android</h1>
			<p>In this chapter, we're continuing our journey of improving the architectural design of the Restaurants application.</p>
			<p>More specifically, we will try to adopt some design decisions from the well-known Clean Architecture. <strong class="bold">Clean Architecture</strong> is a software design philosophy that tries to create projects with the best level of the following:</p>
			<ul>
				<li>Separation of concerns</li>
				<li>Testability</li>
				<li>Independence of frameworks or libraries used in peripheral layers, such as the UI or Model layer</li>
			</ul>
			<p>By doing so, Clean Architecture tries to allow the business parts of our applications to adapt to changing technologies and interfaces.</p>
			<p>Clean Architecture is a very broad and complex topic, so, in this chapter, we will try to focus only on establishing a better separation of concerns by separating existing layers even further, but more importantly, by defining a new layer called the <strong class="bold">Domain layer</strong>.</p>
			<p>In this chapter, we will on one hand borrow some architectural decisions from Clean Architecture through the <em class="italic">Defining the Domain layer with Use Cases</em> section and the <em class="italic">Separating the Domain model from Data models</em> section. On the other hand, we will try to improve project architecture with other techniques through the <em class="italic">Creating a package structure</em> section and the <em class="italic">Decoupling the Compose-based UI layer from ViewModel</em> section.</p>
			<p>Another essential principle of Clean Architecture is the <strong class="bold">Dependency Rule</strong> that we will briefly cover in the <em class="italic">Further reading</em> section where you will find proper resources to follow up with.</p>
			<p>We will cover the following topics in this section:</p>
			<ul>
				<li>Defining the Domain layer with Use Cases</li>
				<li>Separating the Domain model from Data models</li>
				<li>Creating a package structure</li>
				<li>Decoupling the Compose-based UI layer from ViewModel</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor286"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or a newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <strong class="source-inline">Chapter_07</strong> directory of the repository and importing the Android project titled <strong class="source-inline">chapter_7_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_08</strong> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app</a>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor287"/>Defining the Domain layer with Use Cases</h1>
			<p>So far, we've talked <a id="_idIndexMarker605"/>about the Presentation layer (with UI and presentation logic) and the Model layer (with data logic). Yet, apart from these two layers, most of the time, applications also encapsulate a different type of logic, different from UI, presentation, or data logic.</p>
			<p>To identify this type of logic, we must first acknowledge that most applications have a dedicated business scope – for example, a food delivery application could have the business scope of taking orders and generating revenue for the stakeholder. The <strong class="bold">stakeholder</strong> is the<a id="_idIndexMarker606"/> entity interested in the business, such as the company that owns the restaurant chain.</p>
			<p>Such <a id="_idIndexMarker607"/>applications can contain business rules imposed by the stakeholders that can vary from minimum order amounts, custom availability ranges for certain restaurants, or predefined time frames for different delivery charges; the <a id="_idIndexMarker608"/>list could go on. We can refer to such business rules that are dictated by stakeholders as <strong class="bold">business logic</strong>.</p>
			<p>For our Restaurants app, let's imagine that the stakeholder (for example, the company we would be building the application for) asked us to always show the restaurants alphabetically, no matter what. This shouldn't be something that the user would know about; instead, it should be a predefined business rule that we must implement.</p>
			<p>Now, sorting restaurants alphabetically isn't that big of a deal, so the natural question that arises is, where should we apply this sorting logic? </p>
			<p>To figure this out, let's recap <a id="_idIndexMarker609"/>the current layering of the project. Right now, the Presentation layer is connected to the Model layer. </p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B17788_08_01.jpg" alt="Figure 8.1 – Layering of responsibilities in the Restaurants app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Layering of responsibilities in the Restaurants app</p>
			<p>With our existing layer structuring, we could sort the restaurants in the following:</p>
			<ul>
				<li><strong class="bold">UI level (composables)</strong>: Since<a id="_idIndexMarker610"/> this sorting logic is business logic, we should try to avoid adding it here.</li>
				<li><strong class="bold">Inside the ViewModel</strong>: If this<a id="_idIndexMarker611"/> sorting was a presentation option (so the user could sort restaurants in different ways from the UI by selecting a picker or button), we would have considered this to be presentation logic that can be held inside a <strong class="source-inline">ViewModel</strong> class; yet, remember that this rule is part of the business requirements, and the user shouldn't know about it, so it's probably not a good idea to implement it here.</li>
				<li><strong class="bold">Inside the Repository</strong>: Here<a id="_idIndexMarker612"/>, we store data logic (such as caching), which is different from business logic.</li>
			</ul>
			<p>None of<a id="_idIndexMarker613"/> the options are ideal, and we will see in a moment why this is the case. Until then, let's have a compromise and add this business rule inside the Model layer:</p>
			<ol>
				<li>Inside <strong class="source-inline">RestaurantsRepository</strong>, refactor the <strong class="source-inline">getAllRestaurants()</strong> method to sort the restaurants by <strong class="source-inline">title</strong> by calling the <strong class="source-inline">sortedBy { }</strong> extension function on the restaurants that are returned:<p class="source-code">suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        try {</p><p class="source-code">            refreshCache()</p><p class="source-code">        } catch (e: Exception) {…}</p><p class="source-code">        return@withContext restaurantsDao.getAll()</p><p class="source-code">            <strong class="bold">.sortedBy { it.title }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Build and run the application.</li>
			</ol>
			<p>The restaurants are now correctly sorted by their title, yet if you toggle a restaurant as a favorite, you might notice an initial flicker and a re-ordering effect on the list. Can you guess why this has happened?</p>
			<p>The issue here is that in <strong class="source-inline">RestaurantsRepository</strong>, the <strong class="source-inline">toggleFavoriteRestaurant()</strong> method returns the unsorted version of the restaurants from <a id="_idIndexMarker614"/>the <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>):</p>
			<p class="source-code">suspend fun toggleFavoriteRestaurant(…)= withContext(…){</p>
			<p class="source-code">    …</p>
			<p class="source-code">    <strong class="bold">restaurantsDao.getAll()</strong></p>
			<p class="source-code">}</p>
			<p>To fix this, we could repeat the same sorting logic from the <strong class="source-inline">getAllRestaurants()</strong> method.</p>
			<p>Yet, this<a id="_idIndexMarker615"/> approach is problematic because we would be repeating or duplicating the sorting business rule. Worse than that, since we are in the Model layer, we're mixing data logic with business logic. We shouldn't be mixing data caching logic with business rules.</p>
			<p>It's clear that for us to correctly encapsulate business logic and to be able to reuse it, we should extract it to a separate layer. Just like whenever we wanted to prevent any changes impacting the Presentation layer from affecting other layers, such as the UI or Model layers, we want to separate the business logic inside a separate layer so that any changes to the business logic shouldn't impact other layers and their corresponding logic.</p>
			<p>According to Clean Architecture concepts, the layer that encapsulates business rules and business logic is referred to as the Domain layer. This layer sits between the Presentation layer and the Model layer. It should process the data from the Model layer by applying the business rules that it incorporates, and then feed the Presentation layer with the business-compliant content.</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B17788_08_02.jpg" alt="Figure 8.2 – Layering of responsibilities in the Restaurants app, including the Domain layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Layering of responsibilities in the Restaurants app, including the Domain layer</p>
			<p>In other words, in <a id="_idIndexMarker616"/>a particular flow (as in the screen with the list of restaurants), the Presentation layer through the <strong class="source-inline">ViewModel</strong> would connect to the Domain layer instead of the Model layer. In turn, the Domain layer would get the data from the Model layer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Not all applications, screens, or flows contain business logic. For these cases, the Domain layer is optional. The Domain layer should hold business logic, but, if there is no such logic, there should be no such layer.</p>
			<p>But what should the Domain layer contain?</p>
			<p>According to<a id="_idIndexMarker617"/> Clean Architecture concepts, repeatable business logic that is related to a specific application<a id="_idIndexMarker618"/> action or flow should be encapsulated in a Use Case. In other words, <strong class="bold">Use Cases</strong> are classes that extract repeatable business rules related to a single functionality of your application as a single unit of business logic.</p>
			<p>For example, an online ordering app can have business logic related to displaying only stores in the near proximity of the user. To encapsulate this business rule, we could create a <strong class="source-inline">GetStoresInProximityUseCase</strong> class. Or, maybe there is some business logic associated with the logout action triggered by the user (such as executing some user benefits or points calculation behind the scenes); then, we could implement <strong class="source-inline">LogOutUserUseCase</strong>.</p>
			<p>So, in our Restaurants app, any business logic must be encapsulated in a Use Case that sits between the Presentation layer and the Model layer:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B17788_08_03.jpg" alt="Figure 8.3 – Layering of responsibilities where the Domain layer contains Use Cases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Layering of responsibilities where the Domain layer contains Use Cases</p>
			<p>A separated Domain layer brings the <a id="_idIndexMarker619"/>following benefits:</p>
			<ul>
				<li>Improves the testability of the app by separating business logic into its own classes. This way, business responsibilities are separated from other components and their logic can be tested separately without having to care about components from other layers.</li>
				<li>By separating business logic inside Use Cases, we avoid code duplication, and we improve the re-usability of business rules and their corresponding logic.</li>
				<li>Improves the readability of the classes that contain Use Cases dependencies. This is because each unit of business is now extracted separately and provides developers with valuable insights into the business actions each screen or flow executes.</li>
			</ul>
			<p>Before jumping into a <a id="_idIndexMarker620"/>practical example, let's briefly cover a few important aspects of Use Cases:</p>
			<ul>
				<li>They can use (or depend on) other Use Cases. Since Use Cases define a single unit of reusable business logic, then Use Cases can use other Use Cases to define complex business logic.</li>
				<li>They usually obtain their data from the Model layer but are not conditioned to only one <strong class="source-inline">Repository</strong> class – in other words, you can access multiple repositories from within your Use Case.</li>
				<li>They usually have only one public method, mostly because Use Cases encapsulate business rules related to a single functionality of your app (like <strong class="source-inline">LogOutUserUseCase</strong> does).</li>
				<li>They should follow a naming convention. A popular convention for the Use Case class is a verb in the present tense that defines the action, usually followed by a few words that express the <em class="italic">what</em>, and that ends with the UseCase suffix. Some examples could be <strong class="source-inline">GetStoresInProximityUseCase</strong> or <strong class="source-inline">CalculateOrderTotalUseCase</strong>.</li>
			</ul>
			<p>It's time to <a id="_idIndexMarker621"/>see what a Use Case class looks like. In our Restaurants app, the business logic of sorting restaurants alphabetically is a good match for it being extracted to a Use Case because of the following:</p>
			<ul>
				<li>It's a business rule dictated by the stakeholder.</li>
				<li>It's repeated twice.</li>
				<li>It's part of a specific action of the app (getting the restaurants).</li>
			</ul>
			<p>Let's define our first Use Case class!</p>
			<ol>
				<li value="1">Click on the application package, select <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">GetRestaurantsUseCase</strong> as the name, select <strong class="bold">Class</strong>, and add this code:<p class="source-code">class GetRestaurantsUseCase {</p><p class="source-code">    private val repository: RestaurantsRepository = </p><p class="source-code">        RestaurantsRepository()</p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; {</p><p class="source-code">        return repository.getAllRestaurants()</p><p class="source-code">                        .sortedBy { it.title }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Functionally, this Use Case class gets the restaurants from <strong class="source-inline">RestaurantsRepository</strong>, applies the business rule of sorting the restaurants alphabetically, just like <strong class="source-inline">RestarauntsViewModel</strong> did, and then returns the list. In other words, <strong class="source-inline">GetRestaurantsUseCase</strong> is now the one responsible for applying business rules.</p>
			<p>This <a id="_idIndexMarker622"/>Use Case does that with only one public method, which is also a <strong class="source-inline">suspend</strong> function because the <strong class="source-inline">repository.getAllRestaurants()</strong> call is a suspending function call. But, more importantly, why did we name the function of the Use Case as <strong class="source-inline">invoke()</strong> while also specifying the <strong class="source-inline">operator</strong> keyword?</p>
			<p>We did that because Kotlin allows us to define an <strong class="source-inline">invoke</strong> operator on a class so we can call it on any instances of the class without a method name. This is how we will call the <strong class="source-inline">invoke()</strong> operator of <strong class="source-inline">GetRestaurantsUseCase</strong>:</p>
			<p class="source-code">val useCase = GetRestaurantsUseCase()</p>
			<p class="source-code">val result = <strong class="bold">useCase()</strong></p>
			<p>This syntax is especially useful for us because our Use Case classes have only one method, and the name of the class is already suggestive enough, so we don't need a named function.</p>
			<ol>
				<li value="2">Make sure to remove the sorting logic that we initially added in the <strong class="source-inline">getAllRestaurants()</strong> method in <strong class="source-inline">RestaurantsRepository</strong>. The returned data of the method should look like this:<p class="source-code">suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        try { … } catch (e: Exception) {…}</p><p class="source-code">        <strong class="bold">return@withContext restaurantsDao.getAll()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside <strong class="source-inline">RestaurantsViewModel</strong>, add a new dependency to the <strong class="source-inline">GetRestaurantsUseCase</strong> class:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">  private val repository = RestaurantsRepository()</p><p class="source-code">  <strong class="bold">private val getRestaurantsUseCase = GetRestaurantsUseCase()</strong></p><p class="source-code">  […]</p><p class="source-code">}</p></li>
				<li>Then, inside<a id="_idIndexMarker623"/> the <strong class="source-inline">getRestaurants()</strong> method of the <strong class="source-inline">ViewModel</strong>, remove the call for restaurants to the <strong class="source-inline">repository</strong> variable, and instead, call the <strong class="source-inline">invoke()</strong> operator for the <strong class="source-inline">getRestaurantsUseCase</strong> variable:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val restaurants = <strong class="bold">getRestaurantsUseCase()</strong></p><p class="source-code">        _state.value = _state.value.copy(</p><p class="source-code">            restaurants = restaurants, […])</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Before building and running the app, let's try to identify any other business rules for this particular flow of the app.</p>
			<p>If we have a look inside <strong class="source-inline">RestaurantsRepository</strong>, the <strong class="source-inline">toggleFavoriteRestaurant()</strong> method takes in an <strong class="source-inline">oldValue: Boolean</strong> parameter, and negates it before passing it to <strong class="source-inline">PartialRestaurant</strong>:</p>
			<p class="source-code">suspend fun toggleFavoriteRestaurant(</p>
			<p class="source-code">    id: Int,</p>
			<p class="source-code">    oldValue: Boolean</p>
			<p class="source-code">) =</p>
			<p class="source-code">    withContext(Dispatchers.IO) {</p>
			<p class="source-code">        restaurantsDao.update(</p>
			<p class="source-code">            PartialRestaurant(</p>
			<p class="source-code">                id = id,</p>
			<p class="source-code"><strong class="bold">                isFavorite = !oldValue</strong></p>
			<p class="source-code">            )</p>
			<p class="source-code">        )</p>
			<p class="source-code">        restaurantsDao.getAll()</p>
			<p class="source-code">    }</p>
			<p>This <a id="_idIndexMarker624"/>happens every time we mark a restaurant as a favorite or not favorite. The rule of negating <strong class="source-inline">oldValue</strong> of the favorite status of the restaurant (by passing <strong class="source-inline">!oldValue</strong>) can be considered a business rule imposed by the stakeholder: <em class="italic">whenever a user presses on the heart icon of a restaurant, we must toggle its favorite status to the opposite value</em>.</p>
			<p>To be able to reuse this business logic and not have it done by <strong class="source-inline">RestaurantsRepository</strong> , let's also extract this rule to a Use Case.</p>
			<ol>
				<li value="5">First, inside <strong class="source-inline">RestaurantsRepository</strong>, rename the <strong class="source-inline">oldValue</strong> parameter to <strong class="source-inline">value</strong> and make sure to not negate it anymore when passing it to the <strong class="source-inline">isFavorite</strong> field of <strong class="source-inline">PartialRestaurant</strong>:<p class="source-code">suspend fun toggleFavoriteRestaurant(id: Int, <strong class="bold">value</strong>: <strong class="bold">Boolean</strong>)=</p><p class="source-code">    withContext(Dispatchers.IO) {</p><p class="source-code">        restaurantsDao.update(</p><p class="source-code">           PartialRestaurant(id = id, isFavorite = <strong class="bold">value</strong>)</p><p class="source-code">        )</p><p class="source-code">        restaurantsDao.getAll()</p><p class="source-code">    }</p></li>
				<li>Click on the application package, select <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">ToggleRestaurantUseCase</strong> as the name, select <strong class="bold">Class</strong>, and add this code:<p class="source-code">class ToggleRestaurantUseCase {</p><p class="source-code">    private val repository: RestaurantsRepository =</p><p class="source-code">        RestaurantsRepository()</p><p class="source-code">    suspend operator fun invoke(</p><p class="source-code">        id: Int,</p><p class="source-code">        oldValue: Boolean</p><p class="source-code">    ): List&lt;Restaurant&gt; {</p><p class="source-code">        val newFav = oldValue.not()</p><p class="source-code">        return repository</p><p class="source-code">            .toggleFavoriteRestaurant(id, newFav)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This Use <a id="_idIndexMarker625"/>Case now encapsulates the business rule of negating the favorite flag of a restaurant with the <strong class="source-inline">val newFav = oldValue.not()</strong> line. While the business logic here is rather slim, in production apps, things tend to get more complex. This Use Case should be called whenever we mark a restaurant as a favorite or not favorite.</p>
			<ol>
				<li value="7">Inside <strong class="source-inline">RestaurantsViewModel</strong>, add a new dependency to the <strong class="source-inline">ToggleRestaurantUseCase</strong> class:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">    private val getRestaurantsUseCase =</p><p class="source-code">GetRestaurantsUseCase()</p><p class="source-code">    <strong class="bold">private val toggleRestaurantsUseCase = ToggleRestaurantUseCase()</strong></p><p class="source-code">    […]</p><p class="source-code">}</p></li>
			</ol>
			<p>At this step, you can also safely remove the <strong class="source-inline">RestaurantsViewModel</strong> class's dependency to the <strong class="source-inline">RestaurantsRepository</strong> class by removing the <strong class="source-inline">repository</strong> variable.</p>
			<ol>
				<li value="8">Then, inside the <strong class="source-inline">toggleFavorite()</strong> method of the <strong class="source-inline">ViewModel</strong>, remove the call for<a id="_idIndexMarker626"/> toggling the restaurant on the <strong class="source-inline">repository</strong> variable, and instead, call the <strong class="source-inline">invoke()</strong> operator for the <strong class="source-inline">toggleRestaurantUseCase</strong> variable:<p class="source-code">fun toggleFavorite(id: Int, oldValue: Boolean) {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val updatedRestaurants = </p><p class="source-code">            <strong class="bold">toggleRestaurantsUseCase(id, oldValue)</strong></p><p class="source-code">        _state.value = _state.value.copy(…)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, the business rule of toggling a restaurant as a favorite or not is done inside <strong class="source-inline">ToggleRestaurantUseCase</strong>.</p>
			<ol>
				<li value="9">Now that we have extracted business logic into Use Case classes, build the app and run it. The application should behave the same.</li>
			</ol>
			<p>Yet, if you try toggling a restaurant as a favorite, the list of restaurants still flickers, and their order seems to change. Can you think of why this happens?</p>
			<p>Let's circle back to <strong class="source-inline">RestaurantsRepository</strong> and check out the <strong class="source-inline">toggleFavoriteRestaurant</strong> method:</p>
			<p class="source-code">suspend fun toggleFavoriteRestaurant(…)= withContext(…) {</p>
			<p class="source-code">    restaurantsDao.update(</p>
			<p class="source-code">        PartialRestaurant(id = id, isFavorite = value)</p>
			<p class="source-code">    )</p>
			<p class="source-code">    restaurantsDao.getAll()</p>
			<p class="source-code">}</p>
			<p>The problem with this method is that it returns the restaurants obtained from the Room DAO by calling <strong class="source-inline">restaurantsDao.getAll()</strong>. These restaurants are not sorted alphabetically, as our business rules now indicate. So, every time we toggle a restaurant as favorite, we update the UI with the unsorted list of restaurants.</p>
			<p>We need to somehow reuse the sorting logic from <strong class="source-inline">GetRestaurantsUseCase</strong>:</p>
			<ol>
				<li value="1">First, from within <strong class="source-inline">RestaurantsRepository</strong>, remove the <strong class="source-inline">restaurantsDao.getAll()</strong> call from the <strong class="source-inline">toggleFavoriteRestaurant</strong> method:<p class="source-code">suspend fun toggleFavoriteRestaurant(…)= withContext(…) {</p><p class="source-code">    restaurantsDao.update(</p><p class="source-code">        PartialRestaurant(id = id, isFavorite = value)</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>This <a id="_idIndexMarker627"/>way, this method no longer returns a list of restaurants; it just updates a specific restaurant. As of now, the <strong class="source-inline">toggleFavoriteRestaurant</strong> method doesn't return anything anymore.</p>
			<ol>
				<li value="2">Then, inside the <strong class="source-inline">ToggleRestaurantUseCase</strong> class, remove the return statement for the <strong class="source-inline">repository.toggleFavoriteRestaurant()</strong> line, and instead return the sorted list of restaurants by directly instantiating and calling the <strong class="source-inline">invoke()</strong> operator on the <strong class="source-inline">GetRestaurantsUseCase</strong> class:<p class="source-code">class ToggleRestaurantUseCase {</p><p class="source-code">    private val repository: … = RestaurantsRepository()</p><p class="source-code">    suspend operator fun invoke(…): List&lt;Restaurant&gt; {</p><p class="source-code">        val newFav = oldValue.not()</p><p class="source-code">        repository.toggleFavoriteRestaurant(id, newFav)</p><p class="source-code">        <strong class="bold">return GetRestaurantsUseCase().invoke()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This <a id="_idIndexMarker628"/>approach fixes our issue – whenever we toggle a restaurant as a favorite or not, the UI no longer flickers because the UI is updated with the correctly sorted list – yet this happens with a lengthy delay.</p>
			<p>Unfortunately, this functionality is not efficient at all because whenever we toggle a restaurant as a favorite or not, the <strong class="source-inline">GetRestaurantsUseCase</strong> calls the <strong class="source-inline">RestaurantsRepository</strong> class's <strong class="source-inline">getAllRestaurants()</strong> method that, in turn, triggers a request to get the restaurants again from the Web API, attempts to cache them into <strong class="source-inline">Room</strong>, and only then provides us with a list, hence the delay we've just experienced.</p>
			<p>In a good application architecture, a network request that gets the new list of items shouldn't be done after every UI interaction with an item. Let's fix this by refactoring our code and by creating a new Use Case that only retrieves the cached restaurants, sorts them, and returns them:</p>
			<ol>
				<li value="1">First, inside <strong class="source-inline">RestaurantsRepository</strong>, add a new method called <strong class="source-inline">getRestaurants()</strong> that only retrieves the restaurants from our Room DAO:<p class="source-code">suspend fun getRestaurants() : List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        return@withContext restaurantsDao.getAll()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Click on the application package, select <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">GetSortedRestaurantsUseCase</strong> as the name, select <strong class="bold">Class</strong>, and add this code:<p class="source-code">class GetSortedRestaurantsUseCase {</p><p class="source-code">    private val repository: RestaurantsRepository = </p><p class="source-code">        RestaurantsRepository()</p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; {</p><p class="source-code">        return repository.getRestaurants()</p><p class="source-code">            .sortedBy { it.title }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">GetSortedRestaurantsUseCase</strong> class now retrieves the restaurants from <a id="_idIndexMarker629"/>the <strong class="source-inline">RestaurantsRepository</strong> by calling the previously created <strong class="source-inline">getRestaurants()</strong> method (without triggering any network request or caching), applies the sorting business rule, and finally, returns the list of restaurants.</p>
			<ol>
				<li value="3">Use the newly created <strong class="source-inline">GetSortedRestaurantsUseCase</strong> class inside <strong class="source-inline">ToggleRestaurantUseCase</strong> so that we only get the cached restaurants every time we toggle a restaurant as a favorite or not:<p class="source-code">class ToggleRestaurantUseCase {</p><p class="source-code">    private val repository: … = RestaurantsRepository()</p><p class="source-code">    <strong class="bold">private val getSortedRestaurantsUseCase =</strong></p><p class="source-code"><strong class="bold">       </strong> <strong class="bold">GetSortedRestaurantsUseCase()</strong></p><p class="source-code">    suspend operator fun invoke(…): List&lt;Restaurant&gt; {</p><p class="source-code">        val newFav = oldValue.not()</p><p class="source-code">        repository.toggleFavoriteRestaurant(id, newFav)</p><p class="source-code">        <strong class="bold">return getSortedRestaurantsUseCase()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, we must refactor <strong class="source-inline">GetRestaurantsUseCase</strong> to reuse the sorting business logic from within <strong class="source-inline">GetSortedRestaurantsUseCase</strong> because the alphabetical sorting logic is <a id="_idIndexMarker630"/>now duplicated in both Use Cases:</p>
			<ol>
				<li value="1">First, inside <strong class="source-inline">RestaurantsRepository</strong>, update the <strong class="source-inline">getAllRestaurants</strong> method to no longer return the restaurants by no longer returning <strong class="source-inline">restaurantsDao.getAll()</strong>, while also removing the function's return type:<p class="source-code">suspend fun getAllRestaurants() {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        try { … } catch (e: Exception) { … }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Rename the <strong class="source-inline">getAllRestaurants</strong> method to <strong class="source-inline">loadRestaurants()</strong> to better reflect its responsibility:<p class="source-code">suspend fun <strong class="bold">loadRestaurants()</strong> {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        try { … } catch (e: Exception) { … }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside <strong class="source-inline">GetRestaurantsUseCase</strong>, add a new dependency to the <strong class="source-inline">GetSortedRestaurantUseCase</strong> class and refactor the class as follows:<p class="source-code">class GetRestaurantsUseCase {</p><p class="source-code">    private val repository: … = RestaurantsRepository()</p><p class="source-code">    <strong class="bold">private val getSortedRestaurantsUseCase =</strong> </p><p class="source-code">        <strong class="bold">GetSortedRestaurantsUseCase()</strong></p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; {</p><p class="source-code">        <strong class="bold">repository.loadRestaurants()</strong></p><p class="source-code">        <strong class="bold">return getSortedRestaurantsUseCase()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">invoke()</strong> function, we made sure to first call the newly renamed <strong class="source-inline">loadRestaurants()</strong> method of the <strong class="source-inline">RestaurantsRepository</strong> and then, in addition, to invoke <strong class="source-inline">GetSortedRestaurantsUseCase</strong>, which is now also returned.</p>
			<ol>
				<li value="4">To better<a id="_idIndexMarker631"/> reflect its purpose, rename the <strong class="source-inline">GetRestaurantsUseCase</strong> class to <strong class="source-inline">GetInitialRestaurantsUseCase</strong>:<p class="source-code">class <strong class="bold">GetInitialRestaurantsUseCase</strong> {</p><p class="source-code">    private val repository: … = RestaurantsRepository()</p><p class="source-code">    private val getSortedRestaurantsUseCase = </p><p class="source-code">        GetSortedRestaurantsUseCase()</p><p class="source-code">    suspend operator fun invoke(): List&lt;Restaurant&gt; {...}</p><p class="source-code">}</p></li>
				<li>As a consequence, inside <strong class="source-inline">RestaurantsViewModel</strong>, update the type for the <strong class="source-inline">getRestaurantsUseCase</strong> variable:<p class="source-code">class RestaurantsViewModel() : ViewModel() {</p><p class="source-code">  private val repository = RestaurantsRepository()</p><p class="source-code">  private val getRestaurantsUseCase = </p><p class="source-code">      <strong class="bold">GetInitialRestaurantsUseCase()</strong></p><p class="source-code">  …</p><p class="source-code">}</p></li>
				<li>Build the app and run it. The application should now behave correctly when marking a restaurant as a favorite or not; the restaurants remain sorted alphabetically.</li>
			</ol>
			<p>Let's now move on to another way of improving the architecture of our app.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor288"/>Separating the Domain model from Data models</h1>
			<p>Inside the <a id="_idIndexMarker632"/>Domain layer, apart from Use Cases, another essential business component in our app is the <strong class="bold">Domain model component</strong>. The Domain model components <a id="_idIndexMarker633"/>are those classes that represent core business data or concepts used throughout the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since the Domain models reside inside the Domain layer, they should be agnostic of any third-party library or dependency – ideally, they should be pure Java or Kotlin classes.</p>
			<p>For example, in our Restaurants app, the core entity used throughout the app (retrieved, updated, and displayed) is the <strong class="source-inline">Restaurant</strong> data class, which contains data such as <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong>.</p>
			<p>If we think about it, our Restaurants app's core business entity is represented by the restaurant itself: that's what the application is about, so it's only natural that we would consider the <strong class="source-inline">Restaurant</strong> class as a business entity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In Clean Architecture, Domain model classes are often referred to as Entity classes. However, it's important to mention that the Room database <strong class="source-inline">@Entity</strong> annotation has nothing to do with Clean Architecture; any class annotated with the Room <strong class="source-inline">@Entity</strong> annotation doesn't automatically become an entity. In fact, as per Clean Architecture, Entity classes should have no library dependencies such as database annotations.</p>
			<p>If we have a <a id="_idIndexMarker634"/>look at our <strong class="source-inline">Restaurant</strong> data class though, we can identify a serious issue:</p>
			<p class="source-code">import androidx.room.ColumnInfo</p>
			<p class="source-code">      …</p>
			<p class="source-code">import com.google.gson.annotations.SerializedName</p>
			<p class="source-code">@Entity(tableName = "restaurants")</p>
			<p class="source-code">data class Restaurant(</p>
			<p class="source-code">    @PrimaryKey()</p>
			<p class="source-code">    @ColumnInfo(name = "r_id")</p>
			<p class="source-code">    @SerializedName("r_id")</p>
			<p class="source-code">    val id: Int,</p>
			<p class="source-code">    @ColumnInfo(name = "r_title")</p>
			<p class="source-code">    @SerializedName("r_title")</p>
			<p class="source-code">    val title: String,</p>
			<p class="source-code">      …</p>
			<p class="source-code">)</p>
			<p>Can you spot the problem?</p>
			<p>While, in the beginning, the <strong class="source-inline">Restaurant</strong> data class was a pure Kotlin data class with some fields, in time, it grew to something more than that.</p>
			<p>We first added Retrofit to our app so we could get the restaurants from a Web API, and had to mark the fields we obtained with <strong class="source-inline">@SerializedName</strong> annotations so that the GSON (Google Gson) deserialization would work. Then we added Room to the mix because we wanted to cache the restaurants, so we had to add an <strong class="source-inline">@Entity</strong> annotation to the class, and other annotations, such as <strong class="source-inline">@PrimaryKey</strong> and <strong class="source-inline">@ColumnInfo</strong>, to its fields.</p>
			<p>While it was convenient for us to use only one Data model class throughout the app, we have now coupled a Domain model class (<strong class="source-inline">Restaurant.kt</strong>) to library dependencies, such as GSON or Room. This means that our Domain model is coupled to the Data or Model layer that is responsible for obtaining data.</p>
			<p>According <a id="_idIndexMarker635"/>to Clean Architecture, the Domain model classes should reside inside the Domain layer and be agnostic of any libraries tightly related to the way we retrieve or cache data from several sources.</p>
			<p>In other words, we need to make a separation between Domain models and <strong class="bold">Data Transfer Objects </strong>(<strong class="bold">DTOs</strong>) by <a id="_idIndexMarker636"/>creating separate classes for both types. While Domain models are plain Kotlin classes, DTOs are classes that contain both the fields needed for a specific data operation, such as caching items to a local source, but also dependencies such as library annotations.</p>
			<p>With such a separation, the Domain model is now a business entity that doesn't care about implementation details (such as libraries), so every time we might have to replace a library (such as Retrofit or Room) with another library, we must only update the DTOs (hence, the Model layer) and not classes within the Domain model.</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B17788_08_04.jpg" alt="Figure 8.4 – Separating Domain models from DTO models&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Separating Domain models from DTO models</p>
			<p>To achieve such a separation in our Restaurants app, we must split our <strong class="source-inline">Restaurant</strong> class into three classes. We must do the following:</p>
			<ul>
				<li>Create two DTOs as <strong class="source-inline">data class</strong> classes that will be used for transferring data:<ul><li>A <strong class="source-inline">RemoteRestaurant</strong> class that will contain the fields received from the Web API. These fields will also be annotated with GSON serialization annotations required by Retrofit to parse the response.</li><li>A <strong class="source-inline">LocalRestaurant</strong> class that will contain the fields and their corresponding annotations required by Room to cache restaurants.</li></ul></li>
				<li>Refactor <a id="_idIndexMarker637"/>the <strong class="source-inline">Restaurant</strong> data class to be a plain Kotlin data class, without any third-party dependencies. This way, the <strong class="source-inline">Restaurant</strong> data class will be a proper Domain model class, independent of the Model layer that is tightly coupled to third-party libraries.</li>
			</ul>
			<p>Let's begin!</p>
			<ol>
				<li value="1">Click on the application package, select <strong class="bold">New</strong>, and then <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RemoteRestaurant</strong> as the name, select <strong class="bold">Class</strong>, and add this code to define the DTO for our remote source (Firebase remote database):<p class="source-code">data class RemoteRestaurant(</p><p class="source-code">    @SerializedName("r_id")</p><p class="source-code">    val id: Int,</p><p class="source-code">    @SerializedName("r_title")</p><p class="source-code">    val title: String,</p><p class="source-code">    @SerializedName("r_description")</p><p class="source-code">    val description: String)</p></li>
			</ol>
			<p>Inside this class, we have added all the fields received from the Web API, along with their corresponding serialization fields. You can get these annotations and their imports from the <strong class="source-inline">Restaurant</strong> class.</p>
			<p>Another advantage of having a separate DTO class is that it now contains only the necessary fields – for instance, unlike <strong class="source-inline">Restaurant</strong>, <strong class="source-inline">RemoteRestaurant</strong> no longer contains an <strong class="source-inline">isFavorite</strong> field because we don't receive it from the REST API of our Firebase Database.</p>
			<ol>
				<li value="2">Click on the<a id="_idIndexMarker638"/> application package and create a new file called <strong class="source-inline">LocalRestaurant</strong>. Add this code to define the DTO for our local source (Room local database):<p class="source-code">@Entity(tableName = "restaurants")</p><p class="source-code">data class LocalRestaurant(</p><p class="source-code">    @PrimaryKey()</p><p class="source-code">    @ColumnInfo(name = "r_id")</p><p class="source-code">    val id: Int,</p><p class="source-code">    @ColumnInfo(name = "r_title")</p><p class="source-code">    val title: String,</p><p class="source-code">    @ColumnInfo(name = "r_description")</p><p class="source-code">    val description: String,</p><p class="source-code">    @ColumnInfo(name = "is_favorite")</p><p class="source-code">    val isFavorite: Boolean = false)</p></li>
			</ol>
			<p>You can get the fields, annotations, and their imports from the <strong class="source-inline">Restaurant</strong> class.</p>
			<ol>
				<li value="3">Now, navigate to the <strong class="source-inline">Restaurant</strong> class. It's time to remove all its third-party dependencies to Room and GSON and keep it as a simple Domain model class containing the fields that define our restaurant entity. It should now look like this:<p class="source-code">data class Restaurant(</p><p class="source-code">    val id: Int,</p><p class="source-code">    val title: String,</p><p class="source-code">    val description: String,</p><p class="source-code">    val isFavorite: Boolean = false)</p></li>
			</ol>
			<p>Make sure to also remove any imports for the GSON and Room annotations.</p>
			<ol>
				<li value="4">Inside the <strong class="source-inline">RestaurantsDb</strong> class, update the entity used in Room to our newly created <strong class="source-inline">LocalRestaurant</strong>, while also updating the schema version to <strong class="source-inline">3</strong>, just to be sure that Room will provide a fresh start:<p class="source-code">@Database(</p><p class="source-code">    entities = <strong class="bold">[LocalRestaurant::class],</strong></p><p class="source-code">    version = <strong class="bold">3</strong>,</p><p class="source-code">    exportSchema = false)</p><p class="source-code">abstract class RestaurantsDb : RoomDatabase() {</p><p class="source-code">    abstract val dao: RestaurantsDao</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Rename <a id="_idIndexMarker639"/>the <strong class="source-inline">PartialRestaurant</strong> class to <strong class="source-inline">PartialLocalRestaurant</strong> to better clarify that this class is used by our local data source, Room:<p class="source-code">@Entity</p><p class="source-code">class <strong class="bold">PartialLocalRestaurant</strong>(</p><p class="source-code">@ColumnInfo(name = "r_id")</p><p class="source-code">val id: Int,</p><p class="source-code">@ColumnInfo(name = "is_favorite")</p><p class="source-code">val isFavorite: Boolean)</p></li>
				<li>Inside the <strong class="source-inline">RestaurantsDao</strong> interface, replace the <strong class="source-inline">Restaurant</strong> class usages with <strong class="source-inline">LocalRestaurant</strong>, and the <strong class="source-inline">PartialRestaurant</strong> class usages <a id="_idIndexMarker640"/>with <strong class="source-inline">PartialLocalRestaurant</strong>:<p class="source-code">@Dao</p><p class="source-code">interface RestaurantsDao {</p><p class="source-code">    @Query("SELECT * FROM restaurants")</p><p class="source-code">    suspend fun getAll(): List&lt;<strong class="bold">LocalRestaurant</strong>&gt;</p><p class="source-code">    @Insert(onConflict = OnConflictStrategy.REPLACE)</p><p class="source-code">    suspend fun addAll(restaurants: </p><p class="source-code">        List&lt;<strong class="bold">LocalRestaurant</strong>&gt;)</p><p class="source-code">    @Update(entity = <strong class="bold">LocalRestaurant</strong>::class)</p><p class="source-code">    suspend fun update(partialRestaurant: </p><p class="source-code">       <strong class="bold">PartialLocalRestaurant</strong>)</p><p class="source-code">    @Update(entity = <strong class="bold">LocalRestaurant</strong>::class)</p><p class="source-code">    suspend fun updateAll(partialRestaurants: </p><p class="source-code">        List&lt;<strong class="bold">PartialLocalRestaurant</strong>&gt;)</p><p class="source-code">    @Query("SELECT * FROM restaurants WHERE </p><p class="source-code">        is_favorite = 1")</p><p class="source-code">    suspend fun getAllFavorited(): List&lt;<strong class="bold">LocalRestaurant</strong>&gt;</p><p class="source-code">}</p></li>
				<li>Inside <strong class="source-inline">RestaurantsRepository</strong>, navigate to the <strong class="source-inline">toggleFavoriteRestaurant()</strong> method, and replace the <strong class="source-inline">PartialRestaurant</strong> usage with <strong class="source-inline">PartialLocalRestaurant</strong>:<p class="source-code">suspend fun toggleFavoriteRestaurant(</p><p class="source-code">      …</p><p class="source-code">) = withContext(Dispatchers.IO) {</p><p class="source-code">    restaurantsDao.update(</p><p class="source-code">      <strong class="bold">PartialLocalRestaurant</strong>(id = id, isFavorite = value)</p><p class="source-code">    )</p><p class="source-code">}</p></li>
				<li>Still<a id="_idIndexMarker641"/> inside <strong class="source-inline">RestaurantsRepository</strong>, navigate to the <strong class="source-inline">getRestaurants()</strong> method, and map the <strong class="source-inline">LocalRestaurant</strong> objects (received by the <strong class="source-inline">restaurantsDao.getAll()</strong> method call) to <strong class="source-inline">Restaurant</strong> objects:<p class="source-code">suspend fun getRestaurants() : List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        return@withContext restaurantsDao.getAll()<strong class="bold">.map {</strong></p><p class="source-code">            <strong class="bold">Restaurant(it.id, it.title, </strong></p><p class="source-code"><strong class="bold">                it.description,</strong> <strong class="bold">it.isFavorite)</strong></p><p class="source-code">        <strong class="bold">}</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>We have mapped <strong class="source-inline">List&lt;LocalRestaurant&gt;</strong> to <strong class="source-inline">List&lt;Restaurant&gt;</strong> by using the <strong class="source-inline">.map { }</strong> extension function. We did that by constructing and returning a <strong class="source-inline">Restaurant</strong> object from <strong class="source-inline">LocalRestaurant</strong>, represented by the <strong class="source-inline">it</strong> implicit variable name.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Your Model layer (represented by the <strong class="source-inline">Repository</strong> here), should only return Domain model objects to the Domain entity. In our case, <strong class="source-inline">RestaurantsRepository</strong> should return <strong class="source-inline">Restaurant</strong> objects, and not <strong class="source-inline">LocalRestaurants</strong> objects, simply because the Use Case classes (so, the Domain layer) that use this <strong class="source-inline">Repository</strong> shouldn't have any knowledge of DTO classes from the Model layer.</p>
			<ol>
				<li value="9">Navigate<a id="_idIndexMarker642"/> to the <strong class="source-inline">RestaurantsApiService</strong> interface (the Retrofit interface) and replace the usages of the <strong class="source-inline">Restaurant</strong> class with <strong class="source-inline">RemoteRestaurant</strong>:<p class="source-code">interface RestaurantsApiService {</p><p class="source-code">   @GET("restaurants.json")</p><p class="source-code">    suspend fun getRestaurants(): List&lt;<strong class="bold">RemoteRestaurant</strong>&gt;</p><p class="source-code">   @GET("restaurants.json?orderBy=\"r_id\"")</p><p class="source-code">    suspend fun getRestaurant(…):  </p><p class="source-code">        Map&lt;String, <strong class="bold">RemoteRestaurant</strong>&gt;</p><p class="source-code">}</p></li>
				<li>Going back to <strong class="source-inline">RestaurantsRepository</strong>, navigate to the <strong class="source-inline">refreshCache()</strong> method and map the <strong class="source-inline">remoteRestaurants</strong> list from Retrofit to <strong class="source-inline">LocalRestaurant</strong> objects so that <strong class="source-inline">restaurantsDao</strong> can cache them:<p class="source-code">private suspend fun refreshCache() {</p><p class="source-code">    val remoteRestaurants = restInterface</p><p class="source-code">        .getRestaurants()</p><p class="source-code">    val favoriteRestaurants = restaurantsDao</p><p class="source-code">        .getAllFavorited()</p><p class="source-code">    restaurantsDao.addAll(remoteRestaurants.<strong class="bold">map {</strong></p><p class="source-code"><strong class="bold">        LocalRestaurant(</strong></p><p class="source-code"><strong class="bold">            it.id,</strong></p><p class="source-code"><strong class="bold">            it.title,</strong></p><p class="source-code"><strong class="bold">            it.description,</strong></p><p class="source-code"><strong class="bold">            false</strong></p><p class="source-code"><strong class="bold">        )</strong></p><p class="source-code"><strong class="bold">    }</strong>)</p><p class="source-code">    restaurantsDao.updateAll(</p><p class="source-code">        favoriteRestaurants.map {</p><p class="source-code">            <strong class="bold">PartialLocalRestaurant</strong>(</p><p class="source-code">                id = it.id,</p><p class="source-code">                isFavorite = true</p><p class="source-code">            )</p><p class="source-code">        })</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, make sure to update the usage of <strong class="source-inline">PartialRestaurant</strong> to <strong class="source-inline">PartialLocalRestaurant</strong> in the <strong class="source-inline">restaurantsDao.updateAll()</strong> method call.</p>
			<ol>
				<li value="11">Navigate<a id="_idIndexMarker643"/> to <strong class="source-inline">RestaurantsDetailsViewModel</strong> and, inside the <strong class="source-inline">getRemoteRestaurant()</strong> method, map the <strong class="source-inline">RemoteRestaurant</strong> object received from the Retrofit API to a <strong class="source-inline">Restaurant</strong> object by using the <strong class="source-inline">?.let{ }</strong> extension function:<p class="source-code">private suspend fun getRemoteRestaurant(id: Int): Restaurant {</p><p class="source-code">    return withContext(Dispatchers.IO) {</p><p class="source-code">        val response =  restInterface.getRestaurant(id)</p><p class="source-code">        return@withContext response.values.first().<strong class="bold">let {</strong></p><p class="source-code">            <strong class="bold">Restaurant(</strong></p><p class="source-code">                <strong class="bold">id = it.id, </strong></p><p class="source-code">                <strong class="bold">title = it.title,</strong> </p><p class="source-code">                <strong class="bold">description = it.description</strong></p><p class="source-code">            <strong class="bold">)</strong></p><p class="source-code">        <strong class="bold">}</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Remember<a id="_idIndexMarker644"/> that in the restaurant details screen, we don't have any business logic or Use Cases, or even a <strong class="source-inline">Repository</strong>, so we have directly added a variable for the Retrofit interface inside the <strong class="source-inline">ViewModel</strong> – and that's why we are mapping the Domain model inside the <strong class="source-inline">ViewModel</strong>.</p>
			<ol>
				<li value="12">Build and run the app. The app should behave the same.</li>
			</ol>
			<p>Let's now take a break from creating classes and let's organize our project a bit.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor289"/>Creating a package structure</h1>
			<p>Our <a id="_idIndexMarker645"/>Restaurants app has come a long way. As we tried to separate responsibilities and concerns as much as possible, new classes emerged – quite a few actually.</p>
			<p>If we have a look on the left of Android Studio, on the <strong class="bold">Project</strong> tab, we have an overview of the classes we've defined in our project.</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B17788_08_05.jpg" alt="Figure 8.5 – Project structure without any package structuring strategy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Project structure without any package structuring strategy</p>
			<p>It's clear <a id="_idIndexMarker646"/>that our project has no folder structure at all – all files and classes are tossed around inside the <strong class="source-inline">restaurantsapp</strong> root package.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The name of the root package might differ if you selected a different name for your app.</p>
			<p>Because we've opted to throw any new class inside the root package, it's difficult to have clear visibility over the project. Our approach is similar to adding dozens of files and assets on the desktop of our PC – in time, it becomes impossible to find anything on the screen.</p>
			<p>To alleviate this issue, we can opt <a id="_idIndexMarker647"/>for a <strong class="bold">packaging strategy</strong> for our project in which each class belongs to a folder. A clear folder structure allows developers to have good visibility and to gain valuable insight into the application's components, there by allowing easier access and navigation through the project files.</p>
			<p>The most common<a id="_idIndexMarker648"/> package organizing <a id="_idIndexMarker649"/>strategies are as follows:</p>
			<ul>
				<li><strong class="bold">Organize packages by category or layer</strong>: For this strategy, each package contains classes that are of the same type or belong to the same layer. The following are examples:<ul><li>A <strong class="source-inline">presentation</strong> package would contain all the files related to the Presentation layer, regardless of the feature they belong to, such as all the files with composables, and all the <strong class="source-inline">ViewModel</strong> classes.</li><li>Similarly, a <strong class="source-inline">data</strong> package would contain all files related to the Model layer, regardless of the feature they belong to, such as repositories, Retrofit interfaces, or Room DAO interfaces.</li></ul></li>
				<li><strong class="bold">Organize packages by feature</strong>: For this strategy, the root packages represent and reflect a specific feature of the app. For example, a <strong class="source-inline">restaurants</strong> package would contain all the classes related to the <strong class="source-inline">restaurants</strong> feature, from UI classes to <strong class="source-inline">ViewModel</strong> classes, Use Cases, and repositories.</li>
			</ul>
			<p>Both approaches have their pros and cons, but most notably, the package organization by layer doesn't scale well if the app has a lot of features, as there is no way to differentiate between classes from different features.</p>
			<p>On the other hand, the package organization by feature can be problematic if, in each feature package, all classes are thrown around without any distinct categorization.</p>
			<p>For our Restaurants app, we will use a mix of these two strategies. More specifically, we will do the following:</p>
			<ul>
				<li>Keep <strong class="source-inline">RestaurantsApplication.kt</strong> inside the root package.</li>
				<li>Create a root package for the only feature our application has, named <strong class="source-inline">restaurants</strong>. This package will contain the functionality for displaying both the list of restaurants and the detail screen.</li>
				<li>Create sub-packages inside the <strong class="source-inline">restaurants</strong> package for each layer:<ul><li><strong class="source-inline">Presentation</strong>: For composables and <strong class="source-inline">ViewModel</strong> classes. Inside this package, we can <a id="_idIndexMarker650"/>also break the screens that we have into separate packages: <strong class="source-inline">list</strong> for the first screen with the list of restaurants, and <strong class="source-inline">details</strong> for the second screen with the details of one restaurant. Additionally, we will keep the <strong class="source-inline">MainActivity</strong> class inside the <strong class="source-inline">presentation</strong> package since it's the host component for the UI.</li><li><strong class="source-inline">Data</strong>: For classes within the Model layer. Here, we will not only add <strong class="source-inline">RestaurantsRepository,</strong> but we'll also create two sub-packages for the two different data sources: <strong class="source-inline">local</strong> (for caching classes such as <strong class="source-inline">RestaurantsDao</strong> and <strong class="source-inline">LocalRestaurant</strong>), and <strong class="source-inline">remote</strong> (for classes related to the remote source such as <strong class="source-inline">RestaurantsApiService</strong> and <strong class="source-inline">RemoteRestaurant</strong>).</li><li><strong class="source-inline">Domain</strong>: For business-related classes, the Use Case classes, and also the <strong class="source-inline">Restaurant.kt</strong> Domain model class.</li></ul></li>
			</ul>
			<p>With this approach, if we were to add a new feature, maybe related to ordering (which we could call <strong class="source-inline">ordering</strong>), the package structure would provide us with immediate information about the features our application contains. When expanding a certain feature package, we can expand the package of the layer we're interested in working with and have a clear overview of the components we need to update or modify.</p>
			<p>To achieve such a packaging structure, you will have to perform the following actions a few times:</p>
			<ol>
				<li value="1">Create a new package. To do that, left-click on a certain existing package (such as the <strong class="source-inline">restaurantsapp</strong> package), select <strong class="bold">New</strong>, then <strong class="bold">Package</strong>, and finally, enter the name of the package.</li>
				<li>Move an existing class into an existing package. To do that, simply drag the file and drop it into the desired package.</li>
			</ol>
			<p>In the end, the <a id="_idIndexMarker651"/>package structure that we described and that we want to achieve is the following:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B17788_08_06.jpg" alt="Figure 8.6 – Project structure after applying our package structuring strategy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Project structure after applying our package structuring strategy</p>
			<p>Keep in mind, however, that when moving the <strong class="source-inline">MainActivity.kt</strong> file from its initial location to the <strong class="source-inline">presentation</strong> package, you might have to update the <strong class="source-inline">Manifest.xml</strong> file to reference the new correct path to the <strong class="source-inline">MainActivity.kt</strong> file:</p>
			<p class="source-code">&lt;manifest […]&gt;</p>
			<p class="source-code">    […]</p>
			<p class="source-code">    &lt;application</p>
			<p class="source-code">        […]</p>
			<p class="source-code">        &lt;activity</p>
			<p class="source-code">            android:name="<strong class="bold">.restaurants.presentation.</strong></p>
			<p class="source-code"><strong class="bold">                MainActivity</strong>"</p>
			<p class="source-code">            android:exported="true"</p>
			<p class="source-code">            android:label="@string/app_name"</p>
			<p class="source-code">            android:theme="@style/Theme.RestaurantsApp.</p>
			<p class="source-code">                NoActionBar"&gt;</p>
			<p class="source-code">            &lt;intent-filter&gt;</p>
			<p class="source-code">                […]</p>
			<p class="source-code">            &lt;/intent-filter&gt;</p>
			<p class="source-code">            &lt;intent-filter&gt;</p>
			<p class="source-code">                […]</p>
			<p class="source-code">            &lt;/intent-filter&gt;</p>
			<p class="source-code">        &lt;/activity&gt;</p>
			<p class="source-code">    &lt;/application&gt;</p>
			<p class="source-code">&lt;/manifest&gt;</p>
			<p>Some versions <a id="_idIndexMarker652"/>of Android Studio do that out of the box for you; however, if they don't, you might end up with a nasty compilation error because the <strong class="source-inline">Manifest.xml</strong> file is no longer detecting our <strong class="source-inline">Activity</strong>.</p>
			<p>Now that we have refactored the structure of our project, we can say that the packages structure provides us with immediate information about the features of the app (in our case, there is only one feature related to restaurants) and also with a clear overview of the components corresponding to a specific feature.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The autogenerated files for Compose projects (<strong class="source-inline">Color.kt</strong>, <strong class="source-inline">Shape.kt</strong>, <strong class="source-inline">Theme.kt</strong>, and <strong class="source-inline">Type.kt</strong>) were left inside the <strong class="source-inline">theme</strong> package that resides inside the <strong class="source-inline">ui</strong> package. This is because theming should be consistent across features.</p>
			<p>Let's now move on <a id="_idIndexMarker653"/>to another way of improving the decoupling inside the UI layer between the composables and the <strong class="source-inline">ViewModel</strong>.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor290"/>Decoupling the Compose-based UI layer from ViewModel</h1>
			<p>Our <a id="_idIndexMarker654"/>UI layer (represented by the composable functions) is tightly coupled to the <strong class="source-inline">ViewModel</strong>. This is natural, since the screen composables<a id="_idIndexMarker655"/> instantiate their own <strong class="source-inline">ViewModel</strong> to do the following:</p>
			<ul>
				<li>Obtain the UI state and consume it</li>
				<li>Pass events (such as clicking on a UI item) up to the <strong class="source-inline">ViewModel</strong></li>
			</ul>
			<p>As an example, we can see how the <strong class="source-inline">RestaurantsScreen()</strong> composable uses an instance of <strong class="source-inline">RestaurantsViewModel</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p>
			<p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p>
			<p class="source-code">    val state = viewModel.state.value</p>
			<p class="source-code">    Box(…) { … }</p>
			<p class="source-code">}</p>
			<p>The problem with our approach is that if we want to later test the UI layer, then, inside the test, the <strong class="source-inline">RestaurantsScreen</strong> composable will instantiate <strong class="source-inline">RestaurantsViewModel</strong>, which in turn will get data from Use Case classes, which in turn will trigger heavy I/O work in <strong class="source-inline">RestaurantsRepository</strong> (like the network request to obtain the restaurants, or the operation of saving them inside the local database).</p>
			<p>When we have to test the UI, we should not care whether the <strong class="source-inline">ViewModel</strong> obtains the data correctly and translates it into a proper UI state. The effect of separating concerns is to facilitate testing a target class (or composable in this discussion) without having to care about other layers doing their work.</p>
			<p>Right now, our <a id="_idIndexMarker656"/>screen composables are tied to a library dependency, the <strong class="source-inline">ViewModel</strong>, and it's ideal to decouple such dependencies as much as possible to promote reusability and testability.</p>
			<p>In order to <a id="_idIndexMarker657"/>decouple the <strong class="source-inline">RestaurantsScreen()</strong> composable as much as possible from its <strong class="source-inline">ViewModel</strong>, we will refactor it so that the following happens:</p>
			<ul>
				<li>It will no longer reference a <strong class="source-inline">ViewModel</strong> class (the <strong class="source-inline">RestaurantsViewModel</strong> class).</li>
				<li>Instead, it will receive a <strong class="source-inline">RestaurantsScreenState</strong> object as a parameter.</li>
				<li>It will also define new function parameters to expose callbacks to its caller – we will see who the caller is in a minute.<p class="callout-heading">Note</p><p class="callout">By extracting the <strong class="source-inline">ViewModel</strong> instantiation from screen composables, such as <strong class="source-inline">RestaurantsScreen()</strong>, we're promoting reusability in the sense that we can much easier replace the ViewModel type that creates the state for this composable. This approach also enables us to port the Compose-based UI layer much easier<a id="_idIndexMarker658"/> to <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>) projects.</p></li>
			</ul>
			<p>Let's begin!</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RestaurantsScreen</strong> file, update the <strong class="source-inline">RestaurantsScreen() </strong>composable by removing its <strong class="source-inline">viewModel</strong> and <strong class="source-inline">state</strong> variables, while also making sure it receives a <strong class="source-inline">RestaurantsScreenState</strong> object as a <strong class="source-inline">state</strong> parameter and an <strong class="source-inline">onFavoriteClick</strong> function:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(</p><p class="source-code"><strong class="bold">    state: RestaurantsScreenState,</strong></p><p class="source-code">    onItemClick: (id: Int) -&gt; Unit,</p><p class="source-code"><strong class="bold">    onFavoriteClick: (id: Int, oldValue: Boolean) -&gt; Unit</strong></p><p class="source-code">) {</p><p class="source-code">    Box(…) {</p><p class="source-code">        LazyColumn(…) {</p><p class="source-code">            items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;</p><p class="source-code">                RestaurantItem(</p><p class="source-code">                    restaurant,</p><p class="source-code">                    onFavoriteClick = { id, oldValue -&gt;</p><p class="source-code"><strong class="bold">                        onFavoriteClick(id, oldValue)</strong></p><p class="source-code">                    },</p><p class="source-code">                    onItemClick = { id -&gt;</p><p class="source-code">                        onItemClick(id)</p><p class="source-code">                    }</p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        […]</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Additionally, make<a id="_idIndexMarker659"/> sure to remove the <strong class="source-inline">viewModel.toggleFavorite()</strong> call and instead, call the newly added <strong class="source-inline">onFavoriteClick()</strong> function inside the <strong class="source-inline">RestaurantItem</strong> corresponding callback.</p>
			<ol>
				<li value="2">Since we changed <a id="_idIndexMarker660"/>the signature of the <strong class="source-inline">RestaurantsScreen()</strong> function, we must also update the <strong class="source-inline">DefaultPreview()</strong> composable to correctly call the <strong class="source-inline">RestaurantsScreen()</strong> composable:<p class="source-code">@Preview(showBackground = true)</p><p class="source-code">@Composable</p><p class="source-code">fun DefaultPreview() {</p><p class="source-code">    RestaurantsAppTheme {</p><p class="source-code">        RestaurantsScreen(</p><p class="source-code">            <strong class="bold">RestaurantsScreenState(listOf(), true),</strong></p><p class="source-code"><strong class="bold">            {},</strong></p><p class="source-code"><strong class="bold">            { _, _ -&gt; }</strong></p><p class="source-code">        )</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">MainActivity</strong> class and inside the <strong class="source-inline">RestaurantsApp()</strong> composable, make<a id="_idIndexMarker661"/> the destination composable for <strong class="source-inline">RestaurantsScreen()</strong> responsible for wiring up the screen<a id="_idIndexMarker662"/> composable with its <strong class="source-inline">ViewModel</strong>, thereby ensuring good communication between <strong class="source-inline">RestaurantsScreen()</strong> and <strong class="source-inline">RestaurantsViewModel</strong>:<p class="source-code">@Composable</p><p class="source-code">private fun RestaurantsApp() {</p><p class="source-code">    val navController = rememberNavController()</p><p class="source-code">    NavHost(navController, startDestination = </p><p class="source-code">        "restaurants") {</p><p class="source-code">        composable(route = "restaurants") {</p><p class="source-code">            <strong class="bold">val viewModel: RestaurantsViewModel = </strong></p><p class="source-code"><strong class="bold">                viewModel()</strong></p><p class="source-code">            RestaurantsScreen<strong class="bold">(</strong></p><p class="source-code">                <strong class="bold">state = viewModel.state.value,</strong></p><p class="source-code">                <strong class="bold">onItemClick = { id -&gt;</strong></p><p class="source-code">                    <strong class="bold">navController</strong></p><p class="source-code">                        <strong class="bold">.navigate("restaurants/$id")</strong></p><p class="source-code">                <strong class="bold">},</strong></p><p class="source-code">                <strong class="bold">onFavoriteClick = { id, oldValue -&gt;</strong></p><p class="source-code">                   <strong class="bold">viewModel.toggleFavorite(id, oldValue)</strong></p><p class="source-code">                <strong class="bold">})</strong></p><p class="source-code">        }</p><p class="source-code">        composable(</p><p class="source-code">            route = "restaurants/{restaurant_id}",</p><p class="source-code">            […]) { RestaurantDetailsScreen() }</p><p class="source-code">        }</p></li>
			</ol>
			<p>With this<a id="_idIndexMarker663"/> approach, the destination <strong class="source-inline">composable()</strong> with the initial route of <strong class="source-inline">"restaurants"</strong> is the<a id="_idIndexMarker664"/> composable that manages and wires up the <strong class="source-inline">RestaurantsScreen()</strong> composable to its content by doing the following:</p>
			<ul>
				<li>Instantiating <strong class="source-inline">RestaurantsViewModel</strong></li>
				<li>Getting and passing the state to <strong class="source-inline">RestaurantsScreen()</strong></li>
				<li>Handling the <strong class="source-inline">onItemClick()</strong> and <strong class="source-inline">onFavoriteClick()</strong> callbacks</li>
			</ul>
			<ol>
				<li value="4">Build and run the application. The app should behave the same.</li>
				<li>You will notice that if you rebuild the project and navigate back to the <strong class="source-inline">RestaurantsScreen()</strong> composable, the preview will now function correctly because the <strong class="source-inline">RestaurantsScreen()</strong> composable is no longer tied to a <strong class="source-inline">ViewModel</strong>, and so Compose can very easily preview its content.<p class="callout-heading">Assignment</p><p class="callout">In this chapter, we have better decoupled the first screen of the app (the <strong class="source-inline">RestaurantScreen()</strong> composable) from its <strong class="source-inline">ViewModel</strong> to promote reusability and testability. As homework, you can practice doing the same for the <strong class="source-inline">RestaurantDetailScreen()</strong> composable.</p></li>
			</ol>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor291"/>Summary</h1>
			<p>In this chapter, we have dipped our toes into Clean Architecture in Android. We started by understanding a bit about what Clean Architecture means and some of the best ways we can achieve this in our Restaurants app, while also covering the main benefits of following such a software design philosophy.</p>
			<p>We started with Clean Architecture in the first section, where we defined the Domain layer with Use Cases, and continued refactoring in the second section, where we separated the Domain model from Data models.</p>
			<p>Then, we improved the architecture of the app by creating a package structure and by decoupling the Compose-based UI layer from the <strong class="source-inline">ViewModel</strong> classes even further.</p>
			<p>In the next chapter, we will continue our journey of improving the architecture of our application by adopting dependency injection.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor292"/>Further reading</h1>
			<p>Clean Architecture is a very complex subject, and one chapter is simply not enough to cover it. However, one of the most important concepts that Clean Architecture brings is the Dependency Rule. The Dependency Rule states that within a project, dependencies can only point inward.</p>
			<p>To understand what the Dependency Rule is about, let's visualize the layer dependencies of our Restaurants app through a simplified version of concentric circles. Each concentric circle represents different areas of software with their corresponding layer dependencies (and libraries).</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B17788_08_07.jpg" alt="Figure 8.7 – The Dependency Rule with layers and components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – The Dependency Rule with layers and components</p>
			<p>This representation dictates that implementation details should be placed in <em class="italic">outer</em> circles (just as Compose is an implementation detail of the UI layer or Retrofit is an implementation detail for the Data layer), while business policies (Use Cases from the Domain layer) are placed within the <em class="italic">inner</em> circle.</p>
			<p>The purpose of this representation is to enforce the Dependency Rule that states how dependencies should only be pointing inward.</p>
			<p>The Dependency Rule (expressed with the inward-pointing arrows) showcases the following:</p>
			<ul>
				<li>The Presentation layer depends inward on the Domain layer (just like the <strong class="source-inline">ViewModel</strong>  classes in our app correctly depend on Use Case classes) and how the Data layer should also depend inward on the Domain layer (in our app, Use Cases depend on <strong class="source-inline">Repository</strong> classes, while it should be the other way around – more on this in a second).</li>
				<li>The Domain layer should not depend on an outer layer – in our app, the Use Cases depend on <strong class="source-inline">Repository</strong> classes, which violates the Dependency Rule.</li>
			</ul>
			<p>The approach of having the Presentation and Data layers (that contain details of implementation such as the Compose, Room, and Retrofit libraries) depend on the inner Domain layer is beneficial because it allows us to effectively separate the business policies (from within the inner circle, that is, the Domain layer) from outer layers. Outer layers can frequently change their implementation and we don't want these changes to impact the inner Domain layer.</p>
			<p>In our Restaurants app though, the Domain layer depends on the Data layer because Use Case classes depend on <strong class="source-inline">Repository</strong> classes. In other words, the Dependency Rule is violated because the inner circle (the Domain layer) depends on an outer circle.</p>
			<p>To fix this, we could define an <strong class="source-inline">interface</strong> class for the Data layer (for the <strong class="source-inline">Repository</strong> classes) and consider it part of the Domain layer (for now, by moving it inside the <strong class="source-inline">domain</strong> package).</p>
			<p>This way, the Use Cases depend on an interface defined within the Domain layer, so now, the Domain layer has no outer dependencies. On the other hand, the <strong class="source-inline">Repository</strong> class (the Data layer) implements an interface provided by the Domain layer, so the Data layer (from the outer circle) now depends on the Domain layer (from the inner circle), thereby correctly adhering to the Dependency Rule.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another way of separating concerns (or layers) and making sure to respect the Dependency Rule is to modularize the app into layers, where each layer is a Gradle module.</p>
			<p>I encourage you to study more about the Dependency Rule in Robert C. Martin's blog, while also checking out other strategies for achieving Clean Architecture: <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a>.</p>
		</div>
	</body></html>