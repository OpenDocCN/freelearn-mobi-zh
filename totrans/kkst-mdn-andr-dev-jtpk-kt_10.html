<html><head></head><body>
		<div><h1 id="_idParaDest-112"><em class="italic"><a id="_idTextAnchor285"/>Chapter 8</em>: Getting Started with Clean Architecture in Android</h1>
			<p>In this chapter, we're continuing our journey of improving the architectural design of the Restaurants application.</p>
			<p>More specifically, we will try to adopt some design decisions from the well-known Clean Architecture. <strong class="bold">Clean Architecture</strong> is a software design philosophy that tries to create projects with the best level of the following:</p>
			<ul>
				<li>Separation of concerns</li>
				<li>Testability</li>
				<li>Independence of frameworks or libraries used in peripheral layers, such as the UI or Model layer</li>
			</ul>
			<p>By doing so, Clean Architecture tries to allow the business parts of our applications to adapt to changing technologies and interfaces.</p>
			<p>Clean Architecture is a very broad and complex topic, so, in this chapter, we will try to focus only on establishing a better separation of concerns by separating existing layers even further, but more importantly, by defining a new layer called the <strong class="bold">Domain layer</strong>.</p>
			<p>In this chapter, we will on one hand borrow some architectural decisions from Clean Architecture through the <em class="italic">Defining the Domain layer with Use Cases</em> section and the <em class="italic">Separating the Domain model from Data models</em> section. On the other hand, we will try to improve project architecture with other techniques through the <em class="italic">Creating a package structure</em> section and the <em class="italic">Decoupling the Compose-based UI layer from ViewModel</em> section.</p>
			<p>Another essential principle of Clean Architecture is the <strong class="bold">Dependency Rule</strong> that we will briefly cover in the <em class="italic">Further reading</em> section where you will find proper resources to follow up with.</p>
			<p>We will cover the following topics in this section:</p>
			<ul>
				<li>Defining the Domain layer with Use Cases</li>
				<li>Separating the Domain model from Data models</li>
				<li>Creating a package structure</li>
				<li>Decoupling the Compose-based UI layer from ViewModel</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor286"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds, but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or a newer plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application developed in the previous chapter. If you haven't followed the implementation from the previous chapter, access the starting point for this chapter by navigating to the <code>Chapter_07</code> directory of the repository and importing the Android project titled <code>chapter_7_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_08</code> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app</a>.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor287"/>Defining the Domain layer with Use Cases</h1>
			<p>So far, we've talked <a id="_idIndexMarker605"/>about the Presentation layer (with UI and presentation logic) and the Model layer (with data logic). Yet, apart from these two layers, most of the time, applications also encapsulate a different type of logic, different from UI, presentation, or data logic.</p>
			<p>To identify this type of logic, we must first acknowledge that most applications have a dedicated business scope – for example, a food delivery application could have the business scope of taking orders and generating revenue for the stakeholder. The <strong class="bold">stakeholder</strong> is the<a id="_idIndexMarker606"/> entity interested in the business, such as the company that owns the restaurant chain.</p>
			<p>Such <a id="_idIndexMarker607"/>applications can contain business rules imposed by the stakeholders that can vary from minimum order amounts, custom availability ranges for certain restaurants, or predefined time frames for different delivery charges; the <a id="_idIndexMarker608"/>list could go on. We can refer to such business rules that are dictated by stakeholders as <strong class="bold">business logic</strong>.</p>
			<p>For our Restaurants app, let's imagine that the stakeholder (for example, the company we would be building the application for) asked us to always show the restaurants alphabetically, no matter what. This shouldn't be something that the user would know about; instead, it should be a predefined business rule that we must implement.</p>
			<p>Now, sorting restaurants alphabetically isn't that big of a deal, so the natural question that arises is, where should we apply this sorting logic? </p>
			<p>To figure this out, let's recap <a id="_idIndexMarker609"/>the current layering of the project. Right now, the Presentation layer is connected to the Model layer. </p>
			<div><div><img src="img/B17788_08_01.jpg" alt="Figure 8.1 – Layering of responsibilities in the Restaurants app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Layering of responsibilities in the Restaurants app</p>
			<p>With our existing layer structuring, we could sort the restaurants in the following:</p>
			<ul>
				<li><strong class="bold">UI level (composables)</strong>: Since<a id="_idIndexMarker610"/> this sorting logic is business logic, we should try to avoid adding it here.</li>
				<li><code>ViewModel</code> class; yet, remember that this rule is part of the business requirements, and the user shouldn't know about it, so it's probably not a good idea to implement it here.</li>
				<li><strong class="bold">Inside the Repository</strong>: Here<a id="_idIndexMarker612"/>, we store data logic (such as caching), which is different from business logic.</li>
			</ul>
			<p>None of<a id="_idIndexMarker613"/> the options are ideal, and we will see in a moment why this is the case. Until then, let's have a compromise and add this business rule inside the Model layer:</p>
			<ol>
				<li>Inside <code>RestaurantsRepository</code>, refactor the <code>getAllRestaurants()</code> method to sort the restaurants by <code>title</code> by calling the <code>sortedBy { }</code> extension function on the restaurants that are returned:<pre>suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
        try {
            refreshCache()
        } catch (e: Exception) {…}
        return@withContext restaurantsDao.getAll()
            <strong class="bold">.sortedBy { it.title }</strong>
    }
}</pre></li>
				<li>Build and run the application.</li>
			</ol>
			<p>The restaurants are now correctly sorted by their title, yet if you toggle a restaurant as a favorite, you might notice an initial flicker and a re-ordering effect on the list. Can you guess why this has happened?</p>
			<p>The issue here is that in <code>RestaurantsRepository</code>, the <code>toggleFavoriteRestaurant()</code> method returns the unsorted version of the restaurants from <a id="_idIndexMarker614"/>the <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>):</p>
			<pre>suspend fun toggleFavoriteRestaurant(…)= withContext(…){
    …
    <strong class="bold">restaurantsDao.getAll()</strong>
}</pre>
			<p>To fix this, we could repeat the same sorting logic from the <code>getAllRestaurants()</code> method.</p>
			<p>Yet, this<a id="_idIndexMarker615"/> approach is problematic because we would be repeating or duplicating the sorting business rule. Worse than that, since we are in the Model layer, we're mixing data logic with business logic. We shouldn't be mixing data caching logic with business rules.</p>
			<p>It's clear that for us to correctly encapsulate business logic and to be able to reuse it, we should extract it to a separate layer. Just like whenever we wanted to prevent any changes impacting the Presentation layer from affecting other layers, such as the UI or Model layers, we want to separate the business logic inside a separate layer so that any changes to the business logic shouldn't impact other layers and their corresponding logic.</p>
			<p>According to Clean Architecture concepts, the layer that encapsulates business rules and business logic is referred to as the Domain layer. This layer sits between the Presentation layer and the Model layer. It should process the data from the Model layer by applying the business rules that it incorporates, and then feed the Presentation layer with the business-compliant content.</p>
			<div><div><img src="img/B17788_08_02.jpg" alt="Figure 8.2 – Layering of responsibilities in the Restaurants app, including the Domain layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Layering of responsibilities in the Restaurants app, including the Domain layer</p>
			<p>In other words, in <a id="_idIndexMarker616"/>a particular flow (as in the screen with the list of restaurants), the Presentation layer through the <code>ViewModel</code> would connect to the Domain layer instead of the Model layer. In turn, the Domain layer would get the data from the Model layer.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Not all applications, screens, or flows contain business logic. For these cases, the Domain layer is optional. The Domain layer should hold business logic, but, if there is no such logic, there should be no such layer.</p>
			<p>But what should the Domain layer contain?</p>
			<p>According to<a id="_idIndexMarker617"/> Clean Architecture concepts, repeatable business logic that is related to a specific application<a id="_idIndexMarker618"/> action or flow should be encapsulated in a Use Case. In other words, <strong class="bold">Use Cases</strong> are classes that extract repeatable business rules related to a single functionality of your application as a single unit of business logic.</p>
			<p>For example, an online ordering app can have business logic related to displaying only stores in the near proximity of the user. To encapsulate this business rule, we could create a <code>GetStoresInProximityUseCase</code> class. Or, maybe there is some business logic associated with the logout action triggered by the user (such as executing some user benefits or points calculation behind the scenes); then, we could implement <code>LogOutUserUseCase</code>.</p>
			<p>So, in our Restaurants app, any business logic must be encapsulated in a Use Case that sits between the Presentation layer and the Model layer:</p>
			<div><div><img src="img/B17788_08_03.jpg" alt="Figure 8.3 – Layering of responsibilities where the Domain layer contains Use Cases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Layering of responsibilities where the Domain layer contains Use Cases</p>
			<p>A separated Domain layer brings the <a id="_idIndexMarker619"/>following benefits:</p>
			<ul>
				<li>Improves the testability of the app by separating business logic into its own classes. This way, business responsibilities are separated from other components and their logic can be tested separately without having to care about components from other layers.</li>
				<li>By separating business logic inside Use Cases, we avoid code duplication, and we improve the re-usability of business rules and their corresponding logic.</li>
				<li>Improves the readability of the classes that contain Use Cases dependencies. This is because each unit of business is now extracted separately and provides developers with valuable insights into the business actions each screen or flow executes.</li>
			</ul>
			<p>Before jumping into a <a id="_idIndexMarker620"/>practical example, let's briefly cover a few important aspects of Use Cases:</p>
			<ul>
				<li>They can use (or depend on) other Use Cases. Since Use Cases define a single unit of reusable business logic, then Use Cases can use other Use Cases to define complex business logic.</li>
				<li>They usually obtain their data from the Model layer but are not conditioned to only one <code>Repository</code> class – in other words, you can access multiple repositories from within your Use Case.</li>
				<li>They usually have only one public method, mostly because Use Cases encapsulate business rules related to a single functionality of your app (like <code>LogOutUserUseCase</code> does).</li>
				<li>They should follow a naming convention. A popular convention for the Use Case class is a verb in the present tense that defines the action, usually followed by a few words that express the <em class="italic">what</em>, and that ends with the UseCase suffix. Some examples could be <code>GetStoresInProximityUseCase</code> or <code>CalculateOrderTotalUseCase</code>.</li>
			</ul>
			<p>It's time to <a id="_idIndexMarker621"/>see what a Use Case class looks like. In our Restaurants app, the business logic of sorting restaurants alphabetically is a good match for it being extracted to a Use Case because of the following:</p>
			<ul>
				<li>It's a business rule dictated by the stakeholder.</li>
				<li>It's repeated twice.</li>
				<li>It's part of a specific action of the app (getting the restaurants).</li>
			</ul>
			<p>Let's define our first Use Case class!</p>
			<ol>
				<li value="1">Click on the application package, select <code>GetRestaurantsUseCase</code> as the name, select <strong class="bold">Class</strong>, and add this code:<pre>class GetRestaurantsUseCase {
    private val repository: RestaurantsRepository = 
        RestaurantsRepository()
    suspend operator fun invoke(): List&lt;Restaurant&gt; {
        return repository.getAllRestaurants()
                        .sortedBy { it.title }
    }
}</pre></li>
			</ol>
			<p>Functionally, this Use Case class gets the restaurants from <code>RestaurantsRepository</code>, applies the business rule of sorting the restaurants alphabetically, just like <code>RestarauntsViewModel</code> did, and then returns the list. In other words, <code>GetRestaurantsUseCase</code> is now the one responsible for applying business rules.</p>
			<p>This <a id="_idIndexMarker622"/>Use Case does that with only one public method, which is also a <code>suspend</code> function because the <code>repository.getAllRestaurants()</code> call is a suspending function call. But, more importantly, why did we name the function of the Use Case as <code>invoke()</code> while also specifying the <code>operator</code> keyword?</p>
			<p>We did that because Kotlin allows us to define an <code>invoke</code> operator on a class so we can call it on any instances of the class without a method name. This is how we will call the <code>invoke()</code> operator of <code>GetRestaurantsUseCase</code>:</p>
			<pre>val useCase = GetRestaurantsUseCase()
val result = <strong class="bold">useCase()</strong></pre>
			<p>This syntax is especially useful for us because our Use Case classes have only one method, and the name of the class is already suggestive enough, so we don't need a named function.</p>
			<ol>
				<li value="2">Make sure to remove the sorting logic that we initially added in the <code>getAllRestaurants()</code> method in <code>RestaurantsRepository</code>. The returned data of the method should look like this:<pre>suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
        try { … } catch (e: Exception) {…}
        <strong class="bold">return@withContext restaurantsDao.getAll()</strong>
    }
}</pre></li>
				<li>Inside <code>RestaurantsViewModel</code>, add a new dependency to the <code>GetRestaurantsUseCase</code> class:<pre>class RestaurantsViewModel() : ViewModel() {
  private val repository = RestaurantsRepository()
  <strong class="bold">private val getRestaurantsUseCase = GetRestaurantsUseCase()</strong>
  […]
}</pre></li>
				<li>Then, inside<a id="_idIndexMarker623"/> the <code>getRestaurants()</code> method of the <code>ViewModel</code>, remove the call for restaurants to the <code>repository</code> variable, and instead, call the <code>invoke()</code> operator for the <code>getRestaurantsUseCase</code> variable:<pre>private fun getRestaurants() {
    viewModelScope.launch(errorHandler) {
        val restaurants = <strong class="bold">getRestaurantsUseCase()</strong>
        _state.value = _state.value.copy(
            restaurants = restaurants, […])
    }
}</pre></li>
			</ol>
			<p>Before building and running the app, let's try to identify any other business rules for this particular flow of the app.</p>
			<p>If we have a look inside <code>RestaurantsRepository</code>, the <code>toggleFavoriteRestaurant()</code> method takes in an <code>oldValue: Boolean</code> parameter, and negates it before passing it to <code>PartialRestaurant</code>:</p>
			<pre>suspend fun toggleFavoriteRestaurant(
    id: Int,
    oldValue: Boolean
) =
    withContext(Dispatchers.IO) {
        restaurantsDao.update(
            PartialRestaurant(
                id = id,
<strong class="bold">                isFavorite = !oldValue</strong>
            )
        )
        restaurantsDao.getAll()
    }</pre>
			<p>This <a id="_idIndexMarker624"/>happens every time we mark a restaurant as a favorite or not favorite. The rule of negating <code>oldValue</code> of the favorite status of the restaurant (by passing <code>!oldValue</code>) can be considered a business rule imposed by the stakeholder: <em class="italic">whenever a user presses on the heart icon of a restaurant, we must toggle its favorite status to the opposite value</em>.</p>
			<p>To be able to reuse this business logic and not have it done by <code>RestaurantsRepository</code> , let's also extract this rule to a Use Case.</p>
			<ol>
				<li value="5">First, inside <code>RestaurantsRepository</code>, rename the <code>oldValue</code> parameter to <code>value</code> and make sure to not negate it anymore when passing it to the <code>isFavorite</code> field of <code>PartialRestaurant</code>:<pre>suspend fun toggleFavoriteRestaurant(id: Int, <strong class="bold">value</strong>: <strong class="bold">Boolean</strong>)=
    withContext(Dispatchers.IO) {
        restaurantsDao.update(
           PartialRestaurant(id = id, isFavorite = <strong class="bold">value</strong>)
        )
        restaurantsDao.getAll()
    }</pre></li>
				<li>Click on the application package, select <code>ToggleRestaurantUseCase</code> as the name, select <strong class="bold">Class</strong>, and add this code:<pre>class ToggleRestaurantUseCase {
    private val repository: RestaurantsRepository =
        RestaurantsRepository()
    suspend operator fun invoke(
        id: Int,
        oldValue: Boolean
    ): List&lt;Restaurant&gt; {
        val newFav = oldValue.not()
        return repository
            .toggleFavoriteRestaurant(id, newFav)
    }
}</pre></li>
			</ol>
			<p>This Use <a id="_idIndexMarker625"/>Case now encapsulates the business rule of negating the favorite flag of a restaurant with the <code>val newFav = oldValue.not()</code> line. While the business logic here is rather slim, in production apps, things tend to get more complex. This Use Case should be called whenever we mark a restaurant as a favorite or not favorite.</p>
			<ol>
				<li value="7">Inside <code>RestaurantsViewModel</code>, add a new dependency to the <code>ToggleRestaurantUseCase</code> class:<pre>class RestaurantsViewModel() : ViewModel() {
    private val getRestaurantsUseCase =
GetRestaurantsUseCase()
    <strong class="bold">private val toggleRestaurantsUseCase = ToggleRestaurantUseCase()</strong>
    […]
}</pre></li>
			</ol>
			<p>At this step, you can also safely remove the <code>RestaurantsViewModel</code> class's dependency to the <code>RestaurantsRepository</code> class by removing the <code>repository</code> variable.</p>
			<ol>
				<li value="8">Then, inside the <code>toggleFavorite()</code> method of the <code>ViewModel</code>, remove the call for<a id="_idIndexMarker626"/> toggling the restaurant on the <code>repository</code> variable, and instead, call the <code>invoke()</code> operator for the <code>toggleRestaurantUseCase</code> variable:<pre>fun toggleFavorite(id: Int, oldValue: Boolean) {
    viewModelScope.launch(errorHandler) {
        val updatedRestaurants = 
            <strong class="bold">toggleRestaurantsUseCase(id, oldValue)</strong>
        _state.value = _state.value.copy(…)
    }
}</pre></li>
			</ol>
			<p>Now, the business rule of toggling a restaurant as a favorite or not is done inside <code>ToggleRestaurantUseCase</code>.</p>
			<ol>
				<li value="9">Now that we have extracted business logic into Use Case classes, build the app and run it. The application should behave the same.</li>
			</ol>
			<p>Yet, if you try toggling a restaurant as a favorite, the list of restaurants still flickers, and their order seems to change. Can you think of why this happens?</p>
			<p>Let's circle back to <code>RestaurantsRepository</code> and check out the <code>toggleFavoriteRestaurant</code> method:</p>
			<pre>suspend fun toggleFavoriteRestaurant(…)= withContext(…) {
    restaurantsDao.update(
        PartialRestaurant(id = id, isFavorite = value)
    )
    restaurantsDao.getAll()
}</pre>
			<p>The problem with this method is that it returns the restaurants obtained from the Room DAO by calling <code>restaurantsDao.getAll()</code>. These restaurants are not sorted alphabetically, as our business rules now indicate. So, every time we toggle a restaurant as favorite, we update the UI with the unsorted list of restaurants.</p>
			<p>We need to somehow reuse the sorting logic from <code>GetRestaurantsUseCase</code>:</p>
			<ol>
				<li value="1">First, from within <code>RestaurantsRepository</code>, remove the <code>restaurantsDao.getAll()</code> call from the <code>toggleFavoriteRestaurant</code> method:<pre>suspend fun toggleFavoriteRestaurant(…)= withContext(…) {
    restaurantsDao.update(
        PartialRestaurant(id = id, isFavorite = value)
    )
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker627"/>way, this method no longer returns a list of restaurants; it just updates a specific restaurant. As of now, the <code>toggleFavoriteRestaurant</code> method doesn't return anything anymore.</p>
			<ol>
				<li value="2">Then, inside the <code>ToggleRestaurantUseCase</code> class, remove the return statement for the <code>repository.toggleFavoriteRestaurant()</code> line, and instead return the sorted list of restaurants by directly instantiating and calling the <code>invoke()</code> operator on the <code>GetRestaurantsUseCase</code> class:<pre>class ToggleRestaurantUseCase {
    private val repository: … = RestaurantsRepository()
    suspend operator fun invoke(…): List&lt;Restaurant&gt; {
        val newFav = oldValue.not()
        repository.toggleFavoriteRestaurant(id, newFav)
        <strong class="bold">return GetRestaurantsUseCase().invoke()</strong>
    }
}</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker628"/>approach fixes our issue – whenever we toggle a restaurant as a favorite or not, the UI no longer flickers because the UI is updated with the correctly sorted list – yet this happens with a lengthy delay.</p>
			<p>Unfortunately, this functionality is not efficient at all because whenever we toggle a restaurant as a favorite or not, the <code>GetRestaurantsUseCase</code> calls the <code>RestaurantsRepository</code> class's <code>getAllRestaurants()</code> method that, in turn, triggers a request to get the restaurants again from the Web API, attempts to cache them into <code>Room</code>, and only then provides us with a list, hence the delay we've just experienced.</p>
			<p>In a good application architecture, a network request that gets the new list of items shouldn't be done after every UI interaction with an item. Let's fix this by refactoring our code and by creating a new Use Case that only retrieves the cached restaurants, sorts them, and returns them:</p>
			<ol>
				<li value="1">First, inside <code>RestaurantsRepository</code>, add a new method called <code>getRestaurants()</code> that only retrieves the restaurants from our Room DAO:<pre>suspend fun getRestaurants() : List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
        return@withContext restaurantsDao.getAll()
    }
}</pre></li>
				<li>Click on the application package, select <code>GetSortedRestaurantsUseCase</code> as the name, select <strong class="bold">Class</strong>, and add this code:<pre>class GetSortedRestaurantsUseCase {
    private val repository: RestaurantsRepository = 
        RestaurantsRepository()
    suspend operator fun invoke(): List&lt;Restaurant&gt; {
        return repository.getRestaurants()
            .sortedBy { it.title }
    }
}</pre></li>
			</ol>
			<p>The <code>GetSortedRestaurantsUseCase</code> class now retrieves the restaurants from <a id="_idIndexMarker629"/>the <code>RestaurantsRepository</code> by calling the previously created <code>getRestaurants()</code> method (without triggering any network request or caching), applies the sorting business rule, and finally, returns the list of restaurants.</p>
			<ol>
				<li value="3">Use the newly created <code>GetSortedRestaurantsUseCase</code> class inside <code>ToggleRestaurantUseCase</code> so that we only get the cached restaurants every time we toggle a restaurant as a favorite or not:<pre>class ToggleRestaurantUseCase {
    private val repository: … = RestaurantsRepository()
    <strong class="bold">private val getSortedRestaurantsUseCase =</strong>
<strong class="bold">       </strong> <strong class="bold">GetSortedRestaurantsUseCase()</strong>
    suspend operator fun invoke(…): List&lt;Restaurant&gt; {
        val newFav = oldValue.not()
        repository.toggleFavoriteRestaurant(id, newFav)
        <strong class="bold">return getSortedRestaurantsUseCase()</strong>
    }
}</pre></li>
			</ol>
			<p>Now, we must refactor <code>GetRestaurantsUseCase</code> to reuse the sorting business logic from within <code>GetSortedRestaurantsUseCase</code> because the alphabetical sorting logic is <a id="_idIndexMarker630"/>now duplicated in both Use Cases:</p>
			<ol>
				<li value="1">First, inside <code>RestaurantsRepository</code>, update the <code>getAllRestaurants</code> method to no longer return the restaurants by no longer returning <code>restaurantsDao.getAll()</code>, while also removing the function's return type:<pre>suspend fun getAllRestaurants() {
    return withContext(Dispatchers.IO) {
        try { … } catch (e: Exception) { … }
    }
}</pre></li>
				<li>Rename the <code>getAllRestaurants</code> method to <code>loadRestaurants()</code> to better reflect its responsibility:<pre>suspend fun <strong class="bold">loadRestaurants()</strong> {
    return withContext(Dispatchers.IO) {
        try { … } catch (e: Exception) { … }
    }
}</pre></li>
				<li>Inside <code>GetRestaurantsUseCase</code>, add a new dependency to the <code>GetSortedRestaurantUseCase</code> class and refactor the class as follows:<pre>class GetRestaurantsUseCase {
    private val repository: … = RestaurantsRepository()
    <strong class="bold">private val getSortedRestaurantsUseCase =</strong> 
        <strong class="bold">GetSortedRestaurantsUseCase()</strong>
    suspend operator fun invoke(): List&lt;Restaurant&gt; {
        <strong class="bold">repository.loadRestaurants()</strong>
        <strong class="bold">return getSortedRestaurantsUseCase()</strong>
    }
}</pre></li>
			</ol>
			<p>Inside the <code>invoke()</code> function, we made sure to first call the newly renamed <code>loadRestaurants()</code> method of the <code>RestaurantsRepository</code> and then, in addition, to invoke <code>GetSortedRestaurantsUseCase</code>, which is now also returned.</p>
			<ol>
				<li value="4">To better<a id="_idIndexMarker631"/> reflect its purpose, rename the <code>GetRestaurantsUseCase</code> class to <code>GetInitialRestaurantsUseCase</code>:<pre>class <strong class="bold">GetInitialRestaurantsUseCase</strong> {
    private val repository: … = RestaurantsRepository()
    private val getSortedRestaurantsUseCase = 
        GetSortedRestaurantsUseCase()
    suspend operator fun invoke(): List&lt;Restaurant&gt; {...}
}</pre></li>
				<li>As a consequence, inside <code>RestaurantsViewModel</code>, update the type for the <code>getRestaurantsUseCase</code> variable:<pre>class RestaurantsViewModel() : ViewModel() {
  private val repository = RestaurantsRepository()
  private val getRestaurantsUseCase = 
      <strong class="bold">GetInitialRestaurantsUseCase()</strong>
  …
}</pre></li>
				<li>Build the app and run it. The application should now behave correctly when marking a restaurant as a favorite or not; the restaurants remain sorted alphabetically.</li>
			</ol>
			<p>Let's now move on to another way of improving the architecture of our app.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor288"/>Separating the Domain model from Data models</h1>
			<p>Inside the <a id="_idIndexMarker632"/>Domain layer, apart from Use Cases, another essential business component in our app is the <strong class="bold">Domain model component</strong>. The Domain model components <a id="_idIndexMarker633"/>are those classes that represent core business data or concepts used throughout the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since the Domain models reside inside the Domain layer, they should be agnostic of any third-party library or dependency – ideally, they should be pure Java or Kotlin classes.</p>
			<p>For example, in our Restaurants app, the core entity used throughout the app (retrieved, updated, and displayed) is the <code>Restaurant</code> data class, which contains data such as <code>title</code> and <code>description</code>.</p>
			<p>If we think about it, our Restaurants app's core business entity is represented by the restaurant itself: that's what the application is about, so it's only natural that we would consider the <code>Restaurant</code> class as a business entity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In Clean Architecture, Domain model classes are often referred to as Entity classes. However, it's important to mention that the Room database <code>@Entity</code> annotation has nothing to do with Clean Architecture; any class annotated with the Room <code>@Entity</code> annotation doesn't automatically become an entity. In fact, as per Clean Architecture, Entity classes should have no library dependencies such as database annotations.</p>
			<p>If we have a <a id="_idIndexMarker634"/>look at our <code>Restaurant</code> data class though, we can identify a serious issue:</p>
			<pre>import androidx.room.ColumnInfo
      …
import com.google.gson.annotations.SerializedName
@Entity(tableName = "restaurants")
data class Restaurant(
    @PrimaryKey()
    @ColumnInfo(name = "r_id")
    @SerializedName("r_id")
    val id: Int,
    @ColumnInfo(name = "r_title")
    @SerializedName("r_title")
    val title: String,
      …
)</pre>
			<p>Can you spot the problem?</p>
			<p>While, in the beginning, the <code>Restaurant</code> data class was a pure Kotlin data class with some fields, in time, it grew to something more than that.</p>
			<p>We first added Retrofit to our app so we could get the restaurants from a Web API, and had to mark the fields we obtained with <code>@SerializedName</code> annotations so that the GSON (Google Gson) deserialization would work. Then we added Room to the mix because we wanted to cache the restaurants, so we had to add an <code>@Entity</code> annotation to the class, and other annotations, such as <code>@PrimaryKey</code> and <code>@ColumnInfo</code>, to its fields.</p>
			<p>While it was convenient for us to use only one Data model class throughout the app, we have now coupled a Domain model class (<code>Restaurant.kt</code>) to library dependencies, such as GSON or Room. This means that our Domain model is coupled to the Data or Model layer that is responsible for obtaining data.</p>
			<p>According <a id="_idIndexMarker635"/>to Clean Architecture, the Domain model classes should reside inside the Domain layer and be agnostic of any libraries tightly related to the way we retrieve or cache data from several sources.</p>
			<p>In other words, we need to make a separation between Domain models and <strong class="bold">Data Transfer Objects </strong>(<strong class="bold">DTOs</strong>) by <a id="_idIndexMarker636"/>creating separate classes for both types. While Domain models are plain Kotlin classes, DTOs are classes that contain both the fields needed for a specific data operation, such as caching items to a local source, but also dependencies such as library annotations.</p>
			<p>With such a separation, the Domain model is now a business entity that doesn't care about implementation details (such as libraries), so every time we might have to replace a library (such as Retrofit or Room) with another library, we must only update the DTOs (hence, the Model layer) and not classes within the Domain model.</p>
			<div><div><img src="img/B17788_08_04.jpg" alt="Figure 8.4 – Separating Domain models from DTO models&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Separating Domain models from DTO models</p>
			<p>To achieve such a separation in our Restaurants app, we must split our <code>Restaurant</code> class into three classes. We must do the following:</p>
			<ul>
				<li>Create two DTOs as <code>data class</code> classes that will be used for transferring data:<ul><li>A <code>RemoteRestaurant</code> class that will contain the fields received from the Web API. These fields will also be annotated with GSON serialization annotations required by Retrofit to parse the response.</li><li>A <code>LocalRestaurant</code> class that will contain the fields and their corresponding annotations required by Room to cache restaurants.</li></ul></li>
				<li>Refactor <a id="_idIndexMarker637"/>the <code>Restaurant</code> data class to be a plain Kotlin data class, without any third-party dependencies. This way, the <code>Restaurant</code> data class will be a proper Domain model class, independent of the Model layer that is tightly coupled to third-party libraries.</li>
			</ul>
			<p>Let's begin!</p>
			<ol>
				<li value="1">Click on the application package, select <code>RemoteRestaurant</code> as the name, select <strong class="bold">Class</strong>, and add this code to define the DTO for our remote source (Firebase remote database):<pre>data class RemoteRestaurant(
    @SerializedName("r_id")
    val id: Int,
    @SerializedName("r_title")
    val title: String,
    @SerializedName("r_description")
    val description: String)</pre></li>
			</ol>
			<p>Inside this class, we have added all the fields received from the Web API, along with their corresponding serialization fields. You can get these annotations and their imports from the <code>Restaurant</code> class.</p>
			<p>Another advantage of having a separate DTO class is that it now contains only the necessary fields – for instance, unlike <code>Restaurant</code>, <code>RemoteRestaurant</code> no longer contains an <code>isFavorite</code> field because we don't receive it from the REST API of our Firebase Database.</p>
			<ol>
				<li value="2">Click on the<a id="_idIndexMarker638"/> application package and create a new file called <code>LocalRestaurant</code>. Add this code to define the DTO for our local source (Room local database):<pre>@Entity(tableName = "restaurants")
data class LocalRestaurant(
    @PrimaryKey()
    @ColumnInfo(name = "r_id")
    val id: Int,
    @ColumnInfo(name = "r_title")
    val title: String,
    @ColumnInfo(name = "r_description")
    val description: String,
    @ColumnInfo(name = "is_favorite")
    val isFavorite: Boolean = false)</pre></li>
			</ol>
			<p>You can get the fields, annotations, and their imports from the <code>Restaurant</code> class.</p>
			<ol>
				<li value="3">Now, navigate to the <code>Restaurant</code> class. It's time to remove all its third-party dependencies to Room and GSON and keep it as a simple Domain model class containing the fields that define our restaurant entity. It should now look like this:<pre>data class Restaurant(
    val id: Int,
    val title: String,
    val description: String,
    val isFavorite: Boolean = false)</pre></li>
			</ol>
			<p>Make sure to also remove any imports for the GSON and Room annotations.</p>
			<ol>
				<li value="4">Inside the <code>RestaurantsDb</code> class, update the entity used in Room to our newly created <code>LocalRestaurant</code>, while also updating the schema version to <code>3</code>, just to be sure that Room will provide a fresh start:<pre>@Database(
    entities = <strong class="bold">[LocalRestaurant::class],</strong>
    version = <strong class="bold">3</strong>,
    exportSchema = false)
abstract class RestaurantsDb : RoomDatabase() {
    abstract val dao: RestaurantsDao
    …
}</pre></li>
				<li>Rename <a id="_idIndexMarker639"/>the <code>PartialRestaurant</code> class to <code>PartialLocalRestaurant</code> to better clarify that this class is used by our local data source, Room:<pre>@Entity
class <strong class="bold">PartialLocalRestaurant</strong>(
@ColumnInfo(name = "r_id")
val id: Int,
@ColumnInfo(name = "is_favorite")
val isFavorite: Boolean)</pre></li>
				<li>Inside the <code>RestaurantsDao</code> interface, replace the <code>Restaurant</code> class usages with <code>LocalRestaurant</code>, and the <code>PartialRestaurant</code> class usages <a id="_idIndexMarker640"/>with <code>PartialLocalRestaurant</code>:<pre>@Dao
interface RestaurantsDao {
    @Query("SELECT * FROM restaurants")
    suspend fun getAll(): List&lt;<strong class="bold">LocalRestaurant</strong>&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addAll(restaurants: 
        List&lt;<strong class="bold">LocalRestaurant</strong>&gt;)
    @Update(entity = <strong class="bold">LocalRestaurant</strong>::class)
    suspend fun update(partialRestaurant: 
       <strong class="bold">PartialLocalRestaurant</strong>)
    @Update(entity = <strong class="bold">LocalRestaurant</strong>::class)
    suspend fun updateAll(partialRestaurants: 
        List&lt;<strong class="bold">PartialLocalRestaurant</strong>&gt;)
    @Query("SELECT * FROM restaurants WHERE 
        is_favorite = 1")
    suspend fun getAllFavorited(): List&lt;<strong class="bold">LocalRestaurant</strong>&gt;
}</pre></li>
				<li>Inside <code>RestaurantsRepository</code>, navigate to the <code>toggleFavoriteRestaurant()</code> method, and replace the <code>PartialRestaurant</code> usage with <code>PartialLocalRestaurant</code>:<pre>suspend fun toggleFavoriteRestaurant(
      …
) = withContext(Dispatchers.IO) {
    restaurantsDao.update(
      <strong class="bold">PartialLocalRestaurant</strong>(id = id, isFavorite = value)
    )
}</pre></li>
				<li>Still<a id="_idIndexMarker641"/> inside <code>RestaurantsRepository</code>, navigate to the <code>getRestaurants()</code> method, and map the <code>LocalRestaurant</code> objects (received by the <code>restaurantsDao.getAll()</code> method call) to <code>Restaurant</code> objects:<pre>suspend fun getRestaurants() : List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
        return@withContext restaurantsDao.getAll()<strong class="bold">.map {</strong>
            <strong class="bold">Restaurant(it.id, it.title, </strong>
<strong class="bold">                it.description,</strong> <strong class="bold">it.isFavorite)</strong>
        <strong class="bold">}</strong>
    }
}</pre></li>
			</ol>
			<p>We have mapped <code>List&lt;LocalRestaurant&gt;</code> to <code>List&lt;Restaurant&gt;</code> by using the <code>.map { }</code> extension function. We did that by constructing and returning a <code>Restaurant</code> object from <code>LocalRestaurant</code>, represented by the <code>it</code> implicit variable name.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Your Model layer (represented by the <code>Repository</code> here), should only return Domain model objects to the Domain entity. In our case, <code>RestaurantsRepository</code> should return <code>Restaurant</code> objects, and not <code>LocalRestaurants</code> objects, simply because the Use Case classes (so, the Domain layer) that use this <code>Repository</code> shouldn't have any knowledge of DTO classes from the Model layer.</p>
			<ol>
				<li value="9">Navigate<a id="_idIndexMarker642"/> to the <code>RestaurantsApiService</code> interface (the Retrofit interface) and replace the usages of the <code>Restaurant</code> class with <code>RemoteRestaurant</code>:<pre>interface RestaurantsApiService {
   @GET("restaurants.json")
    suspend fun getRestaurants(): List&lt;<strong class="bold">RemoteRestaurant</strong>&gt;
   @GET("restaurants.json?orderBy=\"r_id\"")
    suspend fun getRestaurant(…):  
        Map&lt;String, <strong class="bold">RemoteRestaurant</strong>&gt;
}</pre></li>
				<li>Going back to <code>RestaurantsRepository</code>, navigate to the <code>refreshCache()</code> method and map the <code>remoteRestaurants</code> list from Retrofit to <code>LocalRestaurant</code> objects so that <code>restaurantsDao</code> can cache them:<pre>private suspend fun refreshCache() {
    val remoteRestaurants = restInterface
        .getRestaurants()
    val favoriteRestaurants = restaurantsDao
        .getAllFavorited()
    restaurantsDao.addAll(remoteRestaurants.<strong class="bold">map {</strong>
<strong class="bold">        LocalRestaurant(</strong>
<strong class="bold">            it.id,</strong>
<strong class="bold">            it.title,</strong>
<strong class="bold">            it.description,</strong>
<strong class="bold">            false</strong>
<strong class="bold">        )</strong>
<strong class="bold">    }</strong>)
    restaurantsDao.updateAll(
        favoriteRestaurants.map {
            <strong class="bold">PartialLocalRestaurant</strong>(
                id = it.id,
                isFavorite = true
            )
        })
}</pre></li>
			</ol>
			<p>Additionally, make sure to update the usage of <code>PartialRestaurant</code> to <code>PartialLocalRestaurant</code> in the <code>restaurantsDao.updateAll()</code> method call.</p>
			<ol>
				<li value="11">Navigate<a id="_idIndexMarker643"/> to <code>RestaurantsDetailsViewModel</code> and, inside the <code>getRemoteRestaurant()</code> method, map the <code>RemoteRestaurant</code> object received from the Retrofit API to a <code>Restaurant</code> object by using the <code>?.let{ }</code> extension function:<pre>private suspend fun getRemoteRestaurant(id: Int): Restaurant {
    return withContext(Dispatchers.IO) {
        val response =  restInterface.getRestaurant(id)
        return@withContext response.values.first().<strong class="bold">let {</strong>
            <strong class="bold">Restaurant(</strong>
                <strong class="bold">id = it.id, </strong>
                <strong class="bold">title = it.title,</strong> 
                <strong class="bold">description = it.description</strong>
            <strong class="bold">)</strong>
        <strong class="bold">}</strong>
    }
}</pre></li>
			</ol>
			<p>Remember<a id="_idIndexMarker644"/> that in the restaurant details screen, we don't have any business logic or Use Cases, or even a <code>Repository</code>, so we have directly added a variable for the Retrofit interface inside the <code>ViewModel</code> – and that's why we are mapping the Domain model inside the <code>ViewModel</code>.</p>
			<ol>
				<li value="12">Build and run the app. The app should behave the same.</li>
			</ol>
			<p>Let's now take a break from creating classes and let's organize our project a bit.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor289"/>Creating a package structure</h1>
			<p>Our <a id="_idIndexMarker645"/>Restaurants app has come a long way. As we tried to separate responsibilities and concerns as much as possible, new classes emerged – quite a few actually.</p>
			<p>If we have a look on the left of Android Studio, on the <strong class="bold">Project</strong> tab, we have an overview of the classes we've defined in our project.</p>
			<div><div><img src="img/B17788_08_05.jpg" alt="Figure 8.5 – Project structure without any package structuring strategy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Project structure without any package structuring strategy</p>
			<p>It's clear <a id="_idIndexMarker646"/>that our project has no folder structure at all – all files and classes are tossed around inside the <code>restaurantsapp</code> root package.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The name of the root package might differ if you selected a different name for your app.</p>
			<p>Because we've opted to throw any new class inside the root package, it's difficult to have clear visibility over the project. Our approach is similar to adding dozens of files and assets on the desktop of our PC – in time, it becomes impossible to find anything on the screen.</p>
			<p>To alleviate this issue, we can opt <a id="_idIndexMarker647"/>for a <strong class="bold">packaging strategy</strong> for our project in which each class belongs to a folder. A clear folder structure allows developers to have good visibility and to gain valuable insight into the application's components, there by allowing easier access and navigation through the project files.</p>
			<p>The most common<a id="_idIndexMarker648"/> package organizing <a id="_idIndexMarker649"/>strategies are as follows:</p>
			<ul>
				<li><code>presentation</code> package would contain all the files related to the Presentation layer, regardless of the feature they belong to, such as all the files with composables, and all the <code>ViewModel</code> classes.</li><li>Similarly, a <code>data</code> package would contain all files related to the Model layer, regardless of the feature they belong to, such as repositories, Retrofit interfaces, or Room DAO interfaces.</li></ul></li>
				<li><code>restaurants</code> package would contain all the classes related to the <code>restaurants</code> feature, from UI classes to <code>ViewModel</code> classes, Use Cases, and repositories.</li>
			</ul>
			<p>Both approaches have their pros and cons, but most notably, the package organization by layer doesn't scale well if the app has a lot of features, as there is no way to differentiate between classes from different features.</p>
			<p>On the other hand, the package organization by feature can be problematic if, in each feature package, all classes are thrown around without any distinct categorization.</p>
			<p>For our Restaurants app, we will use a mix of these two strategies. More specifically, we will do the following:</p>
			<ul>
				<li>Keep <code>RestaurantsApplication.kt</code> inside the root package.</li>
				<li>Create a root package for the only feature our application has, named <code>restaurants</code>. This package will contain the functionality for displaying both the list of restaurants and the detail screen.</li>
				<li>Create sub-packages inside the <code>restaurants</code> package for each layer:<ul><li><code>Presentation</code>: For composables and <code>ViewModel</code> classes. Inside this package, we can <a id="_idIndexMarker650"/>also break the screens that we have into separate packages: <code>list</code> for the first screen with the list of restaurants, and <code>details</code> for the second screen with the details of one restaurant. Additionally, we will keep the <code>MainActivity</code> class inside the <code>presentation</code> package since it's the host component for the UI.</li><li><code>Data</code>: For classes within the Model layer. Here, we will not only add <code>RestaurantsRepository,</code> but we'll also create two sub-packages for the two different data sources: <code>local</code> (for caching classes such as <code>RestaurantsDao</code> and <code>LocalRestaurant</code>), and <code>remote</code> (for classes related to the remote source such as <code>RestaurantsApiService</code> and <code>RemoteRestaurant</code>).</li><li><code>Domain</code>: For business-related classes, the Use Case classes, and also the <code>Restaurant.kt</code> Domain model class.</li></ul></li>
			</ul>
			<p>With this approach, if we were to add a new feature, maybe related to ordering (which we could call <code>ordering</code>), the package structure would provide us with immediate information about the features our application contains. When expanding a certain feature package, we can expand the package of the layer we're interested in working with and have a clear overview of the components we need to update or modify.</p>
			<p>To achieve such a packaging structure, you will have to perform the following actions a few times:</p>
			<ol>
				<li value="1">Create a new package. To do that, left-click on a certain existing package (such as the <code>restaurantsapp</code> package), select <strong class="bold">New</strong>, then <strong class="bold">Package</strong>, and finally, enter the name of the package.</li>
				<li>Move an existing class into an existing package. To do that, simply drag the file and drop it into the desired package.</li>
			</ol>
			<p>In the end, the <a id="_idIndexMarker651"/>package structure that we described and that we want to achieve is the following:</p>
			<div><div><img src="img/B17788_08_06.jpg" alt="Figure 8.6 – Project structure after applying our package structuring strategy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Project structure after applying our package structuring strategy</p>
			<p>Keep in mind, however, that when moving the <code>MainActivity.kt</code> file from its initial location to the <code>presentation</code> package, you might have to update the <code>Manifest.xml</code> file to reference the new correct path to the <code>MainActivity.kt</code> file:</p>
			<pre>&lt;manifest […]&gt;
    […]
    &lt;application
        […]
        &lt;activity
            android:name="<strong class="bold">.restaurants.presentation.</strong>
<strong class="bold">                MainActivity</strong>"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.RestaurantsApp.
                NoActionBar"&gt;
            &lt;intent-filter&gt;
                […]
            &lt;/intent-filter&gt;
            &lt;intent-filter&gt;
                […]
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre>
			<p>Some versions <a id="_idIndexMarker652"/>of Android Studio do that out of the box for you; however, if they don't, you might end up with a nasty compilation error because the <code>Manifest.xml</code> file is no longer detecting our <code>Activity</code>.</p>
			<p>Now that we have refactored the structure of our project, we can say that the packages structure provides us with immediate information about the features of the app (in our case, there is only one feature related to restaurants) and also with a clear overview of the components corresponding to a specific feature.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The autogenerated files for Compose projects (<code>Color.kt</code>, <code>Shape.kt</code>, <code>Theme.kt</code>, and <code>Type.kt</code>) were left inside the <code>theme</code> package that resides inside the <code>ui</code> package. This is because theming should be consistent across features.</p>
			<p>Let's now move on <a id="_idIndexMarker653"/>to another way of improving the decoupling inside the UI layer between the composables and the <code>ViewModel</code>.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor290"/>Decoupling the Compose-based UI layer from ViewModel</h1>
			<p>Our <a id="_idIndexMarker654"/>UI layer (represented by the composable functions) is tightly coupled to the <code>ViewModel</code>. This is natural, since the screen composables<a id="_idIndexMarker655"/> instantiate their own <code>ViewModel</code> to do the following:</p>
			<ul>
				<li>Obtain the UI state and consume it</li>
				<li>Pass events (such as clicking on a UI item) up to the <code>ViewModel</code></li>
			</ul>
			<p>As an example, we can see how the <code>RestaurantsScreen()</code> composable uses an instance of <code>RestaurantsViewModel</code>:</p>
			<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    val state = viewModel.state.value
    Box(…) { … }
}</pre>
			<p>The problem with our approach is that if we want to later test the UI layer, then, inside the test, the <code>RestaurantsScreen</code> composable will instantiate <code>RestaurantsViewModel</code>, which in turn will get data from Use Case classes, which in turn will trigger heavy I/O work in <code>RestaurantsRepository</code> (like the network request to obtain the restaurants, or the operation of saving them inside the local database).</p>
			<p>When we have to test the UI, we should not care whether the <code>ViewModel</code> obtains the data correctly and translates it into a proper UI state. The effect of separating concerns is to facilitate testing a target class (or composable in this discussion) without having to care about other layers doing their work.</p>
			<p>Right now, our <a id="_idIndexMarker656"/>screen composables are tied to a library dependency, the <code>ViewModel</code>, and it's ideal to decouple such dependencies as much as possible to promote reusability and testability.</p>
			<p>In order to <a id="_idIndexMarker657"/>decouple the <code>RestaurantsScreen()</code> composable as much as possible from its <code>ViewModel</code>, we will refactor it so that the following happens:</p>
			<ul>
				<li>It will no longer reference a <code>ViewModel</code> class (the <code>RestaurantsViewModel</code> class).</li>
				<li>Instead, it will receive a <code>RestaurantsScreenState</code> object as a parameter.</li>
				<li>It will also define new function parameters to expose callbacks to its caller – we will see who the caller is in a minute.<p class="callout-heading">Note</p><p class="callout">By extracting the <code>ViewModel</code> instantiation from screen composables, such as <code>RestaurantsScreen()</code>, we're promoting reusability in the sense that we can much easier replace the ViewModel type that creates the state for this composable. This approach also enables us to port the Compose-based UI layer much easier<a id="_idIndexMarker658"/> to <strong class="bold">Kotlin Multiplatform</strong> (<strong class="bold">KMP</strong>) projects.</p></li>
			</ul>
			<p>Let's begin!</p>
			<ol>
				<li value="1">Inside the <code>RestaurantsScreen</code> file, update the <code>RestaurantsScreen() </code>composable by removing its <code>viewModel</code> and <code>state</code> variables, while also making sure it receives a <code>RestaurantsScreenState</code> object as a <code>state</code> parameter and an <code>onFavoriteClick</code> function:<pre>@Composable
fun RestaurantsScreen(
<strong class="bold">    state: RestaurantsScreenState,</strong>
    onItemClick: (id: Int) -&gt; Unit,
<strong class="bold">    onFavoriteClick: (id: Int, oldValue: Boolean) -&gt; Unit</strong>
) {
    Box(…) {
        LazyColumn(…) {
            items(<strong class="bold">state.restaurants</strong>) { restaurant -&gt;
                RestaurantItem(
                    restaurant,
                    onFavoriteClick = { id, oldValue -&gt;
<strong class="bold">                        onFavoriteClick(id, oldValue)</strong>
                    },
                    onItemClick = { id -&gt;
                        onItemClick(id)
                    }
                )
            }
        }
        […]
    }
}</pre></li>
			</ol>
			<p>Additionally, make<a id="_idIndexMarker659"/> sure to remove the <code>viewModel.toggleFavorite()</code> call and instead, call the newly added <code>onFavoriteClick()</code> function inside the <code>RestaurantItem</code> corresponding callback.</p>
			<ol>
				<li value="2">Since we changed <a id="_idIndexMarker660"/>the signature of the <code>RestaurantsScreen()</code> function, we must also update the <code>DefaultPreview()</code> composable to correctly call the <code>RestaurantsScreen()</code> composable:<pre>@Preview(showBackground = true)
@Composable
fun DefaultPreview() {
    RestaurantsAppTheme {
        RestaurantsScreen(
            <strong class="bold">RestaurantsScreenState(listOf(), true),</strong>
<strong class="bold">            {},</strong>
<strong class="bold">            { _, _ -&gt; }</strong>
        )
    }
}</pre></li>
				<li>In the <code>MainActivity</code> class and inside the <code>RestaurantsApp()</code> composable, make<a id="_idIndexMarker661"/> the destination composable for <code>RestaurantsScreen()</code> responsible for wiring up the screen<a id="_idIndexMarker662"/> composable with its <code>ViewModel</code>, thereby ensuring good communication between <code>RestaurantsScreen()</code> and <code>RestaurantsViewModel</code>:<pre>@Composable
private fun RestaurantsApp() {
    val navController = rememberNavController()
    NavHost(navController, startDestination = 
        "restaurants") {
        composable(route = "restaurants") {
            <strong class="bold">val viewModel: RestaurantsViewModel = </strong>
<strong class="bold">                viewModel()</strong>
            RestaurantsScreen<strong class="bold">(</strong>
                <strong class="bold">state = viewModel.state.value,</strong>
                <strong class="bold">onItemClick = { id -&gt;</strong>
                    <strong class="bold">navController</strong>
                        <strong class="bold">.navigate("restaurants/$id")</strong>
                <strong class="bold">},</strong>
                <strong class="bold">onFavoriteClick = { id, oldValue -&gt;</strong>
                   <strong class="bold">viewModel.toggleFavorite(id, oldValue)</strong>
                <strong class="bold">})</strong>
        }
        composable(
            route = "restaurants/{restaurant_id}",
            […]) { RestaurantDetailsScreen() }
        }</pre></li>
			</ol>
			<p>With this<a id="_idIndexMarker663"/> approach, the destination <code>composable()</code> with the initial route of <code>"restaurants"</code> is the<a id="_idIndexMarker664"/> composable that manages and wires up the <code>RestaurantsScreen()</code> composable to its content by doing the following:</p>
			<ul>
				<li>Instantiating <code>RestaurantsViewModel</code></li>
				<li>Getting and passing the state to <code>RestaurantsScreen()</code></li>
				<li>Handling the <code>onItemClick()</code> and <code>onFavoriteClick()</code> callbacks</li>
			</ul>
			<ol>
				<li value="4">Build and run the application. The app should behave the same.</li>
				<li>You will notice that if you rebuild the project and navigate back to the <code>RestaurantsScreen()</code> composable, the preview will now function correctly because the <code>RestaurantsScreen()</code> composable is no longer tied to a <code>ViewModel</code>, and so Compose can very easily preview its content.<p class="callout-heading">Assignment</p><p class="callout">In this chapter, we have better decoupled the first screen of the app (the <code>RestaurantScreen()</code> composable) from its <code>ViewModel</code> to promote reusability and testability. As homework, you can practice doing the same for the <code>RestaurantDetailScreen()</code> composable.</p></li>
			</ol>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor291"/>Summary</h1>
			<p>In this chapter, we have dipped our toes into Clean Architecture in Android. We started by understanding a bit about what Clean Architecture means and some of the best ways we can achieve this in our Restaurants app, while also covering the main benefits of following such a software design philosophy.</p>
			<p>We started with Clean Architecture in the first section, where we defined the Domain layer with Use Cases, and continued refactoring in the second section, where we separated the Domain model from Data models.</p>
			<p>Then, we improved the architecture of the app by creating a package structure and by decoupling the Compose-based UI layer from the <code>ViewModel</code> classes even further.</p>
			<p>In the next chapter, we will continue our journey of improving the architecture of our application by adopting dependency injection.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor292"/>Further reading</h1>
			<p>Clean Architecture is a very complex subject, and one chapter is simply not enough to cover it. However, one of the most important concepts that Clean Architecture brings is the Dependency Rule. The Dependency Rule states that within a project, dependencies can only point inward.</p>
			<p>To understand what the Dependency Rule is about, let's visualize the layer dependencies of our Restaurants app through a simplified version of concentric circles. Each concentric circle represents different areas of software with their corresponding layer dependencies (and libraries).</p>
			<div><div><img src="img/B17788_08_07.jpg" alt="Figure 8.7 – The Dependency Rule with layers and components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – The Dependency Rule with layers and components</p>
			<p>This representation dictates that implementation details should be placed in <em class="italic">outer</em> circles (just as Compose is an implementation detail of the UI layer or Retrofit is an implementation detail for the Data layer), while business policies (Use Cases from the Domain layer) are placed within the <em class="italic">inner</em> circle.</p>
			<p>The purpose of this representation is to enforce the Dependency Rule that states how dependencies should only be pointing inward.</p>
			<p>The Dependency Rule (expressed with the inward-pointing arrows) showcases the following:</p>
			<ul>
				<li>The Presentation layer depends inward on the Domain layer (just like the <code>ViewModel</code>  classes in our app correctly depend on Use Case classes) and how the Data layer should also depend inward on the Domain layer (in our app, Use Cases depend on <code>Repository</code> classes, while it should be the other way around – more on this in a second).</li>
				<li>The Domain layer should not depend on an outer layer – in our app, the Use Cases depend on <code>Repository</code> classes, which violates the Dependency Rule.</li>
			</ul>
			<p>The approach of having the Presentation and Data layers (that contain details of implementation such as the Compose, Room, and Retrofit libraries) depend on the inner Domain layer is beneficial because it allows us to effectively separate the business policies (from within the inner circle, that is, the Domain layer) from outer layers. Outer layers can frequently change their implementation and we don't want these changes to impact the inner Domain layer.</p>
			<p>In our Restaurants app though, the Domain layer depends on the Data layer because Use Case classes depend on <code>Repository</code> classes. In other words, the Dependency Rule is violated because the inner circle (the Domain layer) depends on an outer circle.</p>
			<p>To fix this, we could define an <code>interface</code> class for the Data layer (for the <code>Repository</code> classes) and consider it part of the Domain layer (for now, by moving it inside the <code>domain</code> package).</p>
			<p>This way, the Use Cases depend on an interface defined within the Domain layer, so now, the Domain layer has no outer dependencies. On the other hand, the <code>Repository</code> class (the Data layer) implements an interface provided by the Domain layer, so the Data layer (from the outer circle) now depends on the Domain layer (from the inner circle), thereby correctly adhering to the Dependency Rule.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another way of separating concerns (or layers) and making sure to respect the Dependency Rule is to modularize the app into layers, where each layer is a Gradle module.</p>
			<p>I encourage you to study more about the Dependency Rule in Robert C. Martin's blog, while also checking out other strategies for achieving Clean Architecture: <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a>.</p>
		</div>
	</body></html>