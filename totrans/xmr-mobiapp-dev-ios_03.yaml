- en: Chapter 3. Views and Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of the iPhone and the iPad, a view can be thought of as what you see,
    but the types of views you see depend (to an extent) on the application type you
    select when you create your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Projects and their types of layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that your design fits all iOS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection of the project type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you first decide to create an iOS application, you will be presented with
    the view shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selection of the project type](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application types and their view types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project types require a bit of an explanation, which has been provided
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project type | View type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Master-Detail | A table based layout. |'
  prefs: []
  type: TYPE_TB
- en: '| Single View | The simplest form of view. The name does not mean that you
    have an app with just one page, but that views don''t propagate through (so view
    1 may have tabs that go to view 2\. View 2 could be a `MT.D`). |'
  prefs: []
  type: TYPE_TB
- en: '| Tabbed | A standard view with a number of persistent tabs at the bottom of
    the screen. The view changes, but the tabs stay. |'
  prefs: []
  type: TYPE_TB
- en: '| OpenGL | Fast, responsive, used for high resolution gaming. I won''t be covering
    this here, as it is outside the scope of this book. |'
  prefs: []
  type: TYPE_TB
- en: A more complete explanation of the project types can be found at [http://oleb.net/blog/2013/05/xcode-project-templates-difference/](http://oleb.net/blog/2013/05/xcode-project-templates-difference/).
  prefs: []
  type: TYPE_NORMAL
- en: The iOS layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with the layout of the iPhone (and the iPad) user interface, a
    number of factors have to be taken into consideration; the most important is probably
    the physical size of the screen. While it is easy to create a user interface using
    Xcode, unlike Android devices, iOS does not really auto-resize. The UI is partially
    due to the way layouts are created in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I was growing up, I was given a "fuzzy felt" kit at school. For those who
    don't know what it is, a fuzzy felt kit consists of a large background piece of
    felt onto which you stick other pieces of felt; this enables you to create lots
    of pictures. Designing for iOS is the same. You can drag-and-drop any piece of
    the user interface into the main view and leave it there. This is what gives iOS
    a part of the richness it enjoys; it is up to the designer to create, rather than
    have strict rules on what goes where. For the application, the UI elements all
    have an **absolute** position on the screen, rather than being relative to any
    other objects. Here, though, is the problem.
  prefs: []
  type: TYPE_NORMAL
- en: If you increase the screen size, those positions stay the same. So, what may
    look good on an iPhone 4 has bits missing on the 3G and has gaps on the iPhone
    5—don't start thinking about the iPad—as the view would be just in the middle
    of the screen, usually squashed up.
  prefs: []
  type: TYPE_NORMAL
- en: How to avoid some of these problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest method is, when using Xcode to design your UI, you check the **Use
    AutoLayout** checkbox on the UI View. This does the moving around for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to avoid some of these problems](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The problem here though is that you need to set this **Use AutoLayout** on every
    view, and it is also not supported on the iPhone 3GS. However, the 3GS is now
    so old that it is probably not worth going through the hoops required to auto-scale
    on it. The 3GS supports iOS 6, but only by hacking. iOS 5 is nearing the end of
    its life (at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: Views and View Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: They sound similar, but they're not. The simplest way to think of a View Controller
    and a View is like a web page. A typical web page is a piece of information served
    up from a server. The content may be created dynamically (say from a database
    query), but for the user it's just data. This would be considered as a View. It
    has things on it, but no real user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: A View Controller is closer to a web page constructed using `ASP.net`, or some
    other form of language that feeds back to a server (such as PHP). The website
    has a button on it. The button has an event, which is then fed back to the code
    (known as the handler code) behind the button. The View created using Xcode is
    the web page, and the source file with a connection is the server.
  prefs: []
  type: TYPE_NORMAL
- en: As outlined in the previous chapter, the objects on `UIViewController` are connected
    to the code behind the control by clicking on the control (as well as pressing
    the *Ctrl* key) and dragging the widget to the connector entry window.
  prefs: []
  type: TYPE_NORMAL
- en: Other Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Outside of the View choice, there are a number of other views that are available,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| View name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Activity Indicator** **View** | It is a modal indicator that shows that
    something (an activity) is occurring. This can be the loading of a web page or
    the rendering of a map. |'
  prefs: []
  type: TYPE_TB
- en: '| **Progress** **View** | It shows the progress of time for an activity—gives
    the user a better idea of how long something is going to take. |'
  prefs: []
  type: TYPE_TB
- en: '| **Collection** **View** | It displays a collection of cells (`CollectionViewCells`).
    Each cell can be defined. |'
  prefs: []
  type: TYPE_TB
- en: '| **Collection Reusable View** | A reusable collection works as follows: say
    you have a group of cells which, for argument''s sake, occupies the screen. In
    a standard collection, when the cells go off screen, they are still held in the
    collection. While this makes rendering faster when they return, they take up memory
    space. The reusable collection stores a pointer to the cell and then refreshes
    when back on the screen—the collection is then reused. |'
  prefs: []
  type: TYPE_TB
- en: '| **Table View** | It will be covered in [Chapter 4](../Text/part0026.html#page
    "Chapter 4. Controllers"), *Controllers*. |'
  prefs: []
  type: TYPE_TB
- en: '| **ImageView** | Think of this as a picture view. It has no click events and
    displays images. It can, however, play animations within it. |'
  prefs: []
  type: TYPE_TB
- en: '| **Text View** | It displays multiple lines of text. Can be a read only as
    well as a read/write. |'
  prefs: []
  type: TYPE_TB
- en: '| **Web View** | It is a view used to render HTML. The HTML file can be held
    on the phone or remotely. |'
  prefs: []
  type: TYPE_TB
- en: '| **Map View** | It displays a map with various options. Maps are covered later
    in this book. |'
  prefs: []
  type: TYPE_TB
- en: '| **Scroll View** | It is a view designed to allow more content to be accommodated
    on a screen than the screen size actually allows. |'
  prefs: []
  type: TYPE_TB
- en: '| **Picker View** | It is a user-definable picker. |'
  prefs: []
  type: TYPE_TB
- en: '| **AdBanner View** | It is an advertising banner bar for in-app advertising.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **GLKit View** | It is used for OpenGL-ES rendering. |'
  prefs: []
  type: TYPE_TB
- en: I will deal with the views not covered here elsewhere in this book. As with
    all views, these too need to be dragged onto the view in Xcode and then linked
    to the main code.
  prefs: []
  type: TYPE_NORMAL
- en: Activity Indicator and Progress View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UIActivityIndicatorView` class is a very simple view to implement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UIProgressView` class is a little more complex, but still quite simple.
    This works on a thread system to keep track of the indicator. Let''s start by
    setting one up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to construct the thread routine. The `NSAutoreleasePool` class is used
    as a temporary block of memory that is released once the code within the braces
    has been executed. In the following code, it allows access to the `InvokeOnMainThread`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, link it to the Progress View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: UIImageView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `UIImageView` class can bring an image in from `UIImage`, which in turn brings
    images in from a number of places:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FromFile`: a file held within the structure of the application (for example,
    if the application has a directory called `Graphics`, the `FromFile` would point
    to `Graphics` | `image.png`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromImage`: loads from `CoreImage` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromResource`: loads from the `Resources` directory. These are embedded from
    within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromBundle`: loads an image relative to the main application bundle and caches
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadFromData`: an image created from within the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To load a file into `UIImageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `UIImageView` class can also display animations. The main prerequisite for
    doing this is that you should have a number of images to animate. In my example,
    I have six images of a tractor. The wheels are the only parts that move.
  prefs: []
  type: TYPE_NORMAL
- en: '![UIImageView](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To start the animation, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the animation, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animation is covered in [Chapter 10](../Text/part0048.html#page "Chapter 10. Animation"),
    *Animation*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: UICollectionView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest Collection View that you're likely to see is an image gallery.
    Think of the Collection View as being a grid view that can be extended. Each Collection
    View is made up of three different items; cells, supplementary views (data-driven
    views), and decoration views.
  prefs: []
  type: TYPE_NORMAL
- en: Cells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each `UICollectionView` class will contain `UICollectionViewCells`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These cells have a main Content View (where you see something, be it a picture
    or the data derived within the app), and surrounding the Content View is one of
    the two background views: normal or selected. If the content part is not smaller
    than the background, the background won''t be seen.'
  prefs: []
  type: TYPE_NORMAL
- en: Supplementary Views
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are views that present information linked to each section of `UICollectionView`.
    They are data driven. Where the cells are from a data source, the Supplementary
    View presents that section's data (for example, the main view could be the front
    covers of books, the Supplementary View could be the table of contents).
  prefs: []
  type: TYPE_NORMAL
- en: Decoration View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are not data generated and are there purely for aesthetic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Data source
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `UICollectionView` class gets its data via the `UICollectionViewDataSource`
    class. This class provides information, such as the cells (from `GetCell`), supplementary
    views (from `GetViewForSupplementaryElement`), number of sections (from `NumberOfSections`
    or 1 if not implemented), and the number of items per section (from `GetItemsCount`).
  prefs: []
  type: TYPE_NORMAL
- en: Cell Reuse
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `UICollectionView` class will only call the data source to get cells for
    items that are on the screen. Items that are not on the screen are placed in a
    queue to be reused.
  prefs: []
  type: TYPE_NORMAL
- en: UIWebView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UIWebView` class effectively transforms your device into a web browser
    with JavaScript capabilities as well as the usual web facilities, such as move
    back, forward, and typing a URL in the text field when extended with `UITextField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a web page is simple enough, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of factors to remember with web page loading. The first factor
    is that it is typically an asynchronous task; in other words, some parts are completed
    before others and it is quite possible that the application flow will return to
    the main thread before the task is completed. The second factor is the speed.
    I'll not concern myself with the second factor for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the problem caused by asynchronous tasks, there are a number of
    events that can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadStarted`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadFinished`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadError`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The boolean `IsLoading`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IsLoading` boolean is a flag that can be checked at any point to determine
    if something is loading (true) or has completed loading (false).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To move back and forward, the following methods can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web.GoBack()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web.GoForward()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods have a simple boolean test
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`web.CanGoBack`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web.CanGoForward`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For refreshing a webpage, the following method can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is also possible to include zoom support and fitting the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: MapView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are the iOS maps, not Google Maps (Apple moved from using Google to their
    own maps with iOS 6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Maps under iOS require the use of `CoreLocations` and `MapKit`. Mapping and
    location services are dealt with later in [Chapter 12](../Text/part0055.html#page
    "Chapter 12. Peripherals"), *Peripherals*.
  prefs: []
  type: TYPE_NORMAL
- en: UIScrollView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when too much information will be displayed on screen (for example,
    if you are dynamically generating content or creating some form of a drawing application).
    In such cases, `UIScrollView` can be used to ensure that the user can see everything.
  prefs: []
  type: TYPE_NORMAL
- en: The view (when combined with `PageEnabled = true;`) works by calculating the
    size of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the Scroll View has been created in Xcode (and is called `scrollView`),
    the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an effective page system. The problem is tracing which page the
    user is on. This is handled with `UIPageControl`. In the previous example, tracking
    would be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ViewDidLoad()` method, tracking would be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: AdBannerView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have seen these on many different apps. These are the bars at the top that
    advertise anything, from cars to fast food, and normally are targeted on the app
    type (for example, if you design an application that gives statistics on a car
    performance, the ad banner will typically get adverts for car magazines, car games,
    and so on). It is simply a way of generating income for the application developer.
    Advert support is a part of the `AdSupport` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple way to consider these views is as a form of web view with a number
    of key events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AdLoaded`: until the ad is loaded, the view isn''t shown. This makes the experience
    less obtrusive for the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FailedToReceive`: the advert failed to download.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a view with multiple View Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is simple enough to implement a view with more than one View Controller.
    Say we have two views. One occupies the top 130 pixels of the screen; the other
    is 250 pixels in height. It is added by adding the second view as a subview to
    the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The events from both the View Controllers will still work as they do normally
    (so say the second view is a web view and the first has some buttons, the buttons
    will still respond to the the Touch events and the web view will still respond
    to the Web events).
  prefs: []
  type: TYPE_NORMAL
- en: The issue, though, comes when view 1 (the parent) wants to act on the events
    of view 2\. This too is not that difficult to do. In fact, when dealing with the
    `MT.D` class in [Chapter 2](../Text/part0019.html#page "Chapter 2. The User Interface"),
    *The User Interface*, the `SubView` event was acted on in the parent by overriding
    the `Selected` event with adelegate in another class (as demonstrated in the following
    code examples).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And within the class handling `UIPickerViewModel`, the `Selected` method has
    to be overridden to support `PickerChangedEventArgs` as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally within the main app, code that calls the class `UIPickerView` needs
    to fire on the new event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a little wonder that the iPhone is such an adaptable device for displaying
    various forms of data with all of these Views and View types available, despite
    its complexity; it is actually a simple enough system to code for.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve deeper into controllers.
  prefs: []
  type: TYPE_NORMAL
