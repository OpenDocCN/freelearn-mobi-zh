- en: Chapter 12. Working with Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, most major programming languages have functionalities similar to what
    closures offer. Some of these implementations are really hard to use (Objective-C
    blocks), while others are easy (Java lambda and C# delegates). I found that the
    functionality that closures provide is especially useful when developing frameworks.
    I have also used them extensively when communicating with remote services over
    a network connection. While blocks in Objective-C are incredibly useful (and I
    used them quite a bit), their syntax used to declare a block was absolutely horrible.
    Luckily, when Apple was developing the Swift language, they made the syntax of
    closures much easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several useful examples of closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid strong reference cycles with closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures are self-contained blocks of code that can be passed around and used
    throughout our application. We can think of an int type as a type that stores
    an integer and a string type as a type that stores a string. In this context,
    a closure can be thought of as a type that holds a block of code. What this means
    is that we can assign closures to a variable, pass them as arguments to functions,
    and also return functions from them.
  prefs: []
  type: TYPE_NORMAL
- en: Closures have the ability to capture and store references to any variable or
    constant from the context in which they were defined. This is known as closing
    over the variables or constants, and the best thing is, for the most part, Swift
    will handle the memory management for us. The only exception is when we create
    a strong reference cycle, and we will look at how to resolve this in the *Creating
    strong reference cycles with closures* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures in Swift are similar to blocks in Objective-C; however, closures in
    Swift are a lot easier to use and understand. Let''s look at the syntax used to
    define a closure in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the syntax used to create a closure looks very similar to the
    syntax we use to create functions in Swift, and actually, in Swift, global and
    nested functions are closures. The biggest difference in the format between closures
    and functions is the `in` keyword. The `in` keyword is used in place of curly
    brackets to separate the definition of the closure's parameter and return types
    from the body of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: There are many uses for closures and we will go over a number of them later
    in this chapter, but first we need to understand the basics of closures. Let's
    start by looking at some very basic uses for closures so that we can get a better
    understanding of what they are, how to define them, and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin by creating a very simple closure that does not accept any arguments
    and does not return any value. All it does is print `Hello World` to the console.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a closure and assign it to the constant `clos1`.
    Since there are no parameters defined between the parentheses, this closure will
    not accept any parameters. Also, the return type is defined as `Void`; therefore,
    this closure will not return any value. The body of the closure contains one line
    that prints `Hello World` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to use closures; in this example, all we want to do is
    execute it. We would execute this closure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the closure, we will see that `Hello World` is printed to the
    console. At this point, closures may not seem that useful, but as we get further
    along in this chapter, we will see how useful and powerful they can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another simple closure example. This closure will accept one
    string parameter named `name`, but will still not return a value. Within the body
    of the closure, we will print out a greeting to the name passed into the closure
    through the `name` parameter. Here is the code for this second closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The big difference between `clos2` defined in this example and the previous
    `clos1` closure is that we define a single string parameter between the parentheses
    in this closure. As we can see, we define parameters for closures just like we
    define parameters for functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute this closure in the same way in which we executed `clos1`. The
    following code shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example, when executed, will print the message `Hello Jon` to the console.
    Let's look at another way we can use the `clos2` closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our original definition of closures stated, "Closures are self-contained blocks
    of code that can be passed around and used throughout our application code". What
    this tells us is that we can pass our closure from the context that they were
    created in other parts of our code. Let''s look at how to pass our `clos2` closure
    into a function. We will define the function that accepts our `clos2` closure
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the function just like we would any other function; however, in our
    parameter list, we define a parameter named `handler`, and the type defined for
    the handler parameter is `(String)->Void`. If we look closely, we can see that
    the `(String)->Void` definition of the `handler` parameter matches the parameter
    and return types that we defined for `clos2` closure. This means that we can pass
    the `clos2` closure into the function. Let''s look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We call the `testClosure()` function just like any other function and the closure
    that is being passed in looks like any other variable. Since the `clos2` closure
    executed in the `testClosure()` function, we will see the message, `Hello Dasher`,
    printed to the console when this code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see a little later in this chapter, the ability to pass closures
    to functions is what makes closures so exciting and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final piece to the closure puzzle, let''s look at how to return a value
    from a closure. The following example shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `clos3` closure looks very similar to how we defined
    the `clos2` closure. The difference is that we changed the `Void` return type
    to a `String` type. Then, in the body of the closure, instead of printing the
    message to the console, we used the return statement to return the message. We
    can now execute the `clos3` closure just like the previous two closures or pass
    the closure to a function like we did with the `clos2` closure. The following
    example shows how to execute `clos3` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this line of code is executed, the message variable will contain the `Hello
    Buddy` string.
  prefs: []
  type: TYPE_NORMAL
- en: The previous three examples of closures demonstrate the format and how to define
    a typical closure. Those who are familiar with Objective-C can see that the format
    of closures in Swift is a lot cleaner and easier to use. The syntax for creating
    closures that we have shown so far in this chapter is pretty short; however, we
    can shorten it even more. In this next section, we will look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand syntax for closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a couple of ways to shorten the definition
    of closures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the shorthand syntax for closures is really a matter of personal preference.
    There are a lot of developers that like to make their code as small and compact
    as possible and they take great pride in doing so. However, at times, this can
    make code hard to read and understand by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first shorthand syntax for closures that we are going to look at is one
    of the most popular and is the syntax we saw when we were using algorithms with
    arrays in [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*. This format is mainly used when we want
    to send a really small (usually one line) closure to a function, like we did with
    the algorithms for arrays. Before we look at this shorthand syntax, we need to
    write a function that will accept a closure as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts two parameters—the first parameter is an integer named
    `num`, and the second parameter is a closure named `handler` that does not have
    any parameters and does not return any value. Within the function, we create a
    `for` loop that will use the `num` integer to define how many times it loops.
    Within the `for` loop, we call the `handler` closure that was passed into the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a closure and pass it to the `testFunction()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very easy to read and understand; however, it does take five lines
    of code. Now, let''s look at how to shorten this code by writing the closure inline
    within the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created the closure inline within the function call using
    the same syntax that we used with the algorithms for arrays. The closure is placed
    in between two curly brackets (`{}`), which means the code to create our closure
    is `{print("Hello from Shorthand closure")}`. When this code is executed, it will
    print out the message, `Hello from Shorthand closure`, five times on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*, we saw that we were able to pass parameters
    to the array algorithms using the `$0`, `$1`, `$2`, and so on parameters. Let''s
    look at how to use parameters with this shorthand syntax. We will begin by creating
    a new function that will accept a closure with a single parameter. We will name
    this function `testFunction2`. The following example shows what the new `testFunction2`
    function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In `testFunction2`, we define our closure like this: `(name: String)->Void`.
    This definition means that the closure accepts one parameter and does not return
    any value. Now, let''s see how to use the same shorthand syntax to call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The difference between this closure definition and the previous one is `$0`.
    The `$0` parameter is shorthand for the first parameter passed into the function.
    If we execute this code, it prints out the message, `Hello from Me`, five times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the dollar sign (`$`) followed by a number with inline closures allows
    us to define the closure without having to put a parameter list in the definition.
    The number after the dollar sign defines the position of the parameter in the
    parameter list. Let''s examine this format a bit more because we are not limited
    to only using the dollar sign (`$`) and number shorthand format with inline closures.
    This shorthand syntax can also be used to shorten the closure definition by allowing
    us to leave the parameter names off. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, our closure has two string parameters defined; however, we
    do not give them names. The parameters are defined like this: `(String, String)`.
    We can then access the parameters within the body of the closure using `$0` and
    `$1`. Also, note that closure definition is after the colon (`:`), using the same
    syntax that we use to define a variable type, rather than inside the curly brackets.
    When we use anonymous arguments, this is how we would define the closure. It will
    not be valid to define the closure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will receive the `Anonymous closure arguments cannot be
    used inside a closure that has explicit arguments` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `clos5` closure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since `Hello` is the first string in the parameter list, it is accessed with
    `$0`, and as `Kara` is the second string in the parameter list, it is accessed
    with `$1`. When we execute this code, we will see the message, `Hello Kara`, printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next example is used when the closure doesn''t return any value. Rather
    than defining the return type as `Void`, we can use parentheses, as the following
    example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define the closure as `() -> ()`. This tells Swift that
    the closure does not accept any parameters and also does not return a value. We
    will execute this closure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have one more shorthand closure example to demonstrate before we begin showing
    some useful examples of closures. In this last example, we will demonstrate how
    we can return a value from the closure without the need to include the word, `return`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the entire closure body consists of only a single statement, then we can
    omit the `return` keyword, and the results of the statement will be returned.
    Let''s take a look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the closure accepts two parameters of the `Int` type and will
    return an `Int` type. The only statement within the body of the closure adds the
    first parameter to the second parameter. However, if you notice, we do not include
    the `return` keyword before the addition statement. Swift will see that this is
    a single statement closure and will automatically return the results, just as
    if we put the `return` keyword before the addition statement. We do need to make
    sure the result type of our statement matches the return type of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples that were shown in the previous two sections were designed
    to show how to define and use closures. On their own, these examples did not really
    show off the power of closures and they did not show how incredibly useful closures
    are. The remainder of this chapter is written to demonstrate the power and usefulness
    of closures in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Using closures with Swift's array algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*, we looked at several built-in algorithms
    that we could use with Swift's arrays. In that chapter, we briefly saw how to
    add simple rules to each of these algorithms with very basic closures. Now that
    we have a better understanding of closures, let's see how we can expand on these
    algorithms using more advanced closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will primarily be using the map algorithm for consistency
    purposes; however, we can use the basic ideas demonstrated with any of the algorithms.
    We will start by defining an array to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This array contains a list of names and the array is named `guests`. This array
    will be used for all the examples in this section, except for the very last ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `guests` array, let''s add a closure that will print a
    greeting to each of the names in the `guests` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the map algorithm applies the closure to each item of the array, this
    example will print out a greeting for each name within the `guests` array. After
    the first section in this chapter, we should have a pretty good understanding
    of how this closure works. Using the shorthand syntax that we saw in the last
    section, we could reduce the preceding example down to the following single line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the few times, in my opinion, where the shorthand syntax may
    be easier to read than the standard syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that rather than printing the greeting to the console, we wanted
    to return a new array that contained the greetings. For this, we would have returned
    a string type from our closure, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When this code is executed, the `messages` array will contain a greeting to
    each of the names in the `guests` array while the `guests` array will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples in this section showed how to add a closure to the map
    algorithm inline. This is good if we only had one closure that we wanted to use
    with the map algorithm, but what if we had more than one closure that we wanted
    to use, or if we wanted to use the closure multiple times or reuse them with different
    arrays. For this, we could assign the closure to a constant or variable and then
    pass in the closure, using its constant or variable name, as needed. Let''s see
    how to do this. We will begin by defining two closures. One of the closures will
    print a greeting for each name in the `guests` array, and the other closure will
    print a goodbye message for each name in the `guests` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have two closures, we can use them with the map algorithm as needed.
    The following code shows how to use these closures interchangeably with the `guests`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we use the `greetGuest` closure with the `guests` array, the greetings
    message is printed to the console, and whenever we use the `sayGoodbye` closure
    with the `guests` array, the goodbye message is printed to the console. If we
    had another array named `guests2`, we could use the same closures for that array,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the examples, in this section, so far have either printed a message
    to the console or returned a new array from the closure. We are not limited to
    such basic functionality in our closures. For example, we can filter the array
    within our closure, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we print out a different message depending on whether the name
    starts with the letter K or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier in the chapter, closures have the ability to capture
    and store references to any variable or constant from the context in which they
    were defined. Let''s look at an example of this. Let''s say that we have a function
    that contains the highest temperature for the last seven days at a given location
    and this function accepts a closure as a parameter. This function will execute
    the closure on the array of temperature. The function can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function accepts a closure defined as `(Int)->Void`. We then use the map
    algorithm to execute this closure for each item of the `tempArray` array. The
    key to using a closure correctly in this situation is to understand that the `temperatures`
    function does not know or care what goes on inside the `calculate` closure. Also,
    be aware that the closure is also unable to update or change the items within
    the function's context, which means that the closure cannot change any other variable
    within the temperature's function; however, it can update variables in the context
    that it was created in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the function that we will create the closure in. We will name
    this function `testFunction`. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we begin by defining two variables named `total` and `count`,
    where both variables are of the integer type. We then create a closure named `addTemps`
    that will be used to add all of the temperatures from the `temperatures` function
    together. The `addTemps` closure will also count how many temperatures are there
    in the array. To do this, the `addTemps` closure calculates the sum of each item
    in the array and keeps the total in the `total` variable that was defined at the
    beginning of the function. The `addTemps` closure also keeps track of the number
    of items in the array by incrementing the `count` variable for each item. Notice
    that neither the `total` nor `count` variables are defined within the closure;
    however, we are able to use them within the closure because they were defined
    in the same context as the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `temperatures` function and pass it the `addTemps` closure.
    Finally, we print the total, count, and average temperature to the console. When
    the `testFunction` is executed, we see the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the `addTemps` closure is able to update and
    use items that are defined within the context that it was created in, even when
    the closure is used in a different context.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at using closures with the array map algorithm, let's
    look at using closures by themselves. We will also look at the ways we can clean
    up our code to make it easier to read and use.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone closures and good style guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures give us the ability to truly separate the data portions of our code
    from the user interface and business logic portions. This gives us the ability
    to create reusable classes that focus solely on retrieving our data. This is especially
    good for developing classes and frameworks that are designed to retrieve data
    from external services, such as web services, databases, or files. This section
    will show how to develop a class that will execute a closure once our data is
    ready to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a class that will contain the data portion of our
    code. In this example, the class will be named `Guests` and it will contain an
    array of `guests` names. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the `Guests` class defines an array named `guestNames`. The
    `guestNames` array contains seven names. After we define the `guestNames` array,
    we then create a type alias. A type alias defines a named alias for an existing
    type. Just like a function, closures have types that consist of the parameter
    types and return types, which can be aliased. This allows us to define the closure
    once and then use the alias anywhere within our code. Using a type alias can reduce
    the amount of typing we have to do and also prevent errors. Therefore, it is recommended
    that we use them rather than trying to retype the closure definition multiple
    times in our code. It also allows us to change the definition in one location
    and it will then update throughout the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our type alias is named `UseArrayClosure` and is defined as
    a closure that accepts an array of strings as the only parameter and does not
    return a value. We can now use this type alias throughout our code as shorthand
    for the closure definition.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define a `getGuest()` method that accepts a closure named `handler`
    as its only parameter. Within the `getGuests()` method, the only thing we do is
    execute the handler. Normally, in this method, we will have the logic to retrieve
    the data from our external data source; however, in this example, we have an array
    that is hardcoded with our list of guest names. Therefore, all we need to do is
    to execute the closure with the `guestsNames` array as the only parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say that we want to display this array of names in a `UITableView`
    view. A `UITableView` is an iOS view that is designed for displaying lists of
    information. In the view controller, we will need to create an array to hold the
    data to display in `UITableView` and a variable that will link to `UITableView`
    in our display. These will both be class variables defined in our view controller
    class, and they are defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a function called `getData()` that will be used to retrieve
    the list of guests and update the table view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We begin the `getData()` function by defining a closure named `dataClosure`.
    This closure uses the `UseArrayClosure` type alias that we defined in the `Guests`
    class for the closure definition. Within the closure definition, we set the `tableData`
    array, which is defined within the view controller itself (not in the closure),
    equal to the string array that is passed into the closure. We then verify whether
    the `tableView` variable contains an instance of the `UITableView` class, and
    if so, we reload its data. Finally, we create an instance of the `Guests` class
    and call the `getGuest()` method passing it the `dataClosure` closure.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the `guestNames` array, which defines the list of names, is
    defined in the `Guest` class, while the `tableView`, `UITableView`, and `tableData`
    arrays are defined in the view controller class.
  prefs: []
  type: TYPE_NORMAL
- en: When the `dataClosure` closure is passed to the `getGuests()` method, it will
    load the array of names, from the `Guests` class, into the `tableData` array.
    The `tableData` array is then used within the view controller class as the data
    elements for the `UITableView` array. The key items to note in this example are
    that we are able to load data from one context (the `Guests` class) into a variable
    that was defined within the same context as the closure (the view controller),
    and also have the ability to call methods on instances of classes (`tableView`
    and `UITableView`) defined within the same context as the closure.
  prefs: []
  type: TYPE_NORMAL
- en: We could have very easily created a method in the `Guest` class that returned
    the `guestNames` array. With a hardcoded array, such as the one we have in the
    `Guest` class, this method would have worked very well. However, if we were loading
    the data from a web service that takes a little time to load; this will not work
    as well because our UI will freeze while waiting for the data to load. By using
    a closure, as shown in this example, we can make the web service call asynchronously,
    and then when the data is returned, the closure will be executed and the UI updates
    automatically without our UI freezing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is primarily written to teach the Swift language and not specifically
    iOS development; therefore, we are not covering how the UI elements from the Cocoa
    Touch framework work in this example. If you want to see the full iOS example,
    download the code samples for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Changing functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closures also give us the ability to change the functionality of classes on
    the fly. We saw in [Chapter 11](ch11.html "Chapter 11. Working with Generics"),
    *Working with Generics*, that generics give us the ability to write functions
    that are valid for multiple types. With closures, we are able to write functions
    and classes whose functionality can change, based on the closure that is passed
    into it as a parameter. In this section, we will show how to write a function
    whose functionality can be changed with a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by defining a class that will be used to demonstrate how to swap
    out functionality. We will name this class `TestClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We begin this class by defining a type alias for our closure that is named `getNumClosure`.
    Any closure that is defined as a `getNumClosure` closure will take two integers
    and return an integer. Within this closure, we assume that it does something with
    the integers that we pass in to get the value to return, but it really doesn't
    have to. To be honest, this class doesn't really care what the closure does as
    long as it conforms to the `getNumClosure` type. Next, we define three integers
    that are named `numOne`, `NumTwo`, and `results`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define a method named `getNum()`. This method accepts a closure
    that confirms the `getNumClosure` type as its only parameter. Within the `getNum()`
    method, we execute the closure by passing in the `numOne` and `numTwo` class variables,
    and the integer that is returned is put into the `results` class variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at several closures that conform to the `getNumClosure` type
    that we can use with the `getNum()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we define five closures that conform to the `getNumClosure` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max`: This returns the maximum value of the two integers that are passed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: This returns the minimum value of the two integers that are passed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiply`: This multiplies both the values that are passed in and returns
    the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second`: This returns the second parameter that was passed in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`answer`: This returns the answer to life, the universe, and everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `answer` closure, we have an extra line that looks like it does not
    have a purpose: `var tmp = $0 + $1`. We do this purposely because the following
    code is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This class gives us the `error: tuple types ''(Int, Int)'' and ''()'' have
    a different number of elements (2 vs. 0)` error. As we can see by the error, Swift
    does not think that our closure accepts any parameters unless we use `$0` and
    `$1` within the body of the closure. In the closure named `second`, Swifts assumes
    that there are two parameters because `$1` specifies the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now pass each one of these closures to the `getNum` method of our `TestClass`
    to change the functionality of the function to suit our needs. The following code
    illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is run, we will receive the following results for each of the
    closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max`: results = 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: results = 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiply`: results = 40'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second`: results = 8'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`answer`: results = 42'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last example we are going to show you in this chapter is one that is used
    a lot in frameworks, especially the ones that have a functionality that is designed
    to be run asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a closure based on results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final example, we will pass two closures to a method, and then depending
    on some logic, one, or possibly both, of the closures will be executed. Generally,
    one of the closures is called if the method was successfully executed and the
    other closure is called if the method failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a class that will contain a method that will accept
    two closures and then execute one of the closures based on the defined logic.
    We will name this class `TestClass`. Here is the code for the `TestClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We begin this class by creating a type alias that defines the closure that we
    will use for both the successful and failure closures. We will name this type
    alias `ResultsClosure`. This example will also illustrate why using a type alias,
    rather than retyping the closure definition, saves us a lot of typing and also
    prevents us from making mistakes. In this example, if we did not use a type alias,
    we would need to retype the closure definition four times, and if we needed to
    change the closure definition, we would need to change it in four spots. With
    the type alias, we only need to type the closure definition once and then use
    the alias throughout the remaining code.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a method named `isGreater` that takes two integers as the first
    two parameters and then two closures as the next two parameters. The first closure
    is named `successHandler`, and the second closure is named `failureHandler`. Within
    the `isGreater` method, we check whether the first integer parameter is greater
    than the second one. If the first integer is greater, the `successHandler` closure
    is executed; otherwise, the `failureHandler` closure is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create two of our closures. The code for these two closures is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that both closures are defined as the `TestClass.ResultsClosure` type.
    In each closure, we simply print a message to the console to let us know which
    closure was executed. Normally, we would put some functionality in the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then call the method with both the closures like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the method call, we are sending both the success closure and the
    failure closure. In this example, we will see the message, `Success: 8 is greater
    than 6`. If we reversed the numbers, we would see the message, `Failure: 6 is
    not greater than 8`. This use case is really good when we call asynchronous methods,
    such as loading data from a web service. If the web service call was successful,
    the success closure is called; otherwise, the failure closure is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One big advantage of using closures like this is that the UI does not freeze
    while we wait for the web service call to complete. This also involves a concurrency
    piece, which we will be covering in [Chapter 14](ch14.html "Chapter 14. Concurrency
    and Parallelism in Swift"), *Concurrency and Parallelism in Swift*, later in this
    book. As an example, if we tried to retrieve data from a web service like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our UI would freeze while we wait for the response to come back, or we would
    have to make the call in a separate thread so that the UI would not hang. With
    closures, we pass the closures to the networking framework and rely on the framework
    to execute the appropriate closure when it is done. This does rely on the framework
    to implement concurrency correctly to make the calls asynchronously, but a decent
    framework should handle that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating strong reference cycles with closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we said, "the best thing is, for the most part, Swift
    will handle the memory management for us". The "for the most part" section of
    the quote means that if everything is written in a standard way, Swift will handle
    the memory management of the closures for us. However, just like classes, there
    are times where the memory management fails us. Memory management will work correctly
    for all of the examples that we have seen in this chapter so far. It is possible
    to create a strong reference cycle that would prevent Swift's memory management
    from working correctly. Let's look at what happens if we create a strong reference
    cycle with closures.
  prefs: []
  type: TYPE_NORMAL
- en: A strong reference cycle may happen if we assign a closure to a property of
    a class instance and within that closure, we capture the instance of the class.
    This capture occurs because we access a property of that particular instance using
    `self` like `self.someProperty` or we assign self to a variable or constant like
    `let c = self`. By capturing a property of the instance, we are actually capturing
    the instance itself, thereby creating a strong reference cycle where the memory
    manager will not know when to release the instance. As a result, the memory will
    not be freed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a class that has a closure and an instance of the
    string type as its two properties. We will also create a type alias for the closure
    type in this class and define a `deinit()` method that prints a message to the
    console. The `deinit()` method is called when the class gets released and the
    memory is freed. We will know when the class gets released when the message from
    the `deinit()` method is printed to the console. This class will be named `TestClassOne`.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a second class that will contain a method that accepts a
    closure that is of the `nameClosure` type that was defined in the `TestClassOne`
    class. This class will also have a `deinit()` method, so we can also see when
    it gets released. We will name this class `TestClassTwo`. Let''s take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see this code in action by creating instances of each class and
    then trying to manually release the instance by setting them to `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: What we do in this code is create two optionals that may contain an instance
    of our two test classes or nil. We need to create these variables as optionals
    because we will be setting them to `nil` later in the code so that we can see
    whether the instances are released properly.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `closureExample()` method of the `TestClassTwo` instance and
    pass it the `myClosure` property from the `TestClassOne` instance. We now try
    to release the `TestClassOne` and `TestClassTwo` instances by setting them to
    `nil`. Keep in mind that when an instance of a class is released, it attempts
    to call the `deinit()` method of the class if it exists. In our case, both classes
    have a `deinit()` method that prints a message to the console, so we know when
    the instances are actually released.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this project, we will see the following messages printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we do attempt to release the `TestClassOne` instances, but the
    `deinit()` method of the class is never called, indicating that it was not actually
    released; however, the `TestClassTwo` instance was properly released because the
    `deinit()` method of that class was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is supposed to work without the strong reference cycle, change
    the `myClosure` closure to return a string type that is defined within the closure
    itself, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the project, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the `deinit()` methods from both the `TestClassOne` and `TestClassTwo`
    instances were properly called, indicating that they were both released properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, we capture an instance of the `TestClassOne` class within
    the closure because we accessed a property of the `TestClassOne` class using `self.name`.
    This created a strong reference from the closure to the instance of the `TestClassOne`
    class, preventing memory management from releasing the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Swift does provide a very easy and elegant way to resolve strong reference cycles
    in closures. We simply need to tell Swift not to create a strong reference by
    creating a capture list. A capture list defines the rules to use when capturing
    reference types within a closure. We can declare each reference to be a weak or
    unowned reference rather than a strong reference.
  prefs: []
  type: TYPE_NORMAL
- en: A `weak` keyword is used when there is the possibility that the reference will
    become nil during its lifetime; therefore, the type must be an optional. The `unowned`
    keyword is used when there is not a possibility of the reference becoming nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the capture list by pairing the `weak` or `unowned` keywords with
    a reference to a class instance. These pairings are written within square brackets
    (`[ ]`). Therefore, if we update the `myClosure` closure and define an `unowned`
    reference to `self`, we should eliminate the strong reference cycle. The following
    code shows what the new `myClosure` closure will look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the new line—`[unowned self] in`. This line says that we do not want
    to create a strong reference to the instance of `self`. If we run the project
    now, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This shows that both the `TestClassOne` and `TestClassTwo` instances were properly
    released.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that we can define a closure just like we can define
    an int or string type. We can assign closures to a variable, pass them as an argument
    to functions, and also return them from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Closures capture a store references to any constants or variables from the context
    in which the closure was defined. We do have to be careful with this functionality
    to make sure that we do not create a strong reference cycle, which would lead
    to memory leaks in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Swift closures are very similar to blocks in Objective-C, but they have a much
    cleaner and eloquent syntax. This makes them a lot easier to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good understanding of closures is vital to mastering the Swift programming
    language and will make it easier to develop great applications that are easy to
    maintain for OS X and iOS. It is also essential for creating first class frameworks
    that can be used to create OS X and iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: The three use cases that we saw in this chapter are by no means the only three
    *useful* uses for closures. I can promise you that the more you use closures in
    Swift, the more uses you will find for them. Closures are definitely one of the
    most powerful and useful features of the Swift language, and Apple did a great
    job by implementing them in the language.
  prefs: []
  type: TYPE_NORMAL
