- en: Chapter 4. Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the Test Driven Development discipline. We will start
    with a general revision and later on move to the concepts and techniques closely
    related to the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: This is a code intensive chapter, so be prepared to type as you read, which
    would be the best way to seize the examples provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce and explain Test Driven Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze its advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce a potential real life example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand requirements by writing the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolve through the project by applying TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the application that fully complies with the requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Briefly, Test Driven Development is the strategy of writing tests along the
    development process. These test cases are written in advance of the code that
    is supposed to satisfy them.
  prefs: []
  type: TYPE_NORMAL
- en: A single test is added, then the code needed to satisfy the compilation of this
    test and finally the full set of test cases is run to verify their results.
  prefs: []
  type: TYPE_NORMAL
- en: This contrasts with other approaches to the development process where the tests
    are written at the end when all the coding has been done.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the tests in advance of the code that satisfies them has several advantages.
    First, is that the tests are written in one way or another, while if the tests
    are left till the end it is highly probable that they are never written. Second,
    developers take more responsibility for the quality of their work.
  prefs: []
  type: TYPE_NORMAL
- en: Design decisions are taken in single steps and finally the code satisfying the
    tests is improved by refactoring it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This UML activity diagram depicts the Test Driven Development to help us understand
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with TDD](img/3500OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following sections explain the individual activities depicted in this activity
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start our development process with writing a test case. This apparently simple
    process will put some machinery to work inside our heads. After all, it is not
    possible to write some code, test it or not, if we don't have a clear understanding
    of the problem domain and its details. Usually, this step will get you face to
    face with the aspects of the problem you don't understand, and you need to grasp
    if you want to model and write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Running all tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the test is written the obvious following step is to run it, altogether
    with other tests we have written so far. Here, the importance of an IDE with built-in
    support of the testing environment is perhaps more evident than in other situations
    and this could cut the development time by a good fraction. It is expected that
    firstly, our test fails as we still haven't written any code!
  prefs: []
  type: TYPE_NORMAL
- en: To be able to complete our test, we usually write additional code and take design
    decisions. The additional code written is the minimum possible to get our test
    to compile. Consider here that not compiling is failing.
  prefs: []
  type: TYPE_NORMAL
- en: When we get the test to compile and run, if the test fails then we try to write
    the minimum amount of code necessary to make the test succeed. This may sound
    awkward at this point but the following code example in this chapter will help
    you understand the process.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, instead of running all tests again you can just run the newly added
    test first to save some time as sometimes running the tests on the emulator could
    be rather slow. Then run the whole test suite to verify that everything is still
    working properly. We don't want to add a new feature by breaking an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the test succeeds, we refactor the code added to keep it tidy, clean, and
    minimal.
  prefs: []
  type: TYPE_NORMAL
- en: We run all the tests again, to verify that our refactoring has not broken anything
    and if the tests are again satisfied, and no more refactoring is needed we finish
    our task.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests after refactoring is an incredible safety net which has been
    put in place by this methodology. If we made a mistake refactoring an algorithm,
    extracting variables, introducing parameters, changing signatures or whatever
    your refactoring is composed of, this testing infrastructure will detect the problem.
    Furthermore, if some refactoring or optimization could not be valid for every
    possible case we can verify it for every case used by the application and expressed
    as a test case.
  prefs: []
  type: TYPE_NORMAL
- en: What is the advantage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Personally, the main advantage I''ve seen so far is that you focus your destination
    quickly and is much difficult to divert implementing options in your software
    that will never be used. This implementation of unneeded features is a wasting
    of your precious development time and effort. And as you may already know, judiciously
    administering these resources may be the difference between successfully reaching
    the end of the project or not. Probably, Test Driven Development could not be
    indiscriminately applied to any project. I think that, as well as any other technique,
    you should use your judgment and expertise to recognize where it can be applied
    and where not. But keep this in mind: **there are no silver bullets**.'
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage is that you always have a safety net for your changes. Every
    time you change a piece of code, you can be absolutely sure that other parts of
    the system are not affected as long as there are tests verifying that the conditions
    haven't changed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to write a test about any subject, we should first understand the
    Subject under test.
  prefs: []
  type: TYPE_NORMAL
- en: We also mentioned that one of the advantages is that you focus your destination
    quickly instead of revolving around the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Translating requirements into tests and cross referencing them is perhaps the
    best way to understand the requirements, and be sure that there is always an implementation
    and verification for all of them. Also, when the requirements change (something
    that is very frequent in software development projects), we can change the tests
    verifying these requirements and then change the implementation to be sure that
    everything was correctly understood and mapped to code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project—the Temperature Converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our examples will revolve around an extremely simple Android sample project.
    It doesn't try to show all the fancy Android features but focuses on testing and
    gradually building the application from the test, applying the concepts learned
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pretend that we have received a list of requirements to develop an Android
    temperature converter application. Though oversimplified, we will be following
    the steps you normally would to develop such an application. However, in this
    case we will introduce the Test Driven Development techniques in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The list of requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most usual than not, the list of requirements is very vague and there is a high
    number of details not fully covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s pretend that we receive this list from the project owner:'
  prefs: []
  type: TYPE_NORMAL
- en: The application converts temperatures from Celsius to Fahrenheit and vice-versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    other for Fahrenheit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one temperature is entered in one field the other one is automatically
    updated with the conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some space in the user interface should be reserved for the on screen keyboard
    to ease the application operation when several conversions are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry fields should start empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values entered are decimal values with two digits after the point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are right aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last entered values should be retained even after the application is paused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface concept design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we receive this conceptual user interface design from the
    User Interface Design team:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User interface concept design](img/3500_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first step is to create the project. As we mentioned earlier, we are creating
    a main and a test project. The following screenshot shows the creation of the
    `TemperatureConverter` project (all values are typical Android project values):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the projects](img/3500_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you are ready to continue you should press the **Next >** button in order
    to create the related test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of the test project is displayed in this screenshot. All values
    will be selected for you based on your previous entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the projects](img/3500_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the TemperatureConverterActivityTests project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We only have some templates in our **main project** created by the Android
    ADT plugin, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TemperatureConverterActivity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.xml` layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings.xml` resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resources, like icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, we have some templates created in our **test project**. The corresponding
    test packages to keep our tests separated from the main package are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.xml` layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings.xml` resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resources, like icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be very cautious and don't let the template files fool you. There's little or
    no use of these resources in the test project so to avoid confusion, you should
    delete them. If later on you discover that some tests require specific resources,
    you can add only the needed ones.
  prefs: []
  type: TYPE_NORMAL
- en: Proceed with creating the first test by selecting the main test package name
    **com.example.aatg.tc.test** in Eclipse's **Package Explorer**, and then right-click
    on it. Select **New | JUnit Test Case**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have a dialog like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the TemperatureConverterActivityTests project](img/3500_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you need to enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **New JUnit 3 test** | JUnit 3 is the version supported by Android. Always
    use this option. |'
  prefs: []
  type: TYPE_TB
- en: '| **Source folder:** | The default source folder for the tests. The default
    value should be fine. |'
  prefs: []
  type: TYPE_TB
- en: '| **Package:** | The default package for the tests. This is usually the default
    package name for your main project followed by the subpackage test. |'
  prefs: []
  type: TYPE_TB
- en: '| **Name:** | The name of the class for this test. The best practice here is
    to use the same class name of the class under test followed by the word Tests,
    in plural because most probably we will be hosting several tests in it. |'
  prefs: []
  type: TYPE_TB
- en: '| **Superclass:** | We should select our superclass depending on what and how
    we are going to test. In [Chapter 3](ch03.html "Chapter 3. Building Blocks on
    the Android SDK"), *Building Blocks on the Android SDK*, we reviewed the available
    alternatives. Use it as a reference when you try to decide what superclass to
    use.In this particular case and because we are testing a single `Activity` and
    using the system infrastructure we use `ActivityInstrumentationTestCase2`. Also
    note that as `ActivityInstrumentationTestCase2` is a generic class, we need the
    template parameter as well. This is the `Activity` under test which in our case
    is `TemperatureConverterActivity`.We can ignore the warning indicating that the
    superclass does not exist for now; we will be fixing the imports soon. |'
  prefs: []
  type: TYPE_TB
- en: '| **Method stubs** | Select the method stubs you want created. If at this point
    you are not sure what you would need, then select them all, as default stubs will
    be invoking their super counterparts. |'
  prefs: []
  type: TYPE_TB
- en: '| **Do you want to add comments?** | Generates Javadoc comments for the stub
    test method.Usually, unless you have changed the default template in Code Templates,
    the generated comments will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class under test:** | This is the class we are testing - `TemperatureConverterActivity`
    in this case. This is the most useful in other situations where the class under
    test has been implemented already and we would be able to select the list of methods
    we would like to test. Remember that in our case we haven''t implemented the class
    yet so we will be presented with the only method that is in the Android ADT plugin
    template, which is `onCreate`. |'
  prefs: []
  type: TYPE_TB
- en: This situation, where the class under test has not been implemented yet and
    only the method created by the Android ADT is available, is better understood
    pressing **Next >**. Here, the list of methods available to test is presented,
    and in our case we don't have any methods implemented yet other than `onCreate`
    and the inherited methods from Activity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the TemperatureConverterActivityTests project](img/3500_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This dialog has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Available methods:** | This is the list of all the methods we may want
    to test.When methods are overloaded, test names are generated accordingly to cope
    with the situation and parameter names are mangled into the test name. |'
  prefs: []
  type: TYPE_TB
- en: '| **Create final method stubs** | Convenience set to add the final modifier
    to stub methods.The final modifier prevents these methods from being overridden
    by a subclass. |'
  prefs: []
  type: TYPE_TB
- en: '| **Create tasks for generated test methods** | Creates a TODO comment in the
    test case. |'
  prefs: []
  type: TYPE_TB
- en: Either way, we may select `onCreate(Bundle)` to generate the `testOnCreateBundle`
    method for us, but we are leaving the selection list empty for now to avoid extra
    complexity of this simple demonstration application.
  prefs: []
  type: TYPE_NORMAL
- en: We now notice that our automatically generated class has some errors we need
    to fix before running. Otherwise the errors will prevent the test from running.
  prefs: []
  type: TYPE_NORMAL
- en: First we should add the missing imports, using the shortcut *Shift+Ctrl+O*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, the problem we need to fix has been described before in [Chapter 3](ch03.html
    "Chapter 3. Building Blocks on the Android SDK"), *Building Blocks on the Android
    SDK* under the section *The no-argument constructor*. As this pattern dictates,
    we need to implement it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added the no argument constructor `TemperatureConverterActivityTests()`.
    From this constructor, we invoke the constructor that takes a name as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in this given name constructor, we invoke the super constructor and
    set the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To verify that everything has been set up in place, you may run the tests by
    using **Run as | Android JUnit Test**. There are no tests to run yet but at least
    we can verify that the infrastructure supporting our tests is already in place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start creating our test fixture by populating the `setUp` method with
    the elements we need in our tests. Almost unavoidable, in this case, is the use
    of the `Activity` under test, so let''s prepare for the situation and add it to
    the fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's create the `mActivity` field as well as the one proposed by Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: The `ActivityInstrumentationTestCase2.getActivity()` method has a side effect.
    If the `Activity` under test is not running, it is started. This may change the
    intention of a test if we use `getActivity()` as a simple accessor several times
    in a test and for some reason the `Activity` finishes or crashes before test completion.
    We will be inadvertently restarting the `Activity`, that is why in our tests we
    discourage the use of `getActivity()` in favor of having it in the fixture.
  prefs: []
  type: TYPE_NORMAL
- en: Test preconditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned this before and this can be identified as another pattern. It's
    very useful to test all the preconditions and be sure that our fixture has been
    created correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That is, let's check that our fixture is composed by "not null" values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tests to verify that everything is correct and green as shown
    in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test preconditions](img/3500_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to our Test Driven Development track, we need from our concise list of
    requirements that there be two entries for Celsius and Fahrenheit temperatures
    respectively. So let's add them to our test fixture.
  prefs: []
  type: TYPE_NORMAL
- en: They don't exist yet, and we haven't even started designing the user interface
    layout, but we know that there should be two entries like these for sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code you should add to the `setUp()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some important things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the fields for our fixture using `EditText` that we should import
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use previously created `mActivity` to find the `Views` by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the R class for the main project, not the one in the test project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the existence of the user interface components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have added them to the `setUp()` method, as indicated in the previous
    section, we can check their existence in a specific test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are not able to run the tests yet because we must fix some compilation problems
    first. We should fix the missing IDs in the R class.
  prefs: []
  type: TYPE_NORMAL
- en: Having created our test fixture that references elements and IDs in the user
    interface that we don't have yet, it's mandated by the Test Driven Development
    paradigm that we add the needed code to satisfy our tests. The first thing we
    should do is get it to compile at least, so if we have some tests testing unimplemented
    features they will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the IDs defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first stop would be to have the IDs for the user interface elements defined
    in the `R` class so the errors generated by referencing undefined constants `com.example.aatg.tc.R.id.celsius`
    and `com.example.aatg.tc.R.id.fahrenheit` go away.
  prefs: []
  type: TYPE_NORMAL
- en: You, as an experienced Android developer, know how to do it. I'll give you a
    refresher anyway. Open the `main.xml` layout in the layout editor and add the
    required user interface components to get something that resembles the design
    previously introduced in the section *User Interface concept design*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so we get our tests to compile. Running them we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testPreconditions` succeeded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testHasInputFields` succeeded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is green now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This clearly means that we are on track with applying TDD.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that we added some decorative and non functional items
    to our user interface that we are not testing, mainly to keep our example as simple
    as possible. In a real case scenario you may want to add tests for these elements
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Translating requirements to tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tests have a double feature. They verify the correctness of our code but sometimes,
    and more prominently in TDD, they help us understand the design and digest what
    we are implementing. To be able to create the tests, we need to understand the
    problem we are dealing with and if we don't, we should at least have a rough understanding
    of the problem to allow us to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, the requirements behind the user interface are not clearly expressed
    and you should be able to understand them from the schematic UI design. If we
    pretend that this is the case, then we can grasp it by writing our tests first.
  prefs: []
  type: TYPE_NORMAL
- en: Empty fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From one of our requirements, we get: Entry fields should start empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To express this in a test we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply compare the initial contents of the fields against the empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Not very surprisingly, we find that the test fails on execution. We forgot to
    clear the initial contents of the fields and they are not empty. Even though we
    haven't added any value to the `android:text` property of these fields, the ADT
    plugin layout editor adds some default values. Thus removing the default values
    from `android:text="@~+id/EditText01"` and `android:text="@+id/EditText02"` will
    force starting with empty temperature fields. These values may have been added
    by the ADT plugin itself or maybe by you when entering properties.
  prefs: []
  type: TYPE_NORMAL
- en: On running the test again, we find that it passes. We successfully converted
    one requirement to a test and validated it by obtaining the test results.
  prefs: []
  type: TYPE_NORMAL
- en: View properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Identically, we can verify other properties of the `Views` composing our layout.
    Among other things we can verify:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields appear on the screen as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start verifying that the fields are on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained before, we use an assert form here: `ViewAsserts: assertOnScreen`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static imports and how to add them to Eclipse's Content Assist was explained
    in [Chapter 3](ch03.html "Chapter 3. Building Blocks on the Android SDK"), *Building
    Blocks on the Android SDK*. If you haven't done it before, now is the time.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertOnScreen` method needs an origin to start looking for the other `Views`.
    In this case, because we want to start from the top most level, we use `getDecorView(),`
    which retrieves the top-level window decor view containing the standard window
    frame and decorations, and the client's content inside.
  prefs: []
  type: TYPE_NORMAL
- en: By running this test, we can ensure that the entry fields are on the screen
    as the UI design dictates. In some way we already knew that some Views with these
    specific IDs existed. That is, we made the fixture compile by adding the Views
    to the main layout, but we were not sure they were appearing on the screen at
    all. So, nothing else is needed but the sole presence of this test to ensure that
    the condition is not changed in the future. If we remove one of the fields for
    some reason, this test will tell us that it is missing and not complying with
    the UI design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following with our list of requirements, we should test that the `Views` are
    aligned in the layout as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We continue using asserts from `ViewAssert`—in this case, `assertLeftAligned`
    and `assertRightAligned`. These methods verify the alignment of the specified
    `Views`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LinearLayout` we are using by default arranges the fields in the way we
    are expecting them. Again, while we don't need to add anything to the layout,
    to satisfy the test, this will act as a guard condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve verified that they are correctly aligned, we should verify that
    they are covering the whole screen width as specified by the schematic drawing.
    In this example, it''s sufficient to verify the `LayoutParams` having the correct
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We used a custom message to easily identify the problem in case the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this test, we obtain the following message indicating that the test
    failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**junit.framework.AssertionFailedError: mCelsius layout width is not MATCH_PARENT
    expected:<-1> but was:<-2>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to the layout definition. We must change `layout_width` to be
    `match_parent` for Celsius and Fahrenheit fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Same for Fahrenheit—after the change is done, we repeat the cycle and by running
    the test again, we can verify that it is now successful.
  prefs: []
  type: TYPE_NORMAL
- en: Our method is starting to appear. We create the test to verify a condition described
    in the requirements. If it's not met, we change the cause of the problem and running
    the tests again we verify that the latest change solves the problem, and what
    is perhaps more important is that the change doesn't break the exiting code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s verify that font sizes are as defined in our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the font size used by the field is enough in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The default font size is not `24px`, so we need to add this to our layout. It's
    a good practice to add the corresponding dimension to a resource file and then
    use it where it's needed in the layout. So, let's add `label_text_size` to `res/values/dimens.xml`
    with a value of `24px`. Then reference it in the `Text size` property of both
    labels, `celsius_label` and `fahrenheit_label`.
  prefs: []
  type: TYPE_NORMAL
- en: Now the test is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s verify that margins are interpreted as described in the user
    interface design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a similar case as before. We need to add this to our layout. Let's add
    the margin dimension to the resource file and then use it where it's needed in
    the layout. Set the `margin` dimension in `res/values/dimens.xml` to a value of
    `6px`. Then reference it in the `Margin` property of both fields, `celsius` and
    `fahrenheit`, and in the `Left margin` of the labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing that is left is the verification of the justification of the
    entered values. We will validate input shortly to allow only the permitted values
    but for now let''s just pay attention to the justification. The intention is to
    have values that are smaller than the whole field justified to the right and vertically
    centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we verify the gravity values as usual. However, we are using a custom message
    to help us identify the values that could be wrong. As `Gravity` class defines
    several constants whose values are better identified if expressed in hexadecimal,
    we are converting the values to this base in the message.
  prefs: []
  type: TYPE_NORMAL
- en: If this test is failing due to the default gravity used for the fields, then
    what is only left is to change it. Go to the layout definition and alter these
    gravity values so that the test succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is precisely what we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now want to verify that the requirement specifying that enough screen space
    should be reserved to display the keyboard is actually fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This verifies that the actual position of the last field in the screen, which
    is `mFahrenheit`, is not lower than a suggested value.
  prefs: []
  type: TYPE_NORMAL
- en: We can run the tests again verifying that everything is green again.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface is in place. Now we start adding some basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality will include the code to handle the actual temperature conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Temperature conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the list of requirements we can obtain this statement: When one temperature
    is entered in one field the other one is automatically updated with the conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following our plan we must implement this as a test to verify that the correct
    functionality is there. Our test would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, as we already know, to interact with the UI changing its values we
    should run the test on the UI thread and thus is annotated with `@UiThreadTest`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we are using a specialized class to replace `EditText` providing some
    convenience methods like `clear()` or `setNumber()`. This would improve our application
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we invoke a converter, named `TemperatureConverter`, a utility class providing
    the different methods to convert between different temperature units and using
    different types for the temperature values.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we will be truncating the results to provide them in a suitable
    format presented in the user interface we should compare against a delta to assert
    the value of the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test as it is will force us to follow the planned path. Our first
    objective is to add the needed code to get the test to compile and then to satisfy
    the test's needs.
  prefs: []
  type: TYPE_NORMAL
- en: The EditNumber class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our main project, not in the tests one, we should create the class `EditNumber`
    extending `EditText` as we need to extend its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We use Eclipse's help to create this class using **File | New | Class** or its
    shortcut in the Toolbars.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screenshot shows the window that appears after using this shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber class](img/3500_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table describes the most important fields and their meaning in
    the previous screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Source folder:** | The source folder for the newly-created class. In this
    case the default location is fine. |'
  prefs: []
  type: TYPE_TB
- en: '| **Package:** | The package where the new class is created. In this case the
    default package `com.example.aatg.tc` is fine too. |'
  prefs: []
  type: TYPE_TB
- en: '| **Name:** | The name of the class. In this case we use `EditNumber`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Modifiers:** | Modifiers for the class. In this particular case we are
    creating a public class. |'
  prefs: []
  type: TYPE_TB
- en: '| **Superclass:** | The superclass for the newly-created type. We are creating
    a custom `View` and extending the behavior of `EditText`, so this is precisely
    the class we select for the supertype.Remember to use **Browse..**. to find the
    correct package. |'
  prefs: []
  type: TYPE_TB
- en: '| **Which method stubs would you like to create?** | These are the method stubs
    we want Eclipse to create for us. Selecting **Constructors from superclass** and
    **Inherited abstract methods** would be of great help.As we are creating a custom
    View we should provide the constructors that are used in different situations,
    for example when the custom View is used inside an XML layout. |'
  prefs: []
  type: TYPE_TB
- en: '| **Do you want to add comments?** | Some comments are added automatically
    when this option is selected. You can configure Eclipse to personalize these comments.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Once the class is created we need to change the type of the fields first in
    our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then change any cast that is present in the tests. Eclipse will help you do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, there are still two problems we need to fix before
    being able to compile the test:'
  prefs: []
  type: TYPE_NORMAL
- en: We still don't have the methods `clear()` and `setNumber()` in `EditNumber`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have the `TemperatureConverter` utility class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create the methods we are using Eclipse's helpful actions. Let's choose **Create
    method clear() in type EditNumber**.
  prefs: []
  type: TYPE_NORMAL
- en: Same for `setNumber()` and `getNumber().`
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must create the `TemperatureConverter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to create it in the main project and not in the test project.
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber class](img/3500_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having done this, in our test select **Create method fahrenheitToCelsius in
    type TemperatureConverter**.
  prefs: []
  type: TYPE_NORMAL
- en: This fixes our last problem and leads us to a test that we can now compile and
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surprisingly, or not, when we run the tests, they will fail with an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): java.lang.ClassCastException: android.widget.EditText**'
  prefs: []
  type: TYPE_NORMAL
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): at com.example.aatg.tc.test.TemperatureConverterActivityTests.setUp(TemperatureConverterActivityTests.java:41)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): at junit.framework.TestCase.runBare(TestCase.java:125)**'
  prefs: []
  type: TYPE_NORMAL
- en: That is because we updated all of our Java files to include our newly-created
    `EditNumber` class but forgot to change the XMLs, and this could only be detected
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to update our UI definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That is, we replace the original `EditText` by `com.example.aatg.tc.EditNumber`
    which is a `View` extending the original `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we run the tests again and we discover that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute, we haven't implemented any conversion or any handling of
    values in the new `EditNumber` class and all tests passed with no problem. Yes,
    they passed because we don't have enough restrictions in our system and the ones
    in place simply cancel themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Before going further, let's analyze what just happened. Our test invoked the
    `mFahrenheit.setNumber(f)` method to set the temperature entered in the **Fahrenheit**
    field, but `setNumber()` is not implemented and it is an empty method as generated
    by Eclipse and does nothing at all. So the field remains empty.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the value for `expectedC`—the expected temperature in Celsius is calculated
    invoking `TemperatureConverter.fahrenheitToCelsius(f)`, but this is also an empty
    method as generated by Eclipse. In this case, because Eclipse knows about the
    return type it returns a constant 0\. So `expectedC` becomes 0.
  prefs: []
  type: TYPE_NORMAL
- en: Then the actual value for the conversion is obtained from the UI. In this case
    invoking `getNumber()` from `EditNumber`. But once again this method was automatically
    generated by Eclipse and to satisfy the restriction imposed by its signature,
    it must return a value that Eclipse fills with 0.
  prefs: []
  type: TYPE_NORMAL
- en: The delta value is again 0, as calculated by `Math.abs(expectedC actualC)`.
  prefs: []
  type: TYPE_NORMAL
- en: And finally our assertion `assertTrue(msg, delta < 0.005)` is true because `delta=0`
    satisfies the condition, and the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: So, is our methodology flawed as it cannot detect a simple situation like this?
  prefs: []
  type: TYPE_NORMAL
- en: No, not at all. The problem here is that we don't have enough restrictions and
    they are satisfied by the default values used by Eclipse to complete auto-generated
    methods. One alternative could be to throw exceptions at all of the auto-generated
    methods, something like `RuntimeException("not yet implemented")` to detect its
    use when not implemented. But we will be adding enough restrictions in our system
    to easily trap this condition.
  prefs: []
  type: TYPE_NORMAL
- en: TemperatureConverter unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems, from our previous experience, that the default conversion implemented
    by Eclipse always returns 0, so we need something more robust. Otherwise this
    will be only returning a valid result when the parameter takes the value of 32F.
  prefs: []
  type: TYPE_NORMAL
- en: The `TemperatureConverter` is a utility class not related with the Android infrastructure,
    so a standard unit test will be enough to test it.
  prefs: []
  type: TYPE_NORMAL
- en: We create our tests using Eclipse's **File | New | JUnit Test Case**, filling
    in some appropriate values, and selecting the method to generate a test as shown
    in the next screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we create the unit test by extending `junit.framework.TestCase` and
    selecting `com.example.aatg.tc.TemperatureConverter` as the class under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TemperatureConverter unit tests](img/3500_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then by pressing the **Next >** button we can obtain the list of methods we
    may want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TemperatureConverter unit tests](img/3500_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have implemented only one method in `TemperatureConverter`, so it's the only
    one appearing in the list. Other classes implementing more methods will display
    all the options here.
  prefs: []
  type: TYPE_NORMAL
- en: It's good to note that even if the test method is auto-generated by Eclipse
    it won't pass. It will fail with the message *Not yet implemented* to remind us
    that something is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by changing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating a conversion table with values for different temperature conversion
    we know from other sources would be a good way to drive this test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We may just run this test to verify that it fails, giving us this trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '**junit.framework.AssertionFailedError: -40.0F -> -40.0C but is 0.0 (delta
    40.0)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at com.example.aatg.tc.test.TemperatureConverterTests.testFahrenheitToCelsius(TemperatureConverterTests.java:62)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at java.lang.reflect.Method.invokeNative(Native Method)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:520)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this was something we were expecting as our conversion always returns
    0\. Implementing our conversion, we discover that we need some `ABSOLUTE_ZERO_F`
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Absolute zero is the theoretical temperature at which entropy would reach its
    minimum value. To be able to reach this absolute zero state, according to the
    laws of thermodynamics, the system should be isolated from the rest of the universe.
    Thus it is an unreachable state. However, by international agreement, absolute
    zero is defined as 0K on the Kelvin scale and as -273.15°C on the Celsius scale
    or to -459.67°F on the Fahrenheit scale.
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a custom exception, `InvalidTemperatureException`, to indicate
    a failure providing a valid temperature to the conversion method. This exception
    is created simply by extending `RuntimeException:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running the tests again we now discover that `testFahrenheitToCelsiusConversion`
    test fails, however `testFahrenheitToCelsius` succeeds. This tells us that now
    conversions are correctly handled by the converter class but there are still some
    problems with the UI handling this conversion.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the failure trace reveals that there's something still returning
    0 when it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: This reminds us that we are still lacking a proper `EditNumber` implementation.
    Before proceeding to implement the mentioned methods, let's create the corresponding
    tests to verify what we are implementing is correct.
  prefs: []
  type: TYPE_NORMAL
- en: The EditNumber tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the previous chapter, we can now determine that the best base class for
    our custom `View` tests is `AndroidTestCase`, as we need a mock `Context` to create
    the custom `View` but we don't need system infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the dialog we have to complete to create the tests. In this case using
    `android.test.AndroidTestCase` as the base class and `com.example.aatg.tc.EditNumber`
    as the class under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber tests](img/3500_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing **Next >**, we select the methods for which stubs are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber tests](img/3500_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to update the auto-generated constructor to reflect the pattern we
    identified before, the given name pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the fixture. In this case this is a simple `EditNumber`
    which we will be testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The mock context is obtained from the protected field mContext ([http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext))
    available in the `AndroidTestCase` class.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the test we set `mEditNumber` as a focusable `View`, that is it
    will be able to gain focus, as it will be participating in a bunch of tests simulating
    UIs that may need to request its focus explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test that the required `clear()` functionality is implemented correctly
    in the `testClear()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test we verify that it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '**junit.framework.ComparisonFailure: expected:<> but was:<123.45>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at com.example.aatg.tc.test.EditNumberTests.testClear(EditNumberTests.java:62)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:529)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement `EditNumber.clear()` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple case, so just by adding this implementation to `EditNumber`
    we satisfy the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test and proceed. Now let''s complete the `testSetNumber()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Which fails unless we implement `EditNumber.setNumber()`, similar to this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are using a constant, `DEFAULT_FORMAT`, to hold the desired format to convert
    the numbers. This can be later converted to a property that could also be specified
    in the `xml` layout definition of the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the `testGetNumber()` and `getNumber()` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprisingly these tests succeed. But now there''s a test that was passing
    that started to fail: `testFahrenheitToCelsiusConversion()`. The reason is that
    now that we have implemented `EditNumber.setNumber()` and `EditNumber.getNumber()`
    correctly, some values are returned differently and this test method was relying
    on spurious values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a screenshot of the results obtained after running the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The EditNumber tests](img/3500_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you closely analyze the case, you can discover where the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Got it ?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test method is expecting the conversion to be realized automatically when
    the focus changes, as was specified in our list of requirements: when one temperature
    is entered in one field the other one is automatically updated with the conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we don't have buttons or anything else to convert temperature values,
    so the conversion is expected to be done automatically once the values are entered.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us again to the `TemperatureConverterActivity` and the way it handles
    the conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The TemperatureChangeWatcher class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of implementing the required behavior of constantly updating the other
    temperature value once one has changed is through a `TextWatcher`. From the documentation
    we can understand that a `TextWatcher` is an object of a type that is attached
    to an `Editable`; its methods will be called when the text is changed ([http://developer.android.com/intl/de/reference/android/text/TextWatcher.html](http://developer.android.com/intl/de/reference/android/text/TextWatcher.html)).
  prefs: []
  type: TYPE_NORMAL
- en: It seems that is what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement this class as an inner class of `TemperatureConverterActivity`.
    This is the screenshot of the New Java Class in Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TemperatureChangeWatcher class](img/3500_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And this is our code after some additions to the recently created class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We implement extending `TextWatcher` and overriding the unimplemented methods.
  prefs: []
  type: TYPE_NORMAL
- en: Because we will be using the same `TemperatureChangeWatcher` implementation
    for both fields, Celsius and Fahrenheit, we keep a reference to the fields used
    as source and destination as well as the operation needed to update their values.
    To specify this operation we are introducing an `enum` to the `TemperatureConverter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This operation is specified in the constructor and the destination and source
    `EditNumber` are selected accordingly. This way we can use the same watcher for
    different conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The method of the `TextWatcher` interface we are mainly interested in is `onTextChanged`,
    that will be called any time the text changes. At the beginning we avoid potential
    loops, checking who has focus and returning if the conditions are not met.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the destination field as an empty `String` if the source is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we try to set the resulting value of invoking the corresponding conversion
    method to set the destination field. We flag the error as necessary, avoiding
    showing premature errors when the conversion was invoked with a partially entered
    number.
  prefs: []
  type: TYPE_NORMAL
- en: We need to set the listener on the fields in `TemperatureConverterActivity.onCreate():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To be able to run the tests we should compile them. To compile we need at least
    to define the `celsiusToFahrenheit`, which is not yet defined.
  prefs: []
  type: TYPE_NORMAL
- en: More TemperatureConverter tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to implement `celsiusToFahrenheit` and as usual we start from the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fairly equivalent to the other conversion method `fahrenheitToCelsius`
    and we can use the infrastructure we devised while creating this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We use the conversion table to exercise the method through different conversions
    and we verify that the error is less than a predefined delta.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the correspondent conversion implementation in `TemperatureConverter`
    class is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now all the tests are passing but we are still not testing all the common conditions.
    You should check if errors and exceptions are correctly generated, besides all
    the normal cases we created so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the test we create to check the correct generation of exceptions when
    a temperature below absolute zero is used in a conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test we decrement the absolute zero temperature to obtain an even smaller
    value and then we attempt the conversion. We check for the correct exception being
    caught and finally we assert this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In a similar manner we test for the exception being thrown when the attempted
    conversion involves a temperature in Celsius which is lower than the absolute
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: The InputFilter tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to filter the input that is received by the conversion utility so no
    garbage reaches this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EditNumber` class already filters valid input and generates exceptions
    otherwise. We can verify this condition by generating some new tests in `TemperatureConverterActivityTests`.
    We choose this class because we are sending keys to the entry fields, just as
    a real user would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This test requests the focus to the Celsius field using the pattern we have
    reviewed before to run parts of a test in the UI thread, and then send some keys.
    The keys sent are an invalid sequence containing more than one period, which is
    not accepted for a well formed decimal number. It is expected that when the filter
    is in place, this sequence will be filtered and only the valid characters reach
    the field. We use the possibly generated `NumberFormatException` to detect the
    error and then we assert that the value returned by `mCelsius.getNumber()` is
    what we are expecting after filtering.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this filter, we need to add an `InputFilter` to `EditNumber`. Because
    this should be added to all of the constructors we create an additional method
    `init()` which we invoke from them. To achieve our goal we use an instance of
    `DigitsKeyListener` accepting digits, signs, and decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This `init` method is factored and invoked from different constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests again we can verify that all have passed and now everything
    is green again.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing our final application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our final application which satisfies all the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot we are showing one of these requirements, which
    is the detection of an attempt to convert a temperature below the absolute zero
    temperature in Celsius (-1000.00C):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing our final application](img/3500_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UI respects the guidelines provided; the temperatures can be converted by
    entering them in the corresponding unit field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, this was the list of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The application converts temperatures from Celsius to Fahrenheit and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    and the other for Fahrenheit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one temperature is entered in one field the other one is automatically
    updated with the conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some space in the user interface should be reserved for the on-screen keyboard
    to ease the application operation when several conversions are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry fields should start empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values entered are decimal values with two digits after the point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are right aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what is perhaps more important is that we can assure that the application
    not only satisfies the requirements but also has no evident problems or bugs because
    we took every step by analyzing the test results and fixing the problems at their
    first appearance. This will ensure that the same bug, once discovered, will not
    resurface again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We presented Test Driven Development introducing its concepts and later on applying
    them step-by-step in a potential real-life problem.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a concise list of requirement describing the Temperature Converter
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented every test followed by the code that satisfies it. In this
    manner we implemented the application behavior as well as its presentation, conducting
    tests to verify that the UI we designed follows the specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Having the tests in place lead us to analyze the different possibilities we
    have in running them and the next chapter will focus on the Testing Environment.
  prefs: []
  type: TYPE_NORMAL
