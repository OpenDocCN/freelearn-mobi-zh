<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Debugging</h1></div></div></div><p>The debugging environment is one of the most important features of an IDE. Using a debugging tool allows you to easily optimize your application and improve its performance. Do you want to use a debug tool while programming in Android Studio? Android Studio includes <a class="indexterm" id="id359"/>the <strong>Dalvik Debug Monitor Server</strong> (<strong>DDMS</strong>) debugging tool.</p><p>In this chapter, you will start by learning about the <strong>run</strong> and <strong>debug</strong> options and how to emulate your application in one of the Android virtual devices you learned to create in a previous chapter. You will learn about the <strong>Debugger</strong>, <strong>Console</strong>, and <strong>LogCat</strong> tabs in depth. You will also learn how to use breakpoints when using the debugger. We will end this chapter with information about each tab available in the advanced debugger tool included in Android Studio DDMS and the Hierarchy View.</p><p>These are the topics we'll be covering in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Debugging</li><li class="listitem" style="list-style-type: disc">LogCat</li><li class="listitem" style="list-style-type: disc">Instant run</li><li class="listitem" style="list-style-type: disc">Device Monitor tools</li><li class="listitem" style="list-style-type: disc">Hierarchy View</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Running and debugging</h1></div></div></div><p>Android applications can be run from Android Studio in a real device using a USB connection <a class="indexterm" id="id360"/>or in a virtual device using the emulator. Virtual devices <a class="indexterm" id="id361"/>make it possible to test our applications on different types of hardware and software configurations. In this chapter, we will use the emulator to run and debug our application because of its simplicity and flexibility.</p><p>To run an application directly, navigate to <strong>Run</strong> | <strong>Run 'app'</strong>. You can also click on the play icon from the toolbar. To debug an application, navigate to <strong>Run</strong> | <strong>Debug 'app'</strong> or click on the bug icon from the toolbar. If your app is already running, you can start the debug mode by navigating to <strong>Run</strong> | <strong>Attach debugger to Android process</strong>.</p><p>When we select the <strong>Debug 'app'</strong> option, a dialog to choose the device is opened. The <strong>Connected Devices</strong> section is used to choose a running device; the current connected devices are listed, real or virtual. The <strong>Available Emulators</strong> section is used to launch a new instance of the<a class="indexterm" id="id362"/> emulator; the available virtual devices are listed. You can also <a class="indexterm" id="id363"/>create a new emulator from this dialog using the <strong>Create New Emulator</strong> button. This option will open the virtual device configuration dialog that was explained in <a class="link" href="ch06.html" title="Chapter 6. Tools">Chapter 6</a>, <em>Tools</em>. One last option in this dialog is the <strong>Use same selection for future launches</strong> checkbox. Check this if you want to skip this step in future.</p><p>Select the virtual device created in <a class="link" href="ch06.html" title="Chapter 6. Tools">Chapter 6</a>, <em>Tools</em>, from the <strong>Available Emulators</strong> section as shown in the following screenshot and click <strong>OK</strong>.</p><div><img alt="Running and debugging" src="img/B05459_08_01.jpg"/></div><p>The emulator will be launched. The next time we run or debug the application, the emulator will be running, so we will select it from the <strong>Connected Devices</strong> section.</p><p>While debugging, you will note that, at the bottom of Android Studio as shown in the next screenshot, there is a new panel, <strong>Debug</strong>, which contains two tabs: <strong>Debugger</strong> and <strong>Console</strong>. The <strong>Android Monitor</strong> tab contains two other tools: <strong>LogCat</strong> and <strong>Monitors</strong>.</p><div><img alt="Running and debugging" src="img/B05459_08_02.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec23"/>Console</h2></div></div></div><p>
<strong>Console</strong> displays<a class="indexterm" id="id364"/> the events that are taking place while the <a class="indexterm" id="id365"/>emulator is being launched or while it is running. Open it to examine the messages and check that the emulator and the application are being correctly executed. The actions that should appear are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Waiting for device</strong>: This is the starting point when the emulator is being launched.</li><li class="listitem" style="list-style-type: disc"><strong>Uploading file</strong> (the <code class="literal">adb push</code> command): This event states that the application is packed and stored in the device.</li><li class="listitem" style="list-style-type: disc"><strong>Installing</strong> (the <code class="literal">adb shell pm</code> install command): This event states that the application is being installed in the device. After the installation, a success message should be printed.</li><li class="listitem" style="list-style-type: disc"><strong>Launching application</strong> (the <code class="literal">adb shell am start</code> command): This event takes place when the application starts to execute.</li><li class="listitem" style="list-style-type: disc"><strong>Waiting for process</strong>: This event takes place when the application is running and the debug system tries to connect to the application process in the device.</li></ul></div><p>After the success of the previous steps, the application will be visible in the emulator. Test it by typing any name in the text input and clicking on the <strong>Accept</strong> button. The greeting message should change.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec24"/>Debugger</h2></div></div></div><p>
<strong>Debugger</strong> manages the breakpoints, controls the execution of the code, and shows information <a class="indexterm" id="id366"/>about the variables. To add a breakpoint <a class="indexterm" id="id367"/>in your code, just click on the left edge of a line of code. A red point will appear next to the line of code to indicate the breakpoint. To delete the breakpoint, click on it. If you right-click on a breakpoint, more options become available in a small dialog, in which you can click on the <strong>More to open the Breakpoints</strong> window, which is shown in the following screenshot:</p><div><img alt="Debugger" src="img/B05459_08_03.jpg"/></div><p>You can also open the <strong>Breakpoints</strong> window by navigating to <strong>Run</strong> | <strong>View Breakpoints...</strong>. In the left-side panel of the <strong>Breakpoints</strong> window, all the breakpoints of your app are listed. You can add new breakpoints, remove them, or enable and disable them. You can enable <strong>Exception Breakpoints</strong>, which will be triggered when an exception is thrown while your app is running. If you select one breakpoint from the left-side panel, you can configure it using the right-side panel. For example, you can set a condition for the breakpoint, log a message to console, or remove it once it is hit.</p><p>Add a breakpoint in the conditional statement of the <code class="literal">onAcceptClick</code> method of our main activity and debug the application again, as shown:</p><div><img alt="Debugger" src="img/B05459_08_04.jpg"/></div><p>Enter your <a class="indexterm" id="id368"/>name in the application and click on<a class="indexterm" id="id369"/> the <strong>Accept</strong> button. When the execution gets to the breakpoint, it pauses, and the <strong>Debugger</strong> tab is opened. Since we added the breakpoint in the conditional statement before assigning the text, our greeting message has not changed.</p><p>From the debugger tab, we can examine the method call hierarchy and the state of the variables at that point of execution. The available variables are the parameter of the <code class="literal">v</code> method, the <code class="literal">TextView</code> and <code class="literal">EditText</code> objects obtained by the <code class="literal">findViewById</code> method, and the reference to the current activity (<code class="literal">this</code>). Expand the <code class="literal">EditText</code> object named <code class="literal">etName</code>, as shown in the following screenshot, and search for the <code class="literal">mText</code> property. This property should contain the name you typed before:</p><div><img alt="Debugger" src="img/B05459_08_05.jpg"/></div><p>Right-click on the <code class="literal">EditText</code> object to open a menu with more options and select <strong>Evaluate Expression...</strong>. The <strong>Evaluate Expression</strong> dialog allows you to query methods in the context of the selected object. For example, type <code class="literal">etName.getText()</code> and press <em>Enter</em> to evaluate the expression. The result of the expression will be displayed like in the following screenshot:</p><div><img alt="Debugger" src="img/B05459_08_06.jpg"/></div><p>When the<a class="indexterm" id="id370"/> execution of your app is stopped in a<a class="indexterm" id="id371"/> breakpoint, you can do the following actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To execute the next line of code without stepping into the method call, you can navigate to <strong>Run</strong> | <strong>Step Over</strong>, click on the button in the top toolbar of the <strong>Debug</strong> panel, or press the keyboard shortcut indicated for this option, usually the <em>F8</em> key.</li><li class="listitem" style="list-style-type: disc">To step into the method call, you can navigate to <strong>Run</strong> | <strong>Step Into</strong>, click on the button in the top toolbar of the <strong>Debug</strong> panel, or press <em>F7</em>.</li><li class="listitem" style="list-style-type: disc">To choose the method you want to step into, navigate to <strong>Run</strong> | <strong>Smart Step Into</strong> or press <em>Shift</em> +<em>F7</em>.</li><li class="listitem" style="list-style-type: disc">To step to the cursor position in your code, you can navigate to <strong>Run</strong> | <strong>Run to Cursor</strong>, click on the button in the top toolbar of the <strong>Debug</strong> panel, or press <em>Alt</em> + <em>F9</em>.</li><li class="listitem" style="list-style-type: disc">To resume the execution until the next breakpoint, you can navigate to <strong>Run</strong> | <strong>Resume Program</strong>, click on the button in the left-side toolbar of the <strong>Debug</strong> panel, or press <em>F9</em>.</li><li class="listitem" style="list-style-type: disc">To stop the execution, you can navigate to <strong>Run</strong> | <strong>Stop</strong>, click on the button in left-side toolbar of the <strong>Debug</strong> panel, or press <em>Ctrl</em> + <em>F2</em> (<em>Cmd</em> + <em>F2</em> on OS X).</li></ul></div><p>These options, among others, are also available from the debugger tab as icon shortcuts.</p><p>Expand the <code class="literal">tvGreeting</code> object to check the value of its <code class="literal">mText</code> property. Now, step over the conditional statement and the call of the <code class="literal">setText</code> method. Note how the value of the <code class="literal">mText</code> property has changed, which is shown in the next screenshot. Finally, resume the execution so the greeting message changes in the device screen.</p><div><img alt="Debugger" src="img/B05459_08_07.jpg"/></div><p>Create a new<a class="indexterm" id="id372"/> breakpoint inside the <code class="literal">if</code> clause. We can <a class="indexterm" id="id373"/>add a condition to the endpoint so the execution is only paused when the name typed by the user is <code class="literal">"no name"</code>, otherwise, the execution will continue as usual. The following screenshot of the <strong>Breakpoints</strong> window shows the breakpoint details:</p><div><img alt="Debugger" src="img/B05459_08_08.jpg"/></div><p>In the <strong>Condition</strong> field of the breakpoint, add the following condition that compares the text typed by the user in the name field (<code class="literal">etName</code>):</p><div><pre class="programlisting">etName.getText().toString().equals("no name")</pre></div><p>Now, if you <a class="indexterm" id="id374"/>write your name in the app, no breakpoint <a class="indexterm" id="id375"/>will suspend the execution. If you type <code class="literal">"no name"</code>, execution will be suspended at the recently created breakpoint.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec25"/>LogCat</h2></div></div></div><p>
<strong>LogCat</strong> is the<a class="indexterm" id="id376"/> Android logging system that displays all the log <a class="indexterm" id="id377"/>messages generated by the Android system in the running device. Log messages have several levels of significance. From the <strong>LogCat</strong> tab, we can filter the log messages by these levels. For example, if we select the information level as the filter, the messages from <strong>information</strong>, <strong>warning</strong>, and <strong>error</strong> levels will be displayed. The levels are shown in the following diagram:</p><div><img alt="LogCat" src="img/B05459_08_09.jpg"/></div><p>To print log messages from our code, we need to import the <code class="literal">Log</code> class. This class has a method for each level: the <code class="literal">v</code> method for verbose, the <code class="literal">d</code> method for debug, the <code class="literal">i</code> method for information, the <code class="literal">w</code> method for warning, and the <code class="literal">e</code> method for the error level. These methods receive two string parameters. The first string parameter usually identifies the source class of the message and the second string parameter identifies the message itself. To identify the source class, we recommend using a constant, static string tag. However, in the next example, we directly use the string to simplify the code. Add the following log messages to the <code class="literal">onAcceptClick</code> method of our main activity:</p><div><pre class="programlisting">if(etName.getText().length() &gt; 0) {
  <strong>Log.i("MainActivity", "Name read: " + etName.getText());</strong>
  tvGreeting.setText("Hello " + etName.getText());
} 
else {
  <strong>Log.w("MainActivity", "No name typed, greeting didn't change");</strong>
}</pre></div><p>We have a log<a class="indexterm" id="id378"/> message to inform us about the name obtained from the <a class="indexterm" id="id379"/>user input and a log message to print a warning if the user did not type a name. Remove any breakpoint we previously created and then debug the application.</p><p>The <strong>LogCat</strong> tab in the <strong>Android Monitor</strong> has by default printed the log messages generated by the current application. Reading the messages of your application can sometimes be complex and you need to filter the messages. In the <strong>LogCat</strong> tab, there is an expandable list where you can filter the log messages by their level of significance. You can also use the search field to look for certain log messages. There is another expandable list to configure some extra filters: the <strong>No Filters</strong> option displays all the logs generated by the device; the <strong>Show only selected application</strong> option displays the logs generated only by your app; and the <strong>Edit Filter Configuration</strong> option allows you to create a more complex filter. Select <strong>Edit Filter Configuration</strong> to examine this option. A dialog to create filters is opened as shown in the next screenshot:</p><div><img alt="LogCat" src="img/B05459_08_10.jpg"/></div><p>Log messages can be filtered using regular expressions by their <strong>Log Tag</strong>, their <strong>Log Message</strong>, or by the name of the package that printed them. Logs can also be filtered by the <a class="indexterm" id="id380"/>
<strong>process ID</strong> (<strong>PID</strong>) or by their level.</p><p>Create a new filter named <code class="literal">MyApplication</code>, filter it by <strong>Package Name</strong> writing <code class="literal">com.example.myapplication</code> (our application package name), and click on <strong>OK</strong>. Now, the <strong>LogCat</strong> log has <a class="indexterm" id="id381"/>been filtered and it is easier to read our <a class="indexterm" id="id382"/>messages. Now, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Focus on the <strong>Emulator</strong> window, enter a name in the application, and click on <strong>Accept</strong>. Observe how our log message is printed in the <strong>LogCat</strong> view.</li><li class="listitem">Delete your name from the application and click on <strong>Accept</strong>. This time, a warning message is printed. Notice the different colors used for each type of message.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec26"/>Monitors</h2></div></div></div><p>The <strong>Monitors</strong> panel<a class="indexterm" id="id383"/> is available at the bottom-right corner of<a class="indexterm" id="id384"/> Android Studio. Select the device or emulator running your application, and select the process corresponding to your application from the two top expandable lists. There are four monitors available:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Memory</strong>: This <a class="indexterm" id="id385"/>shows the free and allocated memory of the selected application over time, as shown in the following screenshot:<div><img alt="Monitors" src="img/B05459_08_11.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><strong>CPU</strong>: This <a class="indexterm" id="id386"/>shows the CPU usage in real time of your app, as shown in the following screenshot:<div><img alt="Monitors" src="img/B05459_08_12.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><strong>Network</strong>: This<a class="indexterm" id="id387"/> shows the network usage of your app, as shown in the following screenshot:<div><img alt="Monitors" src="img/B05459_08_13.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><strong>GPU</strong>: This<a class="indexterm" id="id388"/> shows the GPU usage<a class="indexterm" id="id389"/> of your app, indicating the time to execute, process, prepare, and draw the frames, as shown in the following screenshot:<div><img alt="Monitors" src="img/B05459_08_14.jpg"/></div></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Instant run</h1></div></div></div><p>Instant run is <a class="indexterm" id="id390"/>a new feature introduced in Android Studio 2.0 that allows you to update your app while it is running on a device without building a new APK. This feature reduces deployment time.</p><p>Instant run requires SDK 15 or higher, though it's recommended to use SDK 21 or higher. You will also need to have your Android Plugin for Gradle updated to version 2.0 or higher. Instant run works for both the emulator and a real device.</p><p>After the first deployment of your app, you will note that the run/debug icon has changed and has an additional thunderbolt icon, such as the debug icon in the following screenshot:</p><div><img alt="Instant run" src="img/B05459_08_15.jpg"/></div><p>The next time you click on the <strong>Debug</strong> button, Android Studio will analyze the changes in your code to make the deployment of your app faster, instead of creating a new APK and doing a full<a class="indexterm" id="id391"/> deployment. There are three types of updates depending on the code that needs to be pushed to the app:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Hot swap</strong>: This is <a class="indexterm" id="id392"/>the fastest swap. This type of swap is done if you<a class="indexterm" id="id393"/> change the code of an existing method. Android Studio will create a stub method with the new code and restart the current activity.<p>If you do not want Android Studio to restart the current activity after a hot swap, you can disable this behavior in the settings screen. Instant run settings are in the <strong>Build, Execution, Deployment</strong> section of the main settings. The following screenshot shows the instant run settings screen:</p><div><img alt="Instant run" src="img/B05459_08_16.jpg"/></div><p>You can disable the restart of the activity by disabling the <strong>Restart activity on code changes</strong> option.</p></li><li class="listitem" style="list-style-type: disc"><strong>Warm swap</strong>: This <a class="indexterm" id="id394"/>type of swap is done if you change or <a class="indexterm" id="id395"/>remove an existing resource. Android Studio will always restart the current activity and you can't disable this behavior.</li><li class="listitem" style="list-style-type: disc"><strong>Cold swap</strong>: This is<a class="indexterm" id="id396"/> the slowest swap and it requires API 21 <a class="indexterm" id="id397"/>or higher. If the device runs an API lower than 21, Android Studio will create a new APK and perform a full deployment. This type of swap is done if changes in the code are structural, such as changing the parent class, the implemented interfaces, a field, or a method signature. Android Studio will restart your app in a cold swap.</li></ul></div><p>Android Studio will deploy a new build if you change the app manifest or anything that affects the app manifest, such as a resource referenced in the manifest.</p><p>Change some code in <a class="indexterm" id="id398"/>your app, for example, change the <code class="literal">Hello</code> text message to a <code class="literal">Goodbye</code> message:</p><div><pre class="programlisting">tvGreeting.setText("Goodbye " + etName.getText());</pre></div><p>Click on the <strong>Debug</strong> button with the thunderbolt. Since you changed the code in a method, Android Studio will do a hot swap. You will notice a flicker while the current activity restarts.</p><p>When the hot swap is finished, a message is displayed in the bottom part of Android Studio, as you can see in the next screenshot:</p><div><img alt="Instant run" src="img/B05459_08_17.jpg"/></div><p>As you can read in the message, the code changes were applied and the current activity was restarted. Type a name and click on <code class="literal">ACCEPT</code>. The text message is the <code class="literal">Goodbye</code> one:</p><div><img alt="Instant run" src="img/B05459_08_18.jpg"/></div><p>Disable the <strong>Restart activity on code changes</strong> option from the settings to observe the differences. Change the code back to the <code class="literal">Hello</code> text message and debug the app. There is no flicker now and, when the hot swap is finished, the message displayed in Android Studio is now different:</p><div><img alt="Instant run" src="img/B05459_08_19.jpg"/></div><p>When the hot <a class="indexterm" id="id399"/>swap is finished, a message is also displayed in the emulator, like in the following screenshot. In this case, the message shown is: <em>Applied code changes without activity restart</em>.</p><div><img alt="Instant run" src="img/B05459_08_20.jpg"/></div><p>Now change a resource, for example, change the hint of the <code class="literal">EditText</code> to the following one:</p><div><pre class="programlisting">android:hint="Please, enter your name"</pre></div><p>Click on the <strong>Debug</strong> button with the thunderbolt. Since you changed a resource, Android Studio will do a <a class="indexterm" id="id400"/>warm swap this time. You will notice that the current activity restarts again. The same message displays in the bottom part of Android Studio:</p><div><img alt="Instant run" src="img/B05459_08_21.jpg"/></div><p>If you want to <a class="indexterm" id="id401"/>disable instant run completely, you can do it from the settings screen by unmarking the <strong>Enable Instant Run to hot swap code/resource changes on deploy (default enabled)</strong> option.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Android Device Monitor</h1></div></div></div><p>The DDMS is<a class="indexterm" id="id402"/> a more advanced debugging tool available in the SDK. The DDMS can be accessed from Android Studio through the <strong>Android Device Monitor</strong> tool. This tool is able to monitor both a real device and the emulator.</p><p>To open the DDMS perspective, navigate to <strong>Tools</strong> | <strong>Android</strong> | <strong>Android Device Monitor</strong>. You can also click on the Android Device Monitor icon from the toolbar. A new window will be opened with the DDMS perspective.</p><p>In the left part of the window, the list of connected devices is shown. Currently, just our virtual device is listed. In the <strong>Devices</strong> section, the list of the processes running on each device is also presented. We should be able to locate our application in the processes of the device we launched before. From the toolbar of the <strong>Devices</strong> section, we can stop a process using the Stop sign icon. We can also take a screen capture of the virtual device by clicking on the Camera icon. Some of the other options will be explained later.</p><p>In the right part of the window, detailed information about the device is provided. This information is divided into seven tabs: <strong>Threads</strong>, <strong>Heap</strong>, <strong>Allocation Tracker</strong>, <strong>Network Statistics</strong>, <strong>File Explorer</strong>, <strong>Emulator Control</strong>, and <strong>System Information</strong>. <strong>LogCat</strong>, which has also been integrated in the DDMS perspective, is placed at the bottom part of the window.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec27"/>Threads</h2></div></div></div><p>The <strong>Threads</strong> tab<a class="indexterm" id="id403"/> displays the list of threads that belong to<a class="indexterm" id="id404"/> the selected process. Select our application process from the <strong>Devices</strong> section. The process is identified by the package name, in this case <code class="literal">com.example.myapplication</code>, click on the <strong>Update Threads</strong> icon button from the toolbar of the <strong>Devices</strong> section and the threads will be loaded in the content of the tab:</p><div><img alt="Threads" src="img/B05459_08_22.jpg"/></div><p>The first columns<a class="indexterm" id="id405"/> are the IDs of the threads. The <strong>Status</strong> column<a class="indexterm" id="id406"/> indicates the thread state, <strong>utime</strong> indicates the total time spent by the thread executing the user code, <strong>stime</strong> indicates the total time spent by the thread executing system code, and <strong>Name</strong> indicates the name of the thread. The threads that interest us are those that spend time executing our user code.</p><p>This <strong>Threads</strong> tool is useful if we create threads in our application apart from the main thread. We can check if they are being executed at a certain point of the application and whether their execution time is moderate or not.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec01"/>Method profiling</h3></div></div></div><p>Method profiling is <a class="indexterm" id="id407"/>a tool to measure the performance of <a class="indexterm" id="id408"/>methods execution in the selected process. The measured parameters are the number of calls and the CPU time spent while executing. There are the following two types of spent time:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Exclusive time</strong>: This is<a class="indexterm" id="id409"/> the time spent in the execution of a method.</li><li class="listitem" style="list-style-type: disc"><strong>Inclusive time</strong>: This is<a class="indexterm" id="id410"/> the total time spent on the execution of a method. This measure includes the time spent by any called methods inside the method. These called functions are known as its<a class="indexterm" id="id411"/> <strong>children methods</strong>.</li></ul></div><p>To collect the method profiling data, select our application process from the <strong>Devices</strong> section and click on the <strong>Start Method Profiling</strong> icon from the toolbar of the <strong>Devices</strong> section, next to the <strong>Update Threads</strong> icon. A dialog to select the profiling option that you prefer is displayed. <strong>Sample based profiling</strong> profiles with less runtime performance impact using a sampling frequency, which can be configured. Sample-based profiling is available in Android 4.4 and later. <strong>Trace based profiling</strong> profiles the entry and exit of all the methods.</p><p>Perform some actions in the application; for example, in our example application, type a name and click on the <strong>Accept</strong> button in order to execute the <code class="literal">onAcceptClick</code> method of the main activity. Stop<a class="indexterm" id="id412"/> the method profiling by clicking on <a class="indexterm" id="id413"/>the <strong>Stop Method Profiling</strong> icon button.</p><p>When the method profiling is stopped, a new tab with the resultant trace is opened in the DDMS perspective. On the top of this new tab, the method calls are represented in a time graph; each row belongs to a thread. On the bottom of the trace, the summary of the time spent in a method is represented in a table.</p><p>Order the methods by their name to search for our <code class="literal">onAcceptClick</code> method (<code class="literal">com.example.myapplication.MainActivity.onAcceptClick</code>). Click on it to expand the detailed information about its execution. Now, note the following facts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The children methods called inside the <code class="literal">onAcceptClick</code> method are listed. We can see the <code class="literal">EditText.getText</code> method, the <code class="literal">Activity.findViewById</code> method, and the <code class="literal">TextView.setText</code> method, which we indeed directly call inside the method, as shown in the next screenshot.</li><li class="listitem" style="list-style-type: disc">The number of calls is detailed in the <strong>Calls/Total</strong> column. For example, we can see that the <code class="literal">Activity.findViewById</code> method is called twice (<strong>2/2</strong> value)—one call to find the <code class="literal">TextView</code> object and a second call to find the <code class="literal">EditText</code> object.</li><li class="listitem" style="list-style-type: disc">The <strong>Exclusive time</strong> columns have no values for the parent or children methods due to their own definition of this type of measured time:<div><img alt="Method profiling" src="img/B05459_08_23.jpg"/></div></li></ul></div><p>Method profiling<a class="indexterm" id="id414"/> is very useful to detect methods that spend too much <a class="indexterm" id="id415"/>time on their execution and to subsequently optimize them. We can identify the most expensive methods to avoid unnecessary calls to them.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec28"/>Heap</h2></div></div></div><p>The <strong>Heap</strong> tab<a class="indexterm" id="id416"/> displays the heap memory usage information <a class="indexterm" id="id417"/>and the statistics of the selected process. Select the application process and click on the <strong>Update Heap</strong> icon button from the toolbar of the <strong>Devices</strong> section to enable it. The heap information is shown after a <strong>garbage collector</strong> (<strong>GC</strong>) execution. To force it, click on the <strong>Cause GC</strong> button or the garbage icon from the <a class="indexterm" id="id418"/>toolbar of the <strong>Devices</strong> section.</p><p>The first table displays the summary of the heap usage: the total size, the allocated space, the free space, and the number of allocated objects. The <strong>Stats</strong> table gives the following detail of the objects allocated in the heap by type: the number of objects (<strong>Count</strong> column), the total size of those objects (<strong>Total Size</strong> column), the size of the smallest (<strong>Smallest</strong> column) and largest objects (<strong>Largest</strong> column), the median size (<strong>Median</strong> column), and the average size (<strong>Average</strong> column). Select one of the types to load the bottom bar graph. </p><p>The graph shows the count of the objects of a type by size, in bytes. If we right-click on the graph, we can change its properties (title, colors, font, labels, and so on) and save it as an image in the PNG format:</p><div><img alt="Heap" src="img/B05459_08_24.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Allocation Tracker</h2></div></div></div><p>The <strong>Allocation Tracker</strong> tab<a class="indexterm" id="id419"/> displays the <a class="indexterm" id="id420"/>memory allocations of the selected process. Select the application process and click on the <strong>Start Tracking</strong> button to start tracking the memory information. Then, click on the <strong>Get Allocations</strong> button to get the list of allocated objects.</p><p>We can use the filter on the top of the tab to filter the objects allocated in our own classes. Type our package name <code class="literal">com.example.myapplication</code> in the filter. For each object, the table shows its allocation size (<strong>Allocation Size</strong>), the thread (<strong>Thread</strong>), the object or class (<strong>Allocated Class</strong>), and the method in which the object was allocated (<strong>Allocated in</strong>). Click on any object to see more information, for example, the line number that allocated it.</p><p>As you can see in the next screenshot, a <code class="literal">java.lang.StringBuilder</code> object was allocated in the <code class="literal">onAcceptClick</code> of the main activity. In the bottom part, you can check the details of its allocation:</p><div><img alt="Allocation Tracker" src="img/B05459_08_25.jpg"/></div><p>Finally, click on the <strong>Stop Tracking</strong> button.</p><p>The<a class="indexterm" id="id421"/> allocation tracker is very useful to <a class="indexterm" id="id422"/>examine the objects that are being allocated when doing certain interactions in our application, in order to improve memory usage.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec30"/>Network Statistics</h2></div></div></div><p>The <strong>Network Statistics</strong> tab<a class="indexterm" id="id423"/> displays how <a class="indexterm" id="id424"/>our application uses the network's resources. To get the network statistics of any application that uses the network, click on the <strong>Start</strong> button. The data transfers will begin to appear in the graph.</p><p>The network statistics are useful to optimize the network requests in our code and control the data transferred at a certain point of the execution.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec31"/>File Explorer</h2></div></div></div><p>The <strong>File Explorer</strong> tab<a class="indexterm" id="id425"/> exposes the whole filesystem<a class="indexterm" id="id426"/> of the device. We can examine the size, date, or permissions of each element. Navigate to <code class="literal">/data/app/</code> to search for our <code class="literal">com.example.myapplication.apk</code> application package file.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec32"/>Emulator Control</h2></div></div></div><p>The <strong>Emulator Control</strong> tab<a class="indexterm" id="id427"/> allows us to <a class="indexterm" id="id428"/>emulate some special states or activities in the virtual device. We can test our application in different environments and situations to check whether it behaves as expected. If our application has features that depend on the device's physical location, we can use mock locations. Some of these special states are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Telephony Status</strong>: This <a class="indexterm" id="id429"/>allows you to choose the voice and data status and its speed and latency</li><li class="listitem" style="list-style-type: disc"><strong>Telephony Actions</strong>: This <a class="indexterm" id="id430"/>is used to simulate an incoming call or SMS</li><li class="listitem" style="list-style-type: disc"><strong>Location Controls</strong>: This <a class="indexterm" id="id431"/>is used to set the geolocation of the device</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec33"/>System Information</h2></div></div></div><p>The <strong>System Information</strong> tab presents the frame render time, total CPU load, and total memory <a class="indexterm" id="id432"/>usage of the device as graphs. We can<a class="indexterm" id="id433"/> search for our application and easily compare it with the rest of the processes running on the device.</p><p>We can change the properties of the graphs such as colors, font, and title and we can save them as images in PNG format. To open these options, right-click on the graph elements.</p><p>Open the CPU load and save the graph while our application is running in the foreground. Then, close the application and update the CPU load by clicking on the <strong>Update from Device</strong> button. Note the difference between both graphs and the growth of the idle percentage, as shown in the following screenshot:</p><div><img alt="System Information" src="img/B05459_08_26.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Hierarchy View</h2></div></div></div><p>Android Device Monitor <a class="indexterm" id="id434"/>contains a second perspective <a class="indexterm" id="id435"/>apart from the DDMS—the <strong>Hierarchy View</strong>. On the top bar of the Android Device, you can change from one perspective to the other. The two options in the top bar are shown in the next screenshot:</p><div><img alt="Hierarchy View" src="img/B05459_08_27.jpg"/></div><p>Open the <strong>Hierarchy View</strong> perspective and select your app from the left-side list. In the left-side panel, click on the following icon (the <strong>Load the view hierarchy into the tree view</strong> action):</p><div><img alt="Hierarchy View" src="img/B05459_08_28.jpg"/></div><p>The view hierarchy is loaded as shown in the next screenshot:</p><div><img alt="Hierarchy View" src="img/B05459_08_29.jpg"/></div><p>There<a class="indexterm" id="id436"/> are three different panels:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Tree Overview</strong>: This <a class="indexterm" id="id437"/>panel shows the overview of the <a class="indexterm" id="id438"/>complete view hierarchy.</li><li class="listitem" style="list-style-type: disc"><strong>Tree View</strong>: This <a class="indexterm" id="id439"/>panel shows in detail a specific area of the view hierarchy. At the bottom of the hierarchy, we can find the <code class="literal">TextView</code> with the ID <code class="literal">textView_greeting</code>, the <code class="literal">EditText</code> with the ID <code class="literal">editText_name</code>, and the <code class="literal">Button</code> with the ID <code class="literal">button_accept</code>. The parent of all of them is the <code class="literal">RelativeLayout</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Layout View</strong>: This<a class="indexterm" id="id440"/> panel shows the layout view.</li></ul></div><p>If you select one of the view elements, you can see its details. The following screenshot shows the details of the <code class="literal">button_accept</code> button:</p><div><img alt="Hierarchy View" src="img/B05459_08_30.jpg"/></div><p>Open the <strong>View Properties</strong> tab from the left-side panel. You can check the properties of the button, such<a class="indexterm" id="id441"/> as the <code class="literal">mText</code> property, the <a class="indexterm" id="id442"/>value of which is <code class="literal">Accept</code>.</p><p>On the top of the <strong>Tree View</strong> panel, there are some actions like saving the tree view as a PNG image or capturing the window layers as a Photoshop file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>Now you know the different launch options for your application as well as how to use the console and the <strong>LogCat</strong> for debugging. We also saw how to debug an application and interpret the data provided by the DDMS in each of the tabs available.</p><p>In the next chapter, we will prepare our application for its release using Android Studio. First, you will learn about the necessary steps to prepare the application before building it in the release mode. You will also learn how applications are compressed in <code class="literal">APK</code> files and how to generate your own <code class="literal">APK</code> file. Finally, you will learn how to get your certificate as a developer and how to generate a signed <code class="literal">APK</code> file, making it ready for release.</p></div></body></html>