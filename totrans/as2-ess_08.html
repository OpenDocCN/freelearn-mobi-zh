<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Debugging</h1></div></div></div><p>The debugging environment is one of the most important features of an IDE. Using a debugging tool allows you to easily optimize your application and improve its performance. Do you want to use a debug tool while programming in Android Studio? Android Studio includes <a class="indexterm" id="id359"/>the <span class="strong"><strong>Dalvik Debug Monitor Server</strong></span> (<span class="strong"><strong>DDMS</strong></span>) debugging tool.</p><p>In this chapter, you will start by learning about the <span class="strong"><strong>run</strong></span> and <span class="strong"><strong>debug</strong></span> options and how to emulate your application in one of the Android virtual devices you learned to create in a previous chapter. You will learn about the <span class="strong"><strong>Debugger</strong></span>, <span class="strong"><strong>Console</strong></span>, and <span class="strong"><strong>LogCat</strong></span> tabs in depth. You will also learn how to use breakpoints when using the debugger. We will end this chapter with information about each tab available in the advanced debugger tool included in Android Studio DDMS and the Hierarchy View.</p><p>These are the topics we'll be covering in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Debugging</li><li class="listitem" style="list-style-type: disc">LogCat</li><li class="listitem" style="list-style-type: disc">Instant run</li><li class="listitem" style="list-style-type: disc">Device Monitor tools</li><li class="listitem" style="list-style-type: disc">Hierarchy View</li></ul></div><div class="section" title="Running and debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Running and debugging</h1></div></div></div><p>Android applications can be run from Android Studio in a real device using a USB connection <a class="indexterm" id="id360"/>or in a virtual device using the emulator. Virtual devices <a class="indexterm" id="id361"/>make it possible to test our applications on different types of hardware and software configurations. In this chapter, we will use the emulator to run and debug our application because of its simplicity and flexibility.</p><p>To run an application directly, navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run 'app'</strong></span>. You can also click on the play icon from the toolbar. To debug an application, navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Debug 'app'</strong></span> or click on the bug icon from the toolbar. If your app is already running, you can start the debug mode by navigating to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Attach debugger to Android process</strong></span>.</p><p>When we select the <span class="strong"><strong>Debug 'app'</strong></span> option, a dialog to choose the device is opened. The <span class="strong"><strong>Connected Devices</strong></span> section is used to choose a running device; the current connected devices are listed, real or virtual. The <span class="strong"><strong>Available Emulators</strong></span> section is used to launch a new instance of the<a class="indexterm" id="id362"/> emulator; the available virtual devices are listed. You can also <a class="indexterm" id="id363"/>create a new emulator from this dialog using the <span class="strong"><strong>Create New Emulator</strong></span> button. This option will open the virtual device configuration dialog that was explained in <a class="link" href="ch06.html" title="Chapter 6. Tools">Chapter 6</a>, <span class="emphasis"><em>Tools</em></span>. One last option in this dialog is the <span class="strong"><strong>Use same selection for future launches</strong></span> checkbox. Check this if you want to skip this step in future.</p><p>Select the virtual device created in <a class="link" href="ch06.html" title="Chapter 6. Tools">Chapter 6</a>, <span class="emphasis"><em>Tools</em></span>, from the <span class="strong"><strong>Available Emulators</strong></span> section as shown in the following screenshot and click <span class="strong"><strong>OK</strong></span>.</p><div class="mediaobject"><img alt="Running and debugging" src="graphics/B05459_08_01.jpg"/></div><p>The emulator will be launched. The next time we run or debug the application, the emulator will be running, so we will select it from the <span class="strong"><strong>Connected Devices</strong></span> section.</p><p>While debugging, you will note that, at the bottom of Android Studio as shown in the next screenshot, there is a new panel, <span class="strong"><strong>Debug</strong></span>, which contains two tabs: <span class="strong"><strong>Debugger</strong></span> and <span class="strong"><strong>Console</strong></span>. The <span class="strong"><strong>Android Monitor</strong></span> tab contains two other tools: <span class="strong"><strong>LogCat</strong></span> and <span class="strong"><strong>Monitors</strong></span>.</p><div class="mediaobject"><img alt="Running and debugging" src="graphics/B05459_08_02.jpg"/></div><div class="section" title="Console"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec23"/>Console</h2></div></div></div><p>
<span class="strong"><strong>Console</strong></span> displays<a class="indexterm" id="id364"/> the events that are taking place while the <a class="indexterm" id="id365"/>emulator is being launched or while it is running. Open it to examine the messages and check that the emulator and the application are being correctly executed. The actions that should appear are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Waiting for device</strong></span>: This is the starting point when the emulator is being launched.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Uploading file</strong></span> (the <code class="literal">adb push</code> command): This event states that the application is packed and stored in the device.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Installing</strong></span> (the <code class="literal">adb shell pm</code> install command): This event states that the application is being installed in the device. After the installation, a success message should be printed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Launching application</strong></span> (the <code class="literal">adb shell am start</code> command): This event takes place when the application starts to execute.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Waiting for process</strong></span>: This event takes place when the application is running and the debug system tries to connect to the application process in the device.</li></ul></div><p>After the success of the previous steps, the application will be visible in the emulator. Test it by typing any name in the text input and clicking on the <span class="strong"><strong>Accept</strong></span> button. The greeting message should change.</p></div><div class="section" title="Debugger"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec24"/>Debugger</h2></div></div></div><p>
<span class="strong"><strong>Debugger</strong></span> manages the breakpoints, controls the execution of the code, and shows information <a class="indexterm" id="id366"/>about the variables. To add a breakpoint <a class="indexterm" id="id367"/>in your code, just click on the left edge of a line of code. A red point will appear next to the line of code to indicate the breakpoint. To delete the breakpoint, click on it. If you right-click on a breakpoint, more options become available in a small dialog, in which you can click on the <span class="strong"><strong>More to open the Breakpoints</strong></span> window, which is shown in the following screenshot:</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_03.jpg"/></div><p>You can also open the <span class="strong"><strong>Breakpoints</strong></span> window by navigating to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>View Breakpoints...</strong></span>. In the left-side panel of the <span class="strong"><strong>Breakpoints</strong></span> window, all the breakpoints of your app are listed. You can add new breakpoints, remove them, or enable and disable them. You can enable <span class="strong"><strong>Exception Breakpoints</strong></span>, which will be triggered when an exception is thrown while your app is running. If you select one breakpoint from the left-side panel, you can configure it using the right-side panel. For example, you can set a condition for the breakpoint, log a message to console, or remove it once it is hit.</p><p>Add a breakpoint in the conditional statement of the <code class="literal">onAcceptClick</code> method of our main activity and debug the application again, as shown:</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_04.jpg"/></div><p>Enter your <a class="indexterm" id="id368"/>name in the application and click on<a class="indexterm" id="id369"/> the <span class="strong"><strong>Accept</strong></span> button. When the execution gets to the breakpoint, it pauses, and the <span class="strong"><strong>Debugger</strong></span> tab is opened. Since we added the breakpoint in the conditional statement before assigning the text, our greeting message has not changed.</p><p>From the debugger tab, we can examine the method call hierarchy and the state of the variables at that point of execution. The available variables are the parameter of the <code class="literal">v</code> method, the <code class="literal">TextView</code> and <code class="literal">EditText</code> objects obtained by the <code class="literal">findViewById</code> method, and the reference to the current activity (<code class="literal">this</code>). Expand the <code class="literal">EditText</code> object named <code class="literal">etName</code>, as shown in the following screenshot, and search for the <code class="literal">mText</code> property. This property should contain the name you typed before:</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_05.jpg"/></div><p>Right-click on the <code class="literal">EditText</code> object to open a menu with more options and select <span class="strong"><strong>Evaluate Expression...</strong></span>. The <span class="strong"><strong>Evaluate Expression</strong></span> dialog allows you to query methods in the context of the selected object. For example, type <code class="literal">etName.getText()</code> and press <span class="emphasis"><em>Enter</em></span> to evaluate the expression. The result of the expression will be displayed like in the following screenshot:</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_06.jpg"/></div><p>When the<a class="indexterm" id="id370"/> execution of your app is stopped in a<a class="indexterm" id="id371"/> breakpoint, you can do the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To execute the next line of code without stepping into the method call, you can navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Step Over</strong></span>, click on the button in the top toolbar of the <span class="strong"><strong>Debug</strong></span> panel, or press the keyboard shortcut indicated for this option, usually the <span class="emphasis"><em>F8</em></span> key.</li><li class="listitem" style="list-style-type: disc">To step into the method call, you can navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Step Into</strong></span>, click on the button in the top toolbar of the <span class="strong"><strong>Debug</strong></span> panel, or press <span class="emphasis"><em>F7</em></span>.</li><li class="listitem" style="list-style-type: disc">To choose the method you want to step into, navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Smart Step Into</strong></span> or press <span class="emphasis"><em>Shift</em></span> +<span class="emphasis"><em>F7</em></span>.</li><li class="listitem" style="list-style-type: disc">To step to the cursor position in your code, you can navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run to Cursor</strong></span>, click on the button in the top toolbar of the <span class="strong"><strong>Debug</strong></span> panel, or press <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>F9</em></span>.</li><li class="listitem" style="list-style-type: disc">To resume the execution until the next breakpoint, you can navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Resume Program</strong></span>, click on the button in the left-side toolbar of the <span class="strong"><strong>Debug</strong></span> panel, or press <span class="emphasis"><em>F9</em></span>.</li><li class="listitem" style="list-style-type: disc">To stop the execution, you can navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Stop</strong></span>, click on the button in left-side toolbar of the <span class="strong"><strong>Debug</strong></span> panel, or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F2</em></span> (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>F2</em></span> on OS X).</li></ul></div><p>These options, among others, are also available from the debugger tab as icon shortcuts.</p><p>Expand the <code class="literal">tvGreeting</code> object to check the value of its <code class="literal">mText</code> property. Now, step over the conditional statement and the call of the <code class="literal">setText</code> method. Note how the value of the <code class="literal">mText</code> property has changed, which is shown in the next screenshot. Finally, resume the execution so the greeting message changes in the device screen.</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_07.jpg"/></div><p>Create a new<a class="indexterm" id="id372"/> breakpoint inside the <code class="literal">if</code> clause. We can <a class="indexterm" id="id373"/>add a condition to the endpoint so the execution is only paused when the name typed by the user is <code class="literal">"no name"</code>, otherwise, the execution will continue as usual. The following screenshot of the <span class="strong"><strong>Breakpoints</strong></span> window shows the breakpoint details:</p><div class="mediaobject"><img alt="Debugger" src="graphics/B05459_08_08.jpg"/></div><p>In the <span class="strong"><strong>Condition</strong></span> field of the breakpoint, add the following condition that compares the text typed by the user in the name field (<code class="literal">etName</code>):</p><div class="informalexample"><pre class="programlisting">etName.getText().toString().equals("no name")</pre></div><p>Now, if you <a class="indexterm" id="id374"/>write your name in the app, no breakpoint <a class="indexterm" id="id375"/>will suspend the execution. If you type <code class="literal">"no name"</code>, execution will be suspended at the recently created breakpoint.</p></div><div class="section" title="LogCat"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec25"/>LogCat</h2></div></div></div><p>
<span class="strong"><strong>LogCat</strong></span> is the<a class="indexterm" id="id376"/> Android logging system that displays all the log <a class="indexterm" id="id377"/>messages generated by the Android system in the running device. Log messages have several levels of significance. From the <span class="strong"><strong>LogCat</strong></span> tab, we can filter the log messages by these levels. For example, if we select the information level as the filter, the messages from <span class="strong"><strong>information</strong></span>, <span class="strong"><strong>warning</strong></span>, and <span class="strong"><strong>error</strong></span> levels will be displayed. The levels are shown in the following diagram:</p><div class="mediaobject"><img alt="LogCat" src="graphics/B05459_08_09.jpg"/></div><p>To print log messages from our code, we need to import the <code class="literal">Log</code> class. This class has a method for each level: the <code class="literal">v</code> method for verbose, the <code class="literal">d</code> method for debug, the <code class="literal">i</code> method for information, the <code class="literal">w</code> method for warning, and the <code class="literal">e</code> method for the error level. These methods receive two string parameters. The first string parameter usually identifies the source class of the message and the second string parameter identifies the message itself. To identify the source class, we recommend using a constant, static string tag. However, in the next example, we directly use the string to simplify the code. Add the following log messages to the <code class="literal">onAcceptClick</code> method of our main activity:</p><div class="informalexample"><pre class="programlisting">if(etName.getText().length() &gt; 0) {
  <span class="strong"><strong>Log.i("MainActivity", "Name read: " + etName.getText());</strong></span>
  tvGreeting.setText("Hello " + etName.getText());
} 
else {
  <span class="strong"><strong>Log.w("MainActivity", "No name typed, greeting didn't change");</strong></span>
}</pre></div><p>We have a log<a class="indexterm" id="id378"/> message to inform us about the name obtained from the <a class="indexterm" id="id379"/>user input and a log message to print a warning if the user did not type a name. Remove any breakpoint we previously created and then debug the application.</p><p>The <span class="strong"><strong>LogCat</strong></span> tab in the <span class="strong"><strong>Android Monitor</strong></span> has by default printed the log messages generated by the current application. Reading the messages of your application can sometimes be complex and you need to filter the messages. In the <span class="strong"><strong>LogCat</strong></span> tab, there is an expandable list where you can filter the log messages by their level of significance. You can also use the search field to look for certain log messages. There is another expandable list to configure some extra filters: the <span class="strong"><strong>No Filters</strong></span> option displays all the logs generated by the device; the <span class="strong"><strong>Show only selected application</strong></span> option displays the logs generated only by your app; and the <span class="strong"><strong>Edit Filter Configuration</strong></span> option allows you to create a more complex filter. Select <span class="strong"><strong>Edit Filter Configuration</strong></span> to examine this option. A dialog to create filters is opened as shown in the next screenshot:</p><div class="mediaobject"><img alt="LogCat" src="graphics/B05459_08_10.jpg"/></div><p>Log messages can be filtered using regular expressions by their <span class="strong"><strong>Log Tag</strong></span>, their <span class="strong"><strong>Log Message</strong></span>, or by the name of the package that printed them. Logs can also be filtered by the <a class="indexterm" id="id380"/>
<span class="strong"><strong>process ID</strong></span> (<span class="strong"><strong>PID</strong></span>) or by their level.</p><p>Create a new filter named <code class="literal">MyApplication</code>, filter it by <span class="strong"><strong>Package Name</strong></span> writing <code class="literal">com.example.myapplication</code> (our application package name), and click on <span class="strong"><strong>OK</strong></span>. Now, the <span class="strong"><strong>LogCat</strong></span> log has <a class="indexterm" id="id381"/>been filtered and it is easier to read our <a class="indexterm" id="id382"/>messages. Now, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Focus on the <span class="strong"><strong>Emulator</strong></span> window, enter a name in the application, and click on <span class="strong"><strong>Accept</strong></span>. Observe how our log message is printed in the <span class="strong"><strong>LogCat</strong></span> view.</li><li class="listitem">Delete your name from the application and click on <span class="strong"><strong>Accept</strong></span>. This time, a warning message is printed. Notice the different colors used for each type of message.</li></ol></div></div><div class="section" title="Monitors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec26"/>Monitors</h2></div></div></div><p>The <span class="strong"><strong>Monitors</strong></span> panel<a class="indexterm" id="id383"/> is available at the bottom-right corner of<a class="indexterm" id="id384"/> Android Studio. Select the device or emulator running your application, and select the process corresponding to your application from the two top expandable lists. There are four monitors available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Memory</strong></span>: This <a class="indexterm" id="id385"/>shows the free and allocated memory of the selected application over time, as shown in the following screenshot:<div class="mediaobject"><img alt="Monitors" src="graphics/B05459_08_11.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CPU</strong></span>: This <a class="indexterm" id="id386"/>shows the CPU usage in real time of your app, as shown in the following screenshot:<div class="mediaobject"><img alt="Monitors" src="graphics/B05459_08_12.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Network</strong></span>: This<a class="indexterm" id="id387"/> shows the network usage of your app, as shown in the following screenshot:<div class="mediaobject"><img alt="Monitors" src="graphics/B05459_08_13.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>GPU</strong></span>: This<a class="indexterm" id="id388"/> shows the GPU usage<a class="indexterm" id="id389"/> of your app, indicating the time to execute, process, prepare, and draw the frames, as shown in the following screenshot:<div class="mediaobject"><img alt="Monitors" src="graphics/B05459_08_14.jpg"/></div></li></ul></div></div></div></div>
<div class="section" title="Instant run"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Instant run</h1></div></div></div><p>Instant run is <a class="indexterm" id="id390"/>a new feature introduced in Android Studio 2.0 that allows you to update your app while it is running on a device without building a new APK. This feature reduces deployment time.</p><p>Instant run requires SDK 15 or higher, though it's recommended to use SDK 21 or higher. You will also need to have your Android Plugin for Gradle updated to version 2.0 or higher. Instant run works for both the emulator and a real device.</p><p>After the first deployment of your app, you will note that the run/debug icon has changed and has an additional thunderbolt icon, such as the debug icon in the following screenshot:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_15.jpg"/></div><p>The next time you click on the <span class="strong"><strong>Debug</strong></span> button, Android Studio will analyze the changes in your code to make the deployment of your app faster, instead of creating a new APK and doing a full<a class="indexterm" id="id391"/> deployment. There are three types of updates depending on the code that needs to be pushed to the app:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hot swap</strong></span>: This is <a class="indexterm" id="id392"/>the fastest swap. This type of swap is done if you<a class="indexterm" id="id393"/> change the code of an existing method. Android Studio will create a stub method with the new code and restart the current activity.<p>If you do not want Android Studio to restart the current activity after a hot swap, you can disable this behavior in the settings screen. Instant run settings are in the <span class="strong"><strong>Build, Execution, Deployment</strong></span> section of the main settings. The following screenshot shows the instant run settings screen:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_16.jpg"/></div><p>You can disable the restart of the activity by disabling the <span class="strong"><strong>Restart activity on code changes</strong></span> option.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Warm swap</strong></span>: This <a class="indexterm" id="id394"/>type of swap is done if you change or <a class="indexterm" id="id395"/>remove an existing resource. Android Studio will always restart the current activity and you can't disable this behavior.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cold swap</strong></span>: This is<a class="indexterm" id="id396"/> the slowest swap and it requires API 21 <a class="indexterm" id="id397"/>or higher. If the device runs an API lower than 21, Android Studio will create a new APK and perform a full deployment. This type of swap is done if changes in the code are structural, such as changing the parent class, the implemented interfaces, a field, or a method signature. Android Studio will restart your app in a cold swap.</li></ul></div><p>Android Studio will deploy a new build if you change the app manifest or anything that affects the app manifest, such as a resource referenced in the manifest.</p><p>Change some code in <a class="indexterm" id="id398"/>your app, for example, change the <code class="literal">Hello</code> text message to a <code class="literal">Goodbye</code> message:</p><div class="informalexample"><pre class="programlisting">tvGreeting.setText("Goodbye " + etName.getText());</pre></div><p>Click on the <span class="strong"><strong>Debug</strong></span> button with the thunderbolt. Since you changed the code in a method, Android Studio will do a hot swap. You will notice a flicker while the current activity restarts.</p><p>When the hot swap is finished, a message is displayed in the bottom part of Android Studio, as you can see in the next screenshot:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_17.jpg"/></div><p>As you can read in the message, the code changes were applied and the current activity was restarted. Type a name and click on <code class="literal">ACCEPT</code>. The text message is the <code class="literal">Goodbye</code> one:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_18.jpg"/></div><p>Disable the <span class="strong"><strong>Restart activity on code changes</strong></span> option from the settings to observe the differences. Change the code back to the <code class="literal">Hello</code> text message and debug the app. There is no flicker now and, when the hot swap is finished, the message displayed in Android Studio is now different:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_19.jpg"/></div><p>When the hot <a class="indexterm" id="id399"/>swap is finished, a message is also displayed in the emulator, like in the following screenshot. In this case, the message shown is: <span class="emphasis"><em>Applied code changes without activity restart</em></span>.</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_20.jpg"/></div><p>Now change a resource, for example, change the hint of the <code class="literal">EditText</code> to the following one:</p><div class="informalexample"><pre class="programlisting">android:hint="Please, enter your name"</pre></div><p>Click on the <span class="strong"><strong>Debug</strong></span> button with the thunderbolt. Since you changed a resource, Android Studio will do a <a class="indexterm" id="id400"/>warm swap this time. You will notice that the current activity restarts again. The same message displays in the bottom part of Android Studio:</p><div class="mediaobject"><img alt="Instant run" src="graphics/B05459_08_21.jpg"/></div><p>If you want to <a class="indexterm" id="id401"/>disable instant run completely, you can do it from the settings screen by unmarking the <span class="strong"><strong>Enable Instant Run to hot swap code/resource changes on deploy (default enabled)</strong></span> option.</p></div>
<div class="section" title="Android Device Monitor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Android Device Monitor</h1></div></div></div><p>The DDMS is<a class="indexterm" id="id402"/> a more advanced debugging tool available in the SDK. The DDMS can be accessed from Android Studio through the <span class="strong"><strong>Android Device Monitor</strong></span> tool. This tool is able to monitor both a real device and the emulator.</p><p>To open the DDMS perspective, navigate to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Android</strong></span> | <span class="strong"><strong>Android Device Monitor</strong></span>. You can also click on the Android Device Monitor icon from the toolbar. A new window will be opened with the DDMS perspective.</p><p>In the left part of the window, the list of connected devices is shown. Currently, just our virtual device is listed. In the <span class="strong"><strong>Devices</strong></span> section, the list of the processes running on each device is also presented. We should be able to locate our application in the processes of the device we launched before. From the toolbar of the <span class="strong"><strong>Devices</strong></span> section, we can stop a process using the Stop sign icon. We can also take a screen capture of the virtual device by clicking on the Camera icon. Some of the other options will be explained later.</p><p>In the right part of the window, detailed information about the device is provided. This information is divided into seven tabs: <span class="strong"><strong>Threads</strong></span>, <span class="strong"><strong>Heap</strong></span>, <span class="strong"><strong>Allocation Tracker</strong></span>, <span class="strong"><strong>Network Statistics</strong></span>, <span class="strong"><strong>File Explorer</strong></span>, <span class="strong"><strong>Emulator Control</strong></span>, and <span class="strong"><strong>System Information</strong></span>. <span class="strong"><strong>LogCat</strong></span>, which has also been integrated in the DDMS perspective, is placed at the bottom part of the window.</p><div class="section" title="Threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec27"/>Threads</h2></div></div></div><p>The <span class="strong"><strong>Threads</strong></span> tab<a class="indexterm" id="id403"/> displays the list of threads that belong to<a class="indexterm" id="id404"/> the selected process. Select our application process from the <span class="strong"><strong>Devices</strong></span> section. The process is identified by the package name, in this case <code class="literal">com.example.myapplication</code>, click on the <span class="strong"><strong>Update Threads</strong></span> icon button from the toolbar of the <span class="strong"><strong>Devices</strong></span> section and the threads will be loaded in the content of the tab:</p><div class="mediaobject"><img alt="Threads" src="graphics/B05459_08_22.jpg"/></div><p>The first columns<a class="indexterm" id="id405"/> are the IDs of the threads. The <span class="strong"><strong>Status</strong></span> column<a class="indexterm" id="id406"/> indicates the thread state, <span class="strong"><strong>utime</strong></span> indicates the total time spent by the thread executing the user code, <span class="strong"><strong>stime</strong></span> indicates the total time spent by the thread executing system code, and <span class="strong"><strong>Name</strong></span> indicates the name of the thread. The threads that interest us are those that spend time executing our user code.</p><p>This <span class="strong"><strong>Threads</strong></span> tool is useful if we create threads in our application apart from the main thread. We can check if they are being executed at a certain point of the application and whether their execution time is moderate or not.</p><div class="section" title="Method profiling"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec01"/>Method profiling</h3></div></div></div><p>Method profiling is <a class="indexterm" id="id407"/>a tool to measure the performance of <a class="indexterm" id="id408"/>methods execution in the selected process. The measured parameters are the number of calls and the CPU time spent while executing. There are the following two types of spent time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Exclusive time</strong></span>: This is<a class="indexterm" id="id409"/> the time spent in the execution of a method.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Inclusive time</strong></span>: This is<a class="indexterm" id="id410"/> the total time spent on the execution of a method. This measure includes the time spent by any called methods inside the method. These called functions are known as its<a class="indexterm" id="id411"/> <span class="strong"><strong>children methods</strong></span>.</li></ul></div><p>To collect the method profiling data, select our application process from the <span class="strong"><strong>Devices</strong></span> section and click on the <span class="strong"><strong>Start Method Profiling</strong></span> icon from the toolbar of the <span class="strong"><strong>Devices</strong></span> section, next to the <span class="strong"><strong>Update Threads</strong></span> icon. A dialog to select the profiling option that you prefer is displayed. <span class="strong"><strong>Sample based profiling</strong></span> profiles with less runtime performance impact using a sampling frequency, which can be configured. Sample-based profiling is available in Android 4.4 and later. <span class="strong"><strong>Trace based profiling</strong></span> profiles the entry and exit of all the methods.</p><p>Perform some actions in the application; for example, in our example application, type a name and click on the <span class="strong"><strong>Accept</strong></span> button in order to execute the <code class="literal">onAcceptClick</code> method of the main activity. Stop<a class="indexterm" id="id412"/> the method profiling by clicking on <a class="indexterm" id="id413"/>the <span class="strong"><strong>Stop Method Profiling</strong></span> icon button.</p><p>When the method profiling is stopped, a new tab with the resultant trace is opened in the DDMS perspective. On the top of this new tab, the method calls are represented in a time graph; each row belongs to a thread. On the bottom of the trace, the summary of the time spent in a method is represented in a table.</p><p>Order the methods by their name to search for our <code class="literal">onAcceptClick</code> method (<code class="literal">com.example.myapplication.MainActivity.onAcceptClick</code>). Click on it to expand the detailed information about its execution. Now, note the following facts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The children methods called inside the <code class="literal">onAcceptClick</code> method are listed. We can see the <code class="literal">EditText.getText</code> method, the <code class="literal">Activity.findViewById</code> method, and the <code class="literal">TextView.setText</code> method, which we indeed directly call inside the method, as shown in the next screenshot.</li><li class="listitem" style="list-style-type: disc">The number of calls is detailed in the <span class="strong"><strong>Calls/Total</strong></span> column. For example, we can see that the <code class="literal">Activity.findViewById</code> method is called twice (<span class="strong"><strong>2/2</strong></span> value)—one call to find the <code class="literal">TextView</code> object and a second call to find the <code class="literal">EditText</code> object.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Exclusive time</strong></span> columns have no values for the parent or children methods due to their own definition of this type of measured time:<div class="mediaobject"><img alt="Method profiling" src="graphics/B05459_08_23.jpg"/></div></li></ul></div><p>Method profiling<a class="indexterm" id="id414"/> is very useful to detect methods that spend too much <a class="indexterm" id="id415"/>time on their execution and to subsequently optimize them. We can identify the most expensive methods to avoid unnecessary calls to them.</p></div></div><div class="section" title="Heap"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec28"/>Heap</h2></div></div></div><p>The <span class="strong"><strong>Heap</strong></span> tab<a class="indexterm" id="id416"/> displays the heap memory usage information <a class="indexterm" id="id417"/>and the statistics of the selected process. Select the application process and click on the <span class="strong"><strong>Update Heap</strong></span> icon button from the toolbar of the <span class="strong"><strong>Devices</strong></span> section to enable it. The heap information is shown after a <span class="strong"><strong>garbage collector</strong></span> (<span class="strong"><strong>GC</strong></span>) execution. To force it, click on the <span class="strong"><strong>Cause GC</strong></span> button or the garbage icon from the <a class="indexterm" id="id418"/>toolbar of the <span class="strong"><strong>Devices</strong></span> section.</p><p>The first table displays the summary of the heap usage: the total size, the allocated space, the free space, and the number of allocated objects. The <span class="strong"><strong>Stats</strong></span> table gives the following detail of the objects allocated in the heap by type: the number of objects (<span class="strong"><strong>Count</strong></span> column), the total size of those objects (<span class="strong"><strong>Total Size</strong></span> column), the size of the smallest (<span class="strong"><strong>Smallest</strong></span> column) and largest objects (<span class="strong"><strong>Largest</strong></span> column), the median size (<span class="strong"><strong>Median</strong></span> column), and the average size (<span class="strong"><strong>Average</strong></span> column). Select one of the types to load the bottom bar graph. </p><p>The graph shows the count of the objects of a type by size, in bytes. If we right-click on the graph, we can change its properties (title, colors, font, labels, and so on) and save it as an image in the PNG format:</p><div class="mediaobject"><img alt="Heap" src="graphics/B05459_08_24.jpg"/></div></div><div class="section" title="Allocation Tracker"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Allocation Tracker</h2></div></div></div><p>The <span class="strong"><strong>Allocation Tracker</strong></span> tab<a class="indexterm" id="id419"/> displays the <a class="indexterm" id="id420"/>memory allocations of the selected process. Select the application process and click on the <span class="strong"><strong>Start Tracking</strong></span> button to start tracking the memory information. Then, click on the <span class="strong"><strong>Get Allocations</strong></span> button to get the list of allocated objects.</p><p>We can use the filter on the top of the tab to filter the objects allocated in our own classes. Type our package name <code class="literal">com.example.myapplication</code> in the filter. For each object, the table shows its allocation size (<span class="strong"><strong>Allocation Size</strong></span>), the thread (<span class="strong"><strong>Thread</strong></span>), the object or class (<span class="strong"><strong>Allocated Class</strong></span>), and the method in which the object was allocated (<span class="strong"><strong>Allocated in</strong></span>). Click on any object to see more information, for example, the line number that allocated it.</p><p>As you can see in the next screenshot, a <code class="literal">java.lang.StringBuilder</code> object was allocated in the <code class="literal">onAcceptClick</code> of the main activity. In the bottom part, you can check the details of its allocation:</p><div class="mediaobject"><img alt="Allocation Tracker" src="graphics/B05459_08_25.jpg"/></div><p>Finally, click on the <span class="strong"><strong>Stop Tracking</strong></span> button.</p><p>The<a class="indexterm" id="id421"/> allocation tracker is very useful to <a class="indexterm" id="id422"/>examine the objects that are being allocated when doing certain interactions in our application, in order to improve memory usage.</p></div><div class="section" title="Network Statistics"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec30"/>Network Statistics</h2></div></div></div><p>The <span class="strong"><strong>Network Statistics</strong></span> tab<a class="indexterm" id="id423"/> displays how <a class="indexterm" id="id424"/>our application uses the network's resources. To get the network statistics of any application that uses the network, click on the <span class="strong"><strong>Start</strong></span> button. The data transfers will begin to appear in the graph.</p><p>The network statistics are useful to optimize the network requests in our code and control the data transferred at a certain point of the execution.</p></div><div class="section" title="File Explorer"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec31"/>File Explorer</h2></div></div></div><p>The <span class="strong"><strong>File Explorer</strong></span> tab<a class="indexterm" id="id425"/> exposes the whole filesystem<a class="indexterm" id="id426"/> of the device. We can examine the size, date, or permissions of each element. Navigate to <code class="literal">/data/app/</code> to search for our <code class="literal">com.example.myapplication.apk</code> application package file.</p></div><div class="section" title="Emulator Control"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec32"/>Emulator Control</h2></div></div></div><p>The <span class="strong"><strong>Emulator Control</strong></span> tab<a class="indexterm" id="id427"/> allows us to <a class="indexterm" id="id428"/>emulate some special states or activities in the virtual device. We can test our application in different environments and situations to check whether it behaves as expected. If our application has features that depend on the device's physical location, we can use mock locations. Some of these special states are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Telephony Status</strong></span>: This <a class="indexterm" id="id429"/>allows you to choose the voice and data status and its speed and latency</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Telephony Actions</strong></span>: This <a class="indexterm" id="id430"/>is used to simulate an incoming call or SMS</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Location Controls</strong></span>: This <a class="indexterm" id="id431"/>is used to set the geolocation of the device</li></ul></div></div><div class="section" title="System Information"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>System Information</h2></div></div></div><p>The <span class="strong"><strong>System Information</strong></span> tab presents the frame render time, total CPU load, and total memory <a class="indexterm" id="id432"/>usage of the device as graphs. We can<a class="indexterm" id="id433"/> search for our application and easily compare it with the rest of the processes running on the device.</p><p>We can change the properties of the graphs such as colors, font, and title and we can save them as images in PNG format. To open these options, right-click on the graph elements.</p><p>Open the CPU load and save the graph while our application is running in the foreground. Then, close the application and update the CPU load by clicking on the <span class="strong"><strong>Update from Device</strong></span> button. Note the difference between both graphs and the growth of the idle percentage, as shown in the following screenshot:</p><div class="mediaobject"><img alt="System Information" src="graphics/B05459_08_26.jpg"/></div></div><div class="section" title="Hierarchy View"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Hierarchy View</h2></div></div></div><p>Android Device Monitor <a class="indexterm" id="id434"/>contains a second perspective <a class="indexterm" id="id435"/>apart from the DDMS—the <span class="strong"><strong>Hierarchy View</strong></span>. On the top bar of the Android Device, you can change from one perspective to the other. The two options in the top bar are shown in the next screenshot:</p><div class="mediaobject"><img alt="Hierarchy View" src="graphics/B05459_08_27.jpg"/></div><p>Open the <span class="strong"><strong>Hierarchy View</strong></span> perspective and select your app from the left-side list. In the left-side panel, click on the following icon (the <span class="strong"><strong>Load the view hierarchy into the tree view</strong></span> action):</p><div class="mediaobject"><img alt="Hierarchy View" src="graphics/B05459_08_28.jpg"/></div><p>The view hierarchy is loaded as shown in the next screenshot:</p><div class="mediaobject"><img alt="Hierarchy View" src="graphics/B05459_08_29.jpg"/></div><p>There<a class="indexterm" id="id436"/> are three different panels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tree Overview</strong></span>: This <a class="indexterm" id="id437"/>panel shows the overview of the <a class="indexterm" id="id438"/>complete view hierarchy.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tree View</strong></span>: This <a class="indexterm" id="id439"/>panel shows in detail a specific area of the view hierarchy. At the bottom of the hierarchy, we can find the <code class="literal">TextView</code> with the ID <code class="literal">textView_greeting</code>, the <code class="literal">EditText</code> with the ID <code class="literal">editText_name</code>, and the <code class="literal">Button</code> with the ID <code class="literal">button_accept</code>. The parent of all of them is the <code class="literal">RelativeLayout</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layout View</strong></span>: This<a class="indexterm" id="id440"/> panel shows the layout view.</li></ul></div><p>If you select one of the view elements, you can see its details. The following screenshot shows the details of the <code class="literal">button_accept</code> button:</p><div class="mediaobject"><img alt="Hierarchy View" src="graphics/B05459_08_30.jpg"/></div><p>Open the <span class="strong"><strong>View Properties</strong></span> tab from the left-side panel. You can check the properties of the button, such<a class="indexterm" id="id441"/> as the <code class="literal">mText</code> property, the <a class="indexterm" id="id442"/>value of which is <code class="literal">Accept</code>.</p><p>On the top of the <span class="strong"><strong>Tree View</strong></span> panel, there are some actions like saving the tree view as a PNG image or capturing the window layers as a Photoshop file.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Summary</h1></div></div></div><p>Now you know the different launch options for your application as well as how to use the console and the <span class="strong"><strong>LogCat</strong></span> for debugging. We also saw how to debug an application and interpret the data provided by the DDMS in each of the tabs available.</p><p>In the next chapter, we will prepare our application for its release using Android Studio. First, you will learn about the necessary steps to prepare the application before building it in the release mode. You will also learn how applications are compressed in <code class="literal">APK</code> files and how to generate your own <code class="literal">APK</code> file. Finally, you will learn how to get your certificate as a developer and how to generate a signed <code class="literal">APK</code> file, making it ready for release.</p></div></body></html>