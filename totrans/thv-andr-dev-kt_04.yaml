- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backing Up Your WhatsPackt Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any chat application, data handling is a significant concern – we need to
    ensure that messages sent and received are stored correctly, quickly retrieved
    when needed, and resilient to potential losses due to unforeseen circumstances
    such as device failures or accidental deletions. This requires a robust data persistence
    strategy. We also need to consider performance and user experience, which calls
    for effective caching mechanisms, as well as making sure that we have backups
    in the event of data loss or when the user changes devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by introducing you to Room, a persistence library
    that provides an abstraction layer over SQLite and makes it easier to work with
    databases in Android. You’ll learn about its architecture and components and how
    to use it to store and retrieve chat conversations and messages.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will tackle the creation of a cache mechanism orchestrating the use
    of Room locally and the use of the API to gather data from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we’ll get you up to speed with Firebase Storage. You’ll learn
    to set it up, understand its benefits, and how to secure data stored in it. We’ll
    then use Firebase Storage to create a backup of our chat conversations, an essential
    feature for any chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll explore how to use `WorkManager`, an API that makes it easy to
    schedule deferrable, asynchronous tasks even if the app exits or the device restarts.
    You’ll learn how it can be used to schedule chat backups and how to upload these
    backups to **Amazon Simple Storage Service** (**Amazon S3**), ensuring data safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Room in WhatsPackt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Firebase Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling **WorkManager** to send backups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Amazon S3 for storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also going to assume that you followed along with the previous chapter.
    You can download this chapter’s complete code from here: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to Android development, one of the most essential tasks is managing
    your application’s data in a local database. The **Room** persistence library,
    part of Android Jetpack, is an abstraction layer over SQLite, a popular database
    that comes with Android. Room offers more robust database access while harnessing
    SQLite’s full power.
  prefs: []
  type: TYPE_NORMAL
- en: Key features of Room
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Room, developers primarily used **SQLite** directly or other **object-relational
    mapping** (**ORM**) libraries. While SQLite is powerful, it can be cumbersome
    to work with because it requires writing a lot of boilerplate code. Additionally,
    errors in SQL queries often aren’t detected until runtime, which can lead to crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Room solves these issues by providing a simpler and more robust API over the
    standard SQLite for managing local data storage. Here are some of its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile-time verification of SQL queries**: Room verifies your SQL queries
    at compile time, not at runtime. This means if there’s an error in one of your
    queries, you’ll know as soon as you compile your app, not after you’ve shipped
    it to users. This leads to more robust and reliable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced boilerplate code**: With Room, you don’t need to write as much code
    to perform simple database operations. This leads to cleaner, more readable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with other architecture components**: Room is designed to integrate
    seamlessly with other **Android Architecture Components** (**AAC**) library components,
    such as **LiveData** and **ViewModel**. This means you can create a well-architected,
    robust app that follows best practices for Android development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy migration paths**: Room offers robust migration support, including migration
    paths and testing. As your app’s data needs evolve, Room makes it easy to adapt
    your database structure to meet those needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports complex queries**: Despite simplifying interaction with SQLite,
    Room still allows you to perform complex SQL queries when you need more flexibility
    and power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, Room offers an efficient and streamlined approach to managing
    your app’s local data. It’s a powerful tool that can make your Android development
    experience much more pleasant and productive.
  prefs: []
  type: TYPE_NORMAL
- en: Room’s architecture and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Room’s architecture is based on three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access** **Object** (**DAO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, you can see how every Room component interacts with the rest of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Diagram of Room architecture](img/B19443_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Diagram of Room architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these components is crucial when using Room effectively, so let’s
    dive into them deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Database` class in Room is a high-level class that works as the main access
    point to your app’s persisted data. It’s an abstract class where you define an
    abstract method for each `@Dao` annotation in your app. When you create an instance
    of the `Database` class, Room generates the implementation code of these DAO methods
    (DAO will be explored in more detail in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Database` class is annotated with `@Database`, specifying the entities
    it comprises and the database version. If you modify the database schema, you
    need to update the version number and define a migration strategy, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve defined a `ChatAppDatabase` Room `Database` class with two entities,
    `Message` and `Conversation`. We’ve also defined abstract methods to access our
    DAOs – `messageDao()` and `conversationDao()`. The `entities` parameter in the
    `@Database` annotation takes an array of all entities in the database, while the
    `version` parameter is used for database migration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Entities** in Room represent the tables in a database. Each entity corresponds
    to a table, and each instance of an entity represents a row in the table. Room
    uses the class fields in an entity to define the columns in a table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare an entity by annotating a data class with `@Entity`. Each `@Entity`
    class represents a table in your database, and you can define the table name.
    If you don’t define a table name, Room uses the class name as the table name,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Message` is an entity that represents a `"messages"` table in our database.
    Each instance of `Message` will represent a row within the `"messages"` table.
    Each property in the `Message` class represents a column in the table. The `@PrimaryKey`
    annotation is used to denote a primary key, and the `@ColumnInfo` annotation is
    used to specify the column name in the database. If not specified, Room uses the
    variable name as the column name.
  prefs: []
  type: TYPE_NORMAL
- en: DAO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DAOs are interfaces that define all the database operations that you want to
    perform. For each DAO, you can define methods for different operations such as
    insertion, deletion, and querying.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should annotate an interface with `@Dao`, and then annotate each method
    with the corresponding operation you want to perform, such as `@Insert`, `@Delete`,
    `@Update`, or `@Query` for custom queries. Then, Room will autogenerate the necessary
    code to perform these operations at compile time. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this `MessageDao` interface, we’ve defined two methods – `insert()` for inserting
    a `Message` object into our database and `getMessagesForConversation()` to retrieve
    all messages related to a specific conversation from our database. The `@Insert`
    annotation is a convenience annotation for inserting an entity into a table. The
    `@Query` annotation allows us to write SQL queries to perform complex reads and
    writes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these components will allow us to leverage the power of Room effectively.
    The following sections will guide you through the process of implementing Room
    in our WhatsPackt application, starting from setting it up in Android Studio to
    creating entities and DAOs.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Room in WhatsPackt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will be guided through the practical steps of implementing
    Room in our chat application. We will begin by setting up Room in Android Studio,
    followed by creating entities and DAOs and eventually using these components to
    interact with our database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using Room, we first need to include the necessary dependencies in
    our project. Open your `build.gradle` file and add the following dependencies
    under `dependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `room-runtime` dependency includes the core Room library, while the `room-compiler`
    dependency is required for Room’s annotation-processing capabilities. Room’s Kotlin
    extensions and coroutines support are provided by `room-ktx`, while `room-testing`
    provides useful classes for testing your Room setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding these lines, sync your project. You can do it using the `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: The Sync Now option that appears in Android Studio when it detects
    any changes to Gradle files](img/B19443_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The Sync Now option that appears in Android Studio when it detects
    any changes to Gradle files'
  prefs: []
  type: TYPE_NORMAL
- en: We are ready now to create our database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed before, the `Database` component is the main access point for
    our app’s data. So, let’s create a `ChatAppDatabase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Database` annotation marks this class as a Room database. It takes two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**entities** is an array of classes that are annotated with **@Entity**, representing
    the tables within the database. In this case, the **Message** and **Conversation**
    classes are entities of **ChatAppDatabase**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**version** is the database version. If you make changes to the database schema,
    you’ll need to increment this version number and define a migration strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, `abstract fun messageDao(): MessageDao` and `abstract fun conversationDao():
    ConversationDao` are abstract methods that return the respective DAOs. They do
    not have method bodies because Room generates their implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we declare a companion object to hold a singleton instance of `ChatAppDatabase`,
    by using the `@Volatile` annotation. This annotation means `INSTANCE` can be accessed
    by multiple threads at once but always in a consistent state, meaning a change
    made by one thread to `INSTANCE` is immediately visible to all other threads.
    `INSTANCE` is marked as nullable because it might not be initialized immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In the `getDatabase()` function, we’re implementing a common pattern for creating
    a singleton instance of a class in a thread-safe way. This pattern ensures that
    only one instance of `ChatAppDatabase` is ever created.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `?:` operator to check whether `INSTANCE` is not `null`, and if it
    is, we enter the synchronized block. This block ensures that only one thread can
    enter this block of code at a time, preventing the creation of multiple instances
    of `ChatAppDatabase` if the function is called concurrently from multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Within the synchronized block, we’re calling `Room.databaseBuilder()` to create
    a new instance of `ChatAppDatabase`. We provide the application context to avoid
    memory leaks, the class of the database, and the name of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `build()` to create the `ChatAppDatabase` instance.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the new instance, we assign it to `INSTANCE` to cache it and
    then return the instance. The next time `getDatabase` is called, it will return
    the cached database instance instead of creating a new one. This is important
    because creating a Room database instance is an expensive operation, and having
    multiple instances would be a waste of resources.
  prefs: []
  type: TYPE_NORMAL
- en: This structure is essential for creating a database instance that will allow
    us to store messages and conversations.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first entity class we are going to create is the `Message` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are including quite a lot of instructions in the annotations,
    so let’s go through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Entity` annotation tells Room to treat this class as a table in the database.
    It comes with optional arguments, some of which are used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tableName**: This sets the name of the table as it will appear in the database.
    In this case, our table will be named **"messages"**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**foreignKeys**: This sets up a foreign key relationship with another table.
    A **ForeignKey** instance takes four main arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**entity**: This represents the class of the parent table that this entity
    has a relationship with. In this case, it’s **Conversation::class**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parentColumns**: This specifies the column(s) in the parent entity that the
    foreign key references. Here, it’s the **id** field of **Conversation**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**childColumns**: This specifies the column(s) in the child entity that holds
    the foreign key. Here, it’s the **conversation_id** field in **Message**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onDelete**: This represents the action that will be taken if the referenced
    row in the parent table is deleted. Here, **ForeignKey.CASCADE** is used, which
    means that if a **Conversation** instance is deleted, all messages that have a
    **conversation_id** value referencing the conversation’s ID will be deleted as
    well.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**indices**: This is used to create an index on **conversation_id** to speed
    up your queries. An index makes data retrieval faster at the cost of additional
    disk space and slower write speed. An index is particularly useful here because
    we will often perform operations related to a specific conversation, and indexing
    **conversation_id** will make these operations more efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we have also added annotations to the properties of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@PrimaryKey**: This annotation indicates that the **id** field is the primary
    key for the **Message** table. A primary key uniquely identifies each row in the
    table. We could use here **autoGenerate = true**, which means that this field
    will be automatically filled with an incrementing integer for each new row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@ColumnInfo(name = "column_name")**: This annotation lets you specify a custom
    column name in the database. If not specified, Room will use the variable name
    as the column name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a `Conversation` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Conversation` entity is very simple – we will just store the `Conversation`
    ID and the time of the last message in the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created and defined our entities, it’s time to create DAOs
    in order to obtain and update data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DAOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DAO is an interface that serves as a communication layer between the application
    code and the database. It defines methods for each operation we might perform
    on the entities in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the DAO for the `Message` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Breaking down the code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@Dao**: This annotation identifies the interface as a DAO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Query**: This annotation is used to specify SQL statements for complex data
    retrieval tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Insert**: This annotation is used to define a method that inserts its argument
    into the database. **OnConflictStrategy.REPLACE** means that if a message with
    the same primary key already exists, it will be replaced by a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Delete**: This annotation is used to define a method that deletes its argument
    from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a DAO for the `Conversation` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The annotations function the same way as they did in `MessageDao`. Here, we’re
    retrieving all conversations ordered by the time of their last message, and we
    have methods for inserting and deleting conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to provide these DAOs for other app components so that they can
    be injected. With that in mind, we will create the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have previously covered the creation of Hilt modules in the previous
    chapters, we won’t go over all the code again. Instead, here are the key parts
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using **@Singleton** to indicate that only a single instance of the object
    should be created and provided as a dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Context` we want to use, we can get confused or provide one that is not
    suitable for this situation. Using the `@ApplicationContext` qualifier will assure
    us that the `Context` injected will be the expected one (the `Application Context`,
    in this case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, as we already did in the previous chapter for the API or WebSocket, we
    are going to create a data source to connect with the database: `LocalMessagesDataSource`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LocalMessagesDataSource data source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create a `LocalMessagesDataSource` data source that will wrap the
    DAO and expose the specific database operations our app needs. This way, if we
    decide to change the database in the future, we will only have to change it here
    (not in the rest of consumers). This class will serve as a DAO at a higher level
    of abstraction, simplifying the API for the rest of our app and making it easier
    to mock the database in tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are just calling the functions we already defined
    in the DAO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we said before, we will use this data source to wrap the database and provide
    an additional abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to combine this local data source with the remote one. This will
    force us to think about a caching strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Handling two data sources in the MessagesRepository component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we only had one data source (the WebSocket one), but we would
    like our users to be able to retrieve their messages even if they have no connection
    for a short time. That’s the reason why we have just created a database and have
    it ready to be populated.
  prefs: []
  type: TYPE_NORMAL
- en: As our use case is to provide a fallback for the WebSocket so that the user
    can continue checking their messages, we will follow a strategy where the main
    source of truth will continue being the WebSocket, but we will store a copy of
    the messages in the app database. Also, we don’t want the records of this database
    to grow infinitely, so we are setting a cap of `100` messages per conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component responsible for combining both data sources is `MessagesRepository`,
    which we already implemented to be connected to `WebsocketDataSource` in the previous
    chapter. Let’s now modify it to include both data sources and to orchestrate the
    data retrieval and local storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will modify the `getMessages()` method to include the logic to store
    the information retrieved from `MessagesSocketDataSource` (remote data source)
    in `DatabaseDataSource` (local data source):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, we have connected to the socket data source, but we have wrapped
    this action in a `try`-`catch` block. So, if everything goes correctly, we will
    store in our database every new message and then emit it in the flow.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we call `manageDatabaseSize()`, which will check and keep
    the size of the database under the limit we have set (100 maximum messages per
    conversation). If the socket fails, we will retrieve messages from the database
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will also modify the `sendMessage` method, where we will also store
    every new message sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The disconnect will be kept the same as we don’t need to do anything related
    to the new data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is the mechanism that we will implement to keep the size of the
    database under the agreed number of messages per conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will obtain all messages related to the conversation and check if the size
    is more than 100\. Then, we will order them based on their timestamp and remove
    the oldest ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the Room database integrated into our app. Our last messages will
    be available even if we lose the connection. In the following section, let’s see
    how we can also send a backup of those messages to be stored in the cloud. For
    that, we will use Firebase Storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Firebase Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Firebase Storage**, also known as Cloud Storage for Firebase, is a powerful
    object storage service built for Google scale. It enables developers to store
    and retrieve user-generated content, such as photos, videos, or other forms of
    user data. Firebase Storage is backed by **Google Cloud Storage** (**GCS**), making
    it robust and scalable for any size of data, from small text files to large video
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key features and capabilities of Firebase Storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-generated content**: Firebase Storage allows your users to upload their
    own content directly from their devices. This could include anything from profile
    pictures to blog posts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with Firebase and Google Cloud**: Firebase Storage integrates
    smoothly with the rest of the Firebase ecosystem, including Firebase Authentication
    and Firebase Security Rules. It’s also a part of the larger Google Cloud ecosystem,
    which opens up possibilities for using Google Cloud’s advanced features, such
    as Cloud Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Firebase Storage provides robust security features. Using Firebase
    Security Rules, you can control who has access to what data. You can restrict
    access based on a user’s authentication state, identity, and claims, as well as
    data patterns and metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Firebase Storage is designed to handle a large number of uploads,
    downloads, and storage of data. It automatically scales with your user base and
    traffic, meaning you don’t need to worry about capacity planning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offline capabilities**: Firebase **software development kits** (**SDKs**)
    for Cloud Storage add Google security to file uploads and downloads for your Firebase
    apps, regardless of network quality. You can use it to pause, resume, and cancel
    transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rich media**: Firebase Storage supports rich media content. This means you
    can use it to store images, audio, video, or even other binary data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong consistency**: Firebase Storage guarantees strong consistency, meaning
    that once an upload or download is completed, the data is immediately available
    from all Google Cloud Storage locations, and any subsequent reads will return
    the latest updated data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our context, a messaging application, Firebase Storage could be used to store
    and retrieve message history or backups, shared files, or even multimedia content
    within conversations. This could serve as a reliable backup solution or a means
    of synchronizing chat history across multiple devices. However, you need to ensure
    you handle privacy and security concerns, especially since chat conversations
    can contain sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: How Firebase Storage works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Firebase Storage, data is stored as objects within a hierarchical structure.
    The full path to an object in Firebase Storage includes the project ID and the
    object’s location within the storage bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the context of cloud storage, a **bucket** is a basic container that holds
    data. It’s the primary parent in the hierarchy of data organization. All data
    in cloud storage is stored in buckets. The concept of a bucket is used by many
    cloud storage systems, including GCS, Amazon S3, and Firebase Storage. These systems
    typically allow you to create one or more buckets in your storage space and then
    upload data as objects or files to these buckets. Each bucket has a unique name
    within the cloud storage system, and it contains data objects, or files, each
    of which is identified by a key or a name.
  prefs: []
  type: TYPE_NORMAL
- en: The object’s location is defined by a path that you specify. This path is similar
    to a filesystem path and includes both the directories and the filename. For example,
    in the `images/profiles/user123.jpg` path, `images` and `profiles` are directories,
    and `user123.jpg` is the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you upload a file to Firebase Storage, you create a reference to the location
    where you’re going to store the file. This reference is represented by a `StorageReference`
    object, which you create by calling the `child()` method on a reference to your
    Firebase Storage bucket and passing the path as an argument, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fileRef` is a reference to the `user123.jpg` file in the profile’s directory
    within the `images` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this reference to perform various operations, such as uploading
    a file, downloading a file, or getting a URL to the file. Each of these operations
    returns a `Task` object that you can use to monitor the operation’s progress or
    get its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The paths in Firebase Storage are flexible, and you can structure them in a
    way that makes sense for your application. For instance, in a messaging application,
    you might store conversation logs in a `chat_logs` directory, with each log’s
    filename being the chat’s ID. The path to a chat log might look like this: `chat_logs/chat123.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s worth noting that Firebase Storage uses rules to control who can
    read and write to your storage bucket. By default, only authenticated users can
    read and write data. You can customize these rules to suit your application’s
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start setting up Firebase Storage in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Firebase Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using Firebase Storage, we’ll first need to add the Cloud Storage
    for Firebase Android library to our app. This can be done by adding the following
    line to our module’s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the chat messages, one approach would be to save the chat logs as text
    files in Firebase Storage. Each conversation could have its own text file, and
    each message would be a line in that file. So, we are going to create a data source
    to upload those files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve added the Firebase storage instance as a parameter to the constructor,
    allowing it to be injected when the class is instantiated using Hilt. The `uploadFile`
    and `downloadFile` methods suspend the coroutine until the upload or download
    operation completes, using the `await()` extension function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use the Firebase storage instance, we would need to provide the
    `FirebaseStorage` dependency. For that, we will need to create the following module
    so that Hilt is aware of how it can obtain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create those files, to then be uploaded using this data source.
    We are going to do it in a newly created repository: `BackupRepository`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `BackupRepository` repository will serve as an intermediary between different
    data sources (such as local databases via DAOs and remote data sources such as
    Firebase Storage) and the rest of the application. It retrieves data from the
    sources, processes it if necessary, and provides it to the calling code in a convenient
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the code, it uses `ConversationDao` to fetch all conversations
    in the local database. Each conversation represents a distinct chat thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then, for each conversation, it fetches the associated messages using `MessageDao`,
    converts the messages to a JSON string using the Gson library, writes this JSON
    string to a temporary file, and then uploads the file to Firebase Storage through
    `StorageDataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the upload to Firebase Storage is complete, it deletes the local temporary
    file to clean up the storage space on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '`BackupRepository` handles all the details of data retrieval, processing, and
    storage. Other parts of the application don’t need to know how the data is stored
    or retrieved. They only interact with `BackupRepository`, which provides a simple
    interface for these operations. This makes the code easier to maintain, understand,
    and test.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will create `UploadMessagesUseCase`, which will be the use case
    or domain interactor responsible for executing the upload action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UploadMessagesUseCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The responsibility of `UploadMessagesUseCase` will be to execute the backup
    using `BackupRepository`. As most of the logic is already in the repository, the
    code will be simpler and will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to retrieve and upload these backups. As it can be a time-
    and resource-consuming task, the idea will be to do it periodically, once per
    week or once per day. This is where `WorkManager` comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling WorkManager to send backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkManager` is the recommended tool for tasks that require guaranteed and
    efficient execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkManager` uses an underlying job dispatching service based on the following
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses **JobScheduler** for devices with API 23 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For devices with API 14 to 22, it uses a combination of **BroadcastReceiver**
    (for system broadcasts) and **AlarmManager**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the app includes the optional **WorkManager** dependency on Firebase **JobDispatcher**
    and Google Play services are available on the device, **WorkManager** uses Firebase
    **JobDispatcher**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkManager` chooses the appropriate way to schedule a background task, depending
    on the device API level and included dependencies. To use `WorkManager`, we need
    first to understand how we can create `Worker` and `WorkRequest` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Worker class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Worker` class (or `CoroutineWorker` if you’re using Kotlin coroutines) and
    override the `doWork()` method to define what the task should do.
  prefs: []
  type: TYPE_NORMAL
- en: The `doWork()` method is where you put the code that needs to be executed in
    the background. This is where you define the operation that needs to be performed,
    such as fetching data from the server, uploading a file, processing an image,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Worker` instance is given a maximum of 10 minutes to finish its execution
    and return a `Result` instance. The `Result` instance can be one of three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Result.success()**: Indicates that the work completed successfully. You can
    optionally return a **Data** object that can be used as the output data of this
    work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result.failure()**: Indicates that the work failed. You can optionally return
    a **Data** object that can describe the failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result.retry()**: Indicates that the work failed and should be tried at another
    time according to its retry policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique feature of `Worker` is that it’s `Worker` instance is running and the
    app goes to the background, the `Worker` instance can continue to run, whereas
    if the device restarts while the `Worker` instance is running, the task can resume
    when the device is back up. This ensures that the work will be performed under
    the constraints specified when creating a `WorkRequest` instance, even if your
    app process is not around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a basic `Worker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we extend the `Worker` class and override the `doWork()` method
    to specify the task to be performed. In this case, we are just returning the result
    as successful, but the code to do the actual work would be where the `// Code
    to execute in the background` comment is placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `Worker` instances work, we need another component: `WorkRequest`.
    Let’s see how we can configure and use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the WorkRequest component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`WorkRequest` is the class that defines an individual unit of work. It encapsulates
    your `Worker` class, along with any constraints that must be satisfied for the
    work to run and any input data it needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two concrete implementations of `WorkRequest` that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OneTimeWorkRequest**: As the name suggests, this represents a one-off job.
    It will only be executed once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PeriodicWorkRequest**: This is used for repeating jobs that run periodically.
    The minimum repeat interval that can be defined is 15 minutes. This constraint
    is discussed further in the official documentation: [https://developer.android.com/reference/androidx/work/PeriodicWorkRequest](https://developer.android.com/reference/androidx/work/PeriodicWorkRequest).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkRequest` has several options for setting conditions for the execution
    of work and for scheduling multiple pieces of work to run in a particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraints**: A **WorkRequest** instance can have a **Constraints** object
    set on it, which allows you to specify conditions that must be met for the work
    to be eligible to run. For example, you might require that the device is idle
    or charging, or that it has a certain type of network connectivity. We will learn
    about these conditions in detail in a few paragraphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input data**: You can attach input data to a **WorkRequest** instance using
    the **setInputData()** method, providing your **Worker** instance with all the
    information it needs to do its work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backoff criteria**: You can set backoff criteria for the **WorkRequest**
    instance to control retry timing when the work fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tags**: You can also add tags to your **WorkRequest** instance, which will
    make it easier to track, observe, or cancel specific groups of work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaining work**: **WorkManager** allows you to create dependent chains of
    work. This means that you can ensure certain pieces of work are executed in a
    certain order. You can create complex chains that run a series of **WorkRequest**
    objects in a specific order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkManager` offers several types of constraints that you can set on a `WorkRequest`
    object to specify when your task should run. This is done using the `Constraints.Builder`
    class. Here are the available constraints you can set:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network type** (**setRequiredNetworkType**): This constraint specifies the
    type of network that must be available for the work to run. Options include **NetworkType.NOT_REQUIRED**,
    **NetworkType.CONNECTED**, **NetworkType.UNMETERED**, **NetworkType.NOT_ROAMING**,
    and **NetworkType.METERED**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battery not low** (**setRequiresBatteryNotLow**): If this constraint is set
    to **true**, the work will only run when the battery isn’t low.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device idle** (**setRequiresDeviceIdle**): If this constraint is set to **true**,
    the work will only run when the device is in idle mode. This is usually when the
    user hasn’t interacted with the device for a period of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage not low** (**setRequiresStorageNotLow**): If set to **true**, the
    work will only run when the storage isn’t low.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device charging** (**setRequiresCharging**): If set to **true**, the work
    will only run when the device is charging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of how we can configure a `WorkRequest` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `MyWorker` will only run when the device is charging, connected
    to a network, and the battery level is not low. It will also have a tag, which
    will allow us to identify it easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram with the flow followed for the `Worker` and `WorkRequest`
    instances to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance](img/B19443_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance'
  prefs: []
  type: TYPE_NORMAL
- en: We now have the tools to build our own `Worker` instance and configure the `WorkRequest`
    instance to retrieve and upload the backup. So, let’s actually create them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Worker instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, to support the `WorkManager` API, we need to include the related dependencies
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen before, the `Worker` class will execute the task that can run
    in the background even when the app is not being used. In other words, it’s a
    unit of work that can be scheduled to run under certain conditions. In our case,
    we have just created the logic for that (in `UploadMessagesUseCase`), so our `Worker`
    class will need to have access to that class.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the reason we will start adding `HiltWorker` is an annotation provided
    by Hilt’s `androidx.hilt` extension library. This annotation tells Hilt that it
    should create an injectable Worker instance (that is, Hilt should manage the dependencies
    of this `Worker` instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete code for our `Worker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also using a new annotation: `AssistedInject`. Now, `AssistedInject`
    is a Dagger Hilt feature that helps with scenarios where you need to inject some
    dependencies but also need to provide some arguments at runtime. Here, the `appContext`
    and `workerParams` arguments to the constructor are provided at runtime (when
    the `Worker` instance is created by `WorkManager`), while `uploadMessagesUseCase`
    is a dependency that should be injected.'
  prefs: []
  type: TYPE_NORMAL
- en: The `doWork()` function is where the work that this `Worker` instance should
    perform is defined. This function is a suspend function and runs within a coroutine
    scope. This means it can perform long-running operations such as network requests
    or database operations without blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: In `doWork()`, `uploadMessagesUseCase.execute()` is called to perform the actual
    work of uploading messages. If this operation is successful, `Result.success()`
    is returned. If an `Exception` error is thrown, `Result.retry()` is returned if
    `runAttemptCount` is less than `MAX_RETRIES`, which means the work should be retried.
    If `runAttemptCount` equals or exceeds `MAX_RETRIES`, `Result.failure()` is returned,
    which means the work should not be retried.
  prefs: []
  type: TYPE_NORMAL
- en: As we want it to only retry three times, we are using `runAttemptCount`, which
    is a property provided by `ListenableWorker` (the superclass of `CoroutineWorker`)
    that keeps track of how many times the work has been attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `MAX_RETRIES` is a constant that defines the maximum number of retries.
    It is set to `3` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, this `Worker` instance uploads messages by calling `uploadMessagesUseCase.execute()`,
    and it can retry the operation up to three times in case of failure. The actual
    dependencies of this `Worker` instance (`UploadMessagesUseCase`) are provided
    via `WorkRequest` class.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the WorkRequest class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of the `WorkRequest` class, we will have to think about how frequently
    we want our messages to be backed up; for example, we can do a backup once per
    week. Also, we are going to configure the `WorkRequest` class to be only called
    when the user has a Wi-Fi connection. Here is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use `PeriodicWorkRequestBuilder` to create a `WorkRequest` instance that
    runs `UploadMessagesWorker` once every week. The `WorkRequest` instance has a
    constraint that requires an unmetered network connection (Wi-Fi). It also specifies
    a linear backoff policy for retries – this means that each retry attempt is delayed
    by a fixed amount of time, increasing linearly with each subsequent retry.
  prefs: []
  type: TYPE_NORMAL
- en: The `enqueue()` method schedules the `WorkRequest` instance to run. If the constraints
    are met and there’s no other work ahead of it in the queue, it will start running
    immediately. Otherwise, it will wait until the constraints are met and it’s the
    `WorkRequest` instance’s turn in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that due to OS restrictions, a `PeriodicWorkRequest` instance may
    not run exactly when the period elapses; it may have some delay, but it will run
    at least once within that time period.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this code and enqueue the `WorkRequest` instance from any place
    in our app, but to ensure it gets scheduled, the most convenient place is when
    we start up the app, in the `WhatsPacktApplication.onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With all this, we would have our app ready to periodically back up messages,
    and our work well could have finished here. However, to explore a different approach,
    let’s see what happens if we need to integrate another storage provider – for
    example, Amazon S3.
  prefs: []
  type: TYPE_NORMAL
- en: Using Amazon S3 for storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon S3** is a scalable, high-speed, web-based cloud storage service designed
    for online backup and archiving of data and applications on **Amazon Web Services**
    (**AWS**). It’s a well-known alternative to Firebase Storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief overview of some key features and capabilities of Amazon S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage**: Amazon S3 can store any amount of data and access it from anywhere
    on the web. It provides virtually limitless storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability and availability**: Amazon S3 is designed for 99.999999999% (11
    9s) of durability, and it stores redundant copies of data across multiple geographically
    separated data centers. It also provides 99.99% availability of objects over a
    given year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Amazon S3 provides advanced security features such as encryption
    for data at rest and in transit, and fine-grained access controls to resources
    using AWS **Identity and Access Management** (**IAM**), **access control lists**
    (**ACLs**), and bucket policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Amazon S3 is designed to scale storage, requests, and users
    to support an unlimited number of web-scale applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: AWS storage makes sure that when you add or delete files,
    you can immediately read the latest version of your files. If you overwrite a
    file or delete it, there might be a short delay before these changes are fully
    updated everywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: Amazon S3 integrates well with other AWS services, such as
    AWS CloudTrail for logging and monitoring, Amazon CloudFront for content delivery,
    AWS Lambda for serverless compute, and many more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management features**: S3 provides functionalities for management tasks such
    as organizing data and configuring finely-tuned access controls to meet specific
    business, organizational, and compliance requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transfer**: S3 Transfer Acceleration enables fast, easy, and secure
    transfers of files over long distances between your client and your Amazon S3
    bucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage classes**: Amazon S3 provides several storage classes for different
    types of data storage needs, such as S3 Standard for general-purpose storage of
    frequently accessed data, S3 Intelligent-Tiering for data with unknown or changing
    access patterns, S3 Standard-IA for long-lived but infrequently accessed data,
    and S3 Glacier for long-term archive and digital preservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query-in-place functionality**: S3 Select enables applications to retrieve
    only a subset of data from an object by using simple SQL expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features make Amazon S3 a robust and versatile choice for various use
    cases, ranging from web applications to backup and restore, archive, enterprise
    applications, IoT devices, and big data analytics.
  prefs: []
  type: TYPE_NORMAL
- en: To implement our storage solution based on Amazon S3, we first need to integrate
    the AWS SDK into our app.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the AWS S3 SDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can integrate the AWS S3 SDK into our Android project by adding the following
    dependencies in our `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have added here dependencies for the AWS SDK and the dependency needed to
    use Amazon Cognito.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also need to provide our AWS credentials (access key ID and secret access
    key) to the SDK. For mobile applications, it is recommended to use Amazon Cognito
    for credential management.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Amazon Cognito
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon Cognito** is a service that provides user sign-up and sign-in services,
    as well as access control for mobile and web applications. When you use Amazon
    Cognito for your user pool, you have the option to secure your data in AWS services
    (such as Amazon S3 for file storage) without having to embed AWS keys in your
    application code, which is a significant security risk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions to set up Amazon Cognito in our Android application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to the Amazon Cognito console: [https://console.aws.amazon.com/cognito/home](https://console.aws.amazon.com/cognito/home).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, click **Identity Pools**, then **Create new** **identity pool**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Guest Access** under the **Authentication** section, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create a New IAM Role**, create a name for it, and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then create a new name for the identity pool and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the summary (as in *Figure 3**.4*), then click **Create** **identity
    pool**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4: New identity pool configuration](img/B19443_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: New identity pool configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are enabling access to unauthenticated identities. You also have the
    option to give access only to authenticated identities, but note that you will
    have to create every user in Amazon Cognito. Nevertheless, this approach is more
    secure than using the S3 SDK to store keys in our app code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our app, we’ll need to obtain the AWS credentials provider. For that,
    we will initialize **CognitoCachingCredentialsProvider** with our **IdentityPoolId**
    class, in the region we configured it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the credentials provider instance while creating a client for
    the AWS service. For example, to use it with Amazon S3, use this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it is time to create a new storage provider.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS S3 Storage provider and integrating it into our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to do the same thing we did for Firebase Storage but with the
    AWS SDK: create a provider. This provider will be `AWSS3Provider` and will be
    used to handle the upload of files to AWS S3\. It will take a `Context` object
    and a `CognitoCachingCredentialsProvider` object as constructor parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `uploadFile` function is a suspending function, meaning it can be called
    from any coroutine scope. The `withContext(Dispatchers.IO)` function is used to
    switch the coroutine context to the I/O dispatcher, which is optimized for I/O-related
    tasks, such as network calls or disk operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into the `uploadFile` function, which is the core of this class.
  prefs: []
  type: TYPE_NORMAL
- en: The `TransferUtility` class simplifies the process of uploading and downloading
    files to/from Amazon S3\. Here, we’re building a `TransferUtility` instance, providing
    it with the Android context, AWS configuration, and an `AmazonS3Client` instance
    initialized with the provided `CognitoCachingCredentialsProvider` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `transferUtility.upload()` method is used to upload a file to the specified
    bucket in S3\. We provide the name of the bucket (`bucketName`), the key under
    which to store the new object (`objectKey`), and the file we want to upload (`File(filePath)`).
    This function returns a `UploadObserver` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`UploadObserver` is used to monitor the progress of the upload.'
  prefs: []
  type: TYPE_NORMAL
- en: We attach`TransferListener` to the observer to get callbacks when the upload
    state changes, the upload makes progress, or an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `onStateChanged()` method is called when the state of the transfer changes.
    If the state is `TransferState.COMPLETED`, it means the file has been uploaded
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `onProgressChanged()` method is called when more bytes have been transferred.
    Here, we calculate the progress as a percentage and log it.
  prefs: []
  type: TYPE_NORMAL
- en: The `onError()` method is called if an error occurs during the transfer. We
    will throw an error when it happens, to be handled by the consumers or this provider.
  prefs: []
  type: TYPE_NORMAL
- en: The `uploadFile` function is called from within a coroutine, and since the actual
    upload operation is a network I/O operation, it’s wrapped in `withContext(Dispatchers.IO)`.
    This ensures the operation doesn’t block the main thread, as the I/O dispatcher
    uses a separate thread pool that’s optimized for disk and network I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will need to create a data source to connect our `BackupRepository`
    instance to this new provider. The best way to do it is by implementing `IStorageDataSource,`
    a common interface for both data sources. This way, you’re able to swap the underlying
    implementation (Firebase Storage, AWS S3, and so on) without changing the rest
    of your code. (This is an application of the **Dependency Inversion Principle**
    (**DIP**), one of the SOLID principles of **object-oriented** (**OO**) design,
    which helps make your code more flexible and easier to maintain.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we will implement `S3StorageDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are implementing the `uploadFile` function calling the `awsProvider.uploadFile`
    function, which will upload the file to the bucket with the `our-bucket-name`
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new `S3StorageDataSource` class can be provided via Hilt in a similar
    way to the previous `FirebaseStorageDataSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a `@Module` annotation that includes a `@Provides` or `@Binds`
    method for `IStorageDataSource`, and Hilt will take care of injecting the right
    implementation based on your configuration. If you want to switch from Firebase
    Storage to AWS S3, you’d modify this module to provide `S3StorageDataSource` instead
    of `FirebaseStorageDataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to integrate it into our `BackupRepository` class. It is as
    easy as replacing the `StorageDataSource` dependency for the `IStorageDataSource`
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And that’s all. Depending on what we are providing in our Hilt module to satisfy
    the `IStorageDataSource` dependency, it will use the Firebase Storage one or the
    AWS S3 one.
  prefs: []
  type: TYPE_NORMAL
- en: And with this change, we finish this chapter and also our work in the WhatsPackt
    application!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: WhatsPackt’s final appearance](img/B19443_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: WhatsPackt’s final appearance'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we centered our efforts on creating a good offline experience
    for our user (storing the messages in a local database using Room) and providing
    a mechanism to store the messages backup, in case something fails. We have also
    learned how to use different providers to store our files in the cloud using Firebase
    Firestore and AWS S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have finished our work in the WhatsPackt app. In the next chapter,
    we will start building a new app: Packtagram. It will be an app to share photos
    and videos with our friends that will provide new and different challenges when
    creating it, such as capturing video. These are challenges that we will learn
    to overcome.'
  prefs: []
  type: TYPE_NORMAL
