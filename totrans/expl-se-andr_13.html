<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Getting to Enforcing Mode</h1></div></div></div><p>As an engineer, you're handed some Android device, and the requirement is to apply SE for Android controls to the device to enhance its security posture. So far, we have seen all the pieces that need to be configured and how they work to enable such a system. In this chapter, we'll take all the skills covered to get our UDOO in enforcing mode. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Run, evaluate, and respond to audit logs from CTS</li><li class="listitem" style="list-style-type: disc">Develop secure policy for the UDOO</li><li class="listitem" style="list-style-type: disc">Switch to enforcing mode</li></ul></div><div><div><div><div><h1 class="title"><a id="ch13lvl1sec68"/>Updating to SEPolicy master</h1></div></div></div><p>Many<a id="id396" class="indexterm"/> changes to the <code class="literal">sepolicy</code> directory have occurred in the AOSP <code class="literal">master</code> branch since the 4.3 release. At the time of this writing, the <code class="literal">master</code> branch of the <code class="literal">external/sepolicy</code> project was on Git commit SHA <code class="literal">b5ffb</code>. The authors recommend attempting to use the most recent commit. However, for illustrative purposes, we will show you how to optionally check out commit <code class="literal">b5ffb</code> so you can accurately follow the examples in this chapter.</p><p>First, you'll need to clone the <code class="literal">external/sepolicy</code> project. In these instructions, we assume your working directory has the UDOO sources contained in the <code class="literal">./udoo</code> directory:</p><div><pre class="programlisting">
<strong>$ git clone https://android.googlesource.com/platform/external/sepolicy</strong>
<strong>$ cd sepolicy</strong>
</pre></div><p>If you want to follow the examples in this chapter precisely, you'll need to check out commit <code class="literal">b5ffb</code> with the following command. If you skip it, you will end up using the latest commit in the <code class="literal">master</code> branch:</p><div><pre class="programlisting">
<strong>$ git checkout b5ffb</strong>
</pre></div><p>Now, we'll replace the UDOO 4.3 sepolicy with what we just acquired from Google:</p><div><pre class="programlisting">
<strong>$ cd ..</strong>
<strong>$ rm -rf udoo/external/sepolicy</strong>
<strong>$ cp -r sepolicy udoo/external/sepolicy</strong>
</pre></div><p>Optionally, you<a id="id397" class="indexterm"/> can remove the <code class="literal">.git</code> folder from the newly copied sepolicy with the following command, but this is not necessary:</p><div><pre class="programlisting">
<strong>$ rm –rf udoo/external/sepolicy/.git</strong>
</pre></div><p>Also, copy the <code class="literal">audit.te</code> file and restore it.</p><p>Additionally, restore the <code class="literal">auditd</code> commit from the NSA Bitbucket <code class="literal">seandroid</code> repository. For your reference, it's commit SHA <code class="literal">d270aa3</code>.</p><p>After that, remove all references to <code class="literal">setool</code> from <code class="literal">udoo/build/core/Makefile</code>. This command will help you locate them:</p><div><pre class="programlisting">
<strong>$ grep -nw setool udoo/build/core/Makefile</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec69"/>Purging the device</h1></div></div></div><p>At this point, our <a id="id398" class="indexterm"/>UDOO is messy, so let's reflash it, including the data directory, and start afresh. We want to have only the code and the <code class="literal">init</code> script changes, without the additional sepolicy. Then we can author a policy properly and apply all the techniques and tools we've encountered. We'll start by resetting to a state analogous to the completion of <a class="link" href="ch04.html" title="Chapter 4. Installation on the UDOO">Chapter 4</a>, <em>Installation on the UDOO</em>. However, the major difference is we need to build a <code class="literal">userdebug</code> version rather than an engineering (<code class="literal">eng</code>) version for CTS. The version is selected in the setup script, which ultimately calls <code class="literal">lunch</code>. To build this version, execute the following commands from the UDOO workspace:</p><div><pre class="programlisting">
<strong>$ . setup udoo-userdebug</strong>
<strong>$ make -j8 2&gt;&amp;1 | tee logz</strong>
</pre></div><p>Flash the system, boot to the SD card, and wipe <code class="literal">userdata</code> with the following commands, assuming the SD card is inserted into the host and <code class="literal">userdata</code> is not mounted:</p><div><pre class="programlisting">
<strong>$ mkdir ~/userdata</strong>
<strong>$ sudo mount /dev/sdd4 ~/userdata</strong>
<strong>$ cd ~/userdata/</strong>
<strong>$ sudo rm -rf *</strong>
<strong>$ cd ..</strong>
<strong>$ sudo umount ~/userdata</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec70"/>Setting up CTS</h1></div></div></div><p>You must <a id="id399" class="indexterm"/>pass CTS if your organization seeks Android branding. However, even if you don't, it's a good idea to run these tests to help ensure a device will be compliant with applications. Based on your security goals and desires, you may fail portions of CTS if you're not seeking Android branding. For our case, we're looking at CTS as a way to exercise the system and uncover policy issues that prevent the proper functioning of the UDOO. Its source is located in the <code class="literal">cts/</code> directory, but we recommend downloading<a id="id400" class="indexterm"/> the binary directly from Google. You can get more information and <a id="id401" class="indexterm"/>the CTS binary itself from <a class="ulink" href="https://source.android.com/compatibility/cts-intro.html">https://source.android.com/compatibility/cts-intro.html</a> and <a class="ulink" href="https://source.android.com/compatibility/android-cts-manual.pdf">https://source.android.com/compatibility/android-cts-manual.pdf</a>.</p><p>Download<a id="id402" class="indexterm"/> the CTS 4.3 binary from the <strong>Downloads</strong> tab. Then select the CTS binary. The <strong>Compatibility Definition Document</strong> (<strong>CDD</strong>) is also worth reading. It covers the high-level details of CTS and compatibility requirements.</p><p>Download CTS from <a class="ulink" href="https://source.android.com/compatibility/downloads.html">https://source.android.com/compatibility/downloads.html</a> and extract it. Select the CTS version that matches your Android version. If you don't know which version your device is running, you can always check the <code class="literal">ro.build.version.release</code> property from the UDOO with <code class="literal">getprop ro.build.version.release</code>:</p><div><pre class="programlisting">
<strong>$ mkdir ~/udoo-cts</strong>
<strong>$ cd ~/udoo-cts</strong>
<strong>$ wget https://dl.google.com/dl/android/cts/android-cts-4.3_r2-linux_x86-arm.zip</strong>
<strong>$ unzip android-cts-4.3_r2-linux_x86-arm.zip</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec71"/>Running CTS</h1></div></div></div><p>The CTS <a id="id403" class="indexterm"/>exercises many components on the device and helps test various parts of the system. A good, general policy should allow proper functioning of Android and pass CTS.</p><p>Follow the directions in the Android CTS user manual to set up your device (see <em>Section 3.3</em>, <em>Setting up your device</em>). Typically, you will see some failures if you don't follow all the steps precisely, as you may not have the access or the capabilities to acquire all the resources needed. However, CTS will still exercise some code paths. At a minimum, we recommend getting the media files copied and Wi-Fi active. Once your device is set up, ensure <code class="literal">adb</code> is active and initiate the testing:</p><div><pre class="programlisting">
<strong>$ ./cts-tradefed</strong>
<strong>11-30 10:30:08 I/: Detected new device 0123456789ABCDEF</strong>
<strong>cts-tf &gt; run cts --plan CTS</strong>
<strong>cts-tf &gt; </strong>
<strong>time passes here</strong>
<strong>11-30 10:30:28 I/TestInvocation: Starting invocation for 'cts' on build '4.3_r2' on device 0123456789ABCDEF</strong>
<strong>11-30 10:30:28 I/0123456789ABCDEF: Created result dir 2014.11.30_10.30.28</strong>
<strong>11-30 10:31:44 I/0123456789ABCDEF: Collecting device info</strong>
<strong>11-30 10:31:45 I/0123456789ABCDEF: -----------------------------------------</strong>
<strong>11-30 10:31:45 I/0123456789ABCDEF: Test package android.aadb started</strong>
<strong>11-30 10:31:45 I/0123456789ABCDEF: -----------------------------------------</strong>
<strong>11-30 10:32:15 I/0123456789ABCDEF: com.android.cts.aadb.TestDeviceFuncTest#testBugreport PASS </strong>
<strong>...</strong>
</pre></div><p>The tests<a id="id404" class="indexterm"/> take many hours to execute, so be patient; but you can check the status of the test:</p><div><pre class="programlisting">
<strong>cts-tf &gt; l i</strong>
<strong>Command Id  Exec Time Device State </strong>
<strong>1 8m:22 0123456789ABCDEF running cts on build 4.3_r2 </strong>
</pre></div><p>Plug in speakers to enjoy the sounds from the media tests and ringtones! Also, CTS reboots the device. If your ADB session is not restored after rebooting, ADB may not execute any tests. Use the <code class="literal">--disable-reboot</code> option when running the <code class="literal">cts-tf &gt; run cts --plan CTS --disable-reboot</code> plan.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec72"/>Gathering the results</h1></div></div></div><p>First, we'll <a id="id405" class="indexterm"/>consider the CTS results. Although we expect some failures, we also expect the problem will not get worse when we go to enforcing mode. Second, we'll look at the audit logs. Let's pull both of these files from the device.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec56"/>CTS test results</h2></div></div></div><p>CTS creates a <a id="id406" class="indexterm"/>test results directory each time it is run. CTS<a id="id407" class="indexterm"/> is indicating the directory name but not the location:</p><div><pre class="programlisting">
<strong>11-30 10:30:28 I/0123456789ABCDEF: Created result dir 2014.11.30_10.30.28</strong>
</pre></div><p>The location is mentioned by the CTS manual and can be found under the extracted CTS directory in <code class="literal">repository/results</code>, typically at <code class="literal">android-cts/repository/results</code>. The test directories contain an XML test report, <code class="literal">testResult.xml</code>. This can be opened in most web browsers. It has a nice overview of the tests and details of all executed tests. The <code class="literal">pass:fail</code> ratio is our baseline. The authors had 18,736 pass, and only 53 fail, which is fairly good considering half of those are feature issues, such as no Bluetooth or returning true for camera support.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec57"/>Audit logs</h2></div></div></div><p>We will use<a id="id408" class="indexterm"/> the audit logs to address deficiencies in our policy. Pull these<a id="id409" class="indexterm"/> off the device using the standard <code class="literal">adb pull</code> commands we have used throughout the book. Since this is a <code class="literal">userdebug</code> build and default <code class="literal">adb</code> terminals are shell <code class="literal">uid</code> (not root), start <code class="literal">adb</code> as root with <code class="literal">adb root</code>. <code class="literal">su</code> is also available on <code class="literal">userdebug</code> builds.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>You may get an error saying <code class="literal">/data/misc/audit/audit.log</code> does not exist. The solution is to run <code class="literal">adb</code> as root via the <code class="literal">adb root</code> command. Also, when running this command, it may hang. Just go to settings, disable, and then enable <strong>USB Debugging</strong> under <strong>Developer Options</strong>. Then kill the <code class="literal">adb-root</code> command and verify you have root by running <code class="literal">adb shell</code>. Now you should be a root user again.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec73"/>Authoring device policy</h1></div></div></div><p>Run both <code class="literal">audit.log</code> and <code class="literal">audit.old</code> through <code class="literal">audit2allow</code> to see what's going on. The output<a id="id410" class="indexterm"/> of <code class="literal">audit2allow</code> is grouped by source domain. Rather than going through it all, we will highlight the unusual cases, starting with the interpreted results of <code class="literal">audit2allow</code>. Assuming you are in the audit log directory, perform <code class="literal">cat audit.* | audit2allow | less</code>. Any policy work will be done in the device-specific UDOO sepolicy directory.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec58"/>adbd</h2></div></div></div><p>The following <a id="id411" class="indexterm"/>are our <code class="literal">adbd</code> denials as filtered through <code class="literal">audit2allow</code>:</p><div><pre class="programlisting">#============= adbd ==============
allow adbd ashmem_device:chr_file execute;
allow adbd dumpstate:unix_stream_socket connectto;
allow adbd dumpstate_socket:sock_file write;
allow adbd input_device:chr_file { write getattr open };
allow adbd log_device:chr_file { write read ioctl open };
allow adbd logcat_exec:file { read getattr open execute execute_no_trans };
allow adbd mediaserver:binder { transfer call };
allow adbd mediaserver:fd use;
allow adbd self:capability { net_raw dac_override };
allow adbd self:process execmem;
allow adbd shell_data_file:file { execute execute_no_trans };
allow adbd system_server:binder { transfer call };
allow adbd tmpfs:file execute;
allow adbd unlabeled:dir getattr;</pre></div><p>The denials in the <code class="literal">adbd</code> domain are quite strange. The first thing that caught our eye was the <code class="literal">execute</code> on <code class="literal">/dev/ashmem</code>, which is a character driver. Typically, this is only needed for Dalvik JIT. Looking <a id="id412" class="indexterm"/>at the raw audits (<code class="literal">cat audit.* | grep adbd | grep execute</code>), we see the following:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417416666.182:788): avc: denied { execute } for pid=3680 comm="Compiler" path=2F6465762F6173686D656D2F64616C76696B2D6A69742D636F64652D6361636865202864656C6574656429 dev=tmpfs ino=412027 scontext=u:r:adbd:s0 tcontext=u:object_r:tmpfs:s0 tclass=file</strong>
<strong>type=1400 msg=audit(1417416670.352:831): avc: denied { execute } for pid=3753 comm="Compiler" path="/dev/ashmem" dev=tmpfs ino=1127 scontext=u:r:adbd:s0 tcontext=u:object_r:ashmem_device:s0 tclass=chr_file</strong>
</pre></div><p>Something with the process <code class="literal">comm</code> field of the compiler is executing on <code class="literal">ashmem</code>. Our guess is it has something to do with Dalvik, but why is it in the <code class="literal">adbd</code> domain? Also, why is <code class="literal">adbd</code> writing to the input device? All this is strange behavior. Typically, when you see things like this, it's because the children didn't end up in the proper domain. Run this command to check the domains and confirm our suspicions:</p><div><pre class="programlisting">
<strong>$ adb shell ps -Z | grep adbd</strong>
<strong>u:r:adbd:s0 root 20046 1 /sbin/adbd</strong>
<strong>u:r:adbd:s0 root 20101 20046 ps</strong>
</pre></div><p>We then run <code class="literal">adb shell ps -Z | grep adbd</code> to see which things were running in the <code class="literal">adb</code> domain, further confirming our suspicions:</p><div><pre class="programlisting">
<strong>u:r:adbd:s0 root 20046 1 /sbin/adbd</strong>
<strong>u:r:adbd:s0 root 20101 20046 ps</strong>
</pre></div><p>The <code class="literal">ps</code> command should not be running in the <code class="literal">adbd</code> context; it should be running in <code class="literal">shell</code>. This confirmed that <code class="literal">shell</code> is not in the right domain:</p><div><pre class="programlisting">
<strong>$ adb shell</strong>
<strong>root@udoo:/ # id</strong>
<strong>uid=0(root) gid=0(root) context=u:r:adbd:s0</strong>
</pre></div><p>The first thing to check is the context on the file:</p><div><pre class="programlisting">
<strong>root@udoo:/ # ls -Z /system/bin/sh</strong>
<strong>lrwxr-xr-x root shell u:object_r:system_file:s0 sh -&gt; mksh</strong>
<strong>root@udoo:/ # ls -Z /system/bin/mksh</strong>
<strong>-rwxr-xr-x root shell u:object_r:system_file:s0 mksh</strong>
</pre></div><p>The base policy defines a domain transition when <code class="literal">adbd</code> loads the shell using <code class="literal">exec</code> to go to the shell domain. This is defined in the <code class="literal">adbd.te</code> external sepolicy as <code class="literal">domain_auto_trans(adbd, shell_exec, shell)</code>.</p><p>Obviously, an incorrect label has been applied to shell, so let's look at <code class="literal">file_contexts</code> in the external sepolicy to find out why.</p><div><pre class="programlisting">
<strong>$ cat file_contexts | grep shell_exec</strong>
<strong>/system/bin/sh -- u:object_r:shell_exec:s0</strong>
</pre></div><p>The two<a id="id413" class="indexterm"/> dashes mean that only regular files will be labeled and symbolic links will be skipped. We probably don't want to label the symlink, but rather the <code class="literal">mksh</code> destination. Do this by adding a custom <code class="literal">file_contexts</code> entry to the device UDOO sepolicy and adding the file to the <code class="literal">BOARD_SEPOLICY_UNION</code> config. In <code class="literal">file_contexts</code>, add <code class="literal">/system/bin/mksh -- u:object_r:shell_exec:s0</code>, and in <code class="literal">sepolicy.mk</code>, add <code class="literal">BOARD_SEPOLICY_UNION += file_contexts</code>.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Throughout the remainder of the chapter, whenever you create or modify policy files (for example, context files or <code class="literal">*.te</code> files), don't forget to add them to <code class="literal">BOARD_SEPOLICY_UNION</code> in <code class="literal">sepolicy.mk</code>.</p></div></div><p>Since this is a fairly fatal issue with the policy and <code class="literal">adbd</code>, we won't worry about the denials for now, with the exception of the unlabeled. Whenever one encounters an unlabeled file, it should be addressed. The <code class="literal">avc</code> denial that caused this is as follows:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405835.872:435): avc: denied { getattr } for pid=4078 comm="ls" path="/device" dev=mmcblk0p7 ino=2 scontext=u:r:adbd:s0 tcontext=u:object_r:unlabeled:s0 tclass=dir</strong>
</pre></div><p>Because this is mounted at <code class="literal">/device</code> and Android mounts are typically at <code class="literal">/</code>, we should look at the mount table:</p><div><pre class="programlisting">
<strong>root@udoo:/ # mount | grep device</strong>
<strong>/dev/block/mmcblk0p7 /device ext4 ro,seclabel,nosuid,nodev,relatime,user_xattr,barrier=1,data=ordered 0 0</strong>
</pre></div><p>Typically, mount commands are in the init scripts following a <code class="literal">mkdir</code>, or in an <code class="literal">fstab</code> file with the init built-in, <code class="literal">mount_all</code>. A quick search for <code class="literal">device</code> and <code class="literal">mkdir</code> in <code class="literal">init.rc</code> finds nothing, but we do find it in <code class="literal">fstab.freescale</code>. The device is read-only, so we should be able to give it a type, label it with file contexts, and apply the <code class="literal">getattr</code> domain to its directory class. Since it's read-only and empty, nobody should need more permissions. Looking at the <code class="literal">make_sd.sh</code> script, we notice that partition 7 of the block device is the <code class="literal">vender</code> directory. This is a misspelling of the common vendor directory that OEMs place proprietary blobs in. We place file types in <code class="literal">file.te</code> and the domain allow rules in <code class="literal">domain.te</code>.</p><p>In <code class="literal">file.te</code>, add this:</p><div><pre class="programlisting">type udoo_device_file, file_type;</pre></div><p>In <code class="literal">domain.te</code>, add the following:</p><div><pre class="programlisting">allow domain udoo_device_file:dir getattr;</pre></div><p>In <code class="literal">file_contexts</code>, add this:</p><div><pre class="programlisting">/device u:object_r:udoo_device_file:s0</pre></div><p>If this directory is not empty, you must manually run <code class="literal">restorecon -R</code> on it to label existing files.</p><p>If you pull the <a id="id414" class="indexterm"/>audit logs multiple times from the UDOO, you may also end up with denials showing that you did so, as <code class="literal">adbd</code> will not be able to access them. You may see this:</p><div><pre class="programlisting">#============= adbd ==============
allow adbd audit_log:file { read getattr open };</pre></div><p>This rule comes from the end of the test when you <code class="literal">adb pull</code>ed the audit logs. We can safely <code class="literal">dontaudit</code> this and add a <code class="literal">neverallow</code> to ensure it doesn't accidentally get allowed. The audit logs contain information a malware writer could use to navigate through the policy, and this information should be protected. In a device <code class="literal">sepolicy</code> folder, add an <code class="literal">adbd.te</code> file and union it in the <code class="literal">sepolicy.mk</code> file:</p><p>In <code class="literal">adbd.te</code>, add this:</p><div><pre class="programlisting"># dont audit adb pull and adb shell cat of audit logs
dontaudit adbd audit_log:file r_file_perms;
dontaudit shell audit_log:file r_file_perms;</pre></div><p>In <code class="literal">auditd.te</code>, add this:</p><div><pre class="programlisting"># Make sure no one adds an allow to the audit logs
# from anything but system server (read only) and
# auditd, rw access.
neverallow { domain -system_server -auditd -init -kernel } audit_log:file ~getattr;
neverallow system_server audit_log:file ~r_file_perms;</pre></div><p>If <code class="literal">auditd.te</code> is still in <code class="literal">external/sepolicy</code>, move it to <code class="literal">device/fsl/udoo/sepolicy</code> along with all dependent types.</p><p>The <code class="literal">neverallow</code> entries show you how to use the compliment, <code class="literal">~</code>, and set difference, <code class="literal">-</code>, operators for strong assertions or brevity. The first <code class="literal">neverallow</code> starts with domain, and all process types (domains) are members of the domain attribute. We prevent access through set difference, leaving the set that must never have access. We then compliment the access vector set to allow only <code class="literal">getattr</code> or <code class="literal">stat</code> on the logs. The second <code class="literal">neverallow</code> uses compliment to ensure <code class="literal">system_server</code> is limited to read operations.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec59"/>bootanim</h2></div></div></div><p>The <code class="literal">bootanim</code> domain is assigned to the boot animation service that presents splash screens<a id="id415" class="indexterm"/> on boot, typically the carrier's branding:</p><div><pre class="programlisting">#============= bootanim ==============
allow bootanim init:unix_stream_socket connectto;
allow bootanim log_device:chr_file { write open };
allow bootanim property_socket:sock_file write;</pre></div><p>Anything touching the <code class="literal">init</code> domain is a red flag. Here, <code class="literal">bootanim</code> connects to an init Unix domain socket. This is a part of the property system, and we can see that after connecting, it writes to the property socket. The socket object and its URI are separate. In this case, it's the filesystem, but it could be an anonymous socket:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405616.640:255): avc: denied { connectto } for pid=2534 comm="BootAnimation" path="/dev/socket/property_service" scontext=u:r:bootanim:s0 tcontext=u:r:init:s0 tclass=unix_stream_socket</strong>
</pre></div><p>The <code class="literal">log_device</code> is deprecated in new versions of Android and replaced with <code class="literal">logd</code>. However, we are backporting a new master sepolicy to 4.3, so we must support this. The patch that removed support is at <a class="ulink" href="https://android-review.googlesource.com/#/c/108147/">https://android-review.googlesource.com/#/c/108147/</a>.</p><p>Rather than apply a reverse patch to the external sepolicy, we can just add the rules to our device policy in a <code class="literal">domain.te</code> file. We can safely allow these using the proper macros and styles in the device UDOO <code class="literal">sepolicy</code> folder. In <code class="literal">bootanim.te</code>, add <code class="literal">unix_socket_connect(bootanim, property, init)</code>, and in <code class="literal">domain.te</code>, add this:</p><div><pre class="programlisting">allow domain udoo_device_file:dir getattr;
allow domain log_device:dir search;
allow domain log_device:chr_file rw_file_perms;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec60"/>debuggerd</h2></div></div></div><div><pre class="programlisting">#============= debuggerd ==============
allow debuggerd log_device:chr_file { write read open };
allow debuggerd system_data_file:sock_file write;</pre></div><p>The log <a id="id416" class="indexterm"/>device denial was addressed under <code class="literal">bootanim</code> by adding the allow rules for all domains to use <code class="literal">log_device</code>. The <code class="literal">system_data_file:sock_file write</code> is strange. In most circumstances, you'll almost never want to allow a cross-domain write, but this is special. Look at the raw denial:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417415122.602:502): avc: denied { write } for pid=2284 comm="debuggerd" name="ndebugsocket" dev=mmcblk0p4 ino=129525 scontext=u:r:debuggerd:s0 tcontext=u:object_r:system_data_file:s0 tclass=sock_file</strong>
</pre></div><p>The denial is on <code class="literal">ndebugsocket</code>. Grepping for this uncovers a named type transition, which policy version 23 does not support:</p><div><pre class="programlisting">
<strong>system_server.te:297:type_transition system_server system_data_file:sock_file system_ndebug_socket "ndebugsocket";</strong>
</pre></div><p>We have to <a id="id417" class="indexterm"/>change the code to set the proper context or just allow it, which we will. We won't grant additional permissions because it never asked for open, and we're crossing domains. Preventing file opens across domains is ideal, as the only way to get this file descriptor is through an IPC call into the owning domain. In <code class="literal">debuggerd.te</code>, add <code class="literal">allow debuggerd system_data_file:sock_file write;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec61"/>drmserver</h2></div></div></div><div><pre class="programlisting">#============= drmserver ==============
allow drmserver log_device:chr_file { write open };</pre></div><p>This is<a id="id418" class="indexterm"/> taken care of by <code class="literal">domain.te</code> rules, so we have nothing to do here.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec62"/>dumpstate</h2></div></div></div><div><pre class="programlisting">#============= dumpstate ==============
allow dumpstate init:binder call;
allow dumpstate init:process signal;
allow dumpstate log_device:chr_file { write read open };
allow dumpstate node:rawip_socket node_bind;
allow dumpstate self:capability sys_resource;
allow dumpstate system_data_file:file { write rename create setattr };</pre></div><p>The<a id="id419" class="indexterm"/> denial to <code class="literal">init:binder call</code> on <code class="literal">dumpstate</code> is strange because <code class="literal">init</code> doesn't use binder. Some process must stay in the init domain. Let's check our process listing for init:</p><div><pre class="programlisting">
<strong>$ adb shell ps -Z | grep init</strong>
<strong>u:r:init:s0 root 1 0 /init</strong>
<strong>u:r:init:s0 root 2286 1 zygote</strong>
<strong>u:r:init:s0 radio 2759 2286 com.android.phone</strong>
</pre></div><p>Here, <code class="literal">zygote</code> and <code class="literal">com.android.phone</code> should not be running as <code class="literal">init</code>. This must be a labeling error on the <code class="literal">app_process</code> file, which is the zygote. The <code class="literal">ls -laZ /system/bin/app_process</code> command reveals <code class="literal">u:object_r:system_file:s0 app_process</code>, so add an entry to <code class="literal">file_contexts</code> to correct this. We can find the label to use in <code class="literal">zygote.te</code> in the base sepolicy defined as the <code class="literal">zygote_exec</code> type:</p><div><pre class="programlisting"># zygote
type zygote, domain;
type zygote_exec, exec_type, file_type;</pre></div><p>In <code class="literal">file_contexts</code>, add <code class="literal">/system/bin/app_process u:object_r:zygote_exec:s0</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec63"/>installd</h2></div></div></div><p>The <a id="id420" class="indexterm"/>added <code class="literal">domain.te</code> rules handle <code class="literal">installd</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec64"/>keystore</h2></div></div></div><div><pre class="programlisting">#============= keystore ==============
allow keystore app_data_file:file write;
allow keystore log_device:chr_file { write open };</pre></div><p>The log <a id="id421" class="indexterm"/>device is taken care of by the <code class="literal">domain.te</code> rules. Let's look at the raw <code class="literal">app_data_file</code> denial:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417417454.442:845): avc: denied { write } for pid=15339 comm="onCtsTestRunner" path="/data/data/com.android.cts.stub/cache/CTS_DUMP" dev=mmcblk0p4 ino=131242 scontext=u:r:keystore:s0 tcontext=u:object_r:app_data_file:s0:c512,c768 tclass=file</strong>
</pre></div><p>Categories are defined in the contexts. This means MLS support is activated for <code class="literal">app domains</code>. In the <code class="literal">seapp_contexts</code> base sepolicy, we see this:</p><div><pre class="programlisting">user=_app domain=untrusted_app type=app_data_file levelFrom=user
user=_app seinfo=platform domain=platform_app type=app_data_file levelFrom=user</pre></div><p>MLS separation of application data is still under development and didn't work on 4.3, so we can disable this. We can just declare them in a device-specific <code class="literal">seapp_contexts</code> file. In <code class="literal">seapp_contexts</code>, add <code class="literal">user=_app domain=untrusted_app type=app_data_file</code> and <code class="literal">user=_app seinfo=platform domain=platform_app type=app_data_file</code>. In 4.3, any changes to context on data require a factory reset. The 4.4 version added smart relabel capabilities.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec65"/>mediaserver</h2></div></div></div><div><pre class="programlisting">#============= mediaserver ==============
allow mediaserver adbd:binder { transfer call };
allow mediaserver init:binder { transfer call };
allow mediaserver log_device:chr_file { write open };</pre></div><p>The log <a id="id422" class="indexterm"/>device was addressed in the <code class="literal">domain.te</code> rules. We'll skip <code class="literal">init</code> and <code class="literal">adbd</code> too, since their issues were triggered by improper process domains. It's important not to add allow rules blindly, as most of the work for existing <a id="id423" class="indexterm"/>domains can be handled with small label changes or a few rules.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec66"/>netd</h2></div></div></div><div><pre class="programlisting">#============= netd ==============
allow netd kernel:system module_request;
allow netd log_device:chr_file { write open };</pre></div><p>The log<a id="id424" class="indexterm"/> device denial of <code class="literal">netd</code> was addressed by <code class="literal">domain.te</code>. However, we should scrutinize anything requesting a capability. When granting capabilities, the policy author needs to be very careful. If a domain is granted the ability to load a system module and that domain or module binary itself is compromised, it could lead to the injection of malware into the kernel via loadable modules. However, <code class="literal">netd</code> needs loadable kernel module support to support some cards. Add the allow rule to a file called <code class="literal">netd.te</code> in the device UDOO sepolicy. In <code class="literal">netd.te</code>, add <code class="literal">allow netd self:capability sys_module;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec67"/>rild</h2></div></div></div><div><pre class="programlisting">#============= rild ==============
allow rild log_device:chr_file { write open };</pre></div><p>This is<a id="id425" class="indexterm"/> taken care of by <code class="literal">domain.te</code> rules, so we have nothing to do here.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec68"/>servicemanager</h2></div></div></div><div><pre class="programlisting">#============= servicemanager ==============
allow servicemanager init:binder transfer;
allow servicemanager log_device:chr_file { write open };</pre></div><p>Again, the<a id="id426" class="indexterm"/> log device was handled in <code class="literal">domain.te</code>. We'll skip <code class="literal">init</code>, since its issues were triggered by improper process domains.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec69"/>surfaceflinger</h2></div></div></div><div><pre class="programlisting">#============= surfaceflinger ==============
allow surfaceflinger init:binder transfer;
allow surfaceflinger log_device:chr_file { write open };</pre></div><p>Again, the <a id="id427" class="indexterm"/>log device was handled in <code class="literal">domain.te</code>. We'll skip <code class="literal">init</code> too, since its issues were triggered by improper process domains.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec70"/>system_server</h2></div></div></div><div><pre class="programlisting">#============= system_server ==============
allow system_server adbd:binder { transfer call };
allow system_server dalvikcache_data_file:file { write setattr };
allow system_server init:binder { transfer call };
allow system_server init:file write;
allow system_server init:process { setsched sigkill getsched };
allow system_server init_tmpfs:file read;
allow system_server log_device:chr_file write;</pre></div><p>Since <code class="literal">log_device</code> is taken care of by <code class="literal">domain.te</code>, and <code class="literal">init</code> and <code class="literal">adbd</code> are polluted, we will <a id="id428" class="indexterm"/>only address the Dalvik cache denial:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405611.550:159): avc: denied { write } for pid=2571 comm="er.ServerThread" name="system@app@SettingsProvider.apk@classes.dex" dev=mmcblk0p4 ino=129458 scontext=u:r:system_server:s0 tcontext=u:object_r:dalvikcache_data_file:s0 tclass=file</strong>
<strong>type=1400 msg=audit(1417405611.550:160): avc: denied { setattr } for pid=2571 comm="er.ServerThread" name="system@app@SettingsProvider.apk@classes.dex" dev=mmcblk0p4 ino=129458 scontext=u:r:system_server:s0 tcontext=u:object_r:dalvikcache_data_file:s0 tclass=file</strong>
</pre></div><p>The external sepolicy seandroid-4.3 branch allowed <code class="literal">domain.te:allow domain dalvikcache_data_file:file r_file_perms;</code>. Writes were allowed by <code class="literal">system_app</code> with <code class="literal">system_app.te:allow system_app dalvikcache_data_file:file { write setattr };</code>. We should be able to grant this write access because there may be a need to update its Dalvik cache file. In <code class="literal">domain.te</code>, add <code class="literal">allow domain dalvikcache_data_file:file r_file_perms;</code>, and in <code class="literal">system_server.te</code>, add <code class="literal">allow system_server dalvikcache_data_file:file { write setattr };</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec71"/>toolbox</h2></div></div></div><div><pre class="programlisting">#============= toolbox ==============
allow toolbox sysfs:file write;</pre></div><p>Typically, one<a id="id429" class="indexterm"/> should not write to <code class="literal">sysfs</code>. Now look at the raw denial for the offending <code class="literal">sysfs</code> file:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405599.660:43): avc: denied { write } for pid=2309 comm="cat" path="/sys/module/usbtouchscreen/parameters/calibration" dev=sysfs ino=2318 scontext=u:r:toolbox:s0 tcontext=u:object_r:sysfs:s0 tclass=file</strong>
</pre></div><p>From here, we properly label <code class="literal">/sys/module/usbtouchscreen/parameters/calibration</code>. We place an entry in <code class="literal">file_contexts</code> to label <code class="literal">sysfs</code>, declare a type in <code class="literal">file.te</code>, and allow <code class="literal">toolbox</code> access to it. In <code class="literal">file.te</code>, add <code class="literal">type sysfs_touchscreen_calibration, fs_type, sysfs_type, mlstrustedobject;</code>, and in <code class="literal">file_contexts</code>, add <code class="literal">/sys/module/usbtouchscreen/parameters/calibration -- u:object_r:sysfs_touchscreen_calibration:s0</code>, and in <code class="literal">toolbox.te</code>, add <code class="literal">allow toolbox sysfs_touchscreen_calibration:file w_file_perms;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec72"/>untrusted_app</h2></div></div></div><div><pre class="programlisting">#============= untrusted_app ==============
allow untrusted_app adb_device:chr_file getattr;
allow untrusted_app adbd:binder { transfer call };
allow untrusted_app adbd:dir { read getattr open search };
allow untrusted_app adbd:file { read getattr open };
allow untrusted_app adbd:lnk_file read;
...</pre></div><p>
<code class="literal">untrusted_app</code> had many denials. Considering the domain labeling issues, we won't address<a id="id430" class="indexterm"/> most of these now. However, you should look out for mislabeled and unlabeled target files. While searching the denial logs as interpreted by <code class="literal">audit2allow</code>, the following was found:</p><div><pre class="programlisting">allow untrusted_app device:chr_file { read getattr };
allow untrusted_app unlabeled:dir { read getattr open };</pre></div><p>For the <code class="literal">chr_file</code> device, we get this:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417416653.742:620): avc: denied { read } for pid=3696 comm="onCtsTestRunner" name="rfkill" dev=tmpfs ino=1126 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417416666.152:784): avc: denied { getattr } for pid=3696 comm="onCtsTestRunner" path="/dev/mxs_viim" dev=tmpfs ino=1131 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417416653.592:561): avc: denied { getattr } for pid=3696 comm="onCtsTestRunner" path="/dev/.coldboot_done" dev=tmpfs ino=578 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:device:s0 tclass=file</strong>
</pre></div><p>Therefore, we need to label <code class="literal">/dev/.coldboot_done</code>, <code class="literal">/dev/rfkill</code> properly, and <code class="literal">/dev/mxs_viim</code>. <code class="literal">/dev/rfkill</code> should be labeled in line with what the 4.3 policy had:</p><div><pre class="programlisting">file_contexts:/sys/class/rfkill/rfkill[0-9]*/state -- u:object_r:sysfs_bluetooth_writable:s0
file_contexts:/sys/class/rfkill/rfkill[0-9]*/type -- u:object_r:sysfs_bluetooth_writable:s0</pre></div><p>The <code class="literal">/dev/mxs_viim</code> device seems to be a globally accessible GPU. We recommend a thorough review of the source code, but for now, we will label it as <code class="literal">gpu_device</code>. <code class="literal">/dev/.coldboot_done</code> is created by <code class="literal">ueventd</code> when the <code class="literal">coldboot</code> process completes. If <code class="literal">ueventd</code> is restarted, it skips the coldboot. We don't need to label this. This denial is caused by the source domain MLS on a target file that is not a subset of the categories of the source and does not have the <code class="literal">mlstrustedsubject</code> attribute; it should go away when <a id="id431" class="indexterm"/>we drop MLS support from apps.</p><p>In <code class="literal">file_contexts</code>:</p><div><pre class="programlisting"># touch screen calibration
/sys/module/usbtouchscreen/parameters/calibration -- u:object_r:sysfs_touchscreen_calibration:s0
#BT RFKill node
/sys/class/rfkill/rfkill[0-9]*/state -- u:object_r:sysfs_bluetooth_writable:s0
/sys/class/rfkill/rfkill[0-9]*/type -- u:object_r:sysfs_bluetooth_writable:s0</pre></div></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec73"/>vold</h2></div></div></div><div><pre class="programlisting">#============= vold ==============
allow vold log_device:chr_file { write open };</pre></div><p>Again, the <a id="id432" class="indexterm"/>log device was handled in <code class="literal">domain.te</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec74"/>watchdogd</h2></div></div></div><div><pre class="programlisting">#============= watchdogd ==============
allow watchdogd device:chr_file { read write create unlink open };</pre></div><p>The<a id="id433" class="indexterm"/> raw denials from watchdog paint in interesting portrait:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405598.000:8): avc: denied { create } for pid=2267 comm="watchdogd" name="__null__" scontext=u:r:watchdogd:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417405598.000:9): avc: denied { read write } for pid=2267 comm="watchdogd" name="__null__" dev=tmpfs ino=2580 scontext=u:r:watchdogd:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417405598.000:10): avc: denied { open } for pid=2267 comm="watchdogd" name="__null__" dev=tmpfs ino=2580 scontext=u:r:watchdogd:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417405598.000:11): avc: denied { unlink } for pid=2267 comm="watchdogd" name="__null__" dev=tmpfs ino=2580 scontext=u:r:watchdogd:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>type=1400 msg=audit(1417416653.602:575): avc: denied { getattr } for pid=3696 comm="onCtsTestRunner" path="/dev/watchdog" dev=tmpfs ino=1095 scontext=u:r:untrusted_app:s0:c512,c768 tcontext=u:object_r:watchdog_device:s0 tclass=chr_file</strong>
</pre></div><p>A file is created and unlinked by <code class="literal">watchdog</code>, which keeps a handle to an anonymous file. No filesystem reference exists after the unlink, but the file descriptor is valid and only <code class="literal">watchdog</code> can use it. In this case, we can just allow watchdog this rule. In <code class="literal">watchdogd.te</code>, add <code class="literal">allow watchdogd device:chr_file create_file_perms;</code>. This rule, however, causes a <code class="literal">neverallow</code> violation in the base policy:</p><div><pre class="programlisting">
<strong>out/host/linux-x86/bin/checkpolicy: loading policy configuration from out/target/product/udoo/obj/ETC/sepolicy_intermediates/policy.conf</strong>
<strong>libsepol.check_assertion_helper: neverallow on line 5375 violated by allow watchdogd device:chr_file { read write open };</strong>
<strong>Error while expanding policy</strong>
</pre></div><p>The <code class="literal">neverallow</code> rule is in the <code class="literal">domain.te</code> base policy as <code class="literal">neverallow { domain -init -ueventd -recovery } device:chr_file { open read write };</code>. For such a simple <a id="id434" class="indexterm"/>change, we'll just modify the base sepolicy to <code class="literal">neverallow { domain -init -ueventd -recovery -watchdogd } device:chr_file { open read write };</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec75"/>wpa</h2></div></div></div><div><pre class="programlisting">#============= wpa ==============
allow wpa device:chr_file { read open };
allow wpa log_device:chr_file { write open };
allow wpa system_data_file:dir { write remove_name add_name setattr };
allow wpa system_data_file:sock_file { write create unlink setattr };</pre></div><p>Again, the<a id="id435" class="indexterm"/> log device was handled in <code class="literal">domain.te</code>. The system data accesses need further investigation, starting with the raw denials:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405614.060:193): avc: denied { setattr } for pid=2639 comm="wpa_supplicant" name="wpa_supplicant" dev=mmcblk0p4 ino=129295 scontext=u:r:wpa:s0 tcontext=u:object_r:system_data_file:s0 tclass=dir</strong>
<strong>type=1400 msg=audit(1417405614.060:194): avc: denied { write } for pid=2639 comm="wpa_supplicant" name="wlan0" dev=mmcblk0p4 ino=129318 scontext=u:r:wpa:s0 tcontext=u:object_r:system_data_file:s0 tclass=sock_file</strong>
<strong>type=1400 msg=audit(1417405614.060:195): avc: denied { write } for pid=2639 comm="wpa_supplicant" name="wpa_supplicant" dev=mmcblk0p4 ino=129295 scontext=u:r:wpa:s0 tcontext=u:object_r:system_data_file:s0 tclass=dir</strong>
<strong>type=1400 msg=audit(1417405614.060:196): avc: denied { remove_name } for pid=2639 co</strong>
</pre></div><p>The offending file was located using <code class="literal">ls -laR</code>:</p><div><pre class="programlisting">
<strong>/data/system/wpa_supplicant:</strong>
<strong>srwxrwx--- wifi wifi 2014-12-01 06:43 wlan0</strong>
</pre></div><p>This socket is created by the <code class="literal">wpa_supplicant</code> itself. Relabeling it without type transitions is impossible, so we have to allow it. In <code class="literal">wpa.te</code>, add <code class="literal">allow wpa system_data_file:dir rw_dir_perms;</code> and <code class="literal">allow wpa system_data_file:sock_file create_file_perms;</code>. The unlabeled device has already been<a id="id436" class="indexterm"/> dealt with; it was on <code class="literal">rfkill</code>:</p><div><pre class="programlisting">
<strong>type=1400 msg=audit(1417405613.640:175): avc: denied { read } for pid=2639 comm="wpa_supplicant" name="rfkill" dev=tmpfs ino=1126 scontext=u:r:wpa:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec74"/>Second policy pass</h1></div></div></div><p>After<a id="id437" class="indexterm"/> loading the drafted policy, the device still has denials on boot:</p><div><pre class="programlisting">#============= init ==============
allow init rootfs:file { write create };
allow init system_file:file execute_no_trans;
#============= shell ==============
allow shell device:chr_file { read write getattr };
allow shell system_file:file entrypoint;</pre></div><p>All of these denials should be investigated because they target sensitive types, <code class="literal">tcontext</code> specifically.</p><div><div><div><div><h2 class="title"><a id="ch13lvl2sec76"/>init</h2></div></div></div><p>The raw <a id="id438" class="indexterm"/>denials for <code class="literal">init</code> are as follows:</p><div><pre class="programlisting">
<strong>&lt;5&gt;type=1400 audit(4.380:3): avc: denied { create } for pid=2268 comm="init" name="tasks" scontext=u:r:init:s0 tcontext=u:object_r:rootfs:s0 tclass=file</strong>
<strong>&lt;5&gt;type=1400 audit(4.380:4): avc: denied { write } for pid=2268 comm="init" name="tasks" dev=rootfs ino=3080 scontext=u:r:init:s0 tcontext=u:object_r:rootfs:s0 tclass=file</strong>
</pre></div><p>These occur before <code class="literal">init</code> remounts <code class="literal">/</code> as read-only. We can safely allow these, and since <code class="literal">init</code> is running unconfined, we can just add it to <code class="literal">init.te</code>. We could add the <code class="literal">allow</code> rule to the unconfined set, but since that is going away, let's minimize the permission only to <code class="literal">init</code>:</p><div><pre class="programlisting">allow int rootfs:file create_file_perms;</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Unconfined is not completely unconfined. Rules get stripped from this domain as AOSP moves closer to zero unconfined domains.</p></div></div><p>Doing this, however, causes another <code class="literal">neverallow</code> to fail. We can modify <code class="literal">external/sepolicy domain.te</code> to bypass this. Change the <code class="literal">neverallow</code> from this:</p><div><pre class="programlisting"># Nothing should be writing to files in the rootfs.
neverallow { domain -recovery} rootfs:file { create write setattr relabelto append unlink link rename };</pre></div><p>Change it to this:</p><div><pre class="programlisting"># Nothing should be writing to files in the rootfs.
neverallow { domain -recovery -init } rootfs:file { create write setattr relabelto append unlink link rename };</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>If you need to modify <code class="literal">neverallow</code> entries to build, you will fail CTS. The proper approach is to remove this behavior from <code class="literal">init</code>.</p></div></div><p>Additionally, we <a id="id439" class="indexterm"/>need to see what is loaded with <code class="literal">exec</code> without a domain transition, causing the <code class="literal">execute_no_trans</code> denial:</p><div><pre class="programlisting">
<strong>&lt;5&gt;type=1400 audit(4.460:6): avc: denied { execute_no_trans } for pid=2292 comm="init" path="/system/bin/magd" dev=mmcblk0p5 ino=146 scontext=u:r:init:s0 tcontext=u:object_r:system_file:s0 tclass=file</strong>
<strong>&lt;5&gt;type=1400 audit(4.460:6): avc: denied { execute_no_trans } for pid=2292 comm="init" path="/system/bin/rfkill" dev=mmcblk0p5 ino=148 scontext=u:r:init:s0 tcontext=u:object_r:system_file:s0 tclass=file</strong>
</pre></div><p>To resolve this, we can relabel <code class="literal">magd</code> with its own type and place it in its own unconfined domain. A <code class="literal">neverallow</code> in the base policy forces us to move each executable into its own domain.</p><p>Create a file called <code class="literal">magd.te</code>, add it to <code class="literal">BOARD_SEPOLICY_UNION</code>, and add the following contents to it:</p><div><pre class="programlisting">type magd, domain;
type magd_exec, exec_type, file_type;
permissive_or_unconfined(magd);</pre></div><p>Also update <code class="literal">file_contexts</code> to contain this:</p><div><pre class="programlisting">/system/bin/magd  u:object_r:magd_exec:s0</pre></div><p>Repeat the steps that were done for <code class="literal">magd</code> for <code class="literal">rfkill</code>. Just replace <code class="literal">magd</code> with <code class="literal">rfkill</code> in the preceding example. Later testing revealed an entry-point denial where the source context was <code class="literal">init_shell</code> and the target was <code class="literal">rfkill_exec</code>. After adding the shell rules, it was discovered that <code class="literal">rfkill</code> is loaded using <code class="literal">exec</code> from the <code class="literal">init_shell</code> domain, so let's also add <code class="literal">domain_auto_trans(init_shell, rfkill_exec, rfkill)</code> to the <code class="literal">rfkill.te</code> file. Additionally grouped with this discovery was <code class="literal">rfkill</code> attempting to open, read, and write <code class="literal">/dev/rfkill</code>. So we must label <code class="literal">/dev/rfkill</code> with <code class="literal">rfkill_device</code>, <code class="literal">allow rfkill</code> access to it, and append <code class="literal">allow rfkill rfkill_device:chr_file rw_file_perms;</code> to the <code class="literal">rfkill.te</code> file. Create a new file to declare this device type, called <code class="literal">device.te</code>, and add <code class="literal">type rfkill_device, dev_type;</code>. After that, label it with <code class="literal">file_contexts</code> by adding <code class="literal">/dev/rfkill u:object_r:rfkill_device:s0</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec77"/>shell</h2></div></div></div><p>The first <a id="id440" class="indexterm"/>shell denial we will evaluate is the denial on <code class="literal">entrypoint</code>:</p><div><pre class="programlisting">&lt;5&gt;type=1400 audit(4.460:5): avc: denied { entrypoint } for pid=2279 comm="init" path="/system/bin/mksh" dev=mmcblk0p5 ino=154 scontext=u:r:shell:s0 tcontext=u:object_r:system_file:s0 tclass=file</pre></div><p>Since we did not label <code class="literal">mksh</code>, we need to label it now. We can create an unconfined domain for shells spawned by <code class="literal">init</code> to end up in the <code class="literal">init_shell</code> domain. The console still ends up in the <code class="literal">shell</code> domain via an explicit <code class="literal">seclabel</code>, and other invocations end up as <code class="literal">init_shell</code>. Create a new file, <code class="literal">init_shell.te</code>, and add it to <code class="literal">BOARD_SEPOLICY_UNION</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch13lvl2sec78"/>init_shell.te</h2></div></div></div><div><pre class="programlisting">type init_shell, domain;
domain_auto_trans(init, shell_exec, init_shell);
permissive_or_unconfined(init_shell);</pre></div><p>Update <code class="literal">file_contexts</code> to include this:</p><div><pre class="programlisting">/system/bin/mksh  u:object_r:shell_exec:s0;</pre></div><p>Now <a id="id441" class="indexterm"/>we will handle shell access to the raw device:</p><div><pre class="programlisting">
<strong>&lt;5&gt;type=1400 audit(6.510:7): avc: denied { read write } for pid=2279 comm="sh" name="ttymxc1" dev=tmpfs ino=122 scontext=u:r:shell:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
<strong>&lt;5&gt;type=1400 audit(7.339:8): avc: denied { getattr } for pid=2279 comm="sh" path="/dev/ttymxc1" dev=tmpfs ino=122 scontext=u:r:shell:s0 tcontext=u:object_r:device:s0 tclass=chr_file</strong>
</pre></div><p>This is just a mislabeled <code class="literal">tty</code>, so we can label this as a <code class="literal">tty_device</code>. Add the following entry to the file contexts:</p><div><pre class="programlisting">/dev/ttymxc[0-9]*  u:object_r:tty_device:s0</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec75"/>Field trials</h1></div></div></div><p>At this<a id="id442" class="indexterm"/> point, rebuild the source tree, wipe the data filesystem, flash, and re-run CTS. Repeat this until all denials are addressed.</p><p>Once you're done with CTS and internal QA trials, we recommend performing a field trial with the device in permissive mode. During this period, you should be gathering the logs and refining policy. If the domains are not stable, you can declare them as permissive in the policy file and still put the device in enforcing mode; enforcing some domains is better than enforcing none.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec76"/>Going enforcing</h1></div></div></div><p>You can<a id="id443" class="indexterm"/> pass the enforcing mode either using <code class="literal">bootloader</code> (which will not be covered here) or with the <code class="literal">init.rc</code> script early in boot time. You can do this right after <code class="literal">setcon</code>:</p><div><pre class="programlisting">setcon u:r:init:s0
setenforce 1</pre></div><p>Once this statement is compiled into the <code class="literal">init.rc</code> script, it can only be undone with a subsequent build and a reflash of <code class="literal">boot.img</code>. You can check this by running the <code class="literal">getenforce</code> command. Also, as an interesting test, you can try to run the <code class="literal">reboot</code> command from the root serial console and watch it fail:</p><div><pre class="programlisting">
<strong>root@udoo:/ # getenforce</strong>
<strong>Enforcing</strong>
<strong>root@udoo:/ # reboot</strong>
<strong>reboot: Operation not permitted</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec77"/>Summary</h1></div></div></div><p>In this chapter, all of your previous understanding of the system was used to develop real SE for Android policy for a brand new device. You are now empowered with the knowledge of how to write SELinux policy for Android, where and how the components of the system work, and how to port and enable these features on various Android platforms. Since this is a fairly new feature that influences many system interactions, issues that will require code changes as well as policy changes will arise. Understanding both is crucial.</p><p>As policy authors and security personnel in general, the responsibility to secure the system rests on our shoulders. In most organizations, you're required to work in the dark. However, if you can, do as much work and ask as many questions as you want to in the mailing list, and never accept the status quo. The SE for Android and AOSP projects welcome all to contribute, and by contributing, you will help make the project better and enhance the feature sets for all.</p></div></body></html>