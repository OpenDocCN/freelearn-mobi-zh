<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Hold onto Your Chair; Advanced Type Changes Are Here!</h1></div></div></div><p>Swift is a great language, and it's getting better with each release. So far, we've covered most of the functionality that you are likely to use in your everyday projects. We are going to cover a few improvements to the language that you might not use on a regular basis. This chapter focuses on <code class="literal">UnsafePointe<em>r</em>
</code> types, <code class="literal">typealiases</code>
<em>,</em> and floating point operations.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Unmanaged and UnsafePointer changes</h1></div></div></div><p>Brace yourself, because we are about to skim the surface of a few types that you may not have seen a lot of and whose names scream, <em>I'll pass on those</em> for the squeamish among you. For the most part, the naming conventions for types in Swift seem approachable and sane to the average developer. However, there is a subset of types that aren't even listed in the main sections of the Swift Programming language document. These are the <em>black sheep</em> types of the language. The ones with names such as <code class="literal">Unmanaged</code>, <code class="literal">UnsafeMutableRawPointer</code>, and <code class="literal">UnsafeBufferPointer</code>. These types just feel <code class="literal">unsafe</code> to use. Perhaps, the names are a big hint that you, as the developer, need to take some precautions when using these types. If you develop long enough in Swift, you will eventually come across one of these types. We might as well cover the changes for these types in Swift 3 so that you will be armed with the most current knowledge of how to use the new features when you need them.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec25"/>Changing Unmanaged to use UnsafePointer [SE-0017]</h2></div></div></div><p>
<code class="literal">Unmanaged</code> is a type in Swift that allows you to work with an <code class="literal">unmanaged</code> object reference, meaning you are responsible for the object's memory and for keeping it alive. An <code class="literal">UnsafePointer</code> is a type that represents a raw pointer to data of type pointer. You are fully responsible for managing memory with this type. Both types are useful when dealing with C APIs. C functions that accept types such as <code class="literal">void * or const void *</code> are extremely common but can present issues in Swift.</p><p>When a C API passes a <code class="literal">void *</code> or <code class="literal">const void *</code> type (or others that aren't easily coerced into a Foundation type) to Swift, the type is converted to an <code class="literal">UnsafePointer</code>. This is our first step, but not our final destination in terms of getting a type that we can use efficiently in Swift. We ultimately want an <code class="literal">Unmanaged</code> type because this type provides a type-safe wrapper around our object, even though it does not participate in <strong>Automatic Reference Counting</strong> (<strong>ARC</strong>). With an <code class="literal">Unmanaged</code> type, the developer can manually make memory decisions. In Swift 2, there was no direct conversion to allow you to go from <code class="literal">UnsafePointer</code> to <code class="literal">Unmanaged</code> type. You had to convert to a <strong>bridge type</strong> first and then convert to your preferred type at <strong>UnsafePointer </strong>| <strong>COpaquePointer</strong> | <strong>Unmanaged.</strong>
</p><p>You accomplished the conversions using one of the following methods on the <code class="literal">Unmanaged</code> type:</p><pre class="programlisting">static func fromOpaque(value: COpaquePointer) -&gt; Unmanaged&lt;Instance&gt; &#13;
func toOpaque() -&gt; COpaquePointer &#13;
</pre><p>In Swift 2:</p><pre class="programlisting">let str0: CFString = "Test string" as CFString &#13;
let bits: Unmanaged&lt;CFString&gt; = Unmanaged.passRetained(str0) &#13;
let oPtr: COpaquePointer = bits.toOpaque() &#13;
let ptr: UnsafePointer&lt;CFString&gt; = UnsafePointer(oPtr) &#13;
 &#13;
let oPtr2 = COpaquePointer(ptr) &#13;
let str1: Unmanaged&lt;CFString&gt; = Unmanaged.fromOpaque(oPtr2) &#13;
str1.takeRetainedValue() &#13;
</pre><p>In Swift 3, we can now convert directly between <code class="literal">Unmanaged</code> and <code class="literal">UnsafePointer</code>. The <code class="literal">fromOpaque</code> and <code class="literal">toOpaque</code> methods replace <code class="literal">COpaquePointer</code> with <code class="literal">UnsafeRawPointer</code> and <code class="literal">UnsafeMutableRawPointer</code> types. We essentially streamlined our code by eliminating the middleman.</p><pre class="programlisting"> static func fromOpaque(_ value: UnsafeRawPointer) -&gt; Unmanaged&lt;Instance&gt; &#13;
func toOpaque() -&gt; UnsafeMutableRawPointer &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">let str0: CFString = "Test string" as CFString &#13;
let bits = Unmanaged.passUnretained(str0) &#13;
let ptr = bits.toOpaque() &#13;
 &#13;
let str1: Unmanaged&lt;CFString&gt; = Unmanaged.fromOpaque(ptr) &#13;
str1.takeRetainedValue() &#13;
</pre><div><div><h3 class="title"><a id="note42"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md">https://github.com/apple/swift-evolution/blob/master/proposals/0017-convert-unmanaged-to-use-unsafepointer.md</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec26"/>Making UnsafePointer explicit using Optional [SE-0055]</h2></div></div></div><p>Unlike in Objective-C, where you can mark pointers as <code class="literal">nullable</code> or <code class="literal">nonnull</code>, Swift does not have a way to determine if a pointer is null. Therefore, when you obtain a reference to an <code class="literal">UnsafePointer&lt;T&gt;</code>, you could be holding a pointer to null. This is an issue because an <code class="literal">UnsafePointer</code> (and similar types) are essentially referencing C pointers. If the developer's code is not expecting or accounting for null values, then the program could crash. This is particularly troubling in Swift due to the fact that every non-trivial operation you could perform using an <code class="literal">UnsafePointer</code> relies on a valid underlying pointer that is not null.</p><p>Fortunately, we don't have to deal with this in Swift for built-in types, classes, and structures, because we have optionals. As we know, <code class="literal">optionals</code> let us deal with situations in which our type may or may not contain a value. New in Swift 3, we can apply <code class="literal">optionals</code> to <code class="literal">UnsafePointer</code> types. When you know for sure that your pointer can't be null, you use the regular form: <code class="literal">UnsafePointer&lt;T&gt;</code>. When you want to represent a <code class="literal">nullable</code> version, you use the optional syntax (<code class="literal">UnsafePointer&lt;T&gt;?</code>).</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md">https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec27"/>Adding UnsafeRawPointer [SE-0107]</h2></div></div></div><p>Swift added the <code class="literal">UnsafePointer </code>type to interoperate with C APIs and to facilitate building high performance data structures (think low-level graphics programming or heavy math-based modeling). In this respect, <code class="literal">UnsafePointer</code> is an important addition to Swift. Unfortunately, the implementation of <code class="literal">UnsafePointer</code> allows the developer to bypass the safety measures put in place to ensure type safe memory access. It's possible to use <code class="literal">UnsafePointer</code> types to violate compiler logic. The violation would normally cause a compilation error. However, the compiler has a built-in exception for the <code class="literal">UnsafePointer</code> type and allows the compilation to proceed. In many cases, running a program that uses the typed memory access to reference a memory location of a different type will cause that program to crash. Swift 3 introduces <code class="literal">UnsafeRawPointer</code> to deal with un-typed memory. Let's use an example to illustrate type memory access abuse.</p><p>In Swift 2:</p><pre class="programlisting">let msg: CFString = "just a few characters" as CFString &#13;
let unmgd: Unmanaged&lt;CFString&gt; = Unmanaged.passRetained(msg) &#13;
let ptr: UnsafeMutablePointer&lt;CFString&gt; = UnsafeMutablePointer(unmgd.toOpaque()) &#13;
// reassign pointer address with new value &#13;
ptr[0] = "testing..." as CFString &#13;
// use typed access of Int to access CFSTring memory location &#13;
let u = UnsafePointer&lt;Int&gt;(ptr)[0] &#13;
</pre><p>In our type memory access example, we create an <code class="literal">UnsafeMutablePointer&lt;CFString&gt;</code> to reference a typed block of memory. Then, we change the value in the first block to a new <code class="literal">CFString</code>, testing our pointer. Everything is fine so far. Next, we create an <code class="literal">UnsafePointer&lt;Int&gt;</code> from the existing memory location. Note that we bound our type to an <em>Int</em> versus the <code class="literal">CFString</code> we used in the original pointer. If we use this <em>Int</em> pointer, our program could crash. Even though the compiler finds this code to be suspicious, it allows compilation because we are using <code class="literal">UnsafePointer</code> types, which are on the compiler's exception list for certain types of operations. To correct the problem in our example, we need to use a type that can access memory without needing to know the type. <code class="literal">UnsafeRawPointer</code> and <code class="literal">UnsafeMutableRawPointer</code> were introduced in Swift 3 to do this very thing.</p><p>
<strong>Takeaways:</strong>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Raw</em> types allow un-typed access to memory; <em>Typed</em> versions access memory using their types</li><li class="listitem" style="list-style-type: disc"><em>Raw</em> access essentially allows C type <code class="literal">memcopy</code> operations, while <em>Typed</em> access follows type aliasing rules</li><li class="listitem" style="list-style-type: disc">C types are now imported as <code class="literal">UnsafeMutableRawPointer</code> and <code class="literal">UnsafeRawPointer</code> when the type isn't clear (for example, <code class="literal">const void *</code> or <code class="literal">void *</code>) and are imported as <code class="literal">UnsafePointer&lt;T&gt;</code> and <code class="literal">UnsafeMutablePointer&lt;T&gt;</code> when their type can be determined (for example, <code class="literal">const T*</code>)</li></ul></div><div><div><h3 class="title"><a id="note44"/>Note</h3><p>You can read one proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md">https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Type aliases and protocol changes</h1></div></div></div><p>Type aliases are named types that fill in for existing types in Swift. Once defined, you can use these types anywhere in your code. Swift 3 now supports type aliases based on generics. In addition, type aliases are now supported for protocols and protocol extensions. Speaking of protocols, Swift 3 made a change to protocol use that makes things simpler and paves the way for expected future changes to this feature. Let's add the new changes more closely and work through some examples.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Generic type aliases [SE-0048]</h2></div></div></div><p>Generic type aliases are a new addition for Swift 3. As a reminder, a type alias is a way to declare a named alias for an existing type in the language. After you create your named alias, you can use the aliased type in your code just as you would any other type. Generic type aliases allow you to add type parameters that can be used in defining a generic type. Let's consider a few examples to show the new possibilities you have with creating type aliases in Swift 3:</p><pre class="programlisting">    typealias ScoreBag&lt;T&gt; = [T]&#13;
    typealias TriplePointTuple&lt;T&gt; = (T,T,T)&#13;
    typealias AddPlotter&lt;X:Hashable,Y&gt; = Dictionary&lt;X, Y&gt;&#13;
    typealias UndoItem&lt;T&gt; = [Date:T]&#13;
</pre><div><div><h3 class="title"><a id="note45"/>Note</h3><p>You can read another proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md">https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md</a>.</p></div></div><div><div><h3 class="title"><a id="note46"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md">https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md</a>.</p></div></div><p>In prior versions of Swift, you needed to use the <code class="literal">protocol&lt;...&gt;</code> syntax when you were defining a type that adhered to multiple protocols. In Swift 3, you now use <em>&amp;</em> between each protocol that your type adopts. This is merely syntactical sugar today, but will serve as the base for defining more generic types in future additions of Swift.</p><p>In Swift 2:</p><pre class="programlisting">protocol Driving {} &#13;
protocol Parking {} &#13;
protocol Braking {} &#13;
struct Car: Driving, Parking, Braking {} &#13;
let zoomzoom: protocol&lt;Driving, Braking, Parking&gt; = Car() &#13;
</pre><p>In Swift 3:</p><pre class="programlisting">let zoomzoom: Driving &amp; Braking &amp; Parking = Car() &#13;
</pre><p>To better convey the intent of a compound type built from individual protocols, the Swift team now prefers using <em>&amp;</em> to a comma for defining multiple protocols on a type.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Type aliases in protocols and protocol extensions [SE-0092]</h2></div></div></div><p>Swift 2.2 introduced the <strong>associatedtype</strong> keyword to handle associated types in protocols. This change removed the confusion around using the <em>typealias</em> keyword because it is now only tasked with defining types. An additional benefit of adding the <em>associatedtype</em> keyword is that it allows us to make type aliases in protocols and protocol extensions that are based on the associated types. Looking at the <em>Sequence</em> protocol from the standard library, we can see that <em>Iterator</em> is defined as an associated type that inherits the <em>IteratorProtocol</em>. With Swift 3, I can now add a type alias named <em>Element</em> that indirectly references an associated type on the <em>IteratorProtocol</em> to make my syntax cleaner. Further, I can use any of the type aliases I create in my protocol with my protocol extensions as well.</p><p>In Swift 3:</p><pre class="programlisting">public protocol Sequence { &#13;
 &#13;
    associatedtype Iterator : IteratorProtocol &#13;
    &#13;
    typealias Element = Iterator.Element &#13;
 &#13;
    public func makeIterator() -&gt; Iterator &#13;
 &#13;
   func map&lt;T&gt;(_ transform: (Element) throws -&gt; T)  &#13;
rethrows -&gt; [T] &#13;
 &#13;
} &#13;
</pre><p>In the preceding <em>Sequence</em> protocol, I can use my type alias <code class="literal">Element</code> in the <code class="literal">map()</code> function. In previous versions of Swift, you would have had to use <code class="literal">Iterator.Element</code>.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md">https://github.com/apple/swift-evolution/blob/master/proposals/0092-typealiases-in-protocols.md</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Floating point changes</h1></div></div></div><p>Floating-point types are used to hold fractional numbers. The main floating-point types in the standard library are <code class="literal">Float</code> and <code class="literal">Double</code>. The Swift team created a <code class="literal">FloatingPoint </code>protocol to hold common math operations, making it easier for you to create functions that support all of the floating-point types available. In this section, we will cover additions to the <code class="literal">FloatingPoint</code> protocol and rounding functions.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Enhanced Floating point protocols [SE-0067]</h2></div></div></div><p>The current <code class="literal">FloatingPoint</code> protocol doesn't provide a full set of features to really conform to an IEEE 754 <a class="ulink" href="https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008">https://en.wikipedia.org/wiki/IEEE_floating_point#CITEREFIEEE_7542008</a> type. The changes to the <code class="literal">FloatingPoint</code> protocol are meant to expand coverage of the operations that most would expect to be included. A second protocol <code class="literal">BinaryFloatingPoint</code> (conforms to <code class="literal">FloatingPoint</code>) has also been added to Swift and will be useful for generic programming.</p><p>The <code class="literal">FloatingPoint</code> protocol now contains most of the IEEE 754 basic operations. The <code class="literal">BinaryFloatingPoint</code> protocol additionally conforms to <code class="literal">FloatLiteralConvertible</code>. You can perform normal arithmetic and comparison operations using the <code class="literal">FloatingPoint</code> protocol and more complex operations that work best using floating-point types that have a fixed radix 2 using the <code class="literal">BinaryFloatingPoint</code> protocol.</p><p>There are many new operations defined on the <code class="literal">FloatingPoint</code> and <code class="literal">BinaryFloatingPoint</code> protocols, and I'll leave exploring them to you as a future exercise.</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md">https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec32"/>New rounding functions on the FloatingPoint protocol [SE-0113]</h2></div></div></div><p>The Swift standard library does not have built-in methods to implement rounding functions such as <code class="literal">floor()</code> or <code class="literal">ceil()</code>. When you need those methods, you have to import <code class="literal">Darwin</code> or <code class="literal">Glibc</code> to access the versions implemented using C. In Swift 3, the Swift team added new rounding methods on the <code class="literal">FloatingPoint</code> protocol. Rounding and/or converting floating-point types to integers are operations the protocol should handle.</p><p>The changes to the <code class="literal">FloatingPoint</code> protocol consist of adding the <code class="literal">FloatingPointRoundingRule</code> enumeration and two rounding methods, <code class="literal">round()</code> and <code class="literal">rounded()</code>:</p><pre class="programlisting">public func rounded(_ rule: FloatingPointRoundingRule) -&gt; Self &#13;
public mutating func round(_ rule: FloatingPointRoundingRule) &#13;
public mutating func round() &#13;
 &#13;
public enum FloatingPointRoundingRule { &#13;
   case toNearestOrAwayFromZero &#13;
   case toNearestOrEven &#13;
   case up &#13;
         case down &#13;
   case towardZero &#13;
   case awayFromZero &#13;
} &#13;
</pre><p>With the new native implementation of the rounding methods, you will be able to replicate behavior that you get with <code class="literal">ceil</code> and <code class="literal">floor</code>, for example:</p><pre class="programlisting">(10.5).rounded(.down) // -&gt; 10.0 &#13;
(5.2).rounded(.up) // -&gt; 6.0 &#13;
</pre><div><div><h3 class="title"><a id="note49"/>Note</h3><p>You can read the proposal at <a class="ulink" href="https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md">https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Summary</h1></div></div></div><p>We covered changes to <code class="literal">Unmanaged</code>, <code class="literal">UnsafePointer</code>, and similar types used when working with C APIs. You learned about Swift 2's compiler quirk when using these types and how things have improved in Swift 3. Next, we covered type alias changes, their use with protocols, and protocol extensions. Finally, we explored changes to the FloatingPoint protocol. In the next chapter, we cover new additions to the Foundation framework.</p></div></body></html>