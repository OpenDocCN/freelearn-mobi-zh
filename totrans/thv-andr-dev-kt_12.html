<html><head></head><body>
<div id="_idContainer072" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor180" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-179" class="calibre5"><a id="_idTextAnchor181" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1"> Extending Video Playback in Your Packtflix App</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Have you ever wanted your users to continue enjoying their favorite videos even when they switch apps or turn off the screen? </span><span class="kobospan" id="kobo.3.2">This chapter dives deep into the world of extended video playback on Android, bringing you the skills to create a more engaging and versatile </span><span><span class="kobospan" id="kobo.4.1">user experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">We’ll be exploring </span><a id="_idIndexMarker1014" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.6.1">two key functionalities: </span><strong class="bold"><span class="kobospan" id="kobo.7.1">picture-in-picture</span></strong><span class="kobospan" id="kobo.8.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.9.1">PiP</span></strong><span class="kobospan" id="kobo.10.1">) mode and media casting. </span><span class="kobospan" id="kobo.10.2">With PiP, you’ll learn how to create a miniature video player that overlays other apps, allowing users to keep an eye on the video while multitasking. </span><span class="kobospan" id="kobo.10.3">With media casting, we’ll use </span><strong class="source-inline"><span class="kobospan" id="kobo.11.1">MediaRouter</span></strong><span class="kobospan" id="kobo.12.1"> and the Cast SDK, which enable users to transfer the video playback to a larger screen, such as a TV with </span><span><span class="kobospan" id="kobo.13.1">Google Chromecast.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">By the end of this chapter, you’ll have gained a solid understanding of the PiP functionalities and unlocked the potential of extended video playback in our </span><span><span class="kobospan" id="kobo.15.1">Android app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">So, in this chapter, we will cover the </span><span><span class="kobospan" id="kobo.17.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.18.1">Getting to know the </span><span><span class="kobospan" id="kobo.19.1">PiP API</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.20.1">Using PiP to continue playback in </span><span><span class="kobospan" id="kobo.21.1">the background</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.22.1">Getting to </span><span><span class="kobospan" id="kobo.23.1">know </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.24.1">MediaRouter</span></strong></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.25.1">Connecting to Google </span><span><span class="kobospan" id="kobo.26.1">Chromecast devices</span></span></li>
</ul>
<h1 id="_idParaDest-180" class="calibre5"><a id="_idTextAnchor182" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.27.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">As in the previous chapter, you will need to have installed Android Studio (or another editor of </span><span><span class="kobospan" id="kobo.29.1">your preference).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">We will follow the project started in </span><a href="B19443_07.xhtml#_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.31.1">Chapter 7</span></em></span></a><span class="kobospan" id="kobo.32.1"> with the changes we have made in </span><a href="B19443_08.xhtml#_idTextAnchor160" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.33.1">Chapter 8</span></em></span></a><span><span class="kobospan" id="kobo.34.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">You can find the complete code that we are going to build through this chapter available in this </span><span><span class="kobospan" id="kobo.36.1">repository: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.37.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9</span></span></a><span><span class="kobospan" id="kobo.38.1">.</span></span></p>
<h1 id="_idParaDest-181" class="calibre5"><a id="_idTextAnchor183" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.39.1">Getting to know the PiP API</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">The first step on our extended video playback journey is to understand the PiP API, which lets us </span><a id="_idIndexMarker1015" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.41.1">use PiP mode. </span><strong class="bold"><span class="kobospan" id="kobo.42.1">PiP mode</span></strong><span class="kobospan" id="kobo.43.1"> allows users to minimize your app and continue watching a video in a resizable and movable miniature player. </span><span class="kobospan" id="kobo.43.2">This functionality enhances user experience by providing flexibility </span><span><span class="kobospan" id="kobo.44.1">and convenience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">This section will </span><a id="_idIndexMarker1016" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1">provide you with the knowledge to leverage PiP effectively in your app. </span><span class="kobospan" id="kobo.46.2">We’ll cover the most important aspects such as understanding the PiP requirements and learning how to enter and exit PiP mode programmatically, and review some different listener events. </span><span class="kobospan" id="kobo.46.3">So, let’s </span><span><span class="kobospan" id="kobo.47.1">get started.</span></span></p>
<h2 id="_idParaDest-182" class="calibre7"><a id="_idTextAnchor184" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1">PiP requirements</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.49.1">Not every device is created equal when it comes to PiP. </span><span class="kobospan" id="kobo.49.2">Before we go deep into the exciting </span><a id="_idIndexMarker1017" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.50.1">functionalities, let’s ensure a smooth user experience by understanding the requirements and compatibility aspects of </span><span><span class="kobospan" id="kobo.51.1">PiP mode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Regarding the requirements, there are two variables to take </span><span><span class="kobospan" id="kobo.53.1">into account:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.54.1">Minimum Android version</span></strong><span class="kobospan" id="kobo.55.1">: PiP mode relies on specific APIs introduced in Android 8.0 (Oreo). </span><span class="kobospan" id="kobo.55.2">Targeting devices running older versions of Android will not only prevent PiP functionality but could also lead to crashes or </span><span><span class="kobospan" id="kobo.56.1">unexpected behavior.</span></span><p class="calibre3"><span class="kobospan" id="kobo.57.1">To check if the user’s device is compatible with PiP, we could implement the </span><span><span class="kobospan" id="kobo.58.1">following code:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.59.1">
val minApiLevel = Build.VERSION_CODES.O
if (android.os.Build.VERSION.SDK_INT &lt; minApiLevel) {
  // PiP not supported on this device
  return false
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.60.1">This code ensures our app gracefully handles devices that can’t use PiP mode. </span><span class="kobospan" id="kobo.60.2">First, we define the minimum Android version required for PiP (typically Android 8.0 or Oreo). </span><span class="kobospan" id="kobo.60.3">Then, we check the device’s current version. </span><span class="kobospan" id="kobo.60.4">If it’s older than the minimum, the code </span><a id="_idIndexMarker1018" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.61.1">recognizes that PiP functionality isn’t available and signals this back (potentially by returning </span><strong class="source-inline"><span class="kobospan" id="kobo.62.1">false</span></strong><span class="kobospan" id="kobo.63.1">) to prevent the app from attempting to use PiP features that would cause issues on </span><span><span class="kobospan" id="kobo.64.1">incompatible devices.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.65.1">This allows you to gracefully handle situations where PiP isn’t available and potentially offer alternative functionalities for users on older devices (for example, we could offer them to send the playback to a </span><span><span class="kobospan" id="kobo.66.1">different device).</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.67.1">Screen size requirements</span></strong><span class="kobospan" id="kobo.68.1">: While PiP mode can be technically implemented on various screen sizes, smaller displays might not provide an optimal user experience. </span><span class="kobospan" id="kobo.68.2">Imagine trying to watch a movie in a tiny PiP window on a phone with a 4-inch screen! </span><span class="kobospan" id="kobo.68.3">Therefore, it’s essential to consider screen </span><span><span class="kobospan" id="kobo.69.1">size limitations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Now that we’ve established the requirements, let’s explore the exciting part: initiating PiP mode within </span><span><span class="kobospan" id="kobo.71.1">our app.</span></span></p>
<h2 id="_idParaDest-183" class="calibre7"><a id="_idTextAnchor185" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.72.1">Entering and exiting PiP mode programmatically</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">As we already </span><a id="_idIndexMarker1019" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.74.1">know, PiP mode offers users the convenience of continuing video playback in a miniature window even when they switch apps or turn off the screen. </span><span class="kobospan" id="kobo.74.2">To do this, we’ll use the </span><strong class="source-inline"><span class="kobospan" id="kobo.75.1">enterPictureInPictureMode()</span></strong><span class="kobospan" id="kobo.76.1"> method available in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">Activity</span></strong></span><span><span class="kobospan" id="kobo.78.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.79.1">
activity.enterPictureInPictureMode()</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.80.1">Calling this method allows you to programmatically trigger PiP mode from within your activity, and the system will handle resizing the video player window and placing it on top of other apps. </span><span class="kobospan" id="kobo.80.2">It’s important to note that you should typically only call this method when the user explicitly requests it, such as upon tapping a dedicated PiP button within your </span><span><span class="kobospan" id="kobo.81.1">app’s UI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.82.1">While entering PiP mode is initiated programmatically, exiting is primarily user-driven. </span><span class="kobospan" id="kobo.82.2">The user can exit PiP mode by swiping the miniature player away or tapping a designated </span><strong class="bold"><span class="kobospan" id="kobo.83.1">Close</span></strong><span class="kobospan" id="kobo.84.1"> button provided by the system. </span><span class="kobospan" id="kobo.84.2">However, as developers, we can still play a role in ensuring a smooth transition back to the fullscreen experience. </span><span class="kobospan" id="kobo.84.3">The system triggers specific </span><a id="_idIndexMarker1020" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.85.1">callbacks within your activity when PiP mode is exited. </span><span class="kobospan" id="kobo.85.2">Here’s how we can utilize </span><span><span class="kobospan" id="kobo.86.1">these callbacks:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.87.1">
override fun onPictureInPictureExited() {
  super.onPictureInPictureExited()
  // Any logic that we want to add when the user comes back
     to the full screen experience in our app
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.88.1">This function will be called every time the user closes the PiP miniature screen. </span><span class="kobospan" id="kobo.88.2">This is not the only function that we can use to handle PiP status changes, though; the listener provides various events to keep our app informed about changes in the PiP window. </span><span class="kobospan" id="kobo.88.3">These events allow us to react and update our app’s behavior accordingly, ensuring a seamless </span><span><span class="kobospan" id="kobo.89.1">user experience:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.90.1">OnPictureInPictureEntered()</span></strong><span class="kobospan" id="kobo.91.1">: This event gets triggered when the user successfully enters PiP mode. </span><span class="kobospan" id="kobo.91.2">You can use this opportunity to potentially update UI elements to reflect the PiP state (for example, hide unnecessary controls) or perform any necessary optimizations for PiP playback (for example, adjust </span><span><span class="kobospan" id="kobo.92.1">video quality).</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.93.1">OnPictureInPictureExited()</span></strong><span class="kobospan" id="kobo.94.1">: As discussed previously, this event signifies the user exiting PiP mode. </span><span class="kobospan" id="kobo.94.2">Here, you can clean up resources associated with the PiP window or update the UI to reflect the return to </span><span><span class="kobospan" id="kobo.95.1">fullscreen playback.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.96.1">OnPictureInPictureUiStateChanged()</span></strong><span class="kobospan" id="kobo.97.1">: This event gets fired whenever any change occurs to the PiP window, such as resizing or moving it. </span><span class="kobospan" id="kobo.97.2">You might use this to adjust your UI layout based on the new PiP window dimensions or update video playback based on potential performance changes due </span><span><span class="kobospan" id="kobo.98.1">to resizing.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">By effectively </span><a id="_idIndexMarker1021" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.100.1">handling PiP events and listener callbacks, you can keep your app in sync with the changing PiP window state. </span><span class="kobospan" id="kobo.100.2">Now, let’s see how we can integrate it into our </span><span><span class="kobospan" id="kobo.101.1">existing project.</span></span></p>
<h1 id="_idParaDest-184" class="calibre5"><a id="_idTextAnchor186" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.102.1">Using PiP to continue playback in the background</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.103.1">The first </span><a id="_idIndexMarker1022" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.104.1">step before we can use PiP in our project is that we must declare support for it in our </span><strong class="source-inline"><span class="kobospan" id="kobo.105.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.106.1"> file. </span><span class="kobospan" id="kobo.106.2">This step is crucial for informing the Android system that our </span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">PlaybackActivity</span></strong><span class="kobospan" id="kobo.108.1"> class is capable of running in PiP mode. </span><span class="kobospan" id="kobo.108.2">We do this </span><span><span class="kobospan" id="kobo.109.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.110.1">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest
    xmlns:android =
        "http://schemas.android.com/apk/res/android"&gt;
    &lt;application&gt;
        &lt;activity
            android:name = "com.packt.playback.presentation
                .PlaybackActivity"
            android:supportsPictureInPicture="true"
            android:resizeableActivity="true"
            android:screenOrientation="landscape"/&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.111.1">For PiP specifically, the key attribute in our manifest </span><span><span class="kobospan" id="kobo.112.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">android:supportsPicture</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.114.1">
InPicture="true"</span></strong><span class="kobospan" id="kobo.115.1">, which explicitly declares that your activity supports </span><span><span class="kobospan" id="kobo.116.1">PiP mode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">resizeableActivity</span></strong><span class="kobospan" id="kobo.119.1"> attribute, while related to the ability of an activity to be resized, is implicitly set to </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">true</span></strong><span class="kobospan" id="kobo.121.1"> for all activities when targeting API level 24 or higher. </span><span class="kobospan" id="kobo.121.2">This means if your app targets API level 24+, you don’t need to explicitly set </span><strong class="source-inline"><span class="kobospan" id="kobo.122.1">resizeableActivity="true"</span></strong><span class="kobospan" id="kobo.123.1"> for PiP mode to work because the system already considers </span><a id="_idIndexMarker1023" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.124.1">all activities to be resizable to support </span><span><span class="kobospan" id="kobo.125.1">multi-window mode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">However, explicitly setting </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">resizeableActivity="true"</span></strong><span class="kobospan" id="kobo.128.1"> can be a good practice for clarity, especially if your app is designed to take advantage of multi-window features beyond just PiP, or if you want to ensure compatibility across different Android versions and devices. </span><span class="kobospan" id="kobo.128.2">It’s also useful for documentation purposes, making it clear to anyone reading your </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.130.1"> file that your activity is intended to support resizable behaviors, </span><span><span class="kobospan" id="kobo.131.1">including PiP.</span></span></p>
<h2 id="_idParaDest-185" class="calibre7"><a id="_idTextAnchor187" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.132.1">Implementing PiP</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">Now that </span><a id="_idIndexMarker1024" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.134.1">we have explicitly opted in our </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">Activity</span></strong><span class="kobospan" id="kobo.136.1"> class to use the PiP feature, let’s implement it. </span><span class="kobospan" id="kobo.136.2">We will override the </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">onUserLeaveHint()</span></strong><span class="kobospan" id="kobo.138.1"> callback, which is triggered when the user presses the </span><strong class="bold"><span class="kobospan" id="kobo.139.1">Home</span></strong><span class="kobospan" id="kobo.140.1"> button or switches to </span><span><span class="kobospan" id="kobo.141.1">another app:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.142.1">
override fun onUserLeaveHint() {
    super.onUserLeaveHint()
    val aspectRatio = Rational(16, 9)
    val params = PictureInPictureParams.Builder()
        .setAspectRatio(aspectRatio)
        .build()
    enterPictureInPictureMode(params)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.143.1">As we said, we are overriding the </span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">onUserLeaveHint()</span></strong><span class="kobospan" id="kobo.145.1"> existing function. </span><span class="kobospan" id="kobo.145.2">Here, we still have to include the call to </span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">super.onUserLeaveHint()</span></strong><span class="kobospan" id="kobo.147.1"> as it ensures that the </span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">Activity</span></strong><span class="kobospan" id="kobo.149.1"> class properly handles any additional underlying operations defined by Android’s framework before executing </span><span><span class="kobospan" id="kobo.150.1">custom behavior.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.151.1">Within this method, the aspect ratio for the PiP window is defined as </span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">16:9</span></strong><span class="kobospan" id="kobo.153.1">, a common choice for video content, by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">Rational</span></strong><span class="kobospan" id="kobo.155.1"> class. </span><span class="kobospan" id="kobo.155.2">This aspect ratio is crucial as it dictates the proportional relationship between the width and height of the PiP window, ensuring the video maintains its intended appearance </span><span><span class="kobospan" id="kobo.156.1">without distortion.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.157.1">To apply </span><a id="_idIndexMarker1025" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.158.1">this aspect ratio, the </span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">PictureInPictureParams.Builder</span></strong><span class="kobospan" id="kobo.160.1"> class is utilized to construct a configuration object. </span><span class="kobospan" id="kobo.160.2">By invoking </span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">setAspectRatio(aspectRatio)</span></strong><span class="kobospan" id="kobo.162.1"> on the builder, the previously defined aspect ratio is applied to </span><span><span class="kobospan" id="kobo.163.1">this configuration.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">While </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">setAspectRatio(Rational)</span></strong><span class="kobospan" id="kobo.166.1"> sets the preferred aspect ratio of the PiP window, meaning that the system will try to maintain this aspect ratio when displaying the PiP window, it may not always be possible depending on the device and screen size constraints. </span><span class="kobospan" id="kobo.166.2">Android 11 (API level 30) introduced </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">setMaxAspectRatio(Rational)</span></strong><span class="kobospan" id="kobo.168.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">setMinAspectRatio(Rational)</span></strong><span class="kobospan" id="kobo.170.1"> for defining the maximum and minimum aspect ratios. </span><span class="kobospan" id="kobo.170.2">Additionally, </span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">setMaxSize(int, int)</span></strong><span class="kobospan" id="kobo.172.1"> allows setting the maximum size of the PiP window, providing greater control over how the PiP window appears on </span><span><span class="kobospan" id="kobo.173.1">different devices.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.174.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.175.1">There are also other </span><strong class="source-inline1"><span class="kobospan" id="kobo.176.1">PictureInPictureParams.Builder</span></strong><span class="kobospan" id="kobo.177.1"> options that could be applied. </span><span class="kobospan" id="kobo.177.2">For more information about these options, refer to the </span><span><span class="kobospan" id="kobo.178.1">documentation: </span></span><a href="https://developer.android.com/reference/android/app/PictureInPictureParams.Builder" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.179.1">https://developer.android.com/reference/android/app/PictureInPictureParams.Builder</span></span></a><span><span class="kobospan" id="kobo.180.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.181.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">build()</span></strong><span class="kobospan" id="kobo.183.1"> method then </span><a id="_idIndexMarker1026" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.184.1">compiles these configurations into a </span><strong class="source-inline"><span class="kobospan" id="kobo.185.1">PictureInPictureParams</span></strong><span class="kobospan" id="kobo.186.1"> object, which encapsulates all the necessary settings for entering </span><span><span class="kobospan" id="kobo.187.1">PiP mode.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">Finally, the </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">enterPictureInPictureMode(params)</span></strong><span class="kobospan" id="kobo.190.1"> method is invoked, signaling the system to transition the current </span><strong class="source-inline"><span class="kobospan" id="kobo.191.1">Activity</span></strong><span class="kobospan" id="kobo.192.1"> class into PiP mode using the </span><span><span class="kobospan" id="kobo.193.1">specified parameters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.194.1">Now that we have integrated this feature, when we are on the playback screen and we leave the application, we should still see the video on the </span><span><span class="kobospan" id="kobo.195.1">PiP screen:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer068">
<span class="kobospan" id="kobo.196.1"><img alt="Figure 9.1: Playback using the PiP feature" src="image/B19443_09_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.197.1">Figure 9.1: Playback using the PiP feature</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.198.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">PictureInPictureParams.Builder</span></strong><span class="kobospan" id="kobo.200.1"> class in Android provides a customizable </span><a id="_idIndexMarker1027" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.201.1">way to configure the behavior and appearance of an app when it enters PiP mode. </span><span class="kobospan" id="kobo.201.2">Apart from setting the aspect ratio with </span><strong class="source-inline"><span class="kobospan" id="kobo.202.1">setAspectRatio()</span></strong><span class="kobospan" id="kobo.203.1">, as we did in the previous instruction, there are several other options available to tailor the </span><span><span class="kobospan" id="kobo.204.1">PiP experience:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.205.1">Actions</span></strong><span class="kobospan" id="kobo.206.1">: Using </span><strong class="source-inline1"><span class="kobospan" id="kobo.207.1">setActions(List&lt;RemoteAction&gt;)</span></strong><span class="kobospan" id="kobo.208.1">, developers can specify a list </span><a id="_idIndexMarker1028" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.209.1">of actions that the user can perform while in PiP mode. </span><span class="kobospan" id="kobo.209.2">These actions are represented as </span><strong class="source-inline1"><span class="kobospan" id="kobo.210.1">RemoteAction</span></strong><span class="kobospan" id="kobo.211.1"> objects and can include things such as play, pause, or skip. </span><span class="kobospan" id="kobo.211.2">These actions appear as buttons in the PiP window, providing interactive elements for the user without needing to return to the full </span><span><span class="kobospan" id="kobo.212.1">app interface.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.213.1">Auto enter/exit</span></strong><span class="kobospan" id="kobo.214.1">: Through </span><strong class="source-inline1"><span class="kobospan" id="kobo.215.1">setAutoEnterEnabled(boolean)</span></strong><span class="kobospan" id="kobo.216.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.217.1">setAutoExitEnabled(boolean)</span></strong><span class="kobospan" id="kobo.218.1"> (introduced in later Android versions), developers </span><a id="_idIndexMarker1029" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.219.1">can control whether the app should automatically enter or exit PiP mode based on certain conditions, such as media </span><span><span class="kobospan" id="kobo.220.1">playback state.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.221.1">Seamless resize</span></strong><span class="kobospan" id="kobo.222.1">: By invoking </span><strong class="source-inline1"><span class="kobospan" id="kobo.223.1">setSeamlessResizeEnabled(boolean)</span></strong><span class="kobospan" id="kobo.224.1">, it’s possible to enable or disable </span><a id="_idIndexMarker1030" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.225.1">seamless resizing for the PiP window. </span><span class="kobospan" id="kobo.225.2">This option, available in later Android versions, helps make the transition into and out of PiP mode </span><span><span class="kobospan" id="kobo.226.1">smoother visually.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.227.1">Source rect hint</span></strong><span class="kobospan" id="kobo.228.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">setSourceRectHint(Rect)</span></strong><span class="kobospan" id="kobo.230.1"> allows developers to suggest </span><a id="_idIndexMarker1031" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.231.1">a preferred area of the screen that the PiP mode should try to align with when entering PiP mode. </span><span class="kobospan" id="kobo.231.2">This can be useful for guiding the system on where the PiP window should ideally be placed based on the app’s </span><span><span class="kobospan" id="kobo.232.1">UI layout.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.233.1">Let’s use these </span><a id="_idIndexMarker1032" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.234.1">options to add actions so that the user can toggle between play and pause in the PiP view. </span><span class="kobospan" id="kobo.234.2">But first, a </span><span><span class="kobospan" id="kobo.235.1">little theory.</span></span></p>
<h2 id="_idParaDest-186" class="calibre7"><a id="_idTextAnchor188" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.236.1">Understanding how to add actions to the PiP mode</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.237.1">Integrating actions into PiP mode enhances user interaction by allowing direct control over app </span><a id="_idIndexMarker1033" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.238.1">functionality without leaving the PiP window. </span><span class="kobospan" id="kobo.238.2">By using the </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">setActions(List&lt;RemoteAction&gt;)</span></strong><span class="kobospan" id="kobo.240.1"> method, you can create a more immersive and user-friendly experience, offering controls such as play, pause, or skip directly within the PiP overlay. </span><span class="kobospan" id="kobo.240.2">This capability is especially valuable in media applications, where users often need to manage playback without disrupting their current </span><span><span class="kobospan" id="kobo.241.1">onscreen activities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.242.1">In a moment, we will learn how to effectively create and manage these </span><strong class="source-inline"><span class="kobospan" id="kobo.243.1">RemoteAction</span></strong><span class="kobospan" id="kobo.244.1"> objects, ensuring our app’s PiP mode is both functional and engaging, complementing the existing array of PiP features. </span><span class="kobospan" id="kobo.244.2">But let’s dig into the </span><span><span class="kobospan" id="kobo.245.1">concepts further.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.246.1">Each </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">RemoteAction</span></strong><span class="kobospan" id="kobo.248.1"> object represents an actionable element in the PiP window, such as a button for play, pause, or skip functionality. </span><span class="kobospan" id="kobo.248.2">To create these actions, we would have to specify an icon, a title, a </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">PendingIntent</span></strong><span class="kobospan" id="kobo.250.1"> object that defines the action to take when the user interacts with the button, and a description for </span><span><span class="kobospan" id="kobo.251.1">accessibility purposes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">The utilization of a </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">PendingIntent</span></strong><span class="kobospan" id="kobo.254.1"> object is crucial here, as it allows the action to trigger specific behaviors in your app when invoked. </span><span class="kobospan" id="kobo.254.2">An </span><strong class="source-inline"><span class="kobospan" id="kobo.255.1">Intent</span></strong><span class="kobospan" id="kobo.256.1"> object in Android is like a message that can signify a wide range of events, including system boot completion, network changes, or custom events defined by the application. </span><span class="kobospan" id="kobo.256.2">Typically, these intents </span><a id="_idIndexMarker1034" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.257.1">are directed toward a </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.259.1"> instance within </span><span><span class="kobospan" id="kobo.260.1">your application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.261.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.263.1"> instance in Android is a fundamental component that enables applications to listen for and respond to broadcast messages from other applications or from the system itself.  </span><span class="kobospan" id="kobo.263.2">When an intent that matches a </span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.265.1"> instance’s filter is broadcasted, the </span><strong class="source-inline"><span class="kobospan" id="kobo.266.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.267.1"> instance’s </span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">onReceive()</span></strong><span class="kobospan" id="kobo.269.1"> method is invoked, allowing the app to execute logic in response to the event. </span><span class="kobospan" id="kobo.269.2">This mechanism provides a powerful way for applications to react to global system events or inter-app communication without needing to be running in the foreground, making </span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.271.1"> instances a key tool for event-driven programming </span><span><span class="kobospan" id="kobo.272.1">in Android.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.273.1">In our case, this </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.275.1"> instance is responsible for listening to and processing the broadcasted intents sent by PiP actions. </span><span class="kobospan" id="kobo.275.2">For instance, when a user presses the </span><strong class="bold"><span class="kobospan" id="kobo.276.1">Play</span></strong><span class="kobospan" id="kobo.277.1"> button in the PiP window, the </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">PendingIntent</span></strong><span class="kobospan" id="kobo.279.1"> object associated with the play action is broadcasted, and the corresponding receiver in your app catches this intent and triggers the media </span><span><span class="kobospan" id="kobo.280.1">to play.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.281.1">The need for a </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.283.1"> instance arises from the decoupled nature of PiP action intents from direct method calls within your app. </span><span class="kobospan" id="kobo.283.2">Since these actions occur outside the regular UI flow, using a broadcast mechanism allows your app to respond to these actions asynchronously and perform the necessary operations, such as updating the media playback state. </span><span class="kobospan" id="kobo.283.3">This setup ensures that your app can handle PiP controls effectively, providing a seamless experience for users even when interacting with the app from the </span><span><span class="kobospan" id="kobo.284.1">PiP window.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.285.1">Now that we know how to create </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">RemoteAction</span></strong><span class="kobospan" id="kobo.287.1"> objects, let’s apply our learnings in </span><span><span class="kobospan" id="kobo.288.1">our project.</span></span></p>
<h2 id="_idParaDest-187" class="calibre7"><a id="_idTextAnchor189" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.289.1">Adding actions to the PiP mode</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.290.1">Let’s start </span><a id="_idIndexMarker1035" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.291.1">by creating our </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.293.1"> subclass. </span><span class="kobospan" id="kobo.293.2">This class will extend </span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.295.1"> and override the </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">onReceive()</span></strong><span class="kobospan" id="kobo.297.1"> method, where you’ll define how your app should react to PiP action </span><span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">Intent</span></strong></span><span><span class="kobospan" id="kobo.299.1"> objects:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.300.1">
class PiPActionReceiver(private val togglePlayPause: () -&gt; Unit) : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent:
    Intent?) {
        when (intent?.action) {
            ACTION_TOGGLE_PLAY -&gt; {
                togglePlayPause()
            }
        }
    }
    companion object {
        const val ACTION_TOGGLE_PLAY =
            "com.packflix.action.TOGGLE_PLAY"
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.301.1">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">onReceive</span></strong><span class="kobospan" id="kobo.303.1"> method, a check is performed on the </span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">Intent</span></strong><span class="kobospan" id="kobo.305.1"> action to determine if it matches the </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">ACTION_TOGGLE_PLAY</span></strong><span class="kobospan" id="kobo.307.1"> action. </span><span class="kobospan" id="kobo.307.2">If it does, the play/pause toggle logic will be executed. </span><span class="kobospan" id="kobo.307.3">In this case, we will execute a callback, as the logic to play or pause the playback will likely be outside </span><span><span class="kobospan" id="kobo.308.1">this receiver.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.309.1">Next, we need to register the </span><strong class="source-inline"><span class="kobospan" id="kobo.310.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.311.1"> instance so that it can receive the </span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">Intent</span></strong><span class="kobospan" id="kobo.313.1"> object. </span><span class="kobospan" id="kobo.313.2">This can be done in </span><span><span class="kobospan" id="kobo.314.1">two ways:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.315.1">Manifest declaration</span></strong><span class="kobospan" id="kobo.316.1">: Registering in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.317.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.318.1"> file is suitable </span><a id="_idIndexMarker1036" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.319.1">for actions that should be received even if your app is not running. </span><span class="kobospan" id="kobo.319.2">However, for PiP actions, dynamic registration in the activity or service that handles PiP mode is often </span><span><span class="kobospan" id="kobo.320.1">more appropriate.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.321.1">Dynamic registration</span></strong><span class="kobospan" id="kobo.322.1">: Since PiP actions are specifically related to when our app is </span><a id="_idIndexMarker1037" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.323.1">in PiP mode, registering the </span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.325.1"> instance dynamically in our </span><strong class="source-inline1"><span class="kobospan" id="kobo.326.1">PlaybackActivity</span></strong><span class="kobospan" id="kobo.327.1"> class allows for more control and is </span><span><span class="kobospan" id="kobo.328.1">contextually relevant.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.329.1">We will </span><a id="_idIndexMarker1038" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.330.1">register the </span><strong class="source-inline"><span class="kobospan" id="kobo.331.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.332.1"> instance using dynamic registration. </span><span class="kobospan" id="kobo.332.2">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">PlaybackActivity</span></strong><span class="kobospan" id="kobo.334.1"> class, the implementation will look </span><span><span class="kobospan" id="kobo.335.1">like this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.336.1">
private lateinit var pipActionReceiver: PiPActionReceiver
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    pipActionReceiver = PiPActionReceiver {
        //TODO handle there the play/pause logic
    }
    val filter =
        IntentFilter(PiPActionReceiver.ACTION_TOGGLE_PLAY)
    if (Build.VERSION.SDK_INT &gt;=
    Build.VERSION_CODES.TIRAMISU) {
        registerReceiver(pipActionReceiver, filter,
            RECEIVER_NOT_EXPORTED)
    } else {
        registerReceiver(pipActionReceiver, filter)
    }
    setContent {
        PlaybackScreen()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.337.1">First, we will </span><a id="_idIndexMarker1039" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.338.1">declare a </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.340.1"> variable named </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">pipActionReceiver</span></strong><span class="kobospan" id="kobo.342.1">. </span><span class="kobospan" id="kobo.342.2">This receiver is not initialized immediately (it is declared as </span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">lateinit var</span></strong><span class="kobospan" id="kobo.344.1">) because it will be set up in the </span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">onCreate</span></strong><span class="kobospan" id="kobo.346.1"> method of </span><span><span class="kobospan" id="kobo.347.1">our activity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.348.1">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">onCreate</span></strong><span class="kobospan" id="kobo.350.1"> method, we will initialize the </span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.352.1"> variable. </span><span class="kobospan" id="kobo.352.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.353.1">pipActionReceiver</span></strong><span class="kobospan" id="kobo.354.1"> variable is instantiated and assigned a lambda function as its argument. </span><span class="kobospan" id="kobo.354.2">This function is intended to contain the logic that handles the </span><span><span class="kobospan" id="kobo.355.1">play/pause action.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">Then, we will register the </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.358.1"> variable, indicating the </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">Intent</span></strong><span class="kobospan" id="kobo.360.1"> filter signal it will listen to. </span><span class="kobospan" id="kobo.360.2">The registration method differs depending on the </span><span><span class="kobospan" id="kobo.361.1">SDK version:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.362.1">For SDK versions Tiramisu (Android 13, API level 33) and above, you use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.363.1">registerReceiver</span></strong><span class="kobospan" id="kobo.364.1"> method with an additional flag, </span><strong class="source-inline1"><span class="kobospan" id="kobo.365.1">RECEIVER_NOT_EXPORTED</span></strong><span class="kobospan" id="kobo.366.1">, for enhanced security, ensuring that your receiver does not inadvertently become accessible to </span><span><span class="kobospan" id="kobo.367.1">other apps.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.368.1">For earlier versions, you register the receiver without this flag. </span><span class="kobospan" id="kobo.368.2">This ensures backward compatibility while adhering to best practices for app security on </span><span><span class="kobospan" id="kobo.369.1">newer devices.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.370.1">Now, let’s create the action that will trigger the </span><strong class="source-inline"><span class="kobospan" id="kobo.371.1">Intent</span></strong><span class="kobospan" id="kobo.372.1"> action needed to launch the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">BroadcastReceiver</span></strong></span><span><span class="kobospan" id="kobo.374.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.375.1">
private fun getIntentForTogglePlayPauseAction():
RemoteAction {
    val icon: Icon = Icon.createWithResource(this,
        R.drawable.baseline_play_arrow_24)
    val intent =
    Intent(PiPActionReceiver.ACTION_TOGGLE_PLAY).let {
   intent -&gt;
        PendingIntent.getBroadcast(this, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or
                PendingIntent.FLAG_IMMUTABLE)
    }
    return RemoteAction(icon, "Toggle Play", "Play or pause
        the video", intent)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.376.1">In this code, we are creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.377.1">RemoteAction</span></strong><span class="kobospan" id="kobo.378.1"> method. </span><span class="kobospan" id="kobo.378.2">The first line inside the method </span><a id="_idIndexMarker1040" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.379.1">creates an </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">Icon</span></strong><span class="kobospan" id="kobo.381.1"> object from a drawable resource </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">(R.drawable.baseline_play_arrow_24)</span></strong><span class="kobospan" id="kobo.383.1">. </span><span class="kobospan" id="kobo.383.2">This icon visually represents the toggle play/pause action to </span><span><span class="kobospan" id="kobo.384.1">the user.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.385.1">Then, a new </span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">Intent</span></strong><span class="kobospan" id="kobo.387.1"> object is instantiated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.388.1">PiPActionReceiver.ACTION_TOGGLE_PLAY</span></strong><span class="kobospan" id="kobo.389.1"> action. </span><span class="kobospan" id="kobo.389.2">This </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">Intent</span></strong><span class="kobospan" id="kobo.391.1"> object is designed to be broadcasted when the </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">RemoteAction</span></strong><span class="kobospan" id="kobo.393.1"> method is invoked by the user. </span><span class="kobospan" id="kobo.393.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">let</span></strong><span class="kobospan" id="kobo.395.1"> block is utilized to directly chain the creation of a </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">PendingIntent</span></strong><span class="kobospan" id="kobo.397.1"> object that wraps this </span><strong class="source-inline"><span class="kobospan" id="kobo.398.1">Intent</span></strong><span class="kobospan" id="kobo.399.1"> object, making it executable from outside the </span><span><span class="kobospan" id="kobo.400.1">application context.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.401.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.402.1">PendingIntent.getBroadcast</span></strong><span class="kobospan" id="kobo.403.1"> method is called to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">PendingIntent</span></strong><span class="kobospan" id="kobo.405.1"> object that broadcasts the </span><strong class="source-inline"><span class="kobospan" id="kobo.406.1">Intent</span></strong><span class="kobospan" id="kobo.407.1"> object. </span><span class="kobospan" id="kobo.407.2">This </span><strong class="source-inline"><span class="kobospan" id="kobo.408.1">PendingIntent</span></strong><span class="kobospan" id="kobo.409.1"> object is configured with </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">PendingIntent.FLAG_UPDATE_CURRENT</span></strong><span class="kobospan" id="kobo.411.1"> to ensure that if the pending </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">Intent</span></strong><span class="kobospan" id="kobo.413.1"> object already exists, it will be reused but with its extra data updated. </span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">PendingIntent.FLAG_IMMUTABLE</span></strong><span class="kobospan" id="kobo.415.1"> is used for security purposes, marking the </span><strong class="source-inline"><span class="kobospan" id="kobo.416.1">Intent</span></strong><span class="kobospan" id="kobo.417.1"> object as immutable to prevent alterations </span><span><span class="kobospan" id="kobo.418.1">after creation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.419.1">Finally, a </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">RemoteAction</span></strong><span class="kobospan" id="kobo.421.1"> object is instantiated and returned. </span><span class="kobospan" id="kobo.421.2">This object takes the previously created icon, a title (</span><strong class="bold"><span class="kobospan" id="kobo.422.1">Toggle Play</span></strong><span class="kobospan" id="kobo.423.1">), a content description (</span><strong class="bold"><span class="kobospan" id="kobo.424.1">Play or pause the video</span></strong><span class="kobospan" id="kobo.425.1">), and the </span><strong class="source-inline"><span class="kobospan" id="kobo.426.1">PendingIntent</span></strong><span class="kobospan" id="kobo.427.1"> object as its parameters. </span><span class="kobospan" id="kobo.427.2">The title and content description should be concise yet descriptive enough to inform the user of the action’s purpose, adhering to </span><span><span class="kobospan" id="kobo.428.1">accessibility standards.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.429.1">Now, we </span><a id="_idIndexMarker1041" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.430.1">need to configure this action as a parameter for our PiP configuration. </span><span class="kobospan" id="kobo.430.2">We will modify the existing configuration </span><span><span class="kobospan" id="kobo.431.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.432.1">
override fun onUserLeaveHint() {
    super.onUserLeaveHint()
    val aspectRatio = Rational(16, 9)
    val params = PictureInPictureParams.Builder()
        .setAspectRatio(aspectRatio)
        .setActions(listOf(
            getIntentForTogglePlayPauseAction()))
        .build()
    enterPictureInPictureMode(params)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.433.1">Here, we are </span><a id="_idIndexMarker1042" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.434.1">using the </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">setActions()</span></strong><span class="kobospan" id="kobo.436.1"> function to add a list including the </span><span><span class="kobospan" id="kobo.437.1">new action.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.438.1">The last step is to handle the logic to effectively toggle between play and pause. </span><span class="kobospan" id="kobo.438.2">We already have this functionality implemented in the </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">ViewModel</span></strong><span class="kobospan" id="kobo.440.1"> component, so we just have to inject the </span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">PlaybackViewModel</span></strong><span class="kobospan" id="kobo.442.1"> component in the </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">Activity</span></strong><span class="kobospan" id="kobo.444.1"> class and call the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">togglePlayPause()</span></strong></span><span><span class="kobospan" id="kobo.446.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.447.1">
@AndroidEntryPoint
class PlaybackActivity: ComponentActivity() {
    private val viewModel: PlaybackViewModel by
    viewModels()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        pipActionReceiver = PiPActionReceiver {
            viewModel.togglePlayPause()
        }
        ...
</span><span class="kobospan1" id="kobo.447.2">    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.448.1">As we </span><a id="_idIndexMarker1043" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.449.1">can see, we are injecting </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">PlaybackViewModel</span></strong><span class="kobospan" id="kobo.451.1"> and then, </span><span><span class="kobospan" id="kobo.452.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.453.1">viewModel.toggle</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">
PlayPause()</span></strong><span class="kobospan" id="kobo.455.1"> function will be invoked when the receiver detects that the user has sent a broadcast with the </span><span><span class="kobospan" id="kobo.456.1">play/pause action.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.457.1">If we execute the code with these changes, we should see the </span><strong class="bold"><span class="kobospan" id="kobo.458.1">Play</span></strong><span class="kobospan" id="kobo.459.1"> button in our </span><span><span class="kobospan" id="kobo.460.1">PiP UI:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<span class="kobospan" id="kobo.461.1"><img alt="Figure 9.2: PiP view with some actions" src="image/B19443_09_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.462.1">Figure 9.2: PiP view with some actions</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.463.1">Having </span><a id="_idIndexMarker1044" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.464.1">implemented PiP mode, let’s move on to connecting with other devices for media playback using the </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">MediaRouter</span></strong><span class="kobospan" id="kobo.466.1"> API, which allows your app to cast or stream content to devices such as smart TVs or Chromecast. </span><span class="kobospan" id="kobo.466.2">We’ll cover how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.467.1">MediaRouter</span></strong><span class="kobospan" id="kobo.468.1"> to identify compatible devices and manage media streaming to them, enhancing our </span><span><span class="kobospan" id="kobo.469.1">app’s functionality.</span></span></p>
<h1 id="_idParaDest-188" class="calibre5"><a id="_idTextAnchor190" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.470.1">Getting to know MediaRouter</span></h1>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.471.1">MediaRouter</span></strong><span class="kobospan" id="kobo.472.1"> is a pivotal component in Android development, especially for applications that deal with multimedia content. </span><span class="kobospan" id="kobo.472.2">It acts as a bridge between devices running your </span><a id="_idIndexMarker1045" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.473.1">app and external devices such as Google Chromecast, smart TVs, and various speakers that support media </span><span><span class="kobospan" id="kobo.474.1">routing capabilities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.475.1">The core function of </span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">MediaRouter</span></strong><span class="kobospan" id="kobo.477.1"> is to facilitate the streaming of multimedia content—be it audio, video, or images—from the user’s current device to another device that provides a better or more suitable playback experience. </span><span class="kobospan" id="kobo.477.2">It intelligently discovers available media routes and allows the application to connect to them, thereby extending the multimedia capabilities beyond the confines of the user’s </span><span><span class="kobospan" id="kobo.478.1">primary device.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.479.1">Android’s </span><strong class="source-inline"><span class="kobospan" id="kobo.480.1">MediaRouter</span></strong><span class="kobospan" id="kobo.481.1"> API provides a framework that developers can utilize to search for and interact with media route providers registered on the local network. </span><span class="kobospan" id="kobo.481.2">These providers represent devices or services capable of media playback. </span><span class="kobospan" id="kobo.481.3">With </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">MediaRouter</span></strong><span class="kobospan" id="kobo.483.1">, applications can not only discover these routes dynamically but also present the user with a streamlined interface for choosing their preferred playback devices, all while managing the connections and playback state seamlessly </span><span><span class="kobospan" id="kobo.484.1">across devices.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.485.1">The use of </span><strong class="source-inline"><span class="kobospan" id="kobo.486.1">MediaRouter</span></strong><span class="kobospan" id="kobo.487.1"> in Android apps opens up a myriad of possibilities for enhancing </span><a id="_idIndexMarker1046" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.488.1">the user’s media consumption experience. </span><span class="kobospan" id="kobo.488.2">Here are some typical </span><span><span class="kobospan" id="kobo.489.1">use cases:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.490.1">Casting videos to larger screens</span></strong><span class="kobospan" id="kobo.491.1">: One of the most common uses of </span><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">MediaRouter</span></strong><span class="kobospan" id="kobo.493.1"> is casting videos from a mobile device to a larger display, such as a smart TV or a monitor with Chromecast. </span><span class="kobospan" id="kobo.493.2">This is particularly appealing for watching movies, TV shows, or user-generated content on a bigger screen that offers a more immersive </span><span><span class="kobospan" id="kobo.494.1">viewing experience.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.495.1">Streaming music to external speakers</span></strong><span class="kobospan" id="kobo.496.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.497.1">MediaRouter</span></strong><span class="kobospan" id="kobo.498.1"> allows apps to stream music to external speakers, amplifying the audio experience. </span><span class="kobospan" id="kobo.498.2">This is ideal for parties, workouts, or simply enhancing the quality of music playback beyond what the phone’s or tablet’s built-in speakers </span><span><span class="kobospan" id="kobo.499.1">can provide.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.500.1">Displaying images on a shared screen</span></strong><span class="kobospan" id="kobo.501.1">: Apps can use </span><strong class="source-inline1"><span class="kobospan" id="kobo.502.1">MediaRouter</span></strong><span class="kobospan" id="kobo.503.1"> to send images to a smart TV or a connected display, making it perfect for sharing photos with a group, conducting presentations, or viewing artwork in </span><span><span class="kobospan" id="kobo.504.1">higher resolution.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.505.1">Gaming</span></strong><span class="kobospan" id="kobo.506.1">: With the capability to cast screen content to a larger display, gaming apps can leverage </span><strong class="source-inline1"><span class="kobospan" id="kobo.507.1">MediaRouter</span></strong><span class="kobospan" id="kobo.508.1"> to provide a console-like gaming experience on the TV while using the mobile device as </span><span><span class="kobospan" id="kobo.509.1">a controller.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.510.1">Fitness and education</span></strong><span class="kobospan" id="kobo.511.1">: For apps focused on fitness or education, casting instructional </span><a id="_idIndexMarker1047" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.512.1">videos or workout routines to a TV allows users to follow along more comfortably </span><span><span class="kobospan" id="kobo.513.1">and effectively.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.514.1">In each of these use cases, </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">MediaRouter</span></strong><span class="kobospan" id="kobo.516.1"> significantly enhances the functionality of apps by leveraging the power of connected devices, thus offering users a more flexible and enriched media playback experience. </span><span class="kobospan" id="kobo.516.2">Through its comprehensive API, developers can create applications that are not just confined to the small screens of mobile devices but are instead capable of bringing content to life on any compatible device within the </span><span><span class="kobospan" id="kobo.517.1">home network.</span></span></p>
<h2 id="_idParaDest-189" class="calibre7"><a id="_idTextAnchor191" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.518.1">Setting up MediaRouter</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.519.1">Integrating </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">MediaRouter</span></strong><span class="kobospan" id="kobo.521.1"> into our Android app involves a few key setup steps, including </span><a id="_idIndexMarker1048" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.522.1">adding the necessary dependencies to your project and ensuring you have the correct permissions </span><span><span class="kobospan" id="kobo.523.1">in place.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.524.1">First, we’ll need to include the </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">MediaRouter</span></strong><span class="kobospan" id="kobo.526.1"> library dependencies in our </span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">libs.versions.toml</span></strong><span class="kobospan" id="kobo.528.1"> file. </span><span class="kobospan" id="kobo.528.2">This library provides the classes and interfaces needed to discover and interact with media </span><span><span class="kobospan" id="kobo.529.1">route providers:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.530.1">
[versions]
...
</span><span class="kobospan1" id="kobo.530.2">mediarouter = "1.7.0"
google-cast = "21.4.0"
[libraries]
...
</span><span class="kobospan1" id="kobo.530.3">media-router = { group = "androidx.mediarouter", name="mediarouter", version.ref="mediarouter"}
google-cast = { group = "com.google.android.gms", name="play-services-cast-framework", version.ref="google-cast"}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.531.1">As we plan to support casting to Chromecast devices or other Google Cast-enabled devices, we need the </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">play-services-cast-framework</span></strong><span class="kobospan" id="kobo.533.1"> library. </span><span class="kobospan" id="kobo.533.2">This library facilitates the integration with Google Cast devices and extends the capabilities </span><span><span class="kobospan" id="kobo.534.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.535.1">MediaRouter</span></strong></span><span><span class="kobospan" id="kobo.536.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.537.1">The next step </span><a id="_idIndexMarker1049" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.538.1">will be to add it to our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">build.gradle</span></strong></span><span><span class="kobospan" id="kobo.540.1"> module:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.541.1">
    implementation(libs.media.router)
    implementation(libs.google.cast)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.542.1">Now, to enable </span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">MediaRouter</span></strong><span class="kobospan" id="kobo.544.1"> to discover and interact with devices on the local network, we must declare the necessary permissions in our app’s </span><span><strong class="source-inline"><span class="kobospan" id="kobo.545.1">AndroidManifest.xml</span></strong></span><span><span class="kobospan" id="kobo.546.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.547.1">
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt;
&lt;uses-permission android:name="android.permission.INTERNET"/&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_CONNECT" /&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_SCAN" /&gt;
&lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS" /&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.548.1">We are including permissions here for </span><span><span class="kobospan" id="kobo.549.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.550.1">Internet permission</span></strong><span class="kobospan" id="kobo.551.1">: Since </span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">MediaRouter</span></strong><span class="kobospan" id="kobo.553.1"> may use the network to communicate with media route providers, your app needs permission to access the internet. </span><span class="kobospan" id="kobo.553.2">We have already needed to declare this permission for the previous chapters, so it shouldn’t </span><span><span class="kobospan" id="kobo.554.1">be new.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.555.1">Network state permissions</span></strong><span class="kobospan" id="kobo.556.1">: These permissions are required for the app to monitor changes in network connectivity, which is essential for discovering devices on </span><span><span class="kobospan" id="kobo.557.1">the network.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.558.1">Local network permissions (Android 12 and above)</span></strong><span class="kobospan" id="kobo.559.1">: Starting with Android 12 (API level 31), if your app targets API level 31 or higher and needs to discover devices on the local network, you must also declare </span><span><span class="kobospan" id="kobo.560.1">the permission.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.561.1">Post notifications</span></strong><span class="kobospan" id="kobo.562.1">: For Android 12+, to access the local network for device discovery, it is mandatory to have </span><span><span class="kobospan" id="kobo.563.1">this permission.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.564.1">After adding </span><a id="_idIndexMarker1050" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.565.1">the necessary dependencies and permissions, our project is ready to use </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">MediaRouter</span></strong><span class="kobospan" id="kobo.567.1"> for discovering media route providers and enabling media streaming to </span><span><span class="kobospan" id="kobo.568.1">external devices.</span></span></p>
<h2 id="_idParaDest-190" class="calibre7"><a id="_idTextAnchor192" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.569.1">Discovering media routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.570.1">Once your app is set up with the necessary </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">MediaRouter</span></strong><span class="kobospan" id="kobo.572.1"> dependencies and permissions, the </span><a id="_idIndexMarker1051" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.573.1">next step is discovering available </span><a id="_idIndexMarker1052" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.574.1">media routes. </span><span class="kobospan" id="kobo.574.2">This involves identifying external devices or services your app can stream media to. </span><span class="kobospan" id="kobo.574.3">Android’s </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">MediaRouter</span></strong><span class="kobospan" id="kobo.576.1"> framework simplifies this by providing tools to both discover media routes and present them </span><span><span class="kobospan" id="kobo.577.1">to users.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.578.1">Learning about MediaRouteProvider</span></h3>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.579.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.580.1"> is a component that publishes media routes to </span><strong class="source-inline"><span class="kobospan" id="kobo.581.1">MediaRouter</span></strong><span class="kobospan" id="kobo.582.1">. </span><span class="kobospan" id="kobo.582.2">It acts </span><a id="_idIndexMarker1053" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1">as a bridge between your app </span><a id="_idIndexMarker1054" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.584.1">and external devices or services, such as speakers, TVs, or other Cast-enabled devices. </span><span class="kobospan" id="kobo.584.2">There are two options to use  </span><span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">MediaRouteProvider</span></strong></span><span><span class="kobospan" id="kobo.586.1">:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.587.1">The </span><a id="_idIndexMarker1055" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.588.1">default </span><strong class="source-inline1"><span class="kobospan" id="kobo.589.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.590.1"> implementation: For most use cases, especially when integrating with Google Cast devices, Android provides a default </span><strong class="source-inline1"><span class="kobospan" id="kobo.591.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.592.1"> implementation, so you don’t need to implement your own. </span><span class="kobospan" id="kobo.592.2">The Google Cast framework automatically discovers compatible devices and makes them available as </span><span><span class="kobospan" id="kobo.593.1">media routes.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.594.1">A custom </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.596.1"> implementation: If you need to discover devices </span><a id="_idIndexMarker1056" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.597.1">for a custom protocol or a specific type of media routing not covered by Google Cast, you can implement your own </span><strong class="source-inline1"><span class="kobospan" id="kobo.598.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.599.1"> instance by extending the </span><strong class="source-inline1"><span class="kobospan" id="kobo.600.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.601.1"> class. </span><span class="kobospan" id="kobo.601.2">This involves defining the discovery logic and publishing routes </span><span><span class="kobospan" id="kobo.602.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">MediaRouter</span></strong></span><span><span class="kobospan" id="kobo.604.1">.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.605.1">However, creating a custom </span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">MediaRouteProvider</span></strong><span class="kobospan" id="kobo.607.1"> implementation is beyond the scope </span><a id="_idIndexMarker1057" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.608.1">of basic media routing and requires in-depth knowledge </span><a id="_idIndexMarker1058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.609.1">of the specific hardware or protocol you’re targeting. </span><span class="kobospan" id="kobo.609.2">If you want to know more, here is the official documentation to create a customized </span><strong class="source-inline"><span class="kobospan" id="kobo.610.1">MediaRouteProvider</span></strong> <span><span class="kobospan" id="kobo.611.1">implementation: </span></span><a href="https://developer.android.com/media/routing/mediarouteprovider" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.612.1">https://developer.android.com/media/routing/mediarouteprovider</span></span></a><span><span class="kobospan" id="kobo.613.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.614.1">We will use the default </span><strong class="source-inline"><span class="kobospan" id="kobo.615.1">MediaRouteProvider</span></strong> <span><span class="kobospan" id="kobo.616.1">implementation instead.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.617.1">Using the MediaRouter class</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.618.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">MediaRouter</span></strong><span class="kobospan" id="kobo.620.1"> class is your primary tool for interacting with media routes. </span><span class="kobospan" id="kobo.620.2">Here’s how you </span><a id="_idIndexMarker1059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.621.1">can use it to discover and monitor available </span><span><span class="kobospan" id="kobo.622.1">media routes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.623.1">We will </span><a id="_idIndexMarker1060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.624.1">begin by defining a </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">MediaRouteSelector</span></strong><span class="kobospan" id="kobo.626.1"> instance and allow it to start discovering other devices to send the media to. </span><span class="kobospan" id="kobo.626.2">We will use </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">LaunchedEffect</span></strong><span class="kobospan" id="kobo.628.1"> to tie the discovery process to the </span><span><span class="kobospan" id="kobo.629.1">composable’s lifecycle:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.630.1">
@Composable
fun MediaRouteDiscoveryOptions(mediaRouter: MediaRouter) {
    val context = LocalContext.current
    val routeSelector = remember {
        MediaRouteSelector.Builder()
            .addControlCategory(
                MediaControlIntent.CATEGORY_REMOTE_PLAYBACK
            )
            .build()
    }
    val mediaRoutes = remember {
    mutableStateListOf&lt;MediaRouter.RouteInfo&gt;() }
    DisposableEffect(mediaRouter) {
        mediaRouter.addCallback(routeSelector, callback,
            MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN)
        onDispose {
            mediaRouter.removeCallback(callback)
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.631.1">This composable </span><a id="_idIndexMarker1061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.632.1">function accepts a </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">MediaRouter</span></strong><span class="kobospan" id="kobo.634.1"> instance as a parameter, highlighting its dependency on this framework for discovering </span><span><span class="kobospan" id="kobo.635.1">media routes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">The function </span><a id="_idIndexMarker1062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.637.1">begins by obtaining the current </span><strong class="source-inline"><span class="kobospan" id="kobo.638.1">Context</span></strong><span class="kobospan" id="kobo.639.1"> value using </span><strong class="source-inline"><span class="kobospan" id="kobo.640.1">LocalContext.current</span></strong><span class="kobospan" id="kobo.641.1">, then it creates a </span><strong class="source-inline"><span class="kobospan" id="kobo.642.1">MediaRouterSelector</span></strong><span class="kobospan" id="kobo.643.1"> instance. </span><span class="kobospan" id="kobo.643.2">This selector is specifically configured to filter for routes supporting live video content. </span><span class="kobospan" id="kobo.643.3">The use of </span><strong class="source-inline"><span class="kobospan" id="kobo.644.1">remember</span></strong><span class="kobospan" id="kobo.645.1"> ensures that the </span><strong class="source-inline"><span class="kobospan" id="kobo.646.1">MediaRouteSelector</span></strong><span class="kobospan" id="kobo.647.1"> instance is preserved across recompositions of the composable, optimizing performance by preventing </span><span><span class="kobospan" id="kobo.648.1">unnecessary reinitializations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.649.1">Then, we are adding a </span><strong class="source-inline"><span class="kobospan" id="kobo.650.1">DisposableEffect</span></strong><span class="kobospan" id="kobo.651.1"> composable, which encapsulates the logic for starting and stopping media route discovery in alignment with the composable’s lifecycle. </span><span class="kobospan" id="kobo.651.2">By passing </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">MediaRouter</span></strong><span class="kobospan" id="kobo.653.1"> as a key to </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">DisposableEffect</span></strong><span class="kobospan" id="kobo.655.1">, the enclosed block of code is executed in a coroutine when the composable is first composed into the UI, and the coroutine is canceled when the composable is removed, effectively managing the lifecycle of the discovery process. </span><span class="kobospan" id="kobo.655.2">Within this block, the </span><strong class="source-inline"><span class="kobospan" id="kobo.656.1">addCallback</span></strong><span class="kobospan" id="kobo.657.1"> method of </span><strong class="source-inline"><span class="kobospan" id="kobo.658.1">MediaRouter</span></strong><span class="kobospan" id="kobo.659.1"> is called to register a callback with the active scan flag, initiating the active scanning for media routes that match the criteria set by </span><strong class="source-inline"><span class="kobospan" id="kobo.660.1">routeSelector</span></strong><span class="kobospan" id="kobo.661.1">. </span><span class="kobospan" id="kobo.661.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.662.1">onDispose</span></strong><span class="kobospan" id="kobo.663.1"> block within </span><strong class="source-inline"><span class="kobospan" id="kobo.664.1">DisposableEffect</span></strong><span class="kobospan" id="kobo.665.1"> serves as a cleanup mechanism, where the callback is unregistered from </span><strong class="source-inline"><span class="kobospan" id="kobo.666.1">MediaRouter</span></strong><span class="kobospan" id="kobo.667.1"> when the composable </span><a id="_idIndexMarker1063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.668.1">is disposed of, ensuring resources are freed and background processing </span><span><span class="kobospan" id="kobo.669.1">is minimized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.670.1">Now, we will </span><a id="_idIndexMarker1064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.671.1">create a callback that we have included in the </span><strong class="source-inline"><span class="kobospan" id="kobo.672.1">addCallback</span></strong><span class="kobospan" id="kobo.673.1"> function </span><span><span class="kobospan" id="kobo.674.1">described previously:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.675.1">
val callback = remember {
    object : MediaRouter.Callback() {
        override fun onRouteAdded(router: MediaRouter,
        route: MediaRouter.RouteInfo) {
            mediaRoutes.add(route)
        }
        override fun onRouteRemoved(router: MediaRouter,
        route: MediaRouter.RouteInfo) {
            mediaRoutes.remove(route)
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.676.1">We are instantiating a </span><strong class="source-inline"><span class="kobospan" id="kobo.677.1">MediaRouter.Callback</span></strong><span class="kobospan" id="kobo.678.1"> listener, using </span><strong class="source-inline"><span class="kobospan" id="kobo.679.1">remember</span></strong><span class="kobospan" id="kobo.680.1"> to avoid needing to recreate it every time the app’s </span><span><span class="kobospan" id="kobo.681.1">UI updates.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.682.1">This listener, </span><strong class="source-inline"><span class="kobospan" id="kobo.683.1">MediaRouter.Callback</span></strong><span class="kobospan" id="kobo.684.1">, has two main jobs through its </span><strong class="source-inline"><span class="kobospan" id="kobo.685.1">onRouteAdded</span></strong><span class="kobospan" id="kobo.686.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.687.1">onRouteRemoved</span></strong><span class="kobospan" id="kobo.688.1"> methods. </span><span class="kobospan" id="kobo.688.2">When a new device becomes available for casting media, </span><strong class="source-inline"><span class="kobospan" id="kobo.689.1">onRouteAdded</span></strong><span class="kobospan" id="kobo.690.1"> gets called, and the app adds this new route to a list called </span><strong class="source-inline"><span class="kobospan" id="kobo.691.1">mediaRoutes</span></strong><span class="kobospan" id="kobo.692.1">. </span><span class="kobospan" id="kobo.692.2">This list is crucial for the app to know what devices are available at any moment. </span><span class="kobospan" id="kobo.692.3">On the flip side, when a device goes offline or disconnects, </span><strong class="source-inline"><span class="kobospan" id="kobo.693.1">onRouteRemoved</span></strong><span class="kobospan" id="kobo.694.1"> is called, and the app removes that route from the list, ensuring the list </span><span><span class="kobospan" id="kobo.695.1">stays current.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.696.1">Effectively, this setup allows the app to dynamically adjust to changes in the available devices for </span><span><span class="kobospan" id="kobo.697.1">media casting.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.698.1">To provide users </span><a id="_idIndexMarker1065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.699.1">with an easy way to select from </span><a id="_idIndexMarker1066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.700.1">these available devices, we need to integrate a button designed for this purpose. </span><span class="kobospan" id="kobo.700.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.701.1">MediaRouter</span></strong><span class="kobospan" id="kobo.702.1"> API offers a ready-made button that displays the available devices for casting. </span><span class="kobospan" id="kobo.702.2">Although this button is an Android view and not a composable, we can still use it in Jetpack Compose by wrapping it with the </span><strong class="source-inline"><span class="kobospan" id="kobo.703.1">AndroidView</span></strong><span class="kobospan" id="kobo.704.1"> composable. </span><span class="kobospan" id="kobo.704.2">Here’s how we can </span><span><span class="kobospan" id="kobo.705.1">do it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.706.1">
AndroidView(
    factory = { ctx -&gt;
        MediaRouteButton(ctx).apply {
            setRouteSelector(routeSelector)
        }
    },
    modifier = Modifier
        .wrapContentWidth()
        .wrapContentHeight()
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.707.1">Now, we just have to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.708.1">MediaRouteDiscoveryOptions</span></strong><span class="kobospan" id="kobo.709.1"> composable from our </span><span><span class="kobospan" id="kobo.710.1">playback screen:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.711.1">
@Composable
fun TopMediaRow(mediaRouter: MediaRouter, modifier:
Modifier = Modifier) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .padding(20.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = "S1:E1 \"Pilot\"", color = Color.White)
        MediaRouteDiscoveryOptions(mediaRouter =
            mediaRouter)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.712.1">Here, we have </span><a id="_idIndexMarker1067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.713.1">added the </span><strong class="source-inline"><span class="kobospan" id="kobo.714.1">MediaRouteDiscoveryOptions</span></strong><span class="kobospan" id="kobo.715.1"> composable to our already existing </span><span><strong class="source-inline"><span class="kobospan" id="kobo.716.1">TopMediaRow</span></strong></span><span><span class="kobospan" id="kobo.717.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.718.1">When </span><a id="_idIndexMarker1068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.719.1">calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.720.1">TopMediaRow</span></strong><span class="kobospan" id="kobo.721.1"> function we will pass it an instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.722.1">mediaRouter</span></strong><span class="kobospan" id="kobo.723.1"> that we had obtained before, </span><span><span class="kobospan" id="kobo.724.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.725.1">LocalContext</span></strong></span><span><span class="kobospan" id="kobo.726.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.727.1">
TopMediaRow(
    mediaRouter =
        MediaRouter.getInstance(LocalContext.current),
    modifier = Modifier.align(Alignment.TopCenter))</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.728.1">Now, we will see the </span><strong class="bold"><span class="kobospan" id="kobo.729.1">Cast</span></strong><span class="kobospan" id="kobo.730.1"> button in the right corner of our existing </span><strong class="source-inline"><span class="kobospan" id="kobo.731.1">PlaybackScreen</span></strong><span class="kobospan" id="kobo.732.1"> composable. </span><span class="kobospan" id="kobo.732.2">If we click it, </span><strong class="source-inline"><span class="kobospan" id="kobo.733.1">MediaRouter</span></strong><span class="kobospan" id="kobo.734.1"> will automatically search </span><span><span class="kobospan" id="kobo.735.1">for devices:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<span class="kobospan" id="kobo.736.1"><img alt="Figure 9.3: MediaRouter searching for devices" src="image/B19443_09_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.737.1">Figure 9.3: MediaRouter searching for devices</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.738.1">If it cannot </span><a id="_idIndexMarker1069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.739.1">find any device, it will show a message encouraging </span><a id="_idIndexMarker1070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.740.1">the user to check </span><span><span class="kobospan" id="kobo.741.1">the connection:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<span class="kobospan" id="kobo.742.1"><img alt="Figure 9.4: MediaRouter functionality, prompting the user to check the device connections" src="image/B19443_09_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.743.1">Figure 9.4: MediaRouter functionality, prompting the user to check the device connections</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.744.1">After discovering available media routes using the </span><strong class="source-inline"><span class="kobospan" id="kobo.745.1">MediaRouter</span></strong><span class="kobospan" id="kobo.746.1"> API, the next step is connecting to a selected device for media playback. </span><span class="kobospan" id="kobo.746.2">This involves two main actions: selecting a media route and then establishing a connection to that route. </span><span class="kobospan" id="kobo.746.3">Here’s how you can approach </span><span><span class="kobospan" id="kobo.747.1">this process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.748.1">When utilizing the built-in media route selector with </span><strong class="source-inline"><span class="kobospan" id="kobo.749.1">MediaRouteButton</span></strong><span class="kobospan" id="kobo.750.1">, the process of connecting to a device is streamlined. </span><strong class="source-inline"><span class="kobospan" id="kobo.751.1">MediaRouteButton</span></strong><span class="kobospan" id="kobo.752.1"> automatically handles the display of available media routes based on the criteria defined in a </span><strong class="source-inline"><span class="kobospan" id="kobo.753.1">MediaRouteSelector</span></strong><span class="kobospan" id="kobo.754.1"> instance. </span><span class="kobospan" id="kobo.754.2">Users can then select their preferred device directly from the UI that </span><span><strong class="source-inline"><span class="kobospan" id="kobo.755.1">MediaRouteButton</span></strong></span><span><span class="kobospan" id="kobo.756.1"> presents.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.757.1">Once a user selects a route from the dialog, the connection to that device is automatically managed by the </span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">MediaRouter</span></strong><span class="kobospan" id="kobo.759.1"> framework based on the route’s capabilities and the types of media specified in your </span><strong class="source-inline"><span class="kobospan" id="kobo.760.1">MediaRouteSelector</span></strong><span class="kobospan" id="kobo.761.1"> instance. </span><span class="kobospan" id="kobo.761.2">There’s no need for additional manual connection management in your </span><span><span class="kobospan" id="kobo.762.1">application code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.763.1">With the </span><a id="_idIndexMarker1071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.764.1">route selected and a connection established, you can </span><a id="_idIndexMarker1072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.765.1">control media playback through the selected route. </span><span class="kobospan" id="kobo.765.2">This typically involves using media control APIs that are appropriate for your application’s media content and the capabilities of the selected route. </span><span class="kobospan" id="kobo.765.3">We will learn how can we cast media playback for Google Cast devices in the </span><span><span class="kobospan" id="kobo.766.1">next section.</span></span></p>
<h1 id="_idParaDest-191" class="calibre5"><a id="_idTextAnchor193" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.767.1">Connecting to Google Chromecast devices</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.768.1">Google Cast is a powerful technology developed by Google that allows users to wirelessly stream audio and video content from their smartphones, tablets, or computers </span><a id="_idIndexMarker1073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.769.1">directly to Cast-enabled devices. </span><span class="kobospan" id="kobo.769.2">This technology is embedded in a wide array of devices, including Chromecast dongles, smart TVs, and speakers, making it accessible to a vast user base. </span><span class="kobospan" id="kobo.769.3">At its core, Google Cast works by establishing a connection between a Cast-enabled app on a mobile device or computer and a Cast-enabled receiver device. </span><span class="kobospan" id="kobo.769.4">Once a connection is made, media can be played back on the receiver device, effectively turning it into a remote screen or speaker for the content </span><span><span class="kobospan" id="kobo.770.1">being cast.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.771.1">The functionality of Google Cast is not limited to streaming media from the internet. </span><span class="kobospan" id="kobo.771.2">It also enables the mirroring of content from the sender device’s screen, extending its utility to presentations, educational content, and more. </span><span class="kobospan" id="kobo.771.3">Google Cast operates over Wi-Fi, ensuring high-quality streaming performance without the need for physical cables </span><span><span class="kobospan" id="kobo.772.1">or adapters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.773.1">We have already done some steps: we have already included the library and we are already detecting the devices that allow casting. </span><span class="kobospan" id="kobo.773.2">Now, we need to establish a cast session. </span><span class="kobospan" id="kobo.773.3">This session facilitates a connection between your app and the selected Cast device, enabling media control and playback on the larger screen. </span><span class="kobospan" id="kobo.773.4">This process hinges on effectively using </span><strong class="source-inline"><span class="kobospan" id="kobo.774.1">CastContext</span></strong><span class="kobospan" id="kobo.775.1"> and adeptly managing Cast </span><span><span class="kobospan" id="kobo.776.1">session events.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.777.1">CastContext</span></strong><span class="kobospan" id="kobo.778.1"> is central to initiating and managing Cast sessions in your application, providing the necessary APIs to connect to the selected Cast device. </span><span class="kobospan" id="kobo.778.2">Here’s how to initiate </span><span><span class="kobospan" id="kobo.779.1">a connection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.780.1">First, we need to ensure that you have initialized </span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">CastContext</span></strong><span class="kobospan" id="kobo.782.1"> in your application. </span><span class="kobospan" id="kobo.782.2">This is typically done in the </span><strong class="source-inline"><span class="kobospan" id="kobo.783.1">Application</span></strong><span class="kobospan" id="kobo.784.1"> subclass or your main activity. </span><span class="kobospan" id="kobo.784.2">We will initialize it in our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">PlaybackActivity</span></strong></span><span><span class="kobospan" id="kobo.786.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.787.1">
val castContext = CastContext.getSharedInstance(context)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.788.1">Then, we need </span><a id="_idIndexMarker1074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.789.1">to select a device. </span><span class="kobospan" id="kobo.789.2">We have already implemented </span><strong class="source-inline"><span class="kobospan" id="kobo.790.1">MediaRouterbutton</span></strong><span class="kobospan" id="kobo.791.1">, which will automatically handle the selection. </span><span class="kobospan" id="kobo.791.2">Once a device is selected, the Cast SDK automatically initiates a connection to the device. </span><span class="kobospan" id="kobo.791.3">This process is abstracted away from the developer, but it’s crucial to listen for session events to manage the </span><span><span class="kobospan" id="kobo.792.1">connection effectively.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.793.1">The Cast SDK provides callbacks for session events such as starting, ending, resuming, and suspending. </span><span class="kobospan" id="kobo.793.2">Handling these events allows your app to respond to changes in the session state, such as updating the UI or pausing media playback when the </span><span><span class="kobospan" id="kobo.794.1">session ends.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.795.1">To listen to these session events, we must </span><span><span class="kobospan" id="kobo.796.1">implement </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.797.1">SessionManagerListener</span></strong></span><span><span class="kobospan" id="kobo.798.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.799.1">
private val sessionManagerListener = object : SessionManagerListener&lt;CastSession&gt; {
    override fun onSessionStarted(session: CastSession,
    sessionId: String) {
        castSession = session
        updateUIForCastSession(true)
    }
    override fun onSessionEnded(p0: CastSession, p1: Int) {
        castSession = null
        updateUIForCastSession(false)
    }
    override fun onSessionResumed(session: CastSession, p1:
    Boolean) {
        castSession = session
        updateUIForCastSession(true)
    }
    override fun onSessionStarting(p0: CastSession) {}
    override fun onSessionStartFailed(
        p0: CastSession, p1: Int) {}
    override fun onSessionResuming(session: CastSession,
        p1: String) {}
    override fun onSessionResumeFailed(session:
        CastSession, p1: Int) { }
    override fun onSessionEnding(session: CastSession) {}
    override fun onSessionSuspended(p0: CastSession,
        p1: Int) {}
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.800.1">Here, we are implementing our </span><strong class="source-inline"><span class="kobospan" id="kobo.801.1">SessionManagerListener&lt;CastSession&gt;</span></strong><span class="kobospan" id="kobo.802.1"> interface, crucial for managing Google Cast sessions. </span><span class="kobospan" id="kobo.802.2">This listener is designed to react to various events </span><a id="_idIndexMarker1075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.803.1">related to the lifecycle of a Cast session, including its start, end, resumption, and failure cases. </span><span class="kobospan" id="kobo.803.2">Let’s look deeper into </span><span><span class="kobospan" id="kobo.804.1">this implementation:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.805.1">onSessionStarted</span></strong><span class="kobospan" id="kobo.806.1">: This callback is invoked when a new Cast session has successfully started. </span><span class="kobospan" id="kobo.806.2">Here, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.807.1">session</span></strong><span class="kobospan" id="kobo.808.1"> parameter, which is an instance of </span><strong class="source-inline1"><span class="kobospan" id="kobo.809.1">CastSession</span></strong><span class="kobospan" id="kobo.810.1">, represents the newly established session. </span><span class="kobospan" id="kobo.810.2">The method sets the global </span><strong class="source-inline1"><span class="kobospan" id="kobo.811.1">castSession</span></strong><span class="kobospan" id="kobo.812.1"> variable to this instance, effectively marking the beginning of a session. </span><span class="kobospan" id="kobo.812.2">Subsequently, it calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.813.1">updateUIForCastSession(true)</span></strong><span class="kobospan" id="kobo.814.1">, a method that will be implemented to update the application’s UI to reflect that casting </span><span><span class="kobospan" id="kobo.815.1">has started.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.816.1">onSessionEnded</span></strong><span class="kobospan" id="kobo.817.1">: Triggered when an existing Cast session ends, this method clears the </span><strong class="source-inline1"><span class="kobospan" id="kobo.818.1">castSession</span></strong><span class="kobospan" id="kobo.819.1"> variable by setting it to </span><strong class="source-inline1"><span class="kobospan" id="kobo.820.1">null</span></strong><span class="kobospan" id="kobo.821.1">, indicating that there is no longer an active Cast session. </span><span class="kobospan" id="kobo.821.2">It also invokes </span><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">updateUIForCastSession(false)</span></strong><span class="kobospan" id="kobo.823.1"> to adjust the UI, signaling to the user that casting </span><span><span class="kobospan" id="kobo.824.1">has stopped.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.825.1">onSessionResumed</span></strong><span class="kobospan" id="kobo.826.1">: Similar to </span><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">onSessionStarted</span></strong><span class="kobospan" id="kobo.828.1">, this callback is called when a previously suspended Cast session is resumed. </span><span class="kobospan" id="kobo.828.2">It updates </span><strong class="source-inline1"><span class="kobospan" id="kobo.829.1">castSession</span></strong><span class="kobospan" id="kobo.830.1"> with the current session and calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.831.1">updateUIForCastSession(true)</span></strong><span class="kobospan" id="kobo.832.1"> to reflect the resumption of casting in </span><span><span class="kobospan" id="kobo.833.1">the UI.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.834.1">onSessionStarting</span></strong><span class="kobospan" id="kobo.835.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">onSessionResuming</span></strong><span class="kobospan" id="kobo.837.1">: Indicate that a session is in the process of starting or resuming but has not yet completed. </span><span class="kobospan" id="kobo.837.2">No action is taken in these callbacks in </span><span><span class="kobospan" id="kobo.838.1">our case.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.839.1">onSessionStartFailed</span></strong><span class="kobospan" id="kobo.840.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.841.1">onSessionResumeFailed</span></strong><span class="kobospan" id="kobo.842.1">: Called when attempts to start or resume a session fail. </span><span class="kobospan" id="kobo.842.2">Again, no action is specified in our case, but these would be appropriate places to handle errors, such as by notifying the user or attempting to restart </span><span><span class="kobospan" id="kobo.843.1">the session.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.844.1">onSessionEnding</span></strong><span class="kobospan" id="kobo.845.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.846.1">onSessionSuspended</span></strong><span class="kobospan" id="kobo.847.1">: These callbacks are triggered when a session is in the process of ending or being suspended. </span><span class="kobospan" id="kobo.847.2">As with the start and resume events, no specific actions are taken in </span><span><span class="kobospan" id="kobo.848.1">these cases.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.849.1">Once we </span><a id="_idIndexMarker1076" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.850.1">have implemented our listener, we need to register it </span><span><span class="kobospan" id="kobo.851.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.852.1">castContext.sessionManager</span></strong></span><span><span class="kobospan" id="kobo.853.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.854.1">
override fun onStart() {
    super.onStart()
    castContext.sessionManager.addSessionManagerListener(
        sessionManagerListener, CastSession::class.java)
}
override fun onStop() {
    super.onStop()
    castContext.sessionManager.removeSessionManagerListener
        (sessionManagerListener, CastSession::class.java)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.855.1">Here, we are registering the listener when the </span><strong class="source-inline"><span class="kobospan" id="kobo.856.1">Activity</span></strong><span class="kobospan" id="kobo.857.1"> class is started and removing it when it is stopped. </span><span class="kobospan" id="kobo.857.2">That way, we ensure that the listener is only retained when the </span><strong class="source-inline"><span class="kobospan" id="kobo.858.1">Activity</span></strong><span class="kobospan" id="kobo.859.1"> class is in a </span><span><span class="kobospan" id="kobo.860.1">started state.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.861.1">Now, let’s implement the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.862.1">updateUIForCastSession</span></strong></span><span><span class="kobospan" id="kobo.863.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.864.1">
private fun updateUIForCastSession(isCasting: Boolean) {
    viewModel.setCastingState(isCasting)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.865.1">Here, we are calling a new function that we will include next in the </span><strong class="source-inline"><span class="kobospan" id="kobo.866.1">ViewModel</span></strong><span class="kobospan" id="kobo.867.1"> component, called </span><strong class="source-inline"><span class="kobospan" id="kobo.868.1">setCastingState</span></strong><span class="kobospan" id="kobo.869.1">. </span><span class="kobospan" id="kobo.869.2">We are passing a Boolean as the argument, indicating whether the app is casting </span><span><span class="kobospan" id="kobo.870.1">or not.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.871.1">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.872.1">PlaybackViewModel</span></strong><span class="kobospan" id="kobo.873.1"> component, we will introduce the followin</span><a id="_idTextAnchor194" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.874.1">g changes. </span><span class="kobospan" id="kobo.874.2">We will start adding a new </span><span><span class="kobospan" id="kobo.875.1">property, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.876.1">isCasting</span></strong></span><span><span class="kobospan" id="kobo.877.1">:</span></span></p>
<pre class="source-code">
<a id="_idTextAnchor195" class="pcalibre1 calibre17 pcalibre"/><span class="kobospan1" id="kobo.878.1">private val _isCasting = MutableStateFlow&lt;Boolean&gt;(false)
val isCasting: MutableStateFlow&lt;Boolean&gt; = _isCasting</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.879.1">Then, we will </span><a id="_idIndexMarker1077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.880.1">ch</span><a id="_idTextAnchor196" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.881.1">ange its value when the </span><strong class="source-inline"><span class="kobospan" id="kobo.882.1">setCastingState</span></strong><span class="kobospan" id="kobo.883.1"> function </span><span><span class="kobospan" id="kobo.884.1">is called:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.885.1">
fun setCastingState(isCasting: Boolean) {
    _isCasting.value = isCasting
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.886.1">Then, we will use it in our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.887.1">PlaybackScreen</span></strong></span><span><span class="kobospan" id="kobo.888.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.889.1">
@Composable
fun PlaybackScreen() {
    ...
</span><span class="kobospan1" id="kobo.889.2">    val isCasting = viewModel.isCasting.collectAsState()
    Box(
        ...
</span><span class="kobospan1" id="kobo.889.3">    ) {
        if (isCasting.value) {
            NowCastingView()
        } else {
            //VideoPlayerComposable and the rest of the UI...
</span><span class="kobospan1" id="kobo.889.4">        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.890.1">In our already existing </span><strong class="source-inline"><span class="kobospan" id="kobo.891.1">PlaybackScreen</span></strong><span class="kobospan" id="kobo.892.1"> composable, we have added a new property, </span><strong class="source-inline"><span class="kobospan" id="kobo.893.1">isCasting</span></strong><span class="kobospan" id="kobo.894.1">. </span><span class="kobospan" id="kobo.894.2">This property is used to choose if the screen will show a </span><strong class="bold"><span class="kobospan" id="kobo.895.1">Now Casting</span></strong><span class="kobospan" id="kobo.896.1"> message or the complete </span><span><span class="kobospan" id="kobo.897.1">playback UI.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.898.1">Next, we will </span><a id="_idIndexMarker1078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.899.1">build a new </span><span><strong class="source-inline"><span class="kobospan" id="kobo.900.1">NowCastingView</span></strong></span><span><span class="kobospan" id="kobo.901.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.902.1">
@Composable
fun NowCastingView() {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Now Casting",
                style =
                    MaterialTheme.typography.headlineMedium
            )
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.903.1">This composable is just placing and showing a text with the </span><strong class="bold"><span class="kobospan" id="kobo.904.1">Now Casting</span></strong><span class="kobospan" id="kobo.905.1"> content, just to make the user aware that the media content is currently being cast to </span><span><span class="kobospan" id="kobo.906.1">another device.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.907.1">There’s just one thing that we must do: load the media in the remote device. </span><span class="kobospan" id="kobo.907.2">We will modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.908.1">onSessionStarted</span></strong><span class="kobospan" id="kobo.909.1"> callback in the </span><strong class="source-inline"><span class="kobospan" id="kobo.910.1">SessionManagerListener</span></strong><span class="kobospan" id="kobo.911.1"> interface, including a call to a new function to load </span><span><span class="kobospan" id="kobo.912.1">the media:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.913.1">
override fun onSessionStarted(session: CastSession,
sessionId: String) {
    castSession = session
    updateUIForCastSession(true)
    loadMedia(session)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.914.1">Finally, we will </span><a id="_idIndexMarker1079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.915.1">implement this function </span><span><span class="kobospan" id="kobo.916.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.917.1">
private fun loadMedia(castSession: CastSession) {
    val mediaInfo = MediaInfo.Builder(viewModel.mediaUrl)
        .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)
        .setContentType("video/mp4")
        .build()
    val mediaLoadOptions = MediaLoadOptions
        .Builder()
        .setAutoplay(true)
        .setPlayPosition(0)
        .build()
    castSession.remoteMediaClient?.load(mediaInfo,
        mediaLoadOptions)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.918.1">The function begins by constructing a </span><strong class="source-inline"><span class="kobospan" id="kobo.919.1">MediaInfo</span></strong><span class="kobospan" id="kobo.920.1"> object, which encapsulates all necessary details about the media file intended for playback. </span><span class="kobospan" id="kobo.920.2">Utilizing the </span><strong class="source-inline"><span class="kobospan" id="kobo.921.1">MediaInfo.Builder</span></strong><span class="kobospan" id="kobo.922.1"> pattern, it starts with specifying the media’s URL, sourced from </span><strong class="source-inline"><span class="kobospan" id="kobo.923.1">viewModel.mediaUrl</span></strong><span class="kobospan" id="kobo.924.1">. </span><span class="kobospan" id="kobo.924.2">This URL is the location of the media file, which the Cast-enabled device will stream. </span><span class="kobospan" id="kobo.924.3">The builder then sets the stream type to </span><strong class="source-inline"><span class="kobospan" id="kobo.925.1">MediaInfo.STREAM_TYPE_BUFFERED</span></strong><span class="kobospan" id="kobo.926.1">, indicating that the content is pre-recorded and can be buffered before playback, which is ideal for video content that isn’t being streamed live. </span><span class="kobospan" id="kobo.926.2">Furthermore, the content type is set to </span><strong class="source-inline"><span class="kobospan" id="kobo.927.1">"video/mp4"</span></strong><span class="kobospan" id="kobo.928.1">, defining the </span><strong class="bold"><span class="kobospan" id="kobo.929.1">MIME</span></strong><span class="kobospan" id="kobo.930.1"> type (</span><strong class="bold"><span class="kobospan" id="kobo.931.1">Multipurpose Internet Mail Extensions</span></strong><span class="kobospan" id="kobo.932.1">, used not only by email but also by </span><a id="_idIndexMarker1080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.933.1">web browsers and apps to interpret and display content correctly.) of the file as an </span><span><span class="kobospan" id="kobo.934.1">MP4 video.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.935.1">Following the creation of the </span><strong class="source-inline"><span class="kobospan" id="kobo.936.1">MediaInfo</span></strong><span class="kobospan" id="kobo.937.1"> object, the function proceeds to configure additional playback options through a </span><strong class="source-inline"><span class="kobospan" id="kobo.938.1">MediaLoadOptions</span></strong><span class="kobospan" id="kobo.939.1"> object. </span><span class="kobospan" id="kobo.939.2">The options set include </span><strong class="source-inline"><span class="kobospan" id="kobo.940.1">setAutoplay(true)</span></strong><span class="kobospan" id="kobo.941.1">, which commands the Cast device to automatically start playing the media as soon as it’s loaded, and </span><strong class="source-inline"><span class="kobospan" id="kobo.942.1">setPlayPosition(0)</span></strong><span class="kobospan" id="kobo.943.1">, ensuring that playback commences from the very beginning of the media file, for simplicity. </span><span class="kobospan" id="kobo.943.2">One improvement </span><a id="_idIndexMarker1081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.944.1">to this could be to obtain the current play position from the </span><strong class="source-inline"><span class="kobospan" id="kobo.945.1">ViewModel</span></strong><span class="kobospan" id="kobo.946.1"> component so that the video can continue at the same point in time if the playback has </span><span><span class="kobospan" id="kobo.947.1">already started.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.948.1">The final step in the </span><strong class="source-inline"><span class="kobospan" id="kobo.949.1">loadMedia</span></strong><span class="kobospan" id="kobo.950.1"> function involves invoking the </span><strong class="source-inline"><span class="kobospan" id="kobo.951.1">load</span></strong><span class="kobospan" id="kobo.952.1"> method on the </span><strong class="source-inline"><span class="kobospan" id="kobo.953.1">castSession</span></strong><span class="kobospan" id="kobo.954.1"> variable’s </span><strong class="source-inline"><span class="kobospan" id="kobo.955.1">remoteMediaClient</span></strong><span class="kobospan" id="kobo.956.1"> instance. </span><span class="kobospan" id="kobo.956.2">This method call is where the media loading and playback command is actually sent to the Cast-enabled device. </span><strong class="source-inline"><span class="kobospan" id="kobo.957.1">remoteMediaClient</span></strong><span class="kobospan" id="kobo.958.1"> acts as the intermediary, transmitting commands from the app to the receiver. </span><span class="kobospan" id="kobo.958.2">By passing the </span><strong class="source-inline"><span class="kobospan" id="kobo.959.1">MediaInfo</span></strong><span class="kobospan" id="kobo.960.1"> object and </span><strong class="source-inline"><span class="kobospan" id="kobo.961.1">MediaLoadOptions</span></strong><span class="kobospan" id="kobo.962.1"> to this method, the app specifies what to play and how it should be played, effectively initiating the streaming of video content to the </span><span><span class="kobospan" id="kobo.963.1">Cast device.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.964.1">Now, our app is ready to start casting to Google Cast devices. </span><span class="kobospan" id="kobo.964.2">With that, we have finished this chapter and learned the vast possibilities of playback in Android and other </span><span><span class="kobospan" id="kobo.965.1">connected devices.</span></span></p>
<h1 id="_idParaDest-192" class="calibre5"><a id="_idTextAnchor197" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.966.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.967.1">In this chapter, we tackled the essentials of extended video playback on Android, focusing on making our app more engaging by allowing videos to play in other contexts. </span><span class="kobospan" id="kobo.967.2">We covered two main areas: PiP mode and media casting, both aimed at keeping our users connected to their content, whether they’re multitasking on their device or looking to enjoy videos on a </span><span><span class="kobospan" id="kobo.968.1">larger screen.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.969.1">Starting with PiP, we walked through how to enable a video to continue playing in a small window while users navigate away from the app. </span><span class="kobospan" id="kobo.969.2">This section detailed everything from modifying your app’s manifest to implementing PiP mode, ensuring users won’t have to pause their viewing experience when they need to use </span><span><span class="kobospan" id="kobo.970.1">another app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.971.1">Next, we shifted focus to media casting, particularly with </span><strong class="source-inline"><span class="kobospan" id="kobo.972.1">MediaRouter</span></strong><span class="kobospan" id="kobo.973.1"> and the Cast SDK for devices such as Google Chromecast. </span><span class="kobospan" id="kobo.973.2">Here, you learned how to let users send video from their mobile device to a TV. </span><span class="kobospan" id="kobo.973.3">We discussed using </span><strong class="source-inline"><span class="kobospan" id="kobo.974.1">MediaRouteButton</span></strong><span class="kobospan" id="kobo.975.1"> for easy device discovery and connection, as well as how to create a custom UI for users who want more control over the </span><span><span class="kobospan" id="kobo.976.1">casting process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.977.1">By the end of this chapter, you should have understood how to implement PiP for in-app multitasking and set up casting to external devices. </span><span class="kobospan" id="kobo.977.2">These skills are key to creating Android apps that offer flexible and user-friendly video playback experiences. </span><span class="kobospan" id="kobo.977.3">Whether it’s keeping a video running in a corner of the screen or sharing a favorite movie on a big TV, your app can now cater to various user needs, enhancing overall engagement with your </span><span><span class="kobospan" id="kobo.978.1">video content.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.979.1">And with that, we’ve reached the end of our journey, where we built key features for three types of apps: a messaging app, a social platform, and a video app. </span><span class="kobospan" id="kobo.979.2">Each project aimed to deepen your Android and Kotlin development skills and inspire you to think about how you can apply these ideas to your </span><span><span class="kobospan" id="kobo.980.1">own work.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.981.1">Thank you for reading this book. </span><span class="kobospan" id="kobo.981.2">I hope it has not only broadened your knowledge but also sparked new ideas for your projects. </span><span class="kobospan" id="kobo.981.3">With the tools and techniques you’ve learned, you’re well prepared to advance your career and start building your own innovative apps. </span><span class="kobospan" id="kobo.981.4">Here’s to your success in the field of mobile development – go out there and make </span><span><span class="kobospan" id="kobo.982.1">great things!</span></span></p>
</div>
</body></html>