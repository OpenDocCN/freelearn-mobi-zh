<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor180" class="calibre6 pcalibre1 pcalibre"/>9</h1>
<h1 id="_idParaDest-179" class="calibre5"><a id="_idTextAnchor181" class="calibre6 pcalibre1 pcalibre"/> Extending Video Playback in Your Packtflix App</h1>
<p class="calibre3">Have you ever wanted your users to continue enjoying their favorite videos even when they switch apps or turn off the screen? This chapter dives deep into the world of extended video playback on Android, bringing you the skills to create a more engaging and versatile user experience.</p>
<p class="calibre3">We’ll be exploring <a id="_idIndexMarker1014" class="calibre6 pcalibre1 pcalibre"/>two key functionalities: <code>MediaRouter</code> and the Cast SDK, which enable users to transfer the video playback to a larger screen, such as a TV with Google Chromecast.</p>
<p class="calibre3">By the end of this chapter, you’ll have gained a solid understanding of the PiP functionalities and unlocked the potential of extended video playback in our Android app.</p>
<p class="calibre3">So, in this chapter, we will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Getting to know the PiP API</li>
<li class="calibre14">Using PiP to continue playback in the background</li>
<li class="calibre14">Getting to know <strong class="source-inline1">MediaRouter</strong></li>
<li class="calibre14">Connecting to Google Chromecast devices</li>
</ul>
<h1 id="_idParaDest-180" class="calibre5"><a id="_idTextAnchor182" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have installed Android Studio (or another editor of your preference).</p>
<p class="calibre3">We will follow the project started in <a href="B19443_07.xhtml#_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a> with the changes we have made in <a href="B19443_08.xhtml#_idTextAnchor160" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 8</em></a>.</p>
<p class="calibre3">You can find the complete code that we are going to build through this chapter available in this repository: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-9</a>.</p>
<h1 id="_idParaDest-181" class="calibre5"><a id="_idTextAnchor183" class="calibre6 pcalibre1 pcalibre"/>Getting to know the PiP API</h1>
<p class="calibre3">The first step on our extended video playback journey is to understand the PiP API, which lets us <a id="_idIndexMarker1015" class="calibre6 pcalibre1 pcalibre"/>use PiP mode. <strong class="bold">PiP mode</strong> allows users to minimize your app and continue watching a video in a resizable and movable miniature player. This functionality enhances user experience by providing flexibility and convenience.</p>
<p class="calibre3">This section will <a id="_idIndexMarker1016" class="calibre6 pcalibre1 pcalibre"/>provide you with the knowledge to leverage PiP effectively in your app. We’ll cover the most important aspects such as understanding the PiP requirements and learning how to enter and exit PiP mode programmatically, and review some different listener events. So, let’s get started.</p>
<h2 id="_idParaDest-182" class="calibre7"><a id="_idTextAnchor184" class="calibre6 pcalibre1 pcalibre"/>PiP requirements</h2>
<p class="calibre3">Not every device is created equal when it comes to PiP. Before we go deep into the exciting <a id="_idIndexMarker1017" class="calibre6 pcalibre1 pcalibre"/>functionalities, let’s ensure a smooth user experience by understanding the requirements and compatibility aspects of PiP mode.</p>
<p class="calibre3">Regarding the requirements, there are two variables to take into account:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Minimum Android version</strong>: PiP mode relies on specific APIs introduced in Android 8.0 (Oreo). Targeting devices running older versions of Android will not only prevent PiP functionality but could also lead to crashes or unexpected behavior.<p class="calibre3">To check if the user’s device is compatible with PiP, we could implement the following code:</p><pre class="source-code">
val minApiLevel = Build.VERSION_CODES.O
if (android.os.Build.VERSION.SDK_INT &lt; minApiLevel) {
  // PiP not supported on this device
  return false
}</pre><p class="calibre3">This code ensures our app gracefully handles devices that can’t use PiP mode. First, we define the minimum Android version required for PiP (typically Android 8.0 or Oreo). Then, we check the device’s current version. If it’s older than the minimum, the code <a id="_idIndexMarker1018" class="calibre6 pcalibre1 pcalibre"/>recognizes that PiP functionality isn’t available and signals this back (potentially by returning <code>false</code>) to prevent the app from attempting to use PiP features that would cause issues on incompatible devices.</p><p class="calibre3">This allows you to gracefully handle situations where PiP isn’t available and potentially offer alternative functionalities for users on older devices (for example, we could offer them to send the playback to a different device).</p></li> <li class="calibre14"><strong class="bold">Screen size requirements</strong>: While PiP mode can be technically implemented on various screen sizes, smaller displays might not provide an optimal user experience. Imagine trying to watch a movie in a tiny PiP window on a phone with a 4-inch screen! Therefore, it’s essential to consider screen size limitations.</li>
</ul>
<p class="calibre3">Now that we’ve established the requirements, let’s explore the exciting part: initiating PiP mode within our app.</p>
<h2 id="_idParaDest-183" class="calibre7"><a id="_idTextAnchor185" class="calibre6 pcalibre1 pcalibre"/>Entering and exiting PiP mode programmatically</h2>
<p class="calibre3">As we already <a id="_idIndexMarker1019" class="calibre6 pcalibre1 pcalibre"/>know, PiP mode offers users the convenience of continuing video playback in a miniature window even when they switch apps or turn off the screen. To do this, we’ll use the <code>enterPictureInPictureMode()</code> method available in the <code>Activity</code> class:</p>
<pre class="source-code">
activity.enterPictureInPictureMode()</pre> <p class="calibre3">Calling this method allows you to programmatically trigger PiP mode from within your activity, and the system will handle resizing the video player window and placing it on top of other apps. It’s important to note that you should typically only call this method when the user explicitly requests it, such as upon tapping a dedicated PiP button within your app’s UI.</p>
<p class="calibre3">While entering PiP mode is initiated programmatically, exiting is primarily user-driven. The user can exit PiP mode by swiping the miniature player away or tapping a designated <strong class="bold">Close</strong> button provided by the system. However, as developers, we can still play a role in ensuring a smooth transition back to the fullscreen experience. The system triggers specific <a id="_idIndexMarker1020" class="calibre6 pcalibre1 pcalibre"/>callbacks within your activity when PiP mode is exited. Here’s how we can utilize these callbacks:</p>
<pre class="source-code">
override fun onPictureInPictureExited() {
  super.onPictureInPictureExited()
  // Any logic that we want to add when the user comes back
     to the full screen experience in our app
}</pre> <p class="calibre3">This function will be called every time the user closes the PiP miniature screen. This is not the only function that we can use to handle PiP status changes, though; the listener provides various events to keep our app informed about changes in the PiP window. These events allow us to react and update our app’s behavior accordingly, ensuring a seamless user experience:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">OnPictureInPictureEntered()</strong>: This event gets triggered when the user successfully enters PiP mode. You can use this opportunity to potentially update UI elements to reflect the PiP state (for example, hide unnecessary controls) or perform any necessary optimizations for PiP playback (for example, adjust video quality).</li>
<li class="calibre14"><strong class="source-inline1">OnPictureInPictureExited()</strong>: As discussed previously, this event signifies the user exiting PiP mode. Here, you can clean up resources associated with the PiP window or update the UI to reflect the return to fullscreen playback.</li>
<li class="calibre14"><strong class="source-inline1">OnPictureInPictureUiStateChanged()</strong>: This event gets fired whenever any change occurs to the PiP window, such as resizing or moving it. You might use this to adjust your UI layout based on the new PiP window dimensions or update video playback based on potential performance changes due to resizing.</li>
</ul>
<p class="calibre3">By effectively <a id="_idIndexMarker1021" class="calibre6 pcalibre1 pcalibre"/>handling PiP events and listener callbacks, you can keep your app in sync with the changing PiP window state. Now, let’s see how we can integrate it into our existing project.</p>
<h1 id="_idParaDest-184" class="calibre5"><a id="_idTextAnchor186" class="calibre6 pcalibre1 pcalibre"/>Using PiP to continue playback in the background</h1>
<p class="calibre3">The first <a id="_idIndexMarker1022" class="calibre6 pcalibre1 pcalibre"/>step before we can use PiP in our project is that we must declare support for it in our <code>AndroidManifest.xml</code> file. This step is crucial for informing the Android system that our <code>PlaybackActivity</code> class is capable of running in PiP mode. We do this like so:</p>
<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest
    xmlns:android =
        "http://schemas.android.com/apk/res/android"&gt;
    &lt;application&gt;
        &lt;activity
            android:name = "com.packt.playback.presentation
                .PlaybackActivity"
            android:supportsPictureInPicture="true"
            android:resizeableActivity="true"
            android:screenOrientation="landscape"/&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre> <p class="calibre3">For PiP specifically, the key attribute in our manifest is <code>android:supportsPicture</code><strong class="source-inline">
InPicture="true"</strong>, which explicitly declares that your activity supports PiP mode.</p>
<p class="calibre3">The <code>resizeableActivity</code> attribute, while related to the ability of an activity to be resized, is implicitly set to <code>true</code> for all activities when targeting API level 24 or higher. This means if your app targets API level 24+, you don’t need to explicitly set <code>resizeableActivity="true"</code> for PiP mode to work because the system already considers <a id="_idIndexMarker1023" class="calibre6 pcalibre1 pcalibre"/>all activities to be resizable to support multi-window mode.</p>
<p class="calibre3">However, explicitly setting <code>resizeableActivity="true"</code> can be a good practice for clarity, especially if your app is designed to take advantage of multi-window features beyond just PiP, or if you want to ensure compatibility across different Android versions and devices. It’s also useful for documentation purposes, making it clear to anyone reading your <code>AndroidManifest.xml</code> file that your activity is intended to support resizable behaviors, including PiP.</p>
<h2 id="_idParaDest-185" class="calibre7"><a id="_idTextAnchor187" class="calibre6 pcalibre1 pcalibre"/>Implementing PiP</h2>
<p class="calibre3">Now that <a id="_idIndexMarker1024" class="calibre6 pcalibre1 pcalibre"/>we have explicitly opted in our <code>Activity</code> class to use the PiP feature, let’s implement it. We will override the <code>onUserLeaveHint()</code> callback, which is triggered when the user presses the <strong class="bold">Home</strong> button or switches to another app:</p>
<pre class="source-code">
override fun onUserLeaveHint() {
    super.onUserLeaveHint()
    val aspectRatio = Rational(16, 9)
    val params = PictureInPictureParams.Builder()
        .setAspectRatio(aspectRatio)
        .build()
    enterPictureInPictureMode(params)
}</pre> <p class="calibre3">As we said, we are overriding the <code>onUserLeaveHint()</code> existing function. Here, we still have to include the call to <code>super.onUserLeaveHint()</code> as it ensures that the <code>Activity</code> class properly handles any additional underlying operations defined by Android’s framework before executing custom behavior.</p>
<p class="calibre3">Within this method, the aspect ratio for the PiP window is defined as <code>16:9</code>, a common choice for video content, by using the <code>Rational</code> class. This aspect ratio is crucial as it dictates the proportional relationship between the width and height of the PiP window, ensuring the video maintains its intended appearance without distortion.</p>
<p class="calibre3">To apply <a id="_idIndexMarker1025" class="calibre6 pcalibre1 pcalibre"/>this aspect ratio, the <code>PictureInPictureParams.Builder</code> class is utilized to construct a configuration object. By invoking <code>setAspectRatio(aspectRatio)</code> on the builder, the previously defined aspect ratio is applied to this configuration.</p>
<p class="calibre3">While <code>setAspectRatio(Rational)</code> sets the preferred aspect ratio of the PiP window, meaning that the system will try to maintain this aspect ratio when displaying the PiP window, it may not always be possible depending on the device and screen size constraints. Android 11 (API level 30) introduced <code>setMaxAspectRatio(Rational)</code> and <code>setMinAspectRatio(Rational)</code> for defining the maximum and minimum aspect ratios. Additionally, <code>setMaxSize(int, int)</code> allows setting the maximum size of the PiP window, providing greater control over how the PiP window appears on different devices.</p>
<p class="callout-heading">Note</p>
<p class="callout">There are also other <strong class="source-inline1">PictureInPictureParams.Builder</strong> options that could be applied. For more information about these options, refer to the documentation: <a href="https://developer.android.com/reference/android/app/PictureInPictureParams.Builder" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/reference/android/app/PictureInPictureParams.Builder</a>.</p>
<p class="calibre3">The <code>build()</code> method then <a id="_idIndexMarker1026" class="calibre6 pcalibre1 pcalibre"/>compiles these configurations into a <code>PictureInPictureParams</code> object, which encapsulates all the necessary settings for entering PiP mode.</p>
<p class="calibre3">Finally, the <code>enterPictureInPictureMode(params)</code> method is invoked, signaling the system to transition the current <code>Activity</code> class into PiP mode using the specified parameters.</p>
<p class="calibre3">Now that we have integrated this feature, when we are on the playback screen and we leave the application, we should still see the video on the PiP screen:</p>
<div><div><img alt="Figure 9.1: Playback using the PiP feature" src="img/B19443_09_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1: Playback using the PiP feature</p>
<p class="calibre3">The <code>PictureInPictureParams.Builder</code> class in Android provides a customizable <a id="_idIndexMarker1027" class="calibre6 pcalibre1 pcalibre"/>way to configure the behavior and appearance of an app when it enters PiP mode. Apart from setting the aspect ratio with <code>setAspectRatio()</code>, as we did in the previous instruction, there are several other options available to tailor the PiP experience:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Actions</strong>: Using <strong class="source-inline1">setActions(List&lt;RemoteAction&gt;)</strong>, developers can specify a list <a id="_idIndexMarker1028" class="calibre6 pcalibre1 pcalibre"/>of actions that the user can perform while in PiP mode. These actions are represented as <strong class="source-inline1">RemoteAction</strong> objects and can include things such as play, pause, or skip. These actions appear as buttons in the PiP window, providing interactive elements for the user without needing to return to the full app interface.</li>
<li class="calibre14"><strong class="bold">Auto enter/exit</strong>: Through <strong class="source-inline1">setAutoEnterEnabled(boolean)</strong> and <strong class="source-inline1">setAutoExitEnabled(boolean)</strong> (introduced in later Android versions), developers <a id="_idIndexMarker1029" class="calibre6 pcalibre1 pcalibre"/>can control whether the app should automatically enter or exit PiP mode based on certain conditions, such as media playback state.</li>
<li class="calibre14"><strong class="bold">Seamless resize</strong>: By invoking <strong class="source-inline1">setSeamlessResizeEnabled(boolean)</strong>, it’s possible to enable or disable <a id="_idIndexMarker1030" class="calibre6 pcalibre1 pcalibre"/>seamless resizing for the PiP window. This option, available in later Android versions, helps make the transition into and out of PiP mode smoother visually.</li>
<li class="calibre14"><strong class="bold">Source rect hint</strong>: <strong class="source-inline1">setSourceRectHint(Rect)</strong> allows developers to suggest <a id="_idIndexMarker1031" class="calibre6 pcalibre1 pcalibre"/>a preferred area of the screen that the PiP mode should try to align with when entering PiP mode. This can be useful for guiding the system on where the PiP window should ideally be placed based on the app’s UI layout.</li>
</ul>
<p class="calibre3">Let’s use these <a id="_idIndexMarker1032" class="calibre6 pcalibre1 pcalibre"/>options to add actions so that the user can toggle between play and pause in the PiP view. But first, a little theory.</p>
<h2 id="_idParaDest-186" class="calibre7"><a id="_idTextAnchor188" class="calibre6 pcalibre1 pcalibre"/>Understanding how to add actions to the PiP mode</h2>
<p class="calibre3">Integrating actions into PiP mode enhances user interaction by allowing direct control over app <a id="_idIndexMarker1033" class="calibre6 pcalibre1 pcalibre"/>functionality without leaving the PiP window. By using the <code>setActions(List&lt;RemoteAction&gt;)</code> method, you can create a more immersive and user-friendly experience, offering controls such as play, pause, or skip directly within the PiP overlay. This capability is especially valuable in media applications, where users often need to manage playback without disrupting their current onscreen activities.</p>
<p class="calibre3">In a moment, we will learn how to effectively create and manage these <code>RemoteAction</code> objects, ensuring our app’s PiP mode is both functional and engaging, complementing the existing array of PiP features. But let’s dig into the concepts further.</p>
<p class="calibre3">Each <code>RemoteAction</code> object represents an actionable element in the PiP window, such as a button for play, pause, or skip functionality. To create these actions, we would have to specify an icon, a title, a <code>PendingIntent</code> object that defines the action to take when the user interacts with the button, and a description for accessibility purposes.</p>
<p class="calibre3">The utilization of a <code>PendingIntent</code> object is crucial here, as it allows the action to trigger specific behaviors in your app when invoked. An <code>Intent</code> object in Android is like a message that can signify a wide range of events, including system boot completion, network changes, or custom events defined by the application. Typically, these intents <a id="_idIndexMarker1034" class="calibre6 pcalibre1 pcalibre"/>are directed toward a <code>BroadcastReceiver</code> instance within your application.</p>
<p class="calibre3">A <code>BroadcastReceiver</code> instance in Android is a fundamental component that enables applications to listen for and respond to broadcast messages from other applications or from the system itself.  When an intent that matches a <code>BroadcastReceiver</code> instance’s filter is broadcasted, the <code>BroadcastReceiver</code> instance’s <code>onReceive()</code> method is invoked, allowing the app to execute logic in response to the event. This mechanism provides a powerful way for applications to react to global system events or inter-app communication without needing to be running in the foreground, making <code>BroadcastReceiver</code> instances a key tool for event-driven programming in Android.</p>
<p class="calibre3">In our case, this <code>BroadcastReceiver</code> instance is responsible for listening to and processing the broadcasted intents sent by PiP actions. For instance, when a user presses the <code>PendingIntent</code> object associated with the play action is broadcasted, and the corresponding receiver in your app catches this intent and triggers the media to play.</p>
<p class="calibre3">The need for a <code>BroadcastReceiver</code> instance arises from the decoupled nature of PiP action intents from direct method calls within your app. Since these actions occur outside the regular UI flow, using a broadcast mechanism allows your app to respond to these actions asynchronously and perform the necessary operations, such as updating the media playback state. This setup ensures that your app can handle PiP controls effectively, providing a seamless experience for users even when interacting with the app from the PiP window.</p>
<p class="calibre3">Now that we know how to create <code>RemoteAction</code> objects, let’s apply our learnings in our project.</p>
<h2 id="_idParaDest-187" class="calibre7"><a id="_idTextAnchor189" class="calibre6 pcalibre1 pcalibre"/>Adding actions to the PiP mode</h2>
<p class="calibre3">Let’s start <a id="_idIndexMarker1035" class="calibre6 pcalibre1 pcalibre"/>by creating our <code>BroadcastReceiver</code> subclass. This class will extend <code>BroadcastReceiver</code> and override the <code>onReceive()</code> method, where you’ll define how your app should react to PiP action <code>Intent</code> objects:</p>
<pre class="source-code">
class PiPActionReceiver(private val togglePlayPause: () -&gt; Unit) : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent:
    Intent?) {
        when (intent?.action) {
            ACTION_TOGGLE_PLAY -&gt; {
                togglePlayPause()
            }
        }
    }
    companion object {
        const val ACTION_TOGGLE_PLAY =
            "com.packflix.action.TOGGLE_PLAY"
    }
}</pre> <p class="calibre3">In the <code>onReceive</code> method, a check is performed on the <code>Intent</code> action to determine if it matches the <code>ACTION_TOGGLE_PLAY</code> action. If it does, the play/pause toggle logic will be executed. In this case, we will execute a callback, as the logic to play or pause the playback will likely be outside this receiver.</p>
<p class="calibre3">Next, we need to register the <code>BroadcastReceiver</code> instance so that it can receive the <code>Intent</code> object. This can be done in two ways:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Manifest declaration</strong>: Registering in the <strong class="source-inline1">AndroidManifest.xml</strong> file is suitable <a id="_idIndexMarker1036" class="calibre6 pcalibre1 pcalibre"/>for actions that should be received even if your app is not running. However, for PiP actions, dynamic registration in the activity or service that handles PiP mode is often more appropriate.</li>
<li class="calibre14"><strong class="bold">Dynamic registration</strong>: Since PiP actions are specifically related to when our app is <a id="_idIndexMarker1037" class="calibre6 pcalibre1 pcalibre"/>in PiP mode, registering the <strong class="source-inline1">BroadcastReceiver</strong> instance dynamically in our <strong class="source-inline1">PlaybackActivity</strong> class allows for more control and is contextually relevant.</li>
</ul>
<p class="calibre3">We will <a id="_idIndexMarker1038" class="calibre6 pcalibre1 pcalibre"/>register the <code>BroadcastReceiver</code> instance using dynamic registration. In our <code>PlaybackActivity</code> class, the implementation will look like this:</p>
<pre class="source-code">
private lateinit var pipActionReceiver: PiPActionReceiver
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    pipActionReceiver = PiPActionReceiver {
        //TODO handle there the play/pause logic
    }
    val filter =
        IntentFilter(PiPActionReceiver.ACTION_TOGGLE_PLAY)
    if (Build.VERSION.SDK_INT &gt;=
    Build.VERSION_CODES.TIRAMISU) {
        registerReceiver(pipActionReceiver, filter,
            RECEIVER_NOT_EXPORTED)
    } else {
        registerReceiver(pipActionReceiver, filter)
    }
    setContent {
        PlaybackScreen()
    }
}</pre> <p class="calibre3">First, we will <a id="_idIndexMarker1039" class="calibre6 pcalibre1 pcalibre"/>declare a <code>BroadcastReceiver</code> variable named <code>pipActionReceiver</code>. This receiver is not initialized immediately (it is declared as <code>lateinit var</code>) because it will be set up in the <code>onCreate</code> method of our activity.</p>
<p class="calibre3">In the <code>onCreate</code> method, we will initialize the <code>BroadcastReceiver</code> variable. The <code>pipActionReceiver</code> variable is instantiated and assigned a lambda function as its argument. This function is intended to contain the logic that handles the play/pause action.</p>
<p class="calibre3">Then, we will register the <code>BroadcastReceiver</code> variable, indicating the <code>Intent</code> filter signal it will listen to. The registration method differs depending on the SDK version:</p>
<ul class="calibre15">
<li class="calibre14">For SDK versions Tiramisu (Android 13, API level 33) and above, you use the <strong class="source-inline1">registerReceiver</strong> method with an additional flag, <strong class="source-inline1">RECEIVER_NOT_EXPORTED</strong>, for enhanced security, ensuring that your receiver does not inadvertently become accessible to other apps.</li>
<li class="calibre14">For earlier versions, you register the receiver without this flag. This ensures backward compatibility while adhering to best practices for app security on newer devices.</li>
</ul>
<p class="calibre3">Now, let’s create the action that will trigger the <code>Intent</code> action needed to launch the <code>BroadcastReceiver</code> instance:</p>
<pre class="source-code">
private fun getIntentForTogglePlayPauseAction():
RemoteAction {
    val icon: Icon = Icon.createWithResource(this,
        R.drawable.baseline_play_arrow_24)
    val intent =
    Intent(PiPActionReceiver.ACTION_TOGGLE_PLAY).let {
   intent -&gt;
        PendingIntent.getBroadcast(this, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or
                PendingIntent.FLAG_IMMUTABLE)
    }
    return RemoteAction(icon, "Toggle Play", "Play or pause
        the video", intent)
}</pre> <p class="calibre3">In this code, we are creating a <code>RemoteAction</code> method. The first line inside the method <a id="_idIndexMarker1040" class="calibre6 pcalibre1 pcalibre"/>creates an <code>Icon</code> object from a drawable resource <code>(R.drawable.baseline_play_arrow_24)</code>. This icon visually represents the toggle play/pause action to the user.</p>
<p class="calibre3">Then, a new <code>Intent</code> object is instantiated with the <code>PiPActionReceiver.ACTION_TOGGLE_PLAY</code> action. This <code>Intent</code> object is designed to be broadcasted when the <code>RemoteAction</code> method is invoked by the user. The <code>let</code> block is utilized to directly chain the creation of a <code>PendingIntent</code> object that wraps this <code>Intent</code> object, making it executable from outside the application context.</p>
<p class="calibre3">The <code>PendingIntent.getBroadcast</code> method is called to create a <code>PendingIntent</code> object that broadcasts the <code>Intent</code> object. This <code>PendingIntent</code> object is configured with <code>PendingIntent.FLAG_UPDATE_CURRENT</code> to ensure that if the pending <code>Intent</code> object already exists, it will be reused but with its extra data updated. <code>PendingIntent.FLAG_IMMUTABLE</code> is used for security purposes, marking the <code>Intent</code> object as immutable to prevent alterations after creation.</p>
<p class="calibre3">Finally, a <code>RemoteAction</code> object is instantiated and returned. This object takes the previously created icon, a title (<code>PendingIntent</code> object as its parameters. The title and content description should be concise yet descriptive enough to inform the user of the action’s purpose, adhering to accessibility standards.</p>
<p class="calibre3">Now, we <a id="_idIndexMarker1041" class="calibre6 pcalibre1 pcalibre"/>need to configure this action as a parameter for our PiP configuration. We will modify the existing configuration as follows:</p>
<pre class="source-code">
override fun onUserLeaveHint() {
    super.onUserLeaveHint()
    val aspectRatio = Rational(16, 9)
    val params = PictureInPictureParams.Builder()
        .setAspectRatio(aspectRatio)
        .setActions(listOf(
            getIntentForTogglePlayPauseAction()))
        .build()
    enterPictureInPictureMode(params)
}</pre> <p class="calibre3">Here, we are <a id="_idIndexMarker1042" class="calibre6 pcalibre1 pcalibre"/>using the <code>setActions()</code> function to add a list including the new action.</p>
<p class="calibre3">The last step is to handle the logic to effectively toggle between play and pause. We already have this functionality implemented in the <code>ViewModel</code> component, so we just have to inject the <code>PlaybackViewModel</code> component in the <code>Activity</code> class and call the <code>togglePlayPause()</code> function:</p>
<pre class="source-code">
@AndroidEntryPoint
class PlaybackActivity: ComponentActivity() {
    private val viewModel: PlaybackViewModel by
    viewModels()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        pipActionReceiver = PiPActionReceiver {
            viewModel.togglePlayPause()
        }
        ...
    }
}</pre> <p class="calibre3">As we <a id="_idIndexMarker1043" class="calibre6 pcalibre1 pcalibre"/>can see, we are injecting <code>PlaybackViewModel</code> and then, the <code>viewModel.toggle</code><strong class="source-inline">
PlayPause()</strong> function will be invoked when the receiver detects that the user has sent a broadcast with the play/pause action.</p>
<p class="calibre3">If we execute the code with these changes, we should see the <strong class="bold">Play</strong> button in our PiP UI:</p>
<div><div><img alt="Figure 9.2: PiP view with some actions" src="img/B19443_09_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2: PiP view with some actions</p>
<p class="calibre3">Having <a id="_idIndexMarker1044" class="calibre6 pcalibre1 pcalibre"/>implemented PiP mode, let’s move on to connecting with other devices for media playback using the <code>MediaRouter</code> API, which allows your app to cast or stream content to devices such as smart TVs or Chromecast. We’ll cover how to use <code>MediaRouter</code> to identify compatible devices and manage media streaming to them, enhancing our app’s functionality.</p>
<h1 id="_idParaDest-188" class="calibre5"><a id="_idTextAnchor190" class="calibre6 pcalibre1 pcalibre"/>Getting to know MediaRouter</h1>
<p class="calibre3"><code>MediaRouter</code> is a pivotal component in Android development, especially for applications that deal with multimedia content. It acts as a bridge between devices running your <a id="_idIndexMarker1045" class="calibre6 pcalibre1 pcalibre"/>app and external devices such as Google Chromecast, smart TVs, and various speakers that support media routing capabilities.</p>
<p class="calibre3">The core function of <code>MediaRouter</code> is to facilitate the streaming of multimedia content—be it audio, video, or images—from the user’s current device to another device that provides a better or more suitable playback experience. It intelligently discovers available media routes and allows the application to connect to them, thereby extending the multimedia capabilities beyond the confines of the user’s primary device.</p>
<p class="calibre3">Android’s <code>MediaRouter</code> API provides a framework that developers can utilize to search for and interact with media route providers registered on the local network. These providers represent devices or services capable of media playback. With <code>MediaRouter</code>, applications can not only discover these routes dynamically but also present the user with a streamlined interface for choosing their preferred playback devices, all while managing the connections and playback state seamlessly across devices.</p>
<p class="calibre3">The use of <code>MediaRouter</code> in Android apps opens up a myriad of possibilities for enhancing <a id="_idIndexMarker1046" class="calibre6 pcalibre1 pcalibre"/>the user’s media consumption experience. Here are some typical use cases:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Casting videos to larger screens</strong>: One of the most common uses of <strong class="source-inline1">MediaRouter</strong> is casting videos from a mobile device to a larger display, such as a smart TV or a monitor with Chromecast. This is particularly appealing for watching movies, TV shows, or user-generated content on a bigger screen that offers a more immersive viewing experience.</li>
<li class="calibre14"><strong class="bold">Streaming music to external speakers</strong>: <strong class="source-inline1">MediaRouter</strong> allows apps to stream music to external speakers, amplifying the audio experience. This is ideal for parties, workouts, or simply enhancing the quality of music playback beyond what the phone’s or tablet’s built-in speakers can provide.</li>
<li class="calibre14"><strong class="bold">Displaying images on a shared screen</strong>: Apps can use <strong class="source-inline1">MediaRouter</strong> to send images to a smart TV or a connected display, making it perfect for sharing photos with a group, conducting presentations, or viewing artwork in higher resolution.</li>
<li class="calibre14"><strong class="bold">Gaming</strong>: With the capability to cast screen content to a larger display, gaming apps can leverage <strong class="source-inline1">MediaRouter</strong> to provide a console-like gaming experience on the TV while using the mobile device as a controller.</li>
<li class="calibre14"><strong class="bold">Fitness and education</strong>: For apps focused on fitness or education, casting instructional <a id="_idIndexMarker1047" class="calibre6 pcalibre1 pcalibre"/>videos or workout routines to a TV allows users to follow along more comfortably and effectively.</li>
</ul>
<p class="calibre3">In each of these use cases, <code>MediaRouter</code> significantly enhances the functionality of apps by leveraging the power of connected devices, thus offering users a more flexible and enriched media playback experience. Through its comprehensive API, developers can create applications that are not just confined to the small screens of mobile devices but are instead capable of bringing content to life on any compatible device within the home network.</p>
<h2 id="_idParaDest-189" class="calibre7"><a id="_idTextAnchor191" class="calibre6 pcalibre1 pcalibre"/>Setting up MediaRouter</h2>
<p class="calibre3">Integrating <code>MediaRouter</code> into our Android app involves a few key setup steps, including <a id="_idIndexMarker1048" class="calibre6 pcalibre1 pcalibre"/>adding the necessary dependencies to your project and ensuring you have the correct permissions in place.</p>
<p class="calibre3">First, we’ll need to include the <code>MediaRouter</code> library dependencies in our <code>libs.versions.toml</code> file. This library provides the classes and interfaces needed to discover and interact with media route providers:</p>
<pre class="source-code">
[versions]
...
mediarouter = "1.7.0"
google-cast = "21.4.0"
[libraries]
...
media-router = { group = "androidx.mediarouter", name="mediarouter", version.ref="mediarouter"}
google-cast = { group = "com.google.android.gms", name="play-services-cast-framework", version.ref="google-cast"}</pre> <p class="calibre3">As we plan to support casting to Chromecast devices or other Google Cast-enabled devices, we need the <code>play-services-cast-framework</code> library. This library facilitates the integration with Google Cast devices and extends the capabilities of <code>MediaRouter</code>.</p>
<p class="calibre3">The next step <a id="_idIndexMarker1049" class="calibre6 pcalibre1 pcalibre"/>will be to add it to our <code>build.gradle</code> module:</p>
<pre class="source-code">
    implementation(libs.media.router)
    implementation(libs.google.cast)</pre> <p class="calibre3">Now, to enable <code>MediaRouter</code> to discover and interact with devices on the local network, we must declare the necessary permissions in our app’s <code>AndroidManifest.xml</code> file:</p>
<pre class="source-code">
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt;
&lt;uses-permission android:name="android.permission.INTERNET"/&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_CONNECT" /&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_SCAN" /&gt;
&lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS" /&gt;</pre> <p class="calibre3">We are including permissions here for the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Internet permission</strong>: Since <strong class="source-inline1">MediaRouter</strong> may use the network to communicate with media route providers, your app needs permission to access the internet. We have already needed to declare this permission for the previous chapters, so it shouldn’t be new.</li>
<li class="calibre14"><strong class="bold">Network state permissions</strong>: These permissions are required for the app to monitor changes in network connectivity, which is essential for discovering devices on the network.</li>
<li class="calibre14"><strong class="bold">Local network permissions (Android 12 and above)</strong>: Starting with Android 12 (API level 31), if your app targets API level 31 or higher and needs to discover devices on the local network, you must also declare the permission.</li>
<li class="calibre14"><strong class="bold">Post notifications</strong>: For Android 12+, to access the local network for device discovery, it is mandatory to have this permission.</li>
</ul>
<p class="calibre3">After adding <a id="_idIndexMarker1050" class="calibre6 pcalibre1 pcalibre"/>the necessary dependencies and permissions, our project is ready to use <code>MediaRouter</code> for discovering media route providers and enabling media streaming to external devices.</p>
<h2 id="_idParaDest-190" class="calibre7"><a id="_idTextAnchor192" class="calibre6 pcalibre1 pcalibre"/>Discovering media routes</h2>
<p class="calibre3">Once your app is set up with the necessary <code>MediaRouter</code> dependencies and permissions, the <a id="_idIndexMarker1051" class="calibre6 pcalibre1 pcalibre"/>next step is discovering available <a id="_idIndexMarker1052" class="calibre6 pcalibre1 pcalibre"/>media routes. This involves identifying external devices or services your app can stream media to. Android’s <code>MediaRouter</code> framework simplifies this by providing tools to both discover media routes and present them to users.</p>
<h3 class="calibre9">Learning about MediaRouteProvider</h3>
<p class="calibre3"><code>MediaRouteProvider</code> is a component that publishes media routes to <code>MediaRouter</code>. It acts <a id="_idIndexMarker1053" class="calibre6 pcalibre1 pcalibre"/>as a bridge between your app <a id="_idIndexMarker1054" class="calibre6 pcalibre1 pcalibre"/>and external devices or services, such as speakers, TVs, or other Cast-enabled devices. There are two options to use  <code>MediaRouteProvider</code>:</p>
<ul class="calibre15">
<li class="calibre14">The <a id="_idIndexMarker1055" class="calibre6 pcalibre1 pcalibre"/>default <strong class="source-inline1">MediaRouteProvider</strong> implementation: For most use cases, especially when integrating with Google Cast devices, Android provides a default <strong class="source-inline1">MediaRouteProvider</strong> implementation, so you don’t need to implement your own. The Google Cast framework automatically discovers compatible devices and makes them available as media routes.</li>
<li class="calibre14">A custom <strong class="source-inline1">MediaRouteProvider</strong> implementation: If you need to discover devices <a id="_idIndexMarker1056" class="calibre6 pcalibre1 pcalibre"/>for a custom protocol or a specific type of media routing not covered by Google Cast, you can implement your own <strong class="source-inline1">MediaRouteProvider</strong> instance by extending the <strong class="source-inline1">MediaRouteProvider</strong> class. This involves defining the discovery logic and publishing routes to <strong class="source-inline1">MediaRouter</strong>.</li>
</ul>
<p class="calibre3">However, creating a custom <code>MediaRouteProvider</code> implementation is beyond the scope <a id="_idIndexMarker1057" class="calibre6 pcalibre1 pcalibre"/>of basic media routing and requires in-depth knowledge <a id="_idIndexMarker1058" class="calibre6 pcalibre1 pcalibre"/>of the specific hardware or protocol you’re targeting. If you want to know more, here is the official documentation to create a customized <code>MediaRouteProvider</code> implementation: <a href="https://developer.android.com/media/routing/mediarouteprovider" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/media/routing/mediarouteprovider</a>.</p>
<p class="calibre3">We will use the default <code>MediaRouteProvider</code> implementation instead.</p>
<h3 class="calibre9">Using the MediaRouter class</h3>
<p class="calibre3">The <code>MediaRouter</code> class is your primary tool for interacting with media routes. Here’s how you <a id="_idIndexMarker1059" class="calibre6 pcalibre1 pcalibre"/>can use it to discover and monitor available media routes.</p>
<p class="calibre3">We will <a id="_idIndexMarker1060" class="calibre6 pcalibre1 pcalibre"/>begin by defining a <code>MediaRouteSelector</code> instance and allow it to start discovering other devices to send the media to. We will use <code>LaunchedEffect</code> to tie the discovery process to the composable’s lifecycle:</p>
<pre class="source-code">
@Composable
fun MediaRouteDiscoveryOptions(mediaRouter: MediaRouter) {
    val context = LocalContext.current
    val routeSelector = remember {
        MediaRouteSelector.Builder()
            .addControlCategory(
                MediaControlIntent.CATEGORY_REMOTE_PLAYBACK
            )
            .build()
    }
    val mediaRoutes = remember {
    mutableStateListOf&lt;MediaRouter.RouteInfo&gt;() }
    DisposableEffect(mediaRouter) {
        mediaRouter.addCallback(routeSelector, callback,
            MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN)
        onDispose {
            mediaRouter.removeCallback(callback)
        }
    }
}</pre> <p class="calibre3">This composable <a id="_idIndexMarker1061" class="calibre6 pcalibre1 pcalibre"/>function accepts a <code>MediaRouter</code> instance as a parameter, highlighting its dependency on this framework for discovering media routes.</p>
<p class="calibre3">The function <a id="_idIndexMarker1062" class="calibre6 pcalibre1 pcalibre"/>begins by obtaining the current <code>Context</code> value using <code>LocalContext.current</code>, then it creates a <code>MediaRouterSelector</code> instance. This selector is specifically configured to filter for routes supporting live video content. The use of <code>remember</code> ensures that the <code>MediaRouteSelector</code> instance is preserved across recompositions of the composable, optimizing performance by preventing unnecessary reinitializations.</p>
<p class="calibre3">Then, we are adding a <code>DisposableEffect</code> composable, which encapsulates the logic for starting and stopping media route discovery in alignment with the composable’s lifecycle. By passing <code>MediaRouter</code> as a key to <code>DisposableEffect</code>, the enclosed block of code is executed in a coroutine when the composable is first composed into the UI, and the coroutine is canceled when the composable is removed, effectively managing the lifecycle of the discovery process. Within this block, the <code>addCallback</code> method of <code>MediaRouter</code> is called to register a callback with the active scan flag, initiating the active scanning for media routes that match the criteria set by <code>routeSelector</code>. The <code>onDispose</code> block within <code>DisposableEffect</code> serves as a cleanup mechanism, where the callback is unregistered from <code>MediaRouter</code> when the composable <a id="_idIndexMarker1063" class="calibre6 pcalibre1 pcalibre"/>is disposed of, ensuring resources are freed and background processing is minimized.</p>
<p class="calibre3">Now, we will <a id="_idIndexMarker1064" class="calibre6 pcalibre1 pcalibre"/>create a callback that we have included in the <code>addCallback</code> function described previously:</p>
<pre class="source-code">
val callback = remember {
    object : MediaRouter.Callback() {
        override fun onRouteAdded(router: MediaRouter,
        route: MediaRouter.RouteInfo) {
            mediaRoutes.add(route)
        }
        override fun onRouteRemoved(router: MediaRouter,
        route: MediaRouter.RouteInfo) {
            mediaRoutes.remove(route)
        }
    }
}</pre> <p class="calibre3">We are instantiating a <code>MediaRouter.Callback</code> listener, using <code>remember</code> to avoid needing to recreate it every time the app’s UI updates.</p>
<p class="calibre3">This listener, <code>MediaRouter.Callback</code>, has two main jobs through its <code>onRouteAdded</code> and <code>onRouteRemoved</code> methods. When a new device becomes available for casting media, <code>onRouteAdded</code> gets called, and the app adds this new route to a list called <code>mediaRoutes</code>. This list is crucial for the app to know what devices are available at any moment. On the flip side, when a device goes offline or disconnects, <code>onRouteRemoved</code> is called, and the app removes that route from the list, ensuring the list stays current.</p>
<p class="calibre3">Effectively, this setup allows the app to dynamically adjust to changes in the available devices for media casting.</p>
<p class="calibre3">To provide users <a id="_idIndexMarker1065" class="calibre6 pcalibre1 pcalibre"/>with an easy way to select from <a id="_idIndexMarker1066" class="calibre6 pcalibre1 pcalibre"/>these available devices, we need to integrate a button designed for this purpose. The <code>MediaRouter</code> API offers a ready-made button that displays the available devices for casting. Although this button is an Android view and not a composable, we can still use it in Jetpack Compose by wrapping it with the <code>AndroidView</code> composable. Here’s how we can do it:</p>
<pre class="source-code">
AndroidView(
    factory = { ctx -&gt;
        MediaRouteButton(ctx).apply {
            setRouteSelector(routeSelector)
        }
    },
    modifier = Modifier
        .wrapContentWidth()
        .wrapContentHeight()
)</pre> <p class="calibre3">Now, we just have to use the <code>MediaRouteDiscoveryOptions</code> composable from our playback screen:</p>
<pre class="source-code">
@Composable
fun TopMediaRow(mediaRouter: MediaRouter, modifier:
Modifier = Modifier) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .padding(20.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = "S1:E1 \"Pilot\"", color = Color.White)
        MediaRouteDiscoveryOptions(mediaRouter =
            mediaRouter)
    }
}</pre> <p class="calibre3">Here, we have <a id="_idIndexMarker1067" class="calibre6 pcalibre1 pcalibre"/>added the <code>MediaRouteDiscoveryOptions</code> composable to our already existing <code>TopMediaRow</code> function.</p>
<p class="calibre3">When <a id="_idIndexMarker1068" class="calibre6 pcalibre1 pcalibre"/>calling the <code>TopMediaRow</code> function we will pass it an instance of <code>mediaRouter</code> that we had obtained before, using <code>LocalContext</code>:</p>
<pre class="source-code">
TopMediaRow(
    mediaRouter =
        MediaRouter.getInstance(LocalContext.current),
    modifier = Modifier.align(Alignment.TopCenter))</pre> <p class="calibre3">Now, we will see the <code>PlaybackScreen</code> composable. If we click it, <code>MediaRouter</code> will automatically search for devices:</p>
<div><div><img alt="Figure 9.3: MediaRouter searching for devices" src="img/B19443_09_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3: MediaRouter searching for devices</p>
<p class="calibre3">If it cannot <a id="_idIndexMarker1069" class="calibre6 pcalibre1 pcalibre"/>find any device, it will show a message encouraging <a id="_idIndexMarker1070" class="calibre6 pcalibre1 pcalibre"/>the user to check the connection:</p>
<div><div><img alt="Figure 9.4: MediaRouter functionality, prompting the user to check the device connections" src="img/B19443_09_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4: MediaRouter functionality, prompting the user to check the device connections</p>
<p class="calibre3">After discovering available media routes using the <code>MediaRouter</code> API, the next step is connecting to a selected device for media playback. This involves two main actions: selecting a media route and then establishing a connection to that route. Here’s how you can approach this process.</p>
<p class="calibre3">When utilizing the built-in media route selector with <code>MediaRouteButton</code>, the process of connecting to a device is streamlined. <code>MediaRouteButton</code> automatically handles the display of available media routes based on the criteria defined in a <code>MediaRouteSelector</code> instance. Users can then select their preferred device directly from the UI that <code>MediaRouteButton</code> presents.</p>
<p class="calibre3">Once a user selects a route from the dialog, the connection to that device is automatically managed by the <code>MediaRouter</code> framework based on the route’s capabilities and the types of media specified in your <code>MediaRouteSelector</code> instance. There’s no need for additional manual connection management in your application code.</p>
<p class="calibre3">With the <a id="_idIndexMarker1071" class="calibre6 pcalibre1 pcalibre"/>route selected and a connection established, you can <a id="_idIndexMarker1072" class="calibre6 pcalibre1 pcalibre"/>control media playback through the selected route. This typically involves using media control APIs that are appropriate for your application’s media content and the capabilities of the selected route. We will learn how can we cast media playback for Google Cast devices in the next section.</p>
<h1 id="_idParaDest-191" class="calibre5"><a id="_idTextAnchor193" class="calibre6 pcalibre1 pcalibre"/>Connecting to Google Chromecast devices</h1>
<p class="calibre3">Google Cast is a powerful technology developed by Google that allows users to wirelessly stream audio and video content from their smartphones, tablets, or computers <a id="_idIndexMarker1073" class="calibre6 pcalibre1 pcalibre"/>directly to Cast-enabled devices. This technology is embedded in a wide array of devices, including Chromecast dongles, smart TVs, and speakers, making it accessible to a vast user base. At its core, Google Cast works by establishing a connection between a Cast-enabled app on a mobile device or computer and a Cast-enabled receiver device. Once a connection is made, media can be played back on the receiver device, effectively turning it into a remote screen or speaker for the content being cast.</p>
<p class="calibre3">The functionality of Google Cast is not limited to streaming media from the internet. It also enables the mirroring of content from the sender device’s screen, extending its utility to presentations, educational content, and more. Google Cast operates over Wi-Fi, ensuring high-quality streaming performance without the need for physical cables or adapters.</p>
<p class="calibre3">We have already done some steps: we have already included the library and we are already detecting the devices that allow casting. Now, we need to establish a cast session. This session facilitates a connection between your app and the selected Cast device, enabling media control and playback on the larger screen. This process hinges on effectively using <code>CastContext</code> and adeptly managing Cast session events.</p>
<p class="calibre3"><code>CastContext</code> is central to initiating and managing Cast sessions in your application, providing the necessary APIs to connect to the selected Cast device. Here’s how to initiate a connection.</p>
<p class="calibre3">First, we need to ensure that you have initialized <code>CastContext</code> in your application. This is typically done in the <code>Application</code> subclass or your main activity. We will initialize it in our <code>PlaybackActivity</code> class:</p>
<pre class="source-code">
val castContext = CastContext.getSharedInstance(context)</pre> <p class="calibre3">Then, we need <a id="_idIndexMarker1074" class="calibre6 pcalibre1 pcalibre"/>to select a device. We have already implemented <code>MediaRouterbutton</code>, which will automatically handle the selection. Once a device is selected, the Cast SDK automatically initiates a connection to the device. This process is abstracted away from the developer, but it’s crucial to listen for session events to manage the connection effectively.</p>
<p class="calibre3">The Cast SDK provides callbacks for session events such as starting, ending, resuming, and suspending. Handling these events allows your app to respond to changes in the session state, such as updating the UI or pausing media playback when the session ends.</p>
<p class="calibre3">To listen to these session events, we must implement <code>SessionManagerListener</code>:</p>
<pre class="source-code">
private val sessionManagerListener = object : SessionManagerListener&lt;CastSession&gt; {
    override fun onSessionStarted(session: CastSession,
    sessionId: String) {
        castSession = session
        updateUIForCastSession(true)
    }
    override fun onSessionEnded(p0: CastSession, p1: Int) {
        castSession = null
        updateUIForCastSession(false)
    }
    override fun onSessionResumed(session: CastSession, p1:
    Boolean) {
        castSession = session
        updateUIForCastSession(true)
    }
    override fun onSessionStarting(p0: CastSession) {}
    override fun onSessionStartFailed(
        p0: CastSession, p1: Int) {}
    override fun onSessionResuming(session: CastSession,
        p1: String) {}
    override fun onSessionResumeFailed(session:
        CastSession, p1: Int) { }
    override fun onSessionEnding(session: CastSession) {}
    override fun onSessionSuspended(p0: CastSession,
        p1: Int) {}
}</pre> <p class="calibre3">Here, we are implementing our <code>SessionManagerListener&lt;CastSession&gt;</code> interface, crucial for managing Google Cast sessions. This listener is designed to react to various events <a id="_idIndexMarker1075" class="calibre6 pcalibre1 pcalibre"/>related to the lifecycle of a Cast session, including its start, end, resumption, and failure cases. Let’s look deeper into this implementation:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">onSessionStarted</strong>: This callback is invoked when a new Cast session has successfully started. Here, the <strong class="source-inline1">session</strong> parameter, which is an instance of <strong class="source-inline1">CastSession</strong>, represents the newly established session. The method sets the global <strong class="source-inline1">castSession</strong> variable to this instance, effectively marking the beginning of a session. Subsequently, it calls <strong class="source-inline1">updateUIForCastSession(true)</strong>, a method that will be implemented to update the application’s UI to reflect that casting has started.</li>
<li class="calibre14"><strong class="source-inline1">onSessionEnded</strong>: Triggered when an existing Cast session ends, this method clears the <strong class="source-inline1">castSession</strong> variable by setting it to <strong class="source-inline1">null</strong>, indicating that there is no longer an active Cast session. It also invokes <strong class="source-inline1">updateUIForCastSession(false)</strong> to adjust the UI, signaling to the user that casting has stopped.</li>
<li class="calibre14"><strong class="source-inline1">onSessionResumed</strong>: Similar to <strong class="source-inline1">onSessionStarted</strong>, this callback is called when a previously suspended Cast session is resumed. It updates <strong class="source-inline1">castSession</strong> with the current session and calls <strong class="source-inline1">updateUIForCastSession(true)</strong> to reflect the resumption of casting in the UI.</li>
<li class="calibre14"><strong class="source-inline1">onSessionStarting</strong> and <strong class="source-inline1">onSessionResuming</strong>: Indicate that a session is in the process of starting or resuming but has not yet completed. No action is taken in these callbacks in our case.</li>
<li class="calibre14"><strong class="source-inline1">onSessionStartFailed</strong> and <strong class="source-inline1">onSessionResumeFailed</strong>: Called when attempts to start or resume a session fail. Again, no action is specified in our case, but these would be appropriate places to handle errors, such as by notifying the user or attempting to restart the session.</li>
<li class="calibre14"><strong class="source-inline1">onSessionEnding</strong> and <strong class="source-inline1">onSessionSuspended</strong>: These callbacks are triggered when a session is in the process of ending or being suspended. As with the start and resume events, no specific actions are taken in these cases.</li>
</ul>
<p class="calibre3">Once we <a id="_idIndexMarker1076" class="calibre6 pcalibre1 pcalibre"/>have implemented our listener, we need to register it using <code>castContext.sessionManager</code>:</p>
<pre class="source-code">
override fun onStart() {
    super.onStart()
    castContext.sessionManager.addSessionManagerListener(
        sessionManagerListener, CastSession::class.java)
}
override fun onStop() {
    super.onStop()
    castContext.sessionManager.removeSessionManagerListener
        (sessionManagerListener, CastSession::class.java)
}</pre> <p class="calibre3">Here, we are registering the listener when the <code>Activity</code> class is started and removing it when it is stopped. That way, we ensure that the listener is only retained when the <code>Activity</code> class is in a started state.</p>
<p class="calibre3">Now, let’s implement the <code>updateUIForCastSession</code> function:</p>
<pre class="source-code">
private fun updateUIForCastSession(isCasting: Boolean) {
    viewModel.setCastingState(isCasting)
}</pre> <p class="calibre3">Here, we are calling a new function that we will include next in the <code>ViewModel</code> component, called <code>setCastingState</code>. We are passing a Boolean as the argument, indicating whether the app is casting or not.</p>
<p class="calibre3">In our <code>PlaybackViewModel</code> component, we will introduce the followin<a id="_idTextAnchor194" class="calibre6 pcalibre1 pcalibre"/>g changes. We will start adding a new property, <code>isCasting</code>:</p>
<pre class="source-code">
<a id="_idTextAnchor195" class="pcalibre1 calibre17 pcalibre"/>private val _isCasting = MutableStateFlow&lt;Boolean&gt;(false)
val isCasting: MutableStateFlow&lt;Boolean&gt; = _isCasting</pre> <p class="calibre3">Then, we will <a id="_idIndexMarker1077" class="calibre6 pcalibre1 pcalibre"/>ch<a id="_idTextAnchor196" class="calibre6 pcalibre1 pcalibre"/>ange its value when the <code>setCastingState</code> function is called:</p>
<pre class="source-code">
fun setCastingState(isCasting: Boolean) {
    _isCasting.value = isCasting
}</pre> <p class="calibre3">Then, we will use it in our <code>PlaybackScreen</code> composable:</p>
<pre class="source-code">
@Composable
fun PlaybackScreen() {
    ...
    val isCasting = viewModel.isCasting.collectAsState()
    Box(
        ...
    ) {
        if (isCasting.value) {
            NowCastingView()
        } else {
            //VideoPlayerComposable and the rest of the UI...
        }
    }
}</pre> <p class="calibre3">In our already existing <code>PlaybackScreen</code> composable, we have added a new property, <code>isCasting</code>. This property is used to choose if the screen will show a <strong class="bold">Now Casting</strong> message or the complete playback UI.</p>
<p class="calibre3">Next, we will <a id="_idIndexMarker1078" class="calibre6 pcalibre1 pcalibre"/>build a new <code>NowCastingView</code> composable:</p>
<pre class="source-code">
@Composable
fun NowCastingView() {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Now Casting",
                style =
                    MaterialTheme.typography.headlineMedium
            )
        }
    }
}</pre> <p class="calibre3">This composable is just placing and showing a text with the <strong class="bold">Now Casting</strong> content, just to make the user aware that the media content is currently being cast to another device.</p>
<p class="calibre3">There’s just one thing that we must do: load the media in the remote device. We will modify the <code>onSessionStarted</code> callback in the <code>SessionManagerListener</code> interface, including a call to a new function to load the media:</p>
<pre class="source-code">
override fun onSessionStarted(session: CastSession,
sessionId: String) {
    castSession = session
    updateUIForCastSession(true)
    loadMedia(session)
}</pre> <p class="calibre3">Finally, we will <a id="_idIndexMarker1079" class="calibre6 pcalibre1 pcalibre"/>implement this function as follows:</p>
<pre class="source-code">
private fun loadMedia(castSession: CastSession) {
    val mediaInfo = MediaInfo.Builder(viewModel.mediaUrl)
        .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED)
        .setContentType("video/mp4")
        .build()
    val mediaLoadOptions = MediaLoadOptions
        .Builder()
        .setAutoplay(true)
        .setPlayPosition(0)
        .build()
    castSession.remoteMediaClient?.load(mediaInfo,
        mediaLoadOptions)
}</pre> <p class="calibre3">The function begins by constructing a <code>MediaInfo</code> object, which encapsulates all necessary details about the media file intended for playback. Utilizing the <code>MediaInfo.Builder</code> pattern, it starts with specifying the media’s URL, sourced from <code>viewModel.mediaUrl</code>. This URL is the location of the media file, which the Cast-enabled device will stream. The builder then sets the stream type to <code>MediaInfo.STREAM_TYPE_BUFFERED</code>, indicating that the content is pre-recorded and can be buffered before playback, which is ideal for video content that isn’t being streamed live. Furthermore, the content type is set to <code>"video/mp4"</code>, defining the <strong class="bold">MIME</strong> type (<strong class="bold">Multipurpose Internet Mail Extensions</strong>, used not only by email but also by <a id="_idIndexMarker1080" class="calibre6 pcalibre1 pcalibre"/>web browsers and apps to interpret and display content correctly.) of the file as an MP4 video.</p>
<p class="calibre3">Following the creation of the <code>MediaInfo</code> object, the function proceeds to configure additional playback options through a <code>MediaLoadOptions</code> object. The options set include <code>setAutoplay(true)</code>, which commands the Cast device to automatically start playing the media as soon as it’s loaded, and <code>setPlayPosition(0)</code>, ensuring that playback commences from the very beginning of the media file, for simplicity. One improvement <a id="_idIndexMarker1081" class="calibre6 pcalibre1 pcalibre"/>to this could be to obtain the current play position from the <code>ViewModel</code> component so that the video can continue at the same point in time if the playback has already started.</p>
<p class="calibre3">The final step in the <code>loadMedia</code> function involves invoking the <code>load</code> method on the <code>castSession</code> variable’s <code>remoteMediaClient</code> instance. This method call is where the media loading and playback command is actually sent to the Cast-enabled device. <code>remoteMediaClient</code> acts as the intermediary, transmitting commands from the app to the receiver. By passing the <code>MediaInfo</code> object and <code>MediaLoadOptions</code> to this method, the app specifies what to play and how it should be played, effectively initiating the streaming of video content to the Cast device.</p>
<p class="calibre3">Now, our app is ready to start casting to Google Cast devices. With that, we have finished this chapter and learned the vast possibilities of playback in Android and other connected devices.</p>
<h1 id="_idParaDest-192" class="calibre5"><a id="_idTextAnchor197" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we tackled the essentials of extended video playback on Android, focusing on making our app more engaging by allowing videos to play in other contexts. We covered two main areas: PiP mode and media casting, both aimed at keeping our users connected to their content, whether they’re multitasking on their device or looking to enjoy videos on a larger screen.</p>
<p class="calibre3">Starting with PiP, we walked through how to enable a video to continue playing in a small window while users navigate away from the app. This section detailed everything from modifying your app’s manifest to implementing PiP mode, ensuring users won’t have to pause their viewing experience when they need to use another app.</p>
<p class="calibre3">Next, we shifted focus to media casting, particularly with <code>MediaRouter</code> and the Cast SDK for devices such as Google Chromecast. Here, you learned how to let users send video from their mobile device to a TV. We discussed using <code>MediaRouteButton</code> for easy device discovery and connection, as well as how to create a custom UI for users who want more control over the casting process.</p>
<p class="calibre3">By the end of this chapter, you should have understood how to implement PiP for in-app multitasking and set up casting to external devices. These skills are key to creating Android apps that offer flexible and user-friendly video playback experiences. Whether it’s keeping a video running in a corner of the screen or sharing a favorite movie on a big TV, your app can now cater to various user needs, enhancing overall engagement with your video content.</p>
<p class="calibre3">And with that, we’ve reached the end of our journey, where we built key features for three types of apps: a messaging app, a social platform, and a video app. Each project aimed to deepen your Android and Kotlin development skills and inspire you to think about how you can apply these ideas to your own work.</p>
<p class="calibre3">Thank you for reading this book. I hope it has not only broadened your knowledge but also sparked new ideas for your projects. With the tools and techniques you’ve learned, you’re well prepared to advance your career and start building your own innovative apps. Here’s to your success in the field of mobile development – go out there and make great things!</p>
</div>
</body></html>