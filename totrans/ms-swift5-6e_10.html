<html><head></head><body>
  <div id="_idContainer070">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-199" class="chapterTitle">Protocol-Oriented Design</h1>
    <p class="normal">When Apple announced Swift 2 at the <strong class="keyword">World Wide Developers Conference</strong> (<strong class="keyword">WWDC</strong>) in 2016, they also <a id="_idIndexMarker457"/>declared that Swift was the world's<a id="_idIndexMarker458"/> first <strong class="keyword">protocol-oriented programming</strong> (<strong class="keyword">POP</strong>) language. From its name, we might assume that POP is all about protocol; however, that would be a wrong assumption. POP is about so much more than just protocol; it is actually a new way of not only writing applications but also thinking about programming.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bullet">What is the difference between OOP and POP design?</li>
      <li class="bullet">What is protocol-oriented design?</li>
      <li class="bullet">What is protocol composition?</li>
      <li class="bullet">What is protocol inheritance?</li>
    </ul>
    <p class="normal">Days after Dave Abrahams did his presentation on POP at WWDC 2016, there were numerous tutorials on the internet about POP that took a very object-oriented approach to it. With this statement, I mean the approach taken by these tutorials focused on replacing the superclass with protocols and protocol extensions. While protocols and protocol extensions are arguably two of the more important concepts of POP, these tutorials seem to be missing some very important concepts.</p>
    <p class="normal">In this chapter, we will be comparing a protocol-oriented design with an object-oriented design to highlight some of the conceptual differences between the two. We will look at how we can use protocols and protocol extensions to replace superclasses, and how a protocol-oriented design will give us a cleaner and easier-to-maintain code base. To do this, we will look at how to define animal types for a video game in both an object-oriented and a protocol-oriented way. Let's start off by defining the requirements for our animals.</p>
    <h1 id="_idParaDest-200" class="title">Requirements</h1>
    <p class="normal">When we develop applications, we usually have a set of requirements that we need to develop against. With that in mind, let's define the requirements for the animal types that we will be creating in this chapter:</p>
    <ul>
      <li class="bullet">We will have three categories of animals: land, sea, and air.</li>
      <li class="bullet">Animals may be members of multiple categories. For example, an alligator can be a member of both the land and sea categories.</li>
      <li class="bullet">Animals may attack and/or move when they are on a tile that matches the categories they are in.</li>
      <li class="bullet">Animals will start off with a certain number of hit points, and if those hit points reach 0 or less, then they will be considered dead.</li>
    </ul>
    <p class="normal">For our example here, we will define two animals, <code class="Code-In-Text--PACKT-">Lion</code> and <code class="Code-In-Text--PACKT-">Alligator</code>, but we know that the number of animal types will grow as we develop the game.</p>
    <p class="normal">We will start off by looking at how we would design the animal types using an object-oriented approach.</p>
    <h1 id="_idParaDest-201" class="title">Object-oriented design</h1>
    <p class="normal">Before we start<a id="_idIndexMarker459"/> writing code, let's create a very basic diagram that shows how we would design the <strong class="screenText">Animal</strong> class hierarchy. In this diagram, we will simply show the classes without much detail. This diagram will help us picture the class hierarchy in our minds. <em class="italic">Figure 10.1</em> shows the class hierarchy for the object-oriented design:</p>
    <figure class="mediaobject"><img src="../Images/B16683_10_01.png" alt="A picture containing screenshot, drawing  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.1: Animal class hierarchy</p>
    <p class="normal"><em class="italic">Figure 10.1</em> shows that we have one superclass named <strong class="screenText">Animal</strong>, and two subclasses named <code class="Code-In-Text--PACKT-">Alligator</code> and <code class="Code-In-Text--PACKT-">Lion</code>. We may think with the three categories (land, air, and sea) that we would want to create a larger class hierarchy where the middle layer would contain the classes for the land, air, and sea animals. This would allow us to separate the code for each animal category; however, that is not possible with our requirements. The reason this is not possible is that any of the animal types can be members of multiple categories, and with a class hierarchy, each class can have one and only one superclass. This means that the <code class="Code-In-Text--PACKT-">Animal</code> superclass will need to contain the code required for each of the three categories.</p>
    <p class="normal">Let's begin by looking at the code for the <code class="Code-In-Text--PACKT-">Animal</code> superclass.</p>
    <p class="normal">We will start the <code class="Code-In-Text--PACKT-">Animal</code> superclass by defining 10 properties. These properties will define what type of animal it is and what type of attacks/movements it can do. We also define a property that will keep track of the remaining hit points for the animal.</p>
    <p class="normal">We define these <a id="_idIndexMarker460"/>properties as <code class="Code-In-Text--PACKT-">internal</code> variables. We will need to set these properties in the subclasses; however, we do not want external entities, outside of our module that defines the animals, to change them. The preference is for these to be constants, but with an object-oriented approach; a subclass cannot set/change the value of a constant defined in a superclass. For this to work, the subclass will need to be defined in the same module as the <code class="Code-In-Text--PACKT-">Animal</code> superclass:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> landAnimal = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> landAttack = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> landMovement = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> seaAnimal = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> seaAttack = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> seaMovement = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> airAnimal = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> airAttack = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> airMovement = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> hitPoints = <span class="hljs-number">0</span>
}
</code></pre>
    <p class="normal">Next, we define an initializer that will set the properties. We will set all the properties to <code class="Code-In-Text--PACKT-">false</code> by default, and the hit points to <code class="Code-In-Text--PACKT-">zero</code>. It will be up to the subclasses to set the appropriate properties that apply:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">init</span>() { 
    landAnimal = <span class="hljs-literal">false</span>
    landAttack = <span class="hljs-literal">false</span>
    landMovement = <span class="hljs-literal">false</span>
    airAnimal = <span class="hljs-literal">false</span>
    airAttack = <span class="hljs-literal">false</span>
    airMovement = <span class="hljs-literal">false</span>
    seaAnimal = <span class="hljs-literal">false</span>
    seaAttack = <span class="hljs-literal">false</span>
    seaMovement = <span class="hljs-literal">false</span>
    hitPoints = <span class="hljs-number">0</span>
}
</code></pre>
    <p class="normal">Since our properties<a id="_idIndexMarker461"/> are internal, we need to create some getter methods so that we can retrieve their values. We will also create a couple of additional methods that check if the animal is alive. We will need another method that deducts hit points when the animal takes a hit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isLandAnimal</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> landAnimal
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canLandAttack</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> landAttack
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canLandMove</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> landMovement
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isSeaAnimal</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> seaAnimal
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canSeaAttack</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> seaAttack
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canSeaMove</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> seaMovement
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isAirAnimal</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> airAnimal
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canAirAttack</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> airAttack
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">canAirMove</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> { 
    <span class="hljs-keyword">return</span> airMovement
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> {} 
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> {}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaAttack</span><span class="hljs-params">()</span> {} 
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaMovement</span><span class="hljs-params">()</span> {}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doAirAttack</span><span class="hljs-params">()</span> {} 
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doAirMovement</span><span class="hljs-params">()</span> {}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">takeHit</span><span class="hljs-params">(amount: Int)</span> { 
    hitPoints -= amount
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">hitPointsRemaining</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span> { 
    <span class="hljs-keyword">return</span> hitPoints
}
<span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isAlive</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> {
    <span class="hljs-keyword">return</span> hitPoints &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>
}
</code></pre>
    <p class="normal">Now that we<a id="_idIndexMarker462"/> have our <code class="Code-In-Text--PACKT-">Animal</code> superclass, we can create the <code class="Code-In-Text--PACKT-">Alligator</code> and <code class="Code-In-Text--PACKT-">Lion</code> classes, which will be subclasses of the <code class="Code-In-Text--PACKT-">Animal</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Lion</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>() landAnimal = <span class="hljs-literal">true</span>
        landAttack = <span class="hljs-literal">true</span>
        landMovement = <span class="hljs-literal">true</span>
        hitPoints = <span class="hljs-number">20</span>
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Attack"</span>)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Move"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Alligator</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
        landAnimal = <span class="hljs-literal">true</span>
        landAttack = <span class="hljs-literal">true</span>
        landMovement = <span class="hljs-literal">true</span>
        seaAnimal = <span class="hljs-literal">true</span>
        seaAttack = <span class="hljs-literal">true</span>
        seaMovement = <span class="hljs-literal">true</span>
        hitPoints = <span class="hljs-number">35</span>
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Land Attack"</span>)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Land Move"</span>)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Sea Attack"</span>)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Sea Move"</span>)
    }
}
</code></pre>
    <p class="normal">As we can see, these<a id="_idIndexMarker463"/> classes set the functionality needed for each animal. The <code class="Code-In-Text--PACKT-">Lion</code> class contains the functionality for a land animal and the <code class="Code-In-Text--PACKT-">Alligator</code> class contains the functionality for both land and sea animals.</p>
    <p class="normal">Another disadvantage of this object-oriented design is that we do not have a single point that defines what type of animal (air, land, or sea) this is. It is very easy to set the wrong flag or add the wrong function when we cut and paste or type in the code. This may lead us to have an animal like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">landAnimal</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
        landAnimal = <span class="hljs-literal">true</span>
        airAttack = <span class="hljs-literal">true</span>
        landMovement = <span class="hljs-literal">true</span>
        hitPoints = <span class="hljs-number">20</span>
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Attack"</span>)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Move"</span>)
    }
}
</code></pre>
    <p class="normal">In the previous code, we set the <code class="Code-In-Text--PACKT-">landAnimal</code> property to true; however, we accidentally set <code class="Code-In-Text--PACKT-">airAttack</code> to true as well. This will give us an animal that can move on land but cannot attack, since the <code class="Code-In-Text--PACKT-">landAttack</code> property is not set. Hopefully, we would catch these types of errors in testing; however, as we will see later in this chapter, a protocol-oriented approach would help prevent coding errors like this.</p>
    <p class="normal">Since both classes have the same <code class="Code-In-Text--PACKT-">Animal</code> superclass, we can use polymorphism to access them through the<a id="_idIndexMarker464"/> interface provided by the <code class="Code-In-Text--PACKT-">Animal</code> superclass:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> animals = [<span class="hljs-type">Animal</span>]()
animals.append(<span class="hljs-type">Alligator</span>())
animals.append(<span class="hljs-type">Alligator</span>())
animals.append(<span class="hljs-type">Lion</span>())
<span class="hljs-keyword">for</span> (index, animal) <span class="hljs-keyword">in</span> animals.enumerated() { 
    <span class="hljs-keyword">if</span> animal.isAirAnimal() {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Air"</span>)
    }
    <span class="hljs-keyword">if</span> animal.isLandAnimal() { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Land"</span>)
    }
    <span class="hljs-keyword">if</span> animal.isSeaAnimal() { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Sea"</span>)
    }
}
</code></pre>
    <p class="normal">The way we designed the animal types here would work; however, there are several drawbacks to this design. The first drawback is the large monolithic <code class="Code-In-Text--PACKT-">Animal</code> superclass. Those who are familiar with designing characters for video games probably realize how much functionality is missing from this superclass and its subclasses. This is on purpose so that we can focus on the design and not the functionality. For those who are not familiar with designing characters for video games, trust me when I say that this class may get very large.</p>
    <p class="normal">Another drawback is not being able to define constants in the superclass that the subclasses can set. We could define various initializers for the superclass that would correctly set the constants for the different animal categories; however, these initializers will become pretty complex and hard to maintain as we add more animals. The builder pattern could help us with the initialization, but as we are about to see, a protocol-oriented design would be even better.</p>
    <p class="normal">One final drawback that I am going to point out is the use of flags (the <code class="Code-In-Text--PACKT-">landAnimal</code>, <code class="Code-In-Text--PACKT-">seaAnimal</code>, and <code class="Code-In-Text--PACKT-">airAnimal</code> properties) to define the type of animal, and the type of attack and movements an animal can perform. If we do not correctly set these flags, then the animal will <a id="_idIndexMarker465"/>not behave correctly. As an example, if we set the <code class="Code-In-Text--PACKT-">seaAnimal</code> flag rather than the <code class="Code-In-Text--PACKT-">landAnimal</code> flag in the <code class="Code-In-Text--PACKT-">Lion</code> class, then the lion will not be able to move or attack on land. Trust me, it is very easy, even for the most experienced developers, to set flags wrongly.</p>
    <p class="normal">Now let's look at how we would define this same functionality in a protocol-oriented way.</p>
    <h1 id="_idParaDest-202" class="title">Protocol-oriented design</h1>
    <p class="normal">Just like our <a id="_idIndexMarker466"/>object-oriented design, we will start off with a diagram that shows the types needed and the relationships between them. <em class="italic">Figure 10.2</em> shows our protocol-oriented design:</p>
    <figure class="mediaobject"><img src="../Images/B16683_10_02.png" alt="A screenshot of a cell phone  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 10.2: Protocol-oriented design</p>
    <p class="normal">As we can see, the POP design is quite different from the OOP design. In this design, we use three techniques <a id="_idIndexMarker467"/>that make POP significantly different from OOP. These techniques are protocol inheritance, protocol composition, and protocol extensions. We looked at protocol extensions in the previous chapter, but we have not covered protocol inheritance or composition yet. It is important to understand these concepts, so before we go into the design, let's look at what protocol inheritance and protocol composition are.</p>
    <h2 id="_idParaDest-203" class="title">Protocol inheritance</h2>
    <p class="normal">Protocol inheritance<a id="_idIndexMarker468"/> is where one protocol can <a id="_idIndexMarker469"/>inherit the requirements from one or more additional protocols. This is similar to class inheritance in OOP, but instead of inheriting functionality, we are inheriting requirements. We can also inherit requirements from multiple protocols, whereas a class in Swift can have only one superclass. Let's start off by defining four protocols, named <code class="Code-In-Text--PACKT-">Name</code>, <code class="Code-In-Text--PACKT-">Age</code>, <code class="Code-In-Text--PACKT-">Fur</code>, and <code class="Code-In-Text--PACKT-">Hair</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Name</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> firstName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> lastName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Age</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Fur</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> furColor: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Hair</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> hairColor: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">Each of the four protocols has different requirements.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">There is one thing that I would like to point out. If you find yourself creating protocols with single requirements (as shown in this example), you probably want to reconsider your overall design. Protocols should not be this granular because we end up with too many protocols and they become hard to manage. We are using smaller protocols here as examples.</p>
    </div>
    <p class="normal">Now let's look at how we can use these protocols and protocol inheritance to create additional<a id="_idIndexMarker470"/> protocols. We will define two more<a id="_idIndexMarker471"/> protocols, named <code class="Code-In-Text--PACKT-">Person</code> and <code class="Code-In-Text--PACKT-">Dog</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Person</span><span class="hljs-class">: </span><span class="hljs-title">Name</span><span class="hljs-class">, </span><span class="hljs-title">Age</span><span class="hljs-class">, </span><span class="hljs-title">Hair</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Dog</span><span class="hljs-class">: </span><span class="hljs-title">Name</span><span class="hljs-class">, </span><span class="hljs-title">Age</span><span class="hljs-class">, </span><span class="hljs-title">Fur</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> breed: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">In this example, any type that conforms to the <code class="Code-In-Text--PACKT-">Person</code> protocol will need to fulfill the requirements of the <code class="Code-In-Text--PACKT-">Name</code>, <code class="Code-In-Text--PACKT-">Age</code>, and <code class="Code-In-Text--PACKT-">Hair</code> protocols, as well as the requirements defined within the <code class="Code-In-Text--PACKT-">Person</code> protocol itself. Any type that conforms to the <code class="Code-In-Text--PACKT-">Dog</code> protocol will need to fulfill the requirements of the <code class="Code-In-Text--PACKT-">Name</code>, <code class="Code-In-Text--PACKT-">Age</code>, and <code class="Code-In-Text--PACKT-">Fur</code> protocols as well as the requirements defined within the <code class="Code-In-Text--PACKT-">Dog</code> protocol itself. This is the basis of protocol inheritance, where we can have one protocol inherit the requirements of one or more protocols.</p>
    <p class="normal">Protocol inheritance is extremely powerful because we can define several smaller protocols and mix/match them to create larger protocols. You will want to be careful not to create <a id="_idIndexMarker472"/>protocols that are too granular because<a id="_idIndexMarker473"/> they will become hard to maintain and manage.</p>
    <h2 id="_idParaDest-204" class="title">Protocol composition</h2>
    <p class="normal">Protocol<a id="_idIndexMarker474"/> composition allows types to conform<a id="_idIndexMarker475"/> to more than one protocol. This is one of the many advantages that protocol-oriented design has over object-oriented design. With object-oriented design, a class can have only one superclass. This can lead to very large, monolithic superclasses, as we saw in the <em class="italic">Object-oriented design</em> section of this chapter. With protocol-oriented design, we are encouraged to create multiple smaller protocols with very specific requirements. Let's look at how protocol composition works.</p>
    <p class="normal">Let's add another protocol, named <code class="Code-In-Text--PACKT-">Occupation</code>, to our example from the <em class="italic">Protocol inheritance</em> section:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Occupation</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> occupationName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">var</span> yearlySalary:<span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> experienceYears: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">Next let's create a new type named <code class="Code-In-Text--PACKT-">Programmer</code> that will conform to both the <code class="Code-In-Text--PACKT-">Person</code> and <code class="Code-In-Text--PACKT-">Occupation</code> protocols:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Programmer</span><span class="hljs-class">: </span><span class="hljs-title">Person</span><span class="hljs-class">, </span><span class="hljs-title">Occupation</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> firstName: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> lastName: <span class="hljs-type">String</span> 
    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> hairColor: <span class="hljs-type">String</span> 
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> occupationName: <span class="hljs-type">String</span> 
    <span class="hljs-keyword">var</span> yearlySalary: <span class="hljs-type">Double</span> 
    <span class="hljs-keyword">var</span> experienceYears: <span class="hljs-type">Double</span>
}
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">Programmer</code> structure conforms to all the requirements from both the <code class="Code-In-Text--PACKT-">Person</code> and <code class="Code-In-Text--PACKT-">Occupation</code> protocols. Keep in mind that the <code class="Code-In-Text--PACKT-">Person</code> protocol is a composite of the requirements from the <code class="Code-In-Text--PACKT-">Name</code>, <code class="Code-In-Text--PACKT-">Age</code>, <code class="Code-In-Text--PACKT-">Hair</code>, and <code class="Code-In-Text--PACKT-">Person</code> protocols; therefore, the <code class="Code-In-Text--PACKT-">Programmer</code> type will need to conform to all those protocols plus the <code class="Code-In-Text--PACKT-">Occupation</code> protocol.</p>
    <p class="normal">Once again, I want to warn you not to make your protocols too granular. Protocol inheritance and composition are really powerful features but can also cause problems if used wrongly.</p>
    <p class="normal">Protocol composition and inheritance may not seem that powerful on their own; however, when we<a id="_idIndexMarker476"/> combine them with protocol <a id="_idIndexMarker477"/>extensions, we have a very powerful programming paradigm. Let's look at how powerful this paradigm is.</p>
    <h2 id="_idParaDest-205" class="title">Protocol-oriented design â€“ putting it all together</h2>
    <p class="normal">We will begin<a id="_idIndexMarker478"/> by rewriting the <code class="Code-In-Text--PACKT-">Animal</code> superclass as a protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> hitPoints: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Animal</code> protocol, the only item that we are defining is the <code class="Code-In-Text--PACKT-">hitPoints</code> property. If we were putting in all the requirements for an animal in a video game, this protocol would contain all the requirements that would be common to every animal. To be consistent with our object-oriented design, we only need to add the <code class="Code-In-Text--PACKT-">hitPoints</code> property to this protocol.</p>
    <p class="normal">Next, we need to add an <code class="Code-In-Text--PACKT-">Animal</code> protocol extension, which will contain the functionality that is common for all types that conform to the protocol. Our <code class="Code-In-Text--PACKT-">Animal</code> protocol extension would contain the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">extension</span><span class="hljs-class"> </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">takeHit</span><span class="hljs-params">(amount: Int)</span> { 
        hitPoints -= amount
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">hitPointsRemaining</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Int</span> { 
        <span class="hljs-keyword">return</span> hitPoints
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">isAlive</span><span class="hljs-params">()</span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> hitPoints &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Animal</code> protocol extension contains the same <code class="Code-In-Text--PACKT-">takeHit()</code>, <code class="Code-In-Text--PACKT-">hitPointsRemaining()</code>, and <code class="Code-In-Text--PACKT-">isAlive()</code> methods that we saw in the <code class="Code-In-Text--PACKT-">Animal</code> superclass from the object-oriented example. Any type that conforms to the <code class="Code-In-Text--PACKT-">Animal</code> protocol will automatically inherit these three methods.</p>
    <p class="normal">Now let's define our <code class="Code-In-Text--PACKT-">LandAnimal</code>, <code class="Code-In-Text--PACKT-">SeaAnimal</code>, and <code class="Code-In-Text--PACKT-">AirAnimal</code> protocols. These protocols will define the <a id="_idIndexMarker479"/>requirements for the <code class="Code-In-Text--PACKT-">land</code>, <code class="Code-In-Text--PACKT-">sea</code>, and <code class="Code-In-Text--PACKT-">air</code> animals respectively:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">LandAnimal</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> landAttack: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> landMovement: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span>
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">SeaAnimal</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> seaAttack: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> seaMovement: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaAttack</span><span class="hljs-params">()</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaMovement</span><span class="hljs-params">()</span>
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">AirAnimal</span><span class="hljs-class">: </span><span class="hljs-title">Animal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> airAttack: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> airMovement: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doAirAttack</span><span class="hljs-params">()</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doAirMovement</span><span class="hljs-params">()</span>
}
</code></pre>
    <p class="normal">Unlike the <code class="Code-In-Text--PACKT-">Animal</code> superclass in the object-oriented design, these three protocols only contain the functionality needed for their particular type of animal. Each of these protocols only contains four lines of code, while the <code class="Code-In-Text--PACKT-">Animal</code> superclass from the object-oriented example contains significantly more. This makes our protocol design much easier to read and manage. The protocol design is also much safer because the functionalities for the various animal types are isolated in their own protocols rather than being embedded in a giant superclass. We are also able to avoid the use of flags to define the animal category and, instead, define the category of the animal by the protocols it conforms to.</p>
    <p class="normal">In a full design, we would probably need to add some protocol extensions for each of the animal types, but once again, to be consistent with our object-oriented design, we do not need them for our example here.</p>
    <p class="normal">Now, let's look at how <a id="_idIndexMarker480"/>we would create our <code class="Code-In-Text--PACKT-">Lion</code> and <code class="Code-In-Text--PACKT-">Alligator</code> types using protocol-oriented design:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Lion</span><span class="hljs-class">: </span><span class="hljs-title">LandAnimal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> hitPoints = <span class="hljs-number">20</span> 
    <span class="hljs-keyword">let</span> landAttack = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> landMovement = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Attack"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lion Move"</span>)
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Alligator</span><span class="hljs-class">: </span><span class="hljs-title">LandAnimal</span><span class="hljs-class">, </span><span class="hljs-title">SeaAnimal</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> hitPoints = <span class="hljs-number">35</span>
    <span class="hljs-keyword">let</span> landAttack = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> landMovement = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> seaAttack = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> seaMovement = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Land Attack"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doLandMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Land Move"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaAttack</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Sea Attack"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">doSeaMovement</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Alligator Sea Move"</span>)
    }
}
</code></pre>
    <p class="normal">Notice that we specify that the <code class="Code-In-Text--PACKT-">Lion</code> type conforms to the <code class="Code-In-Text--PACKT-">LandAnimal</code> protocol, while the <code class="Code-In-Text--PACKT-">Alligator</code> type conforms to both the <code class="Code-In-Text--PACKT-">LandAnimal</code> and <code class="Code-In-Text--PACKT-">SeaAnimal</code> protocols. As we saw previously, having a single type that conforms to multiple protocols is called <strong class="keyword">protocol composition</strong> and is<a id="_idIndexMarker481"/> what allows us to use smaller protocols, rather than one giant monolithic superclass, as we did in the object-oriented example.</p>
    <p class="normal">Both the <code class="Code-In-Text--PACKT-">Lion</code> and <code class="Code-In-Text--PACKT-">Alligator</code> types originate from the <code class="Code-In-Text--PACKT-">Animal</code> protocol; therefore, they will inherit the functionality added with the <code class="Code-In-Text--PACKT-">Animal</code> protocol extension. If our animal type protocols also had extensions, then they would also inherit the function added by those extensions. With protocol inheritance, composition, and extensions, our concrete types contain only the functionality needed by the particular animal types that they conform to, unlike in the object-oriented design, where each animal would contain all of the functionality from the huge, single superclass.</p>
    <p class="normal">Since the <code class="Code-In-Text--PACKT-">Lion</code> and <code class="Code-In-Text--PACKT-">Alligator</code> types originate from the <code class="Code-In-Text--PACKT-">Animal</code> protocol, we can still use polymorphism as<a id="_idIndexMarker482"/> we did in the object-oriented example. Let's look at how this works:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> animals = [<span class="hljs-type">Animal</span>]()
animals.append(<span class="hljs-type">Alligator</span>())
animals.append(<span class="hljs-type">Alligator</span>())
animals.append(<span class="hljs-type">Lion</span>())
<span class="hljs-keyword">for</span> (index, animal) <span class="hljs-keyword">in</span> animals.enumerated() { 
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = animal <span class="hljs-keyword">as</span>? <span class="hljs-type">AirAnimal</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Air"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = animal <span class="hljs-keyword">as</span>? <span class="hljs-type">LandAnimal</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Land"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = animal <span class="hljs-keyword">as</span>? <span class="hljs-type">SeaAnimal</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Animal at \(index) is Sea"</span>)
    }
}
</code></pre>
    <p class="normal">In this example, we create an array that will contain <code class="Code-In-Text--PACKT-">Animal</code> types named <code class="Code-In-Text--PACKT-">animals</code>. We then create two instances of the <code class="Code-In-Text--PACKT-">Alligator</code> type and one instance of the <code class="Code-In-Text--PACKT-">Lion</code> type that are added to the <code class="Code-In-Text--PACKT-">animals</code> array. Finally, we use a <code class="Code-In-Text--PACKT-">for-in</code> loop to loop through the array and print out the <a id="_idIndexMarker483"/>animal type based on the protocol that the instance conforms to.</p>
    <h2 id="_idParaDest-206" class="title">Using the where statement with protocols</h2>
    <p class="normal">With<a id="_idIndexMarker484"/> protocols, we are able to use the <code class="Code-In-Text--PACKT-">where</code> statement<a id="_idIndexMarker485"/> to filter the instances of our types. For example, if we only want to get the instances that conform to the <code class="Code-In-Text--PACKT-">SeaAnimal</code> protocol, we can create a <code class="Code-In-Text--PACKT-">for</code> loop as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> (index, animal) <span class="hljs-keyword">in</span> animals.enumerated() <span class="hljs-keyword">where</span> animal <span class="hljs-keyword">is</span> <span class="hljs-type">SeaAnimal</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Only Sea Animal: \(index)"</span>)
}
</code></pre>
    <p class="normal">This will retrieve only the animals that conform to the <code class="Code-In-Text--PACKT-">SeaAnimal</code> protocol. This is a lot safer than using flags as we did in the object-oriented design example.</p>
    <h1 id="_idParaDest-207" class="title">Structures versus classes</h1>
    <p class="normal">You may have <a id="_idIndexMarker486"/>noticed that in the object-oriented design we used<a id="_idIndexMarker487"/> classes, while in the protocol-oriented design example we used structures. Classes, which are reference types, are one of the pillars of object-oriented programming and every major object-oriented programming language uses them. For Swift, Apple has said that we should prefer value types (structures) to reference types (classes). While this may seem odd for anyone who has extensive experience with object-oriented programming, there are several good reasons for this recommendation.</p>
    <p class="normal">The biggest reason, in my opinion, for using structures (value types) over classes is the performance gain we get. Value types do not incur the additional overhead for reference counting that reference types incur. Value types are also stored on the stack, which provides better performance as compared to reference types, which are stored on the heap. It is also worth noting that copying values is relatively cheap in Swift.</p>
    <p class="normal">Keep in mind that, as our value types get large, the performance cost of copying can negate the other performance gains of value types. In the Swift standard library, Apple has implemented copy-on-write behavior to reduce the overhead of copying large value types.</p>
    <p class="normal">With copy-on-write behavior, we do not create a new copy of our value type when we assign it to a new variable. The copy is postponed until one of the instances changes the value. This means that, if we have an array of 1 million numbers, when we pass this array to another array, we will not make a copy of the 1 million numbers until one of the arrays changes. This can greatly reduce the overhead incurred from copying instances of our value types.</p>
    <p class="normal">Value types are also a lot safer than reference types, because we do not have multiple references pointing to the same instance, as we do with reference types. This really becomes apparent when we are dealing with a multithreaded environment. Value types are also safer because we do not have memory leaks caused by common programming errors, such as the strong reference cycles that we will discuss in <em class="chapterRef">Chapter 18</em>, <em class="italic">Memory Management</em>.</p>
    <p class="normal">Don't worry if you<a id="_idIndexMarker488"/> do not understand some of the items discussed in this <a id="_idIndexMarker489"/>section. The thing to understand is that value types, like structures, are safer, and for the most part provide better performance in Swift, as compared to reference types, such as classes.</p>
    <h1 id="_idParaDest-208" class="title">Summary</h1>
    <p class="normal">As we have read through this chapter and looked at some of the advantages that protocol-oriented design has over object-oriented design, we may think that protocol-oriented design is clearly superior to object-oriented design. However, this assumption would not be entirely correct.</p>
    <p class="normal">Object-oriented design has been around since the 1970s and is a tried and true programming paradigm. Protocol-oriented design is the new kid on the block and was designed to correct some of the issues with object-oriented design.</p>
    <p class="normal">Object-oriented and protocol-oriented design have similar philosophies, such as creating custom types that model real-world objects, and polymorphism to use a single interface to interact with multiple types. The difference is how these philosophies are implemented.</p>
    <p class="normal">To me, the code base in a project that uses protocol-oriented design is much safer, easier to read, and easier to maintain as compared to a project that uses object-oriented design. This does not mean that I am going to stop using object-oriented design altogether. I can still see a need for a class hierarchy in certain instances.</p>
    <p class="normal">Remember that when we are designing our application, we should always use the right tool for the job. We would not want to use a chainsaw to cut a piece of 2 x 4 lumber, but we also would not want to use a skill saw to cut down a tree. Therefore, the winner is the programmer who has the choice of using different programming paradigms rather than being limited to only one. In the next chapter, we will look at generics.</p>
  </div>
</body></html>