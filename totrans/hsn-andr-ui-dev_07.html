<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Overview Screens</h1>
                
            
            
                
<p class="mce-root">Overview screens, or dashboard screens, are layouts that allow the user to get a quick look at their data within an application. As such, they are also screens that the user will return to again and again. Most often, they are positioned as the first screen the user will normally see when they open the application, like the Inbox in an email application, or the list of files in your Google Drive. In apps, navigation is usually goal-oriented; the user starts with an overview, and then navigates to perform a specific action. Once they are finished with their action (for example, writing and sending an email), they are redirected to the overview screen.</p>
<p class="mce-root">Overview screens can be complex systems to build as they should be reactive, and they will often depend on large amounts of application data. As it's the screen your users will see the most often in your app, an overview screen needs special attention in the design process. It's important to present the user with the most important data, without overwhelming them. Placing too much information on the screen makes it harder for your user to find the information that they want.</p>
<p class="mce-root">In this chapter, we'll look at how to design Overview screens. We'll take a detailed look at the following:</p>
<ul>
<li class="mce-root">The <kbd>RecyclerView</kbd> class, which is the most commonly used component in overview lists</li>
<li class="mce-root">How data-binding can make <kbd>RecyclerView</kbd> much easier to use</li>
<li>Techniques that can be used when designing an Overview screen</li>
<li class="mce-root">How to get data from a Room database into a <kbd>RecyclerView</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing an Overview screen</h1>
                
            
            
                
<p>Overview screens and dashboard screens are not only the first thing your users will typically see, but they're also the most common point of contact with your user. They need to be functional, beautiful, and also very fast. An application that takes too long to load its first screen will only frustrate its users. If your application is frustrating to users, they will avoid using it. As such, it's very important to consider what information your user will need, and what are the most important actions they will take from the overview screen.</p>
<p class="mce-root">The <em>Material Design guideline</em>s have excellent recommendations to help you decide on these aspects of your application, which in turn will help you produce better applications. Remember that while it's fun (and important) to get creative with your designs, it's also very important to <strong>stick to the rules</strong>. Common patterns in design help your users understand what you're asking them to do, and how to use your application. This understanding between you and your users is why <em>Material Design is a Design Language</em>, and not just a look and feel. It's a language that you can speak to your users, and they can easily understand. For example, when you have a floating action button in the bottom-right of a screen, the user knows that it will generally start or create something new, such as create an empty document, or take a new photograph (depending on the application).</p>
<p class="mce-root">Overview screens need to allow a user to reach every part of your application, but unlike a website or desktop application, this might have some intermediary steps (although as few as possible). This means that while you might present them with data, it should never be for viewing only. Every element placed on an overview screen must earn its right to be there. They should all fulfill two roles: give the user information, and allow them to take some action with that information (even if only to find out more). One role is fulfilled by simply being on the screen, the other is fulfilled by allowing the user to tap on the widget. You can, of course, add more: swipe to dismiss, scroll, and so on. In these cases, the interactions must be consistent with interactions in Material Design (that is, swipe to dismiss should always be on list items, not on a button).</p>
<p class="mce-root">An example flow through an application should look like the following diagram. You'll note that all the processes eventually return the user to the overview screen. This is what is meant to be deep navigation; it's a goal-oriented structure designed to guide the user toward completing what they are trying to accomplish:</p>
<div><img height="506" width="293" src="img/39b85b0b-39f1-4cc1-a17b-30a77658797e.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Elements of an Overview screen</h1>
                
            
            
                
<p>Overview screens have certain common elements that let the user know what it is they're looking at, and how they're expected to use the screen. It's helpful to know how people look at a screen when they see it for the first time. Studies by groups such as Neilson show that most western people follow a sort of <strong>F</strong> shaped pattern when looking at the screen for the first time. Starting in the top-left corner, their eyes track right and downwards, as shown in this diagram:</p>
<div><img height="208" width="112" src="img/5df07f81-5ceb-4775-ae38-caa26d4d961a.jpg"/></div>
<p class="mce-root">This means that when designing an overview screen, the most important information should be at the top of the screen, with the second most important information to its right, and as you work down the screen, the information becomes less important. The preceding diagram uses a graph at the top of its screen; this is also an important element: favor using graphics and indicators over raw numbers where it's applicable. A user can get a much quicker overview from a graph than they can from a table of numbers, even though the latter is more powerful. An overview screen should be something the user can use in a few seconds; it's not a place where they will want to spend time understanding the details. As such, an overview screen should not need to be scrolled in order to be useful. It's not as important to avoid scrolling an overview screen as it is on a form/input screen, but any scrolling should only be applicable to access detailed information.</p>
<p class="mce-root">It's common for an overview screen to start with a graph, or some summary of the user's data, and then have a list of the most applicable details. Using the travel claim's app as an example, the overview should have the overview fragment you developed at the top of the screen, and this should be followed by a list of their travel claims with the most recent at the top:</p>
<div><img height="294" width="308" src="img/d645629b-96d5-4cb3-8be7-7f9a6be57bc5.png"/></div>
<p class="mce-root">The overview fragment allows them to see how much they have spent, while the list shows them instantly what they've been spending the money on. Another possibility would be a graph showing them the breakdown of how much they have spent in each category. However, this will typically be less useful on a day-to-day basis and more useful at the end of a business trip in the form of a report.</p>
<p class="mce-root">One of the most common elements on an overview screen is a list of some sort. Even when the overview doesn't include graphs and info-graphics, a list of the user's most current / most useful items is a very common structure, and Android provides the <kbd>RecylcerView</kbd> as the perfect system to build these sorts of lists. Unlike <kbd>ViewPager</kbd> or <kbd>ListView</kbd>, a <kbd>RecyclerView</kbd> is a generic system for displaying large amounts of scrolling data. Its child widgets don't need to be laid out in a strict way; they can be lists, they can be a grid, staggered unevenly, or anything you care to think of with a custom layout manager. However, they all share a common collection of structures--every <kbd>RecyclerView</kbd> needs the following components:</p>
<ul>
<li>An <kbd>Adapter</kbd> to provide the child <kbd>View</kbd> objects, and bind them to the data model</li>
<li><kbd>ViewHolder</kbd> classes that wrap the child <kbd>View</kbd> objects</li>
<li>A <kbd>LayoutManager</kbd> to determine how to place the child <kbd>View</kbd> objects relative to each other</li>
</ul>
<p>Let's explore how to build and use the components of a <kbd>RecyclerView</kbd> in some more detail, and how to build the overview screen for the travel claim app.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating layouts for ViewHolders</h1>
                
            
            
                
<p>A <kbd>RecyclerView</kbd> does just what its name suggests--it recycles or reuses its children to present different data to the user. This means that while it appears to have a long list of child-widgets (such as cards or images), it actually has the ones that the user can actually see. When a widget is scrolled off the screen, the <kbd>RecyclerView</kbd> changes its data, and then scrolls it back into view. The <kbd>RecyclerView</kbd> doesn't directly bind the data to the child views; however, it instead goes through a <kbd>ViewHolder</kbd>. The job of the <kbd>ViewHolder</kbd> is to help speed up the data binding process. Think of the travel claim app again; if we want to display each claim item in a <kbd>RecyclerView</kbd>, each one will look something like the following:</p>
<div><img height="115" width="301" src="img/35725611-1c45-4bd8-ad7d-f7e47770b77f.png"/></div>
<p>Each of the preceding items will require a different Android widget, and every time you want to populate them, they need to be looked up and bound to their new data. A <kbd>ViewHolder</kbd> implementation is a convenient place to look up, hold, and bind data for a specific data model type and display component. Let's go ahead and build a layout resource for the preceding diagram, and then we can create a <kbd>ViewHolder</kbd> to use it with a <kbd>RecyclerView</kbd>:</p>
<ol>
<li style="font-weight: 400">In Android Studio, under the application resources (res) directory, right-click on the layout directory and select New| Layout resource file.</li>
<li style="font-weight: 400">Name the new layout resource <kbd>card_claim_item</kbd>.</li>
<li style="font-weight: 400">Change the Root element to <kbd>CardView</kbd>:</li>
</ol>
<div><img height="105" width="546" src="img/9252a871-8c69-479e-9a8e-f811caa9b3ca.png"/></div>
<ol start="4">
<li style="font-weight: 400">Click OK to create the new layout file.</li>
<li style="font-weight: 400">In the Palette, open the Layouts section and drag a <kbd>ConstraintLayout</kbd> into the Design canvas.</li>
<li style="font-weight: 400">In the Palette, open the Images section and drag an <kbd>ImageView</kbd> into the Design canvas.</li>
<li style="font-weight: 400">Select the <kbd>ic_other_black</kbd> icon from the drawable resource selector that automatically opens.</li>
</ol>
<ol start="8">
<li style="font-weight: 400">Use the constraint editor on the right to add constraints to the top, left, and bottom of the new <kbd>ImageView</kbd>, and set all of them to 8, as shown:</li>
</ol>
<div><img height="190" width="442" src="img/2da0a0d1-9057-46f6-baa6-caf326b33dbc.png"/></div>
<ol start="9">
<li style="font-weight: 400">Change the ID of the <kbd>ImageView</kbd> to <kbd>item_category</kbd>.</li>
<li style="font-weight: 400">In the Palette, open the Text section and drag a new <kbd>TextView</kbd> into the Design canvas to the right of the category icon <kbd>ImageView</kbd>.</li>
<li style="font-weight: 400">Use the constraint editor to add constraints of <kbd>8dp</kbd> to the top, right, and bottom of the new <kbd>TextView</kbd> so that it centers and places itself to the right of the Design canvas (directly opposite the category icon <kbd>ImageView</kbd>).</li>
<li style="font-weight: 400">Change the ID of the <kbd>TextView</kbd> to <kbd>item_amount</kbd>.</li>
<li style="font-weight: 400">Remove the contents of the text attribute, and change the text attribute below it (the one with the spanner icon) to <kbd>250</kbd>. This value is only used by the Design canvas, and allows you to preview what the layout will look like with set values (even though the real values are populated at runtime):</li>
</ol>
<div><img height="71" width="224" src="img/106fa629-d493-4c5d-81a9-56d974b9f2f2.png"/></div>
<ol start="14">
<li style="font-weight: 400">Change the textAppearance attribute to <kbd>@style/TextAppearance.AppCompat.Medium</kbd>, which will appear in the drop-down as <kbd>AppCompat.Medium</kbd>.</li>
<li style="font-weight: 400">From the Palette, drag another <kbd>TextView</kbd> into the design view, roughly between the icon <kbd>ImageView</kbd> and the amount <kbd>TextView</kbd>.</li>
</ol>
<ol start="16">
<li style="font-weight: 400">Drag a constraint from the left of the <kbd>TextView</kbd> to the right handle of the <kbd>ImageView</kbd>:</li>
</ol>
<div><img height="89" width="320" src="img/6cbf6ca0-fcdc-4af8-8025-a9c72e7b6b69.png"/></div>
<ol start="17">
<li>Drag another constraint from the right of the new <kbd>TextView</kbd> to the left of the amount <kbd>TextView</kbd>:</li>
</ol>
<div><img height="96" width="325" src="img/b8d9f203-c38f-4ae7-bd53-786b4454340a.png"/></div>
<ol start="18">
<li style="font-weight: 400">Use the constraint editor to add a constraint to the top of the new <kbd>TextView</kbd>.</li>
<li style="font-weight: 400">Set the top constraint to <kbd>8</kbd>:</li>
</ol>
<div><img height="229" width="220" src="img/58ab0190-b105-4f8c-86c2-cc4ec50a1895.png"/></div>
<ol start="20">
<li style="font-weight: 400">Change the <kbd>layout_width</kbd> attribute of the new <kbd>TextView</kbd> to <kbd>match_constraint</kbd> using the Attributes panel (just below the constraint editor).</li>
<li style="font-weight: 400">Change the ID of the new <kbd>TextView</kbd> to <kbd>item_description</kbd>.</li>
<li style="font-weight: 400">Clear the text attribute, and set the Design text attribute to <kbd>Airport Shuttle</kbd> so that you still have something visible in the Design canvas.</li>
<li style="font-weight: 400">Change the textAppearance attribute to <kbd>@style/TextAppearance.AppCompat.Medium</kbd>, which will appear in the drop-down as <kbd>AppCompat.Medium</kbd>.</li>
<li style="font-weight: 400">From the Palette, drag a third <kbd>TextView</kbd> into the Design canvas and drop it between the category icon <kbd>ImageView</kbd> and the amount <kbd>TextView</kbd>.</li>
<li style="font-weight: 400">Just like the description <kbd>TextView</kbd>, constrain the new <kbd>TextView</kbd> to the right of the category icon and to the left of the amount <kbd>TextView</kbd>.</li>
<li style="font-weight: 400">Using the constraint editor, add a constraint at the bottom of the new <kbd>TextView</kbd>, and set its bottom margin to <kbd>8</kbd>:</li>
</ol>
<div><img src="img/6dc42f5a-4a43-4eb2-b06f-1fb6ffcf269a.png"/></div>
<ol start="27">
<li style="font-weight: 400">Set the ID of the new <kbd>TextView</kbd> to <kbd>item_timestamp</kbd>.</li>
<li style="font-weight: 400">Change the layout_width of the new <kbd>TextView</kbd> to match_constraint.</li>
<li style="font-weight: 400">Drag a constraint from the top of the new <kbd>TextView</kbd> to the bottom of the description <kbd>TextView</kbd>; this will ensure that they have at least 8dp between them.</li>
<li style="font-weight: 400">Clear the text attribute, and set the Design tool text attribute to a date such as <kbd>27-December-2017</kbd>.</li>
<li style="font-weight: 400">In the Component Tree panel, select the <kbd>CardView</kbd> at the root of your layout.</li>
<li style="font-weight: 400">Switch over to the View all attributes panel.</li>
<li style="font-weight: 400">Open the Layout_Margin group.</li>
</ol>
<ol start="34">
<li style="font-weight: 400">Set the top margin to <kbd>@dimen/grid_spacer1</kbd>.</li>
<li style="font-weight: 400">Change the layout_height of the <kbd>CardView</kbd> to wrap_content; the layout will roll up looking something like this:</li>
</ol>
<div><img height="72" width="328" src="img/083ab09e-f133-47ad-a21a-bd2c2d4b0472.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a simple ViewHolder class</h1>
                
            
            
                
<p>Creating a <kbd>ViewHolder</kbd> is very simple, and it's a good place to encapsulate any display specific logic for rendering the items for a <kbd>RecyclerView</kbd>. For the preceding layout, follow these steps to build a <kbd>ViewHolder</kbd>:</p>
<ol>
<li>Right-click on the ui package in Android Studio, and select New| Java Class.</li>
<li style="font-weight: 400">Name the new class <kbd>ClaimItemViewHolder</kbd>.</li>
<li style="font-weight: 400">Set the new classes Superclass to <kbd>android.support.v7.widget.RecyclerView.ViewHolder</kbd>.</li>
<li style="font-weight: 400">Click OK to create the new class.</li>
<li style="font-weight: 400">The main job of a <kbd>ViewHolder</kbd> is to speed up the binding between the data model and the user interface widgets and for that to happen, the <kbd>ViewHolder</kbd> needs references to each of the <kbd>View</kbd> objects it will populate:</li>
</ol>
<pre style="padding-left: 60px">private final ImageView categoryIcon;<br/>private final TextView description;<br/>private final TextView amount;<br/>private final TextView timestamp;</pre>
<ol start="6">
<li>This <kbd>ViewHolder</kbd> will also need a way to format the timestamp, and the best way to do that is with a <kbd>java.text.DateFormat</kbd>, which is also something to keep a reference to as they're quite expensive to construct:</li>
</ol>
<pre style="padding-left: 60px">private final DateFormat dateFormat;</pre>
<ol start="7">
<li>A <kbd>ViewHolder</kbd> is usually constructed with the <kbd>View</kbd> object it's expected to bind to. You can inflate the <kbd>View</kbd> object within the <kbd>ViewHolder</kbd> constructor, but to keep things flexible and avoid argument clutter on the constructor, this <kbd>ViewHolder</kbd> implementation will just take the <kbd>View</kbd> object it will wrap:</li>
</ol>
<pre style="padding-left: 60px">public ClaimItemViewHolder(final View claimItemCard) {<br/>    super(claimItemCard);<br/>    this.categoryIcon = claimItemCard.findViewById(R.id.item_category);<br/>    this.description = claimItemCard.findViewById(R.id.item_description);<br/>    this.amount = claimItemCard.findViewById(R.id.item_amount);<br/>    this.timestamp = claimItemCard.findViewById(R.id.item_timestamp);</pre>
<ol start="8">
<li>You also need to create the <kbd>DateFormat</kbd> object and, for this, you want the long date format in the user's current locale:</li>
</ol>
<pre style="padding-left: 60px">this.dateFormat = DateFormat.getDateInstance(DateFormat.LONG);</pre>
<ol start="9">
<li>This class will need a utility method to figure out which icon should be rendered for a <kbd>Category</kbd> that will involve manually referencing the application <kbd>Resources</kbd> to retrieve the black versions of the category icons:</li>
</ol>
<pre>public Drawable getCategoryIcon(final Category category) {<br/>    final Resources resources = itemView.getResources();<br/>    switch (category) {<br/>        case ACCOMMODATION:<br/>            return resources.getDrawable(R.drawable.ic_hotel_black);<br/>        case FOOD:<br/>            return resources.getDrawable(R.drawable.ic_food_black);<br/>        case TRANSPORT:<br/>            return resources.getDrawable(R.drawable.ic_transport_black);<br/>        case ENTERTAINMENT:<br/>            return resources.getDrawable(R.drawable.ic_entertainment_black);<br/>        case BUSINESS:<br/>            return resources.getDrawable(R.drawable.ic_business_black);<br/>        case OTHER:<br/>        default:<br/>            return resources.getDrawable(R.drawable.ic_other_black);<br/>    }<br/>}</pre>
<ol start="10">
<li>You'll also need a utility method to format the amounts so that integer amounts don't have any decimal component, while non-integers only display two decimal places:</li>
</ol>
<pre>public String formatAmount(final double amount) {<br/>    return amount == 0<br/>            ? ""<br/>            : amount == (int) amount<br/>            ? Integer.toString((int) amount)<br/>           : String.format("%.2f", amount);<br/>}</pre>
<ol start="11">
<li>Finally, you need a way for the adapter to populate all the <kbd>View</kbd> elements with data, and because this class is specific to the <kbd>ClaimItem</kbd> data objects, you can make this simple by having a setter-like method:</li>
</ol>
<pre>public void setClaimItem(final ClaimItem item) {<br/>    categoryIcon.setImageDrawable(getCategoryIcon(item.getCategory()));<br/>    description.setText(item.getDescription());<br/>    amount.setText(formatAmount(item.getAmount()));<br/>    timestamp.setText(dateFormat.format(item.getTimestamp()));<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a ViewHolder with data binding</h1>
                
            
            
                
<p>As you can see from building a traditional <kbd>ViewHolder</kbd> implementation, there is quite a lot of work and boilerplate code required just to put the data from a single item onto the screen in a layout. Further, it's actually quite expensive in its own right, because every one of the <kbd>ViewHolder</kbd> instances creates and holds an instance of the <kbd>DateFormatter</kbd> where they can easily be shared between all the <kbd>ClaimItemViewHolder</kbd> instances for a <kbd>RecyclerView</kbd>.</p>
<p class="mce-root">In cases like this, data binding can make a huge difference. Using a few tricks, you can actually create a completely generic <kbd>ViewHolder</kbd> implementation that will work for any data object in your application (assuming that you can bind it to a layout file). First, you'll need to create a nice generic <kbd>ItemPresenter</kbd>, and then modify the layout, and then you're ready to create a generic data-binding <kbd>ViewHolder</kbd> implementation. Follow these instructions, and you'll only ever need one <kbd>ViewHolder</kbd> implementation:</p>
<ol>
<li style="font-weight: 400">Right-click on the presenters package in Android Studio, and select New| Java Class.</li>
<li style="font-weight: 400">Name the class <kbd>ItemPresenter</kbd>.</li>
<li style="font-weight: 400">Click OK to create the new class.</li>
</ol>
<ol start="4">
<li style="font-weight: 400">The <kbd>ItemPresenter</kbd> will need a <kbd>Context</kbd> to reference application <kbd>Resources</kbd> and files:</li>
</ol>
<pre style="padding-left: 60px">private final Context context;<br/><br/>public ItemPresenter(final Context context) {<br/>    this.context = context;<br/>}</pre>
<ol start="5">
<li>Create a <kbd>formatAmount</kbd> utility method the same way as in the simple <kbd>ViewHolder</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">public String formatAmount(final double amount) {<br/>    return amount == 0<br/>            ? ""<br/>            : amount == (int) amount<br/>            ? Integer.toString((int) amount)<br/>            : String.format("%.2f", amount);<br/>}</pre>
<ol start="6">
<li>Write a <kbd>getCategoryIcon</kbd> utility method into the new <kbd>ItemPresenter</kbd> (this is almost exactly the same as the one in the <kbd>ClaimItemViewHolder</kbd>, except in how it accesses the <kbd>Resources</kbd> object):</li>
</ol>
<pre style="padding-left: 60px">public Drawable getCategoryIcon(final Category category) {<br/>    final Resources resources = context.getResources();<br/>    switch (category) {<br/>        case ACCOMMODATION:<br/>            return resources.getDrawable(R.drawable.ic_hotel_black);<br/>        case FOOD:<br/>            return resources.getDrawable(R.drawable.ic_food_black);<br/>        case TRANSPORT:<br/>            return resources.getDrawable(R.drawable.ic_transport_black);<br/>        case ENTERTAINMENT:<br/>            return resources.getDrawable(R.drawable.ic_entertainment_black);<br/>        case BUSINESS:<br/>            return resources.getDrawable(R.drawable.ic_business_black);<br/>        case OTHER:<br/>        default:<br/>            return resources.getDrawable(R.drawable.ic_other_black);<br/>    }<br/>}</pre>
<ol start="7">
<li>Write a <kbd>formatDate</kbd> utility method that will convert the <kbd>Date</kbd> objects into text suitable for displaying on the screen. The conversion is done by a <kbd>DateFormat</kbd> object, which is only created the first time <kbd>formatDate</kbd> is called (it is lazy-initialized). The lazy-initialization is important, as this class is expected to be generic across all possible item presenters in the application and so, there will be cases where it's not used:</li>
</ol>
<pre style="padding-left: 60px">private DateFormat dateFormat;<br/>public String formatDate(final Date date) {<br/>    if (dateFormat == null) {<br/>        dateFormat = DateFormat.getDateInstance(DateFormat.LONG);<br/>    }<br/><br/>    return dateFormat.format(date);<br/>}</pre>
<ol start="8">
<li style="font-weight: 400">Now, open the <kbd>card_claim_item.xml</kbd> layout resource.</li>
<li style="font-weight: 400">Change to the Text view in the editor.</li>
<li style="font-weight: 400">Create a new layout root element above the <kbd>CardView</kbd>, and ensure that you remove the namespace declarations from the <kbd>CardView</kbd> and close the layout element at the end of the file:</li>
</ol>
<pre style="padding-left: 60px">&lt;layout <br/>    <br/>    &gt;</pre>
<ol start="11">
<li>Above the <kbd>CardView</kbd>, declare a data block with two variables. It's important to keep these names generic. One will be an instance of <kbd>ItemPresenter</kbd>, and the other will be the <kbd>ClaimItem</kbd> to be bound by the layout:</li>
</ol>
<pre style="padding-left: 60px">&lt;data&gt;<br/>    &lt;variable name="presenter" type="com.packtpub.claim.ui.presenters.ItemPresenter" /&gt;<br/>    &lt;variable name="item" type="com.packtpub.claim.model.ClaimItem" /&gt;<br/>&lt;/data&gt;</pre>
<ol start="12">
<li>Find the <kbd>ImageView</kbd> declaration for <kbd>item_category</kbd> and add a new data-bound attribute to use the <kbd>ItemPresenter</kbd> to find the correct icon:</li>
</ol>
<pre style="padding-left: 60px">&lt;ImageView<br/>    android:id="@+id/category_icon"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:layout_marginBottom="8dp"<br/>    android:layout_marginStart="8dp"<br/>    android:layout_marginTop="8dp"<br/>    <strong>app:imageDrawable="@{presenter.getCategoryIcon(item.category)}"</strong><br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintStart_toStartOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="13">
<li>Find the amount <kbd>TextView</kbd> declaration and data bind its text attribute, using the presenter to format the amount from the <kbd>ClaimItem</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/item_amount"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:layout_marginBottom="8dp"<br/>    android:layout_marginEnd="8dp"<br/>    android:layout_marginTop="8dp"<br/>    <strong>android:text="@{presenter.formatAmount(item.amount)}"</strong><br/>    android:textAppearance="@style/TextAppearance.AppCompat.Medium"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintEnd_toEndOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent"<br/>    tools:text="150" /&gt;</pre>
<ol start="14">
<li>Data bind the description from the <kbd>ClaimItem</kbd> to the <kbd>item_description</kbd> <kbd>TextView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/item_description"<br/>    android:layout_width="0dp"<br/>    android:layout_height="wrap_content"<br/>    android:layout_marginEnd="8dp"<br/>    android:layout_marginStart="16dp"<br/>    android:layout_marginTop="8dp"<br/>    <strong>android:text="@{item.description}"</strong><br/>    android:textAppearance="@style/TextAppearance.AppCompat.Medium"<br/>    app:layout_constraintEnd_toStartOf="@+id/item_amount"<br/>    app:layout_constraintStart_toEndOf="@+id/category_icon"<br/>    app:layout_constraintTop_toTopOf="parent"<br/>    tools:text="Airport Shuttle" /&gt;</pre>
<ol start="15">
<li>Use the presenter to data bind the timestamp from the <kbd>ClaimItem</kbd> to the timestamp <kbd>TextView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/item_timestamp"<br/>    android:layout_width="0dp"<br/>    android:layout_height="wrap_content"<br/>    android:layout_marginBottom="8dp"<br/>    android:layout_marginEnd="8dp"<br/>    <strong>android:text="@{presenter.formatDate(item.timestamp)}"</strong><br/>    android:textAppearance="@style/TextAppearance.AppCompat.Small"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintEnd_toStartOf="@+id/item_amount"<br/>    app:layout_constraintStart_toStartOf="@+id/item_description"<br/>    app:layout_constraintTop_toBottomOf="@+id/item_description"<br/>    tools:text="16-December-2017" /&gt;</pre>
<ol start="16">
<li style="font-weight: 400">Now, it's time to start on a generic <kbd>ViewHolder</kbd> class that can be reused with any data-bound layout. Right-click on the ui package and select New | Java Class.</li>
<li style="font-weight: 400">Name the new class <kbd>DataBoundViewHolder</kbd>.</li>
<li style="font-weight: 400">Change the Superclass to <kbd>android.support.v7.widget.RecyclerView.ViewHolder</kbd>.</li>
<li style="font-weight: 400">Click OK to create the new class.</li>
<li style="font-weight: 400">Add a generic declaration to the class so that you have generic types for the Presenter, and Item (P, I) variables:</li>
</ol>
<pre style="padding-left: 60px">public class DataBoundViewHolder&lt;P, I&gt; extends RecyclerView.ViewHolder {</pre>
<ol start="21">
<li>Every Binding class generated by the data binding system extends <kbd>ViewDataBinding</kbd>; the <kbd>DataBoundViewHolder</kbd> will actually wrap one of these so that any data-bound layout can be wrapped:</li>
</ol>
<pre style="padding-left: 60px">private final ViewDataBinding binding;</pre>
<ol start="22">
<li>Now, write a constructor that takes a <kbd>ViewDataBinding</kbd> object and a Presenter object for the data-bound layout to use. As <kbd>ViewDataBinding</kbd> is a generic abstract class, we can't directly call the <kbd>setPresenter</kbd> method that will be generated by the data binding system in the <kbd>CardClaimItemBinding</kbd> class. Instead, we can use a special generic data binding method that allows you to assign unknown variables based on a generated ID number; this is a bit like using Java reflection, except that the actual implementation is generated at compile time and is very fast:</li>
</ol>
<pre style="padding-left: 60px">public DataBoundViewHolder(final ViewDataBinding binding, final P presenter) {<br/>    super(binding.getRoot());<br/>    this.binding = binding;<br/>    <strong>this.binding.setVariable(BR.presenter, presenter);</strong><br/>}</pre>
<p>If you are presented with a choice of multiple <kbd>BR</kbd> classes to import, use the one for your own project (<kbd>com.packtpub.claim</kbd>). Much like the normal Android resources (<kbd>R</kbd>), the data binding system generates a lookup class for each project.</p>
<ol start="23">
<li>Then, write in two setter methods so that the <kbd>Presenter</kbd> and <kbd>item</kbd> variables can be changed uniformly from the outside:</li>
</ol>
<pre>public void setItem(final I item) {<br/>    binding.setVariable(BR.item, item);<br/>}<br/><br/>public void setPresenter(final P presenter) {<br/>    binding.setVariable(BR.presenter, presenter);<br/>}</pre>
<p>The <kbd>setVariable</kbd> method is generated at compile time, just like the getter and setter methods as a series of <kbd>if</kbd> statements. This makes it a little slower than the actual setter methods, but much faster than using reflection to invoke the setter methods. It's not the sort of area that should need optimization, especially as there are only two possible variables for these data-bound layouts. If your layout needs more than these two variables in a <kbd>RecyclerView</kbd>, you should consider composing or inheriting the logic and data required into more specific classes.</p>
<p>The generated <kbd>setVariable</kbd> implementation of the <kbd>card_claim_item</kbd> layout defined in this section will look something like this:</p>
<pre>public boolean setVariable(int variableId, @Nullable Object variable) {<br/>    boolean variableSet = true;<br/>    if (BR.item == variableId) {<br/>        setItem((com.packtpub.claim.model.ClaimItem) variable);<br/>    }<br/>    else if (BR.presenter == variableId) {<br/>        setPresenter((ItemPresenter) variable);<br/>    }<br/>    else {<br/>        variableSet = false;<br/>    }<br/>    return variableSet;<br/>}</pre>
<p>As you can see, this code will execute very quickly and won't throw exceptions if an unknown variable ID is given. However, it will throw a <kbd>ClassCastException</kbd> if you tried to pass in the wrong type for a data-bound variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a RecyclerView adapter</h1>
                
            
            
                
<p>In order to get data into a <kbd>RecyclerView</kbd>, you need an <kbd>Adapter</kbd> class, not unlike the <kbd>PagerAdapter</kbd> you wrote to display the attachment previews for the <kbd>CaptureClaimActivity</kbd>. However, <kbd>RecyclerView</kbd> does a lot more of the heavy lifting than <kbd>ViewPager</kbd> and as a result, what you can and can't do inside the adapter is far more restricted than with <kbd>PagerAdapter</kbd>. Also, unlike a <kbd>PagerAdapter</kbd>, a <kbd>RecylcerView</kbd> adapter has two actions that are involved in displaying each element: create and bind. When the <kbd>RecyclerView</kbd> needs a new child widget for an element, it will invoke <kbd>onCreateViewHolder</kbd>, which should return an unpopulated <kbd>ViewHolder</kbd>, which will then be passed to <kbd>onBindViewHolder</kbd> where the data should be mapped into the <kbd>View</kbd> from whatever data source the adapter uses.</p>
<p class="mce-root">First off, the <kbd>RecyclerView</kbd> maintains the list of its child views completely, so the adapter must never add or remove them directly. Secondly, the <kbd>RecyclerView</kbd> expects the adapter to be stable, that is, the data within the adapter must not change without telling the <kbd>RecyclerView</kbd> about the changes.</p>
<p class="mce-root">Unlike older recycling widget classes like <kbd>ListView</kbd> and <kbd>GridView</kbd>, <kbd>RecyclerView</kbd> does not assume that it's presenting the same object model over and over. Instead, each object returned from the <kbd>Adapter</kbd> can optionally have a view type indicator; when these are different, the <kbd>RecylcerView</kbd> maintains a separate pool for each of the view types and recycles all of them separately.</p>
<p>When using different view types, it's common for the adapter to use the layout resource ID as the view type; these are unique per application and avoid any need for a <kbd>switch</kbd> statement or similar mapping between internal view type IDs and the actual resources.</p>
<p>For the travel claim example, you will need an adapter to display all the <kbd>ClaimItems</kbd> on the overview screen. Fortunately, Room provides you with a prebuilt <kbd>LiveData</kbd>, which can be observed directly, which makes building the adapter much simpler. Follow these simple steps to build a <kbd>RecyclerView</kbd> adapter bound to a <kbd>LiveData</kbd> object, and use the <kbd>DataBoundViewHolder</kbd> to present the data to the user:</p>
<ol>
<li style="font-weight: 400">Right-click on the ui package and select New| Java Class.</li>
<li style="font-weight: 400">Name the new class <kbd>ClaimItemAdapter</kbd>.</li>
<li style="font-weight: 400">Click OK to create the new class.</li>
</ol>
<ol start="4">
<li style="font-weight: 400">Change the class declaration to extend from <kbd>RecyclerView.Adapter</kbd> and describe the <kbd>DataBoundViewHolder</kbd> generic you will be using:</li>
</ol>
<pre style="padding-left: 60px">public class ClaimItemAdapter<br/>       extends RecyclerView.Adapter&lt;DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt;&gt; {</pre>
<ol start="5">
<li>This adapter class will inflate the data-bound layout files as resources, so it'll need a <kbd>LayoutInflator</kbd> to do the work for it:</li>
</ol>
<pre style="padding-left: 60px">private final LayoutInflater layoutInflater;</pre>
<ol start="6">
<li>The <kbd>ItemPresenter</kbd> instances can also be shared between all the claim item layouts that are on screen, so the <kbd>ClaimItemAdapter</kbd> should hold a reference to it:</li>
</ol>
<pre style="padding-left: 60px">private final ItemPresenter itemPresenter;</pre>
<ol start="7">
<li>Most importantly, the <kbd>ClaimItemAdapter</kbd> needs data to display. Ensure that you instantiate this reference so that you don't need null-checks in your other methods:</li>
</ol>
<pre style="padding-left: 60px">private List&lt;ClaimItem&gt; items = Collections.emptyList();</pre>
<ol start="8">
<li>Now, declare a constructor for <kbd>ClaimItemAdapter</kbd>; as <kbd>ClaimItemAdapter</kbd> will observe a <kbd>LiveData</kbd> object, it'll need a <kbd>LifecycleOwner</kbd> as well. The <kbd>LifecycleOwner</kbd> tells the <kbd>LiveData</kbd> when to notify you of changes, and when not to and also when to unregister any listeners. Typical <kbd>LifecycleOwners</kbd> are <kbd>Activity</kbd> or <kbd>Fragment</kbd> instances, but you can make almost any class a <kbd>LifecycleOwner</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public ClaimItemAdapter(<br/>        final Context context,<br/>        final LifecycleOwner owner,<br/>        final LiveData&lt;List&lt;ClaimItem&gt;&gt; liveItems) {<br/><br/>    this.layoutInflater = LayoutInflater.from(context);<br/>    this.itemPresenter = new ItemPresenter(context);</pre>
<p>For further flexibility, you can allow the <kbd>ItemPresenter</kbd> to be passed into the constructor. This will allow the <kbd>ItemPresenter</kbd> to be extended or configured outside of the <kbd>ClaimItemAdapter</kbd> objects, and each instance can be given different presentation rules.</p>
<ol start="9">
<li>Note that the <kbd>ClaimItemAdapter</kbd> doesn't keep a reference to the <kbd>LiveData</kbd> instance yet, and in fact, it won't directly hold a reference at all. Instead, you'll use an anonymous inner class (or lambda if it's available to you) to observe the <kbd>LiveData</kbd>. It's important to know that when you start observing a <kbd>LiveData</kbd> instance, you will automatically get an <em>initial</em> event with the current state of the data, if your <kbd>LifecycleOwner</kbd> is in the correct state. This means you should never need to attempt to fetch the data directly:</li>
</ol>
<pre style="padding-left: 60px">liveItems.observe(owner, new Observer&lt;List&lt;ClaimItem&gt;&gt;() {<br/>    public void onChanged(final List&lt;ClaimItem&gt; claimItems) {<br/>        <strong>ClaimItemAdapter.this.items = (claimItems != null)</strong><br/><strong>                ? claimItems </strong><br/><strong>                : Collections.&lt;ClaimItem&gt;emptyList();</strong><br/><strong>        ClaimItemAdapter.this.notifyDataSetChanged();</strong><br/>    }<br/>});</pre>
<ol start="10">
<li>Now the constructor is complete, and it's time to implement the binding-related features. The first step is to implement <kbd>onCreateViewHolder</kbd>, which will use the <kbd>DataBindingUtil</kbd> to create the layout and the <kbd>ViewDataBinding</kbd> that the <kbd>DataBoundViewHolder</kbd> will wrap:</li>
</ol>
<pre style="padding-left: 60px">public DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt; onCreateViewHolder(<br/>        final ViewGroup parent,<br/>        final int viewType) {<br/><br/>    return new DataBoundViewHolder&lt;&gt;(<br/>            <strong>DataBindingUtil.inflate(</strong><br/><strong>                    layoutInflater,</strong><br/><strong>                    R.layout.card_claim_item,</strong><br/><strong>                    parent,</strong><br/><strong>                    false</strong><br/><strong>            )</strong>,<br/>            itemPresenter<br/>    );<br/>}</pre>
<ol start="11">
<li>Due to the <kbd>DataBoundViewHolder</kbd> implementation, the <kbd>onBindViewHolder</kbd> method is trivial to implement:</li>
</ol>
<pre style="padding-left: 60px">public void onBindViewHolder(<br/>        final DataBoundViewHolder&lt;ItemPresenter, ClaimItem&gt; holder,<br/>        final int position) {<br/><br/>    holder.setItem(items.get(position));<br/>}</pre>
<ol start="12">
<li>The <kbd>RecyclerView</kbd> also needs to know how many items are in the data model:</li>
</ol>
<pre style="padding-left: 60px">public int getItemCount() {<br/>    return items.size();<br/>}</pre>
<p>This adapter can be very easily adapted further in the same way as the <kbd>DataBoundViewHolder</kbd>, to allow you to present any <kbd>LiveData</kbd> list returned from a Room database with an arbitrary data-bound layout file. The combination of data binding and <kbd>LiveData</kbd> makes for an extremely powerful combination that dramatically simplifies your user-interface code, and avoids the need to write lots of boilerplate structure for every combination of views and models.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data binding an adapter</h1>
                
            
            
                
<p>If you want to use data binding on a layout with a <kbd>RecyclerView</kbd> in it, you can even data bind the adapter object to the <kbd>RecyclerView</kbd>. All you need to do is expose a method to access the desired adapter object in a presenter class:</p>
<pre style="padding-left: 60px">private RecyclerView.Adapter&lt;?&gt; claimItemsAdapter;<br/><br/>public RecyclerView.Adapter&lt;?&gt; getClaimItemsAdapter() {<br/>    if (claimItemsAdapter == null) {<br/>        claimItemsAdapter = new ClaimItemAdapter(<br/>                this, this,<br/>                database.claimItemDao().selectAll()<br/>        );<br/>    }<br/><br/>    return claimItemsAdapter;<br/>}</pre>
<p>It's important that you preconstruct or cache the instances you create to avoid recreating the adapter object unnecessarily. It's also important to remember not to make the adapter an <kbd>ObservableField</kbd> or similar, since the adapter's content should be what changes, not the adapter itself. To bind the <kbd>RecyclerView</kbd> to its adapter, use the data binding system's <em>auto property</em> system:</p>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.RecyclerView<br/>    <strong>app:adapter="@{presenter.claimItemsAdapter}"</strong><br/>    app:layoutManager="android.support.v7.widget.LinearLayoutManager"<br/>    android:id="@+id/claim_items"<br/>    android:clipChildren="false"<br/>    android:layout_marginTop="@dimen/grid_spacer1"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;</pre>
<p>It's really important when using data binding and adapter views together to remember that they both update the user interface. As such, it's important to ensure that you keep the adapter reference in the presenter stable, and don't change it without being sure of yourself. Changing the adapter reference will cause the <kbd>AdapterView</kbd> (such as a <kbd>RecyclerView</kbd>) to completely rebuild its contents rather than just refreshing its contents. It's much better to use the adapter to notify the <kbd>AdapterView</kbd> of changes than it is to make the adapter observable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Overview activity</h1>
                
            
            
                
<p>The travel claim example app needs a nice overview activity to tie together the allowance overview, a list of the claim items, and a way for the user to create new claim items. As we have a Room database, things can become significantly more decoupled, and that's a really good thing. Having a central reactive source of data allows different parts of your application to always reflect the actual state of the application as it changes, without having to coordinate with each other.</p>
<p class="mce-root">The first part of building the <kbd>OverviewActivity</kbd> is creating the <kbd>Activity</kbd> class itself and populating it with the claim items that the user has entered. Follow these steps to create a skeleton <kbd>OverviewActivity</kbd> and register it as the main <kbd>Activity</kbd> for the application:</p>
<ol>
<li style="font-weight: 400">Start by right-clicking on your main package (that is, com.packtpub.claim) and selecting New | Activity | Empty Activity from the menu.</li>
</ol>
<ol start="2">
<li style="font-weight: 400">Name the new class <kbd>OverviewActivity</kbd>.</li>
<li style="font-weight: 400">Leave all the other fields as their defaults and select Finish to create the new <kbd>Activity</kbd> and its layout file.</li>
<li style="font-weight: 400">Open the new <kbd>activity_overview.xml</kbd> layout file and change to the Text editor.</li>
<li style="font-weight: 400">Android Studio will have placed a <kbd>ConstraintLayout</kbd> as the root element; change it to a <kbd>FrameLayout</kbd> instead, because this layout is very simple and since the logic will be self-binding, there is no point in using a data-bound layout:</li>
</ol>
<pre style="padding-left: 60px">&lt;FrameLayout <br/>    <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context="com.packtpub.claim.OverviewActivity"&gt;<br/><br/>&lt;/FrameLayout&gt;</pre>
<p>A <strong>FrameLayout</strong> is a very simple layout where its children are rendered on top of each other. The first child is painted first, and then the second child is painted on top of the first. This makes it ideally suited for building layered scenes, even when some layers will not always be visible.</p>
<ol start="6">
<li>The first child of the <kbd>FrameLayout</kbd> will be a simple <kbd>LinearLayout</kbd> to allow you to place the allowance overview above the scrolling list of claim items. <kbd>LinearLayout</kbd> is ideal here as it's a very simple and very fast layout to use, and we don't need the complexities of a <kbd>ConstraintLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;LinearLayout<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:clipToPadding="false"<br/>    android:orientation="vertical"<br/>    android:paddingTop="@dimen/grid_spacer1"<br/>    android:paddingBottom="@dimen/grid_spacer1"&gt;<br/>&lt;/LinearLayout&gt;</pre>
<ol start="7">
<li>The first child of the <kbd>LinearLayout</kbd> is the <kbd>AllowanceOverviewFragment</kbd>, which will allow the user to edit their daily allowance and see how much they're spending:</li>
</ol>
<pre style="padding-left: 60px">&lt;fragment<br/>    class="com.packtpub.claim.ui.AllowanceOverviewFragment"<br/>    android:id="@+id/allowance_overview"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content" /&gt;</pre>
<ol start="8">
<li>Next comes the <kbd>RecyclerView</kbd>, which will display a scrolling list of the claim items that the user has entered. Note the clipping and padding attributes here; they ensure that the claim item cards are inset, but that their full borders and shadows will be visible:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.RecyclerView<br/>    android:id="@+id/claim_items"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:layout_marginTop="@dimen/grid_spacer1"<br/>    <strong>android:clipToPadding="false"</strong><br/><strong>    android:paddingLeft="@dimen/grid_spacer1"</strong><br/><strong>    android:paddingRight="@dimen/grid_spacer1"</strong><br/>    app:layoutManager="android.support.v7.widget.LinearLayoutManager" /&gt;</pre>
<ol start="9">
<li style="font-weight: 400">Now, open the <kbd>OverviewActivity</kbd> class that Android Studio generated; it's time to populate the layout with claim items.</li>
<li style="font-weight: 400">We'll be rendering a list of <kbd>ClaimItem</kbd> objects using the <kbd>ClaimItemAdapter</kbd>, and it needs to watch for changes using the <kbd>LiveData</kbd> object produced by the database. This requires that the <kbd>Activity</kbd> report its life cycle, and this is done by extending one of the <kbd>Activity</kbd> implementations provided by the support packages (in this case, <kbd>AppCompatActivity</kbd>):</li>
</ol>
<pre style="padding-left: 60px">public class OverviewActivity<br/>        extends AppCompatActivity {</pre>
<ol start="11">
<li>As all the behavior for this Activity is actually handled by its fragments and by the <kbd>LiveData</kbd> changes triggered by the <kbd>ClaimDatabase</kbd>, the <kbd>onCreate</kbd> implementation only needs to set the adapter for the <kbd>RecyclerView</kbd>. All other logic and behavior for the <kbd>OverviewActivity</kbd> will be handled by the fragments and adapter:</li>
</ol>
<pre style="padding-left: 60px">protected void onCreate(final Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    setContentView(R.layout.activity_overview);<br/><br/>    final RecyclerView claimItems = findViewById(R.id.claim_items);<br/>    <strong>claimItems.setAdapter(new ClaimItemAdapter(</strong><br/><strong>            // both the Context, and LifecycleOwner are the OverviewActivity</strong><br/><strong>            this, this,</strong><br/><strong>            ClaimApplication.getClaimDatabase().claimItemDao().selectAll()</strong><br/><strong>    ));</strong><br/>}</pre>
<ol start="12">
<li style="font-weight: 400">Finally, you'll need to change the <kbd>AndroidManifest.xml</kbd> file to tell the system that the main entry point for the application is now the <kbd>OverviewActivity</kbd>, and not the <kbd>CaptureClaimActivity</kbd>; open the <kbd>manifests</kbd> folder near the top of your projects file-tree and open the <kbd>AndroidManifest.xml</kbd> file.</li>
<li style="font-weight: 400">Change the activity element declarations so that the MAIN / LAUNCHER intent-filter is in the <kbd>OverviewActivity</kbd> element instead of the <kbd>CaptureClaimActivity</kbd> element. It's also worth changing the <kbd>windowSoftInputMode</kbd> attribute so that the software keyboard doesn't automatically open when the <kbd>OverviewActivity</kbd> is started. The keyboard opens by default because the first widget on the screen is the <kbd>EditText</kbd> field, where the user can enter their daily allowance:</li>
</ol>
<pre style="padding-left: 60px">&lt;activity<br/>    android:name=".CaptureClaimActivity"<br/>    android:label="@string/title_activity_capture_claim"<br/>    android:theme="@style/AppTheme.NoActionBar" /&gt;<br/>&lt;activity<br/>    android:name=".OverviewActivity"<br/>    <strong>android:windowSoftInputMode="stateHidden"</strong>&gt;<br/>    <strong>&lt;intent-filter&gt;</strong><br/><strong>        &lt;action android:name="android.intent.action.MAIN" /&gt;</strong><br/><strong>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;</strong><br/><strong>    &lt;/intent-filter&gt;</strong><br/>&lt;/activity&gt;</pre>
<p>If you now run your application, you'll see that while the screen is technically complete, there are no claim items and no way to add them. As such, there is nothing in the <kbd>RecyclerView</kbd> to look at or scroll through:</p>
<div><img height="439" width="256" src="img/2c19f042-71c9-42b4-aad1-d96b93993b2f.png"/></div>
<p>You need to provide a way for your user to add new claim items. The best way is with a floating action button in the bottom-right corner of the screen, and we'll be doing that with a new <kbd>Fragment</kbd>. By using a <kbd>Fragment</kbd> for this task, you'll be able to place a "new item" floating action button on any screen in the application without having to implement any special code in the <kbd>Activity</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating new ClaimItems with a Fragment</h1>
                
            
            
                
<p>An unusual property of using <kbd>LiveData</kbd> from a Room database is that various parts of your application can now interact without needing any direct knowledge of each other. In the case of your <kbd>OverviewActivity</kbd>, this will allow you to populate the database with new <kbd>ClaimItem</kbd> entities without dispatching any sort of "new item" or "item added" events to the <kbd>ClaimItemAdapter</kbd>. However, the Room database abstraction layer prevents you from running any query on the main thread unless it returns a <kbd>LiveData</kbd>. While the query to retrieve the <kbd>ClaimItem</kbd> entities returned a <kbd>LiveData</kbd>, inserting new <kbd>LiveData</kbd> entities will be required to run in the background. Follow these steps to build a <kbd>Fragment</kbd> that can allow the user to capture and record a new travel claim item:</p>
<ol>
<li style="font-weight: 400">You'll need a task to insert both a <kbd>ClaimItem</kbd> entity and any <kbd>Attachment</kbd> entities associated with it. This task will need to run on a background worker thread, so open the <kbd>ClaimDatabase</kbd> class in Android Studio.</li>
<li style="font-weight: 400">After the abstract methods that return, the <kbd>ClaimItemDao</kbd> and <kbd>AttachmentDao</kbd> declare a new method to return a <kbd>Runnable</kbd> task to insert a new <kbd>ClaimItem</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public Runnable createClaimItemTask(final ClaimItem claimItem) {<br/>    return new Runnable() {<br/>        @Override<br/>        public void run() {<br/>        }<br/>    };<br/>}</pre>
<ol start="3">
<li>Within the new <kbd>Runnable</kbd> task, you'll want to use a transaction to save the contents of the <kbd>ClaimItem</kbd> object into the database; if any part of this method fails, the transaction will be rolled back, and the method will have had no effect:</li>
</ol>
<pre style="padding-left: 60px"><strong>beginTransaction();</strong><br/>try {<br/>    final long claimId = claimItemDao().insert(claimItem);<br/>    claimItem.id = claimId;<br/><br/>    for (final Attachment attachment : claimItem.getAttachments()) {<br/>        attachment.claimItemId = claimId;<br/>        attachment.id = attachmentDao().insert(attachment);<br/>    }<br/>    <strong>setTransactionSuccessful();</strong><br/>} finally {<br/>    <strong>endTransaction();</strong><br/>}</pre>
<ol start="4">
<li style="font-weight: 400">You'll also need a method in <kbd>ClaimItem</kbd> to ensure that it has content and is considered valid, so open the <kbd>ClaimItem</kbd> class.</li>
<li style="font-weight: 400">At the end of the <kbd>ClaimItem</kbd> class, create a new <kbd>isValid</kbd> method; this will be used when the <kbd>CaptureClaimActivity</kbd> returns a <kbd>ClaimItem</kbd> to check whether we should store the new <kbd>ClaimItem</kbd> in the database:</li>
</ol>
<pre style="padding-left: 60px">public boolean isValid() {<br/>    return !TextUtils.isEmpty(description)<br/>            &amp;&amp; amount &gt; 0<br/>            &amp;&amp; timestamp != null<br/>            &amp;&amp; category != null;<br/>}</pre>
<ol start="6">
<li style="font-weight: 400">You'll need a new icon for adding claim items; right-click on the drawable resource directory and select New| Vector Asset.</li>
<li style="font-weight: 400">Using the Icon selector, find and select the icon named <kbd>add</kbd>.</li>
<li style="font-weight: 400">Name the new icon resource <kbd>ic_add_white_24dp</kbd>.</li>
<li style="font-weight: 400">Click on Next and then on Finish to create the new resource.</li>
<li style="font-weight: 400">Open the new icon resource in the Android Studio text editor.</li>
<li style="font-weight: 400">Change the <kbd>fillColor</kbd> attribute of the path element to make it white:</li>
</ol>
<pre style="padding-left: 60px">&lt;path<br/>    <strong>android:fillColor="#FFFFFFFF"</strong><br/>    android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/&gt;</pre>
<ol start="12">
<li style="font-weight: 400">Now, right-click on the ui package and select New| Fragment| Fragment (Blank).</li>
<li style="font-weight: 400">Name the new <kbd>Fragment</kbd> class <kbd>NewClaimItemFloatingActionButtonFragment</kbd>.</li>
<li style="font-weight: 400">Turn off the Include fragment factory methods and Include interface callbacks options.</li>
<li style="font-weight: 400">Click on the Finish button to create the new <kbd>Fragment</kbd> class.</li>
<li style="font-weight: 400">Open the new layout file that should be called <kbd>fragment_new_claim_item_floating_action_button.xml</kbd>.</li>
<li style="font-weight: 400">Replace the content of this file with just a <kbd>FloatingActionButton</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.FloatingActionButton<br/>    <br/>    <br/>    <br/>    tools:context="com.packtpub.claim.ui.NewClaimItemFloatingActionButtonFragment"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:fabSize="normal"<br/>    app:srcCompat="@drawable/ic_add_white_24dp" /&gt;</pre>
<ol start="18">
<li style="font-weight: 400">Now, open the new <kbd>NewClaimItemFloatingActionButtonFragment</kbd> class.</li>
<li style="font-weight: 400">Change the class declaration to implement the <kbd>View.OnClickListener</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">public class NewClaimItemFloatingActionButtonFragment<br/>        extends Fragment<br/>        implements View.OnClickListener {</pre>
<ol start="20">
<li>Declare a request-code to be used when sending the user to the <kbd>CaptureClaimActivity</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private static final int REQUEST_CODE_CREATE_CLAIM_ITEM = 100;</pre>
<ol start="21">
<li>Change the <kbd>onCreateView</kbd> method to also set the <kbd>OnClickListener</kbd> of the <kbd>FloatingActionButton</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public View onCreateView(<br/>        final LayoutInflater inflater,<br/>        final ViewGroup container,<br/>        final Bundle savedInstanceState) {<br/><br/>    final View button = inflater.inflate(<br/>            R.layout.fragment_new_claim_item_floating_action_button,<br/>            container,<br/>            false<br/>    );<br/><br/>    button.setOnClickListener(this);<br/>    return button;<br/>}</pre>
<ol start="22">
<li>Override the <kbd>onClick</kbd> method from the <kbd>View.OnClickListener</kbd> and start the <kbd>CaptureClaimActivity</kbd> for result:</li>
</ol>
<pre style="padding-left: 60px">@Override public void onClick(final View view) {<br/>    startActivityForResult(<br/>            new Intent(getContext(), CaptureClaimActivity.class),<br/>            REQUEST_CODE_CREATE_CLAIM_ITEM);<br/>}</pre>
<ol start="23">
<li>Override the <kbd>onActivityResult</kbd> method to handle the incoming <kbd>ClaimItem</kbd>, and if it's valid, save it in the database using the <kbd>SERIAL_EXECUTOR</kbd> from <kbd>AsyncTask</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public void onActivityResult(<br/>        final int requestCode,<br/>        final int resultCode,<br/>        final Intent data) {<br/><br/>    if (requestCode != REQUEST_CODE_CREATE_CLAIM_ITEM<br/>            || resultCode != Activity.RESULT_OK<br/>            || data == null) {<br/>        return;<br/>    }<br/><br/>    final ClaimItem claimItem = data.getParcelableExtra(<br/>            CaptureClaimActivity.EXTRA_CLAIM_ITEM<br/>    );<br/><br/>    <strong>if (claimItem.isValid()) {</strong><br/><strong>        final ClaimDatabase database = ClaimApplication.getClaimDatabase();</strong><br/><strong>        AsyncTask.SERIAL_EXECUTOR.execute(</strong><br/><strong>                database.createClaimItemTask(claimItem)</strong><br/><strong>        );</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="24">
<li style="font-weight: 400">Now, you'll need to add the new fragment to the <kbd>OverviewActivity</kbd>. Open the <kbd>activity_overview</kbd> layout file and change to Text mode.</li>
<li style="font-weight: 400">At the bottom of the <kbd>FrameLayout</kbd> root element, include a fragment tag referencing the <kbd>NewClaimItemFloatingActionButtonFragment</kbd> and position it at the bottom-right of the screen:</li>
</ol>
<pre style="padding-left: 60px">&lt;fragment<br/>        <strong>class="com.packtpub.claim.ui.NewClaimItemFloatingActionButtonFragment"</strong><br/>    android:id="@+id/new_claim_item"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:layout_gravity="bottom|end"<br/>    android:layout_margin="@dimen/fab_margin" /&gt;</pre>
<p>Now you should be able to run the application again; not only should you now have a floating action button at the bottom of the overview screen, but it will work! If you click on the button and capture some details on the <kbd>CaptureClaimActivity</kbd> and then select to navigate back to the <kbd>OverviewActivity</kbd>, the new claim item will appear in the list, sorted by date.</p>
<p class="mce-root">Unlike using <kbd>SQLiteDatabase</kbd> directly, Room will enforce only running queries on a worker thread. This makes it attractive to encapsulate your updates in a <kbd>Runnable</kbd> that can be run on a background thread such as you did with the <kbd>createClaimItemTask</kbd> in the <kbd>ClaimDatabase</kbd> class. Having these methods available on the <kbd>ClaimDatabase</kbd> makes them easily reusable, and keeps the logic consistent throughout your application. It also allows you to put them into queues or run them in parallel with other tasks if you choose to use a thread-pool instead of the <kbd>SERIAL_EXECUTOR</kbd> from <kbd>AsyncTask</kbd> (which will only run one task at a time).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Allowance overview with a Room database</h1>
                
            
            
                
<p>If you run the overview screen and add a few claims to it, you'll notice that one piece of the code isn't reacting to the new items being added to the database: the allowance overview at the top of the screen. This is because while everything else is connected to the Room database, it's still watching the <kbd>Allowance</kbd> data model. Using a data model like this is a good idea when the data is just in memory, but now that you have a database in place, things can change and simplify. For example, the <kbd>Allowance</kbd> class only really keeps how much the user plans to spend each day; the claim items can actually be seen as an entirely separate structure in the database model.</p>
<p class="mce-root">As such, you can move the daily allowance into a different type of data storage--<kbd>SharedPreferences</kbd>. <kbd>SharedPreferences</kbd> are key-value stores for Android that have a shared in-memory representation and atomic updates. If you don't expect them to store too much data, this makes them ideal to keep track of data that doesn't really go in an SQLite database. Let's change the model of the <kbd>Allowance</kbd> overview to use the <kbd>ClaimDatabase</kbd> and <kbd>SharedPreferences</kbd>:</p>
<ol>
<li style="font-weight: 400">First, open the <kbd>AllowanceOverviewPresenter</kbd> class.</li>
<li style="font-weight: 400">Change it from using the <kbd>Allowance</kbd> class to instead expose the daily allowance as an <kbd>ObservableInt</kbd>, and remove the <kbd>OnPropertyChangeCallback</kbd> so that the fields now look like this:</li>
</ol>
<pre style="padding-left: 60px">public final ObservableField&lt;SpendingStats&gt; spendingStats = new ObservableField&lt;&gt;();<br/>public final ObservableInt allowance = new ObservableInt();<br/>private final UpdateSpendingStatsCommand updateSpendStatsCommand =<br/>                  new UpdateSpendingStatsCommand();</pre>
<ol start="3">
<li>Now, change the <kbd>UpdateSpendingStatsCommand</kbd> inner class to take a <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects instead of an <kbd>Allowance</kbd> as its parameter:</li>
</ol>
<pre style="padding-left: 60px">private class UpdateSpendingStatsCommand extends ActionCommand&lt;List&lt;ClaimItem&gt;, SpendingStats&gt; {</pre>
<ol start="4">
<li>Now change the <kbd>onBackground</kbd> implementation to run a single scan through the given <kbd>List</kbd> of <kbd>ClaimItem</kbd> objects and calculate all the spending stats at once:</li>
</ol>
<pre style="padding-left: 60px">public SpendingStats onBackground(final List&lt;ClaimItem&gt; items) throws Exception {<br/>    final Pair&lt;Date, Date&gt; today = getToday();<br/>    final Pair&lt;Date, Date&gt; thisWeek = getThisWeek();<br/><br/>    double spentTotal = 0;<br/>    double spentToday = 0;<br/>    double spentThisWeek = 0;<br/><br/>    for (int i = 0; i &lt; items.size(); i++) {<br/>        final ClaimItem item = items.get(i);<br/>        spentTotal += item.getAmount();<br/><br/>        if (item.getTimestamp().compareTo(thisWeek.first) &gt;= 0<br/>                &amp;&amp; item.getTimestamp().compareTo(thisWeek.second) &lt;= 0) {<br/><br/>            spentThisWeek += item.getAmount();<br/>        }<br/><br/>        if (item.getTimestamp().compareTo(today.first) &gt;= 0<br/>                &amp;&amp; item.getTimestamp().compareTo(today.second) &lt;= 0) {<br/><br/>            spentToday += item.getAmount();<br/>        }<br/>    }<br/><br/>    // for stats we round everything to integers<br/>    return new SpendingStats(<br/>            (int) spentTotal,<br/>            (int) spentToday,<br/>            (int) spentThisWeek<br/>    );<br/>}</pre>
<ol start="5">
<li>Now, change the constructor so that it takes a <kbd>LifecycleOwner</kbd> and the starting allowance to display to the user. Then, use the <kbd>ClaimDatabase</kbd> to update the spending statistics whenever there are new <kbd>ClaimItem</kbd> objects added:</li>
</ol>
<pre style="padding-left: 60px">public AllowanceOverviewPresenter(<br/>        final LifecycleOwner lifecycleOwner,<br/>        final int allowance) {<br/>    <br/>    ClaimApplication.getClaimDatabase()<br/>            .claimItemDao()<br/>            .selectAll()<br/>            .observe(lifecycleOwner, new Observer&lt;List&lt;ClaimItem&gt;&gt;() {<br/>                @Override<br/>                public void onChanged(final List&lt;ClaimItem&gt; claimItems) {<br/>                    updateSpendStatsCommand.exec(claimItems);<br/>                }<br/>            });<br/><br/>    this.allowance.set(allowance);<br/>}</pre>
<ol start="6">
<li>You'll also need to change the <kbd>updateAllowance</kbd> method to use the <kbd>ObservableInt</kbd> instead of the <kbd>Allowance</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">public void updateAllowance(final CharSequence newAllowance) {<br/>    try {<br/>        allowance.set(Integer.parseInt(newAllowance.toString()));<br/>    } catch (final RuntimeException ex) {<br/>        //ignore<br/>        allowance.set(0);<br/>    }<br/>}</pre>
<ol start="7">
<li style="font-weight: 400">Now, open the <kbd>AllowanceOverviewFragment</kbd> class.</li>
<li style="font-weight: 400">Add a <kbd>SharedPreferences</kbd> field to the <kbd>AllowanceOverviewFragment</kbd>; we'll be using them more than once in this class:</li>
</ol>
<pre style="padding-left: 60px">private FragmentAllowanceOverviewBinding binding;<br/>private SharedPreferences preferences;</pre>
<ol start="9">
<li>Override the <kbd>onCreate</kbd> method of <kbd>Fragment</kbd> and retrieve the private <kbd>SharedPreferences</kbd> instance you'll be storing the daily allowance in. The first argument specifies the name of the <kbd>SharedPreferences</kbd> to retrieve, while the second specifies the scope as <kbd>private</kbd>, meaning only your application will be able to see or use this <kbd>SharedPreferences</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onCreate(final Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    this.preferences = getContext().getSharedPreferences(<br/>            "Allowance",<br/>            Context.MODE_PRIVATE<br/>    );<br/>}</pre>
<ol start="10">
<li>Create an <kbd>onCreateView</kbd> method to create an <kbd>AllowanceOverviewPresenter</kbd> and pass the <kbd>Fragment</kbd> instance as the <kbd>LifecycleOwner</kbd>, and to retrieve the current <kbd>allowancePerDay</kbd> from the <kbd>SharedPreferences</kbd>. The second argument passed to the <kbd>SharedPreferences.getInt</kbd> method is a default value that is returned if there is no existing value stored:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public View onCreateView(<br/>        final LayoutInflater inflater,<br/>        final ViewGroup container,<br/>        final Bundle savedInstanceState) {<br/><br/>    this.binding = DataBindingUtil.inflate(<br/>            inflater,<br/>            R.layout.fragment_allowance_overview,<br/>            container,<br/>            false<br/>    );<br/><br/>    this.binding.setPresenter(new AllowanceOverviewPresenter(<br/>            this,<br/>            preferences.getInt("allowancePerDay", 150)<br/>    ));<br/><br/>    return this.binding.getRoot();<br/>}</pre>
<ol start="11">
<li>Finally, create an <kbd>onDestroy</kbd> method to store the allowance per day back in the <kbd>SharedPreferences</kbd> object. You do this by first requesting an <kbd>Editor</kbd> from the <kbd>SharedPreferences</kbd>, and then applying the changes. All the changes in an <kbd>Editor</kbd> are atomically applied at the same time (atomically):</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onDestroy() {<br/>    super.onDestroy();<br/>    preferences.edit()<br/>            .putInt("allowancePerDay", this.binding.getPresenter().allowance.get())<br/>            .apply();<br/>}</pre>
<p>Now, if you build and run the application, you'll notice that the allowance overview will correctly show you how much you've spent "today", "this week", and in total. Use the date selector in the <kbd>CaptureClaimActivity</kbd> to add a few claim items on different days and see how the user interface reacts and recalculates the amounts that you've spent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<ol>
<li>An instance of <kbd>RecyclerView</kbd> will create one <kbd>View</kbd> instance for which of these?
<ul>
<li>Every item of data</li>
<li>Every item of data visible on the screen</li>
<li>Each type of data element that is also visible on the screen</li>
</ul>
</li>
<li class="mce-root">When attaching an observer to <kbd>LiveData</kbd> you need to do which of the following?
<ul>
<li class="mce-root">Detach it when its <kbd>LifecycleOwner</kbd> is destroyed</li>
<li class="mce-root">Attach it on the main thread</li>
<li class="mce-root">Provide a valid <kbd>LifecycleOwner</kbd></li>
</ul>
</li>
<li class="mce-root">Overview / Dashboard screens should have which of these features?
<ul>
<li class="mce-root">They should only use graphs to display statistics</li>
<li class="mce-root">They should not scroll if it can be avoided</li>
<li class="mce-root">They should display an overview with the most important information first</li>
</ul>
</li>
<li class="mce-root">The <kbd>ViewHolder</kbd> class is used by the <kbd>RecyclerView</kbd> to do what?
<ul>
<li class="mce-root">Improve the data binding performance</li>
<li class="mce-root">Reference the views that will be garbage collected</li>
<li class="mce-root">Store the <kbd>View</kbd> objects in a <kbd>Bundle</kbd></li>
</ul>
</li>
<li class="mce-root">When using <kbd>LiveData</kbd> objects to reference data used by multiple <kbd>Fragment</kbd> objects, which of these is true?
<ul>
<li class="mce-root">The <kbd>Fragment</kbd> instances must share the same <kbd>LiveData</kbd> reference to see changes</li>
<li class="mce-root">The <kbd>LiveData</kbd> will only update one of the <kbd>Fragment</kbd> instances</li>
<li class="mce-root">The <kbd>Fragment</kbd> classes must all extend <kbd>android.support.v4.app.Fragment</kbd></li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Overview screens are the first thing a user will see and interact with in your application, and will be the area of the application they will spend most of their time in. It's important to keep the screen focused and opinionated on what data is displayed to the user, and how it's displayed. Always consider how long the user has to look at your screen, and what information they will need easy access to. Make use of the <kbd>RecyclerView</kbd> and <kbd>LiveData</kbd> classes to provide the user with detailed views arranged with the most important information first, and allow them to quickly scroll through their most important recent events.</p>
<p class="mce-root">It's also important to consider the navigation of your application, the various ways the user will leave your overview screen, and how they will get back to it. As far as possible, keep the <kbd>Overview</kbd> class responsible for just arranging the data on the screen. Any logic that takes the user away from the screen, for whatever reason, should be encapsulated in <kbd>Fragment</kbd> classes that also hold the logic to deal with their eventual return to the overview screen.</p>
<p class="mce-root">In this chapter, we looked at a very simple way to build an overview screen. There are many ways that these sorts of screens can be made more useful and powerful by reshaping the layout on the screen as the user scrolls and drags various elements of the user interface.</p>
<p class="mce-root">In the next chapter, we'll take a look at how to leverage some of the layout systems provided by the Material Design API to allow the user interface to change its shape and emphasis dynamically.</p>
<p class="mce-root"/>


            

            
        
    </body></html>