<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Adding Boundaries and Using Sprites to Create Explosions</h1>
            </header>

            <article>
                
<p>In our preceding chapter, we covered the part where we successfully detected collisions. Now that we have understood how to deal with collisions, we can play around with our knowledge and add some cool stuff to our game. This chapter will be pretty concise, and if you have understood the concept of collision detection properly, then this will be a breeze for you. Here's what we will do in this chapter:</p>
<ul>
<li>Add a ground for our player as a boundary</li>
<li>Detect a collision between our player and rocks</li>
<li>Spawn an explosion sprite on the point where a collision takes place</li>
</ul>
<p>Observe that from the preceding tasks, we have already accomplished our second task, so we have to focus on the first and third tasks. Let's dive into creating a ground for our player because right now our player is simply going down infinitely. We will also add an upper boundary in order to contain our player within the screen, otherwise, our player would go right outside the screen. Again, we will divide this chapter into two parts:</p>
<ul>
<li>Adding boundaries to our game</li>
<li>Using sprites to create explosions</li>
</ul>
<p>Let's get started!</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Adding boundaries</h1>
            </header>

            <article>
                
<p>As we are quite familiar with the process of creating a new class, we will simply create our two new classes for our upper and lower boundary and call them <kbd>UpperBoundary.java</kbd> and <kbd>LowerBoundary.java</kbd>, respectively. We have the following objectives for our boundaries:</p>
<ul>
<li>Make them appear at the top and bottom of our game screen</li>
<li>If a player collides with them, then reset the game</li>
</ul>
<p>With these objectives in mind, we will move ahead to create boundaries for our game.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating the classes for our boundaries</h1>
            </header>

            <article>
                
<p>Before actually creating our boundaries, we will need an image sprite in order to make them visible on the screen. For this purpose, we will take a simple sprite with a plain color. Here's the sprite that we will be using for our game:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B05066_07_01.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Our ground.png file</div>
<p>Also, we will place this file in our <kbd>res/drawable</kbd> folder as we did for our previous image files. Once you are done with this, move on to the next part.</p>
<p>So now, let's create our <kbd>UpperBoundary.java</kbd> class. Go ahead, create a new class and write the following code in it:</p>
<pre>
<span>public class </span>UpperBoundary <span>extends </span>GameObj {<br/><span>    private </span>Bitmap <span>img</span>;<br/><span><br/>    public </span>UpperBoundary(Bitmap res, <span>int </span>xc, <span>int </span>yc, <span>int </span>h) {<br/><span>        height </span>= h;<br/><span>        width </span>= <span>20</span>;<br/><span><br/>        this</span>.<span>xc </span>= xc;<br/><span>        this</span>.<span>yc </span>= yc;<br/><span><br/>        dxc </span>= GameView.<span>MOVINGSPEED</span>;<br/><span>        img </span>= Bitmap.<span>createBitmap</span>(res, <span>0</span>, <span>0</span>, <span>width</span>, <span>height</span>);<br/>    }<br/><span><br/>    public void </span>update(){<br/><span>        xc </span>+= <span>dxc</span>;<br/>    }<br/><span><br/>    public void </span>draw(Canvas canvas) {<br/><span>        try</span>{<br/>            canvas.drawBitmap(<span>img</span>, <span>xc</span>, <span>yc</span>, <span>null</span>);<br/>        } <span>catch</span>(Exception e) {<br/>        };<br/>    }<br/>}
</pre>
<p>In this code, we are simply creating our boundary class with its constructor and <kbd>update()</kbd> and <kbd>draw()</kbd> functions. The constructor is pretty simple to understand here. Whenever we create an instance of our boundaries, we will pass in a sprite, the x y position, and the height. We will also set a speed in which the boundaries will move backward, giving an illusion that our player is moving forward.</p>
<p>Like all our previous game objects, this class also extends our main <kbd>GameObj</kbd> class. In a similar way, we will also create our <kbd>LowerBoundary.java</kbd> class. The only change we will make is in our <kbd>height</kbd> and <kbd>width</kbd> variable and the rest of the entire code remains the same as that of the <kbd>UpperBoundary.java</kbd> file:</p>
<pre>
<span>public class </span>LowerBoundary <span>extends </span>GameObj {<br/><span>    public </span>LowerBoundary(Bitmap res, <span>int </span>xc, <span>int </span>yc) {<br/><span>        height </span>= <span>200</span>;<br/><span>        width </span>= <span>20</span>;<br/>    }<br/>}
</pre>
<p>Note here that we are keeping the <kbd>height</kbd> constant since we want to spawn our bottom border as low as possible and thereby <kbd>200</kbd> is a safe limit for the same. You can experiment with these values as per your liking.</p>
<p>Now that we have our classes ready, it is time for us to bring them into our game.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating boundaries in our game</h1>
            </header>

            <article>
                
<p>We will go step by step here since this part may get a bit tricky. We will have to deal with a lot of math calculations for our boundaries as well as lots and lots of new variables. Let's start by declaring some variables in our <kbd>GameView.java</kbd> file. </p>
<p>Throughout this part, we will be working only in our <kbd>GameView.java</kbd> file.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating the variables required</h1>
            </header>

            <article>
                
<p>Here are the new variables that we will declare:</p>
<pre>
<span>private </span>ArrayList&lt;UpperBoundary&gt; <span>upperBoundary</span>;<br/><span>private </span>ArrayList&lt;LowerBoundary&gt; <span>lowerBoundary</span>;<br/><br/><span>private int </span><span>maxBoundaryHeight</span>;<br/><span>private int </span><span>minBoundaryHeight</span>;<br/><br/><span>private boolean </span><span>upBound </span>= <span>true</span>;<br/><span>private boolean </span><span>lowBound </span>= <span>true</span>;<br/><br/><span>private int </span><span>progressDenom </span>= <span>20</span>;<br/><br/><span>private boolean </span><span>newGameCreated</span>;
</pre>
<p>We create our <kbd>upperBoundary</kbd> and <kbd>lowerBoundary</kbd> variables as <kbd>ArrayList</kbd> to keep a track of our actual game object on the screen, then we also create two integer variables--<kbd>maxBoundaryHeight</kbd> and <kbd>minBoundaryHeight</kbd>--to keep a track of the maximum and minimum heights for our upper boundary. We also create two Boolean variables--<kbd>upBound</kbd> and <kbd>lowBound</kbd>--if our boundaries go out of our specified minimum or maximum height. The <kbd>progressDenom</kbd> variable is created as an integer in order to create a cool pattern for our ground rather than just being plane. Finally, we have a <kbd>newGameCreated</kbd> Boolean variable, which will reset our game automatically if our player crashes with any object.</p>
<p>We are set with our variables. We will now move on to referencing our boundaries when the game is started.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Referencing our boundaries</h1>
            </header>

            <article>
                
<p>Just as we assigned a value to our reference in our rocks, we will do the same for both our boundaries. We will do so in our <kbd>surfaceCreated()</kbd> method by adding the variables marked in bold: </p>
<pre>
<span>    @Override<br/></span><span>    public void </span>surfaceCreated(SurfaceHolder holder){<br/><strong>upperBoundary = new ArrayList&lt;UpperBoundary&gt;();<br/></strong><strong>    lowerBoundary = new ArrayList&lt;LowerBoundary&gt;();</strong><br/>    }
</pre>
<p>Looks neat! Now comes the tricky part. We will have to write the update logic for both our boundaries. Don't confuse this with the <kbd>update()</kbd> method in our individual boundaries. That update method will simply make our ground move backward. We will also need to actually write the logic to spawn them on screen. Let's see how to do that.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Updating our boundaries</h1>
            </header>

            <article>
                
<p>We will be updating our upper boundaries on every 50th score and lower boundaries on every 40th score. Let's write the code for our boundaries. This involves a lot of tricky mathematical calculations, so watch out. However, contradictory to that, every step is quite self-explanatory here. Here's the base logic for our boundaries:</p>
<ol>
<li>Update on every 50th or 40th score</li>
<li>Add our image onto the screen</li>
<li>After every frame, call the <kbd>update()</kbd> method in our boundary class</li>
<li>If the boundary goes out of screen, then remove it</li>
<li>If either of the boundary exceeds its maximum or minimum value, then accordingly set its <kbd>upBound</kbd> or <kbd>lowBound</kbd> variable to either <kbd>true</kbd> or <kbd>false</kbd>, depending on its position</li>
</ol>
<p>This is the logic for our boundaries, and the same is repeated for both our upper and lower boundaries. This code block is written after our <kbd>draw()</kbd> method. We write the code for them as follows: </p>
<pre>
<span>public void </span>updateUpperBound () {<br/><span>    if</span>(<span>playerCharacter</span>.getScore() % <span>50 </span>== <span>0</span>){<br/><span>        upperBoundary</span>.add(<span>new<br/></span>        UpperBoundary(BitmapFactory.<span>decodeResource<br/></span>        (getResources(), R.drawable.<span>ground</span>),<br/><span>        upperBoundary</span>.get(<span>upperBoundary</span>.size()-<span>1</span>).<br/>        getXC() + <span>20</span>, <span>0</span>, (<span>int</span>)((<span>rnd</span>.nextDouble()*<br/>        (<span>maxBoundaryHeight</span>))+<span>1</span>)));<br/>    }<br/><span><br/>    for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>upperBoundary</span>.size();i++) {<br/><span>        upperBoundary</span>.get(i).update();<br/><span>        if</span>(<span>upperBoundary</span>.get(i).getXC() &lt; -<span>20</span>){<br/><span>            upperBoundary</span>.remove(i);<br/><br/><span><br/>            if</span>(<span>upperBoundary</span>.get(<span>upperBoundary</span>.size()-<span>1</span>).<br/>            getHeight() &gt;= <span>maxBoundaryHeight</span>) {<br/><span>                upBound </span>= <span>false</span>;<br/>            }<br/><br/><br/><span>            if</span>(<span>upperBoundary</span>.get(<span>upperBoundary</span>.size()-<span>1</span>).<br/>            getHeight() &lt;= <span>minBoundaryHeight</span>) {<br/><span>                upBound </span>= <span>true</span>;<br/>            }<br/><span><br/>            if</span>(<span>upBound</span>){<br/><span>                upperBoundary</span>.add(<span>new <br/></span>                UpperBoundary(BitmapFactory.<span>decodeResource<br/></span>                (getResources(), R.drawable.<span>ground</span>),<br/><span>                upperBoundary</span>.get(<span>upperBoundary</span>.size()-<span>1</span>).<br/>                getXC() + <span>20</span>, <span>0</span>,<span>upperBoundary</span>.get<br/>                (<span>upperBoundary</span>.size()-<span>1</span>).getHeight()+<span>1</span>));<br/>            } <span>else </span>{<br/><span>                upperBoundary</span>.add(<span>new <br/></span>                UpperBoundary(BitmapFactory.<span>decodeResource<br/></span>                (getResources(), R.drawable.<span>ground</span>),<br/><span>                upperBoundary</span>.get(<span>upperBoundary</span>.size()-<span>1</span>).<br/>                getXC() + <span>20</span>, <span>0</span>, <span>upperBoundary</span>.get<br/>                (<span>upperBoundary</span>.size()-<span>1</span>).getHeight()-<span>1</span>));<br/>            }<br/>        }<br/>    }<br/>}<br/><span><br/>public void </span>updateLowerBound () {<br/><span>    if</span>(<span>playerCharacter</span>.getScore() % <span>40 </span>== <span>0</span>) {<br/><span>        lowerBoundary</span>.add(<span>new<br/></span>        LowerBoundary(BitmapFactory.<span>decodeResource<br/></span>        (getResources(),R.drawable.<span>ground</span>),<br/><span>        lowerBoundary</span>.get(<span>lowerBoundary</span>.size() - <span>1</span>).<br/>        getXC() + <span>20</span>,(<span>int</span>)((<span>rnd</span>.nextDouble()*<br/><span>        maxBoundaryHeight</span>) + (<span>HEIGHT </span>- <span>maxBoundaryHeight</span>))));<br/>    }<br/><span><br/>    for</span>(<span>int </span>i=<span>0</span>;i&lt;<span>lowerBoundary</span>.size();i++) {<br/><span>        lowerBoundary</span>.get(i).update();<br/><span><br/>        if</span>(<span>lowerBoundary</span>.get(i).getXC()&lt;-<span>20</span>){<br/><span>            lowerBoundary</span>.remove(i);<br/><span><br/>            if</span>(<span>lowerBoundary</span>.get(<span>lowerBoundary</span>.size()-<span>1</span>).<br/>            getHeight() &gt;= <span>maxBoundaryHeight</span>) {<br/><span>                lowBound </span>= <span>false</span>;<br/>            }<br/><br/><br/><span>            if</span>(<span>lowerBoundary</span>.get(<span>lowerBoundary</span>.size()-<span>1</span>).<br/>            getHeight() &lt;= <span>minBoundaryHeight</span>) {<br/><span>                lowBound </span>= <span>true</span>;<br/>            }<br/><span><br/>            if</span>(<span>lowBound</span>) {<br/><span>                lowerBoundary</span>.add(<span>new<br/></span>                LowerBoundary(BitmapFactory.<span>decodeResource<br/></span>                (getResources(),R.drawable.<span>ground</span>), <br/><span>                lowerBoundary</span>.get(<span>lowerBoundary</span>.size() - <span>1</span>).<br/>                getXC() + <span>20</span>, <span>lowerBoundary</span>.<br/>                get(<span>lowerBoundary</span>.size() - <span>1</span>).getYC() + <span>1</span>));<br/>            } <span>else </span>{<br/><span>                lowerBoundary</span>.add(<span>new<br/></span>                LowerBoundary(BitmapFactory.<span>decodeResource<br/></span>                (getResources(),R.drawable.<span>ground</span>),<br/><span>                lowerBoundary</span>.get(<span>lowerBoundary</span>.size() - <span>1</span>).<br/>                getXC() + <span>20</span>, <span>lowerBoundary</span>.<br/>                get(<span>lowerBoundary</span>.size() - <span>1</span>).getYC() - <span>1</span>));<br/>            }<br/>        }<br/>    }<br/>}
</pre>
<p>Now, we have to actually draw our boundaries on our screen, so we will go to our <kbd>draw()</kbd> method to do so.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Drawing our boundaries on the screen</h1>
            </header>

            <article>
                
<p>As with our previous images, we use the <kbd>draw()</kbd> method to write our code for displaying our ground on the screen:</p>
<pre>
<span>for</span>(UpperBoundary ub : <span>upperBoundary</span>){<br/>    ub.draw(canvas);<br/>}<br/><br/><span>for</span>(LowerBoundary lb: <span>lowerBoundary</span>) {<br/>    lb.draw(canvas);<br/>}
</pre>
<p>Even this part is taken care of for now. Now, we have to look at the collision part of our ground. We need to detect a collision on our ground with the player. </p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Detecting a collision between the ground and player</h1>
            </header>

            <article>
                
<p>Since we have already created our collision method, we simply go ahead and use the function. We already have a clear understanding of how a collision works because of the previous chapter, so we write the following code in our <kbd>update()</kbd> method of our <kbd>GameView.java</kbd> file:</p>
<pre>
<span>for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>lowerBoundary</span>.size();i++) {<br/><span>    if</span>(collision(<span>lowerBoundary</span>.get(i),<span>playerCharacter</span>)) {<br/><span>        playerCharacter</span>.setPlaying(<span>false</span>);<br/>    }<br/>}<br/><br/><span>for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>upperBoundary</span>.size();i++) {<br/><span>    if</span>(collision(<span>upperBoundary</span>.get(i),<span>playerCharacter</span>)) {<br/><span>        playerCharacter</span>.setPlaying(<span>false</span>);<br/>    }<br/>}
</pre>
<p>Collision detection between the player and the ground is completed. Now, we also have to assign our maximum and minimum boundary heights as well as tweak them as per our <kbd>progressDenom</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Maximum and minimum boundary heights</h1>
            </header>

            <article>
                
<p>In our <kbd>update()</kbd> method, we will assign these values based on the player score and <kbd>progressDenom</kbd>. We will also use this method to call our <kbd>updateUpperBound()</kbd> and <kbd>updateLowerBound()</kbd> methods that we created earlier in this chapter:</p>
<pre>
<span>this</span>.updateUpperBound();<br/><span>this</span>.updateLowerBound();<br/><br/><span>maxBoundaryHeight</span> = <span>30</span>+<span>playerCharacter</span>.getScore() / <span>progressDenom</span>;<br/><br/><span>if</span>(<span>maxBoundaryHeight</span> &gt; <span>HEIGHT</span>/<span>4</span>)<span>maxBoundaryHeight</span> = <span>HEIGHT</span>/<span>4</span>;<br/><span>minBoundaryHeight </span>= <span>5 </span>+ <span>playerCharacter</span>.getScore()/<span>progressDenom</span>;
</pre>
<p>We're almost there. Now, the only thing remaining to create is our <kbd>newGame()</kbd> function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a new game</h1>
            </header>

            <article>
                
<p>We will create a <kbd>newGame()</kbd> function that will get called every time the player crashes with an object. We're doing nothing, but just resetting our objects as they were initially when we started the game. So, here's how we do it:</p>
<pre>
<span>public void </span>newGame () {<br/><span>    lowerBoundary</span>.clear();<br/><span>    upperBoundary</span>.clear();<br/><span>    rocks</span>.clear();<br/><span><br/>    minBoundaryHeight </span>= <span>5</span>;<br/><span>    maxBoundaryHeight </span>= <span>30</span>;<br/><span><br/>    playerCharacter</span>.resetScore();<br/><span>    playerCharacter</span>.resetDYC();<br/><span>    playerCharacter</span>.setYC(<span>HEIGHT</span>/<span>2</span>);<br/><span><br/>    for</span>(<span>int </span>i = <span>0</span>; i * <span>20 </span>&lt; <span>WIDTH </span>+ <span>40</span>;i++) {<br/><span>        if</span>(i == <span>0</span>) {<br/><span>            upperBoundary</span>.add(<span>new<br/></span>            UpperBoundary(BitmapFactory.<span>decodeResource<br/></span>            (getResources(),R.drawable.<span>ground</span>),<br/>            i * <span>20</span>, <span>0</span>, <span>10</span>));<br/>        } <span>else </span>{<br/><span>            upperBoundary</span>.add(<span>new<br/></span>            UpperBoundary(BitmapFactory.<span>decodeResource<br/></span>            (getResources(),R.drawable.<span>ground</span>),<br/>            i * <span>20</span>, <span>0</span>, <span>upperBoundary</span>.get(i - <span>1</span>).getHeight() + <span>1</span>));<br/>         }<br/>    }<br/><span><br/>    for</span>(<span>int </span>i = <span>0</span>; i*<span>20</span>&lt;<span>WIDTH</span>+<span>40</span>;i++) {<br/><span>        if</span>(i==<span>0</span>) {<br/><span>            lowerBoundary</span>.add(<span>new <br/></span>            LowerBoundary(BitmapFactory.<span>decodeResource<br/></span>            (getResources(),R.drawable.<span>ground</span>),<br/>            i * <span>20</span>, <span>HEIGHT </span>- <span>minBoundaryHeight</span>));<br/>        } <span>else </span>{<br/><span>            lowerBoundary</span>.add(<span>new <br/></span>            LowerBoundary(BitmapFactory.<span>decodeResource<br/></span>            (getResources(),R.drawable.<span>ground</span>),<br/>            i * <span>20</span>, <span>lowerBoundary</span>.get(i - <span>1</span>).getYC() - <span>1</span>));<br/>        }<br/>    }<br/><span>    newGameCreated </span>= <span>true</span>;<br/>}
</pre>
<p>Also, we still have to call this function from somewhere. As per our objective, we need it to be called after our player crashes. So, we add an else block in our update function after our <kbd><span>if</span>(<span>playerCharacter</span>.getPlaying())</kbd> <span>condition, as follows:</span></p>
<pre>
 <span>else </span>{<br/><span>    newGameCreated </span>= <span>false</span>;<br/><span>    if</span>(!<span>newGameCreated</span>) {<br/>        newGame();<br/>    }<br/>}
</pre>
<p>We're ready with our code. Let's review our code for changes marked in bold and check whether you missed any step:</p>
<pre>
<span>package </span>nikhil.nikmlnkr.game;<br/><br/><span>import </span>android.content.Context;<br/><span>import </span>android.graphics.Bitmap;<br/><span>import </span>android.graphics.BitmapFactory;<br/><span>import </span>android.graphics.Canvas;<br/><span>import </span>android.graphics.Rect;<br/><span>import </span>android.view.MotionEvent;<br/><span>import </span>android.view.SurfaceHolder;<br/><span>import </span>android.view.SurfaceView;<br/><br/><span>import </span>java.util.ArrayList;<br/><span>import </span>java.util.Random;<br/><br/><br/><span>public class </span>GameView <span>extends </span>SurfaceView <span>implements </span>SurfaceHolder.Callback<br/>{<br/><span>    public static final int </span><span>WIDTH </span>= <span>1920</span>;<br/><span>    public static final int </span><span>HEIGHT </span>= <span>1080</span>;<br/><span>    public static final int </span><span>MOVINGSPEED </span>= -<span>5</span>;<br/><span>    private </span>MainGameThread <span>mainThread</span>;<br/><span>    private </span>BackgroundImage <span>bgImg</span>;<br/><span>    private </span>PlayerCharacter <span>playerCharacter</span>;<br/><span>    private </span>ArrayList&lt;Rock&gt; <span>rocks</span>;<br/><strong>    //Our new variable names<br/>    private ArrayList&lt;UpperBoundary&gt; upperBoundary;<br/></strong><strong>    private ArrayList&lt;LowerBoundary&gt; lowerBoundary;</strong><br/><strong><br/>    private int maxBoundaryHeight;<br/></strong><strong>    private int minBoundaryHeight;</strong><br/><strong><br/>    private boolean upBound = true;<br/></strong><strong>    private boolean lowBound = true;</strong><br/><strong><br/>    private int progressDenom = 20;</strong><br/><span><br/>    private boolean </span><span>newGameCreated</span>;<br/><span><br/>    private </span>Random <span>rnd </span>= <span>new </span>Random();<br/><span><br/>    public </span>GameView(Context context){<br/><span>        super</span>(context);<br/><span>        //set callback to the surfaceholder to track events<br/></span>        getHolder().addCallback(<span>this</span>);<br/><span><br/>        mainThread </span>= <span>new </span>MainGameThread(getHolder(), <span>this</span>);<br/><span><br/>        //make gamePanel focusable so it can handle events<br/></span>        setFocusable(<span>true</span>);<br/>    }<br/><span><br/>    @Override<br/></span><span>    public void </span>surfaceChanged(SurfaceHolder holder, <span>int </span>format, <span>int </span>width, <span>int </span>height){}<br/><span><br/>    @Override<br/></span><span>    public void </span>surfaceDestroyed(SurfaceHolder holder){<br/><span>        boolean </span>retry = <span>true</span>;<br/><span>        int </span>counter = <span>0</span>;<br/><span>        while</span>(retry &amp;&amp; counter &lt;<span>1000</span>){<br/>            counter++;<br/><span>            try</span>{<br/><span>                mainThread</span>.setRunning(<span>false</span>);<br/><span>                mainThread</span>.join();<br/>                retry = <span>false</span>;<br/>            }<span>catch</span>(InterruptedException e){e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/><span><br/>    @Override<br/></span><span>    public void </span>surfaceCreated(SurfaceHolder holder){<br/><span><br/>        bgImg </span>= <span>new <br/></span>        BackgroundImage(BitmapFactory.<span>decodeResource<br/></span>        (getResources(), R.drawable.<span>background_image</span>));<br/><span><br/>        playerCharacter </span>= <span>new <br/></span>        PlayerCharacter(BitmapFactory.<span>decodeResource<br/></span>        (getResources(),R.drawable.<span>player_run</span>),<span>200</span>,<span>246</span>,<span>3</span>);<br/><br/><span>        rocks </span>= <span>new </span>ArrayList&lt;Rock&gt;();<br/><strong>        //Referencing our upperBoundary and lowerBoundary variables<br/></strong><strong>        upperBoundary = new ArrayList&lt;UpperBoundary&gt;();<br/></strong><strong>        lowerBoundary = new ArrayList&lt;LowerBoundary&gt;();</strong><br/><span><br/>         //we can safely start the game loop<br/></span><span>         mainThread</span>.setRunning(<span>true</span>);<br/><span>         mainThread</span>.start();<br/>    }<br/><span>    @Override<br/></span><span>    public boolean </span>onTouchEvent(MotionEvent event){<br/><span>        if</span>(event.getAction() == MotionEvent.<span>ACTION_DOWN</span>) {<br/><span>            if</span>(!<span>playerCharacter</span>.getPlaying()){<br/><span>                playerCharacter</span>.setPlaying(<span>true</span>);<br/><strong>                playerCharacter.setUp(true); //minor change<br/></strong>            } <span>else </span>{<br/><span>                playerCharacter</span>.setUp(<span>true</span>);<br/>            }<br/><span>            return true</span>;<br/>        }<br/><span><br/>        if</span>(event.getAction() == MotionEvent.<span>ACTION_UP</span>){<br/><span>            playerCharacter</span>.setUp(<span>false</span>);<br/><span>            return true</span>;<br/>        }<br/><span><br/>        return super</span>.onTouchEvent(event);<br/>    }<br/><span><br/>    public void </span>update()<br/>    {<br/><span>        if</span>(<span>playerCharacter</span>.getPlaying()) {<br/><span>            bgImg</span>.update();<br/><span>            playerCharacter</span>.update();<br/><strong><br/>            this.updateUpperBound();<br/></strong><strong>            this.updateLowerBound();</strong><br/><strong><br/>            maxBoundaryHeight = <br/>            30 + playerCharacter.getScore() / progressDenom;</strong><br/><strong><br/>            if(maxBoundaryHeight &gt; HEIGHT/4)<br/>                maxBoundaryHeight = HEIGHT/4;</strong><br/><strong><br/>            minBoundaryHeight = <br/>            5 + playerCharacter.getScore()/progressDenom;</strong><br/><strong>            <br/>            for(int i=0; i&lt;lowerBoundary.size();i++) {<br/></strong><strong>                if(collision(lowerBoundary.get(i),<br/>                playerCharacter)) {<br/></strong><strong>                    playerCharacter.setPlaying(false);<br/></strong><strong>                }<br/></strong><strong>            }</strong><br/><strong><br/>            for(int i=0; i&lt;upperBoundary.size();i++) {<br/></strong><strong>                if(collision(upperBoundary.get(i),<br/>                playerCharacter)) {<br/></strong><strong>                    playerCharacter.setPlaying(false);<br/></strong><strong>                }<br/></strong><strong>            }</strong><br/><span><br/>            //spawn rocks on screen<br/></span><span>            if</span>(<span>rocks</span>.size() &lt; <span>2</span>){<br/><span>                if</span>(<span>rocks</span>.size() == <span>0</span>){<br/><span>                    rocks</span>.add(<span>new<br/></span>                    Rock(BitmapFactory.<span>decodeResource<br/></span>                    (getResources(), R.drawable.<span>rock</span>), <br/><span>                    WIDTH </span>+ <span>10</span>, <span>HEIGHT</span>/<span>2</span>, <span>200</span>, <span>200</span>,<br/><span>                    playerCharacter</span>.getScore(),<span>3</span>));<br/>                } <span>else </span>{<br/><span>                    rocks</span>.add(<span>new<br/></span>                    Rock(BitmapFactory.<span>decodeResource<br/></span>                    (getResources(), R.drawable.<span>rock</span>), <br/><span>                    WIDTH</span>+<span>10</span>, (<span>int</span>) (<span>rnd</span>.nextDouble() *<br/>                    (<span>HEIGHT </span>- <span>maxBoundaryHeight </span>* <span>2</span>))<br/>                    + <span>maxBoundaryHeight</span>, <span>200</span>, <span>200</span>,<br/><span>                    playerCharacter</span>.getScore(),<span>3</span>));<br/>                }<br/>            }<br/><span><br/>            for</span>(<span>int </span>i=<span>0</span>; i&lt;<span>rocks</span>.size();i++) {<br/><span>                rocks</span>.get(i).update();<br/><span>                if</span>(collision(<span>rocks</span>.get(i),<span>playerCharacter</span>)) {<br/><span>                    rocks</span>.remove(i);<br/><span>                    playerCharacter</span>.setPlaying(<span>false</span>);<br/><span>                    break</span>;<br/>                }<br/><span>                //remove rocks if they go out of the screen<br/></span><span>                if</span>(<span>rocks</span>.get(i).getXC() &lt; -<span>100</span>) {<br/><span>                    rocks</span>.remove(i);<br/><span>                    break</span>;<br/>                }<br/><br/>            }<br/>        }<strong> else {<br/>            //We created an else block to trigger our newGameCreated <br/>            variable and to set a new game<br/></strong><strong>            newGameCreated = false;<br/></strong><strong>            if(!newGameCreated) {<br/></strong><strong>                newGame();<br/></strong><strong>            }<br/></strong>        }<br/>    }<br/><span><br/>    public boolean </span>collision(GameObj a, GameObj b) {<br/><span>        if</span>(Rect.<span>intersects</span>(a.getRectangle(), b.getRectangle())) {<br/><span>            return true</span>;<br/>        }<br/><span>        return false</span>;<br/>    }<br/><span><br/>    @Override<br/></span><span>    public void </span>draw(Canvas canvas){<br/><span>        final float </span>scaleFactorX = getWidth()/<span>WIDTH</span>;<br/><span>        final float </span>scaleFactorY = getHeight()/<span>HEIGHT</span>;<br/><span>        if</span>(canvas != <span>null</span>) {<br/><span>            final int </span>savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/><span>            bgImg</span>.draw(canvas);<br/><span>            playerCharacter</span>.draw(canvas);<br/><span><br/>            for</span>(Rock r : <span>rocks</span>) {<br/>                r.draw(canvas);<br/>            }<br/><strong>            //Drawing our upperBoundary<br/></strong><strong>            for(UpperBoundary ub : upperBoundary){<br/></strong><strong>                ub.draw(canvas);<br/></strong><strong>            }<br/></strong><strong>            //Drawing our lowerBoundary<br/></strong><strong>            for(LowerBoundary lb: lowerBoundary) {<br/></strong><strong>                lb.draw(canvas);<br/></strong><strong>            }</strong><br/><br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/><strong><br/>    public void updateUpperBound () {<br/>        //Refer code block above<br/></strong><strong>    }</strong><br/><strong><br/>    public void updateLowerBound () {<br/>        //Refer</strong><strong> code block above for this<br/></strong><strong>    }</strong><br/><strong><br/>    public void newGame () {<br/>        //Refer code block in above part<br/></strong>    }
</pre>
<p>Now, build and run your game; we have our boundaries ready!:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/B05066_07_02.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Our player won't fall down infinitely now</div>
<p>We can now proceed to our next part of creating explosions on our screen.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating explosions</h1>
            </header>

            <article>
                
<p>We're almost done with our game here, and only the following two parts are remaining:</p>
<ul>
<li>Adding particle effects of an explosion</li>
<li>Displaying our score on the screen</li>
</ul>
<p>We will divide this part into two sections wherein we will finish half of our explosions in this chapter, and the further half will be completed along with the UI of our game that will then conclude this game. So, let's get started with this now. For our explosion, we will be needing a sprite sheet. We will use the following sprite sheet for our game:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="392" src="assets/B05066_07_03.png" width="392"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Our explosion sprite sheet</div>
<p>We will create a new class named <kbd>ExplosionEffect.java</kbd>. Note here that we will not be extending this file to our <kbd>GameObj</kbd> file since we don't need any of the collision components of this image. We will simply spawn it on the screen and make it stay at the same place. So, open up your <kbd>ExplosionEffect.java</kbd> file and let's define our variables first:</p>
<pre>
<span>private int </span><span>xc</span>;<br/><span>private int </span><span>yc</span>;<br/><span>private int </span><span>height</span>;<br/><span>private int </span><span>width</span>;<br/><span>private int </span><span>row</span>;<br/><span>private </span>AnimationClass <span>ac </span>= <span>new </span>AnimationClass();<br/><span>private </span>Bitmap <span>spriteSheet</span>;
</pre>
<p>As you can see, we just need the <kbd>x</kbd>, <kbd>y</kbd> coordinates and the <kbd>height</kbd> and <kbd>width</kbd> as integer values. Also, observe here that we will be working with both rows and columns in this sprite sheet as opposed to our previous sprites where we just used a singular row or column and hence we will need an extra variable <kbd>row</kbd> to help us out with this problem. We need our <kbd>AnimationClass</kbd> variable in order to run our animation and, last but not the least, our <kbd>Bitmap spriteSheet</kbd> variable.</p>
<p>After this, we will define the constructor for our class as follows:</p>
<pre>
<span>public </span>ExplosionEffect(Bitmap res, <span>int </span>xc, <span>int </span>yc, <span>int </span>w, <span>int </span>h, <span>int </span>noOfFrames){<br/><span>    this</span>.<span>xc </span>= xc;<br/><span>    this</span>.<span>yc </span>= yc;<br/><span>    this</span>.<span>width </span>= w;<br/><span>    this</span>.<span>height </span>= h;<br/><br/>    Bitmap[] img = <span>new </span>Bitmap[noOfFrames];<br/><span><br/>    spriteSheet </span>= res;<br/><span><br/>    for</span>(<span>int </span>i = <span>0</span>; i &lt; img.<span>length</span>; i++) {<br/><span>        if</span>(i % <span>5 </span>== <span>0 </span>&amp;&amp; i &gt; <span>0</span>)<br/><span>            row</span>++;<br/>        img[i] = Bitmap.<span>createBitmap<br/></span>        (<span>spriteSheet</span>, (i - (<span>5 </span>* <span>row</span>)) * <span>width</span>, <span>row </span>* <span>height</span>,<br/><span>        width</span>, <span>height</span>);<br/>    }<br/><span>    ac</span>.setFrames(img);<br/><span>    ac</span>.setDelay(<span>10</span>);<br/>}
</pre>
<p>If you observe this closely, you will see that we are simply repeating our steps that we did for our previous game objects, except that we have an extra <kbd>row</kbd> variable here that we defined earlier, and this will help us scan through the rows of our sprite sheet.</p>
<p>Now, we are left with the <kbd>draw()</kbd> and <kbd>update()</kbd> methods for this class. We will also make a method to <kbd>getHeight()</kbd> of the sprite sheet in order for us to work on our calculations when we use this to actually spawn our explosion effects:</p>
<pre>
<span>public void </span>draw(Canvas canvas) {<br/><span>    if</span>(!<span>ac</span>.playedOnce()){<br/>        canvas.drawBitmap(<span>ac</span>.getImage(),<span>xc</span>,<span>yc</span>,<span>null</span>);<br/>    }<br/>}<br/><br/><span>public void </span>update() {<br/><span>    if</span>(!<span>ac</span>.playedOnce()){<br/><span>        ac</span>.update();<br/>    }<br/>}<br/><br/><span>public int </span>getHeight() {<br/><span>    return </span><span>height</span>;<br/>}
</pre>
<p>Once you are done with these, ensure that your <kbd>ExplosionEffect.java</kbd> file looks like this:</p>
<pre>
<span>public class </span>ExplosionEffect {<br/><br/>    //refer variables created above<br/><span>    public </span>ExplosionEffect(Bitmap res, <span>int </span>xc, <span>int </span>yc, <span>int </span>w, <span>int </span>h, <span>int </span>noOfFrames){<br/><span>        this</span>.<span>xc </span>= xc;<br/><span>        this</span>.<span>yc </span>= yc;<br/><span>        this</span>.<span>width </span>= w;<br/><span>        this</span>.<span>height </span>= h;<br/><br/>        Bitmap[] img = <span>new </span>Bitmap[noOfFrames];<br/><span><br/>        spriteSheet </span>= res;<br/><span><br/>        for</span>(<span>int </span>i = <span>0</span>; i &lt; img.<span>length</span>; i++) {<br/><span>            if</span>(i % <span>5 </span>== <span>0 </span>&amp;&amp; i &gt; <span>0</span>)<br/><span>                row</span>++;<br/>            img[i] = Bitmap.<span>createBitmap<br/></span>            (<span>spriteSheet</span>, (i - (<span>5 </span>* <span>row</span>)) * <span>width</span>, <span>row </span>* <span>height</span>,<br/><span>width</span>, <span>height</span>);<br/>        }<br/><span>        ac</span>.setFrames(img);<br/><span>        ac</span>.setDelay(<span>10</span>);<br/>    }<br/><span><br/>    public void </span>draw(Canvas canvas) {<br/><span>        if</span>(!<span>ac</span>.playedOnce()){<br/>            canvas.drawBitmap(<span>ac</span>.getImage(),<span>xc</span>,<span>yc</span>,<span>null</span>);<br/>        }<br/>    }<br/><span><br/>    public void </span>update() {<br/><span>        if</span>(!<span>ac</span>.playedOnce()){<br/><span>            ac</span>.update();<br/>        }<br/>    }<br/><span><br/>    public int </span>getHeight() {<br/><span>        return </span><span>height</span>;<br/>    }<br/>}
</pre>
<p>We are all set with our <kbd>ExplosionEffect.java</kbd> file; that's it for this chapter. We are ready with our class for our explosion, and we will start creating explosion effects on our screen after our rocks collide with our player in the next chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>We learned how to create boundaries for our game and also created our explosion effect file with the required components needed along with its constructor. </p>
<p>We now have a proper upper and lower boundary in our game and we also have created our foundation for adding explosions in our game after our player collides with rocks. </p>
<p>In the next chapter, we will spawn the explosion on the screen after our player collides with the rock and display our score on the screen as a User Interface component.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>