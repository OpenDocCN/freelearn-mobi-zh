<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Audio and Parallax Effect</h1></div></div></div><p>Adding background music and sound effects in SpriteKit is very easy, as it is just a one-line code that you need to call. There are a few important things that need to be considered while adding the effects; for example, will the scene change after asking SpriteKit to play a sound? And what format should be used for the sound file?</p><p>In this chapter, we will be adding background music to the game and sound effects for the moments when the rocket gets fired, the enemy gets hit by a rocket, a button on the screen is pressed, and the game ends. We will also look at a free application that can be used to convert a sound file from one format to the other. In the end, we will add a nice scrolling effect to the background, for extra fun.</p><p>Here are the topics that are covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Audio file formats</li><li class="listitem" style="list-style-type: disc">Downloading and installing Audacity</li><li class="listitem" style="list-style-type: disc">Converting the audio format</li><li class="listitem" style="list-style-type: disc">Adding sound effects</li><li class="listitem" style="list-style-type: disc">Adding background music</li><li class="listitem" style="list-style-type: disc">Parallax background—theory</li><li class="listitem" style="list-style-type: disc">Implementing the parallax effect</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Audio file formats</h1></div></div></div><p>SpriteKit allows us to use<a id="id482" class="indexterm"/> the OSX standard <code class="literal">.caf</code> audio file format, but it also supports <code class="literal">.mp3</code> files. In theory, you can use any of these formats to play audio or effects in the game. All you will need to do is change the name of the file called when asking SpriteKit to play the file. But for the sake of optimization, we will be using an <code class="literal">.mp3</code> file format. The reason is that <code class="literal">.mp3 </code>files are a lot smaller in size compared to <code class="literal">.caf</code> files. Take the example of the background music file, for instance; the <code class="literal">.caf</code> file size is 5.2 megabytes, compared to the <code class="literal">.mp3</code> file, which is just 475 kilobytes—roughly 10 times less than a <code class="literal">.caf</code> file, and the player experience won't be any different.</p><p>The more audio files you add, the more it will add to the bundle size, which will drastically increase the size of the game and take longer for the player to download and play the game. For a small game, such as ours, it might not matter much, but when you start making bigger games with more sound effects and background music, this is something to keep in mind.</p><p>Although <code class="literal">.mp3</code> is a very popular <a id="id483" class="indexterm"/>format, there might be times when you will need to convert audio file formats to <code class="literal">.mp3</code>. In the next section, we will see exactly how to do this.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Downloading and installing Audacity</h1></div></div></div><p>Audacity is a free <a id="id484" class="indexterm"/>cross-platform audio recording and editing software. You can download the <a id="id485" class="indexterm"/>latest version from <a class="ulink" href="http://audacity.sourceforge.net/">http://audacity.sourceforge.net/</a>. Although Version 2.06 says it is for<a id="id486" class="indexterm"/> Mac OS X 10.4 to 10.9.x, it will <a id="id487" class="indexterm"/>also work for Yosemite.</p><div><img src="img/B04014_06_01.jpg" alt="Downloading and installing Audacity"/></div><p>Download the DMG file, double-click on it, and drag the Audacity folder into your <strong>Applications</strong> directory. From the launch pad, click on the <strong>Audacity</strong> application to open it.</p><div><img src="img/B04014_06_02.jpg" alt="Downloading and installing Audacity"/></div><p>You can click <a id="id488" class="indexterm"/>on the <strong>Quick Help</strong>, <strong>Manual</strong>, <strong>Wiki</strong>, and <strong>Forum</strong> links to understand<a id="id489" class="indexterm"/> more about the software and its features. Click on <strong>OK</strong> to continue.</p><p>I am not a sound engineer, so I am really not the right person to tell you or explain what each of the headings does. All I can really say is that if you know a thing or two about sound programming or engineering, you can really do magic with this free and open source application. For example, we can reduce the size of a file by lowering the frequency of a file from 44 kHz to 22 kHz, as shown in the following screenshot, or reduce the format from two channels or stereo to mono.</p><p>To change the frequency, click on the<a id="id490" class="indexterm"/> down arrow next to the name of the file, select <strong>Set Rate</strong>, and <a id="id491" class="indexterm"/>choose <strong>22050 Hz</strong> instead of <strong>44100 Hz</strong>:</p><div><img src="img/B04014_06_03.jpg" alt="Downloading and installing Audacity"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Converting the audio format</h1></div></div></div><p>To convert the format to <a id="id492" class="indexterm"/>MP3, navigate to <strong>File</strong> | <strong>Import</strong> | <strong>Audio</strong>. In the <code class="literal">Resources</code> folder for this chapter, you will find a folder called <code class="literal">Game Audio Files</code>. Inside this folder, there is another folder called <code class="literal">caf</code>. Within this folder, you will have all the audio files in the <code class="literal">.caf</code> format. Select all the files in the folder and click on <strong>Open</strong>. Now all the files will be imported to the current project.</p><div><img src="img/B04014_06_04.jpg" alt="Converting the audio format"/></div><p>Once all the files are imported, to convert them to MP3 files, you will need to install the lame library <a id="id493" class="indexterm"/>from <a class="ulink" href="http://lame.buanzo.org/#lameosxdl">http://lame.buanzo.org/#lameosxdl</a>. I know it has a very corny name, but it really works. Download the first link, which says <strong>For Audacity 1.3.3 or Later</strong>. Download the DMG file, open the package, and install it.</p><div><img src="img/B04014_06_05.jpg" alt="Converting the audio format"/></div><p>Now go back to <a id="id494" class="indexterm"/>Audacity and navigate to <strong>File</strong> | <strong>Export Multiple</strong>. The following window will open:</p><div><img src="img/B04014_06_06.jpg" alt="Converting the audio format"/></div><p>In the window that opens, select the format as <strong>MP3 Files</strong>. For the export location, I created a new folder called <code class="literal">mp3</code> in the <code class="literal">Game Audio Files</code> folder. For the name of the file, select the first choice so that it will keep the same label name as the file we are giving it. You can check or uncheck the <strong>Overwrite existing Files</strong> box as per your preference.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Keep in mind that if you check this box, all the files with the same name with be overwritten in future, so be careful.</p></div></div><p>Click on <a id="id495" class="indexterm"/>
<strong>Export</strong> to start the process. Then click on <strong>OK</strong> for all the files that are getting exported. You will get a confirmation that all the files were converted successfully, like this:</p><div><img src="img/B04014_06_07.jpg" alt="Converting the audio format"/></div><p>Now, if you check out the <code class="literal">mp3</code> folder, you will see that all the files have been converted to the <code class="literal">.mp3</code> format.</p><div><img src="img/B04014_06_08.jpg" alt="Converting the audio format"/></div><p>With the files ready, we can add sound and effects to the game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Adding sound effects</h1></div></div></div><p>As I mentioned earlier, adding <a id="id496" class="indexterm"/>sounds and effects in SpriteKit is very simple. It is really one line of code that needs to be added to create the desired sound effect.</p><p>First, we will import all the files to the project. So, select all the <code class="literal">.mp3</code> files in the folder you created earlier, and drag them into the project.</p><div><img src="img/B04014_06_09.jpg" alt="Adding sound effects"/></div><p>Make sure that you check <strong>Copy items if needed</strong> and your project is selected as the target.</p><div><img src="img/B04014_06_10.jpg" alt="Adding sound effects"/></div><p>Also, make sure that the files <a id="id497" class="indexterm"/>exist under <strong>Copy Bundle Resources in the Build Phases</strong>, as the files sometimes don't get copied, even after you select the project as the target. If the files don't exist here, then you will get a build error saying the said file can't be found, even though the file exits in the project hierarchy. In that case, click on the <strong>+</strong> button and add the files.</p><div><img src="img/B04014_06_11.jpg" alt="Adding sound effects"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Adding the fireRocket sound effect</h2></div></div></div><p>Okay! With all the files<a id="id498" class="indexterm"/> imported, let's call the <code class="literal">fireRocket</code> <a id="id499" class="indexterm"/>sound effect whenever the hero fires a rocket. At the end of the <code class="literal">addRockets</code> function in the <code class="literal">GamePlayScene.swift</code> file, add the following line of code:</p><div><pre class="programlisting">let fireRocker = SKAction.playSoundFileNamed("fireRocket.mp3", waitForCompletion: false)

self.runAction(fireRocker)</pre></div><p>To play sounds, you will also use the <code class="literal">SKAction</code> class. The <code class="literal">SKAction</code> class has a property for playing sounds called <code class="literal">playSoundFileNamed</code>, and it takes two parameters. The first parameter is the name of the sound file, and the second is a Boolean value that determines the length of the action. If it is <code class="literal">true</code>, then the duration of the action is equal to the length of the audio track. Otherwise, it is understood that the action terminated immediately.</p><p>Notice that we have to provide the full name along with the extension when playing the sound. So, if you are using a <code class="literal">.caf</code> file in the project and you want to call the file, you must replace the extension accordingly.</p><p>If you build and run the game, you will hear the sound effect whenever you click on the right of the screen. Yes, it is really that easy!</p><p>Although this is easy, you <a id="id500" class="indexterm"/>might have noticed that the first <a id="id501" class="indexterm"/>time you fired the rocket, there was a bit of a delay between you tapping the screen and the sound file actually playing. This is because when the sound effect is called for the first time, the system has to fetch the file from the memory. The system has to do this for each of the files we will be calling. Once it has loaded initially, from the next time onwards, the file is already stored in the memory, so it is called instantaneously.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Adding the enemy-kill sound effect</h2></div></div></div><p>Next, we will add an effect that will occur <a id="id502" class="indexterm"/>whenever an enemy gets <a id="id503" class="indexterm"/>killed. So, in the <code class="literal">checkCollision</code> function, where we check for a collision between the player's rocket and the enemies, add the following code after the code by which we increase the score in the <code class="literal">GamePlayScene.swift</code> file:</p><div><pre class="programlisting">let enemySound = SKAction.playSoundFileNamed("enemyKill.mp3", waitForCompletion: false)

self.runAction(enemySound)</pre></div><p>And ta-da! The effect will start playing each time an enemy gets killed. You can run the action on the enemy or on the class itself by saying <code class="literal">self</code>; it doesn't really make any difference, as long you make sure you call the action on something, otherwise, the sound won't get played.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Adding a sound effect at GameOver</h2></div></div></div><p>Next, we will add a sound for <a id="id504" class="indexterm"/>when the game is over. So, in the <code class="literal">GameOver</code> function,<a id="id505" class="indexterm"/> add the line highlighted in the following code snippet after we removed action on the self and the hero. This is important because if you add it before, then the action will be removed immediately and you will be sitting there scratching your head, thinking that you did add the sound, but yet no sound is playing:</p><div><pre class="programlisting">//removing actions
self.removeAllActions()
        
for enemy in enemies{
            
     enemy._sprite.removeAllActions()
}
        
hero.removeAllActions()
        
        
<strong>//playing one last action</strong>
<strong>let gameOverSound = SKAction.playSoundFileNamed("gameOver.mp3", waitForCompletion: false)</strong>

<strong>self.runAction(gameOverSound)</strong>
</pre></div><p>Next, we will add a pop sound effect for whenever an on-screen button is pressed. So, in the <code class="literal">touchesbegan</code> function, where we check whether the <code class="literal">menuBtn</code> is pressed, we add the following code just before presenting the scene:</p><div><pre class="programlisting">let popSound = SKAction.playSoundFileNamed("pop.mp3", waitForCompletion: false)
self.runAction(popSound)</pre></div><p>Now, run the game and let it get over. When you press the home button, there is no sound. There is no sound!?!</p><p>Well, since the scene was changed as we moved from <code class="literal">GameplayScene</code> to <code class="literal">MainMenuScene</code>, the sound wasn't played.</p><p>A simple fix to this problem would be to call <code class="literal">MainMenuScene</code> after a small delay so that in the meantime, the sound will be played. To do this, create a function called <code class="literal">btnPressed</code> and copy and paste all of the code that calls <code class="literal">MainMenuScene</code> in it, as shown here:</p><div><pre class="programlisting">func btnPressed(){
        
   let scene = MainMenuScene(size: self.size);
   self.view?.presentScene(scene)
        
}</pre></div><p>Also, remove the following lines as they are already getting called in the <code class="literal">btnPressed</code> function:</p><div><pre class="programlisting">let scene = MainMenuScene(size: self.size)
self.view?.presentScene(scene)</pre></div><p>Then, right after where <a id="id506" class="indexterm"/>we call <code class="literal">popSound</code>, we add the following lines<a id="id507" class="indexterm"/> of code, in which we create <code class="literal">SKAction</code>. This will call the <code class="literal">btnPressed</code> function after a 1-second delay:</p><div><pre class="programlisting">let  buttonPressAction = SKAction.sequence(
[SKAction.runBlock(btnPressed),    SKAction.waitForDuration(1.0)])

self.runAction(buttonPressAction)</pre></div><p>If you press the home button now, the sound will be played, and after a second, the scene will change to <code class="literal">MainMenuScene</code>.</p><p>Similar to how you added <code class="literal">popSound</code> here, in <code class="literal">MainMenuScene</code>, you can add the sound effect when the reset and play buttons are clicked on. When the reset button is pressed, you can just call <code class="literal">popSound</code>, as it will play without any trouble—this is because the scene is not changing. You will need to use a <code class="literal">btnPressed</code> function when <code class="literal">playBtn</code> is pressed, as the scene will change instantaneously and the sound will be not be played. So, make sure you create a <code class="literal">btnPressed</code> function and call it after a delay when the play button is pressed to hear the sound effect play out completely. The code is as follows:</p><div><pre class="programlisting">    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        /* Called when a touch begins */
        
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            
            let _node:SKNode = self.nodeAtPoint(location);
            
            if(_node.name == "playBtn"){
                
                //println("[GameScene] play btn clicked ");
                
                let popSound = SKAction.playSoundFileNamed("pop.mp3", waitForCompletion: true)
                self.runAction(popSound)
                
                let  buttonPressAction = SKAction.repeatActionForever(SKAction.sequence([SKAction.runBlock(btnPressed),SKAction.waitForDuration(1.0)]))
                self.runAction(buttonPressAction)
                
            }
            
            else if (_node.name == "resetBtn"){
                
                let popSound = SKAction.playSoundFileNamed("pop.mp3", waitForCompletion: true)
                self.runAction(popSound)
                
                NSUserDefaults.standardUserDefaults().setInteger(0, forKey: "tinyBazooka_highscore")
                NSUserDefaults.standardUserDefaults().synchronize()
                
                var currentHighScore = NSUserDefaults.standardUserDefaults().integerForKey("tinyBazooka_highscore")
                currentHighScoreLabel.text = "Current High Score: \(currentHighScore)";
                
            }
            
        }
    }</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Adding background music</h1></div></div></div><p>Our game is now populated <a id="id508" class="indexterm"/>with sound effects, but it will be so much more awesome if we add background music. Since the player will need to keep switching between <code class="literal">MainMenuSceen</code> and <code class="literal">GameplayScene</code>, there is no point in using <code class="literal">SKAction</code> to play sounds, as it won't play correctly or will get truncated each time the scene is changed.</p><p>For this purpose, we will have to use Apple's audio visual class called <code class="literal">AVFoundation</code> to help us get around this issue. As you might have guessed, <code class="literal">AVFoundation</code> is a superclass that handles both the audio and video functionalities, so if you want any video to be played in your game (say, for a tutorial), then you can very well use this class—that is why it was created. But <a id="id509" class="indexterm"/>let's get back to including the background music in our game.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Adding audio loops</h2></div></div></div><p>To create<a id="id510" class="indexterm"/> audio loops, we have to import <code class="literal">AVFoundation</code>, and since we have to play the audio track as soon as the game starts, let's add it in the <code class="literal">GameViewController</code> class. So, add the following at the top of the class, as highlighted:</p><div><pre class="programlisting">import UIKit
import SpriteKit
<strong>import AVFoundation</strong>
</pre></div><p>Next, after we create the class, we include the following highlighted line:</p><div><pre class="programlisting">class GameViewController: UIViewController {
    
<strong>let bgMusic = AVAudioPlayer(contentsOfURL: NSBundle.mainBundle().URLForResource("bgMusic", withExtension: "mp3"), error: nil)</strong>
</pre></div><p>Here, we create a new constant called <code class="literal">bgMusic</code>. To it, we assign the <code class="literal">AVAudioPlayer</code> function. It takes two parameters. The first is the location of the file, and the second is the error message to be displayed.</p><p>In the first parameter, we pass the name and extension so that the file can be retrieved from the resource location of main bundle. In the <code class="literal">URLForResource</code> function, we pass the name of the file, which is <code class="literal">bgMusic</code>, and provide the extension, which is of the MP3 format. This will get the <code class="literal">bgMusic.mp3</code> file, which was previously added in <strong>Copy Bundle Resources</strong> under the <strong>Build Phases</strong> section.</p><p>Also, this needs to be retrieved before the view is loaded. If we add this line to <code class="literal">viewDidLoad</code>, then it won't cause errors, but the file will not play properly, so it is called outside the <code class="literal">viewDidLoad</code> function.</p><p>Once the file is loaded in the <code class="literal">viewDidLoad</code> function, add the following line to tell the file to loop forever and start playing:</p><div><pre class="programlisting">bgMusic.numberOfLoops = -1
bgMusic.play()</pre></div><p>By assigning a value of <code class="literal">-1</code> to the number of loops, we are telling it to play the sound file in a loop continuously. If we assign <code class="literal">0</code>, it will play it once; if we assign <code class="literal">1</code>, it will play the sound file twice; and so on.</p><p>And that is all! Now, build and run the game to enjoy the awesome background music.</p><p>Now that we have added <a id="id511" class="indexterm"/>sound in our game, let's also add a scrolling background for fun.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Parallax background theory</h1></div></div></div><p>In this section, we will add a<a id="id512" class="indexterm"/> parallax or scrolling background. This is a very popular effect in games where the objects in the foreground will move faster than the objects in the background, which will move much slower and give the illusion of depth and motion. This is much similar to the movies of the yesteryears, where the hero or the subject will be stationary and act as if they are galloping on a horse, and the background will be looped to give the illusion that the hero is actually moving forward in the scene.</p><p>We will be implementing a very simple parallax effect, where all the objects in the background such as the trees, bushes, and grass will move at the same speed. So, we will just take the background image and make it move in a loop.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>This is how the parallax effect is achieved: instead of one sprite of the background image, we will use two sprites and place them adjacent to each other horizontally at the start of the game, as seen in the following image. The first sprite will be visible but the second sprite will be offscreen and won't be visible to the player initially.</p></div></div><p>When the game starts, both the sprites will be moved with a certain speed in the negative <em>x</em> direction, that is, towards the left of the screen. Both the sprites will be moving at the same speed. So, once the game starts, <code class="literal">sprite1</code> will slowly go offscreen bit by bit and the second sprite will start becoming visible.</p><p>Once the first sprite goes completely offscreen, it is quickly moved to the end of the second sprite, which is the same position the second sprite was at the start of the game.</p><div><img src="img/B04014_06_12.jpg" alt="Parallax background theory"/></div><p>Then process<a id="id513" class="indexterm"/> continues in a loop. Both the sprites always move towards the left of the screen. After each sprite goes offscreen on the left, it is placed at offscreen on the right of the screen and continues to move left.</p><p>There are a couple of things that need to be kept in mind when creating assets for parallax scrolling and coding a parallax effect. The first is that when creating assets for a parallax effect, the art needs to be continuous. For example, if you look at middle of the preceding image, you will see that the mountains look like a continuous mountain range. Even though <code class="literal">sprite1</code> and <code class="literal">sprite2</code> are two different images, when put together, they appear to be a single image. This can again be seen in the light-green bush below the mountain. The left part of the bush is in <code class="literal">sprite1</code> and the right is in <code class="literal">sprite2</code>, yet when the two sprites are kept adjacent to each other, it gives a seamless illusion of being part of a single bush.</p><p>The second aspect to keep in mind is the image gaps. Even if you make the images seamless and make the sprites move at the same speed, you might sometimes encounter gaps between the sprites. This is not a very common problem, but in some frameworks, it might exist. To counter it, you can stretch the images just by a bit so that the sprites overlap each other and it is not very obvious to the player. The other method is to make sure you manually place the sprites at the end of the on-screen sprite and also make the necessary adjustments, if required, to bridge the gap between the sprites.</p><p>This is the main theory <a id="id514" class="indexterm"/>behind parallax scrolling. Let's look at it in practice in the upcoming code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Implementing the parallax effect</h1></div></div></div><p>To create a <a id="id515" class="indexterm"/>parallax effect for the background, we have to create a new class similar to how we created the <code class="literal">MovingSprite</code> class. So, go to <strong>File</strong> | <strong>New</strong> | <strong>File</strong> and create a new swift file called <code class="literal">ParallaxSprite</code>.</p><p>In the file, import SpriteKit at the top of the file and create some constants. In the class, we will just take the name of the file that we want for the parallax effect. Then we will create two sprites called <code class="literal">sprite1</code> and <code class="literal">sprite2</code> from it. We will take a value of speed at which we want to move the sprites. We will then take the instance of the <code class="literal">GameplayScene</code> class so that we can add the sprites to the gameplay class. We will also create a global constant to get the size of the view:</p><div><pre class="programlisting">import Foundation
import SpriteKit

class ParallaxSprite{
    
    let _sprite1: SKSpriteNode!
    let _sprite2: SKSpriteNode!
    let _speed : CGFloat = 0.0
    let _viewSize:CGSize!
    
} //class end</pre></div><p>Next, we will create the <code class="literal">init</code> function for the class in which we will take the <em>names</em> of sprite to be parallax, the <em>speed</em>, and the gameplay scene, and initialize the constants we created at the top of the class:</p><div><pre class="programlisting">    init(sprite1: SKSpriteNode, sprite2: SKSpriteNode, viewSize: CGSize, speed: CGFloat){
        
        _speed = speed
        _viewSize = viewSize
        
        _sprite1 = sprite1
        _sprite1.position = CGPoint(x: _viewSize.width/2, y: _viewSize.height/2)
               
        _sprite2 = sprite2
        _sprite2.position = CGPoint(x: _sprite1.position.x + _sprite2.size.width - 2, y: _viewSize.height/2)
        
    }//init</pre></div><p>In the <code class="literal">init</code> function, we initialize the speed variable with whatever value was passed in. We will also assign the size of the view that can be retrieved from the global constant we created in the <code class="literal">GameplayScene</code> class. We also assign the two sprite names passed into the local sprite variables: <code class="literal">_sprite1</code> and <code class="literal">_sprite2</code>.</p><p>The _<code class="literal">sprite1</code> object<a id="id516" class="indexterm"/> is positioned at the center of the view, so the <code class="literal">x</code> and <code class="literal">y</code> position is obtained by diving the width and height of <code class="literal">viewSize</code> by half.</p><p>For the second sprite, _<code class="literal">sprite2</code>, the height is kept at half the height of the screen, but as for the position, it is placed so that the left edge of <code class="literal">sprite2</code> overlaps the right edge of <code class="literal">sprite1</code>. So, the second sprite is kept at the <code class="literal">x</code> position equal to the width of <code class="literal">sprite2</code>. The <code class="literal">-2</code> is small adjustment factor that is used to make sure that the two sprites overlap each other. This was added after some trial and error to arrive at the number.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>You can increase or decrease this value to see what effect it has, and if you want, you can add more or less overlapping, depending on your preference.</p></div></div><p>Also, note that the sprites are not added to the current class but to the <code class="literal">GameplayScene</code> class. We can't add the sprites to the current class because we don't inherit from <code class="literal">SKNode</code> or <code class="literal">SKSpriteNode</code>, so the current class doesn't have the <code class="literal">addChild</code> property.</p><p>Next, we define the <code class="literal">update</code> function, as we will need to update the positions of <code class="literal">sprite1</code> and <code class="literal">sprite2</code> continuously. So, right<a id="id517" class="indexterm"/> after the <code class="literal">init</code> function, add the <code class="literal">update</code> function:</p><div><pre class="programlisting">func update(){
        
    _sprite1.position.x += _speed
    _sprite2.position.x += _speed
        
    if((_sprite1.position.x + _sprite1.size.width/2) &lt; 0){
        
        _sprite1.position = CGPoint(x: _sprite2.position.x + _sprite1.size.width - 2, y: _viewSize.height/2)
            
    }
        

    if((_sprite2.position.x + _sprite2.size.width/2) &lt; 0){
            
        _sprite2.position = CGPoint(x: _sprite1.position.x + _sprite2.size.width - 2 , y: _viewSize.height/2)
            
    }
        
}//update</pre></div><p>In the <code class="literal">update</code> function, we increment the position of the sprites with a speed, so that the sprites move. So, since we are incrementing and not decrementing the value, when we create an instance of this class, we will need to remember to provide a negative speed value so that sprite moves towards the left, or else sprite will start going in the positive <em>x</em> direction.</p><p>Next, we check whether the right edge of <code class="literal">sprite1</code> has gone beyond the left end of the screen. If the sprite has gone off-screen, we get the position of <code class="literal">sprite2</code>, place <code class="literal">sprite1</code> at the end of the sprite, and subtract it by the adjustment factor to avoid the gap. The similar process is done for <code class="literal">sprite2</code> also, but here we place it at the end of <code class="literal">sprite1</code>.</p><p>That is for the <code class="literal">ParallaxSprite</code> class.</p><p>To implement this class, go to the <code class="literal">GameplayScene</code> class and add a global constant after <code class="literal">var score:Int = 0</code> at the top of the class. Type <code class="literal">ParallaxSprite</code> with the name as <code class="literal">scrollingBg</code>, as shown in the following code. Don't forget the exclamation mark at the end:</p><div><pre class="programlisting">let scrollingBg:ParallaxSprite!</pre></div><p>Next, we remove the code we added to include the BG sprite in the <code class="literal">init</code> function, and add these lines in its place:</p><div><pre class="programlisting">        let BG1 = SKSpriteNode(imageNamed: "BG");   self.addChild(BG1);
        let BG2 = SKSpriteNode(imageNamed: "BG");   self.addChild(BG2);
        
        scrollingBg = ParallaxSprite(sprite1: BG1, sprite2: BG2, viewSize: viewSize, speed: -5.0)</pre></div><p>We create two sprite constants called <code class="literal">BG1</code> and <code class="literal">BG2</code>, and pass the image <code class="literal">BG</code>. Next, we initiate the <code class="literal">scrollingBg</code> class. In it, we pass the names of the image that we want to create scrolling effect for, which is the <code class="literal">BG1</code> and <code class="literal">BG2</code> sprites. We give it a speed of <code class="literal">-5.0</code> and give the current instance of the gameplay scene to it, that is, <code class="literal">self</code>.</p><p>Next, we need to call the <a id="id518" class="indexterm"/>update function of the <code class="literal">ParallaxSprite</code> class so that the objects' positions get updated, and then we should have our scrolling background:</p><div><pre class="programlisting">if(!gameOver){
           
       <strong>scrollingBg.update()</strong>
            
       updateGameObjects()
       updateHero()
       checkCollision()
}//gameOver check </pre></div><div><img src="img/B04014_06_13.jpg" alt="Implementing the parallax effect"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Summary</h1></div></div></div><p>So finally, in this chapter, we have added some music and effects to go along with the gameplay. We also looked at the difference in audio formats and how we can convert one audio format to other.</p><p>To top it all, we added a parallax effect to the game, making it look livelier. Like the background, you can also pass other objects to create an even better parallax effect. For free royalty effects and music, you can visit <a class="ulink" href="http://www.freesound.org">www.freesound.org</a> or <a class="ulink" href="http://www.soundbible.com">www.soundbible.com</a>.</p><p>We will see how to add an opening splash screen, add icons, upload the game to the App Store, and add the final touches to the game in <a class="link" href="ch10.html" title="Chapter 10. Publishing and Distribution">Chapter 10</a>, <em>Publishing and Distribution</em>. In the next chapter, we will look at some of the more advanced features of SpriteKit such as physics, lighting, and so on. See you in the next chapter!</p></div></body></html>