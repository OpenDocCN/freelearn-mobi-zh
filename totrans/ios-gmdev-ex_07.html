<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Particle Effects and Shaders</h1></div></div></div><p>In the previous chapter, we discussed in detail how to animate nodes, controls, the <code class="literal">SceneKit</code> method, and so on. We also discussed handling scene animations. We learned the <code class="literal">SKAction</code> class properties and methods along with learning about various controls by which a game can be played, such as gesture recognition or accelerometer.</p><p>We added player animations, controls, and actions in our <em>Platformer</em> game, this has made the game pretty fun to play and interesting to learn.</p><p>In this chapter, we will study particle effects and shaders in a Sprit Kit game. Particle effect is a very exciting ability provided by Sprite Kit. We can generate particles using the <code class="literal">SKEmitterNode</code> object; these particles create beautiful visual effects such as rain, fire, bokeh, spark, and so on. Shaders were introduced in Sprite Kit with iOS 8. Shaders are used to give customized special effects to scenes. The <code class="literal">SKShader</code> class is used to include shaders in our Sprite Kit game.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Particle effects</h1></div></div></div><p>Particle effects in<a id="id398" class="indexterm"/> games is a technique in which small sprites or other graphical objects are used to simulate a diffused effect, for example, rendering of the following effects by the particle system is very common:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fire</li><li class="listitem" style="list-style-type: disc">Explosion</li><li class="listitem" style="list-style-type: disc">Smoke</li><li class="listitem" style="list-style-type: disc">Moving water</li><li class="listitem" style="list-style-type: disc">Falling leaves</li><li class="listitem" style="list-style-type: disc">Clouds</li><li class="listitem" style="list-style-type: disc">Fog</li><li class="listitem" style="list-style-type: disc">Snow</li><li class="listitem" style="list-style-type: disc">Dust</li><li class="listitem" style="list-style-type: disc">Meteors</li><li class="listitem" style="list-style-type: disc">Stars</li><li class="listitem" style="list-style-type: disc">Galaxies</li><li class="listitem" style="list-style-type: disc">Trails</li></ul></div><p>The entire behavior in<a id="id399" class="indexterm"/> particle effect is defined by the emitter node. A particle in Sprite Kit is similar to a <code class="literal">SKSpriteNode</code> object where it renders a textured or non-textured image that can be sized, colorized, or blended in the scene.</p><div><img src="img/4201_07_06.jpg" alt="Particle effects"/><div><p>An example of different effects</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>The SKEmitter node</h1></div></div></div><p>The <code class="literal">SKEmitterNode</code> object is a node that automatically creates and renders small sprites. We can configure<a id="id400" class="indexterm"/> the emitter node properties from our Xcode itself. We use the particle emitter editor for this purpose.</p><p>We can use target nodes to change the destination of particles. Here is a sample code snippet to demonstrate how we can implement the same.</p><div><pre class="programlisting">// CREATING THE EMITTER NODE
var emitter:SKEmitterNode = (fileNamed: "PlayerCollide.sks")
// SETTING THE EMITTER POSITION AND NAME
emitter.position = CGPointMake(0,-40)
emitter.name = "playerCollide"
// SEND THE PARTICLES TO THE SCENE
emitter.targetNode = self.scene
// ADDING EMITTER NODE
self.addChild(emitter)</pre></div><p>Let's discuss the properties and methods that are used while implementing Sprite Kit's emitter node.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Creating the particle effect</h1></div></div></div><p>Sprite Kit provides <a id="id401" class="indexterm"/>properties and variables to customize particle effects as per their requirement in a game. Let's discuss these properties and variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">var particleBirthRate</code>: In this <a id="id402" class="indexterm"/>property, you define the number of particles created by the emitter every second. The default value of this is <code class="literal">0.0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func advanceSimulationTime( sec:NSTimeInterval )</code>: This method helps you advance the <a id="id403" class="indexterm"/>emitter particle simulation. It takes time in seconds as its parameter, which is the time required to simulate. Preferably, this method is used to preoccupy an emitter node with particles after its addition to scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">var numParticlesToEmit</code>: In this property, you define the number of particles the emitter has to emit. By<a id="id404" class="indexterm"/> default, its value is <code class="literal">0</code>, which means that the emitter creates infinite particles.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func resetSimulation ()</code>: This method<a id="id405" class="indexterm"/> removes all the particles and restarts the simulation. Resetting the simulation clears its internal state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">var targetNode</code>: As discussed <a id="id406" class="indexterm"/>earlier, we can use <code class="literal">targetNode</code> to change the destination of the particles. If the property is <code class="literal">nil</code>, then the particles are treated to be<a id="id407" class="indexterm"/> children of the emitter node. When this property points to the target node, then new particles are treated as if they are children of the target node, but the previously generated particles are calculated based on the emitter node's properties. Its default value is nil.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Properties for determining a particle's lifetime</h2></div></div></div><p>This is the time for which the user-created particle will stay alive and functional. When the lifetime drains out <a id="id408" class="indexterm"/>and drops below zero, the particle will be<a id="id409" class="indexterm"/> killed.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">var particleLifetime</code>: This property determines the average lifetime of a particle in seconds. Its default value is <code class="literal">0.0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">var particleLifetimeRange</code>: We<a id="id410" class="indexterm"/> specify a range in this property, the lifetime of a particle is determined randomly within this range.</li></ul></div><p>It's now time to add a particle effect in our <em>Platformer</em> game.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Adding the particle effect in our Platformer game</h2></div></div></div><p>Let's integrate <a id="id411" class="indexterm"/>particle effect at player collision in our <em>Platformer</em> game. We <a id="id412" class="indexterm"/>will make a particle simulation at the time of collision between blocks and the player.</p><p>As an initial step for implementation, lets create a particle effect. Go to the <strong>Project Navigator</strong> and add new <strong>File</strong> | <strong>SpriteKit Particle File</strong> | <strong>Spark</strong> | <strong>Create</strong>.</p><div><img src="img/4201_07_01.jpg" alt="Adding the particle effect in our Platformer game"/></div><p>You can choose<a id="id413" class="indexterm"/> from a list of particle templates, such <a id="id414" class="indexterm"/>as <strong>Snow</strong>, <strong>Bokeh</strong>, <strong>Fire</strong>, <strong>Rain</strong>, <strong>Spark</strong>, and so on. Here we are using the <strong>Spark</strong> effect template:</p><div><img src="img/4201_07_02.jpg" alt="Adding the particle effect in our Platformer game"/></div><p>Open the <code class="literal">ParticleEffectPlayerCollide.sks</code> file we just created. Particle effect files are saved with the <a id="id415" class="indexterm"/>extension, <code class="literal">.sks</code>. You can change the<a id="id416" class="indexterm"/> different properties of selected particle effects using the particle emitter editor, which you can access on the right-hand side.</p><div><img src="img/4201_07_03.jpg" alt="Adding the particle effect in our Platformer game"/><div><p>The particle emitter editor in Sprite Kit</p></div></div><p>Let's discuss some of the<a id="id417" class="indexterm"/> properties, which are <a id="id418" class="indexterm"/>displayed on the <strong>SpriteKit Particle Emitter</strong> panel:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Particle Texture</strong>: You can select an image to be used for creating the particle. For particle texture, images related to the project can also be used. To assign the image, one must keep in mind that a complex and larger image will require excessive use of resources. A simple and small image is advisable.</li><li class="listitem" style="list-style-type: disc"><strong>Birthrate</strong>: This property is used to set the rate at which the emitter generates the particles. If the birthrate is more than the particle effect, it will look more intensive. So, it's always recommended to follow the lower birthrate for an optimum frame rate.</li><li class="listitem" style="list-style-type: disc"><strong>Lifetime</strong>: This property will define the total lifetime of the particle on the screen. Here, <strong>Range</strong> refers to the random value from the first value <strong>+</strong> or <strong>-</strong> range.</li><li class="listitem" style="list-style-type: disc"><strong>Position Range</strong>: This property will tell you how far from the origin emitter node the effect <a id="id419" class="indexterm"/>should be, using <strong>X</strong> and <strong>Y</strong> co-ordinate values. Change in this property affects the size of the emitter.</li><li class="listitem" style="list-style-type: disc"><strong>Angle</strong>: This property will tell the angle in which the particle effect should happen. This will also use the <strong>Start</strong> and <strong>Range</strong> values.</li><li class="listitem" style="list-style-type: disc"><strong>Speed</strong>: This <a id="id420" class="indexterm"/>property will define the initial speed at which the effect should happen. This will also use the <strong>Start</strong> and <strong>Range</strong> values.</li><li class="listitem" style="list-style-type: disc"><strong>Acceleration</strong>: This property will take care of the acceleration at which the particles should appear from the source emitter using <strong>X</strong> and <strong>Y</strong> coordinates.</li><li class="listitem" style="list-style-type: disc"><strong>Alpha</strong>: This property will take care of the transparency of the effect. This will also use the <strong>Start</strong> and <strong>Range</strong> values with a <strong>Speed</strong>.</li><li class="listitem" style="list-style-type: disc"><strong>Scale</strong>: This property will define the <strong>Scale</strong> position for the texture/image that is used for the effect. This will also use the <strong>Start</strong>, <strong>Range</strong>, and <strong>Speed</strong> values.</li><li class="listitem" style="list-style-type: disc"><strong>Rotation</strong>: This property is used to define the <strong>Rotation</strong> speed for the particle effect. This will also use the <strong>Start</strong>, <strong>Range</strong>, and <strong>Speed</strong> values.</li><li class="listitem" style="list-style-type: disc">The <strong>Color Blend</strong> factor: This property is used to define the color that is used in the particle effect lifetime. Where the particles may follow different colors in their particle lifetime. This will use the <strong>Factor</strong>, <strong>Range</strong>, and <strong>Speed</strong> values for defining the property.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Adding the code to facilitate the particle effect</h3></div></div></div><p>Once you are <a id="id421" class="indexterm"/>done with setting up the desired properties, create a particle node object (the <code class="literal">SKEmitterNode</code> object) in the <code class="literal">GameScene.swift</code> file:</p><div><pre class="programlisting">var particlePlayerNode = SKEmitterNode(fileNamed: "ParticleEffectPlayerCollide.sks")</pre></div><p>Now, set the position in the <code class="literal">didMoveToView()</code> method and also hide the particle node that is created. Finally, add the particle node into the player. Now the <code class="literal">didMoveToView()</code> method should look like the following code:</p><div><pre class="programlisting">override func didMoveToView(view: SKView)
    {
        self.physicsWorld.contactDelegate = self
         // JUMP BUTTON POSITION SETTING AND ADDING ONTO THE SCREEN
        self.btnJump.position = CGPointMake
(-(self.size.width/2.2), -(self.size.height/4))
        self.addChild(btnJump)

  //PROPERTIES FOR PARTICLE NODE      CHAPTER 7
        self.particlePlayerNode.zPosition = 1
        self.particlePlayerNode.hidden = true

        addBackGround()
        addRunningBar()
        addPlayer()

        //ADDING PARTICLE NODE ON SCREEN (AS CHILD TO PLAYER)
        self.player.addChild(self.particlePlayerNode)

        addBlocks()
        //addSpriteWithoutTexture()
    }</pre></div><p>Now, let's define when this particle effect should happen, un-hiding the <code class="literal">particlePlayerNode</code> we created within the <code class="literal">didBeginContact()</code> method, as this method will be called whenever the collision happens.</p><p>The <code class="literal">didBeginContact</code> method should look as follows:</p><div><pre class="programlisting">    func didBeginContact(contact: SKPhysicsContact)
    {
        // SHOWING PARTICLE EFFECT WHEN COLLISION HAPPENS
        self.particlePlayerNode.hidden = false

        var inOutActionWhenPlayerDied = SKAction.scaleBy(0.5, duration: 0.5)
        var upActionWhenPlayerDied = SKAction.moveToY(self.player.size.height * 4, duration: 2)
        var removeFromParent = SKAction.self.removeFromParent()

self.player.runAction(SKAction.sequence
([inOutActionWhenPlayerDied,
inOutActionWhenPlayerDied.reversedAction(),
upActionWhenPlayerDied,removeFromParent]),
gotoMenuScreen)

    }</pre></div><p>This is how the<a id="id422" class="indexterm"/> collision will look with the particle effect:</p><div><img src="img/4201_07_08.jpg" alt="Adding the code to facilitate the particle effect"/></div><p>Now, we have successfully added the particle effect in our <em>Platformer</em> game, and it's time to discuss about shaders and how we can add them in our game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Shaders</h1></div></div></div><p>Shaders in Sprite Kit facilitate <code class="literal">SKScenenode</code> to appear with a special, customized, drawing behavior. This<a id="id423" class="indexterm"/> can be achieved by creating the <code class="literal">SKShader</code> objects and assigning a custom OpenGL ES fragment shader.</p><p>If a custom shader (the <code class="literal">SKShader</code> object) needs to provide a uniform shader, then you need to create one or more <code class="literal">SKUniform</code> objects and associate them with your shader objects. Shader programs are primarily divided into:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vertex shaders</li><li class="listitem" style="list-style-type: disc">Fragment shaders</li></ul></div><p>Let's discuss about both of these in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Vertex shaders</strong>: These <a id="id424" class="indexterm"/>shaders work on each vertex and most of the calculation<a id="id425" class="indexterm"/> is done on the vertex part. They are set by Sprite Kit automatically. As the computation of these shaders are mostly done on the vertex part, not much of the CPU's resources are consumed in the formation.</li><li class="listitem" style="list-style-type: disc"><strong>Fragment shaders</strong>: These <a id="id426" class="indexterm"/>shaders are written in OpenGL <a id="id427" class="indexterm"/>Shading Language. As the name suggests, they work on each pixel. They use very heavy computation and hence are avoided when too many shaders are required.<div><img src="img/4201_07_07.jpg" alt="Shaders"/><div><p>A graphical representation of the vertex and fragment shaders</p></div></div></li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>A fact about using custom shaders</h2></div></div></div><p>Writing your own shaders is a<a id="id428" class="indexterm"/> complicated task if you have not done GLSL code before, but it makes<a id="id429" class="indexterm"/> sense to add shader scripts to an existing Sprite Kit.</p><p>You can easily procure shader files online from various websites and start working on them. From websites such as <a class="ulink" href="https://www.shadertoy.com/">https://www.shadertoy.com/</a> or <a class="ulink" href="http://www.glslsandbox.com">www.glslsandbox.com</a>, and so on, you will <a id="id430" class="indexterm"/>get a simple text file with the extension, <code class="literal">.fsh</code>. Then you just have to add that shader code wherever you require.</p><p>Now, let's discuss about initialization and creation of new shader objects in our game.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>The creation and initialization of new shader objects</h2></div></div></div><p>The methods are discussed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Init! (name: string)</code>: This method<a id="id431" class="indexterm"/> initializes a new shader object by utilizing a fragment shader from a file present in the <code class="literal">app</code> bundle with a <code class="literal">.fsh</code> file extension. You pass the name of the file as a<a id="id432" class="indexterm"/> parameter and get a newly initialized shader object as the return value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Init (source: String!, uniforms: [AnyObject]!)</code>: This method also initializes a new shader <a id="id433" class="indexterm"/>object using the specified source. But along with that, we can also set a list of <code class="literal">uniforms</code> to be added to the shader object. Uniforms are the way to access the data in fragment shaders. Uniforms have the same value for each pixel, for example, the size of the resulting image. We get an initialized shader object with this initializer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Init (source: string!)</code>: This method initializes a new shader object with the <code class="literal">string</code> that contains the initial <code class="literal">source</code> for the shader object.</li></ul></div><p>Let's discuss about properties and methods which can be used for uniform data with shader objects.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Uniform data in shaders</h2></div></div></div><p>The methods are detailed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addUniform(uniform: SKUniform)</code>: This method adds a <code class="literal">uniform</code> object to the shader object. It takes the <code class="literal">uniform</code> object to be <a id="id434" class="indexterm"/>added as its parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeUniformNamed(name: String)</code>: This<a id="id435" class="indexterm"/> method removes a <code class="literal">uniform</code> object from the shader object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">uniformNamed(name: String)</code>: This <a id="id436" class="indexterm"/>method returns the <code class="literal">uniform</code> object resembling a particular <code class="literal">uniform</code> variable. If the <code class="literal">uniform</code> object is not found, it returns <code class="literal">nil</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">var uniforms: [AnyObject]</code>: This <a id="id437" class="indexterm"/>property has a<a id="id438" class="indexterm"/> list of all <code class="literal">uniforms</code> correlating with the shader.</li></ul></div><p>To hold uniform data for a custom OpenGL SL shader, we use the <code class="literal">SKUniform</code> object. The uniform data is usable for all shaders that include the <code class="literal">uniform</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>Implementing shaders in the Platformer game</h2></div></div></div><p>Let's implement shaders in our <em>Platformer</em> game and understand the integration of shaders much more closely.</p><div><ol class="orderedlist arabic"><li class="listitem">Let's create a new <code class="literal">SKScene</code> in our game and load shaders there. We can have a button on the <a id="id439" class="indexterm"/>menu scene, which can take us to this scene.</li><li class="listitem">Now add a new <code class="literal">swift</code> file<a id="id440" class="indexterm"/> with the name, <code class="literal">ShaderDemo.swift</code>, into our project.</li><li class="listitem">Create a <code class="literal">SKSpriteKit</code> node with the name ,<code class="literal">box</code>, and import an image, <code class="literal">box.png</code>, of size 300 x 300 px. The box can be of any color but should only have one single color in it with no design of any kind. We are using this box image to add the shader effect inside the boundaries of the box. Also, set the position of the box image within the <code class="literal">didMoveToView()</code> method of <code class="literal">ShaderDemo.swift</code>:<div><pre class="programlisting">let box = SKSpriteNode(imageNamed: "box")
 let location = CGPoint(x: CGRectGetMidX(self.frame), y: CGRectGetMidY(self.frame))
  box.position = location
   self.addChild(box)</pre></div></li><li class="listitem">Next, we have to create the actual shader program, create a new empty file with the name, <code class="literal">blurShader.fsh</code>. We can get the code for this shader from any online resource. The following<a id="id441" class="indexterm"/> code has been fetched from <a class="ulink" href="http://www.shadertoy.com">www.shadertoy.com</a>. Thanks to the Shadertoy team and its contributors for such a concise resource for us all. The <code class="literal">blurShade.fsh</code> file should look like the following code:<div><pre class="programlisting">void main() {
#define iterations 256

    vec2 position = v_tex_coord; // gets the location of the current pixel in the intervals [0..1] [0..1]
    vec3 color = vec3(0.0,0.0,0.0); // initialize color to black

    vec2 z = position; // z.x is the real component z.y is the imaginary component


    // Rescale the position to the intervals [-2,1] [-1,1]
    z *= vec2(3.0,2.0);
    z -= vec2(2.0,1.0);

    //vec2 c = z;
    vec2 c = vec2(-0.7 + cos(u_time) / 3.0,0.4 + sin(u_time) / 3.0);

    float it = 0.0; // Keep track of what iteration we reached
    for (int i = 0;i &lt; iterations; ++i) {

        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);
        z += c;

        if (dot(z,z) &gt; 4.0) { // dot(z,z) == length(z) ^ 2 only faster to compute
            break;
        }

        it += 1.0;
    }
    if (it &lt; float(iterations)) {
        color.x = sin(it / 3.0);
        color.y = cos(it / 6.0);
        color.z = cos(it / 12.0 + 3.14 / 4.0);
    }

    gl_FragColor = vec4(color,1.0);
}</pre></div></li><li class="listitem">Now, we just<a id="id442" class="indexterm"/> need to create the <code class="literal">SKShader</code> object with the pattern. Give <code class="literal">blurshade.fsh</code> as a file name and add it to the sprite<a id="id443" class="indexterm"/> node in the <code class="literal">didMoveToView()</code> method:<div><pre class="programlisting">let pattern = SKShader(fileNamed: "blurShade.fsh")
box.shader = pattern</pre></div></li><li class="listitem">As <code class="literal">ShaderDemo.fsh</code> is ready to run, let's also add a <code class="literal">BACK</code> button in the shader scene for the user to go back to the previous screen. <code class="literal">ShaderDemo.swift</code> should look like the following:<div><pre class="programlisting">class ShaderDemo : SKScene
{
    var menuSceneInstance : MenuScene?
    override func didMoveToView(view: SKView)
    {
        let box = SKSpriteNode(imageNamed: "box")
        let pattern = SKShader(fileNamed: "blurShade.fsh")
        let location = CGPoint(x: CGRectGetMidX(self.frame), y: CGRectGetMidY(self.frame))
        box.position = location
        box.shader = pattern
        self.addChild(box)
        addBackLabel()
    }
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent)
    {
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            gotoMenuScreen()
        }
    }
    func gotoMenuScreen()
    {
        let transitionEffect = SKTransition.flipVerticalWithDuration(2)
        menuSceneInstance = MenuScene(size: self.size , playbutton: "Play", background: "BG")
        menuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(menuSceneInstance , transition:transitionEffect)
    }
    func addBackLabel()
    {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
        backbutton.zPosition = 3
        self.addChild(backbutton)
    }
    }</pre></div><p>The following<a id="id444" class="indexterm"/> image shows how the code shader effect will look:</p><div><img src="img/4201_07_04.jpg" alt="Implementing shaders in the Platformer game"/></div></li><li class="listitem">Let's also set up a<a id="id445" class="indexterm"/> button in <code class="literal">MenuScene.swift</code> for the user to go to the <code class="literal">ShaderDemo</code> scene. Following is the code for adding this button:<div><pre class="programlisting">var shaderSceneInstance : ShaderDemo?
func addShaderSceneBtn()
    {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "SHADOWS"
        backbutton.text = "SHADOW EFFECT"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
        backbutton.zPosition = 3
        self.addChild(backbutton)
    }</pre></div></li></ol></div><p>Now, the code is ready. For<a id="id446" class="indexterm"/> the sake of presentation, let's also<a id="id447" class="indexterm"/> add a transition for the button to present a shader scene when it is clicked:</p><div><pre class="programlisting">func goToShaderScene(){
        let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
        shaderSceneInstance = ShaderDemo(size: self.size)
        shaderSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(shaderSceneInstance , transition:transitionEffect)

    }</pre></div><p>Call this method from the <code class="literal">touchesBegan()</code> method by checking a condition if the node name equal to <code class="literal">"SHADOWS"</code> as we want both, the <strong>PLAY</strong> button and the <strong>SHADOW EFFECT</strong> button on the menu screen:</p><div><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == PlayButton.name {
                goToGameScene()
                //goToShaderScene()

            }
            else if node.name == "SHADOWS"
            {
              goToShaderScene()
            }
        }
    }
    func goToShaderScene(){
        let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
        shaderSceneInstance = ShaderDemo(size: self.size)
        shaderSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(shaderSceneInstance , transition:transitionEffect)

    }</pre></div><p>Now the file is ready<a id="id448" class="indexterm"/> to run as it should. The following<a id="id449" class="indexterm"/> screenshot shows how the main menu screen will look:</p><div><img src="img/4201_07_05.jpg" alt="Implementing shaders in the Platformer game"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we learned about the particle effect and shaders in detail. We discussed about the <code class="literal">SKEmitterNode</code> object and the <code class="literal">SKShader</code> object, and how we can implement them in our <em>Platformer</em> game. We have also discussed about adding OpenGL ES code in our Sprite Kit project and how we can utilize shaders in our game. Now, our <em>Platformer</em> game has a particle effect when the player collides with the block, and the shader scene is a separate screen to display shader effects.</p><p>In the next chapter, we will add levels in our game, which will further enhance the gameplay experience for the user and help them understand the game concepts in more detail. We will also add a pause button that will pause the game when required.</p></div></body></html>