["```java\n<activity \n    android:name=\".StepCounterActivity\" \n    android:label=\"@string/daily_step_count_title\" \n    android:launchMode=\"singleInstance\" \n/> \n\n```", "```java\npublic class StepCounterActivity extends WearableActivity  implements SensorEventListener \n{ \n  private SensorManager mSensorManager; \n  private Sensor mSensor; \n\n  // Steps counted since the last reboot \n  private int mSteps = 0; \n\n  private static final String TAG =  StepCounterActivity.class.getName(); \n  private BoxInsetLayout stepCounterLayout; \n  private CardFrame cardFrame; \n  private TextView title, desc; \n  private AlarmManager mAmbientStateAlarmManager; \n  private PendingIntent mAmbientStatePendingIntent; \n\n  /** \n   * This custom handler is used for updates in \"Active\" mode. We use a separate static class to \n   * help us avoid memory leaks. \n   */ \n\n  private final Handler mActiveModeUpdateHandler = new UpdateHandler(this); \n\n  /** \n   * Custom 'what' for Message sent to Handler. \n   */ \n\n  private static final int MSG_UPDATE_SCREEN = 0; \n\n  /** \n   * Milliseconds between updates based on state. \n   */ \n\n  private static final long ACTIVE_INTERVAL_MS =  TimeUnit.SECONDS.toMillis(1); \n  private static final long AMBIENT_INTERVAL_MS =  TimeUnit.SECONDS.toMillis(20); \n\n  @Override \n  protected void onCreate(Bundle savedInstanceState)  \n  { \n    super.onCreate(savedInstanceState); \n    setContentView(R.layout.activity_daily_step_counter); \n\n    mSensorManager = (SensorManager)  getSystemService(Context.SENSOR_SERVICE); \n    mSensor =  mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER); \n\n    setAmbientEnabled(); \n\n    mAmbientStateAlarmManager = (AlarmManager)  getSystemService(Context.ALARM_SERVICE); \n    Intent ambientStateIntent = new  Intent(getApplicationContext(), DailyTotalActivity.class); \n\n    mAmbientStatePendingIntent = PendingIntent.getActivity( \n      getApplicationContext(), \n      0 /* requestCode */, \n      ambientStateIntent, \n      PendingIntent.FLAG_UPDATE_CURRENT); \n\n    stepCounterLayout = (BoxInsetLayout)  findViewById(R.id.step_counter_layout); \n    cardFrame = (CardFrame)  findViewById(R.id.step_counter_card_frame); \n    title = (TextView) findViewById(R.id.daily_step_count_title); \n    desc = (TextView) findViewById(R.id.daily_step_count_desc); \n    refreshDisplayAndSetNextUpdate(); \n  } \n\n  /** \n   * Loads data/updates screen (via method), but most importantly, sets up the next refresh \n   * (active mode = Handler and ambient mode = Alarm). \n   */ \n\n  private void refreshDisplayAndSetNextUpdate()  \n  { \n    Log.i(TAG, \"Refresh display and set next update \"); \n    refreshStepCount(); \n    long timeMs = System.currentTimeMillis(); \n    if (isAmbient())  \n    { \n      /** Calculate next trigger time (based on state). */ \n      long delayMs = AMBIENT_INTERVAL_MS - (timeMs %  AMBIENT_INTERVAL_MS); \n      long triggerTimeMs = timeMs + delayMs; \n\n      /** \n       * Note: Make sure you have set activity launchMode to singleInstance in the manifest. \n       * Otherwise, it is easy for the AlarmManager launch intent to open a new activity \n       * every time the Alarm is triggered rather than reusing this Activity \n       */ \n\n      mAmbientStateAlarmManager.setExact( \n        AlarmManager.RTC_WAKEUP, \n        triggerTimeMs, \n        mAmbientStatePendingIntent); \n\n    } \n    else  \n    { \n      /** Calculate next trigger time (based on state). */ \n      long delayMs = ACTIVE_INTERVAL_MS - (timeMs %  ACTIVE_INTERVAL_MS); \n\n      mActiveModeUpdateHandler.removeMessages(MSG_UPDATE_SCREEN); \n      mActiveModeUpdateHandler.sendEmptyMessageDelayed  (MSG_UPDATE_SCREEN, delayMs); \n    } \n  } \n\n  /** \n   * Prepares UI for Ambient view. \n   */ \n\n  @Override \n  public void onEnterAmbient(Bundle ambientDetails)  \n  { \n    Log.d(TAG, \"onEnterAmbient()\"); \n    super.onEnterAmbient(ambientDetails); \n\n    /** Clears Handler queue (only needed for updates in active mode). */ \n\n    mActiveModeUpdateHandler.removeMessages(MSG_UPDATE_SCREEN); \n\n    /** \n     * Following best practices outlined in WatchFaces API (keeping most pixels black, \n     * avoiding large blocks of white pixels, using only black and white, \n     * and disabling anti-aliasing, etc.) \n     */ \n\n    stepCounterLayout.setBackgroundColor(Color.BLACK); \n    cardFrame.setBackgroundColor(Color.BLACK); \n    desc.setTextColor(Color.WHITE); \n    desc.getPaint().setAntiAlias(false); \n    title.setTextColor(Color.WHITE); \n    title.getPaint().setAntiAlias(false); \n    refreshDisplayAndSetNextUpdate(); \n  } \n\n  @Override \npublic void onUpdateAmbient()  \n{ \n    Log.d(TAG, \"onUpdateAmbient()\"); \n    super.onUpdateAmbient(); \n\n    refreshDisplayAndSetNextUpdate(); \n} \n\n/** \n * Prepares UI for Active view (non-Ambient). \n */ \n@Override \npublic void onExitAmbient()  \n{ \n    Log.d(TAG, \"onExitAmbient()\"); \n    super.onExitAmbient(); \n\n    /** Clears out Alarms since they are only used in ambient mode. */ \n    mAmbientStateAlarmManager.cancel(mAmbientStatePendingIntent); \n\n    stepCounterLayout.setBackgroundResource(R.drawable.jogging); \n    cardFrame.setBackgroundColor(Color.WHITE); \n\n    desc.setTextColor(Color.BLACK); \n    desc.getPaint().setAntiAlias(true); \n\n    title.setTextColor(Color.BLACK); \n    title.getPaint().setAntiAlias(true); \n\n    refreshDisplayAndSetNextUpdate(); \n  } \n} \n\n```", "```java\n      Host: disconnected \n      Target: connected \n\n```", "```java\nadb forward tcp:4444 localabstract:/adb-hub\nadb connect localhost:4444\n\n```", "```java\nHost: connected \nTarget: connected \n\n```", "```java\nadb -s localhost:4444 <command>\n\n```", "```java\nadb -s localhost:4444 shell\n\n```"]