- en: Chapter 6. Exploring SELinuxFS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：探索 SELinuxFS
- en: 'In the last few chapters, we saw SELinuxFS surface on numerous occasions. From
    its entry in `/proc/filesystems` to the policy load in the init daemon, it sees
    frequent use in an SELinux-enabled system. SELinuxFS is the kernel-to-userspace
    interface and the foundation on which higher userspace idioms and `libselinux`
    are built. In this chapter, we will explore the capabilities of this filesystem
    for a deeper understanding of how the system works. Specifically, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几章中，我们多次看到了 SELinuxFS 的出现。从 `/proc/filesystems` 中的条目到 init 守护进程中的策略加载，它在启用
    SELinux 的系统中被频繁使用。SELinuxFS 是内核到用户空间的接口，也是更高用户空间习惯和 `libselinux` 的基础。在本章中，我们将探索这个文件系统的功能，以更深入地了解系统是如何工作的。具体来说，我们将：
- en: Determine how to find the mount point of the SELinux filesystem
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何找到 SELinux 文件系统的挂载点
- en: Extract status information about our current SELinux system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取我们当前 SELinux 系统的状态信息
- en: Modify our SELinux system status on the fly from the shell and through code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 shell 和代码动态修改我们的 SELinux 系统状态
- en: Investigate ProcFS interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查 ProcFS 接口
- en: Locating the filesystem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位文件系统
- en: 'The first thing we need to do is locate the mount point for the filesystem.
    `libselinux` mounts the filesystem in either of two places: `/selinux` (by default)
    or `/sys/fs/selinux`. However, this is not a strict requirement and can be altered
    with a call to void `set_selinuxmnt(char *mnt)`, which sets the SELinux mount
    point location. However, this should happen and should not need any adjustment
    in most circumstances.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是定位文件系统的挂载点。`libselinux` 将文件系统挂载在两个位置之一：默认为 `/selinux` 或 `/sys/fs/selinux`。然而，这并不是一个严格的要求，可以通过调用
    `void set_selinuxmnt(char *mnt)` 来更改，该函数设置 SELinux 挂载点位置。然而，在大多数情况下，这应该发生，并且不需要任何调整。
- en: 'The best way to find the mount point in the system is by running the mount
    command and finding the location of the filesystem. From the serial console, issue
    the following commands:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中找到挂载点的最佳方式是运行 `mount` 命令并找到文件系统的位置。从串行控制台发出以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the mount point is `/sys/fs/selinux`. Let''s go to that directory
    by issuing the following command at the serial terminal prompt:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，挂载点是 `/sys/fs/selinux`。让我们通过在串行终端提示符下发出以下命令进入该目录：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You are now in the root of the SELinux filesystem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在位于 SELinux 文件系统的根目录。
- en: Interrogating the filesystem
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询文件系统
- en: 'You can interrogate SELinuxFS to find out what the kernel''s highest supported
    policy version is. This is useful when you begin to work with systems you did
    not build from source. It is also useful when you do not have direct access to
    the KConfig file. It is important to note that both DAC and MAC permissions apply
    to this filesystem. With respect to MAC and SELinux, the access vectors for this
    are enumerated in class security in the policy file located at `external/sepolicy/access_vectors`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 SELinuxFS 来查询内核支持的最高策略版本。这在您开始使用非源码构建的系统时非常有用。当您没有直接访问 KConfig 文件时，这也很有用。需要注意的是，DAC
    和 MAC 权限都适用于此文件系统。关于 MAC 和 SELinux，此文件系统的访问向量在位于 `external/sepolicy/access_vectors`
    的策略文件中的类安全部分中列出：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the previous command, and in several commands to follow, we do not just print
    the files with the `cat` command. This is because these files do not have a trailing
    newline at the end of the file. Without the newline, the command prompt following
    the command's execution would be at the end of the last line of the output. Wrapping
    the `cat` command with `echo` guarantees a newline. An alternate way to get the
    same effect is by using `cat policyvers ; echo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令以及接下来的几个命令中，我们不仅仅使用 `cat` 命令打印文件。这是因为这些文件在文件末尾没有换行符。没有换行符，命令执行后的命令提示符会位于输出最后一行的末尾。使用
    `echo` 将 `cat` 命令包装起来可以保证有换行。另一种达到相同效果的方法是使用 `cat policyvers ; echo`。
- en: 'As we expected, the supported version is 23\. As you recall, we set this value
    in [Chapter 4](ch04.html "Chapter 4. Installation on the UDOO"), *Installation
    on the UDOO* while configuring the kernel to enable SELinux using `make menuconfig`
    from the `kernel_imx` directory. This is also accessible by the `libselinux` API:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所料，支持的版本是 23。如您所回忆的，我们在 [第 4 章](ch04.html "第 4 章。在 UDOO 上安装") *在 UDOO 上安装*
    中设置了此值，当时在 `kernel_imx` 目录中使用 `make menuconfig` 配置内核以启用 SELinux。这也可以通过 `libselinux`
    API 访问：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It should not require any elevated permissions and is readable by anyone on
    the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该需要任何提升的权限，并且可以被系统上的任何人读取。
- en: The enforce node
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执法节点
- en: 'In previous chapters, we discussed that SELinux operates in two modes, **enforcing**
    and **permissive**. Both modes log policy violations, however, enforcing mode
    causes the kernel to deny access to the resource and return an error to the calling
    userspace process (for example, `EACCESS`). SELinuxFS has an interface to query
    this status—the file node `enforce`. Reading from this file returns the status
    `0` or `1` depending on whether we are running in permissive or enforcing mode,
    respectively:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了 SELinux 在两种模式下运行，**执行** 和 **宽容**。两种模式都会记录策略违规，然而，执行模式会导致内核拒绝访问资源，并将错误返回给调用用户空间进程（例如，`EACCESS`）。SELinuxFS
    有一个接口可以查询此状态——文件节点 `enforce`。从该文件读取返回的状态是 `0` 或 `1`，分别取决于我们是否在宽容或执行模式下运行：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, our system is in permissive mode. Android has a toolbox command
    for printing this as well. This command returns the status `Permissive` or `Enforcing`
    depending on whether we are running in a permissive or enforcing mode, respectively:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的系统处于宽容模式。Android 也有一个工具箱命令来打印这个状态。该命令返回的状态是 `Permissive` 或 `Enforcing`，分别取决于我们是否在宽容或执行模式下运行：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also write to the `enforce` file. The DAC permissions for this filesystem
    are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以写入 `enforce` 文件。此文件系统的 DAC 权限是：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Anyone can get the enforcing status, but to set it, you must be the root user.
    The MAC permission required for this is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以获取执行状态，但要设置它，您必须是 root 用户。为此所需的 MAC 权限是：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A command called `setenforce` can change the status:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `setenforce` 的命令可以更改状态：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To see what the command does, run it in `strace`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看命令的作用，请在 `strace` 中运行它：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the interface to `enforce` is as simple as writing `0` or `1`.
    The function in `libselinux` to do this is `int security_setenforce(int value)`.
    Another interesting artifact of the preceding command is we can see `procfs` was
    accessed. SELinux has some additional entries in `procfs` as well. Those will
    be covered further in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`enforce` 的接口就像写入 `0` 或 `1` 那么简单。在 `libselinux` 中执行此操作的函数是 `int security_setenforce(int
    value)`。前述命令的另一个有趣之处是我们可以看到 `procfs` 被访问。SELinux 在 `procfs` 中还有一些额外的条目。这些将在本章中进一步讨论。
- en: The disable file interface
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用文件接口
- en: SELinux can also be disabled at runtime using the `disable` file interface.
    However, the kernel must be built with `CONFIG_SECURITY_SELINUX_DISABLE=y`. Our
    kernel was not built with this option. This file is write only by owner and has
    no specific MAC permission associated with it. We recommend keeping this option
    disabled. Additionally, SELinux can be disabled before a policy is loaded. Even
    when the option is enabled, once a policy is loaded, it is disabled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 还可以通过 `disable` 文件接口在运行时禁用。但是，内核必须使用 `CONFIG_SECURITY_SELINUX_DISABLE=y`
    选项构建。我们的内核没有使用此选项。此文件只能由所有者写入，并且没有与之关联的特定 MAC 权限。我们建议保持此选项禁用。此外，SELinux 可以在加载策略之前禁用。即使选项已启用，一旦加载了策略，它就会被禁用。
- en: The policy file
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略文件
- en: 'The `policy` file lets you read the current SELinux policy file that was loaded
    into the kernel. This can be read and saved to disk:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`policy` 文件允许您读取已加载到内核中的当前 SELinux 策略文件。这可以读取并保存到磁盘：'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By enabling the `adb` interface, you can now extract it from the device and
    analyze it on the host with the standard SELinux tools. The DAC permissions on
    this file are owner: `root`, `read`. There is no SELinux permission specific to
    this file.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用 `adb` 接口，您现在可以从设备中提取它，并在主机上使用标准的 SELinux 工具进行分析。此文件的 DAC 权限是所有者：`root`，`read`。没有针对此文件的特定
    SELinux 权限。
- en: 'The inverse to the `policy` file is the `load` file. We have seen this file
    appear when the policy file is loaded by init using the `libselinux` API:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`policy` 文件的逆操作是 `load` 文件。我们已经看到当策略文件通过 `libselinux` API 被 init 加载时，该文件会出现：'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The null file
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空文件
- en: The `null` file is used by SELinux to redirect unauthorized file accesses when
    domain transitions occur. Remember that a domain transition is when you transition
    from one context to another. In most cases, this occurs when a program performs
    a fork and exec function, but this could happen programmatically. In either case,
    the process has file references it can no longer access, and to help keep processes
    from crashing, they just write/read from the SELinux null device.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 文件在域转换发生时被 SELinux 用于重定向未经授权的文件访问。请记住，域转换是指从一个上下文转换到另一个上下文。在大多数情况下，这发生在程序执行
    fork 和 exec 函数时，但这也可能以编程方式发生。在任何情况下，进程都有它无法访问的文件引用，为了帮助防止进程崩溃，它们只是从 SELinux 的空设备中读写。'
- en: The mls file
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mls 文件
- en: 'One of the capabilities our system has is that our current policy is using
    **multilevel security** (**MLS**) support. This is either `0` or `1`, based on
    whether the loaded policy file is using it. Since we have it enabled, we would
    expect to see `1` from this file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统的一个能力是，我们当前的策略正在使用**多级安全**（**MLS**）支持。这取决于加载的策略文件是否使用它，是`0`或`1`。由于我们已启用它，我们预计从这个文件中看到`1`：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `mls` file is readable by all and has a corresponding SELinux API:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`mls`文件对所有用户可读，并有一个相应的SELinux API：'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The status file
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态文件
- en: 'The `version` file allows a mechanism by which you can be informed of updates
    that occur within SELinux. One such example would be when a policy reload occurs.
    A **userspace object manager** could cache decision results and use the `reload`
    event as a trigger to flush their cache. The `status` file is read only by everyone
    and has no specific MAC permissions. The `libselinux` API interface is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`文件允许一种机制，通过它可以通知您在SELinux中发生的更新。一个例子就是当策略重新加载发生时。一个**用户空间对象管理器**可以缓存决策结果，并使用`reload`事件作为触发器来刷新它们的缓存。`status`文件只能由每个人读取，并且没有特定的MAC权限。`libselinux`API接口是：'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By checking the status structure, you can detect changes and flush the cache.
    Currently, however, you are missing this API in your `libselinux`, but we'll correct
    that in [Chapter 7](ch07.html "Chapter 7. Utilizing Audit Logs"), *Utilizing Audit
    Logs*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查状态结构，您可以检测到变化并刷新缓存。然而，目前您在`libselinux`中缺少这个API，但我们在第7章[利用审计日志](ch07.html
    "第7章。利用审计日志")中会纠正这一点，*利用审计日志*。
- en: 'There are many SELinuxFS files in the file tree; our intent here was only to
    cover several files because of their importance or pertinence to what we''ve done
    and where we''re going. We did not cover:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 文件树中有很多SELinuxFS文件；我们在这里只介绍几个文件，因为它们的重要性或与我们所做的工作和目标的相关性。我们没有涵盖：
- en: '`access`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access`'
- en: '`checkreqprot`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkreqprot`'
- en: '`commit_pending_bools`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit_pending_bools`'
- en: '`context`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`'
- en: '`create`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`'
- en: '`deny_unknown`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deny_unknown`'
- en: '`member`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`member`'
- en: '`reject_unknown`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reject_unknown`'
- en: '`relabel`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relabel`'
- en: The use of these files is not simple and is typically done by userspace object
    managers that are using the `libselinux` API to abstract the complexities.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的使用并不简单，通常由使用`libselinux`API来抽象复杂性的用户空间对象管理器执行。
- en: Access Vector Cache
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问向量缓存
- en: 'SELinuxFS also has some directories you can explore. The first is `avc`. This
    stands for "Access Vector Cache" and can be used to get statistics about the security
    server in the kernel:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SELinuxFS也有一些您可以探索的目录。第一个是`avc`。这代表“访问向量缓存”，可以用来获取内核中安全服务器的统计信息：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All these files can be read with the `cat` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件都可以使用`cat`命令读取：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `cache_stats` file is readable by all and requires no special MAC permissions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_stats`文件对所有用户可读，不需要特殊的MAC权限。'
- en: 'The next file to look at is `hash_stats`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要查看的文件是`hash_stats`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The underlying data structure for the Access Vector Cache is a hash table; `hash_stats`
    lists the current properties. As we can see in the output of the preceding command,
    we have 512 slots in the table, with 284 of them in use. For collisions, we have
    the longest chain at 7 entries. This file is world readable and requires no special
    MAC permissions. You can modify the number of entries in this table through the
    `cache_threshold` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量缓存的基础数据结构是一个哈希表；`hash_stats`列出了当前属性。正如我们可以在前一个命令的输出中看到的那样，表中共有512个槽位，其中284个正在使用。对于冲突，我们有最长的链有7个条目。此文件对所有人可读，不需要特殊的MAC权限。您可以通过`cache_threshold`文件修改此表中的条目数。
- en: 'The `cache_threshold` file is used to tune the number of entries in the `avc`
    hash table. It is world readable and owner writeable. It requires the SELinux
    permission `setsecparam`, and can be written to and read from with the following
    simple commands, respectively:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_threshold`文件用于调整`avc`哈希表中的条目数。它是全球可读的，所有者可写。它需要SELinux权限`setsecparam`，可以使用以下简单的命令进行写入和读取：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can disable the cache by writing `0`. However, outside the benchmarking
    tests, this is not encouraged.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过写入`0`来禁用缓存。然而，在基准测试之外，这并不鼓励。
- en: The booleans directory
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值目录
- en: 'The second directory to look into is `booleans`. An SELinux `boolean` allows
    policy statements to change dynamically via `boolean` conditions. By changing
    the `boolean` state, you can affect the behavior of the loaded policy. The current
    policy does not define any booleans; so this directory is empty. In policies that
    define booleans, the directory would be populated with files named after each
    boolean. You can then read and write to these files to change the `boolean` state.
    The Android toolbox has been modified to include the `getsebool` and `setsebool`
    commands. The `libselinux` API also exposes these capabilities:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要检查的第二个目录是`booleans`。SELinux的`boolean`允许通过`boolean`条件动态地改变策略声明。通过改变`boolean`状态，您可以影响加载的策略的行为。当前策略没有定义任何`boolean`；因此这个目录是空的。在定义了`boolean`的策略中，这个目录会被填充以每个`boolean`命名的文件。然后您可以读取和写入这些文件来改变`boolean`状态。Android工具箱已经被修改，包括`getsebool`和`setsebool`命令。`libselinux`
    API也公开了这些功能：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Booleans are transactional. This means it is an all or nothing set. When you
    use `security_set_boolean*`, you must call `security_commit_booleans()` to make
    it take effect. Unlike Linux desktop systems, permanent booleans are not supported.
    Changing the runtime value does not persist across reboots. Also, on Android,
    if you are attempting Android **Compatibility Test Suite** (**CTS**) compliance,
    booleans will cause the tests to fail. Booleans can have varying DAC permissions
    based on the target, but they always require the SELinux permission, `setbool`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`是事务性的。这意味着它是一个全有或全无的集合。当您使用`security_set_boolean*`时，您必须调用`security_commit_booleans()`以使其生效。与Linux桌面系统不同，不支持永久`boolean`。改变运行时值不会在重启之间持久化。此外，在Android上，如果您正在尝试Android**兼容性测试套件**（**CTS**）合规性，`boolean`会导致测试失败。`boolean`可以根据目标具有不同的DAC权限，但它们始终需要SELinux权限`setbool`。'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You must pass the Android Compatability Test Suite for Android branding. More
    on CTS can be found at [https://source.android.com/compatibility/cts-intro.html](https://source.android.com/compatibility/cts-intro.html).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须通过Android兼容性测试套件（Android branding）测试。更多关于CTS的信息可以在[https://source.android.com/compatibility/cts-intro.html](https://source.android.com/compatibility/cts-intro.html)找到。
- en: The class directory
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`class`目录'
- en: 'The next directory to look at is `class`. The `class` directory contains all
    the classes defined in the `access_vectors` SELinux policy file or via the `class`
    keyword in the SELinux policy language. For each class defined in the policy,
    a directory exists with the same name. For instance, run the following on the
    serial terminal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要查看的目录是`class`。`class`目录包含在`access_vectors` SELinux策略文件中定义的所有类，或者通过SELinux策略语言中的`class`关键字。对于策略中定义的每个类，都存在一个具有相同名称的目录。例如，在串行终端上运行以下命令：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see from the preceding command, there are quite a few directories.
    Let''s examine the `property_service` directory. This directory was chosen because
    it is only one defined on Android. However, the files present in each directory
    are the same and include `index` and `perms`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的命令中可以看到，有很多目录。让我们来检查一下`property_service`目录。这个目录被选中是因为它是在Android上唯一定义的。然而，每个目录中存在的文件是相同的，包括`index`和`perms`：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The mapping between string and some arbitrary integer that is defined in the
    SELinux kernel module is `index`. A directory that contains all the permissions
    possible for that class is `perms`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux内核模块中定义的字符串和某些任意整数之间的映射是`index`。包含该类所有可能权限的目录是`perms`：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `set` access vector is available for the `property_service`
    class. The `class` directory can be very beneficial to observe a policy file already
    loaded in a system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`set`访问向量对`property_service`类可用。`class`目录可以非常有益于观察系统中已加载的策略文件。
- en: The initial_contexts directory
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`initial_contexts`目录'
- en: 'The next directory entry to peer into is `initial_contexts`. This is the static
    mapping of the initial security contexts, better known as **security identifier**
    (**sid**). This map tells the SELinux system which context should be used to start
    each kernel object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要查看的目录条目是`initial_contexts`。这是初始安全上下文的静态映射，也称为**安全标识符**（**sid**）。这个映射告诉SELinux系统应该使用哪个上下文来启动每个内核对象：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can see what the initial sid for `file` is by performing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下操作来查看`file`的初始sid：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This corresponds to the entry in `external/sepolicy/initial_sid_contexts`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于`external/sepolicy/initial_sid_contexts`中的条目：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The policy_capabilities directory
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`policy_capabilities`目录'
- en: 'The last directory to look into is `policy_capabilities`. This directory defines
    any additional capabilities the policy might have. For our current setup, we should
    have:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要查找的目录是 `policy_capabilities`。此目录定义了策略可能具有的任何附加功能。对于我们的当前设置，我们应该有：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each file entry contains a boolean indicating whether the feature is enabled:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件条目都包含一个布尔值，指示该功能是否启用：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The entries are readable by all and writeable by none.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 条目对所有用户都是可读的，但对所有用户都是不可写的。
- en: ProcFS
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProcFS
- en: 'We alluded to some of the procfs interfaces that are being exported. Much of
    what is discussed is the security contexts, so that means the shell should have
    some security context associated with it... but how do we achieve this? Since
    this is a general mechanism that all LSMs use, the security contexts are both
    read and written through procfs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了一些正在导出的 procfs 接口。所讨论的大部分内容是安全上下文，这意味着 shell 应该与一些安全上下文相关联...但我们如何实现这一点？由于这是一个所有
    LSM 都使用的通用机制，安全上下文是通过 procfs 读取和写入的：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also get per-thread contexts as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以获取每个线程的上下文：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Just replace `2278` with the thread ID you want.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 `2278` 替换为您想要的线程 ID。
- en: The DAC permissions on the current file are read and write for everyone, but
    those files are typically very restricted by MAC permissions. Typically, only
    the process that owns the procfs entry can read the files, and you must have both
    standard write permissions and a combination of `setcurrent`. Note that the "from"
    and "to" domains must be allowed using a **dyntransition**. To read, you must
    have `getattr`. All of these permissions are attained from the security class,
    `process`. The `libselinux` API functions `getcon` and `setcon` allow you to manipulate
    `current`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文件上的 DAC 权限对所有人都是可读和可写的，但这些文件通常受到 MAC 权限的严格限制。通常，只有拥有 procfs 条目的进程可以读取这些文件，并且您必须同时拥有标准写权限和
    `setcurrent` 的组合。请注意，“from” 和 “to” 域必须通过 **dyntransition** 允许。要读取，您必须拥有 `getattr`。所有这些权限都是从安全类
    `process` 获得的。`libselinux` API 函数 `getcon` 和 `setcon` 允许您操作 `current`。
- en: 'The `prev` file can be used to find the previous context you switched from.
    This file is not writeable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev` 文件可用于查找您之前切换的上下文。此文件不可写：'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our serial terminal's former domain or security context was `u:r:init:s0`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们串行终端之前的有效域或安全上下文是 `u:r:init:s0`。
- en: The `exec` file is used to set the label for children processes. This is set
    before running an exec. All the permissions on these files are the same with respect
    to the MAC permissions used to actually set them. The caller attempting to set
    this must also hold `setexec` from the `process` class. The libselinux API `int
    setexeccon(security_context_t context)` and `int getexeccon(security_context_t
    *context)` can be used for setting and retrieving the label.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 文件用于设置子进程的标签。这在进行 `exec` 之前设置。这些文件上的所有权限与实际设置它们时使用的 MAC 权限相同。尝试设置此权限的调用者必须也持有
    `process` 类的 `setexec`。libselinux API 中的 `int setexeccon(security_context_t context)`
    和 `int getexeccon(security_context_t *context)` 可用于设置和检索标签。'
- en: 'The `fscreate`, `keycreate`, and `sockcreate` files do similar things. When
    a process creates any one of the corresponding objects, `fs` objects (files, named
    pipes, or other objects), keys, or sockets, the values set here are used. The
    caller must also hold `setfscreate`, `setsockcreate`, and `setkeycreate` from
    the `process` class. The following SELinux API is used to alter these:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`fscreate`、`keycreate` 和 `sockcreate` 文件执行类似的事情。当进程创建相应的对象之一时，即 `fs` 对象（文件、命名管道或其他对象）、密钥或套接字，这里设置的值将被使用。调用者还必须持有
    `process` 类的 `setfscreate`、`setsockcreate` 和 `setkeycreate`。以下 SELinux API 用于更改这些：'
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Where `*` can be `fs`, `key`, or `socket`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `*` 可以是 `fs`、`key` 或 `socket`。
- en: It's important to note that these special `process` class permissions give you
    the ability to change the `proc/attr` file. You still need to get through the
    DAC permissions and any SELinux permissions set on the file objects themselves.
    Then and only then do you need the additional permission, such as `setfscreate`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些特殊的 `process` 类权限赋予您更改 `proc/attr` 文件的权限。您仍然需要通过 DAC 权限以及文件对象上设置的任何
    SELinux 权限。然后，并且只有在这种情况下，您才需要额外的权限，例如 `setfscreate`。
- en: Java SELinux API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java SELinux API
- en: Similar APIs to the C APIs discussed previously exist for Java as well. In this
    case, it is assumed you will build the code with the platform, as these are not
    public APIs shipped with the Android SDK. The API is located at `frameworks/base/core/java/android/os/SELinux.java`.
    However, this is a very limited subset of the API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的C API相似的API也存在于Java中。在这种情况下，假设你将与平台一起构建代码，因为这些API不是与Android SDK一起发布的公共API。API位于`frameworks/base/core/java/android/os/SELinux.java`。然而，这只是API的一个非常有限的子集。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the interface between the kernel and userspace
    with respect to SELinux, and reinforced the concepts of access vector class and
    security context. In the next chapter, we will perform some upgrades to our system
    and look at the audit logs getting one step closer to our ultimate goal—an operable
    device in SELinux enforcing mode. We say operable because we can put it in enforcing
    mode now. However, if you do it now via `setenforce 1` on a UDOO, your device
    will become unstable. On our system, for example, the browser fails to launch
    if we do this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与SELinux相关的内核与用户空间之间的接口，并强化了访问向量类和安全上下文的概念。在下一章中，我们将对我们的系统进行一些升级，并查看审计日志，逐步接近我们的最终目标——在SELinux强制模式下可操作的设备。我们称之为可操作，因为我们现在可以将其置于强制模式。然而，如果你现在通过在UDOO上执行`setenforce
    1`，你的设备将变得不稳定。例如，在我们的系统中，如果我们这样做，浏览器将无法启动。
