- en: Chapter 4. Design Patterns with Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing into a log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a factory of musical notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a home automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivering some pizzas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When object-oriented programming was introduced, the developers noticed that
    there were some objects or classes that were programmed following the same philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Xerox labs, for example, introduced the Model-View-Controller pattern in the
    70s to develop programs using SmallTalk. A few other patterns were introduced
    by Xerox, but they were not called this.
  prefs: []
  type: TYPE_NORMAL
- en: When a book called *Design Patterns* was released in 1994, written by the Gang
    of Four, it brought solutions for common engineering problems. It demonstrated
    that the main problem with software development costs was maintenance; the usage
    of design patterns would cause a high cost in the first phase of software development
    but it would significantly reduce the maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, design patterns are so important that it is very common to talk about
    them in job interviews. If you are experienced in Swift or Objective-C, you've
    already used some of these patterns without realizing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover a few design patterns; if possible, we will look
    at some common samples of these patterns in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start, I''d like to comment that design patterns are very questionable
    nowadays; for example, the singleton pattern that is shown in the *Writing into
    a log file* recipe of this chapter was criticized by some developers because it
    is very easy to implement, and this is also the reason some programmers avoid
    this pattern. Others don''t think that way, they think that you can use it, but
    only at the right moment, as the author explains in this URL: [http://www.ibm.com/developerworks/library/co-single/](http://www.ibm.com/developerworks/library/co-single/).
    Anyway, arguing about this topic is out of the scope of this book. I will show
    you some patterns, and then you can decide whether to use them and when.'
  prefs: []
  type: TYPE_NORMAL
- en: Another detail I'd like to comment on is that some examples can look more complicated
    than those without patterns. Don't forget that design patterns are not based on
    simplicity, but in software maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Writing into a log file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is about a very simple and also a very common pattern design: the
    Singleton pattern. The idea of this pattern is to have an object with only one
    instance. You''ve already used this pattern in Swift or Objective-C, for example,
    when you used UIDevice or UIApplication.'
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will create an object that will write out logs into a file.
    Note that it doesn't matter where we are in our application code, we should write
    only into one single file using one single object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we will write into a file, you will probably like to see its contents after
    running the application. Before we start, let's check whether we are able to see
    the destination folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the simulator, open the Finder window and go to your home directory;
    you can use the shortcut *command* + *shift* + *H*. If you can''t see a folder
    called `Library`, you have to press *command* + *J* to show the view options.
    Now, check the **Show Library Folder** option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you won't have the application if you haven't run it yet, so on your
    `viewDidLoad` method, paste the code `print(NSHomeDirectory())` to know your path,
    and then you can follow it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An easy way to open the document folder of the application is to print the home
    directory and copy it. Then, you can go to the **Finder** application, press *command*
    + *shift* + *G* and paste your path.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a small calculator and record the user actions. Remember that we
    don't need to instantiate the logger object every time we use the log; as it will
    be a singleton, you can call it from anywhere. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a project called `Chapter 4 Log File` and create a file called `Log.swift`.
    Here is where we will define our log class. Copy the following code into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, of course, we need to complete our application to check the usage of our
    code. Go to the storyboard and add two text fields (each of them will represent
    a number), a segmented control that will represent the current operator, a button
    to show the result, and a label where the result will be displayed. Your layout
    should be similar to the following one:![How to do it…](img/00039.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s code the view controller. First, let''s add the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Don''t forget to link each graphic component with its attribute. Now, it''s
    time to code our program methods; in this case, we will develop a method to save
    the chosen operator and another to show the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish our application, we should add a little bit of code on our application
    delegate. Filling these events will register when the user has opened the application,
    put the application on in the background, and returned to the application. Here
    is the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, click on play and test the program; then, press the Home button and come
    back to the application. When you are done, go to the application documents folder,
    as demonstrated at the beginning, and open the file `application.log`. Note that
    every action was registered on the same file; it doesn't matter if it was an event
    produced by the app delegate or by the view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see the introduction of the access control. Swift has
    three access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: In this level, the object, attribute, or global variable can be
    used from anywhere, even from another module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: In this level, the corresponding entity can be accessed from
    anywhere, except from another module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: In this level, the entity can be accessed only from the current
    file, even from the same module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the idea of a singleton is to make sure that there will be only
    one instance of a class. As the initializer of the class is private, it can't
    be called from anywhere, but only from a method or function that is in the current
    file.
  prefs: []
  type: TYPE_NORMAL
- en: So, we created a method called `getInstance` to access the only instance we
    have, and then we can access the object methods. Notice that we had to use classes;
    if we used structs, we would break the rule of one object only.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you will see the implementation of a singleton accepting nil values,
    such as `private var myLogInstance:Log?`, and then initializing it inside the
    `getInstance` method, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that some software architects think that you don't have to start
    your application instantiating every singleton object, except when you are going
    to use it. There are some singleton objects that are never called, and you shouldn't
    waste this memory. If you notice, this class also had a deinitializer. Technically
    speaking, this method won't be called if you are running your application on iOS
    because iOS apps usually don't finish. However, the application can still end
    in certain circumstances, and you might close the file handle in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when talking about file usage, first of all, we have to know what the application
    document's folder path is, because this is the location we have chosen for writing
    the log file. There is a function called `NSSearchPathForDirectoriesInDomains`
    that returns the full path of a requested folder (actually, it returns an array
    of paths). After calling this function, we can create the file with the file manager
    and open it using `NSFileHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t use paths by concatenating with the home directories in this manner:
    `NSHomeDirectory() + /Documents`. Apple can change its path in future versions
    like it did with the bundle on iOS 8.'
  prefs: []
  type: TYPE_NORMAL
- en: If this class wasn't a singleton, you wouldn't open this file here; you would
    open and close it every time you had to write a message because you must avoid
    having two open handles for the same file. Opening and closing a handle is a slow
    operation; it can affect your application performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of writing into the log file with a high frequency, you will have
    to avoid clashing the file writing or opening, but if you have a singleton, this
    problem is much easier to control.
  prefs: []
  type: TYPE_NORMAL
- en: To finish this recipe, I would like to comment that this simple log system is
    based on real log systems used in applications. Usually, log files try to register
    the log level, such as info, error, warning or debug, and its time. With this
    information in mind, you can filter your log when it gets bigger and figure out
    what is going on when the application has crashed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution we had for our singleton application was to keep the object instance
    on a global variable; the ideal solution for this pattern is keeping it on a class
    variable, also called a static attribute. Swift 2 introduced support for static
    attributes so we no longer have to worry about this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a factory of musical notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing music with computers is something very common nowadays. Creating software
    that allows a musician to create his own music looks easy but it is not, mainly
    because there are lots of possibilities for each note.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the pattern **Abstract Factory**. This pattern will
    allow us to change the note type that we want to create, and it will also initialize
    the note type for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may know, there are a lot of note symbols; you can check this URL on
    Wikipedia if you want to know more about it: [http://en.wikipedia.org/wiki/List_of_musical_symbols](http://en.wikipedia.org/wiki/List_of_musical_symbols).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for this recipe, we will work with three types of notes: the drum
    quarter note, the piano quarter note, and the quarter rest note. Of course, this
    is only an example; in a real program, you will probably have to complete it with
    tied notes, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a project called `Chapter 4 Musical Notes`; now, download the pictures
    that correspond to this recipe from the Internet. In this case, we have these
    pictures: `staff.png`, `quarter_rest.png`, `cnote.png`, `dnote`, `cdrum.png`,
    and `ddrum.png`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will also need some MP3 sounds for this recipe. Download three sounds for
    the piano notes and another three for the drums; of course, we won't have any
    sound for the rest note.
  prefs: []
  type: TYPE_NORMAL
- en: Place the pictures that were downloaded into your `images.xcassets` folder.
    If you like, you can also add the same pictures with different resolutions for
    use in different resolution devices (iPad and iPhone).
  prefs: []
  type: TYPE_NORMAL
- en: Before you start, we will just need to add a framework called `AVFoundation`.
    This will enable our app to play sounds. To do this, just click on the project
    navigator, then click on build phases. After this, expand the **Link binary with
    Libraries** section, then click on the plus button. Select **AVFoundation** and
    click on **Add**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we will start with the models. First, let''s create a note protocol,
    as we know that in future we can have more than one type of note and we should
    be prepared for it. So, create a new file called `NoteProtocol.swift` and put
    the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create an implementation of this protocol. Create a file
    called `MusicalNote.swift` and add the following content into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have implemented our note class, see to it that this note is not
    piano-specific or drum-specific; we only need to build it in a different way according
    to the note type and step. So, now we need to define a factory of notes. With
    the same logic we applied before, we now need to create a protocol of a note.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only method that we will define is `createNote`, and it needs to know the
    note step (C, D, or E) and its position on the staff. It''s time to create a new
    file called `AbstractNoteFactory.swift` and type the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have the definition of a note factory, we can start creating our own
    factories. Let''s start with the simplest one: `SilenceFactory`; this factory
    will create only one kind of note, no matter its step. Type this code in a file
    called `SilenceFactory.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this class, we will save some steps for when we need to create a new silent
    note. Following the same logic, let''s create the piano factory and the drum factory.
    Use this code to create the piano factory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now, let''s create the drum factory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good, it's time to create our layout. For this recipe, we will need to add a
    staff (the image view), which is where the notes will be displayed, a segmented
    control that will let us choose the note factory we want, and a play button that
    will appear after we create 10 notes and which will allow us to hear our music.![How
    to do it…](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won't allow the user to play the music before it is completely composed.
    For this reason, the play button must start as invisible. To do this, after adding
    the button to the view on the storyboard, click on it, go to the attribute inspector,
    and select the **Hidden** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you know, we now have to link the segmented control and the button with
    its attribute. Let''s also add other attributes that are necessary for this app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we had to specify the factory type as `AbstractNoteFactory`; if
    not, it will be declared as `SilenceFactory`, and it won't allow us to change
    the factory type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s add the possibility to tap on the staff and add a note. To do this,
    we will add the following code on `viewDidLoad`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, every time we tap on the screen, we have to check whether it
    is in a place where we can add a note. Let''s implement this gesture action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, when we tap on the screen, we just ask for a new note; it doesn''t
    matter which one is the current factory. Now, the segmented control will change
    the current factory when the user wants it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish this app, we have to create an event for the play button. As we are
    not going to press the button for each note, we will initialize the timer and
    create a method to play each note after half a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, click on play and compose your music.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Abstract Factory pattern saves us from performing a lot of steps after instantiating
    an object. As a programmer, we don't need to worry about the class that the object
    needs to use, only the base class; in this case, it created an object of the `NoteProtocol`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: As every factory implements the same protocol, we don't need to check which
    the current factory is. We can also create new factories, and the code change
    wouldn't be painful.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create another creational pattern that will allow us to create a home
    automation simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a home automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technology is getting more and more popular every day; soon we will control
    even our door locks from our mobile phones. However, how does it work? Imagine
    when you walk into your living room, a sensor can detect that there is someone
    there and it will turn on the light. Also, if a barometer detects that it is going
    to rain, it can close the home windows. The examples mentioned here are good samples
    of objects that change their status and tell other objects about this change.
    For this case, we will use the pattern **Observer**, also known as the **publisher-subscriber**
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a sample of a home with only two windows, a door
    lock, and a clothes line. To make it simple, the application will read the sensor
    information from a file.
  prefs: []
  type: TYPE_NORMAL
- en: When we receive information from the radar, it may be that someone is approaching
    your home. In this case, the door lock must be locked and the windows should be
    closed, or when this person goes away, the windows can be opened again. Also,
    when the barometer detects that it is going to rain, the windows must be closed
    and the clothes line must collect the clothes. When the rain stops, these robots
    can do the opposite action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new project called `Chapter 4 Observer`. My first idea for this
    recipe was to create a list of actions into a file, but as with a few actions,
    it will be enough; we will create an array with actions instead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create the simplest model, which in our case is the door lock.
    Basically, the only thing that we need to do here is to store its status, which
    can be opened or closed. So, create a file called `DoorLock.swift` and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we''ve done the previous code, we can do something similar with the clothes
    line, so put the following code into a new file called `ClothesLine.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, now we need our last accessory, that is, the window. In this case, we have
    to store the count of times it was closed. Imagine that two people approach our
    house and one of them goes away; we have to keep the window closed because there
    is another person still near our house. So, create a file called `Window.swift`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good, now it''s time to create the radar. Remember that the radar needs to
    store some objects that will notify the status change, so we will create a nested
    class called `RadarObserver`. Start adding this class into a new file called `Radar.swift`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This feature can be added because we are creating a nested class; Swift doesn't
    allow us to create nested protocols. Now, create the methods that store or remove
    the observers. We will not remove any observer in this recipe but, as I told you
    earlier, always be prepared for the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of this class is the methods that change the object status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we''ve understood it, we can create the barometer following the philosophy
    which we have used here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, now we can create our display. For this recipe, we will add five labels,
    one for each accessory and one to show the last action. We also need a button
    to start simulating the reception of radar and barometer events. You will see
    a view similar to the following one:![How to do it…](img/00041.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s link these components with the corresponding attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s go to the view controller and let''s start completing the attributes.
    In this case, we need a radar, a barometer, two windows, a door lock, a clothes
    line, a list of actions that will be performed, and a timer to make the simulation
    easier for our eyes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a private function that will update the labels. This function
    is an auxiliary function, so we don''t need to repeat this code in every observer
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, on our `viewDidLoad` method, we will add the observer''s code. The following
    code only has the creation of the first two observers; you have to complete it
    following the same rule because it will be exhausting showing all of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can complete creating the simulator, the event of our button, which
    will initialize the actions and the timer, and a function that will be called
    by the timer and perform the corresponding action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's done now! Click on play and watch it work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the main goal of an observer is to execute an action, and to
    do this we used closures. This Swift feature is equivalent to blocks on Objective-C
    and function variables in JavaScript. A closure knows where the object was created
    and can access its attributes even if it was stored in another object.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, when the radar or the barometer detects something different,
    it will notify every observer who has subscribed to it. Each observer acts over
    the corresponding accessory (window, door lock, or that thing called a clothes
    line). Note that if we would like to write a traditional object method, it will
    be necessary to create new classes that inherit from the same observer and store
    in it the attribute that it is going to use. It wouldn't be a bad implementation,
    but using closures is much easier and more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Martin Fowler fan, you have probably noticed that some code here
    is very similar to the barometer observer and the radar observer. This is what
    Mr. Martin calls the smell of a code, meaning that the code doesn't need to be
    technically wrong to still smell bad.
  prefs: []
  type: TYPE_NORMAL
- en: That would be true in this case, except that this is just an example. Remember
    that in real life, the radar would probably have to notify you of the intruder's
    position, and the barometer would need to notify you of the precipitation, making
    the notifier's methods incompatible.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already learned about behavioral patterns and creational patterns. In the
    next recipe, we will use a structural pattern, creating new object types based
    on a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering some pizzas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have to create a new window type which will have a border;
    the first idea is borrowed from a window class, creating a new class called `BorderedWindow`.
    You can do the same thing with scroll bars; call it `ScrolledWindow`. Now, if
    we need to create a window with a scroll and border, we have to create a new class
    called `ScrolledAndBorderedWindow`, but imagine that we now need to add a double
    and triple bordered window, which will have lots of combinations.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this kind of problem, there is a pattern called **decorator**; this
    pattern allows us to create new object types based on a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project called `Chapter 4 Pizzas` and add the pizza image into
    `Images.xcassets`. Now, let's heat up the oven and prepare some pizzas.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s execute these steps to deliver some pizzas:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a base class that defines a pizza, so create a
    new file called `Pizza.swift` and create the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this class stores the price and the pizza or ingredient name.
    Now, we can define some pizzas with their prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file called `PizzaDecorators.swift`; here is where we will create
    the extra ingredients. First, we need to create a class that defines what a pizza
    decorator is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add some extra ingredients. In this case, we will have jalapeños,
    cheese, mushrooms, and olives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Good! Once you're done with that, we can create the view. We will add one label
    to display the total, four buttons for the extra ingredients, one text view to
    display the ingredients that we've already added to our pizza, and an Image View
    to make our application happier. At the end, we should have a layout similar to
    the one shown here:![How to do it…](img/00042.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create the view controller. Let''s start with the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s ask the user to select the pizza that he wants. In this case, we need
    to do it on `viewDidAppear` because we will do it with an action sheet, and this
    component doesn''t work on the `viewDidLoad` method because the view is not ready
    to display action sheets yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create a method called `refreshPrice`; it is as easy as this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish our application, we have to add the events that belong to the buttons;
    don''t forget to link them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the application is done, press play, choose a pizza, add some ingredients
    and enjoy your meal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorator pattern allows us to create a new object based on another one,
    which is very useful to prevent the creation of uncontrolled numbers of classes
    based on combinations of features.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more patterns. You can check them out on Wikipedia ([http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)).
    Check which ones are the best for your project. There is also another feature
    called anti-pattern, which explains common bad practices. In the next chapter,
    we will learn how to work with concurrent code with Swift, something that is very
    common nowadays, mainly if you like to develop games.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the first version of Swift, you were able to extend classes, structs,
    and enums using extensions. This is a very powerful feature and allows you, the
    developer, to fine tune existing types to better meet your application needs.
    With Swift 2.0, Apple has included a new feature: protocol extensions. It is easy
    to only think of this as a small feature; however, it has the power to transform
    the way you write your code. Apple is calling this new paradigm protocol-oriented
    programming. In this recipe, we will learn how to take advantage of this new feature
    and some new patterns compared to object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, create a new playground titled `Chapter 4 Protocols`. We will
    be using a playground only for this recipe, so do not worry about any project
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create two protocols and a struct that conforms to these two
    protocols, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With OOP, we could have created a single superclass with all properties and
    subclasses when needed. However, this would result in a more complex superclass
    and each subclass would contain properties/functionality that it does not need.
    By defining `Flyable` and `Transportable` as protocols, we can have custom data
    types inherit from multiple sources instead of a single superclass. Now that we
    have some basic protocols, it''s time to actually extend them. Let''s extend the
    `Flyable` protocol to check whether another `Flyable` object is faster. Add this
    code to your playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is important to note another new feature related to protocol extensions:
    default behaviors. If you look at our previous implementation, you will notice
    that we defined a method rather than declare one. Standard protocols require the
    conforming object to define each method, but with Swift 2.0, we can provide a
    default implementation so other classes do not have to.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create another extension, but only for types that also conform to the
    Transportable protocol. Add this code to your playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Self` keyword with a capital `S` represents that class or structure that
    is conforming to the protocol. In this case it means the `Plane` class. Using
    this simple combination, you can see how useful protocol extensions can be with
    custom types. The real power of protocol extensions comes from your ability to
    extend the Swift Standard Library. Let's take a look.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the protocol extension feature with the Swift Standard Library allows
    us to add functionality to existing protocols such as `Equatable` and `CollectionType`
    (arrays and dictionaries).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s add functionality to `CollectionType` to get the average speed of `Flyable`
    types in an array. Add this code to your playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This protocol extension defines the `averageTopSpeed` method. The implementation
    is pretty simple. We define a count and total variable and then iterate through
    each item in the collection and add to the total while incrementing count. We
    have to manually increment count because `CollectionType` has a different property
    type for count (rather than `Int`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because protocols provide more flexibility, you can create more finely tuned
    code to fit each of your application's needs. For the most power, utilize custom
    type protocol extensions as well as extending the Swift Standard Library extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Note how we are creating a struct for `Plane` rather than an object. This highlights
    one issue with OOP involving object reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have two objects: A and B. A creates some set of data and then shares
    this data with object B by reference. This means two different objects are referencing
    the same data object. B then changes some of this data. Now, object A may find
    data with changes it does not know how to handle. This may seem like a small issue
    but can cause many problems, even in simple applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, structs are passed by value instead of reference. In our previous
    example, object A would have copied the data rather than pass a reference to it,
    thus each object would have its own copy that does not interfere with the other.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you would like to learn more or better understand why you would want to use
    protocol extensions and protocol-oriented programming, check out the WWDC 2015
    video titled *Protocol-Oriented Programming in Swift* ([https://developer.apple.com/videos/play/wwdc2015-408/](https://developer.apple.com/videos/play/wwdc2015-408/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
