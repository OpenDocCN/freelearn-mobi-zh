<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;SpriteKit Basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. SpriteKit Basics</h1></div></div></div><p>After an entire chapter of theory, we have finally reached the chapter where we will be creating a game. I am sure that this is a moment you have been waiting for and your fingers are aching to write some code and make a game.</p><p>In this chapter, you will create a small and basic game using SpriteKit. We will see how to create the main menu of the game, and you will learn how to transition from the main menu scene to the gameplay scene, where all of the gameplay code will be written.</p><p>In the gameplay scene, we will add sprites, such as the background and hero, first. We will then create a small physics engine to make the hero move around. Then, we will add in the enemies, and move them too. Next, we will make the hero and the enemies shoot at each other. We will detect collision between the hero's rockets and the enemies, and between the enemies' bullets and the hero. For each enemy the hero shoots, we will get one point, but if any of the enemies go past the left of the screen, it will be game over. If the current high score is greater than the previous score saved, then your current score will be saved as the new high score. Once the game is over, the player can click on the button to go back to the main menu to start the game. I hope you are excited! Let's finally jump in.</p><p>The topics covered in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to SpriteKit and SKScene</li><li class="listitem" style="list-style-type: disc">Adding a main menu scene and a gameplay scene</li><li class="listitem" style="list-style-type: disc">Adding and moving the Hero sprite</li><li class="listitem" style="list-style-type: disc">Creating interactivity with touches</li><li class="listitem" style="list-style-type: disc">A simple physics engine</li><li class="listitem" style="list-style-type: disc">Spawning enemies</li><li class="listitem" style="list-style-type: disc">Firing hero rockets and enemy bullets</li><li class="listitem" style="list-style-type: disc">Collision detection</li><li class="listitem" style="list-style-type: disc">Scoring and game over conditions</li><li class="listitem" style="list-style-type: disc">Displaying, saving, and retrieving the score</li></ul></div><div class="section" title="Introduction to SpriteKit and SKScene"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Introduction to SpriteKit and SKScene</h1></div></div></div><p>We have already<a id="id316" class="indexterm"/> seen in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, how to create a SpriteKit project. Just <a id="id317" class="indexterm"/>to jog your memory, I will show you once again how to create a project. Click on <span class="strong"><strong>Xcode</strong></span>, and then on <span class="strong"><strong>Create a new Xcode Project</strong></span>. Then, on the left-hand side panel, navigate under <span class="strong"><strong>iOS</strong></span>, and then under <span class="strong"><strong>Application</strong></span> and select <span class="strong"><strong>Game</strong></span>. Then click on <span class="strong"><strong>Next</strong></span>. Give a new name to the project. Select the language as <span class="strong"><strong>Swift</strong></span>, the game technology as <span class="strong"><strong>SpriteKit</strong></span>, the device as <span class="strong"><strong>iPad</strong></span>, and then click on <span class="strong"><strong>Next</strong></span>. Select the location where you want the project folder to be created and click on <span class="strong"><strong>Create</strong></span>.</p><p>You will see that the majority of the project structure remains similar to the SingleView project we saw in the previous chapter. We have the <code class="literal">GameScene.sks</code>, <code class="literal">GameScene.swift</code>, and <code class="literal">GameViewController.swift</code> files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GameScene.sks</code>: This is a serialized <code class="literal">SpriteKitScene</code> file. This is used to create SKScenes visually <a id="id318" class="indexterm"/>without writing code. So, for example, you can drag-and-drop images and design them as buttons, and by clicking on them, you can make them perform different functions. But since we will be writing it all in code, we won't be using this file to create the interface of the game.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GameScene.swift</code>: This is inherited <a id="id319" class="indexterm"/>from SKScene. SKScenes are the building blocks of games. This class is called once the application view is loaded. You can create SKScene files to create the main menu Scene, gameplay scene, options scene, and so on. In fact, we will later rename the <code class="literal">GameScene.swift</code> file to <code class="literal">MainMenuScene.swift</code> and create a new scene called <code class="literal">GamePlayScene</code>, where will write our gameplay code.<div class="mediaobject"><img src="graphics/B04014_04_01.jpg" alt="Introduction to SpriteKit and SKScene"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">GameViewController.swift</code>: This<a id="id320" class="indexterm"/> class is similar to the <code class="literal">ViewController.swift</code> file we saw in the previous chapter. In the <code class="literal">Main.Storyboard</code> file, you will see that there is a <code class="literal">GameViewControllerScene</code> file instead of <code class="literal">ViewController</code>, but the structure is very similar to it. If you click on <span class="strong"><strong>GameViewController</strong></span>, you can see that it calls the <code class="literal">GameViewController</code> class on the <span class="strong"><strong>Utility</strong></span> panel under the <span class="strong"><strong>Identity</strong></span> inspector. Refer to the preceding diagram.</li></ul></div><p>Now, open the <code class="literal">GameViewController.swift</code> file. You will see some new functions and some older <a id="id321" class="indexterm"/>functions that we saw in <code class="literal">ViewController.swift</code>. You will also notice that <a id="id322" class="indexterm"/>SpriteKit has been imported. We will need to import SpriteKit in all the classes in which we want to use its features. All classes and objects that are part of SpriteKit start with the prefix <code class="literal">SK</code>, so SpriteKit Scenes are <code class="literal">SKScene</code>, sprites are <code class="literal">SKSpriteNode</code>, and so on.</p><p>A <code class="literal">SpriteKitNode</code> or <code class="literal">SKNode</code> is the basic building block required for creating any content in SpriteKit, but unlike an <code class="literal">SKScene</code> or <code class="literal">SKSpriteNode</code>, it doesn't draw any visual content. However, both <code class="literal">SKScene</code> and <code class="literal">SKSpriteNode</code> are child classes of <code class="literal">SKNode</code>. So, if <code class="literal">SKScene</code> is the building block of any game, <code class="literal">SKNode</code> is the basic building block of SpriteKit itself. A detailed explanation is provided under the SpriteKit section in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>.</p><p>After importing the SpriteKit, we see that an extension of SKNode is created with a class function called <code class="literal">unarchivedFromFile</code>, which takes a string and returns an SKNode. The following function is used to load the <code class="literal">.sks </code>file we saw earlier:</p><div class="informalexample"><pre class="programlisting">extension SKNode {
    class func unarchiveFromFile(file : NSString) -&gt; SKNode? {
        if let path = NSBundle.mainBundle().pathForResource(file, ofType: "sks") {
            var sceneData = NSData(contentsOfFile: path, options: .DataReadingMappedIfSafe, error: nil)!
            var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)
            
            archiver.setClass(self.classForKeyedUnarchiver(), forClassName: "SKScene")
            let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as GameScene
            archiver.finishDecoding()
            return scene
        } else {
            return nil
        }
    }
}</pre></div><p>After the<a id="id323" class="indexterm"/> extension, we see the actual class of <code class="literal">GameViewController</code>. It is<a id="id324" class="indexterm"/> still inheriting from <code class="literal">UIViewController</code>. Similar to the <code class="literal">ViewController.swift</code> file, the first function called here is <code class="literal">viewDidLoad</code>, which is the function that is called as soon as the view gets loaded. The <code class="literal">super.viewDidLoad</code> function is called, which calls the <code class="literal">viewDidLoad</code> of the parent class. Then, the <code class="literal">GameScene.sks</code> file is loaded using the extension that was created earlier. The <code class="literal">if let</code> statement checks if the object scene is empty or not. If it is not empty, then the code in the <code class="literal">if</code> block will be executed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<code class="literal">extension</code>: In Swift, you can add functionality to an existing class. In the preceding case, we are adding a new function called <code class="literal">unarchivedFromFile</code> to the <code class="literal">SKNode</code> class, which unarchives files and returns an SKScene. This function is used to unarchive the <code class="literal">SKS</code> file in the <code class="literal">viewDidLoad</code> function in the following code.</p><p>
<code class="literal">if let</code>: This checks if the object scene is empty or not. If it is not empty, then the code in the <code class="literal">if</code> block will be executed.</p><p>
<code class="literal">as</code>: This operator is used to downcast SKView since it is actually a subclass of <code class="literal">UIView</code>.</p></div></div><div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()

        if let scene = GameScene.unarchiveFromFile("GameScene") as? GameScene {
            // Configure the view.
            
            let skView = self.view as SKView
            skView.showsFPS = true
            skView.showsNodeCount = true
            
            /* Sprite Kit applies additional optimizations to improve rendering performance */
            skView.ignoresSiblingOrder = true
            
            /* Set the scale mode to scale to fit the window */
            scene.scaleMode = .AspectFill
            
            skView.presentScene(scene)
        }
    }</pre></div><p>A new variable, <code class="literal">skView</code> is created and the current view is assigned to it by type casting it as an SKView since the root view of <code class="literal">GameViewController</code> is an SKView.</p><p>Then, the <a id="id325" class="indexterm"/>
<code class="literal">showsFPS</code> and <code class="literal">showsNodeCount</code> properties of the scene are set to <code class="literal">true</code>, which <a id="id326" class="indexterm"/>will show the <span class="strong"><strong>FPS</strong></span> and <span class="strong"><strong>Node Count</strong></span> on the bottom-right of the screen.</p><p>The <code class="literal">ignoreSiblingOrder</code> property is set to <code class="literal">true</code>, meaning that if one or more objects are at the same depth, then it won't prioritize between them and all objects will be drawn at the same depth.</p><p>The value of <span class="strong"><strong>Z order,</strong></span> or depth order, decides which object is at the front and which object is at the back of the screen. The object with the smallest <span class="strong"><strong>Z</strong></span> value is kept at the back of the screen and the object the with highest value is the closest to the screen. If no Z order value is assigned to an object, SpriteKit will assume that this object is above the previous object added. That is why in all games, the background is added first so that it is at the lowest Z order and other objects such as the hero are added next. If you were to add the hero first and then the background, the hero would be at the lowest Z order and the background image that covers the whole screen would be above it. You might think that there is something wrong with the code or SpriteKit since the hero is not being displayed only the background. The fact is that the hero is there but he is behind the background. So, be careful about Z orders as this may lead to bugs or unexpected results in games.</p><p>After setting the order, we can set the <code class="literal">scaleMode</code> property of the scene. Here, by default, it has been set to <code class="literal">AspectFill</code>. There are four modes: <code class="literal">AspectFill</code>, <code class="literal">Fill</code>, <code class="literal">AspectFit</code>, and <code class="literal">ResizeFill</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AspectFill</code>: This is the default<a id="id327" class="indexterm"/> mode when you create a new project. In this scale, both <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> scale factors are calculated and the large-scale factor is chosen to fill the view and maintain aspect ratio of the image. This will lead to cropping of the scene.<p>Let us create a project and place characters at the top-right and bottom-left corners, and observe what happens when we move from the landscape mode to the portrait mode.</p><p>In the landscape mode, both characters are displayed as they should be. One at the bottom left and the other at the top-right corner of the screen, as<a id="id328" class="indexterm"/> shown in <a id="id329" class="indexterm"/>the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_02.jpg" alt="Introduction to SpriteKit and SKScene"/></div><p>But in the portrait mode, they<a id="id330" class="indexterm"/> have gone out of bounds of the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_03.jpg" alt="Introduction to SpriteKit and SKScene"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fill</code>: Both<a id="id331" class="indexterm"/> <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes are scaled to fill the view. The view is the region<a id="id332" class="indexterm"/> that is shown once you click on the view in the <code class="literal">Main.Storyboard</code> file. The aspect ratio of the image will change both in <a id="id333" class="indexterm"/>terms of the width and height, to fill the view.<p>If we do the same test with <code class="literal">.Fill,</code> once again in landscape mode, the images appear to be normal, but in the portrait mode, the two images are in their respective locations, but they are squashed to fit, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_04.jpg" alt="Introduction to SpriteKit and SKScene"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">AspectFit</code>: Instead<a id="id334" class="indexterm"/> of the upper scale factor, the lower scale factor will be<a id="id335" class="indexterm"/> chosen to maintain the aspect ratio of the scene. This may<a id="id336" class="indexterm"/> lead to letterboxing of the scene, but all the content of the scene will be displayed and will be visible in view.<p>With this mode, once again everything looks fine in the landscape mode, but then in the portrait mode, the image is not at all squared; the whole scene is scaled down to fit to the width of the screen. This will cause letterboxing on the top and bottom of the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_05.jpg" alt="Introduction to SpriteKit and SKScene"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">ResizeFill</code>: The scene<a id="id337" class="indexterm"/> is not scaled at all. It is just resized to fit the view. The <a id="id338" class="indexterm"/>images will maintain the original size and <a id="id339" class="indexterm"/>aspect ratios.<p>Here, since the aspect ratio and scale are maintained, the bottom-left image is shown at the right position but the top-right image goes out of bounds of the screen, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_06.jpg" alt="Introduction to SpriteKit and SKScene"/></div></li></ul></div><p>Looking at the <a id="id340" class="indexterm"/>preceding screenshots of the four modes, we can see that not all sizes fit all. You<a id="id341" class="indexterm"/> need to tinker with the scale mode to best suit the needs of your game. Since our game is primarily designed to be played in the landscape mode, we will just disable the portrait mode. So, in the main project node, disable the <span class="strong"><strong>Portrait</strong></span> mode and <span class="strong"><strong>Upside Down</strong></span> by unchecking it in the <span class="strong"><strong>General</strong></span> tab, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_07.jpg" alt="Introduction to SpriteKit and SKScene"/></div><p>We will also be using <code class="literal">ResizeFill</code> as we will be providing separate images for Retina and NonRetina assets of the <a id="id342" class="indexterm"/>devices, so that aspect ratio is not affected, resulting in nice full-screen images instead of cropped or scaled images. So, in the <code class="literal">GameViewController</code> class, change the scale mode to <code class="literal">ResizeFill</code> as follows:</p><div class="informalexample"><pre class="programlisting">            /* Set the scale mode to scale to fit the window */
            scene.scaleMode = .ResizeFill</pre></div><p>Finally, the scene is loaded and presented using the <code class="literal">presentScene</code> function of the <code class="literal">skView</code> object.</p><p>Once the <code class="literal">GameScene.swift</code> file is presented, the <code class="literal">didMoveToView</code> function is called, which, as we saw in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting Started</em></span>, shows the <code class="literal">SKLabelNode</code> label showing the <span class="strong"><strong>Hello, World!</strong></span> text, and each time you click on the screen, the <code class="literal">touchesBegan</code> function gets called, and at the location of the touch, a SKSpriteNode is created and an action is run on it.</p><p>There are <a id="id343" class="indexterm"/>three new functions: the <code class="literal">shouldAutoRotate</code> function, which is set to <code class="literal">true</code>, and <a id="id344" class="indexterm"/>will rotate the view if the device is rotated; the <code class="literal">supportedInterfaceOrientation</code> function, which checks for the orientation and aligns view accordingly; and the <code class="literal">prefersStatusBarHidden</code> function, which hides status bar elements, such as network and battery indicators on the top of the screen. You can enable or disable them depending upon your needs.</p><p>We will now change the <code class="literal">GameScene</code> to start making our game.</p></div></div>
<div class="section" title="Adding a main menu scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Adding a main menu scene</h1></div></div></div><p>Let us make some <a id="id345" class="indexterm"/>changes to the <code class="literal">GameScene</code> class to make it our main menu scene:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Rename the file to <code class="literal">MainMenuScene.swift</code> by selecting the file in the project hierarchy in the project navigator.</li><li class="listitem">Change the name of the class in the file to <code class="literal">MainMenuScene</code>.</li><li class="listitem">Delete all the lines of code inside <code class="literal">didMoveToView</code>.</li><li class="listitem">In the <code class="literal">touchesBegan</code> function, delete the code related to the adding of the sprite and the running of the action upon it.</li><li class="listitem">Delete the <code class="literal">update</code> function as it is not required for the main menu scene. If required, we will add it later.</li></ol></div><p>The <code class="literal">MainMenuScene.swift</code> file should look like the following code snippet, as we deleted all the code from the <code class="literal">didMoveToView</code> function and modified the <code class="literal">touchedBegan</code> function:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class MainMenuScene: SKScene {
    
    override func didMoveToView(view: SKView) {
        
    }
    
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        /* Called when a touch begins */
        
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
         
        }
    }
}</pre></div><p>Delete the <code class="literal">GameScene.sks</code> file from the project hierarchy by moving it to <span class="strong"><strong>Trash</strong></span>.</p><p>We also need to make <a id="id346" class="indexterm"/>some changes to the <code class="literal">GameViewController.swift</code> file as well.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Delete the extension created for SKNode</li><li class="listitem">Remove the <code class="literal">if let</code> scene line and the opening and closing bracket since we will be calling the <code class="literal">MainMenuScene</code> class directly through code.</li><li class="listitem">Replace the above line with <code class="literal">let scene = MainMenuScene(size: view.bounds.size)</code>. The SKScene constructor takes the size of the screen, so here we get it from the <code class="literal">bounds.size</code> property of the view.</li><li class="listitem">Change <code class="literal">.AspectFill</code> to <code class="literal">.ResizeFill</code>.</li></ol></div><p>The rest of the file can remain the same. Now the <code class="literal">viewDidLoad</code> function should look like the following code:</p><div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        
        super.viewDidLoad()
        
            let scene = MainMenuScene(size: view.bounds.size)
     
            // Configure the view.
            
            let skView = self.view as SKView
            skView.showsFPS = true
            skView.showsNodeCount = true
            
            /* Sprite Kit applies additional optimizations to improve rendering performance */
            skView.ignoresSiblingOrder = true
            
            /* Set the scale mode to scale to fit the window */
            scene.scaleMode = .ResizeFill
            
            skView.presentScene(scene)        
    }</pre></div><p>Let's start adding <a id="id347" class="indexterm"/>content to the main menu scene next.</p><p>In the <code class="literal">MainMenuScene.swift</code> file in the <code class="literal">didMoveToView</code> function, we will first add the background image, then we will add a label that will display the name of the game, and then we will finally add the play button, which, if clicked, will launch <code class="literal">GamePlayScene</code> and start the game.</p><p>To add the background image, add the following code:</p><div class="informalexample"><pre class="programlisting">let BG = SKSpriteNode(imageNamed: "BG")
BG.position = CGPoint(x: viewSize.width/2, y: viewSize.height/2)
self.addChild(BG)</pre></div><p>We create a constant variable called <code class="literal">BG</code> and assign an image set named <code class="literal">BG</code> to it. Then, we position this image. For positioning the image, we need the size of the view. It is very simple to get the width and height of the view. We create a new constant called <code class="literal">viewSize</code> of type <code class="literal">CGView</code> and assign <code class="literal">view.bounds.size</code> to it. So, add the following at the start of the <code class="literal">didMoveToView</code> function:</p><div class="informalexample"><pre class="programlisting">let viewSize:CGSize = view.bounds.size</pre></div><p>We can now set the position of <code class="literal">BG</code>. To set the position, we assign <code class="literal">BG.position</code> equal to half of the width and half of the height of the size of the view. Whenever we need to assign or create a new <code class="literal">CGPoint</code> variable, we have to call CGPoint, and in the brackets provide the <code class="literal">x</code> and <code class="literal">y</code> values separated by a comma. The <code class="literal">x</code> value needs to be prefixed with <code class="literal">x</code> and then a colon and, similarly, the <code class="literal">y</code> value needs to be prefixed with <code class="literal">y</code> followed by a colon.</p><p>For the background to get displayed, we will have to call the <code class="literal">addChild</code> function on self, and pass in the background created.</p><p>If you run the game now, it will give errors as we have still not assigned an actual image to the project. For this, go to the <code class="literal">Resources</code> folder of this chapter and copy all the assets onto the desktop. This will contain all the assets that will be used in this chapter.</p><p>Now, go to the <code class="literal">Images.xcassets</code> file in your project navigator, and right-click on the panel and select <span class="strong"><strong>New Image Set</strong></span>, as shown in the following screenshot. A new file called <code class="literal">Image</code> will be created. Select and rename it to <code class="literal">BG</code>. When we call <code class="literal">BG</code> while creating the sprite for the background, we are actually referring to this file. So, if you name it incorrectly, the code will give errors.</p><div class="mediaobject"><img src="graphics/B04014_04_08.jpg" alt="Adding a main menu scene"/></div><p>The file has<a id="id348" class="indexterm"/> placeholders for <span class="strong"><strong>1x</strong></span>, <span class="strong"><strong>2x</strong></span>, and <span class="strong"><strong>3x</strong></span> images. Since we are making the game for the iPad, there are only two resolutions we have to worry about; the 1024 x 768 and 2048 x 1536 resolutions. Our BG is also of the same two resolutions. In the <code class="literal">Resources</code> folder, look for image files <code class="literal">Bg.png</code> and <code class="literal">Bg2.png</code>. Drag <code class="literal">Bg.png</code> to the <span class="strong"><strong>1x</strong></span> box and <code class="literal">Bg2.png</code> to the <span class="strong"><strong>2x</strong></span> box, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_09.jpg" alt="Adding a main menu scene"/></div><p>Now you can run the application and the screen will display the background image in all its glory. On the simulator, you can select <span class="strong"><strong>iPad2</strong></span> or <span class="strong"><strong>iPadAir</strong></span>, and you will see the image will fill the entire screen, as shown in the following screenshot. Make sure you are running in the landscape mode.</p><div class="mediaobject"><img src="graphics/B04014_04_10.jpg" alt="Adding a main menu scene"/></div><p>Next we will add<a id="id349" class="indexterm"/> the label to display the name of the game. Labels are used to display text onto the screen. Add the following code to display the label right after we added the BG to the scene:</p><div class="informalexample"><pre class="programlisting">let myLabel = SKLabelNode(fontNamed:"Chalkduster")

myLabel.text = "Ms.TinyBazooka"

myLabel.fontSize = 65

myLabel.position = CGPoint(x: viewSize.width/2, y: viewSize.height * 0.8)

self.addChild(myLabel)</pre></div><p>We create a new <a id="id350" class="indexterm"/>constant called <code class="literal">myLabel</code> and call the constructor of <code class="literal">SKLabelNode</code>. It takes the name of the font we want to use to create the text, so we pass in <code class="literal">Chalkduster</code>, which is one of the default fonts in Mac. In <code class="literal">myLabel.text</code>, we pass in the actual text that we want to display. Next we assign the size of the font, its position, and add it to the current class as a child. To create text, we don't have to create an image set but we have to have the font in the system as it is automatically taken from the system's font directory.</p><p>Let us create the play button next. In the <code class="literal">Resources</code> folder, you will find <code class="literal">playBtn.png</code> and <code class="literal">playBtn2.png</code>. Similar to how we created an image set for <code class="literal">BG</code>, create one for the play button by naming the file <code class="literal">playBtn</code>. Drag the <code class="literal">playBtn.png</code> image to <span class="strong"><strong>1x</strong></span> and <code class="literal">playBtn2.png</code> to <span class="strong"><strong>2x</strong></span>.</p><p>For all the assets in the <code class="literal">Resources</code> folder, you will find two of each, one with the filename and the second one ending with a <code class="literal">2</code> at the end. Make sure, henceforth, that the regular filename asset is assigned to <span class="strong"><strong>1x</strong></span> and one with the <code class="literal">2</code> at the end of the file is assigned to <span class="strong"><strong>2x</strong></span>.</p><p>Now appropriate images are assigned to the <code class="literal">playBtn</code> image set. Add the following code right under where we added the code for the label:</p><div class="informalexample"><pre class="programlisting">let playBtn = SKSpriteNode(imageNamed: "playBtn")

playBtn.position = CGPoint(x: viewSize.width/2, y: viewSize.height/2)

self.addChild(playBtn)

playBtn.name = "playBtn"</pre></div><p>The <code class="literal">playBtn</code> image set is also a regular SKSpriteNode, so similar to how we added <code class="literal">BG</code>, we will assign the <code class="literal">playBtn</code> image set to the <code class="literal">playBtn</code> constant. Position it at the center of the view and then add it to the view.</p><p>In addition to what we do usually, I have also assigned a name to the <code class="literal">playBtn</code> constant so that we can refer to it later, if needed. It is not necessary that you assign a string; you can even assign an integer value if you wish. It should be named something that you find easy to remember and associate the constant with.</p><p>Now, if you build and run the project, it should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_11.jpg" alt="Adding a main menu scene"/></div><p>Next, we will add <a id="id351" class="indexterm"/>code in the <code class="literal">touchesbegan</code> function to check whether the play button was pressed. In the <code class="literal">touchesbegan</code> function, we first check whether any object was touched on the screen, and then, if it was touched, we get the location of the touch. After getting the location, we add the following code:</p><div class="informalexample"><pre class="programlisting">   let _node:SKNode = self.nodeAtPoint(location)
            
   if(_node.name == "playBtn"){
               
      let scene = GamePlayScene(size: self.size)
      self.view?.presentScene(scene)
}</pre></div><p>We create a new constant called <code class="literal">_node</code> of type <code class="literal">SKNode</code> and get the node that is at the touched location. We then check whether the name of the node pressed is <code class="literal">playBtn</code>, if it is pressed, then we create a constant named <code class="literal">scene</code> and assign <code class="literal">GameplayScene</code> to it, and then present the scene like we presented <code class="literal">MainMenuScene</code> in the <code class="literal">GameViewController</code> class. Since we have not created <code class="literal">GamePlayScene</code>, you will get an error. Don't worry, we will be creating it in the next section.</p><p>The question mark<a id="id352" class="indexterm"/> after <code class="literal">self.view</code> checks if the view is empty or not. If it is empty, it will give an error, but since the view exists, it won't give an error. Let us create the gameplay scene so that we don't get errors saying that it doesn't exist.</p></div>
<div class="section" title="Adding a gameplay scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Adding a gameplay scene</h1></div></div></div><p>All this time, we have been modifying <a id="id353" class="indexterm"/>the files already included with the base project. Now we will create a new file in the project. Right-click on the base project folder and click on <span class="strong"><strong>New File</strong></span>:</p><div class="mediaobject"><img src="graphics/B04014_04_12.jpg" alt="Adding a gameplay scene"/></div><p>In the left panel, select <span class="strong"><strong>iOS</strong></span> and select the Swift file, and then click on <span class="strong"><strong>Next</strong></span>. It will ask for the name of the file, call it <code class="literal">GamePlayScene</code> and click on <span class="strong"><strong>Create</strong></span>. This will create an empty Swift file.</p><p>Add the following code in it. This is the basic structure required whenever you create a new scene file:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class GamePlayScene: SKScene {
    
   required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    
} // required init
    
    override init(size: CGSize){
        
        super.init(size: size)

    } //init function

} //class end</pre></div><p>We first import SpriteKit, and<a id="id354" class="indexterm"/> then we create the class using the <code class="literal">class</code> keyword followed by the name of the class and inherit from <code class="literal">SKScene</code>.</p><p>Then we have the <code class="literal">required init</code> function after that. Since superclass <code class="literal">SKScene</code> implemented it, it has to be included in all the subclasses. This is a requirement, so there is no avoiding it, but we won't be using it for anything as we will be using the regular <code class="literal">init</code> function.</p><p>The regular <code class="literal">init</code> function of an SKScene takes in the size of the view. Then we have to make sure we call the <code class="literal">super.init</code> function and pass the size of the view in it as well.</p><p>That's it, and we are ready to add some gameplay code in this class. You can check in the <code class="literal">MainMenuScene.swift</code> file that there are no errors and code is building properly.</p><p>In the <code class="literal">GamePlayScene.swift</code> file, first we have to create a global variable for the <code class="literal">viewSize</code>. So, between the class and the required <code class="literal">init</code> function, add <code class="literal">let viewSize:CGSize!</code> to make <code class="literal">viewSize</code> a global variable. Also, we use <code class="literal">let</code> instead of <code class="literal">var</code> as we know that the size of the view won't change in the middle of the game.</p><p>Since we are not initializing the constant here, we have to use an exclamation mark at the end to tell Swift that we will initialize it and we know that the type that we will initialize will be <code class="literal">CGSize</code>.</p><p>Initialize <code class="literal">viewSize</code> equal to the size that got passed in the <code class="literal">init</code> function. Add the following line after <code class="literal">super.init</code> is called:</p><div class="informalexample"><pre class="programlisting">viewSize = size</pre></div></div>
<div class="section" title="Adding a background and a hero"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Adding a background and a hero</h1></div></div></div><p>We are going add the<a id="id355" class="indexterm"/> background first, so we can copy and paste the same code from the <code class="literal">MainMenuScene</code> into the <code class="literal">init</code> function right after where we initialized <code class="literal">viewSize</code>:</p><div class="informalexample"><pre class="programlisting">let BG = SKSpriteNode(imageNamed: "BG")
BG.position = CGPoint(x: viewSize.width/2, y: viewSize.height/2)
self.addChild(BG)</pre></div><p>Next we will add the <a id="id356" class="indexterm"/>hero sprite. Similar to how we created the <code class="literal">BG</code> image asset, create a new asset called <code class="literal">hero</code> and assign <code class="literal">hero.png</code> and <code class="literal">hero2.png</code> to the <span class="strong"><strong>1x</strong></span> and <span class="strong"><strong>2x</strong></span> slots.</p><p>Next we want the hero to be a global variable aswell, as we will need to refer to her outside of the <code class="literal">init</code> function. So, right under where we created the <code class="literal">viewSize</code> property, add the following line of code at the top of the class:</p><div class="informalexample"><pre class="programlisting">let hero:SKSpriteNode! </pre></div><p>Next, in the <code class="literal">init</code> function after where we added <code class="literal">BG</code>, add the following code:</p><div class="informalexample"><pre class="programlisting">hero = SKSpriteNode(imageNamed: "hero")
hero.position = CGPoint(x: viewSize.width/4, y: viewSize.height/2)
self.addChild(hero)</pre></div><p>Here, as usual, we assign the image set <code class="literal">hero</code> to the constant, assign the position, and add it to the scene.</p><p>Similar to how we positioned the background, we position the hero, but instead of adding the hero in the center, we place her at a distance of one fourth the <code class="literal">viewSize</code> from the left of the screen.</p><div class="section" title="Updating the position of the hero"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Updating the position of the hero</h2></div></div></div><p>Next, let's update the<a id="id357" class="indexterm"/> position of the hero. Let us add gravity to the scene so that she starts falling down once the game starts. For updating her position, we will use the <code class="literal">update</code> function. The <code class="literal">update</code> function gets called as soon as the class gets created and it gets called 60 times a second. So, add the <code class="literal">update</code> function to the class as follows. Call a <code class="literal">updateHero()</code> function in it, we will define this function shortly:</p><div class="informalexample"><pre class="programlisting">override func update(currentTime: CFTimeInterval) {
        
  updateHero()
}</pre></div><p>Create a new global constant after the <code class="literal">let hero</code> line called <code class="literal">gravity</code> of type <code class="literal">CGPoint</code> and initialize it with <code class="literal">x</code> value <code class="literal">0</code> and a <code class="literal">y</code> value of <code class="literal">–1</code> as gravity only affects in the negative <span class="emphasis"><em>y</em></span> direction:</p><div class="informalexample"><pre class="programlisting">let gravity = CGPoint(x:0.0, y: -1.0)</pre></div><p>We will also create a new function called <code class="literal">updateHero</code> in which we will write all the code to update the hero's position. Create this function under the <code class="literal">update</code> function and don't forget to call this function in the <code class="literal">update</code> function, otherwise the hero's position won't be updated.</p><div class="informalexample"><pre class="programlisting">    func updateHero(){
        
        hero.position.y += gravity.y
        
    }</pre></div><p>In the <code class="literal">updateHero</code> function, we <a id="id358" class="indexterm"/>are decrementing the <code class="literal">y</code> position of the hero in each update. Eventually, she will fall through the bottom of screen. To make her stay within the bounds, we check whether she is about to go beyond the screen and place her back at the bottom edge of the screen. To do this, add the following in the <code class="literal">heroUpdate</code> function right under where we decrement her position:</p><div class="informalexample"><pre class="programlisting">if(hero.position.y - hero.size.height/2 &lt;= 0){
            
        hero.position.y = hero.size.height/2
            
}else if (hero.position.y + hero.size.height/2  &gt;= viewSize.height){
            
        hero.position.y = viewSize.height - hero.size.height/2            
}</pre></div><p>In the first <code class="literal">if</code> block, we check whether the bottom of the hero has crossed the bottom of the screen. If so, then we place the hero's origin at half her height from the bottom of the screen.</p><p>In the <code class="literal">else if</code> block, we check whether the top of the hero has crossed the top of the screen. If so, then we place her at half her height from the top of the screen.</p><p>Now, if you build and run the game and press play, the hero will be at one fourth of the distance from the left of the screen and will stop once she reaches the bottom of the screen.</p><div class="mediaobject"><img src="graphics/B04014_04_13.jpg" alt="Updating the position of the hero"/></div></div><div class="section" title="Adding player controls"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Adding player controls</h2></div></div></div><p>We will now add player <a id="id359" class="indexterm"/>controls by <a id="id360" class="indexterm"/>using the <code class="literal">touchesbegan</code> function. If the player taps the left side of the screen, the hero get pushed up and will then start falling again due to gravity, and if the player taps the right of the screen, the hero will fire rockets.</p><p>For detecting touches, add the <code class="literal">touchesBegan</code> function under the <code class="literal">update</code> function as follows:</p><div class="informalexample"><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
  /* Called when a touch begins */
        
  for touch: AnyObject in touches {
       let location = touch.locationInNode(self)            
            
  }
        
}//touchesBegan </pre></div><p>This is obviously the same function that we used in <code class="literal">MainMenuScene</code> to detect touches on the play button. Since we are just going to be checking the location of the touch, we don't require the object we touched, for now at least.</p><p>To detect which side of the <a id="id361" class="indexterm"/>screen was tapped, add the following code under<a id="id362" class="indexterm"/> where we get the location of the touches in the <code class="literal">for in</code> loop:</p><div class="informalexample"><pre class="programlisting">  if(location.x &lt; viewSize.width/2){
                    
        println("[GamePlayScene] touchedLeftSide ")
                    
            
   }else if(location.x &gt; viewSize.width/2){
            
         println("[GamePlayScene] touchedRightSide ")
                
   }</pre></div><p>We check whether the <code class="literal">x</code> value of the touched location is less than half of the width of the screen. If so, then we print out that the left side of the screen was touched, otherwise we check whether the <code class="literal">x</code> value of the touched location was greater than half of the width of the screen, then in that case, we can confirm that the right of the screen was touched.</p><p>Now, to push the hero up in the air, we give her a small thrust each time the player touches the left of the screen. Add a global variable called <code class="literal">thrust</code> of type <code class="literal">CGPoint</code> and initialize both <code class="literal">x</code> and <code class="literal">y</code> values to zero as follows:</p><div class="informalexample"><pre class="programlisting">var thrust = CGPointZero</pre></div><p>Note that we are using <code class="literal">var</code> and not <code class="literal">let,</code> as the value of <code class="literal">thrust</code> will change over a period of time. Also, <code class="literal">CGPointZero</code> is just short for <code class="literal">CGPoint(x:0, y:0)</code>. They will both do the same thing, so it is just a matter of convenience and preference.</p><p>In the <code class="literal">touchesBegan</code> function, right after we checked if the left part of the screen is tapped, add the following line:</p><div class="informalexample"><pre class="programlisting">thrust.y = 15.0</pre></div><p>And in the <code class="literal">updateHero</code> function, change the line <code class="literal">hero.position.y += gravity.y</code> to the following:</p><div class="informalexample"><pre class="programlisting">thrust.y += gravity.y
hero.position.y += thrust.y

println("Thrust Y Value: \(thrust.y)")</pre></div><p>Now, whenever the left side of the screen is touched, the hero will be pushed up by 15 points and then she will start falling down after reaching the highest position. Log the value of <code class="literal">thrust.y</code> as follows to see how it works:</p><div class="informalexample"><pre class="programlisting">[GamePlayScene] touchedLeftSide 
Thrust Y Value: 14.0
Thrust Y Value: 13.0
Thrust Y Value: 12.0
Thrust Y Value: 11.0
Thrust Y Value: 10.0</pre></div><p>Once the screen is tapped, the<a id="id363" class="indexterm"/> <code class="literal">y</code> value of <code class="literal">thrust</code> that was initially set to <code class="literal">0</code> is set<a id="id364" class="indexterm"/> to <code class="literal">14</code>. It is not 15 since we are subtracting 1 from it due to gravity. Then, at each update, the <code class="literal">y</code> position of the hero is slowly decreased until it becomes zero, and gravity will start acting again and start pulling the hero down.</p><p>One thing you will notice is that when the hero is at the bottom of the screen and you apply an upward thrust, the hero doesn't immediately start moving up. The answer to why this is also visible in the console output of <code class="literal">thrust.y</code>. As the gravity is added to the <code class="literal">thrust.y</code>, its value becomes huge and the small thrust of 15 has to overcome this value to make the hero move up again. To solve this, we have to set the value of <code class="literal">thrust</code> back to zero once the hero touches the top or the bottom of the screen. So, in the <code class="literal">updateHero</code> function, where we check whether that she touched the top or bottom of the screen, add the following line in both the <code class="literal">if</code> and the <code class="literal">if else</code> blocks after setting the hero's position:</p><div class="informalexample"><pre class="programlisting">thrust.y = 0   </pre></div><p>We will next add the rockets that fire when the right side of the screen is tapped. For this, we will create a new generic class so that we can use it later for creating enemies and enemy bullets.</p><p>As we created the <code class="literal">GamePlayScene.swift</code> file, create a file called <code class="literal">MovingSprite</code>, and in this file, add the following code:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class MovingSprite{
    
    let _sprite: SKSpriteNode!
    let _speed : CGPoint!

    init(sprite: SKSpriteNode, speed: CGPoint){
        
        _sprite = sprite
        _speed = speed
            
    }//init

    

    func moveSprite(){
        
        _sprite.position.x += _speed.x
    }

}//class</pre></div><p>In this class, we import<a id="id365" class="indexterm"/> SpriteKit and then create the definition of the class. We<a id="id366" class="indexterm"/> create two global constants for holding the reference of the SKSpriteNode and CGPoint objects we will be passing into the constructor. The SKSpriteNode will hold the sprite that we will be passing in, and <code class="literal">CGPoint</code> will hold the speed with which we want the sprite to move by.</p><p>In the <code class="literal">init</code> function, we assign the objects passed in to the local objects we have created. We have added one more function called <code class="literal">moveSprite</code>. This will move the sprite with the speed that was assigned to it. That is all for this class for now. We will revisit and modify this class when we add the enemy and bullets class.</p><p>For creating the rockets, create a new function called <code class="literal">addRockets</code> in the <code class="literal">GamePlayScene</code> file. In it, we add the following code to create the rockets:</p><div class="informalexample"><pre class="programlisting">func addRockets(){
    
let rocketNode: SKSpriteNode = SKSpriteNode(imageNamed: "rocket")
rocketNode.position = CGPoint(x: hero.position.x + hero.size.width/2 + rocketNode.size.width/2,y: hero.position.y - rocketNode.size.height/2)
    
   self.addChild(rocketNode)
    
      let speed: CGPoint = CGPoint(x: 10.0, y: 0.0)
      let rocket: MovingSprite = MovingSprite(sprite: rocketNode, speed: speed)
    
}</pre></div><p>In the <code class="literal">addRockets</code> function, we first create a constant called <code class="literal">rocketNode</code> of type <code class="literal">SKSpriteNode</code> and assign a rocket from the <code class="literal">imageset</code>. So, create a new image set and name it <code class="literal">rocket</code>. In the <code class="literal">Resources</code> folder, you will find <code class="literal">rocket.png</code> and <code class="literal">rocket2.png</code>, which you can assign to the <span class="strong"><strong>1x</strong></span> and <span class="strong"><strong>2x</strong></span> slots, respectively, in the file.</p><p>Next we set the position of the rocket. Since we want the rockets to appear to be coming out of the bazooka, instead of spawning in at the position of the player, we place it at the front end of the bazooka. So, for the <code class="literal">x</code> position, we get the player's position, and then add half of the width of the player to it and also add half of the width of the rocket itself to it. For the <code class="literal">y</code> position, we get the y position of the hero and subtract half of the height of the rocket from it. We then add it to the scenes display list.</p><p>Next we create an object<a id="id367" class="indexterm"/> called <code class="literal">rocket</code> of the type <code class="literal">MovingSprite</code> and <a id="id368" class="indexterm"/>assign the speed with which we want to move the sprite and pass in the <code class="literal">rocketNode</code> we created earlier. For assigning the speed, we create a new constant called <code class="literal">speed</code> of type <code class="literal">CGPoint</code> and assign <code class="literal">10</code> and <code class="literal">0</code> to the <code class="literal">x</code> and the <code class="literal">y</code> values, respectively, so that whenever we call the <code class="literal">moveSprite</code> function of the class, the position will update in the <span class="emphasis"><em>x</em></span> direction according to the value provided.</p><p>In the <code class="literal">touchedBegan</code> function, where we checked if the right side of the screen was clicked, add the <code class="literal">addRocket</code> function to create the rocket every time the right side of the screen is tapped:</p><div class="informalexample"><pre class="programlisting">    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        /* Called when a touch begins */
        
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)

                if(location.x &lt; viewSize.width/2){
                    
                    println("[GamePlayScene] touchedLeftSide ")
                    
                    thrust.y = 15.0
                    
                }else if(location.x &gt; viewSize.width/2){
                    
                    println("[GamePlayScene] touchedRightSide ")
                    
                    addRockets()
                }
                    
            }
        }//touchesBegan</pre></div><p>Now, if you build and <a id="id369" class="indexterm"/>run, and tap on the right side of the screen, the <a id="id370" class="indexterm"/>rockets will be created, but they are not moving. To move the rockets, we have to add each rocket we created, into an array, and on each rocket we have to call the <code class="literal">moveSprite</code> function to actually move the sprites.</p><p>For updating the position of the rockets, first we have to create an array to hold all the rockets. This array needs to be a global variable so that we can easily access it. So, right under where we added <code class="literal">var thrust = CGPointZero</code> at the start of the class, add the following line of code right under it. We create an array called <code class="literal">rockets</code> to hold objects of type <code class="literal">MovingSprite</code> and we are using <code class="literal">var,</code> as it is a mutable array, meaning we will be adding and removing objects from it during the course of the game.</p><div class="informalexample"><pre class="programlisting">var rockets:[MovingSprite] = []</pre></div><p>Next, create a new function called <code class="literal">updateGameObjects</code> right under where we created the function for updating the hero, and add the following code:</p><div class="informalexample"><pre class="programlisting">func updateGameObjects(){
                    
for(var i:Int = 0; i &lt; rockets.count; i++){
                    
      rockets[i].moveSprite()            
      var sprite: SKSpriteNode = rockets[i]._sprite
if((sprite.position.x - sprite.size.width/2) &gt; 
                              viewSize.width){
                    
              sprite.removeFromParent()
              rockets.removeAtIndex(i)
        }
}
}</pre></div><p>You might be thinking, why are we using a <code class="literal">for</code> loop instead of a <code class="literal">for in</code> loop? Well this is because once the rocket goes off screen, we have to delete the object, and for removing objects from the array in Swift, we require the index of the object to be removed and the <code class="literal">for in</code> loop doesn't have that feature.</p><p>So, we create a regular <code class="literal">for</code> loop starting from <code class="literal">0</code> and go through each object in the <code class="literal">rockets</code> array by incrementing the index by 1 every time. We call the <code class="literal">moveSprite</code> function on the ith object of the array. Next, for convenience, we get the <code class="literal">spritenode</code> from the index so that we can perform some checks on it. We check whether the left edge of the rocket sprite is beyond the width of the screen, and, if so, then we remove the sprite from its parent node, which is <a id="id371" class="indexterm"/>the <code class="literal">GamePlayScene</code> as this is where we will<a id="id372" class="indexterm"/> add <code class="literal">addChild</code> in the <code class="literal">addRockets</code> function. Then, we remove the object at the current index in the rockets array by calling the <code class="literal">removeAtIndex</code> function of the array and pass in the current index.</p><p>Finally, we also need to add the objects to the array to delete it. So, in the <code class="literal">addRocket</code> function, add <code class="literal">rockets.append(rocket)</code> at the end of the function to add the rocket to the <code class="literal">rockets</code> array:</p><div class="informalexample"><pre class="programlisting">    func addRockets(){
    
        let rocketNode: SKSpriteNode = 
SKSpriteNode(imageNamed: "rocket")
        rocketNode.position = CGPoint(
                    x: hero.position.x + hero.size.width/2 +
               rocketNode.size.width/2,
                    y: hero.position.y - rocketNode.size.height/2)
                    self.addChild(rocketNode)
        
        let speed: CGPoint = CGPoint(x: 10.0, y: 0.0)
        let rocket: MovingSprite = 
   MovingSprite(sprite: rocketNode, speed: speed)
        
        <span class="strong"><strong>rockets.append(rocket)</strong></span>
    }</pre></div><p>Lastly, don't forget to call the <code class="literal">updateGameObjects</code> function in the <code class="literal">update</code> function right below where we call the <code class="literal">updateHero</code> function.</p><p>Now, when you build and run the game, you will be able to tap on the left-hand side of the screen to boost up the player and then tap on the right-hand side of the screen to shoot the rockets.</p><p>Also, take a look at the node count on the bottom right of the screen. Each time a new rocket is created, the node count will increase, and since the rockets are removed once they are off screen, the count will also decrease every time a rocket is removed from the scene.</p><p>You can also <a id="id373" class="indexterm"/>log the <code class="literal">rockets.count</code> to check how many rockets <a id="id374" class="indexterm"/>there are in the rockets array by adding the following in the <code class="literal">update</code> function:</p><div class="informalexample"><pre class="programlisting">println(" rockets count: \(rockets.count)")</pre></div><div class="mediaobject"><img src="graphics/B04014_04_14.jpg" alt="Adding player controls"/></div></div><div class="section" title="Adding enemies"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Adding enemies</h2></div></div></div><p>For the hero to be a <a id="id375" class="indexterm"/>hero, we need villains. So, we will add the enemies now. Similar <a id="id376" class="indexterm"/>to how we created the <code class="literal">addRocket</code> function, create a new function called <code class="literal">addEnemy</code>.</p><p>Also, create a new array called <code class="literal">enemies</code> just after the <code class="literal">rocket</code> array in the global variables of the <code class="literal">GamePlayScene</code> class. This adds a new array that will manage enemies, like the following:</p><div class="informalexample"><pre class="programlisting">var enemies:[MovingSprite] = []</pre></div><p>You should now have something similar to the following in your variables declarations:</p><div class="informalexample"><pre class="programlisting">  
  let viewSize:CGSize!
  let hero:SKSpriteNode!
  let gravity = CGPoint(x:0.0, y: -1.0)
  var thrust = CGPointZero
  var rockets:[MovingSprite] = []
  var enemies:[MovingSprite] = []</pre></div><p>We can now update all the enemies, update their positions and remove them when they leave the screen.</p><p>Create a new image set called <code class="literal">enemy</code> and add the <code class="literal">enemy.png</code> and <code class="literal">enemy2.png</code> to the file.</p><p>Unlike the rockets that spawn at the nozzle of the bazooka, the enemy will spawn from the right of the screen and move toward the left of the screen. They will also be spawning at different heights on the screen. It won't be challenging to the player if all the enemies spawned from the same position. So, we will create a random number, based on which we will decide at what height the enemy will be created.</p><p>Create the <code class="literal">addEnemy</code> function as follows:</p><div class="informalexample"><pre class="programlisting">func addEnemy(){
    
   var factor = arc4random_uniform(4) + 1
   var fraction = CGFloat(factor) * 0.20
   var height = fraction * viewSize.height
    
   println("enemy height: \(factor), \(fraction), \(height)")    
    
   var enemyNode:SKSpriteNode = SKSpriteNode(imageNamed: "enemy")
    
enemyNode.position = CGPoint(x: viewSize.width +   enemyNode.size.width/2, y: height)
   
self.addChild(enemyNode)
    
enemyNode.name = "enemy"
    
   let speed: CGPoint = CGPoint(x: -5.0, y: 0.0)
    
var enemy:MovingSprite = MovingSprite(sprite: enemyNode, speed: speed)
    
enemies.append(enemy)
}</pre></div><p>For creating a random<a id="id377" class="indexterm"/> number, we use the inbuilt function <code class="literal">arc4random_uniform</code>. This <a id="id378" class="indexterm"/>function takes in a value and generates a random number from <code class="literal">0</code> to one less than the number. So, in this case, since we have passed in <code class="literal">4</code>, it will create a number from <code class="literal">0</code> to <code class="literal">3</code>. Since we want a random number from <code class="literal">1</code> to <code class="literal">4</code>, we add <code class="literal">1</code> to it at the end. We assign this value to a variable called <code class="literal">factor</code>.</p><p>Then, we typecast this variable to <code class="literal">CGFloat</code> so that we can get a fraction value. Then, multiply this value by 0.20 and store it in a new variable called <code class="literal">fraction</code>. To finally get the random height at which the enemy needs to be created, we multiply the fraction with the height of the view, and assign it to a variable called <code class="literal">height</code>.</p><p>This way the enemy will be created at 20, 40, 60, or 80 percent of the height of the screen. We can't spawn the enemy at 0 percent or at 100 percent of the height since then, either the top or the bottom part of the enemy wouldn't be visible, because the anchor point for sprites are at the center of the sprite.</p><p>Now, similar to how we created the rocket, we create a new called <code class="literal">enemyNode</code> of type <code class="literal">SKSpriteNode</code> and assign the enemy image set to it. We have to place the enemy just beyond the right of the screen, so we get the width of the screen and add half the enemy width to it. For the height, we give the random height at which the enemy needs to be spawned in and add the enemy sprite to the scene. Finally, we will name the <code class="literal">enemyNode</code> sprite as <code class="literal">enemy</code> as we will need it later.</p><p>Next, since we need to create an instance of the <code class="literal">MovingSprite</code> class and provide the <code class="literal">enemySprite</code> node and speed, we will create a new <code class="literal">speed</code> object. Since this time we want the enemy to be moving in the negative <span class="emphasis"><em>x</em></span> direction, we provide the value of <code class="literal">–5</code> in the <code class="literal">x</code> direction for speed, keeping the <code class="literal">y</code> value as <code class="literal">0</code> as we don't want the enemy to be moving in the <span class="emphasis"><em>y</em></span> direction. Then, we create a new <code class="literal">MovingSprite</code> object called <code class="literal">enemy</code> and provide <code class="literal">enemySprite</code> and <code class="literal">speed</code> to it. At the end, we append the newly created enemy object to the <code class="literal">enemies</code> array so we create an array called <code class="literal">enemies</code> at the top, similar to how we created rockets for the hero.</p><p>Now we have to <a id="id379" class="indexterm"/>update through the enemy objects in the array and call<a id="id380" class="indexterm"/> <code class="literal">moveSprite</code> on the enemy to make it move in the negative <span class="emphasis"><em>x</em></span> direction. We also need to make sure that we remove the enemy sprite from the parent class and then remove the enemy object from the <code class="literal">enemies</code> array. To do this, we add the following code under where we update the player rockets in the <code class="literal">updateGameObjects</code> function:</p><div class="informalexample"><pre class="programlisting">    for(var i:Int = 0; i &lt; enemies.count; i++){
            
       enemies[i].moveSprite()
            
       var sprite: SKSpriteNode = enemies[i]._sprite
            
       if((sprite.position.x + sprite.size.width/2) &lt; 0){
                
           sprite.removeFromParent()
           enemies.removeAtIndex(i)
       }
    }//update enemies </pre></div><p>Similar to how we updated the hero rockets, we create a <code class="literal">for</code> loop and then call the <code class="literal">moveSprite</code> function on all the objects. Create a <code class="literal">sprite</code> node for convenience. Now, instead of checking if the object left from the right end of the screen, as the enemy is moving, the negative <span class="emphasis"><em>x</em></span> direction, we check whether the right edge of the enemy is beyond the left of the screen, and if so, then we remove the sprite from the parent and then remove the object from the current index in the <code class="literal">enemies</code> array.</p><p>Since we are already calling <code class="literal">updateGameObjects</code> in the <code class="literal">update</code> function, we aren't required to add it again. But we should call the <code class="literal">addEnemy</code> function after every couple of seconds to spawn the enemy.</p><p>For actually spawning the enemy, we can use an action to call the <code class="literal">addEnemy</code> function after whatever duration we want. To do this, in the <code class="literal">init</code> function, add the following under where we added the hero to the scene:</p><div class="informalexample"><pre class="programlisting">//spawn enemies after delay
let callFunc = SKAction.runBlock(addEnemy)
let delay = SKAction.waitForDuration(3.0)
let sequence = SKAction.sequence([callFunc,delay])
let addEnemyActiom = SKAction.repeatActionForever(sequence)

self.runAction(addEnemyActiom)</pre></div><p>First we create <a id="id381" class="indexterm"/>a few actions. All actions are of the type <code class="literal">SKAction</code>. The<a id="id382" class="indexterm"/> first action is <code class="literal">runBlock</code> in which we provide the function that we want to call, which is <code class="literal">addEnemy</code>. We assign this action to <code class="literal">let</code> called <code class="literal">callFunc</code>. Next we create another action called <code class="literal">waitDuration</code> and assign <code class="literal">3.0</code>, which is 3 seconds, and assign it to <code class="literal">delay</code>. The third action is a <code class="literal">sequence</code>. A <code class="literal">sequence</code> action lets you perform actions one after the other. So, here we first give <code class="literal">callFunc</code> and then <code class="literal">delay</code>. The square brackets indicate that the sequence is an array, so we can create a sequence of however many actions we want to call, by adding it to the array and then passing it into the sequence. In this sequence, the <code class="literal">callEnemy</code> function will be called first and then the action will wait for 3 seconds.</p><p>The last action is the <code class="literal">repeatActionForever</code> action and here we pass in the sequence action so that the sequence is called over and over.</p><p>Finally, we run the action on the current scene and provide <code class="literal">addEnemyAction</code>, which will eventually call the <code class="literal">addEnemy</code> function until we tell it to stop running the action.</p><p>Build and run now to see enemies popping up from the right of the screen, getting updated, and then once they leave the scene, getting deleted from the scene.</p><div class="mediaobject"><img src="graphics/B04014_04_15.jpg" alt="Adding enemies"/></div></div><div class="section" title="Adding enemy bullets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Adding enemy bullets</h2></div></div></div><p>OK. The enemy seems to <a id="id383" class="indexterm"/>be carrying a rifle of some cartoony sort but he <a id="id384" class="indexterm"/>doesn't seem to be doing anything with it. Let's make him use it. We will make the enemy shoot bullets.</p><p>Create an image set called <code class="literal">bullet</code> and assign <code class="literal">bullet.png</code> and <code class="literal">bullet2.png</code> to the <span class="strong"><strong>1x</strong></span> and <span class="strong"><strong>2x</strong></span> slots, respectively, in <code class="literal">Images.xcassets</code>. Also, create a new global variable called <code class="literal">bullets</code> of type <code class="literal">array</code> at the top of the <code class="literal">GamePlayScene</code> class as follows:</p><div class="informalexample"><pre class="programlisting">var bullets:[MovingSprite] = []  </pre></div><p>For spawning the bullets, we will be using the <code class="literal">movingSprite</code> class. But we have to make some changes to it so that as soon as the enemy is created, he starts firing away with the rifle.</p><p>So, open the <code class="literal">movingSprite</code> class and add the following in the <code class="literal">init</code> function right after we initialize the global variables. Remember that we added a name to the enemy sprite when we create it. This will come into use in the following:</p><div class="informalexample"><pre class="programlisting">if(_sprite.name == "enemy"){
            
let shootActiom = SKAction.repeatActionForever(SKAction.sequence([SKAction.runBlock(shootBullet),SKAction.waitForDuration(3.0)]))
    
_sprite.runAction(shootActiom)
}  </pre></div><p>Here we first check the<a id="id385" class="indexterm"/> name of the sprite passed in, and if it is the <a id="id386" class="indexterm"/>enemy, then we create an action similar to how we created the spawning of the enemies in the <code class="literal">GameplayScene</code> class. The difference being that, instead of creating a separate variable for each action here, we are just creating one single action called <code class="literal">shootAction</code> and calling all the actions inside it.</p><p>So, basically, we are calling a <code class="literal">shootBullet</code> function, which we will create in the same class, that will be called every 3 seconds.</p><p>After we create <code class="literal">shootAction</code>, we call the action on the sprite so that it can start calling <code class="literal">shootAction</code>.</p><p>We will define the <code class="literal">shootBullet</code> function as follows. This can be added right under where we added the <code class="literal">moveSprite</code> function.</p><div class="informalexample"><pre class="programlisting">func shootBullet(){
        
   let _gameplayScene = _sprite.parent as GamePlayScene
   _gameplayScene.addBullets(_sprite.position, size: _sprite.size)
        
} </pre></div><p>This function, in turn, will call a function called <code class="literal">addBullets</code> in the <code class="literal">GameplayScene</code>. Since we have added the hero, rockets, and enemy in the gameplay scene, it is better if we also add the bullets into the same scene, as it will be easier for us to cycle through the objects when checking for collision.</p><p>To get an instance of the <code class="literal">GameplayScene</code>, we will create a local constant called <code class="literal">_gameplayScene</code> and use the <code class="literal">.parent</code> property of the <code class="literal">SKSpriteNode</code> to get the parent class on to which the sprite was added. Since we added the enemy in <code class="literal">GameplayScene</code>, it will return <code class="literal">GameplayScene</code>. We still need to typecast it so that we use the <code class="literal">as</code> operator and typecast it to <code class="literal">GamePlayScene</code>.</p><p>Now, since we need to position the bullets properly, the same way we positioned the rockets for the hero, we will need to provide the position and size of the enemy object while creating bullets. Assuming that, we will create a function called <code class="literal">addBullets</code>, we will call this function on the <code class="literal">GamePlayScene</code> by providing the position and size of the enemy sprite.</p><p>Now, let's go to <a id="id387" class="indexterm"/>
<code class="literal">GameplayScene</code> and create the <code class="literal">addBullets</code> function as follows:</p><div class="informalexample"><pre class="programlisting">func addBullets(pos:CGPoint, size: CGSize){
        
   let bulletNode: SKSpriteNode = SKSpriteNode(imageNamed: " bullet")
        
var newPos = CGPoint(x: pos.x - size.width/2 -     
                                    bulletNode.size.width/2,
                        y: pos.y - bulletNode.size.height)
        
   bulletNode.position = newPos
   self.addChild(bulletNode)
        
   let speed: CGPoint = CGPoint(x: -10.0, y: 0.0)
   let bullet: MovingSprite = MovingSprite(sprite: bulletNode, speed: speed)
   bullets.append(bullet)
    
}  </pre></div><p>You should be quite <a id="id388" class="indexterm"/>accustomed to adding objects in SpriteKit now. Like the rockets, we create a <code class="literal">SKSpriteNode</code> called <code class="literal">bulletNode</code> and assign the bullet image set it. You know the drill.</p><p>We then create a new position, which will be at the left end of the enemy sprite. So, we take the current position of the enemy and subtract half the width of the enemy and half the <code class="literal">bulletNode</code> from the <code class="literal">x</code> position. For the <code class="literal">y</code> position, we get the <code class="literal">y</code> position of the position and subtract the full height of the bullet. In the next step, we assign this position to the position of <code class="literal">bulletNode</code>, and then we add it to the current scene.</p><p>We create a new speed variable and assign the speed with which we want the bullet to move. We create a new constant called <code class="literal">bullet</code> and provide the <code class="literal">bulletNode</code> and speed to it.</p><p>A bullets array <a id="id389" class="indexterm"/>needs to be created to append all the bullets <a id="id390" class="indexterm"/>created. So, create a new array called <code class="literal">bullets</code> that takes in <code class="literal">MovingSprite</code> and adds it to the top of the class.</p><p>After the bullet is created, append it to the <code class="literal">bullets</code> array.</p><p>We also need to update the position of the bullets and check so we can delete them once they have left the screen. So, similar to updating the enemy, we need to add the following code in the <code class="literal">updateGameObjects</code> function to update the bullets:</p><div class="informalexample"><pre class="programlisting">for(var i:Int = 0; i &lt; bullets.count; i++){
            
    bullets[i].moveSprite()
            
    var sprite: SKSpriteNode = bullets[i]._sprite
            
    if((sprite.position.x + sprite.size.width/2) &lt; 0){
                
        sprite.removeFromParent()
        bullets.removeAtIndex(i)
    }
}     </pre></div><p>So, here we go through the bullets in the array, call the <code class="literal">moveSprite</code> function, and if the sprite has gone beyond the left of the screen, we remove it from the parent and remove the object in the current index.</p><div class="mediaobject"><img src="graphics/B04014_04_16.jpg" alt="Adding enemy bullets"/></div><p>Now we have<a id="id391" class="indexterm"/> all the elements needed to go to the next stage of<a id="id392" class="indexterm"/> development, that is, to check for collisions between the hero's rockets and enemies, and between the enemy's bullets and the hero. Based on collision, we will be doing the scoring and checking for the game over condition.</p></div></div>
<div class="section" title="Collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Collision detection</h1></div></div></div><p>Collision detection in 2D games is done <a id="id393" class="indexterm"/>using the <code class="literal">intersectsNode</code> function of the sprite class itself. We can check whether the current sprite is overlapping the other sprite. In the <code class="literal">intersectsNode</code> function of the current node, we pass in a node that we want to check for collision with the current node. If there is an intersection, the function will return <code class="literal">true</code>, if not, it returns <code class="literal">false</code>.</p><p>For checking collision, we will first check the collision between the enemy's bullets and the hero. If there is collision, then the game is over. Then we will check collision between the hero's rockets and the enemies. If we detect a collision, then we have to update the score.</p><p>Also, if the enemy goes beyond the left of the screen, the game is over, so we will call the <code class="literal">GameOver</code> function in this case also.</p><p>For checking collision, create a new function called <code class="literal">checkCollision</code> in the <code class="literal">GameplayScene</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">//Hero and Bullets
 
for bullet in bullets{
            
    var sprite = bullet._sprite
            
    if(sprite.intersectsNode(hero)){
                
        GameOver()
    }
}</pre></div><p>As we wont be needing to<a id="id394" class="indexterm"/> know the index numbers, we will just use the <code class="literal">for in</code> loop to check collision.</p><p>Here we go through all the bullet objects in the <code class="literal">bullets</code> array. First, we assign the sprite of the bullet object to a local sprite variable. Then, we will call the <code class="literal">intersectsNode</code> function on the sprite to check whether it intersects the hero sprite. If it does intersect, then the <code class="literal">GameOver</code> function is called.</p><p>The <code class="literal">intersectsNode</code> function just takes the sprite of the node and checks if the box surrounding this sprite intersects with the bounding box of the sprite provided for it. If there is some overlapping, it will return <code class="literal">true</code> if the collision has occurred, or <code class="literal">false</code> otherwise.</p><p>Call the <code class="literal">checkCollision</code> function in the <code class="literal">update</code> function right after we update the hero and the game objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    override func update(currentTime: CFTimeInterval) {
        /* Called before each frame is rendered */

            updateGameObjects()
            updateHero()
            checkCollision()

    }</pre></div><p>Next, let's create the<a id="id395" class="indexterm"/> <code class="literal">GameOver</code> function. Once the game is over, we want to stop updating the hero and game objects, and stop checking for collision.</p><p>Also, create a global bool at the top of the class called <code class="literal">gameOver</code> and set it to <code class="literal">false</code>. It should be a <code class="literal">var</code> and not <code class="literal">let</code> as we will change it in the <code class="literal">GameOver</code> function:</p><div class="informalexample"><pre class="programlisting">var enemies:[MovingSprite] = []
    var bullets:[MovingSprite] = []
    <span class="strong"><strong>var gameOver = false</strong></span>
</pre></div><p>Add the <code class="literal">GameOver</code> function to the <code class="literal">GamePlayScene</code> class right after the <code class="literal">update</code> function as follows:</p><div class="informalexample"><pre class="programlisting">func GameOver(){
        
   gameOver = true
        
   self.removeAllActions()
        
   for enemy in enemies{
            
       enemy._sprite.removeAllActions()
   }
}</pre></div><p>Once the game is over, we set the <code class="literal">gameOver</code> bool to <code class="literal">false</code>. Next we call <code class="literal">removeAllActions</code> on the current class so that enemies will stop spawning, and then we also call the function on all the enemies that are currently present on the screen, so that the bullets stop spawning.</p><p>We also need to call the <code class="literal">GameOver</code> function when any of the enemies go beyond the left of the screen, so to update the position of the enemy, call the <code class="literal">GameOver</code> function in the <code class="literal">if</code> condition in the loop, as follows:</p><div class="informalexample"><pre class="programlisting">for(var i:Int = 0; i &lt; enemies.count; i++){
            
       enemies[i].moveSprite()
            
       var sprite: SKSpriteNode = enemies[i]._sprite
            
       if((sprite.position.x + sprite.size.width/2) &lt; 0){
                
           sprite.removeFromParent()
           enemies.removeAtIndex(i)
                
           <span class="strong"><strong>GameOver()</strong></span>
       }
}//update enemies</pre></div><p>In order to stop updating the hero and game objects and stop checking for collision, once the game is over, enclose the three functions in an <code class="literal">if</code> condition, as shown in the following code, where we check whether the <code class="literal">gameOver</code> Boolean value is <code class="literal">false</code> or not. If it is <code class="literal">false</code>, then the functions will get called, else it will be bypassed and won't call the functions.</p><div class="informalexample"><pre class="programlisting">override func update(currentTime: CFTimeInterval) {
   /* Called before each frame is rendered */
            if(!gameOver){

       updateGameObjects()
       updateHero()
       checkCollision()

   }
}</pre></div><p>Next, if the game is <a id="id396" class="indexterm"/>over, the player shouldn't be able to fire rockets or make the hero thrust up. So, basically, we have to disable the player controls once the game is over. So, in the <code class="literal">touchesBegan</code> function, enclose where we check which side the screen is tapped in the <code class="literal">if</code> condition, checking if the game over condition is met or not, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
   
/* Called when a touch begins */
   
   for touch: AnyObject in touches {
   
       let location = touch.locationInNode(self)
            
       let _node:SKNode = self.nodeAtPoint(location)        
            
       <span class="strong"><strong>if(!gameOver){</strong></span> //if game is not over check for touches
            
           if(location.x &lt; viewSize.width/2){
                    
               println("[GamePlayScene] touchedLeftSide ")
                    
               thrust.y = 15.0
            
           }else if(location.x &gt; viewSize.width/2){
            
               println("[GamePlayScene] touchedRightSide ")
                
               addRockets()                
           }
        <span class="strong"><strong>}</strong></span>
    }      
 }</pre></div></div>
<div class="section" title="Keeping score"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Keeping score</h1></div></div></div><p>We are still not done <a id="id397" class="indexterm"/>with the <code class="literal">checkCollision</code> function. We still need to keep track of the score. For this, we have to check the collision between the hero's rockets and the enemies. So, in the <code class="literal">checkCollision</code> function, add the following:</p><div class="informalexample"><pre class="programlisting">for(var i:Int = 0; i &lt; rockets.count; i++){
            
    var rocketSprite = rockets[i]._sprite
            
    for(var j:Int = 0 ; j &lt; enemies.count; j++){
            
        var enemySprite = enemies[j]._sprite
            
          if(rocketSprite.intersectsNode(enemySprite)){
            
            enemySprite.removeFromParent()
            rocketSprite.removeFromParent()
            
            rockets.removeAtIndex(i)
            enemies.removeAtIndex(j)
            
            score++
            
        }
    }
}</pre></div><p>We are using the <code class="literal">for</code> loop as we will need the index of the objects in the loops here. We loop through all the rockets in the scene and check the collision with all the enemies in the scene by looping <a id="id398" class="indexterm"/>through the <code class="literal">enemies</code> array. If any of the rockets collides with the enemy, then we remove both the rocket and the enemy sprite node from the scene, and also remove the rocket and enemy from the array.</p><p>Finally, create a new global variable <code class="literal">var</code> called <code class="literal">score</code> of type <code class="literal">int</code> and initialize it equal to zero at the top of the class, as shown in the following. We increase the score by 1 after checking the collision, to keep track of the score.</p><div class="informalexample"><pre class="programlisting">    var bullets:[MovingSprite] = []
    var gameOver = false
    <span class="strong"><strong>var score:Int = 0</strong></span>
</pre></div><p>We can log the score in the console to check whether the score variable is actually increasing. But how will the player know how much he/she has scored?</p><div class="section" title="Displaying the score"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Displaying the score</h2></div></div></div><p>For showing the <a id="id399" class="indexterm"/>score, we will use a <code class="literal">SKLabelNode</code> and assign the value of the score every time the score is changed. Since we will need to access this variable in the <code class="literal">checkCollision</code> function, it has to be a global variable. So, create a variable called <code class="literal">scoreLabel</code> of type <code class="literal">SKLabelNode</code> along with the other global variables at the top:</p><div class="informalexample"><pre class="programlisting">var scoreLabel: SKLabelNode!</pre></div><p>In the <code class="literal">init</code> function, right after we added the hero, we can add the following lines to initialize the <code class="literal">scoreLabel</code> variable:</p><div class="informalexample"><pre class="programlisting">scoreLabel = SKLabelNode(fontNamed:"Chalkduster")
scoreLabel.text = "Score: 0"
scoreLabel.fontSize = 45
scoreLabel.position = CGPoint(x: viewSize.width/2, y: viewSize.height * 0.9)
self.addChild(scoreLabel)</pre></div><p>We give a font name to use as the font, which is <code class="literal">Chalkdust</code>. Then we assign the actual text to be displayed. We will later change the value of this text, depending on what the score variable is later in the <code class="literal">checkCollision</code> function. We set the size to <code class="literal">45</code> and place the <code class="literal">scoreLabel</code> at 90 percent of the height of the display, so that it is at the top of the screen, and place it at the center of the width of the screen. Finally, we add the <code class="literal">scoreLabel</code> to the current scene.</p><p>If you run the game now, the text that we assigned will be displayed, but the score won't update. For the score to update, we have to change the text and assign the actual value of the score variable we created earlier.</p><p>So, right after we increment the score in the <code class="literal">checkCollision</code> function, add the following to increment the score text of the label:</p><div class="informalexample"><pre class="programlisting">rockets.removeAtIndex(i)
enemies.removeAtIndex(j)
                    
score++
                   
<span class="strong"><strong>scoreLabel.text = "Score: \(score)"  </strong></span>
</pre></div><p>Similar to how we <a id="id400" class="indexterm"/>log variables to the console, we assign the score value to the string and then pass it to the text property of <code class="literal">scoreLabel</code>. Now, if we build and run the game, it should display the current score, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_04_17.jpg" alt="Displaying the score"/></div></div></div>
<div class="section" title="Displaying the game over screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Displaying the game over screen</h1></div></div></div><p>Once the game is over, we <a id="id401" class="indexterm"/>have to display <span class="strong"><strong>GameOver!</strong></span> to the player and add a button so that the player can go back to the main menu.</p><p>In the <code class="literal">GameOver</code> function, add a label called <code class="literal">myLabel</code> after we called the function to stop all the actions:</p><div class="informalexample"><pre class="programlisting">let myLabel = SKLabelNode(fontNamed:"Chalkduster")
myLabel.text = "GameOver!"
myLabel.fontSize = 65
myLabel.position = CGPoint(x: viewSize.width * 0.5, y: viewSize.height * 0.65)
self.addChild(myLabel)</pre></div><p>We add the <span class="strong"><strong>GameOver!</strong></span> text of font size <code class="literal">65</code> so that it is easily visible to the player and place it slightly above the<a id="id402" class="indexterm"/> center of the screen to make space for the main menu button that we will be adding next.</p></div>
<div class="section" title="Adding the main menu button"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Adding the main menu button</h1></div></div></div><p>Next, in the <code class="literal">GameOver</code> function, a SKSpriteNode called <code class="literal">menuBtn</code> is created, and we pass the <code class="literal">menuBtn</code> image set to it. For <a id="id403" class="indexterm"/>creating the image set in <code class="literal">images.xcassets</code>, <code class="literal">homeBtn.png</code>, and <code class="literal">homeBtn2.png</code> are included in the <code class="literal">Resources</code> folder. We place it at the center of the screen. We also give it a name so that we can refer to it later in the <code class="literal">touchesBegan</code> function so that if it is pressed, we can call some function on it:</p><div class="informalexample"><pre class="programlisting">let menuBtn = SKSpriteNode(imageNamed: "menuBtn")
menuBtn.position = CGPoint(x: viewSize.width/2, y: viewSize.height/2)
self.addChild(menuBtn)
menuBtn.name = "menuBtn"</pre></div><p>Next, in the <code class="literal">touchesBegan</code> function, after we checked if the game is over or not, add an <code class="literal">else</code> block and add the following code to replace the current scene with the <code class="literal">MainMenuScene</code>:</p><div class="informalexample"><pre class="programlisting">else{ // else check whether main menu button is clicked
            
     let _node:SKNode = self.nodeAtPoint(location)
                
     if(_node.name == "menuBtn"){
                             
            let scene = MainMenuScene(size: self.size)
            self.view?.presentScene(scene)                    
      }
}</pre></div><div class="mediaobject"><img src="graphics/B04014_04_18.jpg" alt="Adding the main menu button"/></div><p>Similar to how we made<a id="id404" class="indexterm"/> the play button interactive, if the game is over, we check whether the player touched the screen. If the location that he tapped contains the node name <code class="literal">menuBtn</code>, we create a local object called <code class="literal">scene</code> and assign the <code class="literal">MainMenuScene</code>, and then we replace the current scene with the <code class="literal">MainMenuScene</code>.</p><p>As far as gameplay goes, we are done with it. Now let's add a feature that allows us to save the high score, so that we can challenge the player to beat it, to increase replayability of the game.</p></div>
<div class="section" title="Saving the high score"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Saving the high score</h1></div></div></div><p>For saving the high scores, we<a id="id405" class="indexterm"/> can use the <code class="literal">NSUserDefaults</code> property. Here we can use a key<a id="id406" class="indexterm"/> and assign a particular value to it which the device will store in its memory, so that we can retrieve later. The best thing about this is, we can retrieve and rewrite the value stored in it currently, to some other file. So, here we will store the high score in <code class="literal">GamePlayScene</code> and later the value stored in the key, in the <code class="literal">MainMenuScene</code>.</p><p>Since it is a dictionary, you can store integer, floats, and string. In this case, since the high score will always be an integer, we will get and store an integer for the key. The key here is a string and the value that is stored is an integer.</p><p>For retrieving the high score value, add the following code after we added <code class="literal">menuBtn</code> in the <code class="literal">GameOver</code> function:</p><div class="informalexample"><pre class="programlisting">var currentHighScore = NSUserDefaults.standardUserDefaults().integerForKey("tinyBazooka_highscore")</pre></div><p>Since no value is stored currently in the key, it will return zero.</p><p>For congratulating the players on getting a new high score, create a new <code class="literal">SKLabelNode</code>, right after we added the <code class="literal">currentHighScore</code>, and call it <code class="literal">highScoreLabel</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var highScoreLabel = SKLabelNode(fontNamed:"Chalkduster")
highScoreLabel.text = ""
highScoreLabel.fontSize = 45
highScoreLabel.position = CGPoint(x: viewSize.width * 0.5, y: viewSize.height * 0.30)
self.addChild(highScoreLabel)</pre></div><p>We create the label with font <code class="literal">Chalkduster</code>. We set the initial text value to a blank so that we can change it later depending on whether the player beats the high score or not. We set the text height to <code class="literal">45</code>, and place it below the button and then add it to the scene.</p><p>Next we check the value stored in <code class="literal">currentHighScore</code> against the current <code class="literal">score</code> and see if the <code class="literal">currentHighScore</code> value is greater than the current <code class="literal">score</code>, as shown in the following:</p><div class="informalexample"><pre class="programlisting">if (score &gt; currentHighScore) {
            
NSUserDefaults.standardUserDefaults().setInteger(score, 
                       forKey: "tinyBazooka_highscore")
    
NSUserDefaults.standardUserDefaults().synchronize()
            
highScoreLabel.text = "New High Score: \(score) !"

            
} else {
        
    highScoreLabel.text = "You can Do Better than \(score)"

}</pre></div><p>If the score is higher than the<a id="id407" class="indexterm"/> current high score, then we call the <code class="literal">setInteger</code> function<a id="id408" class="indexterm"/> of <code class="literal">standardUserDefaults</code> and assign the new high score that is the current score and the key to store it against. When assigning keys, make sure it is unique.</p><p>To save the data to the device, we have to call the <code class="literal">synchronize</code> function. If we fail to call this, once you close the application, the data will be lost, so make sure to call this function each time you store the value against a key.</p><p>We then congratulate the player on getting a new high score by changing the text property to show the current score, which is the new high score.</p><p>If the player didn't beat his current high score, then in the <code class="literal">else</code> statement we change the text property of the <code class="literal">highScoreLabel</code> to show that he can do better than the current score so that it will motivate him to play the game again and beat his previous high score.</p><p>In the following screenshot, I scored <span class="strong"><strong>7</strong></span>, which is okay I think. With a little bit of practice, I think I will be able to do better. It is also just to demonstrate that the code works fine, and if the current score is greater than the high score, then it shows the new high score.</p><div class="mediaobject"><img src="graphics/B04014_04_19.jpg" alt="Saving the high score"/></div><p>If the current score is less<a id="id409" class="indexterm"/> than the current high score, then you will see the following <a id="id410" class="indexterm"/>screen. Here I got a <span class="strong"><strong>4</strong></span>, which is less than the current high score saved in memory that is <span class="strong"><strong>7</strong></span>.</p><div class="mediaobject"><img src="graphics/B04014_04_20.jpg" alt="Saving the high score"/></div></div>
<div class="section" title="Resetting the high score count"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Resetting the high score count</h1></div></div></div><p>What if the player wants to <a id="id411" class="indexterm"/>reset their high score to zero? We can do this<a id="id412" class="indexterm"/> by adding a button in the main menu and resetting the value of the key to zero.</p><p>Open the <code class="literal">MainMenuScene.swift</code> file, and in the <code class="literal">didMoveToView</code> function where we created the play button, create one more SKSpriteNode called <code class="literal">resetBtn</code>. Place this button at three-fourth of the width of the screen and name the sprite <code class="literal">resetBtn</code>. We will use the name to check whether the player clicked the play button or the reset button.</p><p>The assets for the reset button are in the <code class="literal">Resources</code> folder, so create a new image set called <code class="literal">resetBtn</code> and drag-and-drop <code class="literal">resetBtn.png</code> and <code class="literal">resetBtn2.png</code> to the <span class="strong"><strong>1x</strong></span> and <span class="strong"><strong>2x</strong></span> placeholders, respectively, as shown in the following:</p><div class="informalexample"><pre class="programlisting">let resetBtn = SKSpriteNode(imageNamed: "resetBtn")

resetBtn.position = CGPoint(x: viewSize.width * 0.75, y: viewSize.height/2)

self.addChild(resetBtn)

resetBtn.name = "resetBtn"</pre></div><p>Now, in the <code class="literal">touchesBegan</code> function where we checked for <code class="literal">playBtn</code>, add an <code class="literal">else if</code> block and check whether <code class="literal">resetBtn</code> is pressed, like this:</p><div class="informalexample"><pre class="programlisting">else if (_node.name == "resetBtn"){
                
NSUserDefaults.standardUserDefaults().setInteger(0, forKey: "tinyBazooka_highscore")
   
NSUserDefaults.standardUserDefaults().synchronize()
            
}</pre></div><p>If the reset button is<a id="id413" class="indexterm"/> pressed, we set the value of the key by which we <a id="id414" class="indexterm"/>have been getting the value, to zero and call the synchronize function again so that this value is stored in the system.</p><p>Now, as one last thing, let's show the player the current high score when the application opens, so create a new global variable called <code class="literal">currentHighScoreLabel</code> of type <code class="literal">SKLabel</code> at the top of the <code class="literal">MainMenuScene</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class MainMenuScene: SKScene {
    
<span class="strong"><strong>    var currentHighScoreLabel: SKLabelNode!</strong></span>
</pre></div><p>Next, we add the following in the <code class="literal">didMoveToView</code> function right after where we added the reset button:</p><div class="informalexample"><pre class="programlisting">var currentHighScore = NSUserDefaults.standardUserDefaults().integerForKey("tinyBazooka_highscore")
        
currentHighScoreLabel = SKLabelNode(fontNamed:"Chalkduster")

currentHighScoreLabel.text = "Current High Score: \(currentHighScore)"

currentHighScoreLabel.fontSize = 45
currentHighScoreLabel.position = CGPoint(x: viewSize.width * 0.5, y: viewSize.height * 0.20)

self.addChild(currentHighScoreLabel)</pre></div><p>We first get the current high score stored, and then assign the value to the text. The rest of the code is similar to the code except that the <code class="literal">y</code> value for the position is multiplied by 0.2 instead of 0.3, as the play button is pretty big.</p><p>We also need to <a id="id415" class="indexterm"/>change the text once the high score is reset, so in<a id="id416" class="indexterm"/> the <code class="literal">else if</code> block where we check whether the reset button is pressed, under the place where we added code to reset the value for the key, add the highlighted lines shown here:</p><div class="informalexample"><pre class="programlisting">else if (_node.name == "resetBtn"){
                
     NSUserDefaults.standardUserDefaults().setInteger(0, forKey: "tinyBazooka_highscore")
     
NSUserDefaults.standardUserDefaults().synchronize()
                
<span class="strong"><strong>     var currentHighScore = NSUserDefaults.standardUserDefaults().integerForKey("tinyBazooka_highscore")</strong></span>
<span class="strong"><strong>     currentHighScoreLabel.text = "Current High Score: \(currentHighScore)"</strong></span>
                
}</pre></div><p>Here, we get the stored value again just to check whether the value that we stored earlier is actually reflected. Then we set text of <code class="literal">currentHighScoreLabel</code> to this value.</p><p>We could have just set the text as <code class="literal">Current High Score: 0</code> and it would have still worked without a problem, but this way, we would not have been sure whether the value for the key was actually set to zero.</p><p>Now, if you run the code, you can see the current high score displayed at the main menu screen when the game starts. You can also verify that the value of the high score is actually set to zero once you reset it.</p><p>So, in the following screenshot, the main menu scene, once again, is showing my current high score, even though<a id="id417" class="indexterm"/> this code was added after achieving my new <a id="id418" class="indexterm"/>high score:</p><div class="mediaobject"><img src="graphics/B04014_04_21.jpg" alt="Resetting the high score count"/></div><p>In the next screenshot, we can be sure that the value of the current high score changes once the reset button is pressed:</p><div class="mediaobject"><img src="graphics/B04014_04_22.jpg" alt="Resetting the high score count"/></div><p>So this is all for this <a id="id419" class="indexterm"/>chapter. Save this file and keep it, as we will need it <a id="id420" class="indexterm"/>again in the next chapter.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Summary</h1></div></div></div><p>This was a pretty long chapter and we actually made a complete working game in it. We created the main menu and gameplay scenes using SKScenes and added interactive buttons to move between the scenes.</p><p>You learned how to import assets into the project, add them onto the screen, and make them move around and interact with each other. You also saw how to remove objects from the screen and add and update the score.</p><p>Finally, you saw how to store and retrieve the current high score on the device. However, we are not done with the game. We still need to add animations, particle effects, and background music and sounds effects to the game to make it come alive. Hope you guys are looking forward to it.</p><p>In the meantime, you can practice and try to beat my high score.</p></div></body></html>