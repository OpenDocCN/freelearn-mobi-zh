- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Persistent Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While, as iOS developers, we primarily focus on UI-related topics such as UIKit
    and SwiftUI, there are other essential aspects of iOS development to consider,
    such as persistent memory. This topic is critical as it enables us to store and
    retrieve information even after an app is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many benefits to managing persistent memory well, some of which are
    detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improving user experience**: Apps that can save and retrieve user data later
    provide a better user experience. For instance, if the user has downloaded information
    from our backend server, we can show it to them the next time they enter the app
    without waiting for network requests to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providing offline access**: Offline access is a great feature allowing users
    to work with our app even when they are offline. For example, a messaging app
    may allow users to view their previous conversations even when they don’t have
    an internet connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping a local state**: With persistent memory, we can keep a local state
    even after the app is closed. For example, storing access tokens, user profile
    details, or continuing the user experience from the last time the user stopped
    are essential features we can add to our app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent memory is a critical component for iOS developers, involving user
    experience, security, and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following important topics in persistent memory:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering *Core* *Data* questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling persistent state with **UserDefaults**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing sensitive information in the *Keychain*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the *filesystem*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many young developers are often intimidated by a framework called Core Data.
    Let’s begin by exploring this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Core Data questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most interviewers don’t ask about general frameworks (besides UIKit, SwiftUI,
    and Foundation), but Core Data is considered an exception. **Core Data** is a
    fundamental framework in iOS development because it’s an optimized and simple
    solution for setting up our data layer and managing a persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data evolved over the years and became a primary framework for many developers.
    It is integrated perfectly into the iOS development ecosystem, working perfectly
    with Xcode and other iOS frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several concepts to know about Core Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data model**: Core Data is built around a data model, which defines the data
    structure stored in the app. The data model is typically determined using Xcode’s
    data modeling tool and includes entities (which represent objects in the app),
    attributes (which describe properties of those objects), and relationships (which
    define how entities are related to each other).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed object context**: The managed object context is the heart of the
    Core Data framework. It is responsible for managing the life cycle of the app’s
    data objects (known as “managed objects”) and provides a way for the app to query,
    create, update, and delete those objects. It is also responsible for handling
    undo/redo operations and managing object relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent store coordinator**: The persistent store coordinator is responsible
    for managing the app’s persistent store, where the data is stored on disk. It
    coordinates communication between the managed object context and the persistent
    store and ensures that changes made to the managed object context are properly
    persisted to disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fetch requests**: We use Fetch requests to query the app’s data model and
    retrieve specific objects from the managed object context. We can also customize
    Fetch requests with predicates (to filter results), sort descriptors (to order
    results), and fetch limits (to limit the number of results returned).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationships**: Core Data provides a powerful mechanism for defining relationships
    between entities in the data model. Relationships can be one-to-one, one-to-many,
    or many-to-many and can be uni-directional or bi-directional. Relationships can
    also be configured with delete rules, which define how objects should be deleted
    when a relationship is broken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migration**: Core Data includes tools for migrating data between different
    data model versions. This allows developers to change the data model over time
    while preserving existing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s another important term we know about Core Data, and that’s the **Core
    Data Stack**. The Core Data Stack is a layer set that allows our app to interact
    with the persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the three Core Data Stack layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed object model**: This is the bottom layer containing the data model.
    Because everything is built around the data structure, we start with that layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent store coordinator**: This is the persistent store coordinator
    built upon the object model. The coordinator uses the data model to define a corresponding
    persistent store that matches the data scheme. The store could be based on XML,
    SQLite, JSON, or a backend service. Core Data allows us to base the persistent
    store upon any technology we want. Another essential thing to remember about the
    persistent store is that it needs to match the data model exactly. Any change
    in the data model will require a modification to the store and migration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed object context**: This is the managed object context that manages
    the life cycle of the app’s data objects (known as “managed objects”). It provides
    a way for the app to query, create, update, and delete those objects. It is also
    responsible for handling undo/redo operations and managing object relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to set up the Core Data Stack to start using Core Data. This can be
    done quickly using `NSPersistentContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the code example, we use `MyDataModel`. This line also creates the persistent
    store and returns a container object.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we *load* the persistent store into the stack and create a managed
    object context so we can start working with Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the context, we can perform entity creation, fetching, updates,
    and deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is so simple that it speaks for itself. We create a new `Employee`
    object based on the context we created earlier, set its properties, and save the
    new object using the `context` save method.
  prefs: []
  type: TYPE_NORMAL
- en: '`Employee` is a subclass of `NSManagedObject`, and it allows us direct access
    to the entity’s properties and an easy way to modify its data. The `context.save()`
    action commits the changes into the persistent store.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the primary usage of Core Data is straightforward, and it
    has become even simpler over the years. While setting up a Core Data Stack is
    essential to using Core Data, it’s not the only aspect developers need to master.
    Due to the challenges and complexities of working with Core Data, interviewers
    often ask about these challenges rather than just the basic setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some challenges we may consider learning well before the interview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling concurrency**: Concurrency is a complex topic not only in Core Data
    but in any persistent store or local data. Several techniques and patterns exist
    for performing concurrency jobs in Core Data and avoiding data loss and exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Designing a data model**: Technically, setting up a data model with entities
    and attributes is a simple job as we perform most of the work in a model editor,
    a built-in Xcode editor. But the real challenge is to *design* the data model
    in a way that serves our app’s critical journeys and tasks. We need to master
    the primary terms such as **to-many** and **to-one** and fully understand the
    **deletion rules**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding data migrations**: We’ll have to modify our data model, adding,
    editing, and removing entities and attributes over time. Changing the data model
    while there’s data in the persistent store is called “data migrations,” which
    is also a critical topic we, as iOS developers, need to understand and know how
    to perform. Mistakes in this area may lead to data corruption and even crashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s transition to some Core Data-related questions specifically addressing
    these topics.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you design a Core Data Stack that supports concurrency while ensuring
    thread safety, and how can you use NSManagedObjectIDs in a multi-threaded environment
    to facilitate this?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is an important top in Core Data development, and handling concurrency
    well shows a deep understanding of how Core Data context works.
  prefs: []
  type: TYPE_NORMAL
- en: If we understand how Core Data context works, we should also answer the second
    part of this question – the `NSManagedObjectID`, which can help us identify an
    object in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s talk about two principles that are related to Core Data concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Considering a context as a sandbox**: When working with contexts, we can
    create objects, update, and delete them. We do all that only in the context and
    not in the persistent store. When we call the **save()** method, Core Data pushes
    the changes to the parent context and, if there isn’t any parent context, to the
    persistent store. We should think of context as a sandbox – we can perform changes
    and commit them only when ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessing a context from the same thread that created it**: In Core Data,
    a context belongs to a thread. Once we create a new background thread, we can’t
    access an object created or fetched in another thread. Each thread needs to have
    its context to allow it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we understand these two principles, we can try to define the different
    patterns for setting up our Core Data Stack. These patterns rely on our application
    needs and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go over them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have several private contexts in multiple context patterns, and each works
    directly with the persistent store. The multiple contexts are responsible for
    reading and writing and provide a flexible way to handle different concurrency
    operations across our app and do that even in a modular way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create two contexts for writing (`writeContext`) and reading
    (`readContext`). It is important to note that changes we make to the writing context
    don’t reflect on the read context until we perform saving and re-fetching.
  prefs: []
  type: TYPE_NORMAL
- en: There are some significant drawbacks to multiple contexts patterns. For example,
    this pattern can add complexity to our database and requires us to manage changes
    between contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Another drawback we may encounter is complexity with features such as batch
    changes and redo/undo, which can be critical in some application use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we have a decent alternative: the parent-child context. Let’s talk
    about it.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with parent-child context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the multiple contexts pattern has a “flat” structure, the parent-child pattern
    is more hierarchical. The basic principle states that we have a root context (aka
    “parent”) dedicated to writing operations and child contexts dedicated to reading
    operations. The parent context is private, and the child contexts work with the
    main queue. Every change we make in the writing context is reflected in the child’s
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The parent-child pattern is excellent for background updates, offline editing,
    and undo-redo use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example for the parent-child pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see the parent context is private, and the children are the main ones.
    Also, we can see how we linked the children to their parent directly and not to
    the persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: What does a “private context” mean?
  prefs: []
  type: TYPE_NORMAL
- en: A private context is typically used to perform background tasks such as importing
    or exporting data, allowing those tasks to be performed asynchronously without
    blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, both parent-child and multiple contexts serve different purposes and
    use cases. It is important to say they provide basic principles for managing concurrency
    with Core Data. Combining these patterns or even using their principles to create
    a new pattern is perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: And what about using NSManagedObjectID?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with contexts, we cannot take a managed object fetched in one context
    and use it in another. We need to re-fetch it using `NSManagedObjectID`. That
    critical point may lead to an exception if not done right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code example of re-fetching the same object in another context using
    `NSManagedObjectID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each managed object has a property named `objectID`, which is identical to the
    same object across different contexts. Its primary purpose is precisely that –
    to ensure working with the same object when moving between contexts. `NSManagedObjectID`
    is an essential concept when performing concurrency operations in Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: “What would your Core Data data model look like for a recipe app that includes
    ingredients, cooking instructions, and user ratings?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: We are iOS developers and not DBAs, but we have significant weight in designing
    a data model that fits our app business needs. A bad data model design directly
    influences the app’s performance and stability. As developers, it is our responsibility
    to convert the requirements and workflows of an app into a technical design, and
    this question evaluates our proficiency in achieving that objective.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a data model for a specific app usage requires us to follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the *app’s needs* and basic flows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the *different entities and their attributes*, including the data types,
    default values, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create *indexes* for the relevant attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the *relationships* between the different entities – one-to-one or
    one-to-many.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the *deletion* rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are always relevant when approaching a data model design, and the
    use case described in the question is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to identify the primary workflows of the app. It is important
    to remember that the data layer should support the business logic and UI and not
    exist independently. It's perfectly legitimate to ask the interviewer additional
    questions; it is even part of the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can define the basic entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipe**: This holds the essential details for a single recipe. Attributes:
    title, date of creation, description, level, and category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingredient**: This can be shared across recipes. Attributes: name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instruction**: This is part of the steps required when using a recipe. Attributes:
    description, title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Rating**: This is a review of a single recipe. Attributes: name, rating
    (**int**), and description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While entities are a crucial aspect of the data model, they are often ineffective
    without clearly defining the relationships between them.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s understand how the entities are linked and the main challenges (because
    there are some!).
  prefs: []
  type: TYPE_NORMAL
- en: We understand that `Recipe` has a one-to-many relationship with `Instruction`
    and a one-to-many relationship with `User Rating`. That’s easy. What do we do
    with the ingredients? The naïve approach would be to define a one-to-many relationship
    with `Ingredient`, just as we did with `Instruction` and `User Rating`. The thing
    about `Ingredient` is that we can share it across recipes. For example, let’s
    say we have a feature that helps the user find all the recipes available based
    on ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a many-to-many relationship is required here. So, here’s something
    we learn: to construct the data model effectively, it is important to communicate
    with the interviewer and evaluate the app’s various features. We should also discuss
    potential use cases for the data to determine the best approach.'
  prefs: []
  type: TYPE_NORMAL
- en: If we need to share ingredients between our recipes and create a many-to-many
    relationship, we will probably need to develop a different entity, and that’s
    `IngredientUsage`.
  prefs: []
  type: TYPE_NORMAL
- en: '`IngredientUsage` represents one usage of `Ingredient` for a recipe, and it
    links between `Recipe` and `Ingredient`. Besides that link, it also provides more
    information, such as the amount.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore this further, let’s look at *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9\uFEFF.1 – Relationships between Recipe, IngredientUsage, and Ingredient](img/Figure_9.1_B18653.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Relationships between Recipe, IngredientUsage, and Ingredient
  prefs: []
  type: TYPE_NORMAL
- en: The main issue we solve in *Figure 9**.1* is that we cannot put additional information
    about relationships in Core Data. We can define a to-many relationship between
    `Recipe` and `Ingredient`, but we cannot tell the amount. The amount can’t be
    part of `Ingredient` because we want to share the ingredient with other recipes,
    which probably have a different amount. That’s the role of `IngredientUsage`.
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful tip is to remember that a similar issue can arise during any
    many-to-many relationship. If it is necessary to load the relationship with more
    information, a dedicated entity for the relationship can effectively address this
    concern.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the relationships between the data models, we need
    to consider the deletion rules. Core Data has several deletion rules, and it is
    important to pick the right one so we can maintain our data over time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we delete `Recipe`, we want its `IngredientUsage`, `User Rating`,
    and `Instruction` data to be deleted. Therefore, we define the deletion rules
    between `Recipe` and the other entities as **Cascade**. Cascade is a deletion
    rule that deletes the related objects if the source object is being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: However, that’s not the case between `IngredientUsage` and `Ingredient`. If
    we delete `IngredientUsage`, we don’t want to delete the ingredient as it is being
    shared with other `IngredientUsage` objects. In this case, we set the deletion
    rule for **Nullify**.
  prefs: []
  type: TYPE_NORMAL
- en: What about the inverse relationships? Do we need to delete a `Recipe` object
    if we delete one of its `User Rating` objects? Probably not. We want to keep `Recipe`
    if we delete a `User Rating` object. That’s also the case with `Instruction`.
    In both cases, we set the deletion rule to *Nullify* as well.
  prefs: []
  type: TYPE_NORMAL
- en: To recap our approach, I started by outlining five fundamental steps that form
    the process of defining a data model. It’s important to note that each step builds
    upon the previous one. To proceed with the answer, we can take a collaborative
    approach with our interviewer by walking through each step and discussing our
    thought process out loud. Doing that will ensure a great answer, even though the
    solution may not be perfect or ideal. Remember that the interviewer wants to see
    our thinking and not solve a real problem.
  prefs: []
  type: TYPE_NORMAL
- en: “How would you approach testing Core Data in an iOS app?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Core Data is an essential framework that plays a significant role in the app’s
    data layer. As such, it will be there when we are testing our app. But what does
    it mean? How can we test a persistent store? This question checks our understanding
    of the different tests we can perform with Core Data and the tools to perform
    them effectively and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: We can perform three different types of tests with Core Data, and we already
    discussed tests earlier in this book. If you need to refresh, go back to [*Chapter
    6*](B18653_06.xhtml#_idTextAnchor196) and ensure you are familiar with the different
    types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: The first type of testing we can perform is the unit test – in this case, we
    want to simulate a Core Data Stack and not use an actual persistent store file.
    To do that, we can create an **in-memory** persistent store. The in-memory persistent
    store is lightweight, doesn’t use an actual database file, and performs all the
    I/O operations in RAM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up an in-memory store is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are adding a persistent store of type `NSInMemoryStoreType`,
    which only creates an in-memory store.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of relevant test for Core Data is integration – in this case,
    we want to keep the Core Data store as it is and verify that actions we perform
    in the business logic or even the UI layers are being saved to the Core Data file.
    It is good practice to use a temporary database file or clean the data store before
    and after each test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third test relevant to Core Data is the performance test. Core Data consists
    of I/O operations that can be heavy to perform, and it is a good idea to ensure
    we don’t have any bottlenecks in our app. We can use the `measure` function in
    `XCTestCase` to check I/O operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we perform Core Data fetching and measure its duration.
    To simulate a workload, we perform the fetch operation `200` times. The test asserts
    when the duration exceeds a certain threshold.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize – we can test Core Data in unit tests and eliminate any I/O operations,
    integration tests to ensure our system works as expected, and performance tests
    to check the impact Core Data has on our app performance.
  prefs: []
  type: TYPE_NORMAL
- en: Handling persistent state with UserDefaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UserDefaults` is a fundamental yet simple solution for iOS developers to store
    persistent information in a key-value format. We can easily store and fetch Boolean,
    int, string, arrays, and dictionary values with UserDefaults.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is how we store a Boolean in UserDefaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how we read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The UserDefaults goal is not to store and retrieve large datasets – UserDefaults
    is a slow and unsecured solution for that use case. If we want to manage a local
    data store, we should use Core Data or SQLite for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, UserDefaults is a very simple and straightforward tool.
    However, it still has some advanced capabilities we may need to know when preparing
    for our interview. Let’s review some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: “Explain how an iOS app and its extensions can share data using UserDefaults.
    What steps are involved in setting up and using UserDefaults to share data between
    an app and its extensions?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Many apps live happily isolated during their lifetime. But once we add an extension
    or another app, we will probably need to share some data between them. For example,
    we might need to share keys, tokens, or profile information.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Apple provides us with a secure and easy way to do just that. Let’s
    look at the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps we need to do to share data between an iOS app and its
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting up an App Group**: The App Group feature allows us to combine and
    synchronize data between multiple extensions or apps. We create a new App Group
    using the Developer Portal and enable it for both our app and the extension.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure the Xcode project settings**: Once we’ve set up the App Group in
    the Developer Portal, we’ll need to configure the Xcode project settings for our
    app and extensions. We’ll need to specify the App Group Identifier and enable
    the App Group entitlement for our app and extensions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use UserDefaults to share data**: Once the Xcode project settings have been
    configured, we can use UserDefaults to share data between our app and extensions.
    To do this, we’ll need to create a new **UserDefaults** object with the App Group
    Identifier as the suite name and then use the **set(_:forKey:)** method to save
    data and the **object(forKey:**) method to retrieve data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a code example of how to set and read data from shared `UserDefaults`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we are setting up a new `UserDefaults` and passing the
    App Group Identifier we defined in the Developer Portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the code stays as before in this section: reading and writing using
    a key-value mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see – sharing data between an app and an extension is straightforward,
    but it is also something not many developers are familiar with. Sharing the Core
    Data store between the app and the extension is also a fundamental feature.
  prefs: []
  type: TYPE_NORMAL
- en: “Can you explain how to store a struct or a class in UserDefaults in an iOS
    app?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: Saving primitive dictionaries and arrays is probably the most common use case
    when working with `UserDefaults`. But there are many cases where we need to store
    an entire object or a class. For example, we sometimes need to save a user object
    that contains full details, and Core Data is like using a sledgehammer to crack
    a nut.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'UserDefaults has two popular ways to store an object or a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to use **NSKeyedArchiver**. One of the data types we can
    save in **UserDefaults** is **Data**. **NSKeyedArchiver** can take a struct or
    an object and convert it into a **Data** object, which can be saved directly to
    **NSKeyedArchiver**. To un-archive the object, we can use **NSKeyedUnarchiver**.
    Let’s see a code example for that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code example, we converted a `Person` struct into a `Data` object using
    `NSKeyedArchiver`. The data can be set and restored easily, like any other data
    type saved to `UserDefaults`. After we fetch the data, we can convert it into
    a `Person` object again using `NSKeyedUnarchiver`.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to use **JSONEncoder**. With **JSONEncoder**, we can convert
    to a **Data** object the same way we did with **NSKeyedArchiver**. Once we have
    a data object, we can set and restore the **Person** object from **UserDefaults**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we save and restore the same `Person` struct, but now with `JSONEncoder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We use `JSONEncoder` to convert the struct into data and `JSONDecoder` to restore
    the data back to `Person`. Notice that in this case, `Person` needs to *conform
    to Codable*, which requires its properties to also conform to Codable.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the options is better? There’s no clear answer. Generally, it is a
    best practice for our structs and classes to conform to **Codable** as it provides
    more capabilities such as automatic parsing and encoding.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `NSKeyedArchiver` is more efficient than `JSONEncoder` when
    working on large or complex datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Both APIs are good enough for most cases, and it depends on our app structure
    and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Storing sensitive information in the Keychain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UserDefaults` is an excellent storing mechanism, but it is unsuitable for
    storing data such as passwords or tokens. **Keychain** is Apple’s solution for
    storing sensitive data, and it provides a higher level of security and is an essential
    tool for iOS developers to protect their data.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in the keychain is much more complex than using other solutions.
    The keychain provides a particular API, based on the C function, to prevent malicious
    hackers from reverse-engineering calls to that API. The keychain also requires
    more information when saving, so it can save and index it more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to store a simple token in the keychain while wrapping it with
    a class for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we notice from that code example is that we import the `Security`
    framework, which is also responsible for authentication, secure transport, and
    data protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the code is much more complex than working with `UserDefaults`.
    Instead of storing a simple value, we need to create a keychain item with several
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**kSecClass**: This key specifies the level of security of the item. We can
    choose from several constants, such as **kSecClassGenericPassword**, **kSecClassInternetPassword**,
    and **kSecClassIdentity**. Choosing the correct class ensures the right level
    of security for our data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kSecAttrService**: **kSecAttrService** defines the service name for our item.
    We can group multiple items to increase security in case of compromising part
    of the app, to share part of the keychain items, and for better organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kSecAttrAccount**: This is used to add identification to the keychain item,
    such as a username or email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kSecValueData**: This is the actual data we want to save. It can be either
    **Data** or **String**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These four keys are not the only ones we can use for creating a keychain item,
    but they are the most common ones. Once we have `CFDictionary`, we can use `SecItemAdd`
    to push the keychain item into the keychain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to read the token back from the keychain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To read the token, we create `CFDictionary` once again and use `SecItemCopyMatching`
    to query the keychain and retrieve the token. Afterward, we examine the results
    – if the status is `success` and we have `tokenData`, we can extract the token
    by converting it into a string and return it.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, keychain management is not as trivial as other storage tools
    and a keychain wrapper is a good solution that can help us simplify the process.
  prefs: []
  type: TYPE_NORMAL
- en: “What is a Keychain Access Group, and how can it be used to securely share Keychain
    items between different components of an iOS app, such as the app and its extensions?”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we discussed UserDefaults and how to share information
    between our app and our extensions (or other apps, for that matter). Now we are
    moving forward with that question and being asked how to share sensitive information
    between the different components. This way, our app extensions can be much more
    powerful and independent.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: A **Keychain access group** is a unique identifier that specifies which Keychain
    items can be accessed by a particular app or extension.
  prefs: []
  type: TYPE_NORMAL
- en: Access groups are defined in the app’s entitlements file and provide secure
    sharing of sensitive data between different components of an app, such as an app
    and its extensions.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying the same access group for multiple components of an app, those
    components can securely share Keychain items without compromising their integrity.
    This feature is important for iOS app developers because it enables them to provide
    a secure and reliable storage mechanism for sensitive data that is accessible
    across multiple components of an app.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how to set up a Keychain access group and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a new access group in the app’s entitlements file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We must also define the same access group in the extension’s entitlement file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the access group we created in our code when saving and fetching
    keychain values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice we added the `kSecAttrAccessGroup` key to our keychain item with our
    new keychain group.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the keychain, we can see that most of our boilerplate is the
    different keychain values management, while setting up an access group is easy
    and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking – working with the iOS keychain is not as straightforward
    as the other tools we have – it requires more code, using C functions, and providing
    additional keys and information. But iOS development requires us to work with
    sensitive information and even share it between our apps. Therefore, we must understand
    how the keychain works and how to approach it with its API.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a common assumption that iOS “doesn’t have a filesystem.” And even though
    there is a **Files** app, it is true that the filesystem is almost hidden for
    most standard users.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not the case for iOS developers.
  prefs: []
  type: TYPE_NORMAL
- en: iOS developers use the iOS filesystem to store documents, images, cache files,
    and even database files.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem allows us to store a large set of information, work with resources
    and even share data with other app components. Most interview questions focus
    on organizing our files and responding to different use cases. Understanding how
    the sandbox is built is crucial for us as developers.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s review a question about our sandbox structure.
  prefs: []
  type: TYPE_NORMAL
- en: '“Can you explain the purpose of each of the following folders in an iOS app:
    Documents, Library, Cache, and Temp? How would you decide which folder to use
    for storing different types of files in your app?”'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Why is this* *question important?*'
  prefs: []
  type: TYPE_NORMAL
- en: File operations in iOS for reading and writing are generally straightforward
    from a technical perspective. However, the key is to grasp the methodological
    concept of properly organizing files in the appropriate folder. Each folder serves
    a distinct purpose and possesses different characteristics, and the iOS system
    distinctly manages each folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*What is* *the answer?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, each folder has its distinct purpose and characteristics, so
    let’s go over them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documents**: This folder is meant for storing data that can be created or
    edited by the user, such as documents, images, and videos. This folder is backed
    up by iCloud and is visible to the user through iTunes file sharing. We should
    use this folder for data that the user expects to be available even after the
    app is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library**: This folder is intended for storing app-specific data not created
    by the user, such as downloaded content, cache files, and preferences. This folder
    is backed up by iCloud but is not visible to the user through iTunes file sharing.
    We should use this folder for important data for the app’s functionality, but
    it can be recreated if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache**: This folder is designed for storing temporary files that can be
    regenerated or downloaded again. This folder is not backed up by iCloud and can
    be emptied by the system when the device runs low on storage. We should use this
    folder for data that is not critical of the app’s functionality and can be discarded
    if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temp**: iOS also provides a temporary directory for storing temporary files,
    known as the **Temp** folder. This folder is intended to hold only needed temporary
    files and can be deleted when the app is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content type leads us to decide which folder to store our files. For example,
    we want to use the `Documents` folder for user-generated files. We can use the
    `Temp` folder if we need temporary files for generating information or calculations.
    The `Library` folder is suitable for storing the local data persistent store file.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a file in the wrong folder may lead to unexpected behavior, such as
    data loss, performance issues, and increasing the user backup size for no reason.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over some critical topics in persistent memory. We
    discussed Core Data concurrency and data model design, advanced topics in `UserDefaults`,
    how to handle sensitive information with the Keychain, and the different folders
    in our app sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we should ultimately be ready for that topic in our interview!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will cover an essential topic that could hinder the scalability
    of an app for iOS developers who are unfamiliar with it: CocoaPods and the Swift
    Package Manager.'
  prefs: []
  type: TYPE_NORMAL
