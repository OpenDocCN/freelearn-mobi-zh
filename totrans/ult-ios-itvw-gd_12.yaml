- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Understanding Persistent Memory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解持久化存储
- en: While, as iOS developers, we primarily focus on UI-related topics such as UIKit
    and SwiftUI, there are other essential aspects of iOS development to consider,
    such as persistent memory. This topic is critical as it enables us to store and
    retrieve information even after an app is closed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，作为 iOS 开发者，我们主要关注 UI 相关的主题，如 UIKit 和 SwiftUI，但还有其他 iOS 开发的关键方面需要考虑，例如持久化存储。这个主题至关重要，因为它使我们能够在
    App 关闭后存储和检索信息。
- en: 'There are many benefits to managing persistent memory well, some of which are
    detailed here:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 管理持久化存储的好处很多，其中一些细节如下：
- en: '**Improving user experience**: Apps that can save and retrieve user data later
    provide a better user experience. For instance, if the user has downloaded information
    from our backend server, we can show it to them the next time they enter the app
    without waiting for network requests to complete.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升用户体验**：能够保存和稍后检索用户数据的 App 可以提供更好的用户体验。例如，如果用户已从我们的后端服务器下载了信息，我们可以在他们下次进入
    App 时立即展示这些信息，而无需等待网络请求完成。'
- en: '**Providing offline access**: Offline access is a great feature allowing users
    to work with our app even when they are offline. For example, a messaging app
    may allow users to view their previous conversations even when they don’t have
    an internet connection.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供离线访问**：离线访问是一个伟大的功能，允许用户在离线时也能使用我们的 App。例如，一个消息应用可能允许用户在无互联网连接的情况下查看他们之前的对话。'
- en: '**Keeping a local state**: With persistent memory, we can keep a local state
    even after the app is closed. For example, storing access tokens, user profile
    details, or continuing the user experience from the last time the user stopped
    are essential features we can add to our app.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持本地状态**：使用持久化存储，我们可以在 App 关闭后保持本地状态。例如，存储访问令牌、用户配置文件详情或从用户上次停止的地方继续用户体验是我们可以添加到
    App 中的关键功能。'
- en: Persistent memory is a critical component for iOS developers, involving user
    experience, security, and efficiency.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化存储对于 iOS 开发者来说是一个关键组件，它涉及到用户体验、安全和效率。
- en: 'This chapter covers the following important topics in persistent memory:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了持久化存储中的以下重要主题：
- en: Mastering *Core* *Data* questions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 *Core* *Data* 问题
- en: Handling persistent state with **UserDefaults**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **UserDefaults** 处理持久化状态
- en: Storing sensitive information in the *Keychain*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *密钥链* 中存储敏感信息
- en: Working with the *filesystem*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 *文件系统* 一起工作
- en: Many young developers are often intimidated by a framework called Core Data.
    Let’s begin by exploring this topic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年轻的开发者常常对名为 Core Data 的框架感到畏惧。让我们从探索这个主题开始。
- en: Mastering Core Data questions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握 Core Data 问题
- en: Most interviewers don’t ask about general frameworks (besides UIKit, SwiftUI,
    and Foundation), but Core Data is considered an exception. **Core Data** is a
    fundamental framework in iOS development because it’s an optimized and simple
    solution for setting up our data layer and managing a persistent store.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面试官不会询问关于通用框架的问题（除了 UIKit、SwiftUI 和 Foundation 之外），但 Core Data 被视为一个例外。**Core
    Data** 是 iOS 开发中的基本框架，因为它是一个设置数据层和管理持久化存储的优化且简单的解决方案。
- en: Core Data evolved over the years and became a primary framework for many developers.
    It is integrated perfectly into the iOS development ecosystem, working perfectly
    with Xcode and other iOS frameworks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 在这些年中不断发展，成为许多开发者的主要框架。它完美地集成到 iOS 开发生态系统中，与 Xcode 和其他 iOS 框架完美配合。
- en: 'There are several concepts to know about Core Data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Core Data 有几个概念需要了解：
- en: '**Data model**: Core Data is built around a data model, which defines the data
    structure stored in the app. The data model is typically determined using Xcode’s
    data modeling tool and includes entities (which represent objects in the app),
    attributes (which describe properties of those objects), and relationships (which
    define how entities are related to each other).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型**：Core Data 围绕一个数据模型构建，该模型定义了 App 中存储的数据结构。数据模型通常使用 Xcode 的数据建模工具确定，包括实体（代表
    App 中的对象）、属性（描述这些对象的属性）和关系（定义实体之间如何相互关联）。'
- en: '**Managed object context**: The managed object context is the heart of the
    Core Data framework. It is responsible for managing the life cycle of the app’s
    data objects (known as “managed objects”) and provides a way for the app to query,
    create, update, and delete those objects. It is also responsible for handling
    undo/redo operations and managing object relationships.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理对象上下文**：管理对象上下文是 Core Data 框架的核心。它负责管理应用数据对象（称为“管理对象”）的生命周期，并为应用提供了查询、创建、更新和删除这些对象的方式。它还负责处理撤销/重做操作和管理对象关系。'
- en: '**Persistent store coordinator**: The persistent store coordinator is responsible
    for managing the app’s persistent store, where the data is stored on disk. It
    coordinates communication between the managed object context and the persistent
    store and ensures that changes made to the managed object context are properly
    persisted to disk.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化存储协调器**：持久化存储协调器负责管理应用的数据持久化存储，数据存储在磁盘上。它协调管理对象上下文和持久化存储之间的通信，并确保对管理对象上下文所做的更改被正确地持久化到磁盘。'
- en: '**Fetch requests**: We use Fetch requests to query the app’s data model and
    retrieve specific objects from the managed object context. We can also customize
    Fetch requests with predicates (to filter results), sort descriptors (to order
    results), and fetch limits (to limit the number of results returned).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询请求**：我们使用查询请求来查询应用的数据模型并从管理对象上下文中检索特定对象。我们还可以使用谓词（以过滤结果）、排序描述符（以排序结果）和查询限制（以限制返回的结果数量）来自定义查询请求。'
- en: '**Relationships**: Core Data provides a powerful mechanism for defining relationships
    between entities in the data model. Relationships can be one-to-one, one-to-many,
    or many-to-many and can be uni-directional or bi-directional. Relationships can
    also be configured with delete rules, which define how objects should be deleted
    when a relationship is broken.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**：Core Data 提供了一种强大的机制来定义数据模型中实体之间的关系。关系可以是一对一、一对多或多对多，可以是单向的或双向的。关系还可以配置删除规则，这些规则定义了当关系断开时对象应该如何被删除。'
- en: '**Migration**: Core Data includes tools for migrating data between different
    data model versions. This allows developers to change the data model over time
    while preserving existing data.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移**：Core Data 包含在不同数据模型版本之间迁移数据的工具。这允许开发者随着时间的推移更改数据模型，同时保留现有数据。'
- en: There’s another important term we know about Core Data, and that’s the **Core
    Data Stack**. The Core Data Stack is a layer set that allows our app to interact
    with the persistent store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解 Core Data 的另一个重要术语，那就是 **Core Data 栈**。Core Data 栈是一个层集，允许我们的应用与持久化存储进行交互。
- en: 'Here are the three Core Data Stack layers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Core Data 栈的三个层级：
- en: '**Managed object model**: This is the bottom layer containing the data model.
    Because everything is built around the data structure, we start with that layer.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理对象模型**：这是包含数据模型的底层。因为一切都是围绕数据结构构建的，所以我们从这个层开始。'
- en: '**Persistent store coordinator**: This is the persistent store coordinator
    built upon the object model. The coordinator uses the data model to define a corresponding
    persistent store that matches the data scheme. The store could be based on XML,
    SQLite, JSON, or a backend service. Core Data allows us to base the persistent
    store upon any technology we want. Another essential thing to remember about the
    persistent store is that it needs to match the data model exactly. Any change
    in the data model will require a modification to the store and migration.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化存储协调器**：这是基于对象模型构建的持久化存储协调器。协调器使用数据模型来定义一个与数据方案相对应的持久化存储。存储可以基于 XML、SQLite、JSON
    或后端服务。Core Data 允许我们基于我们想要的任何技术来构建持久化存储。关于持久化存储的另一个重要事项是，它需要与数据模型完全匹配。任何数据模型的变化都要求对存储进行修改并执行迁移。'
- en: '**Managed object context**: This is the managed object context that manages
    the life cycle of the app’s data objects (known as “managed objects”). It provides
    a way for the app to query, create, update, and delete those objects. It is also
    responsible for handling undo/redo operations and managing object relationships.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理对象上下文**：这是管理应用数据对象生命周期（称为“管理对象”）的管理对象上下文。它为应用提供了查询、创建、更新和删除这些对象的方式。它还负责处理撤销/重做操作和管理对象关系。'
- en: 'We need to set up the Core Data Stack to start using Core Data. This can be
    done quickly using `NSPersistentContainer`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置 Core Data 栈以开始使用 Core Data。这可以通过使用 `NSPersistentContainer` 快速完成：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code example, we use `MyDataModel`. This line also creates the persistent
    store and returns a container object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们使用`MyDataModel`。这一行也创建了持久存储并返回一个容器对象。
- en: Afterward, we *load* the persistent store into the stack and create a managed
    object context so we can start working with Core Data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将持久存储加载到堆栈中，并创建一个管理对象上下文，这样我们就可以开始使用Core Data了。
- en: 'Once we have the context, we can perform entity creation, fetching, updates,
    and deletion:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了上下文，我们就可以执行实体创建、获取、更新和删除操作：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is so simple that it speaks for itself. We create a new `Employee`
    object based on the context we created earlier, set its properties, and save the
    new object using the `context` save method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如此简单，以至于它自身就能说明一切。我们根据之前创建的上下文创建一个新的`Employee`对象，设置其属性，并使用`context`的保存方法保存新对象。
- en: '`Employee` is a subclass of `NSManagedObject`, and it allows us direct access
    to the entity’s properties and an easy way to modify its data. The `context.save()`
    action commits the changes into the persistent store.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`是`NSManagedObject`的子类，它允许我们直接访问实体的属性，并提供了修改其数据的一种简单方式。`context.save()`操作将更改提交到持久存储。'
- en: Generally speaking, the primary usage of Core Data is straightforward, and it
    has become even simpler over the years. While setting up a Core Data Stack is
    essential to using Core Data, it’s not the only aspect developers need to master.
    Due to the challenges and complexities of working with Core Data, interviewers
    often ask about these challenges rather than just the basic setup.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，Core Data的主要用法很简单，而且随着时间的推移变得更加简单。虽然设置Core Data堆栈对于使用Core Data至关重要，但这并不是开发者需要掌握的唯一方面。由于与Core
    Data一起工作的挑战和复杂性，面试官通常会询问这些挑战，而不仅仅是基本设置。
- en: 'Here are some challenges we may consider learning well before the interview:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们可能在面试前需要很好地学习的挑战：
- en: '**Handling concurrency**: Concurrency is a complex topic not only in Core Data
    but in any persistent store or local data. Several techniques and patterns exist
    for performing concurrency jobs in Core Data and avoiding data loss and exceptions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理并发**：并发是一个复杂的话题，不仅在于Core Data，还在于任何持久存储或本地数据。在Core Data中执行并发任务并避免数据丢失和异常，存在几种技术和模式。'
- en: '**Designing a data model**: Technically, setting up a data model with entities
    and attributes is a simple job as we perform most of the work in a model editor,
    a built-in Xcode editor. But the real challenge is to *design* the data model
    in a way that serves our app’s critical journeys and tasks. We need to master
    the primary terms such as **to-many** and **to-one** and fully understand the
    **deletion rules**.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计数据模型**：从技术上讲，设置具有实体和属性的数据模型是一项简单的工作，因为我们的大部分工作都在模型编辑器中完成，这是一个内置的Xcode编辑器。但真正的挑战是以一种服务于我们应用程序关键旅程和任务的方式设计数据模型。我们需要掌握主要术语，如**多对多**和**一对多**，并完全理解**删除规则**。'
- en: '**Understanding data migrations**: We’ll have to modify our data model, adding,
    editing, and removing entities and attributes over time. Changing the data model
    while there’s data in the persistent store is called “data migrations,” which
    is also a critical topic we, as iOS developers, need to understand and know how
    to perform. Mistakes in this area may lead to data corruption and even crashes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解数据迁移**：随着时间的推移，我们不得不修改我们的数据模型，添加、编辑和删除实体和属性。在持久存储中有数据时更改数据模型称为“数据迁移”，这也是作为iOS开发者，我们需要理解和知道如何执行的关键话题。在这个领域的错误可能会导致数据损坏甚至崩溃。'
- en: Now, let’s transition to some Core Data-related questions specifically addressing
    these topics.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们过渡到一些专门针对这些主题的Core Data相关的问题。
- en: “How do you design a Core Data Stack that supports concurrency while ensuring
    thread safety, and how can you use NSManagedObjectIDs in a multi-threaded environment
    to facilitate this?”
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你如何设计一个支持并发同时确保线程安全的Core Data堆栈，以及你如何在多线程环境中使用NSManagedObjectIDs来促进这一点？”
- en: '*Why is this* *question important?*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题的意义是什么？*'
- en: Concurrency is an important top in Core Data development, and handling concurrency
    well shows a deep understanding of how Core Data context works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是Core Data开发中的一个重要话题，妥善处理并发显示了我们对Core Data上下文工作原理的深入理解。
- en: If we understand how Core Data context works, we should also answer the second
    part of this question – the `NSManagedObjectID`, which can help us identify an
    object in different contexts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们理解了Core Data上下文的工作原理，我们也应该回答这个问题的第二部分——`NSManagedObjectID`，它可以帮助我们在不同的上下文中识别对象。
- en: '*What is* *the answer?*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'First, let’s talk about two principles that are related to Core Data concurrency:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈与Core Data并发相关的两个原则：
- en: '**Considering a context as a sandbox**: When working with contexts, we can
    create objects, update, and delete them. We do all that only in the context and
    not in the persistent store. When we call the **save()** method, Core Data pushes
    the changes to the parent context and, if there isn’t any parent context, to the
    persistent store. We should think of context as a sandbox – we can perform changes
    and commit them only when ready.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将上下文视为沙盒**：当与上下文一起工作时，我们可以创建对象、更新和删除它们。我们只在这个上下文中执行所有这些操作，而不是在持久存储中。当我们调用**save()**方法时，Core
    Data会将更改推送到父上下文，如果没有父上下文，则推送到持久存储。我们应该将上下文视为沙盒——我们可以在准备好时执行更改并提交它们。'
- en: '**Accessing a context from the same thread that created it**: In Core Data,
    a context belongs to a thread. Once we create a new background thread, we can’t
    access an object created or fetched in another thread. Each thread needs to have
    its context to allow it.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从创建上下文的同一线程访问上下文**：在Core Data中，上下文属于一个线程。一旦我们创建了一个新的后台线程，我们就无法访问在另一个线程中创建或检索的对象。每个线程都需要自己的上下文来允许它。'
- en: After we understand these two principles, we can try to define the different
    patterns for setting up our Core Data Stack. These patterns rely on our application
    needs and requirements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解了这两个原则之后，我们可以尝试定义设置我们的Core Data堆栈的不同模式。这些模式依赖于我们的应用程序需求和需求。
- en: Let’s go over them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。
- en: Working with multiple contexts
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个上下文
- en: We have several private contexts in multiple context patterns, and each works
    directly with the persistent store. The multiple contexts are responsible for
    reading and writing and provide a flexible way to handle different concurrency
    operations across our app and do that even in a modular way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个上下文模式中，我们有几个私有上下文，并且每个上下文都直接与持久存储一起工作。多个上下文负责读取和写入，并提供了一种灵活的方式来处理我们应用程序中的不同并发操作，甚至以模块化的方式做到这一点。
- en: 'Here’s an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we create two contexts for writing (`writeContext`) and reading
    (`readContext`). It is important to note that changes we make to the writing context
    don’t reflect on the read context until we perform saving and re-fetching.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个上下文用于写入（`writeContext`）和读取（`readContext`）。重要的是要注意，我们对写入上下文所做的更改不会反映在读取上下文中，直到我们执行保存和重新检索。
- en: There are some significant drawbacks to multiple contexts patterns. For example,
    this pattern can add complexity to our database and requires us to manage changes
    between contexts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 多个上下文模式有一些显著的缺点。例如，这种模式可能会增加我们的数据库复杂性，并要求我们在上下文之间管理更改。
- en: Another drawback we may encounter is complexity with features such as batch
    changes and redo/undo, which can be critical in some application use cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的另一个缺点是与批处理更改和重做/撤销等特性相关的复杂性，这在某些应用程序用例中可能是关键的。
- en: 'However, we have a decent alternative: the parent-child context. Let’s talk
    about it.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有一个相当不错的替代方案：父-子上下文。让我们来谈谈它。
- en: Working with parent-child context
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用父-子上下文
- en: If the multiple contexts pattern has a “flat” structure, the parent-child pattern
    is more hierarchical. The basic principle states that we have a root context (aka
    “parent”) dedicated to writing operations and child contexts dedicated to reading
    operations. The parent context is private, and the child contexts work with the
    main queue. Every change we make in the writing context is reflected in the child’s
    contexts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个上下文模式具有“扁平”结构，则父-子模式更具层次性。基本原理指出，我们有一个根上下文（也称为“父”），专门用于写入操作，而子上下文专门用于读取操作。父上下文是私有的，子上下文与主队列一起工作。我们在写入上下文中进行的每个更改都会反映在子上下文中。
- en: The parent-child pattern is excellent for background updates, offline editing,
    and undo-redo use cases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 父-子模式对于后台更新、离线编辑和撤销-重做用例非常出色。
- en: 'Here’s a code example for the parent-child pattern:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个父-子模式的代码示例：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see the parent context is private, and the children are the main ones.
    Also, we can see how we linked the children to their parent directly and not to
    the persistent store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到父上下文是私有的，而子上下文是主要的。我们还可以看到我们如何直接将子上下文链接到其父上下文，而不是链接到持久存储。
- en: What does a “private context” mean?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: “私有上下文”是什么意思？
- en: A private context is typically used to perform background tasks such as importing
    or exporting data, allowing those tasks to be performed asynchronously without
    blocking the main thread.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 私有上下文通常用于执行导入或导出数据等后台任务，允许这些任务异步执行而不阻塞主线程。
- en: Overall, both parent-child and multiple contexts serve different purposes and
    use cases. It is important to say they provide basic principles for managing concurrency
    with Core Data. Combining these patterns or even using their principles to create
    a new pattern is perfectly fine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，父-子关系和多个上下文服务于不同的目的和用例。重要的是要说明它们提供了使用Core Data管理并发的基本原则。结合这些模式，甚至使用它们的原理来创建新的模式是完全可行的。
- en: And what about using NSManagedObjectID?
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么，使用`NSManagedObjectID`呢？
- en: When working with contexts, we cannot take a managed object fetched in one context
    and use it in another. We need to re-fetch it using `NSManagedObjectID`. That
    critical point may lead to an exception if not done right.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当与上下文一起工作时，我们不能将一个上下文中获取的托管对象用于另一个上下文。我们需要使用`NSManagedObjectID`重新获取它。这个关键点如果没有正确执行可能会导致异常。
- en: 'Here’s a code example of re-fetching the same object in another context using
    `NSManagedObjectID`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`NSManagedObjectID`在另一个上下文中重新获取相同对象的代码示例：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each managed object has a property named `objectID`, which is identical to the
    same object across different contexts. Its primary purpose is precisely that –
    to ensure working with the same object when moving between contexts. `NSManagedObjectID`
    is an essential concept when performing concurrency operations in Core Data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个托管对象都有一个名为`objectID`的属性，它在不同上下文中与同一对象相同。它的主要目的正是如此——确保在上下文之间移动时使用的是同一对象。`NSManagedObjectID`是执行Core
    Data并发操作时的一个基本概念。
- en: “What would your Core Data data model look like for a recipe app that includes
    ingredients, cooking instructions, and user ratings?”
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “对于一个包含成分、烹饪说明和用户评分的食谱应用，你的Core Data数据模型会是什么样子？”
- en: '*Why is this* *question important?*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要*？'
- en: We are iOS developers and not DBAs, but we have significant weight in designing
    a data model that fits our app business needs. A bad data model design directly
    influences the app’s performance and stability. As developers, it is our responsibility
    to convert the requirements and workflows of an app into a technical design, and
    this question evaluates our proficiency in achieving that objective.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是iOS开发者，而不是数据库管理员，但我们有重要的责任来设计一个符合我们应用业务需求的数据模型。糟糕的数据模型设计会直接影响应用的性能和稳定性。作为开发者，将应用的需求和工作流程转换为技术设计是我们的责任，这个问题评估了我们实现这一目标的熟练程度。
- en: '*What is* *the answer?*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么*？'
- en: 'Creating a data model for a specific app usage requires us to follow these
    steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定的应用使用创建数据模型需要我们遵循以下步骤：
- en: Understand the *app’s needs* and basic flows.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解*应用的需求*和基本流程。
- en: Define the *different entities and their attributes*, including the data types,
    default values, and more.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义*不同的实体及其属性*，包括数据类型、默认值等。
- en: Create *indexes* for the relevant attributes.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为相关属性创建*索引*。
- en: Understand the *relationships* between the different entities – one-to-one or
    one-to-many.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解不同实体之间的*关系*——一对一或一对多。
- en: Set the *deletion* rules.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置*删除*规则。
- en: These steps are always relevant when approaching a data model design, and the
    use case described in the question is no exception.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在接近数据模型设计时始终相关，问题中描述的用例也不例外。
- en: The first step is to identify the primary workflows of the app. It is important
    to remember that the data layer should support the business logic and UI and not
    exist independently. It's perfectly legitimate to ask the interviewer additional
    questions; it is even part of the task.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定应用的主要工作流程。重要的是要记住，数据层应该支持业务逻辑和UI，而不是独立存在。向面试官提出额外的问题是完全合法的；这甚至是任务的一部分。
- en: 'Second, we can define the basic entities:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我们可以定义基本实体：
- en: '**Recipe**: This holds the essential details for a single recipe. Attributes:
    title, date of creation, description, level, and category.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**食谱**：这包含单个食谱的基本细节。属性：标题，创建日期，描述，难度级别和类别。'
- en: '**Ingredient**: This can be shared across recipes. Attributes: name.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成分**：这可以在多个食谱之间共享。属性：名称。'
- en: '**Instruction**: This is part of the steps required when using a recipe. Attributes:
    description, title.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：这是使用配方时所需的步骤之一。属性：描述，标题。'
- en: '**User Rating**: This is a review of a single recipe. Attributes: name, rating
    (**int**), and description.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户评分**：这是对单个食谱的评论。属性：名称，评分（**int**），和描述。'
- en: While entities are a crucial aspect of the data model, they are often ineffective
    without clearly defining the relationships between them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实体是数据模型的关键部分，但如果没有明确定义它们之间的关系，它们通常是没有效果的。
- en: So, let’s understand how the entities are linked and the main challenges (because
    there are some!).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们了解实体是如何链接的，以及主要挑战（因为有一些挑战！）。
- en: We understand that `Recipe` has a one-to-many relationship with `Instruction`
    and a one-to-many relationship with `User Rating`. That’s easy. What do we do
    with the ingredients? The naïve approach would be to define a one-to-many relationship
    with `Ingredient`, just as we did with `Instruction` and `User Rating`. The thing
    about `Ingredient` is that we can share it across recipes. For example, let’s
    say we have a feature that helps the user find all the recipes available based
    on ingredients.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解`Recipe`与`Instruction`和`User Rating`之间存在一对一和一对一的关系。这很简单。我们该如何处理成分呢？简单的方法是定义一个与`Ingredient`的一对多关系，就像我们处理`Instruction`和`User
    Rating`一样。关于`Ingredient`的问题是我们可以在多个食谱之间共享它。例如，假设我们有一个帮助用户根据成分找到所有可用食谱的功能。
- en: 'In this case, a many-to-many relationship is required here. So, here’s something
    we learn: to construct the data model effectively, it is important to communicate
    with the interviewer and evaluate the app’s various features. We should also discuss
    potential use cases for the data to determine the best approach.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这里需要一个多对多的关系。因此，这里有一些我们学到的知识：为了有效地构建数据模型，与面试官沟通并评估应用程序的各种功能是很重要的。我们还应该讨论数据的潜在用例，以确定最佳方法。
- en: If we need to share ingredients between our recipes and create a many-to-many
    relationship, we will probably need to develop a different entity, and that’s
    `IngredientUsage`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在食谱之间共享成分并创建多对多关系，我们可能需要开发一个不同的实体，那就是`IngredientUsage`。
- en: '`IngredientUsage` represents one usage of `Ingredient` for a recipe, and it
    links between `Recipe` and `Ingredient`. Besides that link, it also provides more
    information, such as the amount.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`IngredientUsage`代表一个食谱中`Ingredient`的一次使用，并在`Recipe`和`Ingredient`之间建立链接。除了这个链接之外，它还提供了更多信息，例如数量。'
- en: 'To explore this further, let’s look at *Figure 9**.1*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探讨这个问题，让我们来看一下*图9**.1*：
- en: "![Figure 9\uFEFF.1 – Relationships between Recipe, IngredientUsage, and Ingredient](img/Figure_9.1_B18653.jpg)"
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: "![图9\uFEFF.1 – Recipe、IngredientUsage和Ingredient之间的关系](img/Figure_9.1_B18653.jpg)"
- en: Figure 9.1 – Relationships between Recipe, IngredientUsage, and Ingredient
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Recipe、IngredientUsage和Ingredient之间的关系
- en: The main issue we solve in *Figure 9**.1* is that we cannot put additional information
    about relationships in Core Data. We can define a to-many relationship between
    `Recipe` and `Ingredient`, but we cannot tell the amount. The amount can’t be
    part of `Ingredient` because we want to share the ingredient with other recipes,
    which probably have a different amount. That’s the role of `IngredientUsage`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.1*中，我们解决的主要问题是Core Data无法在关系中放置关于关系的附加信息。我们可以在`Recipe`和`Ingredient`之间定义一对多关系，但不能告诉数量。数量不能成为`Ingredient`的一部分，因为我们希望与其他食谱共享成分，这些食谱可能有不同的数量。这就是`IngredientUsage`的作用。
- en: Another helpful tip is to remember that a similar issue can arise during any
    many-to-many relationship. If it is necessary to load the relationship with more
    information, a dedicated entity for the relationship can effectively address this
    concern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的提示是记住，在多对多关系的任何情况下都可能发生类似的问题。如果需要加载包含更多信息的关系，为关系创建一个专门的实体可以有效地解决这个问题。
- en: Now that we have defined the relationships between the data models, we need
    to consider the deletion rules. Core Data has several deletion rules, and it is
    important to pick the right one so we can maintain our data over time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据模型之间的关系，我们需要考虑删除规则。Core Data有几个删除规则，选择正确的规则很重要，这样我们才能随着时间的推移维护我们的数据。
- en: For example, if we delete `Recipe`, we want its `IngredientUsage`, `User Rating`,
    and `Instruction` data to be deleted. Therefore, we define the deletion rules
    between `Recipe` and the other entities as **Cascade**. Cascade is a deletion
    rule that deletes the related objects if the source object is being deleted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们删除`Recipe`，我们希望其`IngredientUsage`、`User Rating`和`Instruction`数据被删除。因此，我们将`Recipe`与其他实体之间的删除规则定义为**级联**。级联是一个删除规则，如果源对象被删除，则删除相关对象。
- en: However, that’s not the case between `IngredientUsage` and `Ingredient`. If
    we delete `IngredientUsage`, we don’t want to delete the ingredient as it is being
    shared with other `IngredientUsage` objects. In this case, we set the deletion
    rule for **Nullify**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`IngredientUsage`和`Ingredient`之间并不是这样。如果我们删除`IngredientUsage`，我们不希望删除成分，因为它正在与其他`IngredientUsage`对象共享。在这种情况下，我们设置了**Nullify**的删除规则。
- en: What about the inverse relationships? Do we need to delete a `Recipe` object
    if we delete one of its `User Rating` objects? Probably not. We want to keep `Recipe`
    if we delete a `User Rating` object. That’s also the case with `Instruction`.
    In both cases, we set the deletion rule to *Nullify* as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于反向关系呢？如果我们删除了一个 `User Rating` 对象，是否需要删除一个 `Recipe` 对象？可能不需要。如果我们删除一个 `User
    Rating` 对象，我们希望保留 `Recipe`。对于 `Instruction` 也是如此。在这两种情况下，我们都将删除规则设置为 *Nullify*。
- en: To recap our approach, I started by outlining five fundamental steps that form
    the process of defining a data model. It’s important to note that each step builds
    upon the previous one. To proceed with the answer, we can take a collaborative
    approach with our interviewer by walking through each step and discussing our
    thought process out loud. Doing that will ensure a great answer, even though the
    solution may not be perfect or ideal. Remember that the interviewer wants to see
    our thinking and not solve a real problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们的方法，我首先概述了五个基本步骤，这些步骤构成了定义数据模型的过程。重要的是要注意，每一步都是建立在之前步骤的基础上的。为了继续回答，我们可以与面试官采取一种协作方法，通过逐一讨论每个步骤并大声说出我们的思考过程。这样做将确保得到一个很好的答案，即使解决方案可能不是完美或理想的。记住，面试官想看到我们的思考，而不是解决一个真实的问题。
- en: “How would you approach testing Core Data in an iOS app?”
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你将如何测试 iOS 应用中的 Core Data？”
- en: '*Why is this* *question important?*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Core Data is an essential framework that plays a significant role in the app’s
    data layer. As such, it will be there when we are testing our app. But what does
    it mean? How can we test a persistent store? This question checks our understanding
    of the different tests we can perform with Core Data and the tools to perform
    them effectively and consistently.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 是一个至关重要的框架，在应用程序的数据层中扮演着重要的角色。因此，在我们测试应用程序时，它将始终存在。但这究竟意味着什么？我们如何测试持久化存储？这个问题检验了我们对于使用
    Core Data 可以执行的不同测试以及执行这些测试的有效和一致性的工具的理解。
- en: '*What is* *the answer?*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: We can perform three different types of tests with Core Data, and we already
    discussed tests earlier in this book. If you need to refresh, go back to [*Chapter
    6*](B18653_06.xhtml#_idTextAnchor196) and ensure you are familiar with the different
    types of tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Core Data 执行三种不同的测试类型，我们已经在本书的早期讨论了测试。如果您需要刷新，请回到[*第 6 章*](B18653_06.xhtml#_idTextAnchor196)并确保您熟悉不同类型的测试。
- en: The first type of testing we can perform is the unit test – in this case, we
    want to simulate a Core Data Stack and not use an actual persistent store file.
    To do that, we can create an **in-memory** persistent store. The in-memory persistent
    store is lightweight, doesn’t use an actual database file, and performs all the
    I/O operations in RAM.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行的第一种测试类型是单元测试——在这种情况下，我们想要模拟一个 Core Data 栈，而不使用实际的持久化存储文件。为了做到这一点，我们可以创建一个
    **内存中的**持久化存储。内存中的持久化存储轻量级，不使用实际的数据库文件，并在 RAM 中执行所有 I/O 操作。
- en: 'Setting up an in-memory store is easy:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置内存存储很简单：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we are adding a persistent store of type `NSInMemoryStoreType`,
    which only creates an in-memory store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个类型为 `NSInMemoryStoreType` 的持久化存储，它只创建一个内存中的存储。
- en: The second type of relevant test for Core Data is integration – in this case,
    we want to keep the Core Data store as it is and verify that actions we perform
    in the business logic or even the UI layers are being saved to the Core Data file.
    It is good practice to use a temporary database file or clean the data store before
    and after each test case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Core Data 相关的另一种相关测试类型是集成测试——在这种情况下，我们希望保持 Core Data 存储不变，并验证我们在业务逻辑或甚至 UI
    层执行的操作是否被保存到 Core Data 文件中。在测试用例前后使用临时数据库文件或清理数据存储是一个好的做法。
- en: 'The third test relevant to Core Data is the performance test. Core Data consists
    of I/O operations that can be heavy to perform, and it is a good idea to ensure
    we don’t have any bottlenecks in our app. We can use the `measure` function in
    `XCTestCase` to check I/O operations:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Core Data 相关的第三种测试是性能测试。Core Data 包含一些可能执行起来很重的 I/O 操作，确保我们的应用程序中没有瓶颈是一个好主意。我们可以使用
    `XCTestCase` 中的 `measure` 函数来检查 I/O 操作：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we perform Core Data fetching and measure its duration.
    To simulate a workload, we perform the fetch operation `200` times. The test asserts
    when the duration exceeds a certain threshold.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们执行了 Core Data 检索并测量了其持续时间。为了模拟工作负载，我们执行了 `200` 次检索操作。测试断言当持续时间超过某个阈值时。
- en: To summarize – we can test Core Data in unit tests and eliminate any I/O operations,
    integration tests to ensure our system works as expected, and performance tests
    to check the impact Core Data has on our app performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下——我们可以在单元测试中测试Core Data，消除任何I/O操作，集成测试以确保我们的系统按预期工作，以及性能测试来检查Core Data对我们应用性能的影响。
- en: Handling persistent state with UserDefaults
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UserDefaults处理持久状态
- en: '`UserDefaults` is a fundamental yet simple solution for iOS developers to store
    persistent information in a key-value format. We can easily store and fetch Boolean,
    int, string, arrays, and dictionary values with UserDefaults.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDefaults`是iOS开发者以键值格式存储持久信息的根本且简单的方法。我们可以轻松地使用UserDefaults存储和检索布尔值、整数、字符串、数组和字典值。'
- en: 'For example, this is how we store a Boolean in UserDefaults:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们在UserDefaults中存储布尔值的方法：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And this is how we read it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取它的方法：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The UserDefaults goal is not to store and retrieve large datasets – UserDefaults
    is a slow and unsecured solution for that use case. If we want to manage a local
    data store, we should use Core Data or SQLite for this purpose.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: UserDefaults的目标不是存储和检索大型数据集——对于这种情况，UserDefaults是一个慢速且不安全的解决方案。如果我们想管理本地数据存储，我们应该使用Core
    Data或SQLite来完成这项任务。
- en: 'As mentioned earlier, UserDefaults is a very simple and straightforward tool.
    However, it still has some advanced capabilities we may need to know when preparing
    for our interview. Let’s review some of them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，UserDefaults是一个非常简单且直接的工具。然而，它仍然有一些我们可能在准备面试时需要了解的高级功能。让我们回顾一些：
- en: “Explain how an iOS app and its extensions can share data using UserDefaults.
    What steps are involved in setting up and using UserDefaults to share data between
    an app and its extensions?”
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “解释iOS应用及其扩展如何使用UserDefaults共享数据。设置和使用UserDefaults在应用及其扩展之间共享数据涉及哪些步骤？”
- en: '*Why is this* *question important?*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Many apps live happily isolated during their lifetime. But once we add an extension
    or another app, we will probably need to share some data between them. For example,
    we might need to share keys, tokens, or profile information.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用在其生命周期中快乐地独立存在。但一旦我们添加了一个扩展或另一个应用，我们可能需要在它们之间共享一些数据。例如，我们可能需要共享密钥、令牌或配置文件信息。
- en: Luckily, Apple provides us with a secure and easy way to do just that. Let’s
    look at the answer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Apple为我们提供了一个安全且简单的方式来做到这一点。让我们看看答案。
- en: '*What is* *the answer?*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'These are the steps we need to do to share data between an iOS app and its
    extension:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要在iOS应用和其扩展之间共享数据时执行的步骤：
- en: '**Setting up an App Group**: The App Group feature allows us to combine and
    synchronize data between multiple extensions or apps. We create a new App Group
    using the Developer Portal and enable it for both our app and the extension.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置App Group**：App Group功能允许我们在多个扩展或应用之间组合和同步数据。我们使用开发者门户创建一个新的App Group，并为其应用和扩展启用。'
- en: '**Configure the Xcode project settings**: Once we’ve set up the App Group in
    the Developer Portal, we’ll need to configure the Xcode project settings for our
    app and extensions. We’ll need to specify the App Group Identifier and enable
    the App Group entitlement for our app and extensions.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置Xcode项目设置**：一旦我们在开发者门户中设置了App Group，我们就需要为我们的应用和扩展配置Xcode项目设置。我们需要指定App
    Group标识符并启用我们的应用和扩展的App Group权限。'
- en: '**Use UserDefaults to share data**: Once the Xcode project settings have been
    configured, we can use UserDefaults to share data between our app and extensions.
    To do this, we’ll need to create a new **UserDefaults** object with the App Group
    Identifier as the suite name and then use the **set(_:forKey:)** method to save
    data and the **object(forKey:**) method to retrieve data.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用UserDefaults共享数据**：一旦配置了Xcode项目设置，我们就可以使用UserDefaults在应用和扩展之间共享数据。为此，我们需要创建一个新的**UserDefaults**对象，将App
    Group标识符作为套件名称，然后使用**set(_:forKey:)**方法保存数据，并使用**object(forKey:**)方法检索数据。'
- en: 'Here’s a code example of how to set and read data from shared `UserDefaults`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何设置和从共享`UserDefaults`中读取数据的代码示例：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code example, we are setting up a new `UserDefaults` and passing the
    App Group Identifier we defined in the Developer Portal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们正在设置一个新的`UserDefaults`，并传递我们在开发者门户中定义的App Group标识符。
- en: 'The rest of the code stays as before in this section: reading and writing using
    a key-value mechanism.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，其余的代码保持不变：使用键值机制进行读取和写入。
- en: As we can see – sharing data between an app and an extension is straightforward,
    but it is also something not many developers are familiar with. Sharing the Core
    Data store between the app and the extension is also a fundamental feature.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见——在应用和扩展之间共享数据是直接的，但这也是许多开发者不太熟悉的事情。在应用和扩展之间共享 Core Data 存储也是一个基本功能。
- en: “Can you explain how to store a struct or a class in UserDefaults in an iOS
    app?”
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释如何在 iOS 应用中用 UserDefaults 存储结构体或类吗？”
- en: '*Why is this* *question important?*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要*？'
- en: Saving primitive dictionaries and arrays is probably the most common use case
    when working with `UserDefaults`. But there are many cases where we need to store
    an entire object or a class. For example, we sometimes need to save a user object
    that contains full details, and Core Data is like using a sledgehammer to crack
    a nut.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保存原始字典和数组是使用 `UserDefaults` 时最常见的情况。但有许多情况我们需要存储整个对象或类。例如，我们有时需要保存包含完整详细信息的用户对象，而
    Core Data 就像是用大锤砸核桃。
- en: '*What is* *the answer?*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是* *答案*？'
- en: 'UserDefaults has two popular ways to store an object or a struct:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDefaults` 存储对象或结构体有两种流行的方式：'
- en: 'The first option is to use **NSKeyedArchiver**. One of the data types we can
    save in **UserDefaults** is **Data**. **NSKeyedArchiver** can take a struct or
    an object and convert it into a **Data** object, which can be saved directly to
    **NSKeyedArchiver**. To un-archive the object, we can use **NSKeyedUnarchiver**.
    Let’s see a code example for that:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项是使用 **NSKeyedArchiver**。我们可以在 **UserDefaults** 中保存的数据类型之一是 **Data**。**NSKeyedArchiver**
    可以将结构体或对象转换为 **Data** 对象，可以直接保存到 **NSKeyedArchiver** 中。要解档对象，我们可以使用 **NSKeyedUnarchiver**。让我们看看一个代码示例：
- en: '[PRE10]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this code example, we converted a `Person` struct into a `Data` object using
    `NSKeyedArchiver`. The data can be set and restored easily, like any other data
    type saved to `UserDefaults`. After we fetch the data, we can convert it into
    a `Person` object again using `NSKeyedUnarchiver`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们使用 `NSKeyedArchiver` 将 `Person` 结构体转换为 `Data` 对象。数据可以像任何其他保存到 `UserDefaults`
    的数据类型一样轻松设置和恢复。在获取数据后，我们可以使用 `NSKeyedUnarchiver` 再次将其转换为 `Person` 对象。
- en: The second option is to use **JSONEncoder**. With **JSONEncoder**, we can convert
    to a **Data** object the same way we did with **NSKeyedArchiver**. Once we have
    a data object, we can set and restore the **Person** object from **UserDefaults**.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个选项是使用 **JSONEncoder**。与 **NSKeyedArchiver** 一样，我们可以将结构体转换为 **Data** 对象。一旦我们有了数据对象，我们就可以从
    **UserDefaults** 中设置和恢复 **Person** 对象。
- en: 'Let’s see how we save and restore the same `Person` struct, but now with `JSONEncoder`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用 `JSONEncoder` 保存和恢复相同的 `Person` 结构体：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use `JSONEncoder` to convert the struct into data and `JSONDecoder` to restore
    the data back to `Person`. Notice that in this case, `Person` needs to *conform
    to Codable*, which requires its properties to also conform to Codable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `JSONEncoder` 将结构体转换为数据，使用 `JSONDecoder` 将数据恢复回 `Person`。注意，在这种情况下，`Person`
    需要遵守 *conform to Codable*，这要求其属性也遵守 Codable。
- en: Which of the options is better? There’s no clear answer. Generally, it is a
    best practice for our structs and classes to conform to **Codable** as it provides
    more capabilities such as automatic parsing and encoding.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个选项更好？没有明确的答案。通常，对于我们的结构体和类来说，遵守 **Codable** 是最佳实践，因为它提供了更多功能，如自动解析和编码。
- en: On the other hand, `NSKeyedArchiver` is more efficient than `JSONEncoder` when
    working on large or complex datasets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当处理大型或复杂的数据集时，`NSKeyedArchiver` 比 `JSONEncoder` 更高效。
- en: Both APIs are good enough for most cases, and it depends on our app structure
    and requirements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 API 对于大多数情况都足够好，这取决于我们的应用结构和需求。
- en: Storing sensitive information in the Keychain
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Keychain 中存储敏感信息
- en: '`UserDefaults` is an excellent storing mechanism, but it is unsuitable for
    storing data such as passwords or tokens. **Keychain** is Apple’s solution for
    storing sensitive data, and it provides a higher level of security and is an essential
    tool for iOS developers to protect their data.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDefaults` 是一个出色的存储机制，但它不适合存储密码或令牌等数据。**Keychain** 是 Apple 为存储敏感数据提供的解决方案，它提供了更高的安全性，并且是
    iOS 开发者保护其数据的重要工具。'
- en: Storing data in the keychain is much more complex than using other solutions.
    The keychain provides a particular API, based on the C function, to prevent malicious
    hackers from reverse-engineering calls to that API. The keychain also requires
    more information when saving, so it can save and index it more efficiently.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥链中存储数据比使用其他解决方案要复杂得多。密钥链提供了一个基于 C 函数的特定 API，以防止恶意黑客对该 API 的调用进行逆向工程。密钥链在保存时还需要更多信息，以便更有效地保存和索引。
- en: 'Let’s see how to store a simple token in the keychain while wrapping it with
    a class for convenience:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将一个简单的令牌存储在密钥链中，同时用类包装以方便使用：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing we notice from that code example is that we import the `Security`
    framework, which is also responsible for authentication, secure transport, and
    data protection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个代码示例中，我们首先注意到我们导入了 `Security` 框架，该框架也负责身份验证、安全传输和数据保护。
- en: 'We can also see that the code is much more complex than working with `UserDefaults`.
    Instead of storing a simple value, we need to create a keychain item with several
    properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，代码比使用 `UserDefaults` 要复杂得多。我们需要创建一个具有多个属性的密钥链项目，而不是存储一个简单的值：
- en: '**kSecClass**: This key specifies the level of security of the item. We can
    choose from several constants, such as **kSecClassGenericPassword**, **kSecClassInternetPassword**,
    and **kSecClassIdentity**. Choosing the correct class ensures the right level
    of security for our data.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kSecClass**: 此密钥指定了项目的安全级别。我们可以从几个常量中选择，例如 **kSecClassGenericPassword**、**kSecClassInternetPassword**
    和 **kSecClassIdentity**。选择正确的类别确保我们的数据有适当的安全级别。'
- en: '**kSecAttrService**: **kSecAttrService** defines the service name for our item.
    We can group multiple items to increase security in case of compromising part
    of the app, to share part of the keychain items, and for better organization.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kSecAttrService**: **kSecAttrService** 定义了我们项目的服务名称。我们可以将多个项目分组在一起，以增加安全性，以防应用程序的一部分被破坏，以共享部分密钥链项目，以及更好地组织。'
- en: '**kSecAttrAccount**: This is used to add identification to the keychain item,
    such as a username or email.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kSecAttrAccount**: 这用于向密钥链项目添加标识，例如用户名或电子邮件。'
- en: '**kSecValueData**: This is the actual data we want to save. It can be either
    **Data** or **String**.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kSecValueData**: 这是我们要保存的实际数据。它可以是 **Data** 或 **String**。'
- en: These four keys are not the only ones we can use for creating a keychain item,
    but they are the most common ones. Once we have `CFDictionary`, we can use `SecItemAdd`
    to push the keychain item into the keychain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个密钥并不是我们创建密钥链项目时唯一可以使用的密钥，但它们是最常见的。一旦我们有了 `CFDictionary`，我们就可以使用 `SecItemAdd`
    将密钥链项目推入密钥链。
- en: 'Here’s how to read the token back from the keychain:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从密钥链中读取令牌的示例：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To read the token, we create `CFDictionary` once again and use `SecItemCopyMatching`
    to query the keychain and retrieve the token. Afterward, we examine the results
    – if the status is `success` and we have `tokenData`, we can extract the token
    by converting it into a string and return it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取令牌，我们再次创建 `CFDictionary` 并使用 `SecItemCopyMatching` 查询密钥链并检索令牌。之后，我们检查结果——如果状态是
    `success` 并且我们有 `tokenData`，我们可以通过将其转换为字符串来提取令牌并返回它。
- en: As we can see, keychain management is not as trivial as other storage tools
    and a keychain wrapper is a good solution that can help us simplify the process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，密钥链管理并不像其他存储工具那样简单，密钥链包装器是一个很好的解决方案，可以帮助我们简化这个过程。
- en: “What is a Keychain Access Group, and how can it be used to securely share Keychain
    items between different components of an iOS app, such as the app and its extensions?”
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “什么是密钥链访问组，以及如何使用它来在 iOS 应用程序的不同组件之间安全地共享密钥链项目，例如应用程序及其扩展？”
- en: '*Why is this* *question important?*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: In the previous section, we discussed UserDefaults and how to share information
    between our app and our extensions (or other apps, for that matter). Now we are
    moving forward with that question and being asked how to share sensitive information
    between the different components. This way, our app extensions can be much more
    powerful and independent.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了 `UserDefaults` 以及如何在我们的应用程序和扩展（或其他应用程序）之间共享信息。现在我们继续这个问题，并询问如何在不同组件之间共享敏感信息。这样，我们的应用程序扩展可以更强大且更独立。
- en: '*What is* *the answer?*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: A **Keychain access group** is a unique identifier that specifies which Keychain
    items can be accessed by a particular app or extension.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥链访问组** 是一个唯一标识符，指定了哪些密钥链项目可以被特定的应用程序或扩展访问。'
- en: Access groups are defined in the app’s entitlements file and provide secure
    sharing of sensitive data between different components of an app, such as an app
    and its extensions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 访问组在应用程序的权限文件中定义，并在应用程序的不同组件之间提供敏感数据的secure sharing，例如应用程序及其扩展。
- en: By specifying the same access group for multiple components of an app, those
    components can securely share Keychain items without compromising their integrity.
    This feature is important for iOS app developers because it enables them to provide
    a secure and reliable storage mechanism for sensitive data that is accessible
    across multiple components of an app.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为应用程序的多个组件指定相同的访问组，这些组件可以安全地共享密钥链项，而不会损害其完整性。这个特性对于iOS应用程序开发者来说非常重要，因为它使他们能够为应用程序的多个组件提供安全可靠的数据存储机制。
- en: Here’s how to set up a Keychain access group and use it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何设置密钥链访问组并使用它的方法。
- en: 'First, we need to define a new access group in the app’s entitlements file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在应用程序的权限文件中定义一个新的访问组：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We must also define the same access group in the extension’s entitlement file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在扩展的权限文件中定义相同的访问组。
- en: 'Now, we can use the access group we created in our code when saving and fetching
    keychain values:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的代码中使用我们创建的访问组来保存和检索密钥链值：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice we added the `kSecAttrAccessGroup` key to our keychain item with our
    new keychain group.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加了`kSecAttrAccessGroup`键到我们的密钥链项中，并使用我们的新密钥链组。
- en: When working with the keychain, we can see that most of our boilerplate is the
    different keychain values management, while setting up an access group is easy
    and simple.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当与密钥链一起工作时，我们可以看到我们的大部分样板代码是不同的密钥链值管理，而设置访问组则简单且直接。
- en: Generally speaking – working with the iOS keychain is not as straightforward
    as the other tools we have – it requires more code, using C functions, and providing
    additional keys and information. But iOS development requires us to work with
    sensitive information and even share it between our apps. Therefore, we must understand
    how the keychain works and how to approach it with its API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言——与iOS密钥链一起工作并不像我们拥有的其他工具那样简单——它需要更多的代码，使用C函数，并提供额外的键和信息。但iOS开发要求我们处理敏感信息，甚至在我们之间共享它。因此，我们必须了解密钥链是如何工作的，以及如何使用其API来处理它。
- en: Working with the filesystem
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统一起工作
- en: There’s a common assumption that iOS “doesn’t have a filesystem.” And even though
    there is a **Files** app, it is true that the filesystem is almost hidden for
    most standard users.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常见的假设是iOS“没有文件系统”。尽管有“文件”应用，但对于大多数标准用户来说，文件系统几乎是隐藏的。
- en: That’s not the case for iOS developers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS开发者来说，情况并非如此。
- en: iOS developers use the iOS filesystem to store documents, images, cache files,
    and even database files.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: iOS开发者使用iOS文件系统来存储文档、图像、缓存文件，甚至数据库文件。
- en: The filesystem allows us to store a large set of information, work with resources
    and even share data with other app components. Most interview questions focus
    on organizing our files and responding to different use cases. Understanding how
    the sandbox is built is crucial for us as developers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统允许我们存储大量信息，处理资源，甚至与其他应用程序组件共享数据。大多数面试问题都集中在组织我们的文件和响应不同的用例上。理解沙盒是如何构建的对于我们作为开发者来说至关重要。
- en: So, let’s review a question about our sandbox structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一个关于我们的沙盒结构的问题。
- en: '“Can you explain the purpose of each of the following folders in an iOS app:
    Documents, Library, Cache, and Temp? How would you decide which folder to use
    for storing different types of files in your app?”'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下iOS应用程序中以下文件夹的用途吗：Documents、Library、Cache和Temp？你将如何决定在你的应用程序中存储不同类型的文件使用哪个文件夹？”
- en: '*Why is this* *question important?*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: File operations in iOS for reading and writing are generally straightforward
    from a technical perspective. However, the key is to grasp the methodological
    concept of properly organizing files in the appropriate folder. Each folder serves
    a distinct purpose and possesses different characteristics, and the iOS system
    distinctly manages each folder.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，iOS中的文件操作在读取和写入方面通常很简单。然而，关键在于掌握在适当文件夹中正确组织文件的方法论概念。每个文件夹都有其独特的作用和特性，iOS系统会明确管理每个文件夹。
- en: '*What is* *the answer?*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'As mentioned, each folder has its distinct purpose and characteristics, so
    let’s go over them here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个文件夹都有其独特的作用和特性，所以让我们在这里了解一下：
- en: '**Documents**: This folder is meant for storing data that can be created or
    edited by the user, such as documents, images, and videos. This folder is backed
    up by iCloud and is visible to the user through iTunes file sharing. We should
    use this folder for data that the user expects to be available even after the
    app is closed.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Documents**: 此文件夹旨在存储用户可以创建或编辑的数据，例如文档、图片和视频。此文件夹由iCloud备份，并且用户可以通过iTunes文件共享看到。我们应该为此文件夹使用用户期望在应用关闭后仍然可用的数据。'
- en: '**Library**: This folder is intended for storing app-specific data not created
    by the user, such as downloaded content, cache files, and preferences. This folder
    is backed up by iCloud but is not visible to the user through iTunes file sharing.
    We should use this folder for important data for the app’s functionality, but
    it can be recreated if necessary.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Library**: 此文件夹旨在存储由用户未创建的应用特定数据，例如下载内容、缓存文件和首选项。此文件夹由iCloud备份，但用户通过iTunes文件共享无法看到。我们应该为此文件夹使用对应用功能重要但必要时可以重新创建的数据。'
- en: '**Cache**: This folder is designed for storing temporary files that can be
    regenerated or downloaded again. This folder is not backed up by iCloud and can
    be emptied by the system when the device runs low on storage. We should use this
    folder for data that is not critical of the app’s functionality and can be discarded
    if necessary.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cache**: 此文件夹设计用于存储可以重新生成或再次下载的临时文件。此文件夹不由iCloud备份，当设备存储空间不足时，系统可以清空此文件夹。我们应该为此文件夹使用对应用功能非关键且必要时可以丢弃的数据。'
- en: '**Temp**: iOS also provides a temporary directory for storing temporary files,
    known as the **Temp** folder. This folder is intended to hold only needed temporary
    files and can be deleted when the app is closed.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Temp**: iOS还为存储临时文件提供了一个临时目录，称为**Temp**文件夹。此文件夹仅用于存放所需的临时文件，当应用关闭时可以删除。'
- en: The content type leads us to decide which folder to store our files. For example,
    we want to use the `Documents` folder for user-generated files. We can use the
    `Temp` folder if we need temporary files for generating information or calculations.
    The `Library` folder is suitable for storing the local data persistent store file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 内容类型引导我们决定将文件存储在哪个文件夹中。例如，我们希望使用`Documents`文件夹来存储用户生成的文件。如果我们需要临时文件来生成信息或计算，可以使用`Temp`文件夹。`Library`文件夹适合存储本地数据持久存储文件。
- en: Storing a file in the wrong folder may lead to unexpected behavior, such as
    data loss, performance issues, and increasing the user backup size for no reason.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件存储在错误的文件夹可能会导致意外的行为，例如数据丢失、性能问题，以及无端增加用户备份大小。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over some critical topics in persistent memory. We
    discussed Core Data concurrency and data model design, advanced topics in `UserDefaults`,
    how to handle sensitive information with the Keychain, and the different folders
    in our app sandbox.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了持久内存的一些关键主题。我们讨论了Core Data并发和数据模型设计、`UserDefaults`的高级主题、如何使用Keychain处理敏感信息，以及我们应用沙盒中的不同文件夹。
- en: By now, we should ultimately be ready for that topic in our interview!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们应该为面试中的那个主题做好准备！
- en: 'The next chapter will cover an essential topic that could hinder the scalability
    of an app for iOS developers who are unfamiliar with it: CocoaPods and the Swift
    Package Manager.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖一个可能阻碍iOS开发者（如果他们不熟悉）的应用可扩展性的关键主题：CocoaPods和Swift包管理器。
