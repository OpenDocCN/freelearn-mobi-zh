- en: Chapter 5. Creating Custom Views in Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 使用 Swift 创建自定义视图
- en: User interfaces can be built by combining standard views and view controllers
    through Interface Builder, Storyboard Editor, or with custom code. However, it
    will eventually become necessary to break apart a user interface into smaller,
    reusable, and easier to test segments. These are known as *custom views*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面可以通过 Interface Builder、Storyboard 编辑器或自定义代码通过组合标准视图和视图控制器来构建。然而，最终可能需要将用户界面分解成更小、可重用且易于测试的片段。这些被称为
    *自定义视图*。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Customizing table views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义表格视图
- en: Building and laying out custom view subclasses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和布局自定义视图子类
- en: Drawing graphical views with `drawRect`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `drawRect` 绘制图形视图
- en: Creating layered graphics with animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画创建分层图形
- en: An overview of UIView
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UIView 概述
- en: 'All iOS views are rooted in an Objective-C class called `UIView`, which comes
    from the `UIKit` framework/module. The `UIView` class represents a rectangular
    space that may be associated with `UIWindow` or constructed to represent an off-screen
    view. Views that perform user interactions are generally subclasses of `UIControl`.
    Both `UIView` and `UIViewController` inherit from the `UIResponder` class, which
    in turn inherits from `NSObject`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 iOS 视图都基于一个名为 `UIView` 的 Objective-C 类，该类来自 `UIKit` 框架/模块。`UIView` 类代表一个可能关联到
    `UIWindow` 或用于表示离屏视图的矩形空间。执行用户交互的视图通常是 `UIControl` 的子类。`UIView` 和 `UIViewController`
    都继承自 `UIResponder` 类，而 `UIResponder` 类又继承自 `NSObject`：
- en: '![An overview of UIView](img/00066.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![UIView 概述](img/00066.jpeg)'
- en: On Mac OS X, views are rooted in NSView and come from the `AppKit` framework.
    Otherwise, these two implementations are very similar. A new Xcode project will
    be used to create custom view classes. Create a new project called `CustomViews`
    that is based on the **Tabbed Application** template. To start with a blank sheet,
    delete the generated view controllers from the `Main.storyboard` and their associated
    `FirstViewController` and `SecondViewController` classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，视图基于 NSView，来自 `AppKit` 框架。否则，这两个实现非常相似。将使用一个新的 Xcode 项目来创建自定义视图类。创建一个基于
    **标签应用** 模板的名为 `CustomViews` 的新项目。要从一个空白表单开始，请从 `Main.storyboard` 中删除生成的视图控制器及其相关的
    `FirstViewController` 和 `SecondViewController` 类。
- en: Creating new views with Interface Builder
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Interface Builder 创建新视图
- en: The easiest way to create a custom view is to use Interface Builder to drag
    and drop the contents. This is typically done with a `UITableView` and a *prototype
    table cell*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义视图最简单的方法是使用 Interface Builder 拖放内容。这通常是通过 `UITableView` 和 *原型表格单元格* 来完成的。
- en: Creating a table view controller
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表格视图控制器
- en: Drag in a **Table View Controller** from the object library onto the main storyboard,
    and drag and drop from the tab bar controller to the newly created table view
    controller to create a relation segue called `view controllers`. (Segues are covered
    in more detail in the *Storyboards*, *Segues* *, and Scenes* section in [Chapter
    4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b "Chapter 4. Storyboard
    Applications with Swift and iOS"), *Storyboard Applications with Swift and iOS*.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象库中将 **Table View Controller** 拖放到主故事板中，然后从标签栏控制器拖放到新创建的表格视图控制器中，以创建一个名为 `view
    controllers` 的关系转换。（转换在 [第 4 章](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "第 4 章. 使用 Swift 和 iOS 的 Storyboard 应用") 的 *Storyboards*、*转换* 和 *场景* 部分有更详细的介绍，*Storyboard
    Applications with Swift and iOS*。）
- en: 'By default, the table view controller will have *dynamic property content*—that
    is, it will be able to display a variable number of rows. This is defined in the
    **Table View** section of **Attributes Inspector**, which can be displayed by
    selecting **Table View** from the scene navigator and then pressing *Command*
    + *Option* + *4*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表格视图控制器将具有 *动态属性内容*——也就是说，它能够显示可变数量的行。这定义在 **表格视图** 部分的 **属性检查器** 中，可以通过从场景导航器中选择
    **表格视图** 并按 *Command* + *Option* + *4* 来显示：
- en: '![Creating a table view controller](img/00067.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![创建表格视图控制器](img/00067.jpeg)'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is an option for tables to have *static content*; a fixed number of rows
    in the table. This is sometimes useful when creating scrollable content that can
    be partitioned into slices, even if it doesn't look like a table. Most of the
    elements in the iOS settings are represented as a fixed-size table view. At the
    top of the table view are one or more *prototype cells*. These are used to define
    the look and feel of the table items. By default, a `UITableViewCell` is used,
    which has a label and an image, but a prototype cell can be used to add more data
    to the entries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表格有一个选项可以具有*静态内容*；表格中的固定行数。这在创建可以分割成块的可滚动内容时有时很有用，即使它看起来不像表格。iOS设置中的大多数元素都表示为固定大小的表格视图。在表格视图的顶部有一个或多个**原型单元格**。这些用于定义表格项的外观和感觉。默认情况下，使用`UITableViewCell`，它有一个标签和一个图像，但可以使用原型单元格向条目添加更多数据。
- en: '![Creating a table view controller](img/00068.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![创建表格视图控制器](img/00068.jpeg)'
- en: The prototype cell can be used to provide additional information or views. For
    example, two labels can be dragged into the view; one label can be centered at
    the top and can be displayed in the headline font, while the second can be left-aligned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用原型单元格提供额外的信息或视图。例如，可以将两个标签拖入视图中；一个标签可以居中在顶部，并使用标题字体显示，而第二个可以左对齐。
- en: Drag two **UILabels** from the object library into the prototype cell and arrange
    them using **Auto Layout**, appropriately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象库中拖动两个**UILabel**到原型单元格中，并使用**Auto Layout**适当地排列它们。
- en: 'To change a label''s font, select the label in the editor and go to **Attributes
    Inspector**. In the **Label** section, click on the **Font Chooser** icon and
    select **Headline** or **Subhead**, as appropriate:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改标签的字体，在编辑器中选择标签，然后转到**属性检查器**。在**标签**部分，单击**字体选择器**图标并选择**标题**或**副标题**，根据需要：
- en: '![Creating a table view controller](img/00069.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![创建表格视图控制器](img/00069.jpeg)'
- en: 'When finished, the prototype cell will look similar to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，原型单元格将类似于以下截图：
- en: '![Creating a table view controller](img/00070.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![创建表格视图控制器](img/00070.jpeg)'
- en: When the application is run, an empty table will be seen. This is because the
    table doesn't have any items displayed at the moment. The next section shows how
    to add data to a table so that it binds and displays items to the prototype cell.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，将看到一个空表格。这是因为表格目前没有显示任何条目。下一节将展示如何向表格添加数据，以便将其绑定并显示到原型单元格中。
- en: Showing data in the table
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表格中显示数据
- en: A `UITableView` acquires data from a `UITableViewDataSource`. The `UITableViewController`
    class already implements the `UITableViewDataSource` protocol, so only a small
    number of methods are required to provide data for the table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView`从`UITableViewDataSource`获取数据。`UITableViewController`类已经实现了`UITableViewDataSource`协议，因此只需要实现少量方法来为表格提供数据。'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As `UITableView` was originally implemented in Objective-C, the methods that
    are defined in the protocol take a `tableView`. As a result, all of the `UITableViewDataSource`
    delegate methods in Swift end up being called `tableView` with different arguments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`UITableView`最初是用Objective-C实现的，因此协议中定义的方法接受一个`tableView`。因此，Swift中的所有`UITableViewDataSource`代理方法最终都以`tableView`结尾，并带有不同的参数。
- en: 'Create a new `SampleTable` class that extends `UITableViewController`. Implement
    the class as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`SampleTable`类，该类继承自`UITableViewController`。按照以下方式实现该类：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the data source methods are implemented, the labels need to be configured
    to display the data from the array. There are three things that need to be done:
    the prototype cell must be acquired from the `xib` file; the labels need to be
    extracted; and finally the table view controller needs to be associated with the
    custom `SampleTable` class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实现数据源方法后，需要配置标签以显示数组中的数据。需要完成三件事：从`xib`文件中获取原型单元格；提取标签；最后，将表格视图控制器与自定义的`SampleTable`类关联。
- en: 'Firstly, the `cellForRowAtIndex` function needs an identifier for reusable
    cells. The **Identifier** is set on the prototype cell in the main storyboard.
    To set this, select the prototype cell and go to the **Attributes Inspector**.
    Enter `prototypeCell` in the **Identifier** of the **Table View Cell** section:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`cellForRowAtIndex`函数需要一个可重用单元格的标识符。**标识符**在主故事板中的原型单元格上设置。要设置此标识符，请选择原型单元格，然后转到**属性检查器**。在**表格视图单元格**部分的**标识符**中输入`prototypeCell`：
- en: '![Showing data in the table](img/00071.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在表格中显示数据](img/00071.jpeg)'
- en: The identifier is used in the `dequeueReusableCellWithIdentifier` method of
    the `tableView`. When a `xib` is used to load the cell, the return value will
    either reuse a cell that has gone off screen earlier, or a new cell will be instantiated
    from the `xib`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符用于`tableView`的`dequeueReusableCellWithIdentifier`方法中。当使用`xib`来加载单元格时，返回值将要么是之前已经离开屏幕的单元格，要么是从`xib`中实例化出的新单元格。
- en: 'Each label can be given a non-zero integer **Tag** so that the label can be
    extracted from the prototype cell using the `viewWithTag` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签都可以分配一个非零整数**Tag**，这样就可以使用`viewWithTag`方法从原型单元格中提取标签：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To assign tags to the views, select the **Heading Label**, navigate to **Attributes
    Inspector**, and change **Tag** to `1`. Do the same thing for the **Subheading
    Label** with **Tag** set to `2`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要为视图分配标签，选择**Heading Label**，导航到**Attributes Inspector**，并将**Tag**更改为`1`。对**Subheading
    Label**做同样的事情，将**Tag**设置为`2`：
- en: '![Showing data in the table](img/00072.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![在表中显示数据](img/00072.jpeg)'
- en: 'Now, the text values for the row can be set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以设置行的文本值：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, the `SampleTable` needs to be associated with the table view controller.
    Click the table, go to **Identity Inspector**, and enter `SampleTable` in the
    **Custom Class** section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要将`SampleTable`与表格视图控制器关联起来。点击表格，进入**Identity Inspector**，在**Custom Class**部分输入`SampleTable`：
- en: '![Showing data in the table](img/00073.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![在表中显示数据](img/00073.jpeg)'
- en: 'When the application is run, the following view will be displayed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，将显示以下视图：
- en: '![Showing data in the table](img/00074.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![在表中显示数据](img/00074.jpeg)'
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To hide the status bar, add or change **Status bar is initially hidden** to
    **YES** and **View controller-based status bar appearance** to **NO** in the `Info.plist`
    file. Please note that Xcode 7 displays a `CGContextRestoreGState: invalid context
    0x0` error message when using these options, which is a known issue that may be
    fixed in later releases.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '要隐藏状态栏，在`Info.plist`文件中添加或更改**Status bar is initially hidden**为**YES**，并将**View
    controller-based status bar appearance**设置为**NO**。请注意，Xcode 7在使用这些选项时显示`CGContextRestoreGState:
    invalid context 0x0`错误消息，这是一个已知问题，可能在后续版本中修复。'
- en: Defining a view in a xib file
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在xib文件中定义视图
- en: It is possible to create a view using **Interface Builder**, save it as a `xib`
    file, and then instantiate it on demand. This is what happens under the covers
    with `UITableView`—there is a `registerNib:forCellReuseIdentifier:` method, which
    takes a `xib` file and an identifier (which corresponds to `prototypeCell` in
    the previous example).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**Interface Builder**创建视图，将其保存为`xib`文件，然后按需实例化。这就是`UITableView`背后的操作——存在一个`registerNib:forCellReuseIdentifier:`方法，它接受一个`xib`文件和一个标识符（在先前的例子中对应于`prototypeCell`）。
- en: 'Create a new interface file named `CounterView.xib` to represent the view,
    by navigating to **File** | **New** | **File** | **iOS** | **User Interface**
    | **View**. When opened, it will display as an empty view with no content and
    in a 600 x 600 square. To change the size to something that is a little more reasonable,
    go to **Attributes Inspector** and change the size from **Inferred** to **Freeform**.
    At the same time, change the **Status Bar**, **Top Bar**, and **Bottom Bar** to
    **None**. Then switch to the **Size Inspector** and modify the view''s **Frame
    Rectangle** to `300` x `50`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到**File** | **New** | **File** | **iOS** | **User Interface** | **View**创建一个名为`CounterView.xib`的新接口文件来表示视图。打开后，它将显示为一个空视图，没有内容，并且在一个600
    x 600的正方形中。要将大小更改为更合理的尺寸，转到**Attributes Inspector**并将大小从**Inferred**更改为**Freeform**。同时，将**Status
    Bar**、**Top Bar**和**Bottom Bar**更改为**None**。然后切换到**Size Inspector**并修改视图的**Frame
    Rectangle**为`300` x `50`：
- en: '![Defining a view in a xib file](img/00075.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![在xib文件中定义视图](img/00075.jpeg)'
- en: 'This should resize the view so that it is displayed as 300 by 50 instead of
    the previous 600 by 600, and the status bar and other bars should not be seen.
    Now add a **Stepper** from the object library by dragging it to the left-hand
    side of the view and dragging a **Label** to the right. Adjust the size and add
    the missing constraints so that the view looks similar to the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会调整视图的大小，使其显示为300 x 50而不是之前的600 x 600，并且状态栏和其他栏不应可见。现在，通过从对象库中拖动到视图的左侧添加一个**Stepper**，并将一个**Label**拖到右侧。调整大小并添加缺失的约束，使视图看起来类似于以下截图：
- en: '![Defining a view in a xib file](img/00076.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在xib文件中定义视图](img/00076.jpeg)'
- en: Wiring a custom view class
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接自定义视图类
- en: Create a new `CounterView` class that extends `UIView`, and define an `@IBOutlet`
    for the `label` and an `@IBAction` `change` method that takes a `sender`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `CounterView` 类，它扩展了 `UIView`，并为 `label` 定义一个 `@IBOutlet`，以及一个接受 `sender`
    的 `@IBAction` `change` 方法。
- en: 'Open the `CounterView.xib` file and select the view. Change **Custom Class**
    to be `CounterView`. Wire the stepper''s `valueChanged` event to the `change`
    method and connect the `label` outlet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `CounterView.xib` 文件并选择视图。将 **Custom Class** 更改为 `CounterView`。将步进器的 `valueChanged`
    事件连接到 `change` 方法，并连接到 `label` 输出：
- en: '![Wiring a custom view class](img/00077.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![连接自定义视图类](img/00077.jpeg)'
- en: 'Implement the `change` function such that the label text is changed when the
    stepper is picked:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `change` 函数，以便在选择步进器时更改标签文本：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CounterView` will be added to the **table header** of the `SampleTable`.
    Each `UITableViewController` has a reference to its associated `UITableView`,
    and each `UITableView` has an optional `headerView` (and `footerView`) that is
    used for the table as a whole.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CounterView` 将被添加到 `SampleTable` 的 **表头** 中。每个 `UITableViewController` 都有一个对其关联的
    `UITableView` 的引用，每个 `UITableView` 都有一个用于整个表格的可选 `headerView`（和 `footerView`）。'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UITableView` also has `sectionHeader` and `sectionFooter`, which are used
    to separate different sections of the table. A table can have multiple sections—for
    example, one section per month—and a separate header and footer can be used per
    section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 还具有 `sectionHeader` 和 `sectionFooter`，它们用于分隔表格的不同部分。一个表格可以有多个部分——例如，每个月一个部分——并且每个部分都可以使用单独的头部和尾部。'
- en: 'To create a `CounterView`, the `xib` file must be loaded. This is done by instantiating
    a `UINib` with a `nibName` and a `bundle`. The most appropriate place to do this
    is in the `viewDidLoad` method of the `SampleTable` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `CounterView`，必须加载 `xib` 文件。这是通过使用 `nibName` 和 `bundle` 实例化一个 `UINib`
    来实现的。最合适的地方是在 `SampleTable` 类的 `viewDidLoad` 方法中完成这个操作：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the `xib` is loaded, the view must be created. The `instantiateWithOwner`
    method allows the object(s) in the `xib` to be deserialized.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载 `xib`，就必须创建视图。`instantiateWithOwner` 方法允许将 `xib` 中的对象反序列化。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to store multiple objects in a `xib` file (for example, to define
    a separate view that is suitable for a small display device versus a big display
    device); but in general, a `xib` file only contains one view.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `xib` 文件中可以存储多个对象（例如，为了定义一个适合小显示设备而不是大显示设备的单独视图）；但通常，`xib` 文件只包含一个视图。
- en: 'The owner is passed to the view so that any connections can be wired up to
    the File''s Owner in the interface. This is typically either `self` or `nil` if
    there are no connections:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权传递给视图，以便可以将任何连接连接到界面的文件所有者。这通常是 `self`，如果没有连接则为 `nil`：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This returns an array of `AnyObject` instances, and so casting the first element
    to a `UIView` is a common step.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个 `AnyObject` 实例的数组，因此将第一个元素强制转换为 `UIView` 是一个常见的步骤。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is possible to use `objects[0]`, but this will cause a failure if the array
    is empty. Instead, use `objects.first` to get an optional value that contains
    the first element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `objects[0]`，但如果数组为空，这将导致失败。相反，使用 `objects.first` 来获取包含第一个元素的可选值。
- en: 'Using the `as?` cast, it is possible to convert the optional value to a more
    specific type, and from this, perform the assignment to the `tableHeaderView`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `as?` 强制类型转换，可以将可选值转换为更具体的类型，并从这一点进行到 `tableHeaderView` 的赋值：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When this application is run in the simulator, the following header is seen
    at the top of the table:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当在这个模拟器中运行此应用程序时，可以在表格顶部看到以下头部：
- en: '![Wiring a custom view class](img/00078.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![连接自定义视图类](img/00078.jpeg)'
- en: 'One of the advantages of having a `xib` to represent the user interface is
    that it can be reused in many places with a single definition. For example, it
    is possible to use the same `xib` to instantiate another view for the footer of
    the table, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个 `xib` 来表示用户界面的一个优点是，它可以使用单个定义在许多地方重用。例如，可以使用相同的 `xib` 来实例化另一个视图作为表格的底部，如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the application is run now, counters are created at the top and bottom
    of the table:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序现在运行时，计数器会在表格的顶部和底部创建：
- en: '![Wiring a custom view class](img/00079.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![连接自定义视图类](img/00079.jpeg)'
- en: Dealing with intrinsic size
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理固有大小
- en: 'When a view is added into a view that is being managed with **Auto Layout**,
    its *intrinsic content size* is used. Unfortunately, views that are defined in
    **Interface Builder** have no way of setting their intrinsic size programmatically
    or specifying it in Interface Builder. **Size Inspector** allows this value to
    be changed, but as Xcode notes, this has no effect at runtime:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个视图被添加到一个使用 **Auto Layout** 管理的视图中时，它将使用其 *固有内容大小*。不幸的是，在 **Interface Builder**
    中定义的视图没有方法可以程序化地设置其固有大小或在 Interface Builder 中指定它。**大小检查器** 允许更改此值，但正如 Xcode 所注明的，这在运行时没有任何效果：
- en: '![Dealing with intrinsic size](img/00080.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![处理固有大小](img/00080.jpeg)'
- en: 'If a custom class is associated with the view, then an appropriate intrinsic
    size can be defined. Add a method to `CounterView` that overrides the `intrinsicContentSize`
    method and returns a `CGSize`, allows some `xib` customization, and returns the
    maximum of the label''s intrinsic size and a value, such as `(300,50)`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个自定义类与视图相关联，则可以定义一个适当的固有大小。向 `CounterView` 添加一个方法，重写 `intrinsicContentSize`
    方法并返回一个 `CGSize`，允许一些 `.xib` 自定义，并返回标签的固有大小和某个值（如 `(300,50)`）的最大值：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now when the view is added into a view that is managed by Auto Layout, it will
    have an appropriate initial size although it can grow larger.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当视图被添加到一个由 Auto Layout 管理的视图中时，它将有一个适当的初始大小，尽管它可以变得更大。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size should take into account the size of the various views that are contained
    inside, as well as any font sizes or themes, which might change the view. Using
    the label's `intrinsicSize` to calculate a maximum is a good idea.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大小应该考虑到包含在其中的各种视图的大小，以及任何可能改变视图的字体大小或主题。使用标签的 `intrinsicSize` 来计算最大值是一个好主意。
- en: Creating new views by subclassing UIView
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过子类化 `UIView` 创建新视图
- en: 'Although the `xib` files offer a mechanism to customize classes, the majority
    of `UIKit` views outside of standard frameworks are implemented in custom code.
    This makes it easier to reason what the intrinsic size should be as well as to
    receive code patches and understand `diffs` from version control systems. The
    downside of this approach is when using Auto Layout, writing the constraints can
    be a challenge and the intrinsic sizes are often misreported or return the unknown
    value: `(-1,-1)`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`.xib` 文件提供了一个自定义类的机制，但标准框架之外的大多数 `UIKit` 视图都是通过自定义代码实现的。这使得推理固有大小应该是什么以及接收代码补丁和理解版本控制系统的
    `diffs` 变得更容易。这种方法的一个缺点是，在使用 Auto Layout 时，编写约束可能是一个挑战，固有大小通常报告错误或返回未知值：`(-1,-1)`。
- en: A custom view can be implemented as a subclass of `UIView`. Subclasses of `UIView`
    are expected to have two initializers, one that takes a `frame:CGRect` and one
    that takes a `coder:NSCoder`. The `frame` is generally used in code, and the `rect`
    specifies the position on screen (`0,0` is the top-left) along with the `width`
    and `height`. The `coder` is used when deserializing from a `xib` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义视图可以作为一个 `UIView` 的子类来实现。`UIView` 的子类通常应该有两个初始化器，一个接受 `frame:CGRect` 参数，另一个接受
    `coder:NSCoder` 参数。`frame` 通常在代码中使用，它指定了屏幕上的位置（`0,0` 是左上角）以及宽度和高度。`coder` 在从 `xib`
    文件反序列化时使用。
- en: To allow custom subclasses to either be used in Interface Builder or instantiated
    from code, it is good practice to ensure that both the initializers create the
    necessary views. This can be done using a third method called `setupView`, which
    is invoked from both.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许自定义子类既可以在 Interface Builder 中使用，也可以从代码中实例化，一个好的做法是确保两个初始化器都创建了必要的视图。这可以通过一个名为
    `setupView` 的第三个方法来完成，它从两个地方调用。
- en: 'Create a class called `TwoLabels` that has two labels in a view:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `TwoLabels` 的类，该类在视图中包含两个标签：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `setupView` call will add the subviews to the view. Code that goes in here
    should be executed only once. There isn't a standard name, and often, example
    code will place the setup in one or other of the `init` methods instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupView` 调用将子视图添加到视图中。这里放入的代码应该只执行一次。没有标准的名称，通常示例代码会将设置放在一个或另一个 `init` 方法中。'
- en: 'It is conventional to have a separate method, such as `configureView`, to populate
    the UI with the current set of data. This can be called repeatedly based on the
    state of the system; for example, a field may be enabled or disabled based on
    some condition. This code should be repeatable so that it does not modify the
    view hierarchy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有一个单独的方法，例如 `configureView`，用于用当前的数据集填充 UI。这可以根据系统的状态重复调用；例如，一个字段可能根据某些条件被启用或禁用。此代码应该是可重复的，以便它不会修改视图层次结构：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In an explicitly sized environment (where the text label is being set and placed
    at a particular location), there is a `layoutSubviews` method that is called to
    request the view to be laid out correctly. However, there is a better way to do
    this, which is to use Auto Layout and constraints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式设置大小环境中（其中文本标签正在设置并放置在特定位置），有一个`layoutSubviews`方法被调用以请求正确布局视图。然而，有一种更好的方法，那就是使用自动布局和约束。
- en: Auto Layout and custom views
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动布局和自定义视图
- en: Auto Layout is covered in the *Using Auto Layout* section of [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*. When creating a user interface explicitly, views must be
    sized and managed appropriately. The easiest way to manage this is to use Auto
    Layout, which requires constraints to be added in order to set up the views.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自动布局在[第4章](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b "第4章。使用Swift和iOS的Storyboard应用")的*使用自动布局*部分中介绍，*使用Swift和iOS的Storyboard应用*。在显式创建用户界面时，必须适当地设置和管理工作视图。管理这些视图的最简单方法是使用自动布局，这需要添加约束来设置视图。
- en: 'Constraints can be added or updated in the `updateConstraints` method. This
    is called after `setNeedsUpdateConstraints` is called. Constraints may need to
    be updated if views become visible or the data is changed. Typically, this can
    be triggered by placing a call at the end of the `setupView` method, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`updateConstraints`方法中添加或更新约束。这通常在调用`setNeedsUpdateConstraints`之后进行。如果视图变得可见或数据发生变化，可能需要更新约束。通常，这可以通过在`setupView`方法末尾放置一个调用来实现，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `updateConstraints` method needs to do several things. To prevent autoresizing
    masks being translated into constraints, each view needs to call `setTranslatesAutoresizingMaskIntoConstraints`
    with an argument of `false`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateConstraints`方法需要执行几个操作。为了防止自动调整大小掩码被转换为约束，每个视图都需要调用`setTranslatesAutoresizingMaskIntoConstraints`并传递参数`false`。'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To facilitate the transition between springs and struts (also known as autoresizing
    masks) and Auto Layouts, views can be configured to translate springs and struts
    into Auto Layout constraints. This is enabled by default for all views in order
    to provide backward compatibility for existing views, but it should be disabled
    when implementing Auto Layouts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在弹簧和支柱（也称为自动调整大小掩码）之间以及自动布局之间进行转换，可以配置视图将弹簧和支柱转换为自动布局约束。默认情况下，对所有视图启用此功能，以提供对现有视图的向后兼容性，但在实现自动布局时应将其禁用。
- en: 'Either the constraints can be incrementally updated or the existing constraints
    can be removed. A `removeConstraints` method allows existing constraints to be
    removed first, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以增量更新约束或删除现有约束。`removeConstraints`方法允许首先删除现有约束，如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Constraints can be added programmatically using the `NSLayoutConstraint` class.
    The constraints that are added in Interface Builder are also instances of the
    `NSLayoutConstraint` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`NSLayoutConstraint`类编程添加约束。在Interface Builder中添加的约束也是`NSLayoutConstraint`类的实例。
- en: 'Constraints are represented as an equation; properties of two objects are related
    as an equality (or inequality) of the following form:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 约束表示为一个方程；两个对象的属性以以下形式的等式（或不等式）相关联：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To declare that both labels are of equal width, the following can be added
    to the `updateConstraints` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明两个标签具有相同的宽度，可以在`updateConstraints`方法中添加以下内容：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Constraints and the visual format language
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束和视觉格式语言
- en: Although adding individual constraints gives us ultimate flexibility, it can
    be tedious to set up programmatically. The *visual format language* can be used
    to add multiple constraints to a view. This is an ASCII-based representation that
    allows views to be related to each other in position and extrapolated into an
    array of constraints.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然添加单个约束为我们提供了最大的灵活性，但通过编程设置可能会很繁琐。可以使用*视觉格式语言*向视图添加多个约束。这是一种基于ASCII的表示，允许视图在位置上相互关联，并扩展成约束数组。
- en: Constraints can be applied horizontally (the default) or vertically. The `|`
    character can be used to represent either the start or end of the containing superview,
    and `–` is used to represent the space that separates views, which are named in
    `[]` and referenced in a dictionary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以水平（默认）或垂直应用。`|`字符可以用来表示包含的父视图的开始或结束，而`-`用来表示在`[]`中命名的视图之间的空间，这些视图在字典中引用。
- en: To constrain the two labels that are next to each other in the view, `H:|-[left]-[right]-|`
    can be used. This can be read as a horizontal (`H:`) with a gap from the left
    edge (`|-`) followed by the left view (`[left]`), a gap (`-`), a right view (`[right]`),
    and finally, a gap from the right edge (`-|`). Similarly, vertical constraints
    can be added with a `V:` prefix.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要约束在视图中相邻的两个标签，可以使用 `H:|-[left]-[right]-|`。这可以读作一个水平（`H:`）从左边距（`|-`）开始，然后是左视图（`[left]`），一个间隔（`-`），一个右视图（`[right]`），最后是一个从右边距的间隔（`-|`）。同样，可以使用
    `V:` 前缀添加垂直约束。
- en: The `constraintsWithVisualFormat` method on the `NSLayoutConstraint` class can
    be used to parse visual format constraints. It takes a set of `options`, `metrics`,
    and a dictionary of `views` that are referenced in the visual format. An array
    of constraints is returned, which can be passed into the `addConstraints` method
    of the view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSLayoutConstraint` 类上的 `constraintsWithVisualFormat` 方法可以用来解析视觉格式约束。它接受一组
    `options`、`metrics` 以及一个包含在视觉格式中引用的 `views` 字典。返回一个约束数组，这些约束可以被传递到视图的 `addConstraints`
    方法中。'
- en: 'To add constraints that ensure the `left` and `right` views have equal widths,
    a space between them, and a vertical space between the top of the view and the
    labels, the following code can be used:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加确保 `left` 和 `right` 视图具有相等宽度、它们之间有空间以及视图顶部和标签之间有垂直空间的约束，可以使用以下代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If there are ambiguous constraints, then an error will be printed to the console
    when the view is displayed. Messages that include the `NSAutoresizingMaskLayout`
    constraints indicate that the view has not disabled the automatic translation
    of the autoresizing mask into the constraints.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在模糊的约束，则在视图显示时将在控制台打印错误。包含 `NSAutoresizingMaskLayout` 约束的消息表明视图尚未禁用自动将自动调整大小掩码转换为约束的自动转换。
- en: Adding the custom view to the table
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自定义视图添加到表格中
- en: 'The `TwoLabels` view can be tested by adding it as a footer to the `SimpleTable`
    that was created previously. The footer is a special class, `UITableViewHeaderFooterView`,
    which needs to be created and added to `tableView`. The `TwoLabels` view can then
    be added to the footer''s `contentView`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将其添加到之前创建的 `SimpleTable` 的页脚来测试 `TwoLabels` 视图。页脚是一个特殊类，`UITableViewHeaderFooterView`，需要创建并添加到
    `tableView` 中。然后可以将 `TwoLabels` 视图添加到页脚的 `contentView`：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now when the application is run in the simulator, the custom view will be seen:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序在模拟器中运行时，将看到自定义视图：
- en: '![Adding the custom view to the table](img/00081.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![将自定义视图添加到表格中](img/00081.jpeg)'
- en: Custom graphics with drawRect
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `drawRect` 绘制自定义图形
- en: Subclasses of `UIView` can implement their own custom graphics by providing
    a **drawRect** method that implements the custom drawing routines. The `drawRect`
    method takes a `CGRect` argument, which indicates the area to draw in. However,
    the actual drawing commands are performed on a Core Graphics context, which is
    represented by the `CGContext` class and can be obtained by a call to `UIGraphicsGetCurrentContext`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView` 的子类可以通过提供一个实现自定义绘图例程的 **drawRect** 方法来实现它们自己的自定义图形。`drawRect` 方法接受一个
    `CGRect` 参数，它指示要绘制的区域。然而，实际的绘图命令是在 Core Graphics 上下文中执行的，该上下文由 `CGContext` 类表示，可以通过调用
    `UIGraphicsGetCurrentContext` 获取。'
- en: The Core Graphics context represents a drawable area in iOS, and it is used
    to print as well as draw graphics. Each view has the responsibility to draw itself;
    the rectangle will either be the full area (for example, the first time that a
    view is drawn) or it may be a subset of the area (for example, when a dialog has
    been displayed and then subsequently removed).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Core Graphics 上下文表示 iOS 中的一个可绘制区域，它用于打印以及绘制图形。每个视图都有绘制自己的责任；矩形将是整个区域（例如，视图第一次绘制时）或可能是区域的一个子集（例如，当对话框显示然后随后被移除时）。
- en: '*Core Graphics* is a C-based interface (rather than Objective-C-based), so
    the API is exposed as a set of functions beginning with the `UIGraphics` prefix.
    As with other drawing APIs, the program can set the current drawing color, draw
    lines, set a fill color, fill rectangles, and so on.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心图形* 是一个基于 C 的接口（而不是基于 Objective-C），因此 API 以 `UIGraphics` 前缀开始的一组函数的形式公开。与其他绘图
    API 一样，程序可以设置当前绘图颜色、绘制线条、设置填充颜色、填充矩形等。'
- en: To test this, create a class called `SquaresView` that is a subclass of `UIView`
    in a new Swift file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，创建一个名为 `SquaresView` 的类，它是 `UIView` 的新子类，在一个新的 Swift 文件中。
- en: 'All views have the standard `init` methods; delegate them to the superclass''s
    implementation. Finally, create a `drawRect` method that takes a `CGRect`. This
    will be where the custom drawing occurs. The skeleton will look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视图都有标准的`init`方法；将它们委托给超类的实现。最后，创建一个接受`CGRect`的`drawRect`方法。这将是在自定义绘图发生的地方。其骨架如下所示：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the `Main.storyboard`, drag in another `UIViewController` and set the custom
    class of the view to `SquaresView` in **Identity Inspector**. Drag in a relationship
    segue between the tabbed view controller and the new view controller, and set
    the tab bar item to `Squares` which will allow testing to move to a different
    view. If the application is run, a blank view will be seen in the **Squares**
    tab.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Main.storyboard`，拖入另一个`UIViewController`，并在**Identity Inspector**中将视图的定制类设置为`SquaresView`。在标签视图控制器和新视图控制器之间拖入一个关系切换，并将标签栏项设置为`Squares`，这将允许测试移动到不同的视图。如果运行应用程序，将在**Squares**标签中看到一个空白视图。
- en: Drawing graphics in drawRect
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在drawRect中绘制图形
- en: To draw graphics in the view, it is necessary to acquire a `CGContext` and then
    set a drawing (stroke) color. A `UIColor` can be acquired and then converted into
    a `CGColor` to be able to set it on the graphics context.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中绘制图形，需要获取一个`CGContext`并设置一个绘图（描边）颜色。可以获取一个`UIColor`并将其转换为`CGColor`，以便能够在图形上下文中设置它。
- en: 'Finally, a rectangle can be drawn with `CGContextStrokeRect`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用`CGContextStrokeRect`绘制一个矩形：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this is run in the simulator, a red rectangle will be displayed on the
    **Squares** tab.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模拟器中运行时，将在**Squares**标签上显示一个红色矩形。
- en: To draw a green square with a black outline in the middle requires a filled
    green square to be drawn first, followed by a black square afterwards. (Drawing
    them in the opposite order will result in the solid green square obliterating
    the black square.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在中间绘制一个带有黑色轮廓的绿色正方形，首先需要绘制一个填充的绿色正方形，然后绘制一个黑色正方形。 (以相反的顺序绘制它们将导致实心绿色正方形消除黑色正方形。)
- en: 'There are two different colors in a Core Graphics context: the *stroke color*,
    which is used to draw lines and paths, and the *fill color*, which is used when
    creating a filled path. Although the `CGContextSetFillColorWithColor` function
    exists, in Swift, there is an easier way of setting this directly with `UIColor`
    using the `setFill` or `setStroke` methods. The following code will create the
    green square with a black border:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Core Graphics上下文中有两种不同的颜色：*描边颜色*，用于绘制线条和路径，以及*填充颜色*，用于创建填充路径。尽管存在`CGContextSetFillColorWithColor`函数，但在Swift中，使用`UIColor`的`setFill`或`setStroke`方法直接设置要简单得多。以下代码将创建一个带有黑色边框的绿色正方形：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now when the application is run, the following will be seen:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，将看到以下内容：
- en: '![Drawing graphics in drawRect](img/00082.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![在drawRect中绘制图形](img/00082.jpeg)'
- en: Responding to orientation changes
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应方向变化
- en: When the screen rotates, the view is stretched and squashed, resulting in the
    square turning into a rectangle. The `drawRect` call is not called when the view
    changes orientation; the existing display is squashed and stretched automatically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕旋转时，视图被拉伸和挤压，导致正方形变成矩形。当视图改变方向时，不会调用`drawRect`调用；现有的显示会自动被挤压和拉伸。
- en: To prevent this, the *content mode* of the view can be changed. There is a `UIViewContentMode`
    enumeration that can be specified to cause different behaviors. Using `Redraw`
    will result in the `drawRect` being called when the orientation changes or when
    the bounds changes size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，可以更改视图的*内容模式*。有一个名为`UIViewContentMode`的枚举，可以指定以引起不同的行为。使用`Redraw`将在方向改变或边界大小改变时调用`drawRect`。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The other `enum` values are documented in the `UIViewContentMode` type, and
    they include scaling options as well as being centered or attached to one of the
    edges or corners.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`enum`值在`UIViewContentMode`类型中有所记录，包括缩放选项以及居中或附着到其中一个边缘或角落。
- en: 'The squares can be centered on the screen; instead of starting at the position
    `50,50`, the view''s `center` property can be accessed to find out what the position
    is. Modify the code as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形可以居中在屏幕上；而不是从位置`50,50`开始，可以通过访问视图的`center`属性来找出位置。按照以下方式修改代码：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now when the application is run, the squares will be centered on the screen.
    If the screen rotates, `drawRect` will be invoked again and the display will be
    redrawn.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，正方形将居中在屏幕上。如果屏幕旋转，`drawRect`将被再次调用，并且显示将被重新绘制。
- en: Custom graphics with layers
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图层进行自定义图形
- en: Drawing graphics by overriding `drawRect` is not very performant because all
    the drawing routines are executed on the CPU. Offloading the graphics drawing
    to the GPU is both more performant and more power efficient.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 `drawRect` 来绘制图形并不太高效，因为所有的绘图例程都是在 CPU 上执行的。将图形绘制任务卸载到 GPU 上既更高效，也更节能。
- en: iOS has a concept of layers, which are Core Graphics optimized drawing contents.
    Operations composed on a *layer*, including adding a *path*, can be translated
    into code that can execute on the GPU and be rendered efficiently. In addition,
    Core Animation can be used to animate changes on layers efficiently. *Core Animation*
    is provided in the **QuartzCore** framework/module; the two terms are interchangeable.
    It is more generally known as Core Animation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 有一个层的概念，它们是 Core Graphics 优化的绘图内容。在 *层* 上组成的操作，包括添加 *路径*，可以转换为可以在 GPU 上执行并高效渲染的代码。此外，可以使用
    Core Animation 高效地动画化层上的变化。*Core Animation* 由 **QuartzCore** 框架/模块提供；这两个术语可以互换使用。它更普遍地被称为
    Core Animation。
- en: The download progress icon on iOS can be recreated as a `ProgressView` containing
    layers for the circular outline, a layer for the square stop button in the middle,
    and a layer for the progress arc. The final view will composite these three layers
    together to provide the finished view.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，可以将下载进度图标重新创建为一个包含层（用于圆形轮廓）、一个层（用于中间的方形停止按钮）和一个层（用于进度弧）的 `ProgressView`。最终的视图将组合这三个层以提供完成后的视图。
- en: 'Every `UIView` has an implicit associated layer, which can have sublayers added
    to it. As with views, newly-added layers overlay existing layers. There are several
    **core animation layer** classes that can be used, which are subclasses of `CALayer`,
    and they are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `UIView` 都有一个隐式关联的层，可以向其添加子层。与视图一样，新添加的层会覆盖现有层。可以使用几个 **核心动画层** 类，它们是 `CALayer`
    的子类，具体如下：
- en: The `CAEAGLLayer` class provides a way to embed OpenGL content into a view
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAEAGLLayer` 类提供了一种将 OpenGL 内容嵌入到视图中的方法'
- en: The `CAEmitterLayer` class provides a mechanism to generate emitter effects,
    such as smoke and fire
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAEmitterLayer` 类提供了一种生成发射效果（如烟雾和火焰）的机制'
- en: The `CAGradientLayer` class provides a way to create a background with a gradient
    color
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAGradientLayer` 类提供了一种创建具有渐变颜色的背景的方法'
- en: The `CAReplicatorLayer` class provides a means to replicate the existing layers
    with different transformations, which allows effects, such as reflections and
    coverflow, to be displayed
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAReplicatorLayer` 类提供了一种通过不同的变换复制现有层的方法，这允许显示如反射和 coverflow 这样的效果'
- en: The `CAScrollLayer` class provides a way to perform scrolling
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAScrollLayer` 类提供了一种执行滚动的方法'
- en: The `CAShapeLayer` class provides a means to draw and animate a single path
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAShapeLayer` 类提供了一种绘制和动画化单个路径的方法'
- en: The `CATextLayer` class allows text to be displayed
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATextLayer` 类允许显示文本'
- en: The `CATiledLayer` class provides a means to generate tiled content at different
    zoom levels, such as a map
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATiledLayer` 类提供了一种在不同缩放级别生成平铺内容的方法，如地图'
- en: The `CATransformLayer` class provides a means to transform layers into 3D views,
    such as a coverflow style image animation
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATransformLayer` 类提供了一种将层转换为 3D 视图（如 coverflow 风格的图像动画）的方法'
- en: Creating a ProgressView from layers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过层创建 `ProgressView`
- en: 'Create another view class called `ProgressView` which extends `UIView`. Set
    it up with the default `init` methods, a `setupView`, and a `configureView` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个名为 `ProgressView` 的视图类，它扩展了 `UIView`。使用默认的 `init` 方法、`setupView` 方法和 `configureView`
    方法来设置它：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Create a new `Layers` `Scene` in the `Main.storyboard` by dragging a `UIViewController`
    from the object library onto the storyboard. Connect it to the tab-bar controller
    by dragging a relationship segue to the newly created layers view controller.
    Add the `ProgressView` by dragging a **View** from the object library and giving
    it a **Custom Class** of `ProgressView`. Size it with an approximate location
    of the middle of the screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从对象库中将 `UIViewController` 拖动到 `Main.storyboard` 中来创建一个新的 `Layers` `Scene`。通过拖动一个关系
    segue 到新创建的 layers 视图控制器来将其连接到标签栏控制器。通过从对象库中拖动一个 **View** 并将其 **Custom Class**
    设置为 `ProgressView` 来添加 `ProgressView`。将其大小调整到屏幕中间的大致位置。
- en: 'Now add an instance variable to the `ProgressView` class called `circle` and
    create a new instance of `CAShapeLayer`. In `setupView`, set `strokeColor` as
    `black` and `fillColor` as `nil`. Finally, add the `circle` layer to the view''s
    layer so that it is displayed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向 `ProgressView` 类添加一个实例变量 `circle` 并创建一个新的 `CAShapeLayer` 实例。在 `setupView`
    中，将 `strokeColor` 设置为 `black`，`fillColor` 设置为 `nil`。最后，将 `circle` 层添加到视图的层中，以便显示：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`CAShapeLayer` has a `path` property, which is used to perform all the drawing.
    The easiest way to use this is to create a `UIBezierPath` and then use the `CGPath`
    accessor to convert it to a `CGPath`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAShapeLayer` 有一个 `path` 属性，用于执行所有绘图操作。使用它的最简单方法是创建一个 `UIBezierPath`，然后使用
    `CGPath` 访问器将其转换为 `CGPath`。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A *bezier curve* is a way of representing a smooth curve between two points
    and one or more additional control points. These can be scaled accurately and
    are easy to compute in a graphics card. A `UIBezierPath` provides a way to represent
    one or several bezier paths together, resulting in smooth and efficient curve
    generation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*贝塞尔曲线* 是在两点之间表示平滑曲线以及一个或多个控制点的一种方法。这些曲线可以精确缩放，并且在图形卡上易于计算。`UIBezierPath` 提供了一种表示一个或多个贝塞尔路径的方法，从而实现平滑且高效的曲线生成。'
- en: 'Unlike the `UIGraphics*` methods, there are no separate `draw*` and `fill*`
    operations; instead, either the `fillColor` or `strokeColor` is set and then the
    path is filled or stroked (drawn). The `UIBezierPath` can be constructed by adding
    segments, but there are several initializers that can be used to draw specific
    shapes. For example, circles can be drawn with the `ovalInRect` initializer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `UIGraphics*` 方法不同，没有单独的 `draw*` 和 `fill*` 操作；相反，要么设置 `fillColor` 或 `strokeColor`，然后填充或绘制路径（绘制）。`UIBezierPath`
    可以通过添加段来构建，但有几个初始化器可以用来绘制特定形状。例如，可以使用 `ovalInRect` 初始化器绘制圆形：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now when the application is run, a small black circle will be seen on the **Layers**
    tab:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，将在 **图层** 选项卡上看到一个小的黑色圆圈：
- en: '![Creating a ProgressView from layers](img/00083.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![从图层创建 ProgressView](img/00083.jpeg)'
- en: Adding the stop square
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加停止正方形
- en: The stop square can be added by creating another layer. This will allow the
    stop button to be turned on or off as necessary. (For example, during a download,
    the stop button can be displayed, and when the download is completed, it can be
    animated away.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建另一个图层来添加停止正方形。这将允许根据需要打开或关闭停止按钮。（例如，在下载过程中，可以显示停止按钮，当下载完成后，可以将其动画化消失。）
- en: 'Add a new constant called `square` of type `CAShapeLayer`. It will help to
    create a constant, `black`, as it will be used again elsewhere in this class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `square` 的新常量，类型为 `CAShapeLayer`。它将有助于创建一个常量 `black`，因为它将在本类的其他地方再次使用：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `setupView` method can now be updated to deal with additional layers. As
    it is common to set them up in the same way, using a loop is a quick way to set
    up multiple layers, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 `setupView` 方法更新以处理额外的图层。由于通常以相同的方式设置它们，因此使用循环是设置多个图层的快速方法，如下所示：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The path for the `square` can be created using the `rect` initializer of `UIBezierPath`.
    To create a rectangle that will be centered inside the circle, use the `insetBy`
    method with an appropriate value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UIBezierPath` 的 `rect` 初始化器可以创建 `square` 的路径。为了创建一个位于圆内的矩形，请使用 `insetBy`
    方法并设置一个合适的值：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now when the application is run, the following will be seen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，将看到以下内容：
- en: '![Adding the stop square](img/00084.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![添加停止正方形](img/00084.jpeg)'
- en: Adding a progress bar
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加进度条
- en: The progress bar can be drawn as an arc representing the amount of data that
    has downloaded so far. On other iOS applications, the progress bar starts at the
    12 o'clock position and then moves clockwise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条可以绘制为表示已下载数据量的弧线。在其他 iOS 应用程序中，进度条从 12 点位置开始，然后顺时针移动。
- en: 'There are two ways to achieve this: using an arc that is drawn up to some particular
    amount, or by setting a single path that represents the entire circle and then
    using `strokeStart` and `strokeEnd` to define which segment of the path should
    be drawn. The advantage of using `strokeStart` and `strokeEnd` is that they are
    *animatable properties*, which allow some animated effects.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以实现这一点：使用绘制到某个特定数量的弧线，或者通过设置表示整个圆的单一路径，然后使用 `strokeStart` 和 `strokeEnd`
    来定义应该绘制路径的哪一段。使用 `strokeStart` 和 `strokeEnd` 的优点是它们是 *可动画属性*，这允许一些动画效果。
- en: The arc needs to be drawn from the top, moved clockwise to the right, and then
    back up again. The `strokeStart` and `strokeEnd` are `CGFloat` values between
    0 and 1, so they can be used to represent the progress of the download.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 需要从顶部绘制弧线，顺时针移动到右边，然后再向上。`strokeStart`和`strokeEnd`是介于0和1之间的`CGFloat`值，因此它们可以用来表示下载的进度。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Easy as Pi**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**就像π一样简单**'
- en: Although circles are often split into 360 degrees (mainly because 360 has a
    lot of factors and is easily divisible into different numbers), computers tend
    to work in *radians*. There are `2pi` radians in a circle; so half a circle is
    `pi`, and a quarter of a circle is `pi/2`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然圆通常被分成360度（主要是因为360有很多因数，很容易被分成不同的数字），但计算机倾向于使用*弧度*。一个圆中有`2pi`弧度；所以半个圆是`pi`，四分之一圆是`pi/2`。
- en: 'There is a `UIBezierPath` convenience initializer that can draw an arc; the
    `center` and `radius` are specified along with a `startAngle` and `endAngle` point.
    The start and end points are both specified in radians, with 0 being the 3 o''
    clock position and going clockwise or anticlockwise as specified:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`UIBezierPath`便利初始化器可以绘制弧线；`center`和`radius`被指定，以及一个`startAngle`和`endAngle`点。起点和终点都指定为弧度，0是3点钟位置，顺时针或逆时针，根据指定进行：
- en: '![Adding a progress bar](img/00085.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![添加进度条](img/00085.jpeg)'
- en: To draw progress starting from the top of the circle, the start point must be
    specified as `-pi/2`. Drawing clockwise from here around the complete circle takes
    it to `-pi/2` `+` `2pi`, which is `3` `*` `pi/2`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要从圆的顶部开始绘制进度，必须将起点指定为`-pi/2`。从这里顺时针绘制整个圆到达`-pi/2 + 2pi`，即`3 * pi/2`。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Computers use pi a lot, defined in `usr/include/math.h`, which is included
    transitively from `UIKit` through the `Darwin` module. The constants: `M_PI`,
    `M_PI_2` (pi/2), and `M_PI_4` (pi/4), and the inverses: `M_1_PI` (1/pi), and `M_2_PI`
    (2/pi), are available.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机大量使用π，定义在`usr/include/math.h`中，它通过`Darwin`模块间接包含在`UIKit`中。常数：`M_PI`，`M_PI_2`（π/2），和`M_PI_4`（π/4），以及它们的倒数：`M_1_PI`（1/π），和`M_2_PI`（2/π），都是可用的。
- en: 'The middle of the diagram can be calculated by accessing `self.center`, and
    the `radius` of the circle will be half the minimum `width` or `height`. To add
    the path, create a new `CAShapeLayer` called `progress`, add it into the layers
    array, and optionally give it a different `width` and `color` to distinguish it
    from the background:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中间可以通过访问`self.center`来计算，圆的`radius`将是`width`或`height`的最小值的一半。要添加路径，创建一个新的`CAShapeLayer`，命名为`progress`，将其添加到层数组中，并可选地给它不同的`width`和`color`以区分背景：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When this is run, the progress bar will be seen behind the circle:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，进度条将显示在圆的后面：
- en: '![Adding a progress bar](img/00086.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![添加进度条](img/00086.jpeg)'
- en: Clipping the view
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图裁剪
- en: The problem with the progress line is that it extends beyond the circular boundary
    of the progress view. A simple approach may be to try and calculate a half-width
    distance from the radius and redraw the circle, but this is fragile as changes
    to the line width may result in the diagram not looking right in the future.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 进度线的麻烦在于它延伸到了进度视图的圆形边界之外。一个简单的方法可能是尝试计算从半径到半宽度的距离，然后重新绘制圆，但这很脆弱，因为线宽的变化可能会导致未来的图表看起来不正确。
- en: A better approach is to *mask* the graphics area so that the drawing does not
    go outside a particular shape. By specifying a mask, any drawing that occurs within
    the mask is displayed; graphics that are drawn outside the mask are not displayed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是*遮罩*图形区域，这样绘图就不会超出特定形状之外。通过指定遮罩，任何在遮罩内的绘图都会显示出来；绘制在遮罩外的图形则不会显示。
- en: A mask can be defined as a rectangular area or the result of a filled layer.
    Creating a circular mask requires creating a new mask layer and then setting a
    circular path as we did before.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 遮罩可以被定义为矩形区域或填充层的输出结果。创建圆形遮罩需要创建一个新的遮罩层，然后设置一个圆形路径，就像我们之前做的那样。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A mask can only be used by a single layer. If the same mask is needed for more
    than one layer, either the mask layer needs to be copied or the mask can be set
    on a common parent layer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 遮罩只能被单个层使用。如果需要为多个层使用相同的遮罩，要么需要复制遮罩层，要么可以将遮罩设置在公共父层上。
- en: 'Create a new `CAShapeLayer` that can be used for the `mask`, and create a `path`
    that is based on the `UIBezierPath` with an `ovalInRect`. The `mask` can then
    be assigned to the `mask` layer of the `progress` layer:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`CAShapeLayer`，用于遮罩，并创建一个基于`UIBezierPath`的`ovalInRect`的`path`。然后可以将遮罩分配给`progress`层的`mask`层：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now when the display is shown, the progress bar does not bleed over the edge:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当显示出现时，进度条不会溢出边缘：
- en: '![Clipping the view](img/00087.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![裁剪视图](img/00087.jpeg)'
- en: Testing views in Xcode
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Xcode 中测试视图
- en: To test the view in Interface Builder directly, the class can be marked as `@IBDesignable`.
    This gives permission for Xcode to instantiate and run the view as well as update
    it for any changes that are made. If the class is marked as `@IBDesignable`, then
    Xcode will attempt to load the view and display it in storyboard and `xib` files.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接在 Interface Builder 中测试视图，可以将类标记为 `@IBDesignable`。这允许 Xcode 实例化和运行视图，以及更新任何所做的更改。如果类被标记为
    `@IBDesignable`，则 Xcode 将尝试加载视图并在故事板和 `xib` 文件中显示它。
- en: 'However, when the class loads, the UI will not be displayed properly, because
    the frame size needs to be initialized correctly. Override the `layoutSubviews`
    method to call `configureView`, which ensures that the view is properly redrawn
    when the view changes size or is displayed for the first time:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当类加载时，UI 不会正确显示，因为框架大小需要正确初始化。重写 `layoutSubviews` 方法来调用 `configureView`，这确保了视图在视图大小改变或首次显示时被正确重绘：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now when the `ProgressView` is added or displayed in Interface Builder, it will
    be rendered in place. Build the project, then open the `Main.storyboard`, and
    click on the **Progress View**; after a brief delay, it will be drawn.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 `ProgressView` 被添加或显示在 Interface Builder 中时，它将就地渲染。构建项目后，打开 `Main.storyboard`，点击
    **Progress View**；经过短暂延迟后，它将被绘制。
- en: Xcode can also be used to edit different attributes of an object in Interface
    Builder. This allows the view to be tested without running the application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 还可以用于编辑 Interface Builder 中对象的属性。这允许在不运行应用程序的情况下测试视图。
- en: 'To allow Interface Builder to edit properties, they can be marked as `@IBInspectable`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许 Interface Builder 编辑属性，可以将它们标记为 `@IBInspectable`：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After building the project, open the storyboard, select **Progress View** and
    go to **Attributes Inspector**. Just above the **View** section will be a **Progress
    View** section with the **Progress Amount** field that is based on the `@IBInspectable`
    field of the same name:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目后，打开故事板，选择 **Progress View** 并转到 **Attributes Inspector**。在 **View** 部分上方将有一个
    **Progress View** 部分，其中包含基于同名 `@IBInspectable` 字段的 **Progress Amount** 字段：
- en: '![Testing views in Xcode](img/00088.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xcode 中测试视图](img/00088.jpeg)'
- en: Responding to change
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应变化
- en: If `UISlider` is added to **Layers View**, changes can be triggered by adding
    `@IBAction` to allow the `valueChanged` event to propagate the value to the caller.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `UISlider` 添加到 **Layers View**，可以通过添加 `@IBAction` 来触发更改，允许 `valueChanged`
    事件将值传播给调用者。
- en: 'Create an `@IBAction` function, `setProgress`, which takes a sender and then,
    depending on the type of that sender, extracts a value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `@IBAction` 函数，名为 `setProgress`，它接受一个发送者，然后根据发送者的类型提取一个值：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using a `switch` statement that is based on the type allows additional views
    to be added in the future.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于类型的 `switch` 语句允许将来添加更多视图。
- en: The `valueChanged` event on `UISlider` can now be connected to `setProgess`
    on `ProgressView`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 `UISlider` 上的 `valueChanged` 事件连接到 `ProgressView` 的 `setProgess`。
- en: 'Assigning the `progressAmount` value alone has no visible effect, so a property
    observer can be used to trigger display changes whenever the field is modified.
    A *property observer* is a block of code that gets called before (`willSet`) or
    after (`didSet`) a property is changed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 仅分配 `progressAmount` 值没有可见效果，因此可以使用属性观察器在字段修改时触发显示更改。*属性观察器* 是在属性更改之前（`willSet`）或之后（`didSet`）被调用的代码块：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now when the application is run and the slider value is moved, the download
    amount will be updated in the view:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行并移动滑块值时，视图中的下载量将更新：
- en: '![Responding to change](img/00089.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![响应变化](img/00089.jpeg)'
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the image doesn't update when the slider changes value, check that `didSet`
    on `progressAmount` triggers a `setNeedsLayout` call, and that the `layoutSubviews`
    function correctly calls `configureView`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果滑块值改变时图像没有更新，请检查 `progressAmount` 上的 `didSet` 是否触发了 `setNeedsLayout` 调用，以及
    `layoutSubviews` 函数是否正确调用了 `configureView`。
- en: Observe that the changes to `progressAmount` are animated automatically, so
    if the slider is quickly moved from one end to the other the download arc will
    smoothly animate.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `progressAmount` 的更改会自动动画化，所以如果快速将滑块从一个端点移动到另一个端点，下载弧将平滑地动画化。
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The property observer uses `setNeedsLayout` to trigger a call to `layoutSubviews`
    in order to achieve the change in display. As changes only need to be picked up
    when a size change occurs or when a property is changed, this is more efficient
    than implementing other methods, such as `drawRect`, which will be called every
    time the display needs to be updated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 属性观察者使用`setNeedsLayout`来触发对`layoutSubviews`的调用，以实现显示上的变化。由于只有在尺寸发生变化或属性被更改时才需要检测变化，因此这比实现其他方法（如每次显示需要更新时都会被调用的`drawRect`）更高效。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at several different ways to create views in iOS.
    The first approach was to use Interface Builder to build the view graphically
    and analyze some of the problems that this can cause. We then looked at subclassing
    `UIView` and adding other views to build up a custom view. Finally, we presented
    two different ways of drawing custom graphics; first with `drawRect`, and subsequently,
    with layers. The next chapter will show you how to use networking APIs in iOS
    to download networked data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在iOS中创建视图的几种不同方法。首先，我们使用Interface Builder图形化地构建视图并分析了一些可能引起的问题。然后，我们探讨了通过子类化`UIView`并添加其他视图来构建自定义视图的方法。最后，我们介绍了两种绘制自定义图形的不同方式；首先是通过`drawRect`，然后是通过层。下一章将向您展示如何使用iOS中的网络API下载网络数据。
