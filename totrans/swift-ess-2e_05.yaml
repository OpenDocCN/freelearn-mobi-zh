- en: Chapter 5. Creating Custom Views in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User interfaces can be built by combining standard views and view controllers
    through Interface Builder, Storyboard Editor, or with custom code. However, it
    will eventually become necessary to break apart a user interface into smaller,
    reusable, and easier to test segments. These are known as *custom views*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing table views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and laying out custom view subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing graphical views with `drawRect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating layered graphics with animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of UIView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All iOS views are rooted in an Objective-C class called `UIView`, which comes
    from the `UIKit` framework/module. The `UIView` class represents a rectangular
    space that may be associated with `UIWindow` or constructed to represent an off-screen
    view. Views that perform user interactions are generally subclasses of `UIControl`.
    Both `UIView` and `UIViewController` inherit from the `UIResponder` class, which
    in turn inherits from `NSObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of UIView](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On Mac OS X, views are rooted in NSView and come from the `AppKit` framework.
    Otherwise, these two implementations are very similar. A new Xcode project will
    be used to create custom view classes. Create a new project called `CustomViews`
    that is based on the **Tabbed Application** template. To start with a blank sheet,
    delete the generated view controllers from the `Main.storyboard` and their associated
    `FirstViewController` and `SecondViewController` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new views with Interface Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to create a custom view is to use Interface Builder to drag
    and drop the contents. This is typically done with a `UITableView` and a *prototype
    table cell*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table view controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag in a **Table View Controller** from the object library onto the main storyboard,
    and drag and drop from the tab bar controller to the newly created table view
    controller to create a relation segue called `view controllers`. (Segues are covered
    in more detail in the *Storyboards*, *Segues* *, and Scenes* section in [Chapter
    4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b "Chapter 4. Storyboard
    Applications with Swift and iOS"), *Storyboard Applications with Swift and iOS*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the table view controller will have *dynamic property content*—that
    is, it will be able to display a variable number of rows. This is defined in the
    **Table View** section of **Attributes Inspector**, which can be displayed by
    selecting **Table View** from the scene navigator and then pressing *Command*
    + *Option* + *4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table view controller](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an option for tables to have *static content*; a fixed number of rows
    in the table. This is sometimes useful when creating scrollable content that can
    be partitioned into slices, even if it doesn't look like a table. Most of the
    elements in the iOS settings are represented as a fixed-size table view. At the
    top of the table view are one or more *prototype cells*. These are used to define
    the look and feel of the table items. By default, a `UITableViewCell` is used,
    which has a label and an image, but a prototype cell can be used to add more data
    to the entries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table view controller](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The prototype cell can be used to provide additional information or views. For
    example, two labels can be dragged into the view; one label can be centered at
    the top and can be displayed in the headline font, while the second can be left-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Drag two **UILabels** from the object library into the prototype cell and arrange
    them using **Auto Layout**, appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change a label''s font, select the label in the editor and go to **Attributes
    Inspector**. In the **Label** section, click on the **Font Chooser** icon and
    select **Headline** or **Subhead**, as appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table view controller](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When finished, the prototype cell will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table view controller](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the application is run, an empty table will be seen. This is because the
    table doesn't have any items displayed at the moment. The next section shows how
    to add data to a table so that it binds and displays items to the prototype cell.
  prefs: []
  type: TYPE_NORMAL
- en: Showing data in the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `UITableView` acquires data from a `UITableViewDataSource`. The `UITableViewController`
    class already implements the `UITableViewDataSource` protocol, so only a small
    number of methods are required to provide data for the table.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As `UITableView` was originally implemented in Objective-C, the methods that
    are defined in the protocol take a `tableView`. As a result, all of the `UITableViewDataSource`
    delegate methods in Swift end up being called `tableView` with different arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `SampleTable` class that extends `UITableViewController`. Implement
    the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data source methods are implemented, the labels need to be configured
    to display the data from the array. There are three things that need to be done:
    the prototype cell must be acquired from the `xib` file; the labels need to be
    extracted; and finally the table view controller needs to be associated with the
    custom `SampleTable` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, the `cellForRowAtIndex` function needs an identifier for reusable
    cells. The **Identifier** is set on the prototype cell in the main storyboard.
    To set this, select the prototype cell and go to the **Attributes Inspector**.
    Enter `prototypeCell` in the **Identifier** of the **Table View Cell** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing data in the table](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The identifier is used in the `dequeueReusableCellWithIdentifier` method of
    the `tableView`. When a `xib` is used to load the cell, the return value will
    either reuse a cell that has gone off screen earlier, or a new cell will be instantiated
    from the `xib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each label can be given a non-zero integer **Tag** so that the label can be
    extracted from the prototype cell using the `viewWithTag` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign tags to the views, select the **Heading Label**, navigate to **Attributes
    Inspector**, and change **Tag** to `1`. Do the same thing for the **Subheading
    Label** with **Tag** set to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing data in the table](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the text values for the row can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `SampleTable` needs to be associated with the table view controller.
    Click the table, go to **Identity Inspector**, and enter `SampleTable` in the
    **Custom Class** section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing data in the table](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the application is run, the following view will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing data in the table](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To hide the status bar, add or change **Status bar is initially hidden** to
    **YES** and **View controller-based status bar appearance** to **NO** in the `Info.plist`
    file. Please note that Xcode 7 displays a `CGContextRestoreGState: invalid context
    0x0` error message when using these options, which is a known issue that may be
    fixed in later releases.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a view in a xib file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to create a view using **Interface Builder**, save it as a `xib`
    file, and then instantiate it on demand. This is what happens under the covers
    with `UITableView`—there is a `registerNib:forCellReuseIdentifier:` method, which
    takes a `xib` file and an identifier (which corresponds to `prototypeCell` in
    the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new interface file named `CounterView.xib` to represent the view,
    by navigating to **File** | **New** | **File** | **iOS** | **User Interface**
    | **View**. When opened, it will display as an empty view with no content and
    in a 600 x 600 square. To change the size to something that is a little more reasonable,
    go to **Attributes Inspector** and change the size from **Inferred** to **Freeform**.
    At the same time, change the **Status Bar**, **Top Bar**, and **Bottom Bar** to
    **None**. Then switch to the **Size Inspector** and modify the view''s **Frame
    Rectangle** to `300` x `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a view in a xib file](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This should resize the view so that it is displayed as 300 by 50 instead of
    the previous 600 by 600, and the status bar and other bars should not be seen.
    Now add a **Stepper** from the object library by dragging it to the left-hand
    side of the view and dragging a **Label** to the right. Adjust the size and add
    the missing constraints so that the view looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a view in a xib file](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wiring a custom view class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `CounterView` class that extends `UIView`, and define an `@IBOutlet`
    for the `label` and an `@IBAction` `change` method that takes a `sender`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `CounterView.xib` file and select the view. Change **Custom Class**
    to be `CounterView`. Wire the stepper''s `valueChanged` event to the `change`
    method and connect the `label` outlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a custom view class](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implement the `change` function such that the label text is changed when the
    stepper is picked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `CounterView` will be added to the **table header** of the `SampleTable`.
    Each `UITableViewController` has a reference to its associated `UITableView`,
    and each `UITableView` has an optional `headerView` (and `footerView`) that is
    used for the table as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `UITableView` also has `sectionHeader` and `sectionFooter`, which are used
    to separate different sections of the table. A table can have multiple sections—for
    example, one section per month—and a separate header and footer can be used per
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `CounterView`, the `xib` file must be loaded. This is done by instantiating
    a `UINib` with a `nibName` and a `bundle`. The most appropriate place to do this
    is in the `viewDidLoad` method of the `SampleTable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the `xib` is loaded, the view must be created. The `instantiateWithOwner`
    method allows the object(s) in the `xib` to be deserialized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to store multiple objects in a `xib` file (for example, to define
    a separate view that is suitable for a small display device versus a big display
    device); but in general, a `xib` file only contains one view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The owner is passed to the view so that any connections can be wired up to
    the File''s Owner in the interface. This is typically either `self` or `nil` if
    there are no connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This returns an array of `AnyObject` instances, and so casting the first element
    to a `UIView` is a common step.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to use `objects[0]`, but this will cause a failure if the array
    is empty. Instead, use `objects.first` to get an optional value that contains
    the first element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `as?` cast, it is possible to convert the optional value to a more
    specific type, and from this, perform the assignment to the `tableHeaderView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this application is run in the simulator, the following header is seen
    at the top of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a custom view class](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the advantages of having a `xib` to represent the user interface is
    that it can be reused in many places with a single definition. For example, it
    is possible to use the same `xib` to instantiate another view for the footer of
    the table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is run now, counters are created at the top and bottom
    of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring a custom view class](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Dealing with intrinsic size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a view is added into a view that is being managed with **Auto Layout**,
    its *intrinsic content size* is used. Unfortunately, views that are defined in
    **Interface Builder** have no way of setting their intrinsic size programmatically
    or specifying it in Interface Builder. **Size Inspector** allows this value to
    be changed, but as Xcode notes, this has no effect at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with intrinsic size](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If a custom class is associated with the view, then an appropriate intrinsic
    size can be defined. Add a method to `CounterView` that overrides the `intrinsicContentSize`
    method and returns a `CGSize`, allows some `xib` customization, and returns the
    maximum of the label''s intrinsic size and a value, such as `(300,50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now when the view is added into a view that is managed by Auto Layout, it will
    have an appropriate initial size although it can grow larger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The size should take into account the size of the various views that are contained
    inside, as well as any font sizes or themes, which might change the view. Using
    the label's `intrinsicSize` to calculate a maximum is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new views by subclassing UIView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the `xib` files offer a mechanism to customize classes, the majority
    of `UIKit` views outside of standard frameworks are implemented in custom code.
    This makes it easier to reason what the intrinsic size should be as well as to
    receive code patches and understand `diffs` from version control systems. The
    downside of this approach is when using Auto Layout, writing the constraints can
    be a challenge and the intrinsic sizes are often misreported or return the unknown
    value: `(-1,-1)`.'
  prefs: []
  type: TYPE_NORMAL
- en: A custom view can be implemented as a subclass of `UIView`. Subclasses of `UIView`
    are expected to have two initializers, one that takes a `frame:CGRect` and one
    that takes a `coder:NSCoder`. The `frame` is generally used in code, and the `rect`
    specifies the position on screen (`0,0` is the top-left) along with the `width`
    and `height`. The `coder` is used when deserializing from a `xib` file.
  prefs: []
  type: TYPE_NORMAL
- en: To allow custom subclasses to either be used in Interface Builder or instantiated
    from code, it is good practice to ensure that both the initializers create the
    necessary views. This can be done using a third method called `setupView`, which
    is invoked from both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class called `TwoLabels` that has two labels in a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `setupView` call will add the subviews to the view. Code that goes in here
    should be executed only once. There isn't a standard name, and often, example
    code will place the setup in one or other of the `init` methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is conventional to have a separate method, such as `configureView`, to populate
    the UI with the current set of data. This can be called repeatedly based on the
    state of the system; for example, a field may be enabled or disabled based on
    some condition. This code should be repeatable so that it does not modify the
    view hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In an explicitly sized environment (where the text label is being set and placed
    at a particular location), there is a `layoutSubviews` method that is called to
    request the view to be laid out correctly. However, there is a better way to do
    this, which is to use Auto Layout and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout and custom views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auto Layout is covered in the *Using Auto Layout* section of [Chapter 4](part0034_split_000.html#10DJ42-d7e55eb5242648e89c396442afe4f84b
    "Chapter 4. Storyboard Applications with Swift and iOS"), *Storyboard Applications
    with Swift and iOS*. When creating a user interface explicitly, views must be
    sized and managed appropriately. The easiest way to manage this is to use Auto
    Layout, which requires constraints to be added in order to set up the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints can be added or updated in the `updateConstraints` method. This
    is called after `setNeedsUpdateConstraints` is called. Constraints may need to
    be updated if views become visible or the data is changed. Typically, this can
    be triggered by placing a call at the end of the `setupView` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `updateConstraints` method needs to do several things. To prevent autoresizing
    masks being translated into constraints, each view needs to call `setTranslatesAutoresizingMaskIntoConstraints`
    with an argument of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To facilitate the transition between springs and struts (also known as autoresizing
    masks) and Auto Layouts, views can be configured to translate springs and struts
    into Auto Layout constraints. This is enabled by default for all views in order
    to provide backward compatibility for existing views, but it should be disabled
    when implementing Auto Layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the constraints can be incrementally updated or the existing constraints
    can be removed. A `removeConstraints` method allows existing constraints to be
    removed first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Constraints can be added programmatically using the `NSLayoutConstraint` class.
    The constraints that are added in Interface Builder are also instances of the
    `NSLayoutConstraint` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints are represented as an equation; properties of two objects are related
    as an equality (or inequality) of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To declare that both labels are of equal width, the following can be added
    to the `updateConstraints` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Constraints and the visual format language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although adding individual constraints gives us ultimate flexibility, it can
    be tedious to set up programmatically. The *visual format language* can be used
    to add multiple constraints to a view. This is an ASCII-based representation that
    allows views to be related to each other in position and extrapolated into an
    array of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints can be applied horizontally (the default) or vertically. The `|`
    character can be used to represent either the start or end of the containing superview,
    and `–` is used to represent the space that separates views, which are named in
    `[]` and referenced in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: To constrain the two labels that are next to each other in the view, `H:|-[left]-[right]-|`
    can be used. This can be read as a horizontal (`H:`) with a gap from the left
    edge (`|-`) followed by the left view (`[left]`), a gap (`-`), a right view (`[right]`),
    and finally, a gap from the right edge (`-|`). Similarly, vertical constraints
    can be added with a `V:` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The `constraintsWithVisualFormat` method on the `NSLayoutConstraint` class can
    be used to parse visual format constraints. It takes a set of `options`, `metrics`,
    and a dictionary of `views` that are referenced in the visual format. An array
    of constraints is returned, which can be passed into the `addConstraints` method
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add constraints that ensure the `left` and `right` views have equal widths,
    a space between them, and a vertical space between the top of the view and the
    labels, the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are ambiguous constraints, then an error will be printed to the console
    when the view is displayed. Messages that include the `NSAutoresizingMaskLayout`
    constraints indicate that the view has not disabled the automatic translation
    of the autoresizing mask into the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the custom view to the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TwoLabels` view can be tested by adding it as a footer to the `SimpleTable`
    that was created previously. The footer is a special class, `UITableViewHeaderFooterView`,
    which needs to be created and added to `tableView`. The `TwoLabels` view can then
    be added to the footer''s `contentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the application is run in the simulator, the custom view will be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the custom view to the table](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom graphics with drawRect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subclasses of `UIView` can implement their own custom graphics by providing
    a **drawRect** method that implements the custom drawing routines. The `drawRect`
    method takes a `CGRect` argument, which indicates the area to draw in. However,
    the actual drawing commands are performed on a Core Graphics context, which is
    represented by the `CGContext` class and can be obtained by a call to `UIGraphicsGetCurrentContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Graphics context represents a drawable area in iOS, and it is used
    to print as well as draw graphics. Each view has the responsibility to draw itself;
    the rectangle will either be the full area (for example, the first time that a
    view is drawn) or it may be a subset of the area (for example, when a dialog has
    been displayed and then subsequently removed).
  prefs: []
  type: TYPE_NORMAL
- en: '*Core Graphics* is a C-based interface (rather than Objective-C-based), so
    the API is exposed as a set of functions beginning with the `UIGraphics` prefix.
    As with other drawing APIs, the program can set the current drawing color, draw
    lines, set a fill color, fill rectangles, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: To test this, create a class called `SquaresView` that is a subclass of `UIView`
    in a new Swift file.
  prefs: []
  type: TYPE_NORMAL
- en: 'All views have the standard `init` methods; delegate them to the superclass''s
    implementation. Finally, create a `drawRect` method that takes a `CGRect`. This
    will be where the custom drawing occurs. The skeleton will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Open the `Main.storyboard`, drag in another `UIViewController` and set the custom
    class of the view to `SquaresView` in **Identity Inspector**. Drag in a relationship
    segue between the tabbed view controller and the new view controller, and set
    the tab bar item to `Squares` which will allow testing to move to a different
    view. If the application is run, a blank view will be seen in the **Squares**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing graphics in drawRect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw graphics in the view, it is necessary to acquire a `CGContext` and then
    set a drawing (stroke) color. A `UIColor` can be acquired and then converted into
    a `CGColor` to be able to set it on the graphics context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a rectangle can be drawn with `CGContextStrokeRect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When this is run in the simulator, a red rectangle will be displayed on the
    **Squares** tab.
  prefs: []
  type: TYPE_NORMAL
- en: To draw a green square with a black outline in the middle requires a filled
    green square to be drawn first, followed by a black square afterwards. (Drawing
    them in the opposite order will result in the solid green square obliterating
    the black square.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different colors in a Core Graphics context: the *stroke color*,
    which is used to draw lines and paths, and the *fill color*, which is used when
    creating a filled path. Although the `CGContextSetFillColorWithColor` function
    exists, in Swift, there is an easier way of setting this directly with `UIColor`
    using the `setFill` or `setStroke` methods. The following code will create the
    green square with a black border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the application is run, the following will be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing graphics in drawRect](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Responding to orientation changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the screen rotates, the view is stretched and squashed, resulting in the
    square turning into a rectangle. The `drawRect` call is not called when the view
    changes orientation; the existing display is squashed and stretched automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, the *content mode* of the view can be changed. There is a `UIViewContentMode`
    enumeration that can be specified to cause different behaviors. Using `Redraw`
    will result in the `drawRect` being called when the orientation changes or when
    the bounds changes size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other `enum` values are documented in the `UIViewContentMode` type, and
    they include scaling options as well as being centered or attached to one of the
    edges or corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The squares can be centered on the screen; instead of starting at the position
    `50,50`, the view''s `center` property can be accessed to find out what the position
    is. Modify the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now when the application is run, the squares will be centered on the screen.
    If the screen rotates, `drawRect` will be invoked again and the display will be
    redrawn.
  prefs: []
  type: TYPE_NORMAL
- en: Custom graphics with layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing graphics by overriding `drawRect` is not very performant because all
    the drawing routines are executed on the CPU. Offloading the graphics drawing
    to the GPU is both more performant and more power efficient.
  prefs: []
  type: TYPE_NORMAL
- en: iOS has a concept of layers, which are Core Graphics optimized drawing contents.
    Operations composed on a *layer*, including adding a *path*, can be translated
    into code that can execute on the GPU and be rendered efficiently. In addition,
    Core Animation can be used to animate changes on layers efficiently. *Core Animation*
    is provided in the **QuartzCore** framework/module; the two terms are interchangeable.
    It is more generally known as Core Animation.
  prefs: []
  type: TYPE_NORMAL
- en: The download progress icon on iOS can be recreated as a `ProgressView` containing
    layers for the circular outline, a layer for the square stop button in the middle,
    and a layer for the progress arc. The final view will composite these three layers
    together to provide the finished view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `UIView` has an implicit associated layer, which can have sublayers added
    to it. As with views, newly-added layers overlay existing layers. There are several
    **core animation layer** classes that can be used, which are subclasses of `CALayer`,
    and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CAEAGLLayer` class provides a way to embed OpenGL content into a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CAEmitterLayer` class provides a mechanism to generate emitter effects,
    such as smoke and fire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CAGradientLayer` class provides a way to create a background with a gradient
    color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CAReplicatorLayer` class provides a means to replicate the existing layers
    with different transformations, which allows effects, such as reflections and
    coverflow, to be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CAScrollLayer` class provides a way to perform scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CAShapeLayer` class provides a means to draw and animate a single path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CATextLayer` class allows text to be displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CATiledLayer` class provides a means to generate tiled content at different
    zoom levels, such as a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CATransformLayer` class provides a means to transform layers into 3D views,
    such as a coverflow style image animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a ProgressView from layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create another view class called `ProgressView` which extends `UIView`. Set
    it up with the default `init` methods, a `setupView`, and a `configureView` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Layers` `Scene` in the `Main.storyboard` by dragging a `UIViewController`
    from the object library onto the storyboard. Connect it to the tab-bar controller
    by dragging a relationship segue to the newly created layers view controller.
    Add the `ProgressView` by dragging a **View** from the object library and giving
    it a **Custom Class** of `ProgressView`. Size it with an approximate location
    of the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add an instance variable to the `ProgressView` class called `circle` and
    create a new instance of `CAShapeLayer`. In `setupView`, set `strokeColor` as
    `black` and `fillColor` as `nil`. Finally, add the `circle` layer to the view''s
    layer so that it is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`CAShapeLayer` has a `path` property, which is used to perform all the drawing.
    The easiest way to use this is to create a `UIBezierPath` and then use the `CGPath`
    accessor to convert it to a `CGPath`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *bezier curve* is a way of representing a smooth curve between two points
    and one or more additional control points. These can be scaled accurately and
    are easy to compute in a graphics card. A `UIBezierPath` provides a way to represent
    one or several bezier paths together, resulting in smooth and efficient curve
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `UIGraphics*` methods, there are no separate `draw*` and `fill*`
    operations; instead, either the `fillColor` or `strokeColor` is set and then the
    path is filled or stroked (drawn). The `UIBezierPath` can be constructed by adding
    segments, but there are several initializers that can be used to draw specific
    shapes. For example, circles can be drawn with the `ovalInRect` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the application is run, a small black circle will be seen on the **Layers**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a ProgressView from layers](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the stop square
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stop square can be added by creating another layer. This will allow the
    stop button to be turned on or off as necessary. (For example, during a download,
    the stop button can be displayed, and when the download is completed, it can be
    animated away.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new constant called `square` of type `CAShapeLayer`. It will help to
    create a constant, `black`, as it will be used again elsewhere in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setupView` method can now be updated to deal with additional layers. As
    it is common to set them up in the same way, using a loop is a quick way to set
    up multiple layers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The path for the `square` can be created using the `rect` initializer of `UIBezierPath`.
    To create a rectangle that will be centered inside the circle, use the `insetBy`
    method with an appropriate value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the application is run, the following will be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the stop square](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The progress bar can be drawn as an arc representing the amount of data that
    has downloaded so far. On other iOS applications, the progress bar starts at the
    12 o'clock position and then moves clockwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to achieve this: using an arc that is drawn up to some particular
    amount, or by setting a single path that represents the entire circle and then
    using `strokeStart` and `strokeEnd` to define which segment of the path should
    be drawn. The advantage of using `strokeStart` and `strokeEnd` is that they are
    *animatable properties*, which allow some animated effects.'
  prefs: []
  type: TYPE_NORMAL
- en: The arc needs to be drawn from the top, moved clockwise to the right, and then
    back up again. The `strokeStart` and `strokeEnd` are `CGFloat` values between
    0 and 1, so they can be used to represent the progress of the download.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Easy as Pi**'
  prefs: []
  type: TYPE_NORMAL
- en: Although circles are often split into 360 degrees (mainly because 360 has a
    lot of factors and is easily divisible into different numbers), computers tend
    to work in *radians*. There are `2pi` radians in a circle; so half a circle is
    `pi`, and a quarter of a circle is `pi/2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `UIBezierPath` convenience initializer that can draw an arc; the
    `center` and `radius` are specified along with a `startAngle` and `endAngle` point.
    The start and end points are both specified in radians, with 0 being the 3 o''
    clock position and going clockwise or anticlockwise as specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a progress bar](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To draw progress starting from the top of the circle, the start point must be
    specified as `-pi/2`. Drawing clockwise from here around the complete circle takes
    it to `-pi/2` `+` `2pi`, which is `3` `*` `pi/2`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computers use pi a lot, defined in `usr/include/math.h`, which is included
    transitively from `UIKit` through the `Darwin` module. The constants: `M_PI`,
    `M_PI_2` (pi/2), and `M_PI_4` (pi/4), and the inverses: `M_1_PI` (1/pi), and `M_2_PI`
    (2/pi), are available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The middle of the diagram can be calculated by accessing `self.center`, and
    the `radius` of the circle will be half the minimum `width` or `height`. To add
    the path, create a new `CAShapeLayer` called `progress`, add it into the layers
    array, and optionally give it a different `width` and `color` to distinguish it
    from the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run, the progress bar will be seen behind the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a progress bar](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clipping the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem with the progress line is that it extends beyond the circular boundary
    of the progress view. A simple approach may be to try and calculate a half-width
    distance from the radius and redraw the circle, but this is fragile as changes
    to the line width may result in the diagram not looking right in the future.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to *mask* the graphics area so that the drawing does not
    go outside a particular shape. By specifying a mask, any drawing that occurs within
    the mask is displayed; graphics that are drawn outside the mask are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: A mask can be defined as a rectangular area or the result of a filled layer.
    Creating a circular mask requires creating a new mask layer and then setting a
    circular path as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mask can only be used by a single layer. If the same mask is needed for more
    than one layer, either the mask layer needs to be copied or the mask can be set
    on a common parent layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `CAShapeLayer` that can be used for the `mask`, and create a `path`
    that is based on the `UIBezierPath` with an `ovalInRect`. The `mask` can then
    be assigned to the `mask` layer of the `progress` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the display is shown, the progress bar does not bleed over the edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clipping the view](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing views in Xcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the view in Interface Builder directly, the class can be marked as `@IBDesignable`.
    This gives permission for Xcode to instantiate and run the view as well as update
    it for any changes that are made. If the class is marked as `@IBDesignable`, then
    Xcode will attempt to load the view and display it in storyboard and `xib` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when the class loads, the UI will not be displayed properly, because
    the frame size needs to be initialized correctly. Override the `layoutSubviews`
    method to call `configureView`, which ensures that the view is properly redrawn
    when the view changes size or is displayed for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now when the `ProgressView` is added or displayed in Interface Builder, it will
    be rendered in place. Build the project, then open the `Main.storyboard`, and
    click on the **Progress View**; after a brief delay, it will be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode can also be used to edit different attributes of an object in Interface
    Builder. This allows the view to be tested without running the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow Interface Builder to edit properties, they can be marked as `@IBInspectable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After building the project, open the storyboard, select **Progress View** and
    go to **Attributes Inspector**. Just above the **View** section will be a **Progress
    View** section with the **Progress Amount** field that is based on the `@IBInspectable`
    field of the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing views in Xcode](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Responding to change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `UISlider` is added to **Layers View**, changes can be triggered by adding
    `@IBAction` to allow the `valueChanged` event to propagate the value to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `@IBAction` function, `setProgress`, which takes a sender and then,
    depending on the type of that sender, extracts a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a `switch` statement that is based on the type allows additional views
    to be added in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `valueChanged` event on `UISlider` can now be connected to `setProgess`
    on `ProgressView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning the `progressAmount` value alone has no visible effect, so a property
    observer can be used to trigger display changes whenever the field is modified.
    A *property observer* is a block of code that gets called before (`willSet`) or
    after (`didSet`) a property is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the application is run and the slider value is moved, the download
    amount will be updated in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Responding to change](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the image doesn't update when the slider changes value, check that `didSet`
    on `progressAmount` triggers a `setNeedsLayout` call, and that the `layoutSubviews`
    function correctly calls `configureView`.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the changes to `progressAmount` are animated automatically, so
    if the slider is quickly moved from one end to the other the download arc will
    smoothly animate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The property observer uses `setNeedsLayout` to trigger a call to `layoutSubviews`
    in order to achieve the change in display. As changes only need to be picked up
    when a size change occurs or when a property is changed, this is more efficient
    than implementing other methods, such as `drawRect`, which will be called every
    time the display needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at several different ways to create views in iOS.
    The first approach was to use Interface Builder to build the view graphically
    and analyze some of the problems that this can cause. We then looked at subclassing
    `UIView` and adding other views to build up a custom view. Finally, we presented
    two different ways of drawing custom graphics; first with `drawRect`, and subsequently,
    with layers. The next chapter will show you how to use networking APIs in iOS
    to download networked data.
  prefs: []
  type: TYPE_NORMAL
