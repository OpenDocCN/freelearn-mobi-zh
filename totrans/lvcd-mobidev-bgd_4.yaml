- en: Chapter 4. Using Remote Data and Media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*While creating a LiveCode application, we need to think about the structure
    of the stack, its code, and the data it uses. Applications can be made when all
    the supporting data is within the application, but quite often, we want to display
    data that is out in the real world somewhere and also want to save information
    (a high-score list perhaps) to text files that are external to the application.
    You may also want to share information with other people or sync between apps
    or devices.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the various ways a stack might be structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about where code should go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to and read from external text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a scrapbook-like app to remember interesting Internet-based media files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you want to save time typing code?
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of lines of code in this chapter. The code is shown along with
    explanations of each function and you could use this code to build up something
    that matches the corresponding sample file. However, it would be very easy to
    make a mistake while transcribing the scripts, both in terms of what the script
    says and where the script should be placed. It may be safer to study the sample
    files and read the overall description here. You can download the code from the
    Packt Publishing website at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  prefs: []
  type: TYPE_NORMAL
- en: The stack structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two aspects to how the stack may be structured. One is about how user
    interface elements are organized and the other is about where in the hierarchy
    of a stack you should place your code. The first addresses how to make the app
    understandable, logical, and easy to use. The second addresses how to minimize
    development time, subsequent maintenance effort, and how to maximize the resulting
    performance of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Code-driven and manually created layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you imagine how a typical mobile application appears, it would be somewhat
    along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code-driven and manually created layouts](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, applications are entirely code-driven where every screen you see
    is created using code at the time that it's needed. Perhaps, it would already
    lay out the elements that are saved as resources and then the code would load
    these resources. In either case, the whole application could take place on the
    equivalent of one LiveCode card.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach would be to lay out every possible screen combination as different
    cards or even stacks and to go to the card or stack that looks like how the app
    appears at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, you would need to run the application and go through the
    user actions in order to check whether the layout was correct. Then, you would
    need to go back and change the code or resources and try again. In the second
    case, you may face a lot of combinations of layout.
  prefs: []
  type: TYPE_NORMAL
- en: As we start making apps here, we'll try to find a middle ground where we'll
    use cards to set up the main screens we'll need and then we'll use code to show
    and hide other elements. Our goal is to try and be efficient and not create complex
    code to lay out items that could be laid out quickly by hand. We also don't want
    to use a lot of images when a small amount of code could get us the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Locations for code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LiveCode is extremely flexible in terms of how you structure things that you
    make with it. In addition to a dozen different kinds of controls that could contain
    code, you can also control front scripts, groups, the current card, a mainstack,
    stacks in use, back script, and LiveCode itself. The following diagram shows you
    only a few example controls, but gives you the sense of how many levels there
    are to the hierarchy of LiveCode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Locations for code](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can also have sub stacks that are often used to show dialog windows, the
    ability to add front and back scripts, and you can put stacks in and out of use
    too. Overall, it can get quite confusing!
  prefs: []
  type: TYPE_NORMAL
- en: It is largely a case of personal style as to where you put your scripts and
    often, you may have a reasonable argument why you did it in a certain way. You
    could argue that all the actions that take place should be in the script of the
    button you clicked on. It would make it easy to edit all the handlers involved
    and if you need the same features in another stack, you would only have to copy
    the button across. However, if you had a number of those buttons on the screen
    and needed to make changes, you would have to do so for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Another valid argument would be to say that all handlers are at the stack level.
    You would then have one central place to make changes, but you would have to make
    lots of `if` statements to check which control has been operated on.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to reuse routines that you have developed over time and would
    have a set of stacks that you could put into use, where each stack just handles
    a particular aspect of the task at hand. In the world of **Object-oriented Programming**
    (**OOP**), it's quite common to extend this approach to a crazy degree with hundreds
    or even thousands of small files where each file handles a tiny portion of the
    overall application.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go to any of these extremes. Instead, we will try to put code at the
    lowest level that it needs to be without duplicating the code, as you make additional
    controls that need the same code. While doing this, we will try to think ahead
    and spot efficiencies that we can use. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a main menu button and its function is to take the user back
    to the card named `main`. Having this as the button''s script would make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It would appear to be the lowest level the code can be at and we''re not going
    to duplicate it, as there''s just one main menu button. However, suppose we want
    to track the user''s progress, the main menu button won''t know anything about
    that. So, we could do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the card script, there would be this handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveNavState` function would be somewhere, saving the user''s state. The
    only problem is that for each of the cards we make, which includes the main menu
    button, we will have to have this `navTo` handler in each of their scripts. Therefore,
    we''ll put the handler in the mainstack stack script. With it being at this level,
    it can handle calls from any button on any card. The help button''s script could
    be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Going to the help card would also save the user's state. Later, we could also
    add a visual effect as you jump from place to place and make that change in `navTo`
    instead of going around the various buttons that make use of the `navTo` handler.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – name that structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a common term used to describe the LiveCode hierarchy that helps convey
    how information is passed up and down the hierarchy. What is that term called?
  prefs: []
  type: TYPE_NORMAL
- en: The Event Horizon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Message Path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Call Stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Home Stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'For further reading, RunRev has an online lesson that describes the message
    path, which you can find at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path](http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path)'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and saving external data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many applications, you will want to keep track of changes that a user has
    made. There are several ways to do this with LiveCode, including querying a URL,
    reading and writing to a text file, and saving data inside a stack.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, web-based applications load and save data from server-side scripts.
    This can work with LiveCode apps too. Here''s an example which shows the closing
    share price for Google yesterday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment of writing this book, this line was tested and `609.46` appeared
    in the **Message Box,** shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Querying a URL](img/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Who knows what you'll find when you try it! In fact, while doing the second
    revision of this book, the number that popped up was 1172.9301\. Go Google!
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any such calls to an online service, there is a chance that it may
    take some time for the value to return, and in the preceding example, LiveCode
    would be blocked from doing anything else until the data returns. An alternate
    approach for this, is to load the URL in order to cache it and then display the
    results when it is cached. LiveCode would be able to do other actions while the
    data returns. A button script would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `gotit` handler also checks whether the call worked fine and if it didn't,
    it will display the error that caused the problem. The `unload` line is used to
    make sure that you're not reading the previously cached value. If it's a value
    that only changes infrequently, as with the closing price of a stock, then you
    would usually only clear the cached version when it's likely to be changed. For
    this example, that might be the next day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Posting data works in the same way. A game that sends your score to the server
    can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If `username` or any other parts of the posted data contain space characters,
    you should use `URLEncode` in the location first. Doing so will convert spaces
    and other special characters into codes that will safely arrive at the destination
    URL. The following would be a safer variation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing to a text file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the days of HyperCard, the only real choice to save and load external
    data was to write a text file. LiveCode can of course do that too, and in some
    cases, it may be the simplest solution. Configuration and preference files are
    a couple of good examples where a small text file can be used to set up the application
    in the way the user wishes it to be.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, say we have configuration text files named `englishstrings.txt`
    and `frenchstrings.txt` that were included in the **Copy Files** list of the **Standalone
    Application Settings** dialog box and they are going to be used to set the button's
    names in English or French within your application. Also, we'll want to write
    a preferences file to remember the user's choice. When the app is opened, we would
    check what the preferences file says and then load the appropriate strings file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With mobile operating systems, iOS in particular, there are strict rules about
    where you are allowed to save data. As we move forward, we will use locations
    that are approved for such use by Apple and Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text files that you include in a mobile app will be in the same location
    as the app itself, and the text files that you want to write to, should be in
    the `documents` folder of your app. Because these paths look quite different in
    iOS and Android, we should use LiveCode''s `specialFolderPath` function to locate
    these folders. Here''s how an `openStack` handler would check whether the preferences
    have been set and if not, would take the user to an initial language choice screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The special **engine** folder path is in the same location as the application
    file and the supporting files that you included in the **Copy Files** section
    of the **Standalone Application Settings** dialog box (as described in the *Copy
    Files* section of [Chapter 7](part0093.xhtml#aid-2OM4A2 "Chapter 7. Deploying
    to Your Device"), *Deploying to Your Device*) while saving the standalone application.
    In the preceding example, there would be files named `englishstrings.txt`, `frenchstrings.txt`,
    `spanishstrings.txt`, and so on. The following line of code will concatenate the
    path where the included files are located, the language that you wish to use (stored
    in the variable `prefstext`), and the ending of these filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will give you the full path to the language strings text file that matches
    your chosen language.
  prefs: []
  type: TYPE_NORMAL
- en: Using another stack to store data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, you would just save changes in the stack you are in at the time, except
    that iOS doesn't permit you to save the changes in the application directory.
    We have to work around this by saving a stack, in the documents folder. The stack
    to save can either be the one that is our application stack or it could just be
    a stack purely used to store data. Saving data in a stack can be more convenient
    than saving it in text files. For example, you can have several text fields that
    are there to store bits of information that will be needed the next time the app
    is run. If you use text files, you would either need lots of them or you will
    have to process the text from a single file in order to extract the individual
    bits of information.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to try and save data in stacks without making a mobile app to
    check whether the basic technique works. Afterwards, you can try the same on an
    actual device. An advantage of trying this on your computer first is that you
    can browse to the `documents` folder in order to see the magic as it happens!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a data save stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to make a copy of a stack, but only if another copy of that stack
    doesn't exist. LiveCode has a nice `if there is a…` function, which was made for
    times like this!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the stacks we''ll need by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new Mainstack with the name `LaunchStack`. Save it somewhere other than
    your computer's `Documents` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start another new Mainstack with the name `AppStack`. Save it in the same folder
    as the first stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place some data on each stack's card, so that you can easily recognize when
    you're in that stack. For example, drag a button onto the card of the `LaunchStack`
    stack and name it in a way that makes it very easy to recognize. Do the same for
    the `AppStack` stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following `openStack` handler in the stack script of `LaunchStack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save both the stacks and quit LiveCode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before trying the stacks on a device or in the simulator, we''ll try them as
    desktop stacks by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look in your `Documents` folder; there should *not* be an `AppStack.livecode`
    file in this folder at the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch LiveCode by double-clicking on the `LaunchStack.livecode` file. If you
    find that LiveCode doesn't launch this way, make sure that you have the associated
    `.livecode` documents to be opened with LiveCode. If you are using more than one
    copy of LiveCode, say you're trying the Community version and the Commercial version,
    you can drag the stack file onto the copy of LiveCode that you're intending to
    use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look in your `Documents` folder; there now should be an `AppStack.livecode`
    file with the time when the file was created that matches the current time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should also see that the path to AppStack is indeed in your `Documents`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, follow these steps to try our stacks on a mobile device or an iOS Simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the AppStack stack and uncomment the `put specialFolderPath…` line from
    the `LaunchStack` stack script that you entered in step 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Standalone Application Settings** and choose the **Copy Files** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add File…** and locate and add the original `AppStack.livecode` stack
    (not the one that was created with the previous test).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose either the **Android** or **iOS** section of the **Standalone Application
    Settings** and check the box to make the app available for that platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Development** menu, select your test target. That would be either
    one of the iOS simulators, if you choose iOS, or the connected Android device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Test** from the **Development** menu. You should now be able to view
    your AppStack and an alert dialog box showing the path to the stack. The following
    screenshot shows the resulting dialog box in the iOS Simulator window and in an
    Android 4 tablet:![Time for action – creating a data save stack](img/image00271.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up our app to copy the main application stack in the documents area on
    the device, so that we'll be able to make changes and save those successfully.
    If you happen to test on iOS and Android, you will see quite different looking
    paths for the stack. LiveCode takes care of finding these special folders for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – other special places
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check whether you just happen to know this or use this question as an excuse
    to read the release notes and dictionary! Which of these is *not* a `specialFolderPath`
    type?
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Desktop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '0x000e'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: 1'
  prefs: []
  type: TYPE_NORMAL
- en: The `specialFolderPath` types `Home` and `Desktop` are not used by Android and
    `Desktop` is not used by iOS. `0x000e` sounds suspicious, but is actually the
    `specialFolderPath` entry for `My Videos` under Unix! None of the systems have
    a `Users` entry.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web "scraper" app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an excuse to try out various native mobile controls, we're going to make
    an app that can read web pages and extract links to different media on the page.
    The app will have a card that shows a web browser, cards to show the links, text,
    media from the web page, and a set of cards to remember the selected items.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the tab navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the process of making the Browser card, we need to set
    up the items that are shared across all the cards in the app. The following steps
    will help you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use MobGUI again to make life easier. Select **revMobGUI** by navigating
    to the **Development** | **Plugins** submenu. Also, open the **Project Browser**
    from the LiveCode **Tools** menu to observe the stack structure as it develops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Mainstack, set its name to `WebScraper`, and save it someplace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In these instructions, we'll use iPhone in portrait orientation, but feel free
    to use iPad or an Android size for the card. Either select **iOS7** and **320x480**
    in the MobGUI window or your preferred options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you did in the *Time for action – using MobGUI to remember layouts for us*
    section in [Chapter 3](part0038.xhtml#aid-147LC1 "Chapter 3. Building User Interfaces"),
    *Building User Interfaces*, use the MobGUI tools to add a **Navbar** and click
    on **Snap to top** of the card window, a **Tab-bar** with **Snap to bottom** of
    the card window, and **Bg colors** for both. Note that a MobGUI card and behavior
    controls are added to the project automatically when MobGUI controls are added
    to the Mainstack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a LiveCode field control to the NavBar and label it `NavBar`. Format it
    as you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out a **Button** control from the MobGUI palette and duplicate it four
    times. Select all the five buttons and select **Align Objects** from the **Inspector**.
    Align their tops and distribute them across the card. Drag the five buttons to
    the Tab-bar that you just created and adjust their size and position as desired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the five buttons as `Browser`, `Links`, `Text`, `Media`, and `Keepers`.
    Do this by setting the **Label** entry in the Inspector palette.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of each button and in the `mouseUp` handler, add the following
    lines to leave the handler looking like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the **Edit** menu, and select **Select All** | **Group Selected** from
    the **Object** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the group, and in the **Basic Settings** menu of the regular LiveCode
    Object Inspector, give the group, the name `Common` and check the **Behave like
    a background** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the name of the card to `Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new card and name it `Links`. Note that the grouped buttons appear on
    the new card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for three more cards that are to be named `Text`, `Media`, and `Keepers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Standalone Application Settings**, choose **iOS** or **Android** as
    the platform you want to try, select the appropriate target from the **Development**
    menu, and perform a **Test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on or touch the five tab buttons and you should see that the name of the
    `NavBar` field has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By naming the buttons and cards the same, we were able to go to the five cards
    using the script attached to the group. Also, we used the button script to set
    the name of the NavBar to match the name of the card we had jumped to. The `init`
    line will come on its own as we write the card scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the same name with the same type of control on the same card. Your
    script may end up operating on the wrong control.
  prefs: []
  type: TYPE_NORMAL
- en: The Browser card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll now add a few controls and scripts to the first card to create the following
    mini web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Browser card](img/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The native browser control has many properties, actions, and messages associated
    with it. You can view both the **iOS Release Notes** and the **Android Release**
    **Notes** at the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-iOS.pdf](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-iOS.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-Android.pdf](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-Android.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional updates on support documents can be found at the following :'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://livecode.com/blog/2013/10/18/6-1-2-brings-ios-7-support/](http://livecode.com/blog/2013/10/18/6-1-2-brings-ios-7-support/)'
  prefs: []
  type: TYPE_NORMAL
- en: For our application though, we only need a few of LiveCode's abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the browser controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Return to the first card of the stack and find your way to the native controls
    part of the MobGUI window. The following steps will guide you through it:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Browser** control on the card window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the control to fill the width of the card and resize the control so that
    its height fits between the tab bar and a little way below the NavBar. Give it
    the name `Page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the browser control selected, make sure that the box in the MobGUI window
    titled **Auto delete** is checked. This will help reduce the memory usage of the
    final app during the times you're not on the browser card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the MobGUI window, drag an **Input** control into the gap between the browser
    control and the NavBar. Name it `url` and resize it to be nearly as wide as the
    card, leaving space for the **Go** button on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Button** control into that space, set its label to `Go`, and resize
    it to look nice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the **Go** button (which as you may notice, is really a
    group) and add a couple of lines in the mouseUp handler, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Later, we will send an `init` message to the cards. For the Browser card, we
    can use this as a way to restore the previously chosen web page. Add the following
    to the Browser card script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Edit the script of the browser (group `Page`) control. We're going to use the
    `browserFinishedLoading` message to know when to update some variables and URL
    text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify this handler of the browser control''s script, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and perform another **Test** to see the browser card in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting the `pURL` command of the browser control to `mgText` was enough to
    make the browser function, but some of what was just done was in preparation for
    what we'll need in the other cards. In particular, we used the regular LiveCode
    `put url` command to stash a copy of the web page HTML code in a global variable
    and this will be needed when we start extracting links and media from the page.
  prefs: []
  type: TYPE_NORMAL
- en: The Links card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Links, Text, and Media cards will take the page source that is stored in
    the `gPageHTML` global variable and extract the bits of interest from it. How
    will they do that?
  prefs: []
  type: TYPE_NORMAL
- en: A common approach while extracting a known pattern of text is to use regular
    expressions, which are often referred to as `regex` or `regexp`. At it's the simplest
    approach, it's easy to understand, but can get quite complex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read the Wikipedia article if you want to understand about a regular expression
    in depth at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful source of information is this Packt Publishing article on regular
    expressions, which you can find at [http://www.packtpub.com/article/regular-expressions-python-26-text-processing](http://www.packtpub.com/article/regular-expressions-python-26-text-processing).
  prefs: []
  type: TYPE_NORMAL
- en: One problem though, is that using regexp to parse HTML content is frowned upon.
    There are scores of articles online telling you outright NOT TO parse HTML with
    regexp! Here's one pithy example at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html](http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, parsing an HTML source is exactly what we want to do here and one solution
    to the problem is to mix and match using LiveCode's other text matching and filtering
    abilities to do most of the work. Although it's not exactly regexp, LiveCode can
    use regular expressions in some of its matching and filtering functions and they
    are somewhat easier to understand than full-blown regexp. So, let's begin by using
    these.
  prefs: []
  type: TYPE_NORMAL
- en: 'While looking for links, we will make the assumption that the link is inside
    an `a href` tag, but even then, there are a lot of variations of how that can
    appear. The general structure of an `href` tag is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the text of the web page will be the phrase `Link text that the user will
    see`. When this is pointed at by the mouse, the user will see the pointing finger
    cursor, and when it's clicked on, the page will reload using the URL shown in
    the `href` part of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example shows the full path to the support forum; here are the
    ways that the very same web location might be written as in a page link:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.runrev.com/support/forum/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/support/forum/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`support/forum/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`../support/forum/`'
  prefs: []
  type: TYPE_NORMAL
- en: The first link will take you there no matter where you are at that time. The
    second will take you there if you're somewhere else on the [http://runrev.com/](http://runrev.com/)
    site. The third will be correct while you are at the root level of [http://runrev.com/](http://runrev.com/),
    and the last example would work from within one of the other root-level directories
    on the site.
  prefs: []
  type: TYPE_NORMAL
- en: With regex, you might create an extravagant expression that deals with all possible
    variations of how the links are contained in the page source, but even then it
    would not give us the full paths we need.
  prefs: []
  type: TYPE_NORMAL
- en: By taking things slowly, we can reduce the whole page source to a set of lines
    of "a href" entries, extract the URL part of each line, and finally, take the
    preceding variations and convert them into full path URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making a links extraction function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it''s handy to create tests in a separate stack and then to take
    the function you''ve made into your application stack. The following points will
    help you in making a links extraction function:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Mainstack** and save it, just to be safe!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a couple of fields and a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the button''s script to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the stack script and create a function for `getLinks`. Start with returning
    what it has sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try clicking on the button at this point, you will see that the whole
    page source appears in field 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re going to use the filter function, and it needs the text to be in separate
    lines. So, we want every link to be in a line of its own. The `replace` function
    can do this nicely. Add these two lines to the script (before the "return" line,
    of course!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try clicking on the button now. The two fields will look much the same, but
    any lines that have a link in them will certainly be on a line of their own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a line to filter the list, as it stands, to reduce it so that it shows
    only the lines with links in them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `*` characters are wildcards that reduces the list so that it only contains
    the lines that have both `a href` and `/a>`. Try the button again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you''ll see that there are only lines with links in them, but they still
    include the junk either side of the link itself. The part we need is between the
    first and second quote marks, and using the `itemdelimiter`, we can get at that
    bit. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you now click on the button, you should get a list of only the URL part
    of each line. However note that most of the links start with `/` and not `http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make another function in the stack script that will change the links to full
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the code needed to cope with the variations of URL (to function `getPath`),
    starting with it''s full path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you recall from earlier, we saved the URL of the main page in a global variable,
    `gPageURL`. For the case where the link is a root relative (it starts with a `/`),
    we want to combine the host location and the link URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When that first character is not `/`, it may start with `../` to step up one
    level in the server structure. Deleting the last part of the page URL will give
    us what we need to combine with the link URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, if all of these checks fail, we will return an empty string, so that
    this strange structured link URL doesn''t go on to confuse us later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the `getLinks` function to use the `getPath` function, we need to make
    a change to the script shown in step 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In stages, we developed a function that can find the links in a web page's source
    text ending with a set of full path URLs that we can present to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The missing links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The one missing piece in the test stack is the global variable that stores the
    page URL. In the case of the app stack, the value is provided by the browser control's
    `browserFinishedLoading` function, but here, we need to plug in a value for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a global declaration line in the button''s script and the stack script.
    In the button script, fill in the variable with our test case value. The script
    will then be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Try the button now, you should see a list of full path URLs in your second field.
    If it works correctly, copy the two stack functions and the global declaration
    line and paste them into the stack script of the WebScraper stack.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tab bar script includes an init line. This will call the card script; in
    this case, the Links card script, but it doesn't exist yet! Let's make it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding the links card's init handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before proceeding, make sure that you are happy with the functions in the test
    stack and that you have copied them to the WebScraper stack script using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Links card of the WebScraper stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the card script and add these global variables and `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do a Test of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the iPhone Simulator or Android device, if that's what you're using, change
    the URL to [http://www.runrev.com/](http://www.runrev.com/) and select the **Go**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the page is loaded, select the **Links** tab button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be looking at the list of links from the RunRev page; only this
    time, it's presented in a native picker list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a link from the list and then **Done**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be taken back to the Browser card with the linked page loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The card script we entered does the same job as the button in the test stack;
    in that, it calls to the stack functions to get a list of links. Here, rather
    than putting the list into a plain field, we used LiveCode''s ability to open
    a native picker control using the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The required parameters of this function are a list of items to be shown and
    an index position to be the one that is selected. By entering `1`, the first item
    is selected by default. The result that comes back from the picker is an index
    of the item that was selected, and we can use this to look up the matching line
    in the `gLinks` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining lines take us back to the Browser card, set the URL to be loaded,
    and also change the NavBar to reflect the card name.
  prefs: []
  type: TYPE_NORMAL
- en: The Text card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making the Text card work is a lot simpler, but includes an unbelievably complex
    regular expression line, which can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents](http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents)'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the Text card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start off in the test stack that you made, so that we can get the function
    working there before adding it to the WebScraper stack.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the button you made when extracting links. Change the function call
    `getLinks` to `getText`; the rest of the script can remain the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the test stack and add this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try clicking on the button you just made. You should see your second field filled
    with just the text parts of the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the function and go back to the WebScraper stack script. Paste the function
    there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Text card of the stack and from the MobGUI window, drag the **Multiline
    Text** control onto the card. Set its name to `PageText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the control to fill the area between the NavBar and the Tab-bar. You
    may have to use the LiveCode Inspector to modify the size if the text does not
    fill the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the MobGUI window properties for the control, uncheck the box for **Editable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the card script and add this `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try a **Test** of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Browser** card, change the URL from [http://google.com/](http://google.com/)
    to [http://runrev.com/](http://runrev.com/) and click on **Go**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Text** tab button at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be on the **Text** card and should be able to see the text elements
    from the web page displayed in a native scrolling text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This enormously long regular expression ran through the web page source and
    removed anything that was script, style, or just tag information, leaving the
    text parts alone. However, it would leave it with lots of spare line feed characters
    and tab characters, which we went on to remove using the LiveCode `replace` function.
    The final text may not be perfect, but you can use the standard mobile text features
    to copy parts of the text for use in other apps.
  prefs: []
  type: TYPE_NORMAL
- en: The Media card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Media card is going to start off very much like the Links card, with an
    `init` function in the card script and a stack script function to extract the
    media links from the page.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – extracting a list of media links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There probably is a regular expression that would extract all the `src` links
    from a page, but we''re only interested in things that we know LiveCode is able
    to show or play. So in these steps, we''ll use a more devious way to extract just
    the links we can handle:'
  prefs: []
  type: TYPE_NORMAL
- en: You may as well head over to the test stack!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a third button by duplicating one of the other two and change the `getLinks`
    or `getText` part in the button script to call `getMedia` instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the stack script, enter all of this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the button and you should see a list of full paths to the various images
    in the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This devious approach involved the task of finding any place where the media
    of interest is mentioned and adding an asterisk and return character in order
    to make sure that the link was easily identified and at the end of a unique line.
    Then, each of these lines were sent to another function, `removeLeaders`, to remove
    any other text that was earlier in the line than at the start of the link. Finally,
    the same `getPath` function we used while extracting links was used to give us
    full paths to the media files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a list of media links, we need to add the card level handlers
    required to present the list to the user and to load their selected media item
    onto the card window.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the Media card scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy the functions that you have proved to work, in the test stack script and
    paste them into the WebScraper stack script. Then, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Media card. As with the Links card, we're not going to add any controls
    to the card, as we'll do that with the script. So, edit the card script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the Media card''s `init` function and the needed global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike the Links case, we've built up a list of just the filename part of the
    URL, to be seen in a native picker, and when we've selected something we will
    call a `showMedia` function in the stack script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the stack script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `showMedia` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can start with the google.com page; click on the **Media** tab button to
    see a list of the images used on that page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an image from the list and click on **Done**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should appear on the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Browser** card and change the URL to `http://www.apple.com/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apple usually includes some video link thumbnails on the main page. click on
    one of those, so that you see the large video player. However, don't play it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Media** tab button to see a list of all the media on that page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the list and look for one of the longer-named items that seems like
    it must be a video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select that item and press **Done**. The video should load and play on the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the video controller's **Done** button when you are finished watching the
    video to return to the **Media** card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then click on the **Media** tab button again to make the picker reappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the **Browser** card and enter a URL that contains examples of MP3
    files. `http://www.ntonyx.com/mp3_songs.htm` is one such example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Media** tab button to return to the **Media** card with the list
    of all the media on that page, which in this case will be mainly MP3 files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one of the MP3s from the list and click on **Done**. The MP3 should play
    in the same player that the video is played in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we made use of both a standard LiveCode control, the image,
    and also a native control, the video player. LiveCode handles the setting up of
    the player and with the very simple "play video videoname" syntax, we were able
    to invoke the native player. It was able to play both video and audio files.
  prefs: []
  type: TYPE_NORMAL
- en: The Keepers card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, this should be the Keepers *cards*. These cards are where you can
    stash media that you've found interesting. For file size reasons, we're actually
    just going to store the URL to the media; after all, a long video would soon use
    up your device's storage!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the Keepers card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the **Keepers** card and create a MobGUI button for **Prev**, **Next**,
    and **Play Media**. Make a MobGUI **Multiline** field and name it `mediaURL`.
    Be sure to uncheck the **Auto delete** option, so that it keeps the URL data when
    we change cards. Also uncheck the **Editable** option. You should now have something
    looking like the following screenshot:![Time for action – setting up the Keepers
    card](img/image00273.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add these lines to the `mouseUp` handler of the **Prev** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add these lines to the `mouseUp` handler of the **Next** button. Note that
    `- 1` is used since the last card is the MobGUI card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this line to the Play Media button''s `mouseUp` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the four controls and Group them. Check the box that says **Behave like
    a background**. Name the group `keeperbuttons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script of the new group. Add this `refresh` handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to go back and add things to the **Media** card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Media** card and add a MobGUI button. Set the name and label to
    `Keep Media`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One tricky thing is that media will play full screen on smaller screens and
    by the time you see the **Keep Media** button, the video has already gone away.
    We can work around this by storing the URL of the last shown media in a global
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Media** card script, change the `init` function, so that the later
    lines read like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the global variable declaration line to include the `gLastMedia` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `mouseUp` handler of the **Keep Media** button to be this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, only one last step is required for the stack to save the media. We need
    to create a launcher app like we did earlier in this chapter. Create a stack named
    `LaunchScraper` with the following stack script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the Launch Scraper and Web Scraper apps are in the same folder.
    Open only the Launch Scraper app and make sure that the Web Scraper app is included
    in the **Copy files** of the **Standalone Application Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your **Test** **Target** device and then **Test**. Note that the last
    answer statement will display the path and the filename where the main app is
    stored on your device. This can be commented out once you are comfortable that
    it is working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Browser** card to load a page with plenty of images, videos, or sounds
    on it and go to the **Media** card to see those listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any item followed by a click on **Done**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you like the image, sound, or video, use the **Keep Media** button to go
    to the end of the stack to save the media's URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose more bits of media and keep them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Keepers** section and use the **Next** and **Prev** buttons to browse
    through the items you've kept.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The images should appear automatically and the video and audio can be started
    with the **Play Media** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added the last feature of our application, a set of cards where we can go
    to view the bits of media that we've chosen to keep.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – add some preset locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do make the Web Scraper app and start to find it useful, it's quite likely
    that there will be a set of web pages that you'd like to go back to again and
    again. To type the URL every time would be tedious. So, why not make a hidden
    field on the **Browser** card and type in a list of your favorite pages. Add a
    button to the card too, which will bring up a list of those pages for you to choose
    from. The one you choose can then load the **Browser** control at the desired
    page. All of the steps to do this were covered in the *The Links card* section.
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty certain that if you've carefully followed all the steps in this
    chapter and indeed all the steps were perfect, you still wouldn't have an app
    ready to be submitted to the app stores! You would require a splash screen, a
    main menu, icons on the tab buttons as well and some love from a graphic designer!
    Feature wise, it would be nice if the images you keep could be zoomed and panned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the topics that we covered here are less glamorous, mostly the ones
    about processing HTML text, but we did also use a few mobile features. We demonstrated
    how a native app can store data for subsequent usage, and how to make and control
    a web browser. The use of a native picker to present lists was covered. We also
    created a native scrolling field that had all the normal OS-specific abilities
    and played video and audio using the native media players.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is almost entirely about dealing with graphics, so we'll make
    sure to use some image manipulating gestures and you could revisit the Web Scraper
    app later to add the same features to the Keepers cards.
  prefs: []
  type: TYPE_NORMAL
