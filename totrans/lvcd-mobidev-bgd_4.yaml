- en: Chapter 4. Using Remote Data and Media
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 使用远程数据和媒体
- en: '*While creating a LiveCode application, we need to think about the structure
    of the stack, its code, and the data it uses. Applications can be made when all
    the supporting data is within the application, but quite often, we want to display
    data that is out in the real world somewhere and also want to save information
    (a high-score list perhaps) to text files that are external to the application.
    You may also want to share information with other people or sync between apps
    or devices.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在创建LiveCode应用程序时，我们需要考虑栈的结构、其代码以及它使用的数据。当所有支持数据都在应用程序内部时，可以创建应用程序，但很多时候，我们希望显示存在于现实世界中的数据，并且还想将信息（比如高分排行榜）保存到应用程序外部的文本文件中。你可能还想与他人共享信息或在不同应用程序或设备之间同步。*'
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Look at the various ways a stack might be structured
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看栈可能的结构方式
- en: Think about where code should go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑代码应该放在哪里
- en: Write to and read from external text files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入和读取外部文本文件
- en: Create a scrapbook-like app to remember interesting Internet-based media files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类似剪贴簿的应用程序来记住有趣的基于互联网的媒体文件
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do you want to save time typing code?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你想节省打字代码的时间吗？
- en: There are a lot of lines of code in this chapter. The code is shown along with
    explanations of each function and you could use this code to build up something
    that matches the corresponding sample file. However, it would be very easy to
    make a mistake while transcribing the scripts, both in terms of what the script
    says and where the script should be placed. It may be safer to study the sample
    files and read the overall description here. You can download the code from the
    Packt Publishing website at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有很多代码行。代码会与每个函数的解释一起展示，你可以使用这段代码构建与相应样本文件匹配的内容。然而，在转录脚本时，无论是脚本的内容还是脚本应该放置的位置，都很容易出错。可能更安全的方法是研究样本文件，并在这里阅读整体描述。你可以从Packt
    Publishing网站下载代码，网址为[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)。
- en: The stack structure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈结构
- en: There are two aspects to how the stack may be structured. One is about how user
    interface elements are organized and the other is about where in the hierarchy
    of a stack you should place your code. The first addresses how to make the app
    understandable, logical, and easy to use. The second addresses how to minimize
    development time, subsequent maintenance effort, and how to maximize the resulting
    performance of the app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的结构有两个方面。一方面是关于用户界面元素的组织方式，另一方面是关于在栈的层次结构中你应该放置代码的位置。前者解决的是如何使应用程序易于理解、逻辑性强且易于使用。后者解决的是如何最小化开发时间、后续维护工作，以及如何最大化应用程序的性能。
- en: Code-driven and manually created layouts
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码驱动和手动创建的布局
- en: 'When you imagine how a typical mobile application appears, it would be somewhat
    along these lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想象一个典型的移动应用程序看起来像什么时，它可能大致是这样的：
- en: '![Code-driven and manually created layouts](img/image00268.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![代码驱动和手动创建的布局](img/image00268.jpeg)'
- en: Sometimes, applications are entirely code-driven where every screen you see
    is created using code at the time that it's needed. Perhaps, it would already
    lay out the elements that are saved as resources and then the code would load
    these resources. In either case, the whole application could take place on the
    equivalent of one LiveCode card.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序完全是代码驱动的，你看到的每个屏幕都是根据需要即时使用代码创建的。也许它已经布局了作为资源保存的元素，然后代码会加载这些资源。在任何情况下，整个应用程序都可以在一个LiveCode卡片上完成。
- en: Another approach would be to lay out every possible screen combination as different
    cards or even stacks and to go to the card or stack that looks like how the app
    appears at that moment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将每个可能的屏幕组合作为不同的卡片或甚至栈，并转到看起来像应用程序在那个时刻的样子。
- en: In the first case, you would need to run the application and go through the
    user actions in order to check whether the layout was correct. Then, you would
    need to go back and change the code or resources and try again. In the second
    case, you may face a lot of combinations of layout.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你需要运行应用程序并执行用户操作，以检查布局是否正确。然后，你需要返回并更改代码或资源，然后再次尝试。在第二种情况下，你可能面临许多布局组合。
- en: As we start making apps here, we'll try to find a middle ground where we'll
    use cards to set up the main screens we'll need and then we'll use code to show
    and hide other elements. Our goal is to try and be efficient and not create complex
    code to lay out items that could be laid out quickly by hand. We also don't want
    to use a lot of images when a small amount of code could get us the same results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始在这里制作应用程序时，我们会尝试找到一个中间地带，在那里我们将使用卡片来设置我们需要的主体屏幕，然后我们将使用代码来显示和隐藏其他元素。我们的目标是尽量提高效率，不要编写复杂的代码来布局那些可以快速手动布局的项目。我们也不希望在代码可以取得相同结果的情况下使用大量图像。
- en: Locations for code
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码位置
- en: 'LiveCode is extremely flexible in terms of how you structure things that you
    make with it. In addition to a dozen different kinds of controls that could contain
    code, you can also control front scripts, groups, the current card, a mainstack,
    stacks in use, back script, and LiveCode itself. The following diagram shows you
    only a few example controls, but gives you the sense of how many levels there
    are to the hierarchy of LiveCode:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode在如何构建你用它制作的事物方面非常灵活。除了可以包含代码的十几种不同类型的控件之外，你还可以控制前端脚本、组、当前卡片、主堆栈、正在使用的堆栈、后端脚本以及LiveCode本身。以下图表只显示了几个示例控件，但它给你了一个LiveCode层次结构有多少级别的概念：
- en: '![Locations for code](img/image00269.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![代码位置](img/image00269.jpeg)'
- en: You can also have sub stacks that are often used to show dialog windows, the
    ability to add front and back scripts, and you can put stacks in and out of use
    too. Overall, it can get quite confusing!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以有子堆栈，通常用于显示对话框窗口，添加前后脚本的能力，以及你可以将堆栈放入或移出使用。总的来说，可能会变得相当混乱！
- en: It is largely a case of personal style as to where you put your scripts and
    often, you may have a reasonable argument why you did it in a certain way. You
    could argue that all the actions that take place should be in the script of the
    button you clicked on. It would make it easy to edit all the handlers involved
    and if you need the same features in another stack, you would only have to copy
    the button across. However, if you had a number of those buttons on the screen
    and needed to make changes, you would have to do so for all of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于个人风格，至于你将脚本放在哪里，通常你可能会有一个合理的理由来解释你为什么以某种方式做了。你可以争论说，所有发生的行为都应该在点击的按钮的脚本中。这将使得编辑所有涉及的处理器变得容易，如果你需要在另一个堆栈中具有相同的功能，你只需复制按钮即可。然而，如果你在屏幕上有许多这样的按钮并且需要做出更改，你必须对它们全部进行更改。
- en: Another valid argument would be to say that all handlers are at the stack level.
    You would then have one central place to make changes, but you would have to make
    lots of `if` statements to check which control has been operated on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有效的论点是可以说所有处理器都在堆栈级别。这样，你将有一个中央位置来做出更改，但你将不得不做出很多`if`语句来检查哪个控件已被操作。
- en: You might want to reuse routines that you have developed over time and would
    have a set of stacks that you could put into use, where each stack just handles
    a particular aspect of the task at hand. In the world of **Object-oriented Programming**
    (**OOP**), it's quite common to extend this approach to a crazy degree with hundreds
    or even thousands of small files where each file handles a tiny portion of the
    overall application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望重用你随着时间的推移开发出的例程，并会有一组你可以投入使用的堆栈，其中每个堆栈仅处理手头任务的特定方面。在面向对象编程（**OOP**）的世界里，将这种方法扩展到疯狂的程度是很常见的，有数百甚至数千个小文件，每个文件处理整体应用程序的一小部分。
- en: We won't go to any of these extremes. Instead, we will try to put code at the
    lowest level that it needs to be without duplicating the code, as you make additional
    controls that need the same code. While doing this, we will try to think ahead
    and spot efficiencies that we can use. Let's look at an example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会走向这些极端。相反，我们将尝试将代码放在最低级别，这样它就不需要重复代码，正如你创建需要相同代码的额外控件时。在这个过程中，我们将尝试提前思考并发现我们可以使用的效率。让我们看看一个例子。
- en: 'Suppose you have a main menu button and its function is to take the user back
    to the card named `main`. Having this as the button''s script would make sense:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个主菜单按钮，其功能是将用户带回到名为`main`的卡片。将此作为按钮的脚本是有意义的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It would appear to be the lowest level the code can be at and we''re not going
    to duplicate it, as there''s just one main menu button. However, suppose we want
    to track the user''s progress, the main menu button won''t know anything about
    that. So, we could do this instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是代码可以到达的最低级别，我们不会重复它，因为只有一个主菜单按钮。然而，如果我们想跟踪用户的进度，主菜单按钮将对此一无所知。所以，我们可以这样做：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the card script, there would be this handler:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡片脚本中，会有这个处理程序：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `saveNavState` function would be somewhere, saving the user''s state. The
    only problem is that for each of the cards we make, which includes the main menu
    button, we will have to have this `navTo` handler in each of their scripts. Therefore,
    we''ll put the handler in the mainstack stack script. With it being at this level,
    it can handle calls from any button on any card. The help button''s script could
    be this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveNavState`函数会在某个地方保存用户的状态。唯一的问题是，对于我们所创建的每一张卡片，包括主菜单按钮，我们将在它们的脚本中都要有这个`navTo`处理程序。因此，我们将处理程序放在主栈栈脚本中。由于它处于这个级别，它可以处理来自任何卡片上任何按钮的调用。帮助按钮的脚本可能是这样的：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Going to the help card would also save the user's state. Later, we could also
    add a visual effect as you jump from place to place and make that change in `navTo`
    instead of going around the various buttons that make use of the `navTo` handler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前往帮助卡片也会保存用户的状态。稍后，我们还可以添加一个视觉效果，当你从一个地方跳到另一个地方时，并在`navTo`中而不是绕过使用`navTo`处理程序的各个按钮中做出这种改变。
- en: Pop quiz – name that structure
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——命名这个结构
- en: There is a common term used to describe the LiveCode hierarchy that helps convey
    how information is passed up and down the hierarchy. What is that term called?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常用的术语用来描述LiveCode的层次结构，有助于传达信息如何在层次结构中上下传递。这个术语叫什么？
- en: The Event Horizon
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件视界
- en: The Message Path
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息路径
- en: The Call Stack
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用栈
- en: The Home Stack
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主栈
- en: 'Answer: 2'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：2
- en: 'For further reading, RunRev has an online lesson that describes the message
    path, which you can find at:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进一步阅读，RunRev有一个在线课程，描述了消息路径，你可以在以下位置找到：
- en: '[http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path](http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path](http://lessons.runrev.com/s/lessons/m/4603/l/44036-the-livecode-message-path)'
- en: Loading and saving external data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存外部数据
- en: In many applications, you will want to keep track of changes that a user has
    made. There are several ways to do this with LiveCode, including querying a URL,
    reading and writing to a text file, and saving data inside a stack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，你可能想要跟踪用户所做的更改。LiveCode有几种方法可以做到这一点，包括查询URL、读取和写入文本文件以及保存堆栈内的数据。
- en: Querying a URL
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询URL
- en: 'Quite often, web-based applications load and save data from server-side scripts.
    This can work with LiveCode apps too. Here''s an example which shows the closing
    share price for Google yesterday:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，基于Web的应用程序从服务器端脚本中加载和保存数据。这也适用于LiveCode应用程序。以下是一个示例，展示了昨天谷歌的收盘价：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At the moment of writing this book, this line was tested and `609.46` appeared
    in the **Message Box,** shown as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，这一行已经过测试，**消息框**中出现了`609.46`，如下所示：
- en: '![Querying a URL](img/image00270.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![查询URL](img/image00270.jpeg)'
- en: Who knows what you'll find when you try it! In fact, while doing the second
    revision of this book, the number that popped up was 1172.9301\. Go Google!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道当你尝试时你会找到什么！实际上，在本书的第二版修订过程中，跳出的数字是1172.9301。去谷歌搜索吧！
- en: 'As with any such calls to an online service, there is a chance that it may
    take some time for the value to return, and in the preceding example, LiveCode
    would be blocked from doing anything else until the data returns. An alternate
    approach for this, is to load the URL in order to cache it and then display the
    results when it is cached. LiveCode would be able to do other actions while the
    data returns. A button script would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何此类对在线服务的调用一样，有可能需要一些时间才能返回值，在前面的例子中，LiveCode在数据返回之前将无法执行其他任何操作。对于这种情况的一个替代方法是先加载URL以缓存它，然后在它被缓存后显示结果。在数据返回时，LiveCode可以执行其他操作。按钮脚本可能看起来像这样：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `gotit` handler also checks whether the call worked fine and if it didn't,
    it will display the error that caused the problem. The `unload` line is used to
    make sure that you're not reading the previously cached value. If it's a value
    that only changes infrequently, as with the closing price of a stock, then you
    would usually only clear the cached version when it's likely to be changed. For
    this example, that might be the next day.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`gotit`处理程序还会检查调用是否正常工作，如果没有，它将显示导致问题的错误。`unload`行用于确保您没有读取之前缓存的值。如果这是一个只偶尔改变的价值，例如股票的收盘价，那么您通常只有在它可能改变时才清除缓存版本。对于这个例子，那可能就是第二天。'
- en: 'Posting data works in the same way. A game that sends your score to the server
    can do it this way:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 发布数据的工作方式相同。一个将您的分数发送到服务器的游戏可以这样操作：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If `username` or any other parts of the posted data contain space characters,
    you should use `URLEncode` in the location first. Doing so will convert spaces
    and other special characters into codes that will safely arrive at the destination
    URL. The following would be a safer variation of the preceding code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`username`或任何其他发布数据的部分包含空格字符，您应该首先在位置处使用`URLEncode`。这样做会将空格和其他特殊字符转换为安全到达目标URL的代码。以下将是前面代码的一个更安全的变体：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reading and writing to a text file
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入文本文件
- en: Back in the days of HyperCard, the only real choice to save and load external
    data was to write a text file. LiveCode can of course do that too, and in some
    cases, it may be the simplest solution. Configuration and preference files are
    a couple of good examples where a small text file can be used to set up the application
    in the way the user wishes it to be.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在HyperCard的时代，保存和加载外部数据的唯一真正选择是编写一个文本文件。当然，LiveCode也可以这样做，在某些情况下，这可能是最简单的解决方案。配置和首选项文件是几个很好的例子，其中一个小型文本文件可以用来以用户希望的方式设置应用程序。
- en: As an example, say we have configuration text files named `englishstrings.txt`
    and `frenchstrings.txt` that were included in the **Copy Files** list of the **Standalone
    Application Settings** dialog box and they are going to be used to set the button's
    names in English or French within your application. Also, we'll want to write
    a preferences file to remember the user's choice. When the app is opened, we would
    check what the preferences file says and then load the appropriate strings file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一些配置文本文件名为`englishstrings.txt`和`frenchstrings.txt`，它们包含在**独立应用程序设置**对话框框的**复制文件**列表中，并且它们将被用来在您的应用程序中设置按钮的英文名称或法文名称。此外，我们还想编写一个首选项文件来记住用户的选择。当应用程序打开时，我们会检查首选项文件的内容，然后加载适当的字符串文件。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With mobile operating systems, iOS in particular, there are strict rules about
    where you are allowed to save data. As we move forward, we will use locations
    that are approved for such use by Apple and Google.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动操作系统，尤其是iOS中，关于您允许保存数据的位置有严格的规则。随着我们向前发展，我们将使用苹果和谷歌批准用于此类用途的位置。
- en: 'The text files that you include in a mobile app will be in the same location
    as the app itself, and the text files that you want to write to, should be in
    the `documents` folder of your app. Because these paths look quite different in
    iOS and Android, we should use LiveCode''s `specialFolderPath` function to locate
    these folders. Here''s how an `openStack` handler would check whether the preferences
    have been set and if not, would take the user to an initial language choice screen:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序中包含的文本文件将与应用程序本身位于同一位置，而您想要写入的文本文件应该位于应用程序的`documents`文件夹中。因为这些路径在iOS和Android中看起来相当不同，我们应该使用LiveCode的`specialFolderPath`函数来定位这些文件夹。以下是一个`openStack`处理程序如何检查首选项是否已设置，如果没有，将用户带到初始语言选择屏幕的方法：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The special **engine** folder path is in the same location as the application
    file and the supporting files that you included in the **Copy Files** section
    of the **Standalone Application Settings** dialog box (as described in the *Copy
    Files* section of [Chapter 7](part0093.xhtml#aid-2OM4A2 "Chapter 7. Deploying
    to Your Device"), *Deploying to Your Device*) while saving the standalone application.
    In the preceding example, there would be files named `englishstrings.txt`, `frenchstrings.txt`,
    `spanishstrings.txt`, and so on. The following line of code will concatenate the
    path where the included files are located, the language that you wish to use (stored
    in the variable `prefstext`), and the ending of these filenames:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊**引擎**文件夹路径与应用程序文件以及您在**独立应用程序设置**对话框的**复制文件**部分中包含的支持文件位于同一位置（如[第7章](part0093.xhtml#aid-2OM4A2
    "第7章。将应用程序部署到您的设备")中的*复制文件*部分所述，*将应用程序部署到您的设备*)，在保存独立应用程序时。在前面的例子中，会有名为`englishstrings.txt`、`frenchstrings.txt`、`spanishstrings.txt`等文件。以下代码行将连接包含文件的路径、您希望使用的语言（存储在变量`prefstext`中）以及这些文件名的结尾：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will give you the full path to the language strings text file that matches
    your chosen language.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供与您选择的语言匹配的语言字符串文本文件的完整路径。
- en: Using another stack to store data
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用另一个堆栈存储数据
- en: Ideally, you would just save changes in the stack you are in at the time, except
    that iOS doesn't permit you to save the changes in the application directory.
    We have to work around this by saving a stack, in the documents folder. The stack
    to save can either be the one that is our application stack or it could just be
    a stack purely used to store data. Saving data in a stack can be more convenient
    than saving it in text files. For example, you can have several text fields that
    are there to store bits of information that will be needed the next time the app
    is run. If you use text files, you would either need lots of them or you will
    have to process the text from a single file in order to extract the individual
    bits of information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您只需保存您当时所在的堆栈中的更改即可，但iOS不允许您在应用程序目录中保存更改。我们必须通过在文档文件夹中保存堆栈来解决这个问题。要保存的堆栈可以是我们的应用程序堆栈，也可以是仅用于存储数据的堆栈。在堆栈中保存数据可能比在文本文件中保存更方便。例如，您可以有多个文本字段，用于存储下次运行应用程序时需要的信息片段。如果您使用文本文件，您可能需要很多个，或者您将不得不从单个文件中处理文本以提取个别信息片段。
- en: It's possible to try and save data in stacks without making a mobile app to
    check whether the basic technique works. Afterwards, you can try the same on an
    actual device. An advantage of trying this on your computer first is that you
    can browse to the `documents` folder in order to see the magic as it happens!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在不创建移动应用的情况下尝试在堆栈中保存数据，以检查基本技术是否可行。之后，您可以在实际设备上尝试相同的方法。首先在您的计算机上尝试此方法的优势是，您可以浏览到`documents`文件夹，以便看到事情发生时的神奇效果！
- en: Time for action – creating a data save stack
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建数据保存堆栈
- en: We're going to make a copy of a stack, but only if another copy of that stack
    doesn't exist. LiveCode has a nice `if there is a…` function, which was made for
    times like this!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制一个堆栈，但前提是那个堆栈没有其他副本。LiveCode有一个很好的`if there is a…`函数，它就是为了这种情况而设计的！
- en: 'First, we will create the stacks we''ll need by following these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按照以下步骤创建所需的堆栈：
- en: Start a new Mainstack with the name `LaunchStack`. Save it somewhere other than
    your computer's `Documents` folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以名称`LaunchStack`开始一个新的主堆栈。将其保存在除您计算机的`Documents`文件夹以外的其他位置。
- en: Start another new Mainstack with the name `AppStack`. Save it in the same folder
    as the first stack.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以名称`AppStack`开始另一个新的主堆栈。将其保存在第一个堆栈相同的文件夹中。
- en: Place some data on each stack's card, so that you can easily recognize when
    you're in that stack. For example, drag a button onto the card of the `LaunchStack`
    stack and name it in a way that makes it very easy to recognize. Do the same for
    the `AppStack` stack.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个堆栈的卡片上放置一些数据，这样您就可以轻松地识别出您是否在该堆栈中。例如，将一个按钮拖放到`LaunchStack`堆栈的卡片上，并以一种使其非常容易识别的方式命名它。对`AppStack`堆栈也做同样的操作。
- en: 'Put the following `openStack` handler in the stack script of `LaunchStack`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`openStack`处理程序放入`LaunchStack`的堆栈脚本中：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save both the stacks and quit LiveCode.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存堆栈并退出LiveCode。
- en: 'Before trying the stacks on a device or in the simulator, we''ll try them as
    desktop stacks by following these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试在设备或模拟器上尝试堆栈之前，我们将按照以下步骤将它们作为桌面堆栈尝试：
- en: Look in your `Documents` folder; there should *not* be an `AppStack.livecode`
    file in this folder at the moment.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Documents`文件夹中查看；目前这个文件夹中不应该有`AppStack.livecode`文件。
- en: Launch LiveCode by double-clicking on the `LaunchStack.livecode` file. If you
    find that LiveCode doesn't launch this way, make sure that you have the associated
    `.livecode` documents to be opened with LiveCode. If you are using more than one
    copy of LiveCode, say you're trying the Community version and the Commercial version,
    you can drag the stack file onto the copy of LiveCode that you're intending to
    use.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击`LaunchStack.livecode`文件来启动LiveCode。如果你发现LiveCode不能以这种方式启动，请确保你有与LiveCode关联的`.livecode`文档。如果你使用多个LiveCode副本，比如说你正在尝试社区版和商业版，你可以将堆栈文件拖放到你打算使用的LiveCode副本上。
- en: Look in your `Documents` folder; there now should be an `AppStack.livecode`
    file with the time when the file was created that matches the current time.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Documents`文件夹中查看；现在应该有一个创建时间与当前时间匹配的`AppStack.livecode`文件。
- en: You should also see that the path to AppStack is indeed in your `Documents`
    folder.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也应该看到，AppStack的路径确实位于你的`Documents`文件夹中。
- en: 'Now, follow these steps to try our stacks on a mobile device or an iOS Simulator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤在移动设备或iOS模拟器上尝试我们的堆栈：
- en: Close the AppStack stack and uncomment the `put specialFolderPath…` line from
    the `LaunchStack` stack script that you entered in step 4.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭AppStack堆栈，并取消注释步骤4中输入的`LaunchStack`堆栈脚本中的`put specialFolderPath…`行。
- en: Go to **Standalone Application Settings** and choose the **Copy Files** section.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**独立应用程序设置**并选择**复制文件**部分。
- en: Click on **Add File…** and locate and add the original `AppStack.livecode` stack
    (not the one that was created with the previous test).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加文件…**并定位并添加原始的`AppStack.livecode`堆栈（不是之前测试中创建的那个）。
- en: Choose either the **Android** or **iOS** section of the **Standalone Application
    Settings** and check the box to make the app available for that platform.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**独立应用程序设置**中的**Android**或**iOS**部分，并勾选复选框以使应用程序适用于该平台。
- en: From the **Development** menu, select your test target. That would be either
    one of the iOS simulators, if you choose iOS, or the connected Android device.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中选择你的测试目标。如果你选择iOS，那将是iOS模拟器之一；如果你选择Android，那将是连接的Android设备。
- en: Select **Test** from the **Development** menu. You should now be able to view
    your AppStack and an alert dialog box showing the path to the stack. The following
    screenshot shows the resulting dialog box in the iOS Simulator window and in an
    Android 4 tablet:![Time for action – creating a data save stack](img/image00271.jpeg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**开发**菜单中选择**测试**。你现在应该能够查看AppStack以及显示堆栈路径的警告对话框。以下截图显示了iOS模拟器窗口和Android 4平板电脑上的结果对话框：![行动时间
    – 创建数据保存堆栈](img/image00271.jpeg)
- en: '*What just happened?*'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We set up our app to copy the main application stack in the documents area on
    the device, so that we'll be able to make changes and save those successfully.
    If you happen to test on iOS and Android, you will see quite different looking
    paths for the stack. LiveCode takes care of finding these special folders for
    us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了应用程序以复制设备文档区域中的主应用程序堆栈，这样我们就能成功地进行更改并保存它们。如果你在iOS和Android上进行测试，你会看到堆栈的路径看起来相当不同。LiveCode会为我们找到这些特殊文件夹。
- en: Pop quiz – other special places
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 – 其他特殊位置
- en: Check whether you just happen to know this or use this question as an excuse
    to read the release notes and dictionary! Which of these is *not* a `specialFolderPath`
    type?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否偶然知道这个或使用这个问题作为借口去阅读发布说明和字典！以下哪个不是`specialFolderPath`类型？
- en: Users
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户
- en: Home
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主页
- en: Desktop
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桌面
- en: '0x000e'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '0x000e'
- en: 'Answer: 1'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：1
- en: The `specialFolderPath` types `Home` and `Desktop` are not used by Android and
    `Desktop` is not used by iOS. `0x000e` sounds suspicious, but is actually the
    `specialFolderPath` entry for `My Videos` under Unix! None of the systems have
    a `Users` entry.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`specialFolderPath`类型`Home`和`Desktop`在Android中不被使用，而`Desktop`在iOS中也不被使用。`0x000e`听起来可疑，但实际上是Unix下`My
    Videos`的`specialFolderPath`条目！系统中都没有`Users`条目。'
- en: Creating a web "scraper" app
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个网络“抓取”应用程序
- en: As an excuse to try out various native mobile controls, we're going to make
    an app that can read web pages and extract links to different media on the page.
    The app will have a card that shows a web browser, cards to show the links, text,
    media from the web page, and a set of cards to remember the selected items.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试各种原生移动控件，我们将制作一个可以读取网页并提取页面不同媒体链接的应用。该应用将包含一个显示网页浏览器的卡片、显示链接的卡片、网页文本和媒体以及一组用于记住所选项目的卡片。
- en: Time for action – setting up the tab navigation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 设置标签导航
- en: 'Before getting into the process of making the Browser card, we need to set
    up the items that are shared across all the cards in the app. The following steps
    will help you do this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始制作浏览器卡片的过程之前，我们需要设置应用中所有卡片共享的项目。以下步骤将帮助您完成此操作：
- en: We'll use MobGUI again to make life easier. Select **revMobGUI** by navigating
    to the **Development** | **Plugins** submenu. Also, open the **Project Browser**
    from the LiveCode **Tools** menu to observe the stack structure as it develops.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次使用 MobGUI 来简化操作。通过导航到**开发** | **插件**子菜单选择**revMobGUI**。此外，从 LiveCode **工具**菜单打开**项目浏览器**以观察堆栈结构的发展。
- en: Create a new Mainstack, set its name to `WebScraper`, and save it someplace.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Mainstack，将其名称设置为 `WebScraper`，并将其保存到某个位置。
- en: In these instructions, we'll use iPhone in portrait orientation, but feel free
    to use iPad or an Android size for the card. Either select **iOS7** and **320x480**
    in the MobGUI window or your preferred options.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些说明中，我们将使用纵向模式的 iPhone，但您也可以使用 iPad 或 Android 尺寸的卡片。您可以在 MobGUI 窗口中选择 **iOS7**
    和 **320x480**，或者选择您喜欢的选项。
- en: As you did in the *Time for action – using MobGUI to remember layouts for us*
    section in [Chapter 3](part0038.xhtml#aid-147LC1 "Chapter 3. Building User Interfaces"),
    *Building User Interfaces*, use the MobGUI tools to add a **Navbar** and click
    on **Snap to top** of the card window, a **Tab-bar** with **Snap to bottom** of
    the card window, and **Bg colors** for both. Note that a MobGUI card and behavior
    controls are added to the project automatically when MobGUI controls are added
    to the Mainstack.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同在[第 3 章](part0038.xhtml#aid-147LC1 "第 3 章。构建用户界面")中“使用 MobGUI 记忆布局”部分所做的那样，使用
    MobGUI 工具添加一个**导航栏**并点击卡片窗口的**吸附到顶部**，添加一个**标签栏**并点击卡片窗口的**吸附到底部**，以及两者的**背景颜色**。请注意，当将
    MobGUI 控件添加到 Mainstack 时，项目会自动添加 MobGUI 卡片和行为控件。
- en: Drag a LiveCode field control to the NavBar and label it `NavBar`. Format it
    as you like.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 LiveCode 字段控件拖到 NavBar 中并标记为 `NavBar`。按您喜欢的格式进行格式化。
- en: Drag out a **Button** control from the MobGUI palette and duplicate it four
    times. Select all the five buttons and select **Align Objects** from the **Inspector**.
    Align their tops and distribute them across the card. Drag the five buttons to
    the Tab-bar that you just created and adjust their size and position as desired.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 MobGUI 面板拖出一个 **Button** 控件并复制四次。选择所有五个按钮，并在 **Inspector** 中选择 **Align Objects**。将它们的顶部对齐并在卡片上分布它们。将五个按钮拖到您刚刚创建的标签栏上，并根据需要调整它们的大小和位置。
- en: Name the five buttons as `Browser`, `Links`, `Text`, `Media`, and `Keepers`.
    Do this by setting the **Label** entry in the Inspector palette.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将五个按钮命名为 `Browser`、`Links`、`Text`、`Media` 和 `Keepers`。通过在检查器调色板中设置**标签**条目来完成此操作。
- en: 'Edit the script of each button and in the `mouseUp` handler, add the following
    lines to leave the handler looking like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑每个按钮的脚本，并在 `mouseUp` 处理程序中添加以下行，使处理程序看起来如下：
- en: '[PRE11]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From the **Edit** menu, and select **Select All** | **Group Selected** from
    the **Object** menu.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**编辑**菜单中，选择**选择全部** | **对象菜单中的** **分组选择**。
- en: Select the group, and in the **Basic Settings** menu of the regular LiveCode
    Object Inspector, give the group, the name `Common` and check the **Behave like
    a background** button.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该组，在常规 LiveCode 对象检查器的**基本设置**菜单中，给该组命名为 `Common` 并勾选**行为像背景**按钮。
- en: Set the name of the card to `Browser`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将卡片的名称设置为 `Browser`。
- en: Make a new card and name it `Links`. Note that the grouped buttons appear on
    the new card.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的卡片并将其命名为 `Links`。请注意，分组按钮将出现在新卡片上。
- en: Do the same for three more cards that are to be named `Text`, `Media`, and `Keepers`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对另外三个要命名的卡片 `Text`、`Media` 和 `Keepers` 也进行相同的操作。
- en: Go to **Standalone Application Settings**, choose **iOS** or **Android** as
    the platform you want to try, select the appropriate target from the **Development**
    menu, and perform a **Test**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**独立应用程序设置**，选择您想要尝试的平台**iOS**或**Android**，从**开发**菜单中选择适当的目标，并执行**测试**。
- en: Click on or touch the five tab buttons and you should see that the name of the
    `NavBar` field has changed.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击或触摸五个标签按钮，你应该会看到`NavBar`字段的名称已更改。
- en: '*What just happened?*'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: By naming the buttons and cards the same, we were able to go to the five cards
    using the script attached to the group. Also, we used the button script to set
    the name of the NavBar to match the name of the card we had jumped to. The `init`
    line will come on its own as we write the card scripts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将按钮和卡片命名为相同的名称，我们能够通过附加到组的脚本访问五个卡片。我们还使用了按钮脚本，将NavBar的名称设置为与我们跳转到的卡片名称相匹配。`init`行将在我们编写卡片脚本时自动出现。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use the same name with the same type of control on the same card. Your
    script may end up operating on the wrong control.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在同一张卡片上使用相同类型的控件相同的名称。你的脚本可能会最终操作错误的控件。
- en: The Browser card
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器卡片
- en: 'We''ll now add a few controls and scripts to the first card to create the following
    mini web browser:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向第一张卡片添加一些控件和脚本，以创建以下迷你网页浏览器：
- en: '![The Browser card](img/image00272.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器卡片](img/image00272.jpeg)'
- en: 'The native browser control has many properties, actions, and messages associated
    with it. You can view both the **iOS Release Notes** and the **Android Release**
    **Notes** at the following websites:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 原生浏览器控件具有许多与之相关的属性、动作和消息。你可以在以下网站上查看**iOS 发布说明**和**Android 发布说明**：
- en: '[http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-iOS.pdf](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-iOS.pdf)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[LiveCode 5.5.5 版本笔记 - iOS](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-iOS.pdf)'
- en: '[http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-Android.pdf](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-Android.pdf)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[LiveCode 5.5.5 版本笔记 - Android](http://downloads.livecode.com/livecode/5_5_5/LiveCodeNotes-5_5_5-Android.pdf)'
- en: 'Additional updates on support documents can be found at the following :'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 支持文档的额外更新可以在以下找到：
- en: '[http://livecode.com/blog/2013/10/18/6-1-2-brings-ios-7-support/](http://livecode.com/blog/2013/10/18/6-1-2-brings-ios-7-support/)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[LiveCode 博客 - 6.1.2 带来 iOS 7 支持](http://livecode.com/blog/2013/10/18/6-1-2-brings-ios-7-support/)'
- en: For our application though, we only need a few of LiveCode's abilities.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，对于我们这个应用来说，我们只需要LiveCode的少数几个功能。
- en: Time for action – adding the browser controls
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——添加浏览器控件
- en: 'Return to the first card of the stack and find your way to the native controls
    part of the MobGUI window. The following steps will guide you through it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 返回堆栈的第一张卡片，找到MobGUI窗口中本机控件部分。以下步骤将引导你完成：
- en: Drag the **Browser** control on the card window.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**浏览器**控件拖拽到卡片窗口上。
- en: Resize the control to fill the width of the card and resize the control so that
    its height fits between the tab bar and a little way below the NavBar. Give it
    the name `Page`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整控件大小以填充卡片宽度，并调整控件高度，使其介于标签栏和NavBar下方一点的位置。给它命名为`Page`。
- en: With the browser control selected, make sure that the box in the MobGUI window
    titled **Auto delete** is checked. This will help reduce the memory usage of the
    final app during the times you're not on the browser card.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器控件被选中时，确保MobGUI窗口中标题为**自动删除**的框被勾选。这将在你不在浏览器卡片上时帮助减少最终应用的内存使用。
- en: From the MobGUI window, drag an **Input** control into the gap between the browser
    control and the NavBar. Name it `url` and resize it to be nearly as wide as the
    card, leaving space for the **Go** button on the right.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MobGUI窗口中，将一个**输入**控件拖拽到浏览器控件和NavBar之间的空隙中。将其命名为`url`，并调整大小，使其几乎与卡片一样宽，为右边的**Go**按钮留出空间。
- en: Drag a **Button** control into that space, set its label to `Go`, and resize
    it to look nice.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**按钮**控件拖拽到该空间，将其标签设置为`Go`，并调整大小以使其看起来更美观。
- en: 'Edit the script of the **Go** button (which as you may notice, is really a
    group) and add a couple of lines in the mouseUp handler, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**Go**按钮（你可能已经注意到，它实际上是一个组）的脚本，并在mouseUp处理程序中添加几行，如下所示：
- en: '[PRE12]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Later, we will send an `init` message to the cards. For the Browser card, we
    can use this as a way to restore the previously chosen web page. Add the following
    to the Browser card script:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将向卡片发送一个`init`消息。对于浏览器卡片，我们可以使用这种方式来恢复之前选择的网页。在浏览器卡片脚本中添加以下内容：
- en: '[PRE13]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Edit the script of the browser (group `Page`) control. We're going to use the
    `browserFinishedLoading` message to know when to update some variables and URL
    text.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑浏览器（组`Page`）控件的脚本。我们将使用`browserFinishedLoading`消息来知道何时更新一些变量和URL文本。
- en: 'Modify this handler of the browser control''s script, shown as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改浏览器控制脚本中的此处理程序，如下所示：
- en: '[PRE14]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save and perform another **Test** to see the browser card in action.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并执行另一个**测试**以查看浏览器卡片的效果。
- en: '*What just happened?*'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Setting the `pURL` command of the browser control to `mgText` was enough to
    make the browser function, but some of what was just done was in preparation for
    what we'll need in the other cards. In particular, we used the regular LiveCode
    `put url` command to stash a copy of the web page HTML code in a global variable
    and this will be needed when we start extracting links and media from the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器控制的`pURL`命令设置为`mgText`就足以使浏览器正常工作，但刚刚所做的一些操作是为了准备我们在其他卡片中需要的内容。特别是，我们使用了常规的LiveCode
    `put url`命令将网页HTML代码的副本存储在一个全局变量中，当我们开始从页面中提取链接和媒体时，这将是有用的。
- en: The Links card
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接卡片
- en: The Links, Text, and Media cards will take the page source that is stored in
    the `gPageHTML` global variable and extract the bits of interest from it. How
    will they do that?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 链接、文本和媒体卡片将使用存储在`gPageHTML`全局变量中的页面源代码，并从中提取感兴趣的部分。它们将如何做到这一点呢？
- en: A common approach while extracting a known pattern of text is to use regular
    expressions, which are often referred to as `regex` or `regexp`. At it's the simplest
    approach, it's easy to understand, but can get quite complex.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取已知文本模式时，常用的方法是用正则表达式，通常被称为`regex`或`regexp`。在最简单的情况下，它很容易理解，但可能会变得相当复杂。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Read the Wikipedia article if you want to understand about a regular expression
    in depth at:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解正则表达式，请阅读维基百科上的文章：
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
- en: Another useful source of information is this Packt Publishing article on regular
    expressions, which you can find at [http://www.packtpub.com/article/regular-expressions-python-26-text-processing](http://www.packtpub.com/article/regular-expressions-python-26-text-processing).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的信息来源是Packt Publishing关于正则表达式的文章，您可以在[http://www.packtpub.com/article/regular-expressions-python-26-text-processing](http://www.packtpub.com/article/regular-expressions-python-26-text-processing)找到。
- en: One problem though, is that using regexp to parse HTML content is frowned upon.
    There are scores of articles online telling you outright NOT TO parse HTML with
    regexp! Here's one pithy example at
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用正则表达式解析HTML内容是不被推荐的。网上有大量文章明确告诉你不要用正则表达式解析HTML！这里有一个简短示例：
- en: '[http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html](http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html](http://boingboing.net/2011/11/24/why-you-shouldnt-parse-html.html).'
- en: Now, parsing an HTML source is exactly what we want to do here and one solution
    to the problem is to mix and match using LiveCode's other text matching and filtering
    abilities to do most of the work. Although it's not exactly regexp, LiveCode can
    use regular expressions in some of its matching and filtering functions and they
    are somewhat easier to understand than full-blown regexp. So, let's begin by using
    these.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解析HTML源代码正是我们在这里想要做的事情，解决这个问题的方法之一是混合使用LiveCode的其他文本匹配和过滤能力来完成大部分工作。尽管这并不完全是正则表达式，但LiveCode可以在其匹配和过滤函数中使用正则表达式，并且它们比完整的正则表达式更容易理解。所以，让我们从使用这些功能开始。
- en: 'While looking for links, we will make the assumption that the link is inside
    an `a href` tag, but even then, there are a lot of variations of how that can
    appear. The general structure of an `href` tag is like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找链接时，我们将假设链接位于`a href`标签内，但即使如此，它可能以很多不同的方式出现。`href`标签的一般结构如下：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the text of the web page will be the phrase `Link text that the user will
    see`. When this is pointed at by the mouse, the user will see the pointing finger
    cursor, and when it's clicked on, the page will reload using the URL shown in
    the `href` part of the tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页文本中将会出现用户将看到的`链接文本`。当鼠标指向它时，用户将看到指向的手指光标，当点击它时，页面将使用标签`href`部分显示的URL重新加载。
- en: 'The preceding example shows the full path to the support forum; here are the
    ways that the very same web location might be written as in a page link:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示了支持论坛的完整路径；以下是一些将完全相同的网络位置写入页面链接的方式：
- en: '`http://www.runrev.com/support/forum/`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://www.runrev.com/support/forum/`'
- en: '`/support/forum/`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`/support/forum/`'
- en: '`support/forum/`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`support/forum/`'
- en: '`../support/forum/`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`../support/forum/`'
- en: The first link will take you there no matter where you are at that time. The
    second will take you there if you're somewhere else on the [http://runrev.com/](http://runrev.com/)
    site. The third will be correct while you are at the root level of [http://runrev.com/](http://runrev.com/),
    and the last example would work from within one of the other root-level directories
    on the site.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个链接无论你在什么位置点击都会带你到那里。第二个链接如果你在[http://runrev.com/](http://runrev.com/)网站上其他地方点击，则会带你到那里。第三个链接在你位于[http://runrev.com/](http://runrev.com/)网站的根级别时是正确的，最后一个示例将从一个其他根级别目录在网站上工作。
- en: With regex, you might create an extravagant expression that deals with all possible
    variations of how the links are contained in the page source, but even then it
    would not give us the full paths we need.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式，你可能创建一个处理页面源代码中链接所有可能变体的复杂表达式，但即使如此，它也不会给我们需要的完整路径。
- en: By taking things slowly, we can reduce the whole page source to a set of lines
    of "a href" entries, extract the URL part of each line, and finally, take the
    preceding variations and convert them into full path URLs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步处理，我们可以将整个页面源代码减少到一组“a href”条目，提取每行的URL部分，最后，将前面的变体转换为完整的路径URL。
- en: Time for action – making a links extraction function
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建一个链接提取函数
- en: 'Sometimes it''s handy to create tests in a separate stack and then to take
    the function you''ve made into your application stack. The following points will
    help you in making a links extraction function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在单独的堆栈中创建测试然后将其中的函数应用到你的应用程序堆栈中是非常方便的。以下要点将帮助你创建一个链接提取函数：
- en: Create a new **Mainstack** and save it, just to be safe!
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**主堆栈**并保存它，以确保安全！
- en: Add a couple of fields and a button.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加几个字段和一个按钮。
- en: 'Set the button''s script to this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮的脚本设置为以下内容：
- en: '[PRE16]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Edit the stack script and create a function for `getLinks`. Start with returning
    what it has sent:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑堆栈脚本并创建一个`getLinks`函数。从返回它发送的内容开始：
- en: '[PRE17]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you try clicking on the button at this point, you will see that the whole
    page source appears in field 2.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在尝试点击按钮，你会看到整个页面源代码出现在字段2中。
- en: 'We''re going to use the filter function, and it needs the text to be in separate
    lines. So, we want every link to be in a line of its own. The `replace` function
    can do this nicely. Add these two lines to the script (before the "return" line,
    of course!):'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用过滤函数，并且它需要文本以单独的行存在。因此，我们希望每个链接都在一行中。`replace`函数可以很好地做到这一点。在“return”行之前添加这两行脚本：
- en: '[PRE18]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try clicking on the button now. The two fields will look much the same, but
    any lines that have a link in them will certainly be on a line of their own.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试点击按钮。两个字段看起来几乎一样，但任何包含链接的行都将单独一行显示。
- en: 'Add a line to filter the list, as it stands, to reduce it so that it shows
    only the lines with links in them:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行以过滤列表，使其只显示包含链接的行：
- en: '[PRE19]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `*` characters are wildcards that reduces the list so that it only contains
    the lines that have both `a href` and `/a>`. Try the button again.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`字符是通配符，它将列表减少到只包含同时具有`a href`和`/a>`的行。再次尝试按钮。'
- en: 'Now you''ll see that there are only lines with links in them, but they still
    include the junk either side of the link itself. The part we need is between the
    first and second quote marks, and using the `itemdelimiter`, we can get at that
    bit. Add the following lines:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你将看到只有包含链接的行，但它们仍然包含链接本身的两侧的垃圾信息。我们需要的部分是在第一个和第二个引号之间，使用`itemdelimiter`我们可以获取这部分。添加以下行：
- en: '[PRE20]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you now click on the button, you should get a list of only the URL part
    of each line. However note that most of the links start with `/` and not `http`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击按钮，你应该得到一个只包含每行URL部分的列表。然而请注意，大多数链接以`/`开头而不是`http`。
- en: 'Make another function in the stack script that will change the links to full
    path:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆栈脚本中再创建一个函数，用于将链接转换为完整路径：
- en: '[PRE21]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, add the code needed to cope with the variations of URL (to function `getPath`),
    starting with it''s full path:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加处理URL变体的代码（到`getPath`函数），从它的完整路径开始：
- en: '[PRE22]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you recall from earlier, we saved the URL of the main page in a global variable,
    `gPageURL`. For the case where the link is a root relative (it starts with a `/`),
    we want to combine the host location and the link URL:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还记得之前的内容，我们已将主页面的URL保存在一个全局变量中，`gPageURL`。对于链接是根相对路径的情况（它以`/`开头），我们想要组合主机位置和链接URL：
- en: '[PRE23]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When that first character is not `/`, it may start with `../` to step up one
    level in the server structure. Deleting the last part of the page URL will give
    us what we need to combine with the link URL:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一个字符不是`/`时，它可能以`../`开头，以在服务器结构中向上移动一级。删除页面URL的最后部分将给我们需要与链接URL组合的内容：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, if all of these checks fail, we will return an empty string, so that
    this strange structured link URL doesn''t go on to confuse us later:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果所有这些检查都失败了，我们将返回一个空字符串，这样这个奇怪的链接URL结构就不会在以后混淆我们：
- en: '[PRE25]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get the `getLinks` function to use the `getPath` function, we need to make
    a change to the script shown in step 9:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`getLinks`函数使用`getPath`函数，我们需要对步骤9中显示的脚本进行更改：
- en: '[PRE26]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*What just happened?*'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In stages, we developed a function that can find the links in a web page's source
    text ending with a set of full path URLs that we can present to the user.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分阶段开发了一个函数，该函数可以在网页源文本中找到以一组完整路径URL结尾的链接，我们可以将这些链接呈现给用户。
- en: The missing links
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失的链接
- en: The one missing piece in the test stack is the global variable that stores the
    page URL. In the case of the app stack, the value is provided by the browser control's
    `browserFinishedLoading` function, but here, we need to plug in a value for testing
    purposes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 测试堆栈中缺失的一块是存储页面URL的全局变量。在应用堆栈的情况下，该值由浏览器控制的`browserFinishedLoading`函数提供，但在这里，我们需要为测试目的插入一个值。
- en: 'Place a global declaration line in the button''s script and the stack script.
    In the button script, fill in the variable with our test case value. The script
    will then be like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮脚本和堆栈脚本中放置一个全局声明行。在按钮脚本中，用我们的测试用例值填写变量。脚本将如下所示：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Try the button now, you should see a list of full path URLs in your second field.
    If it works correctly, copy the two stack functions and the global declaration
    line and paste them into the stack script of the WebScraper stack.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试按钮，你应该能在第二个字段中看到完整的路径URL列表。如果它工作正常，复制两个堆栈函数和全局声明行，并将它们粘贴到WebScraper堆栈的堆栈脚本中。
- en: One more thing…
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有一件事…
- en: The tab bar script includes an init line. This will call the card script; in
    this case, the Links card script, but it doesn't exist yet! Let's make it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡栏脚本包括一个初始化行。这将调用卡片脚本；在这种情况下，是链接卡片脚本，但它目前还不存在！让我们来创建它。
- en: Time for action – adding the links card's init handler
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加链接卡片初始化处理程序了
- en: 'Before proceeding, make sure that you are happy with the functions in the test
    stack and that you have copied them to the WebScraper stack script using the following
    steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你对测试堆栈中的函数感到满意，并且已经使用以下步骤将它们复制到WebScraper堆栈脚本中：
- en: Go to the Links card of the WebScraper stack.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往WebScraper堆栈的链接卡片。
- en: 'Edit the card script and add these global variables and `init` function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑卡片脚本并添加这些全局变量和`init`函数：
- en: '[PRE28]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do a Test of the app.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应用进行测试。
- en: In the iPhone Simulator or Android device, if that's what you're using, change
    the URL to [http://www.runrev.com/](http://www.runrev.com/) and select the **Go**
    button.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iPhone模拟器或Android设备上（如果你使用的是这些设备），将URL更改为[http://www.runrev.com/](http://www.runrev.com/)并选择**前往**按钮。
- en: When the page is loaded, select the **Links** tab button.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，选择**链接**选项卡按钮。
- en: You should now be looking at the list of links from the RunRev page; only this
    time, it's presented in a native picker list.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能看到来自RunRev页面的链接列表；但这次，它是以原生选择器列表的形式呈现的。
- en: Select a link from the list and then **Done**.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个链接，然后**完成**。
- en: You will be taken back to the Browser card with the linked page loaded.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被带回到带有加载的链接页面的浏览器卡片。
- en: '*What just happened?*'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'The card script we entered does the same job as the button in the test stack;
    in that, it calls to the stack functions to get a list of links. Here, rather
    than putting the list into a plain field, we used LiveCode''s ability to open
    a native picker control using the line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的卡片脚本与测试堆栈中的按钮执行相同的任务；在那里，它调用堆栈函数以获取链接列表。在这里，我们不是将列表放入普通字段中，而是使用了LiveCode的能力，通过以下行打开原生选择器控件：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The required parameters of this function are a list of items to be shown and
    an index position to be the one that is selected. By entering `1`, the first item
    is selected by default. The result that comes back from the picker is an index
    of the item that was selected, and we can use this to look up the matching line
    in the `gLinks` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数所需的参数是要显示的项目列表和一个索引位置，该位置将被选中。通过输入`1`，默认选中第一个项目。从选择器返回的结果是选中项目的索引，我们可以使用这个索引在`gLinks`变量中查找匹配的行。
- en: The remaining lines take us back to the Browser card, set the URL to be loaded,
    and also change the NavBar to reflect the card name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行将带我们回到浏览器卡片，设置要加载的URL，并更改NavBar以反映卡片名称。
- en: The Text card
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本卡片
- en: 'Making the Text card work is a lot simpler, but includes an unbelievably complex
    regular expression line, which can be found at:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使文本卡片工作要简单得多，但包括一条难以置信的复杂正则表达式行，该行可以在以下位置找到：
- en: '[http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents](http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents](http://stackoverflow.com/questions/3951485/regex-extracting-readable-non-code-text-and-urls-from-html-documents)'
- en: Time for action – setting up the Text card
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 设置文本卡片
- en: We will start off in the test stack that you made, so that we can get the function
    working there before adding it to the WebScraper stack.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从您制作的测试堆栈开始，这样我们就可以在将其添加到WebScraper堆栈之前在那里使函数工作。
- en: Duplicate the button you made when extracting links. Change the function call
    `getLinks` to `getText`; the rest of the script can remain the same.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你在提取链接时制作的按钮。将函数调用`getLinks`更改为`getText`；其余的脚本可以保持不变。
- en: 'Edit the script of the test stack and add this function:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑测试堆栈的脚本并添加此函数：
- en: '[PRE30]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Try clicking on the button you just made. You should see your second field filled
    with just the text parts of the web page.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击您刚刚制作的按钮。你应该看到您的第二个字段只填充了网页的文本部分。
- en: Copy the function and go back to the WebScraper stack script. Paste the function
    there.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制函数并回到WebScraper堆栈脚本。将函数粘贴到那里。
- en: Go to the Text card of the stack and from the MobGUI window, drag the **Multiline
    Text** control onto the card. Set its name to `PageText`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往堆栈的文本卡片，并从MobGUI窗口中，将**多行文本**控件拖到卡片上。将其名称设置为`PageText`。
- en: Resize the control to fill the area between the NavBar and the Tab-bar. You
    may have to use the LiveCode Inspector to modify the size if the text does not
    fill the field.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整控件大小以填充NavBar和Tab-bar之间的区域。如果文本无法填满字段，您可能需要使用LiveCode检查器来修改大小。
- en: In the MobGUI window properties for the control, uncheck the box for **Editable**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的MobGUI窗口属性中，取消勾选**可编辑**复选框。
- en: 'Edit the card script and add this `init` function:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑卡片脚本并添加此`init`函数：
- en: '[PRE31]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Try a **Test** of the app.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试对应用进行**测试**。
- en: In the **Browser** card, change the URL from [http://google.com/](http://google.com/)
    to [http://runrev.com/](http://runrev.com/) and click on **Go**.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**浏览器**卡片中，将URL从[http://google.com/](http://google.com/)更改为[http://runrev.com/](http://runrev.com/)并点击**前往**。
- en: Press the **Text** tab button at the bottom.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**文本**标签按钮。
- en: You should now be on the **Text** card and should be able to see the text elements
    from the web page displayed in a native scrolling text field.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该处于**文本**卡片上，并且应该能够看到在原生滚动文本字段中显示的网页文本元素。
- en: '*What just happened?*'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: This enormously long regular expression ran through the web page source and
    removed anything that was script, style, or just tag information, leaving the
    text parts alone. However, it would leave it with lots of spare line feed characters
    and tab characters, which we went on to remove using the LiveCode `replace` function.
    The final text may not be perfect, but you can use the standard mobile text features
    to copy parts of the text for use in other apps.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常长的正则表达式在网页源代码中运行，移除了任何脚本、样式或仅仅是标签信息，而文本部分则保持不变。然而，它会在文本中留下很多多余的换行符和制表符，我们继续使用LiveCode的`replace`函数来移除它们。最终文本可能并不完美，但您可以使用标准的移动文本功能来复制文本的部分以在其他应用中使用。
- en: The Media card
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体卡片
- en: The Media card is going to start off very much like the Links card, with an
    `init` function in the card script and a stack script function to extract the
    media links from the page.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体卡片将非常类似于链接卡片，卡片脚本中有一个`init`函数和一个堆栈脚本函数用于从页面中提取媒体链接。
- en: Time for action – extracting a list of media links
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 提取媒体链接列表
- en: 'There probably is a regular expression that would extract all the `src` links
    from a page, but we''re only interested in things that we know LiveCode is able
    to show or play. So in these steps, we''ll use a more devious way to extract just
    the links we can handle:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个正则表达式可以提取页面上的所有`src`链接，但我们只对我们知道LiveCode能够显示或播放的内容感兴趣。因此，在这些步骤中，我们将使用更狡猾的方法来提取我们能够处理的链接：
- en: You may as well head over to the test stack!
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不妨去测试堆栈看看！
- en: Make a third button by duplicating one of the other two and change the `getLinks`
    or `getText` part in the button script to call `getMedia` instead.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制其他两个中的一个来创建第三个按钮，并在按钮脚本中将`getLinks`或`getText`部分更改为调用`getMedia`。
- en: 'In the stack script, enter all of this:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆栈脚本中输入所有这些：
- en: '[PRE32]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Click on the button and you should see a list of full paths to the various images
    in the web page.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，你应该会看到网页中各种图片的完整路径列表。
- en: '*What just happened?*'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This devious approach involved the task of finding any place where the media
    of interest is mentioned and adding an asterisk and return character in order
    to make sure that the link was easily identified and at the end of a unique line.
    Then, each of these lines were sent to another function, `removeLeaders`, to remove
    any other text that was earlier in the line than at the start of the link. Finally,
    the same `getPath` function we used while extracting links was used to give us
    full paths to the media files.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种狡猾的方法涉及找到感兴趣媒体被提及的任何地方，并添加一个星号和回车符，以确保链接容易被识别，并且位于独一无二的行尾。然后，将这些行中的每一行都发送到另一个函数`removeLeaders`，以移除链接开始之前该行中的任何其他文本。最后，我们使用了在提取链接时使用的相同的`getPath`函数，以提供媒体文件的完整路径。
- en: Now that we have a list of media links, we need to add the card level handlers
    required to present the list to the user and to load their selected media item
    onto the card window.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了媒体链接的列表，我们需要添加卡片级别的处理程序，以向用户展示列表并将他们选择的媒体项目加载到卡片窗口中。
- en: Time for action – setting up the Media card scripts
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 设置媒体卡片脚本
- en: 'Copy the functions that you have proved to work, in the test stack script and
    paste them into the WebScraper stack script. Then, perform these steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将你在测试堆栈脚本中证明可以工作的函数复制，粘贴到WebScraper堆栈脚本中。然后执行以下步骤：
- en: Go to the Media card. As with the Links card, we're not going to add any controls
    to the card, as we'll do that with the script. So, edit the card script.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**媒体**卡片。与**链接**卡片一样，我们不会向卡片添加任何控件，因为我们将通过脚本完成。所以，编辑卡片脚本。
- en: 'Here''s the Media card''s `init` function and the needed global variables:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是媒体卡片的`init`函数和所需的全局变量：
- en: '[PRE33]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Unlike the Links case, we've built up a list of just the filename part of the
    URL, to be seen in a native picker, and when we've selected something we will
    call a `showMedia` function in the stack script.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与链接的情况不同，我们建立了一个仅包含URL文件名部分的列表，将在本地选择器中显示，并且当我们选择某项内容时，将在堆栈脚本中调用`showMedia`函数。
- en: Edit the stack script.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑堆栈脚本。
- en: 'Create the `showMedia` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`showMedia`函数：
- en: '[PRE34]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Test the app.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用。
- en: You can start with the google.com page; click on the **Media** tab button to
    see a list of the images used on that page.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从google.com页面开始；点击**媒体**标签按钮查看该页面上使用的所有图片列表。
- en: Select an image from the list and click on **Done**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个图片并点击**完成**。
- en: The image should appear on the card.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片应该出现在卡片上。
- en: Go back to the **Browser** card and change the URL to `http://www.apple.com/`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**浏览器**卡片并将URL更改为`http://www.apple.com/`。
- en: Apple usually includes some video link thumbnails on the main page. click on
    one of those, so that you see the large video player. However, don't play it!
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 苹果通常在主页上包含一些视频链接缩略图。点击其中一个，以便看到大型的视频播放器。然而，不要播放它！
- en: Click on the **Media** tab button to see a list of all the media on that page.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**媒体**标签按钮查看该页面上所有媒体的列表。
- en: Scroll down the list and look for one of the longer-named items that seems like
    it must be a video.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动列表并寻找一个名字较长的项目，看起来它肯定是一个视频。
- en: Select that item and press **Done**. The video should load and play on the card.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该项并按**完成**。视频应该在卡片上加载并播放。
- en: Use the video controller's **Done** button when you are finished watching the
    video to return to the **Media** card.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在观看完视频后，使用视频控制器的**完成**按钮返回到**媒体**卡片。
- en: You can then click on the **Media** tab button again to make the picker reappear.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以再次点击**媒体**标签按钮，使选择器重新出现。
- en: Go back to the **Browser** card and enter a URL that contains examples of MP3
    files. `http://www.ntonyx.com/mp3_songs.htm` is one such example.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**浏览器**卡片，并输入包含MP3文件示例的URL。`http://www.ntonyx.com/mp3_songs.htm`就是这样一个例子。
- en: Click on the **Media** tab button to return to the **Media** card with the list
    of all the media on that page, which in this case will be mainly MP3 files.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**媒体**标签按钮返回到包含该页面上所有媒体列表的**媒体**卡片，在这种情况下，主要是MP3文件。
- en: Select one of the MP3s from the list and click on **Done**. The MP3 should play
    in the same player that the video is played in.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择一个 MP3 文件，然后点击 **完成**。MP3 应该在播放视频的相同播放器中播放。
- en: '*What just happened?*'
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In this example, we made use of both a standard LiveCode control, the image,
    and also a native control, the video player. LiveCode handles the setting up of
    the player and with the very simple "play video videoname" syntax, we were able
    to invoke the native player. It was able to play both video and audio files.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了标准 LiveCode 控件，图像，以及原生控件，视频播放器。LiveCode 处理播放器的设置，并且使用非常简单的 "play
    video videoname" 语法，我们能够调用原生播放器。它能够播放视频和音频文件。
- en: The Keepers card
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Keepers 卡
- en: Actually, this should be the Keepers *cards*. These cards are where you can
    stash media that you've found interesting. For file size reasons, we're actually
    just going to store the URL to the media; after all, a long video would soon use
    up your device's storage!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这应该是 Keepers **卡片**。这些卡片是你可以存放找到的有趣媒体的地方。由于文件大小原因，我们实际上只是存储媒体的 URL；毕竟，一个长的视频很快就会耗尽你的设备存储空间！
- en: Time for action – setting up the Keepers card
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 设置 Keepers 卡
- en: Go to the **Keepers** card and create a MobGUI button for **Prev**, **Next**,
    and **Play Media**. Make a MobGUI **Multiline** field and name it `mediaURL`.
    Be sure to uncheck the **Auto delete** option, so that it keeps the URL data when
    we change cards. Also uncheck the **Editable** option. You should now have something
    looking like the following screenshot:![Time for action – setting up the Keepers
    card](img/image00273.jpeg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Keepers** 卡并创建一个用于 **Prev**、**Next** 和 **Play Media** 的 MobGUI 按钮。创建一个
    MobGUI **多行** 字段并命名为 `mediaURL`。确保取消选中 **自动删除** 选项，以便在更改卡片时保留 URL 数据。还要取消选中 **可编辑**
    选项。你现在应该有一个类似于以下截图的内容：![行动时间 – 设置 Keepers 卡](img/image00273.jpeg)
- en: 'Add these lines to the `mouseUp` handler of the **Prev** button:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到 **Prev** 按钮的 `mouseUp` 处理程序中：
- en: '[PRE35]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add these lines to the `mouseUp` handler of the **Next** button. Note that
    `- 1` is used since the last card is the MobGUI card:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到 **Next** 按钮的 `mouseUp` 处理程序中。注意，使用 `- 1` 是因为最后一张卡片是 MobGUI 卡：
- en: '[PRE36]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add this line to the Play Media button''s `mouseUp` handler:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此行添加到 Play Media 按钮的 `mouseUp` 处理程序中：
- en: '[PRE37]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Select the four controls and Group them. Check the box that says **Behave like
    a background**. Name the group `keeperbuttons`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择四个控件并将它们分组。勾选表示 **像背景一样行为** 的复选框。将组命名为 `keeperbuttons`。
- en: 'Edit the script of the new group. Add this `refresh` handler:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑新组的脚本。添加此 `refresh` 处理程序：
- en: '[PRE38]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to go back and add things to the **Media** card.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要回到并添加内容到 **Media** 卡。
- en: Go to the **Media** card and add a MobGUI button. Set the name and label to
    `Keep Media`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Media** 卡并添加一个 MobGUI 按钮。设置名称和标签为 `Keep Media`。
- en: One tricky thing is that media will play full screen on smaller screens and
    by the time you see the **Keep Media** button, the video has already gone away.
    We can work around this by storing the URL of the last shown media in a global
    variable.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个棘手的问题是，媒体将在小屏幕上全屏播放，并且在你看到 **Keep Media** 按钮的时候，视频已经消失了。我们可以通过在全局变量中存储最后显示的媒体的
    URL 来解决这个问题。
- en: 'In the **Media** card script, change the `init` function, so that the later
    lines read like this:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Media** 卡脚本中，更改 `init` 函数，以便后续行如下所示：
- en: '[PRE39]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Change the global variable declaration line to include the `gLastMedia` variable.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将全局变量声明行修改为包含 `gLastMedia` 变量。
- en: 'Set the `mouseUp` handler of the **Keep Media** button to be this:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Keep Media** 按钮的 `mouseUp` 处理程序设置为以下内容：
- en: '[PRE40]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, only one last step is required for the stack to save the media. We need
    to create a launcher app like we did earlier in this chapter. Create a stack named
    `LaunchScraper` with the following stack script:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，堆栈保存媒体只需要最后一步。我们需要创建一个类似于本章前面所做的那样启动应用程序。创建一个名为 `LaunchScraper` 的堆栈，其堆栈脚本如下：
- en: '[PRE41]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Make sure that the Launch Scraper and Web Scraper apps are in the same folder.
    Open only the Launch Scraper app and make sure that the Web Scraper app is included
    in the **Copy files** of the **Standalone Application Settings**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Launch Scraper 和 Web Scraper 应用程序位于同一文件夹中。只打开 Launch Scraper 应用程序，并确保 Web
    Scraper 应用程序包含在 **独立应用程序设置** 的 **复制文件** 中。
- en: Select your **Test** **Target** device and then **Test**. Note that the last
    answer statement will display the path and the filename where the main app is
    stored on your device. This can be commented out once you are comfortable that
    it is working.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的 **测试目标** 设备，然后 **测试**。注意，最后一个答案语句将显示主应用存储在你设备上的路径和文件名。一旦你确信它正在正常工作，可以将其注释掉。
- en: Use the **Browser** card to load a page with plenty of images, videos, or sounds
    on it and go to the **Media** card to see those listed.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**浏览器**卡片加载一个包含大量图片、视频或声音的页面，然后转到**媒体**卡片查看这些列表。
- en: Select any item followed by a click on **Done**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何项目，然后点击**完成**。
- en: If you like the image, sound, or video, use the **Keep Media** button to go
    to the end of the stack to save the media's URL.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你喜欢图片、声音或视频，使用**保留媒体**按钮将媒体推到堆栈的底部以保存媒体URL。
- en: Choose more bits of media and keep them.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择更多媒体片段并保留它们。
- en: Go to the **Keepers** section and use the **Next** and **Prev** buttons to browse
    through the items you've kept.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**保留者**部分，并使用**下一页**和**上一页**按钮浏览你保留的项目。
- en: The images should appear automatically and the video and audio can be started
    with the **Play Media** button.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片应自动显示，视频和音频可以通过**播放媒体**按钮开始播放。
- en: '*What just happened?*'
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We added the last feature of our application, a set of cards where we can go
    to view the bits of media that we've chosen to keep.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了我们应用程序的最后一个功能，一组卡片，我们可以通过它们查看我们选择保留的媒体片段。
- en: Have a go hero – add some preset locations
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的操作——添加一些预设位置
- en: If you do make the Web Scraper app and start to find it useful, it's quite likely
    that there will be a set of web pages that you'd like to go back to again and
    again. To type the URL every time would be tedious. So, why not make a hidden
    field on the **Browser** card and type in a list of your favorite pages. Add a
    button to the card too, which will bring up a list of those pages for you to choose
    from. The one you choose can then load the **Browser** control at the desired
    page. All of the steps to do this were covered in the *The Links card* section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的制作了Web Scraper应用并开始觉得它有用，很可能会有一些网页你希望反复访问。每次都输入URL会很麻烦。所以，为什么不在**浏览器**卡片上创建一个隐藏字段并输入你喜欢的网页列表。在卡片上添加一个按钮，这样你就可以选择这些页面。你选择的页面可以加载到所需的**浏览器**控件。所有完成这些步骤的步骤都在*链接卡片*部分中进行了介绍。
- en: It's pretty certain that if you've carefully followed all the steps in this
    chapter and indeed all the steps were perfect, you still wouldn't have an app
    ready to be submitted to the app stores! You would require a splash screen, a
    main menu, icons on the tab buttons as well and some love from a graphic designer!
    Feature wise, it would be nice if the images you keep could be zoomed and panned.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，如果你仔细遵循了本章的所有步骤，并且确实所有步骤都完美无缺，你仍然不会有一个可以提交到应用商店的应用程序！你需要一个启动画面、主菜单、标签按钮上的图标，以及图形设计师的一些创意！从功能上讲，如果保留的图片可以缩放和平移会很好。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Some of the topics that we covered here are less glamorous, mostly the ones
    about processing HTML text, but we did also use a few mobile features. We demonstrated
    how a native app can store data for subsequent usage, and how to make and control
    a web browser. The use of a native picker to present lists was covered. We also
    created a native scrolling field that had all the normal OS-specific abilities
    and played video and audio using the native media players.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们讨论的一些主题可能不那么引人注目，主要是关于处理HTML文本的，但我们也使用了一些移动功能。我们展示了原生应用如何存储数据以供后续使用，以及如何创建和控制网页浏览器。我们还涵盖了使用原生选择器来展示列表的方法。我们还创建了一个具有所有正常操作系统特定功能的原生滚动字段，并使用原生媒体播放器播放视频和音频。
- en: The next chapter is almost entirely about dealing with graphics, so we'll make
    sure to use some image manipulating gestures and you could revisit the Web Scraper
    app later to add the same features to the Keepers cards.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章几乎完全关于处理图形，所以我们会确保使用一些图像处理手势，并且你可以稍后重新访问Web Scraper应用，为Keepers卡片添加相同的特性。
