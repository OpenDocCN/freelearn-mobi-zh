<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. SceneKit and 3D Game Design</h1></div></div></div><p class="calibre8">For this chapter, we will be going over the iOS framework used for 3D game development known as <a id="id207" class="calibre1"/>SceneKit. SceneKit first became available in iOS 7 but originally was just used for MacOS development. Previously, developers had to code 3D games using OpenGL or third-party frameworks and engines, such as Cocos3D, Unreal Engine, Havok, and Unity. As the graphical power in the iOS family of devices improved, so did the need for an immersive, hands-on first-party 3D game design engine. SceneKit shortly became available for iOS giving developers an Xcode built-in solution to make 3D games.</p><p class="calibre8">In the previous chapter, we approached iOS game development in a more code-based methodology. We'll still be working in some code, but since the introduction of Xcode 5 and Xcode 6, Apple has provided some great demos that show how the IDE can be just as visually dynamic of a game engine as multiplatform game engines are. The benefit of using Xcode and the SpriteKit/SceneKit frameworks over those engines is that you have a dedicated design environment for a specific platform. In our case, that platform is iOS and the Apple family of devices. As iOS frequently updates and continues to give new features, Xcode and these frameworks will update with it. Updates to the multiplatform engines usually occur at a later date with sometimes the additional need to install plugins to ensure that your app runs smoothly in future updates.</p><p class="calibre8">In addition to the very dynamic and tool-rich DemoBots SpriteKit demo, the <em class="calibre10">June 2015 World Wide Developer's Conference</em> also introduced a wonderful SceneKit demo named Fox. The Fox demo also makes use of features introduced in iOS 9 that we can use for either SpriteKit or SceneKit, such as reusable actions, components, and state machines.</p><p class="calibre8">In this chapter, we will go over the basics of SceneKit and we will make a simple SceneKit scene (known as <code class="email">SCNScene</code>) using both code and the visual design tools Xcode provides. We will then add physics, lights, and particles to our SceneKit objects and scene. We will then wrap up with a look into the <em class="calibre10">WWDC15</em> Fox Demo and some of the features/APIs it uses, which became available in iOS 8 and iOS 9.</p><div><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre8">In the previous chapter, we left out much of these asset creation features in our discussion on SpriteKit. With SpriteKit scene files, (<code class="email">.sks</code>), we can also create game assets, such as lights, physics fields, bounding boxes/physics constraints, normal maps, textures, entire levels, and characters in the same fashion that SceneKit scene files (<code class="email">.scn</code>) work. We will at times show the SpriteKit method to similar features.</p><p class="calibre8">Since SpriteKit and <a id="id208" class="calibre1"/>SceneKit scene assets work similarly and can be together in the same scene (thanks to their inherit node/tree functionality), we thought that it was best to save the visual and asset tool discussion for this chapter. The previous chapter's talk on the game/render loop and much of the scene code functionality will work in SceneKit much like it did previously in SpriteKit.</p><p class="calibre8">So in other words, we are already set up to dive right into SceneKit.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec33" class="calibre1"/>SceneKit basics and working with nodes</h1></div></div></div><p class="calibre8">Like <a id="id209" class="calibre1"/>SpriteKit, SceneKit is based on the concept of nodes. SpriteKit <a id="id210" class="calibre1"/>objects are children of the <code class="email">SKNode</code> class, while SceneKit objects are children of the <code class="email">SCNNode</code> class.</p><div><img src="img/00034.jpeg" alt="SceneKit basics and working with nodes" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding image is the SceneGraph hierarchy from Apple's SceneKit introduction. As we see, SceneKit has various nodes that branch off from the <code class="email">SCNScene</code> class. These include the generic <code class="email">SCNNode</code> for lights, geometry, and the camera.</p><p class="calibre8">Nodes are a tree data structure that can have other nodes added to them and have information of other nodes in the structure. As seen in the preceding graph, it's shown with the <code class="email">childNode[]</code> array and parent properties. Spatial information, such as position, scale, and orientation, can be received from these properties. This is what makes nodes unique to other parent-child structuring in object-oriented design (OOD).</p><p class="calibre8">In SpriteKit, we'd typically add a node to our scene or to another node within our scene via the <code class="email">addChild()</code> function. In SceneKit, the same functionality is done with <code class="email">addChildNode()</code>. For example, the main root node in a SceneKit scene is the <code class="email">SCNScene</code> node that is placed in the <code class="email">SCNView</code> node, that is, the framework's unique version of the <code class="email">UIView</code> class. To add a basic sphere object to our scene, we'd do the following:</p><div><pre class="programlisting">let sphereGeometry = SCNSphere(radius: 1.0)
let sphereNode = SCNNode(geometry: sphereGeometry)
self.rootNode.addChildNode(sphereNode)</pre></div><p class="calibre8">As stated with <a id="id211" class="calibre1"/>SpriteKit, working with nodes in SpriteKit can allow <a id="id212" class="calibre1"/>us to group various members of our game scene together into their own parent nodes and make actions on them in one call also iterating through for loops or other iteration calls.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>SpriteKit / SceneKit interactivity</h1></div></div></div><p class="calibre8">One great <a id="id213" class="calibre1"/>feature of SceneKit is that we can have a <a id="id214" class="calibre1"/>SpriteKit scene overlay our 3D game.</p><div><pre class="programlisting">self.overlaySKScene = skScene</pre></div><p class="calibre8">Using the <code class="email">SCNView</code> property <code class="email">overlaySKcene</code>, we can take an already established <code class="email">SKScene</code> node (which can be a character, an animation sequence, an HUD, and more) and have them in our 3D scene. </p><p class="calibre8">Want to have a cute sprite animation overlay your 3D character's stage win or maybe want to make a 2.5D game with 2D sprites and physics overlaying a 3D background? Then this is how you can do it.</p><div><img src="img/00035.jpeg" alt="SpriteKit / SceneKit interactivity" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The most common functionality of mixing SpriteKit with SceneKit is that SpriteKit is the HUD for the SceneKit scene. The lives, collectables, and character icon seen in the earlier Fox demo shows a SpriteKit node overlaying a SceneKit scene.</p><p class="calibre8">Nodes in general can <a id="id215" class="calibre1"/>help add a functional structure <a id="id216" class="calibre1"/>to your game and game scenes. A high reliance on nodes and inheritance in game design doesn't come without its flaws though.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec43" class="calibre1"/>The issue with inheritance-based structuring and game design</h2></div></div></div><p class="calibre8">Before going <a id="id217" class="calibre1"/>forward, we should mention about a certain pitfall that could plague a game that relies too much on the concept of nodes and even the general concept of inheritance-based structuring in OOD. When possible, it's best not to rely too much on inheritance for your game logic and work more with what's known as composite-based structuring. We'll go deeper into this in our next chapter when we talk about the helper game development framework first introduced in iOS 9, GamePlayKit, but here's a glance so that we know that working with inheritance and even nodes might not always be the best solution in our games.</p><div><img src="img/00036.jpeg" alt="The issue with inheritance-based structuring and game design" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">At first glance, one might think that inheritance-based structuring is perfectly made for game development. Many of us familiar with OOD know that we can have generic parent classes or nodes of our game objects, such as an all-encompassing <code class="email">GameObject</code> class, and then use inheritance and polymorphism to work with unique child classes from this base class. For small, simplistic games that will hold true, but games tend to have objects that could share some of the same functionality, but make no sense to have in a parent-child structure.</p><p class="calibre8">Take this typical structuring in a tower-based strategy game:</p><div><img src="img/00037.jpeg" alt="The issue with inheritance-based structuring and game design" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In a typical tower game, we'd have our base, tower, and enemy objects that can all inherit from a generic <code class="email">GameObject</code> class we define. Towers can fire at enemies but so can enemies back at the towers and other player-based objects. Part of good programming and design is to have reusable code and methods. Normally, we'd do this with inheritance. The preceding graph shows two-way inheritance that can solve this. We would then want a <code class="email">ShootingEnemy</code> class that inherits the movement and shooting functionality. We can't do this, as that would involve inheriting from two separate and rather unrelated classes of objects. In OOD, there's only one child-parent relationship. The next solution shown on the right would be to have the generic <code class="email">GameObject</code> class have this functionality. The <a id="id218" class="calibre1"/>issue that arises is that our once simple <code class="email">GameObject</code> parent class becomes all but simple and we inevitably want to add additional features and functionalities to objects in our game. In the past, this would involve refactoring tons of code to accommodate what essentially are simple design add-ons. Protocols used to be somewhat of a solution to this as they'd force us to make a class in a certain way, but even they could get confusing and don't involve the implementation of these features. </p><p class="calibre8">The solution would be to work with entities and components.</p><div><img src="img/00038.jpeg" alt="The issue with inheritance-based structuring and game design" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This preceding diagram gives an example of composite-based structuring. With this methodology, we can have components that share similar functionality, being used by multiple and usually unrelated game objects. This way, the generic <code class="email">GameObject</code> class in this example doesn't have to have every possible function of its child class and we can keep <code class="email">Enemy</code> classes as being members of <code class="email">Enemy</code>. The shared functionality can be written once and then used throughout the game and even in the other games we wish to make. iOS 9's SpriteKit demo, DemoBots, and the SceneKit demo mentioned earlier, Fox, both use composite-based structuring for actions and animations.</p><p class="calibre8">It's important when <a id="id219" class="calibre1"/>thinking with nodes in both SpriteKit and SceneKit that they are used in the context of the View of the MVC model, or in both frameworks, the context of their scenes.</p><p class="calibre8">As for scenes in SceneKit, let's move on to making a very basic one.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Our first SceneKit scene – the Xcode template</h1></div></div></div><p class="calibre8">3D art and <a id="id220" class="calibre1"/>animation is a very in-depth topic. We could go on <em class="calibre10">ad nauseam</em> about <a id="id221" class="calibre1"/>materials, shaders, lighting, sculpting, PVR textures, and all of the topics of what makes great 3D objects for games, movies, architecture, or any other 3D object-based application. </p><p class="calibre8">Some of the details of these topics are beyond the scope of this book, so for now, let's keep things simple.</p><div><img src="img/00039.jpeg" alt="Our first SceneKit scene – the Xcode template" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Let's work with the default SceneKit scene and objects that Xcode gives us as a start, as shown in the preceding image:</p><div><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre8">As of the time of writing this book, we used the SceneKit template for Xcode 7 – Beta. Based on the version you use, there might be some differences.</p></div><div><ol class="orderedlist"><li class="listitem" value="1">First, open <a id="id222" class="calibre1"/>Xcode, create a new project, and select the <strong class="calibre9">Game</strong> template.<div><img src="img/00040.jpeg" alt="Our first SceneKit scene – the Xcode template" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">Next, name your project, make sure that the <strong class="calibre9">Game Technology</strong> field says <strong class="calibre9">SceneKit</strong>, and click on <strong class="calibre9">Next</strong>.<div><img src="img/00041.jpeg" alt="Our first SceneKit scene – the Xcode template" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">The project files and structure are about the same as we saw with SpriteKit but with a couple of differences, particularly the <code class="email">art.scnassets</code> folder. The only difference is that there is now an <code class="email">art.scnassets</code> folder in addition to <code class="email">Assests.xcassets</code>. This is where our 3D objects are held. Click on that folder to see the <code class="email">ship.dae</code> asset that Apple provides.<div><img src="img/00042.jpeg" alt="Our first SceneKit scene – the Xcode template" class="calibre11"/></div><p class="calibre16"> </p></li></ol><div></div><p class="calibre8">With the SceneKit editor, we can view and edit the following 3D file types:</p><div><ul class="itemizedlist"><li class="listitem">DAE</li><li class="listitem">OBJ</li><li class="listitem">Alembic</li><li class="listitem">STL</li><li class="listitem">PLY</li></ul></div><p class="calibre8">The example given to <a id="id223" class="calibre1"/>us is a spaceship of the type DAE and with the <code class="email">ship.dae</code> file as the ship's texture file (<code class="email">texture.png</code>). Before we look into the code and how the scene works, build and run the program on either your own device or the Xcode device simulator.</p><p class="calibre8">From the sample scene, we see our spaceship rotating in front of a black background and we can change its orientation when we swipe the ship. Tapping on the ship causes it to glow red for a moment.</p><p class="calibre8">Let's now see what's going on with the code and then we'll get into the tools the editor gives us to edit our objects and scenes without any code.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec44" class="calibre1"/>SceneKit project flow and structure</h2></div></div></div><p class="calibre8">Like <a id="id224" class="calibre1"/>SpriteKit, a SceneKit scene uses the same game-rendering <a id="id225" class="calibre1"/>loop as we saw from the previous chapter and the same type of entry point structuring we mentioned in <em class="calibre10">Chapter 2</em>, <em class="calibre10">Structuring and Planning a Game Using iOS 9 Storyboards and Segues</em>. We have the <code class="email">AppDelegate.swift</code> file that is our entry point with the ability to control special app functionality based on upper level device events, such as the app closing, going into the background, and coming back from being in the background. We also have the launch screen and <code class="email">Main.storyboard</code> files as seen before in SpriteKit.</p><div><img src="img/00043.jpeg" alt="SceneKit project flow and structure" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The difference with the <code class="email">Main.storyboard</code> file is that it has a SceneKit scene icon, shown with the <a id="id226" class="calibre1"/>cube, as seen in the preceding screenshot.</p><p class="calibre8">The <code class="email">ViewController</code> class the AppDelegate moves to is the <code class="email">GameViewController.swift</code> class. This is where all of our code for the demo takes place:</p><div><pre class="programlisting">override func viewDidLoad() {
        super.viewDidLoad()
        
        // create a new scene
        let scene = SCNScene(named: "art.scnassets/ship.dae")!
...</pre></div><p class="calibre8">We see that we <a id="id227" class="calibre1"/>begin with the overwritten <code class="email">viewDidLoad()</code> function. SceneKit lets us create an entire scene with even an instance of our 3D object/assets, as seen from the unwrapped <code class="email">let scene = SCNScene(named: "art.scnassets/ship.dae")!</code> call. This simply creates the scene object. To get the object seen on the screen, we still need to attach this to the <code class="email">SCNView</code> node, as we will see later in the function.</p><p class="calibre8">Let's look at some more of the code here:</p><div><pre class="programlisting">//(1) create and add a camera to the scene
   let cameraNode = SCNNode()
   cameraNode.camera = SCNCamera()
   scene.rootNode.addChildNode(cameraNode)     
// place the camera
   cameraNode.position = SCNVector3(x: 0, y: 0, z: 15)       
//(2) create and add a light to the scene
   let lightNode = SCNNode()
   lightNode.light = SCNLight()
   lightNode.light!.type = SCNLightTypeOmni
   lightNode.position = SCNVector3(x: 0, y: 10, z: 10)
   scene.rootNode.addChildNode(lightNode)     
 // create and add an ambient light to the scene
   let ambientLightNode = SCNNode()
   ambientLightNode.light = SCNLight()
   ambientLightNode.light!.type = SCNLightTypeAmbient
   ambientLightNode.light!.color = UIColor.darkGrayColor()
   scene.rootNode.addChildNode(ambientLightNode)      
 //(3) retrieve the ship node
   let ship = scene.rootNode.childNodeWithName("ship", recursively: true)!      
 //(4) animate the 3d object
         ship.runAction(SCNAction.repeatActionForever(SCNAction.rotateByX(0, y: 2, z: 0, duration: 1)))       
 //(5) retrieve the SCNView
   let scnView = self.view as! SCNView    
 //set the scene to the view
   scnView.scene = scene
 //(6)allows the user to manipulate the camera
    scnView.allowsCameraControl = true     
 // show statistics such as fps and timing information
    scnView.showsStatistics = true    
 // configure the view
    scnView.backgroundColor = UIColor.blackColor()      
 //(7) add a tap gesture recognizer
    let tapGesture = UITapGestureRecognizer(target: self, action: "handleTap:")
        scnView.addGestureRecognizer(tapGesture)</pre></div><p class="calibre8">The <code class="email">viewDidLoad()</code> function mentioned earlier is provided to us in the template. It's actually rather simple <a id="id228" class="calibre1"/>to follow and other than the <code class="email">handleTap()</code> function, does practically all that's needed to create this scene. Anyone who's created 3D graphics <a id="id229" class="calibre1"/>in OpenGL either for iOS or other platforms would appreciate how SceneKit gives us a number of simple upper level controls for the scene and objects. Here are more details of the provided code:</p><p class="calibre8">On line <code class="email">(1)</code>, an <code class="email">SCNNode</code> named cameraNode is created, and we assign the <code class="email">camera</code> attribute of <code class="email">SCNNode</code> to the <code class="email">SCNCameraNode</code> type. Then, the camera is placed in a three-dimensional space using the <code class="email">SCNVector3()</code> function on the camera's <code class="email">position</code> property. In this case, the camera is placed at (<code class="email">x: 0</code>, <code class="email">y: 0</code>, <code class="email">z: 15</code>). In other words, the <em class="calibre10">x</em> and <em class="calibre10">y</em> coordinates are set at the origin while the camera is moved slightly backwards in the <em class="calibre10">z</em> axis.</p><div><img src="img/00044.jpeg" alt="SceneKit project flow and structure" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">You can find the <a id="id230" class="calibre1"/>SceneKit coordinate diagram at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/</a>.</p><p class="calibre8">The coordinate <a id="id231" class="calibre1"/>system in SceneKit is what's known as a <strong class="calibre9">Right-Handed Coordinate System</strong>. One trick to understand the 3D coordinates is if we take our right hand, make a gun-like gesture out with our thumb up in the air and pointer finger straight ahead of us while our middle finger to the side at a right angle from the pointer finger, we'd have our <em class="calibre10">x</em>, <em class="calibre10">y</em>, and <em class="calibre10">z</em> coordinates. Your middle finger would be on the <em class="calibre10">x</em> axis (left/right), your thumb would be on the <em class="calibre10">y</em> axis (up/down), and your pointer finger would be on the <em class="calibre10">z</em> axis (backward/forward).</p><p class="calibre8">In the <code class="email">(2)</code> block of <a id="id232" class="calibre1"/>code, we are adding lights to our screen. SceneKit, as well as SpriteKit, lets us create a number of different lighting effects, from ambient <a id="id233" class="calibre1"/>occlusion, the use of normal maps, and more. Here, an instance of <code class="email">SCNNode</code> is created with the name <code class="email">lightNode</code>, and the <code class="email">SCNNode</code> property light is assigned the <code class="email">SCNLight</code> class type. The first light created and added to the scene is what's known as an <code class="email">SCNLightTypeOmni</code> type light, as seen from the implicitly unwrapped call <code class="email">lightNode.light!.type = SCNLightTypeOmni</code>. This type of light is typically used more for debugging as the next light added, <code class="email">ambientLightNode</code>, would be one of the types used to create the atmosphere to your game. As we see with the line, <code class="email">ambientLightNode.light!.color = UIColor.darkGrayColor()</code>, we can assign a color to that light in code.</p><p class="calibre8">More information on <a id="id234" class="calibre1"/><code class="email">SCNLights</code> can be found at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html">https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html</a>.</p><p class="calibre8">We'll soon see how to visually add lights and other aspects of the demo <code class="email">viewDidLoad()</code> function to our scene, but it's usually beneficial to understand the boilerplate code behind the scenes.</p><p class="calibre8">In the line <code class="email">(3)</code>, <code class="email">let ship = scene.rootNode.childNodeWithName("ship", recursively: true)!</code> is how we add our <code class="email">ship</code> object to the scene's root node. This is not too much different than other objects in the scene. It takes the string <code class="email">ship</code> from the name of our <code class="email">ship.dae</code> object in the <code class="email">art.scnassets</code> folder. The <code class="email">recursively: true</code> parameter in the <code class="email">childNodeWithName</code> function tells the scene that it should add all child nodes of the object to the scene. Depending on how the 3D object was modeled and rigged in its original 3D model program, the object might have a complex array of child nodes. Setting recursively to <code class="email">true</code> will iterate through not just the child nodes but their child nodes as well.</p><p class="calibre8">The following long line (part of line <code class="email">(4)</code>) is a compact way of telling the ship to rotate continually by <em class="calibre10">x</em>, <em class="calibre10">y</em>, and/or <em class="calibre10">z</em> angles based on its current orientation:</p><div><pre class="programlisting">ship.runAction(SCNAction.repeatActionForever(SCNAction.rotateByX(0, y: 2, z: 0, duration: 1)))</pre></div><p class="calibre8">This can be broken down <a id="id235" class="calibre1"/>into its various parts, as it's an <code class="email">SCNAction</code> within an <code class="email">SCNAction</code>, namely, the <code class="email">rotateByX</code> function wrapped into a <code class="email">repeatActionForever</code> function of <code class="email">SCNAction</code>. Actions in both SceneKit (<code class="email">SCNAction</code>) and SpriteKit (<code class="email">SKAction</code>) cannot only be added to objects by code but also in Xcode's visual <a id="id236" class="calibre1"/>editor, as we shall see later in our review of the Fox demo.</p><p class="calibre8">Find more on both the <code class="email">SCNAction</code> and <code class="email">SKAction</code> classes here:</p><p class="calibre8">For <a id="id237" class="calibre1"/><code class="email">SCNAction</code>, refer to <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/">https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/</a>.</p><p class="calibre8">For <a id="id238" class="calibre1"/><code class="email">SKAction</code>, refer to <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/">https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/</a>.</p><p class="calibre8">In line <code class="email">(5)</code>, we create the <code class="email">SCNView</code> object and assign it as the view of <code class="email">GameViewController</code> with the line <code class="email">let scnView = self.view as! SCNView</code>. The scene and its nodes that we created with the object named <code class="email">scene</code> back in line <code class="email">(1)</code> then gets assigned to the <code class="email">scene</code> attribute of <code class="email">scnView</code> via <code class="email">scnView.scene = scene</code>. There is a slight bit of ambiguity as to which scene is assigned to what node, but this essentially has to do with the setting up of <code class="email">rootNode</code> itself.</p><p class="calibre8">The next few lines (of <code class="email">(6)</code>) show some of the properties that we can use from the <code class="email">SCNView</code> class; the first being the ability to control the camera with the <code class="email">allowsCameraControl</code> property. Setting this to <code class="email">false</code> would prevent the player from being able to move the camera about. This could be great for in-game cut scenes or locking the camera during a part of a stage where it would be necessary. The line <code class="email">scnView.showsStatistics = true</code> tells the scene to show any rendering data that would be beneficial to <a id="id239" class="calibre1"/>debugging. For example, we could see the <strong class="calibre9">frames per second</strong> (<strong class="calibre9">fps</strong>) our game is running at.</p><p class="calibre8">This is equivalent to <a id="id240" class="calibre1"/>a SpriteKit scene's code part of <code class="email">skView.showsFPS</code> <a id="id241" class="calibre1"/>and <code class="email">skView.showsNodeCount</code>, where <code class="email">skView</code> is the name of an <code class="email">SKView</code> object.</p><p class="calibre8">The next line, <code class="email">scnView.backgroundColor = UIColor.blackColor()</code>, allows us to set the background color to black, just the same way as we did with <code class="email">ambientLightNode.light!.color = UIColor.darkGrayColor()</code> using the <code class="email">UIColor</code> class.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec45" class="calibre1"/>SceneKit Debugging Options</h2></div></div></div><div><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">As of iOS 9, even <a id="id242" class="calibre1"/>more debugging options became available through the use of the <code class="email">SCNDebugOptions</code> struct and the <code class="email">debugOptions</code> attribute of <code class="email">SCNView</code>.</p><p class="calibre8">If we were to write the following, we'd be able to see our ship's bounding boxes:</p><div><pre class="programlisting">scnView.debugOptions = .ShowBoundingBoxes</pre></div><p class="calibre8">There are other options such as <code class="email">ShowLightInfluences</code>, <code class="email">ShowPhysicsShapes</code>, and <code class="email">ShowWireframe</code>.</p><div><img src="img/00045.jpeg" alt="SceneKit Debugging Options" class="calibre11"/><div><p class="calibre15">WWDC15's Fox Demo with the .ShowBoundingBoxes and ShowPhysicsShapes options enabled</p></div></div><p class="calibre12"> </p></div><p class="calibre8">Finally, in line <code class="email">(7)</code>, <code class="email">let tapGesture = UITapGestureRecognizer(target: self, action: "handleTap:")</code> creates a <code class="email">UITapGestureRecognizer</code> object named <code class="email">tapGesture</code>, which will call the function <code class="email">handleTap(gestureRecognize: UIGestureRecognizer)</code> when <a id="id243" class="calibre1"/>any tap is performed and <code class="email">scnView.addGestureRecognizer(tapGesture)</code> adds that recognizer to the scene.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec46" class="calibre1"/>Handling user input in SceneKit</h2></div></div></div><p class="calibre8">The <code class="email">UITapGestureRecognizer</code> objects are great in order to selectively organize the input we receive <a id="id244" class="calibre1"/>from the player. This goes for both SceneKit and SpriteKit scenes. We can have recognizers for taps, swipes in each direction, panning, pinches, and long presses; long presses are great for when you'd need to possibly handle a character charging their attack.</p><p class="calibre8">Here's the <a id="id245" class="calibre1"/>documentation of the <code class="email">UITapGestureRecognizer</code> class for reference:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html">https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html</a>
</p><p class="calibre8">Let's take a look at that <code class="email">handleTaps</code> function as it contains an object of the SceneKit class, <code class="email">SCNTransaction</code>:</p><div><pre class="programlisting">func handleTap(gestureRecognize: UIGestureRecognizer) {
        //(1) retrieve the SCNView
        let scnView = self.view as! SCNView
        // check what nodes are tapped
        let p = gestureRecognize.locationInView(scnView)
        /(2)
        let hitResults = scnView.hitTest(p, options: nil)
        // check that we clicked on at least one object
        if hitResults.count &gt; 0 {
            // retrieved the first clicked object
            let result: AnyObject! = hitResults[0]
            // get its material
            let material = result.node!.geometry!.firstMaterial!
            
        //(3)// highlight it
            SCNTransaction.begin()
            SCNTransaction.setAnimationDuration(0.5)
            // on completion - unhighlight
            SCNTransaction.setCompletionBlock {
                SCNTransaction.begin()
                SCNTransaction.setAnimationDuration(0.5)
                material.emission.contents = UIColor.blackColor()   
                SCNTransaction.commit()
            }  
            material.emission.contents = UIColor.redColor()
            SCNTransaction.commit()
        }
    }</pre></div><p class="calibre8">In line <code class="email">(1)</code>, we are just creating a reference to the current <code class="email">SCNView</code> object named <code class="email">scnView</code>. Next, the constant <code class="email">p</code> is created using <code class="email">gestureRecognize.locationInView(scnView)</code>. What this is doing is capturing the gesture's location in the view we wish to keep tabs on. In this case, it's the entire view, <code class="email">scnView</code>. If we had subviews, say a game's menu screen, then we could if we'd wish only target gestures there in this fashion.</p><div><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre8">If building a game where the player has to tap at the spur of the moment and many times for a character's movement or dodging, we did find the <code class="email">touchesBegan()</code> functionality we spoke about in SpriteKit to be a bit faster than <code class="email">UITapGestureRecognizer</code>. This might eventually become a moot point with each new and faster iOS device, but if your game's controls are heavily dependent on quickness of the player, you might notice some lag in response to the gestures via the <code class="email">UITapGesterRecognizer</code> approach. This could effect the goal of your game, so try the <code class="email">touchesBegan()</code> function to see what works best for your game. Using <code class="email">touchesBegan()</code> for swipes and other non-tap gestures could be rather tricky, so there's a trade-off there on the development side too.</p></div><p class="calibre8">Next in line <code class="email">(2)</code>, we take a count of how many of these gestures, taps in our case, were captured in the view <a id="id246" class="calibre1"/>using the <code class="email">hitTest()</code> function of <code class="email">SCNView</code> and only counting if that gesture made contact with any object in our scene by passing the position constant, <code class="email">p</code>, as a parameter. The function <code class="email">hitTest()</code> returns an array of event results, and the <code class="email">count</code> property then counts how large that array is. We can then capture a reference to the first tap by referencing the first member of that array. We only have a single object in this demo provided for us, the spaceship, so we can just get an instance of Swift's most upper parent object, <code class="email">AnyObject</code>. Our <code class="email">hitTest</code> object, <code class="email">hitResults</code>, is an array containing references to every object tapped in this context. Again, this is just our spaceship object, so we can simply take the first object instanced at <code class="email">hitTest[0]</code>. This is what the result constant represents.</p><p class="calibre8">The line <code class="email">let material = result.node!.geometry!.firstMaterial!</code> shows us how we get a reference to that object's material by drilling down the node's children using the dot operator while also implicitly unwrapping each node via the exclamation point (<code class="email">!</code>). This material reference is needed for when the tap needs to make the spaceship turn red.</p><div><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre8">This is actually a nice broad example of how we can select only certain objects in our SceneKit scene to be the focus of a player's input. Here, it just picks any object using the broad type <code class="email">AnyObject</code> class, but imagine a game where only a certain type of character or characters are selectable; think of an isometric top down shooter or <strong class="calibre9">real-time strategy</strong> (<strong class="calibre9">RTS</strong>) game. We could possibly check whether the tapped <a id="id247" class="calibre1"/>object only is a member of a certain class type (<code class="email">isKindOfClass()</code>) or conforms to a certain protocol (<code class="email">conformsToProtocol()</code>) before taking any action on those selected game objects. Want the player in your RTS game to only take actions on Tank objects? Then combining this with a menu that tells the game which object type is the focus could be what gives you that ability here in SceneKit.</p></div><p class="calibre8">In line <code class="email">(3)</code>, the default SceneKit template also hands us this useful bit of code showing the use of <code class="email">SCNTransaction</code>. The <code class="email">SCNTransaction</code> class first became available in iOS 8, and we can think of <code class="email">SCNTransaction</code> as a laundry list of changes and animations we want in the scene to take place at a certain specified set of time. An <code class="email">SCNTransaction</code> class begins with the <code class="email">SCNTransaction.begin()</code> call and ends at the <code class="email">SCNTransaction.commit()</code> call. Scene graph animation calls that are within that block get called, by default, with a 0 second delay. In many cases, we'd want to control the duration of these animations, thus we use the <code class="email">setAnimationDuration()</code> function at the beginning of the <code class="email">SCNTransaction</code> block to set that. The line <code class="email">SCNTransaction.setAnimationDuration(0.5)</code> sets the time to complete this block at half a second. Do note that within this block is another block of code starting with <code class="email">SCNTransaction.setCompletionBlock{…}</code>. What this does is execute the call only after the <code class="email">SCNTransation</code> block it's within completes. In the case of this template demo, at first for half a <a id="id248" class="calibre1"/>second, the ship is highlighted red, as done in the <code class="email">material.emission.contents = UIColor.redColor()</code> line. After this completes, for another half a second, the ship is brought back to it's original color by setting its material emission back to <code class="email">UIColor.blackColor()</code>. This is a bit confusing at first but there are a slew of animations and transactions we can do for our scenes with this method in just one block. Check out this link to the documentation; other transitions/transactions can be for fading in/out, camera field of view, rotation, translations, lighting, and more: <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey">https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey</a>.</p><p class="calibre8">As for the default SceneKit template, that's all the code used to make the scene. It's a basic scene and far from a game, but it should give us a basic understanding of what essentially makes up the main structure and logic of a scene in SceneKit. Before we look into the Fox demo and thus an actual full game project, let's look at a few other features that were added to Xcode as of iOS 9 / Xcode 7.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>SceneKit features introduced in iOS 9 / Xcode 7</h1></div></div></div><p class="calibre8">Let's go <a id="id249" class="calibre1"/>back to transitions and animations. As <a id="id250" class="calibre1"/>of iOS 9, we can change a character or other 3D object's blend mode very easily in SceneKit.</p><div><img src="img/00046.jpeg" alt="SceneKit features introduced in iOS 9 / Xcode 7" class="calibre11"/><div><p class="calibre15">A display of the various blend modes in SceneKit from WWDC2015</p></div></div><p class="calibre12"> </p><p class="calibre8">Blend modes can be changed simply with one line, <code class="email">aSCNMaterial.blendMode = .Add</code>, where <code class="email">aSCNMaterial</code> is an object representing the material of <code class="email">SCNNode</code>. Changing blend modes can create a number of effects. Some games use a player's <em class="calibre10">ghost</em> to show a past run through they are trying to beat, or there's the fade effect boss characters make when defeated. Combine with <code class="email">SCNTransaction</code> to have characters fade in and out of these modes.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec47" class="calibre1"/>Audio nodes and 3D sound</h2></div></div></div><p class="calibre8">As of <a id="id251" class="calibre1"/>iOS 9, we can place 3D sounds into our SceneKit scenes. The <code class="email">addAudioPlayer()</code> function of the <code class="email">SCNNode</code> class function lets us append a sound to that node, and wherever that node is in 3D space, the sound will adhere to 3D audio mixing; that is, if the audio source's <code class="email">positional</code> property is set to <code class="email">true</code>. Here's how we'd create 3D sound with audio nodes:</p><div><pre class="programlisting">let source = SCNAudioSource(named: "sound.caf")
let soundEffect = SCNAudioPlayer(source: source)
node.addAudioPlayer(soundEffect)
source.positional = true 
source.loops = false</pre></div><p class="calibre8">This gives a sound effect to the game object, the <code class="email">SCNNode</code> named node.</p><p class="calibre8">To actually play the sound, we'd need to call <code class="email">SCNAction</code> on it, as shown:</p><div><pre class="programlisting">let action = SCNAction.playAudioSource(source, waitForCompletion: true) 
node.runAction(action)</pre></div><p class="calibre8">The <code class="email">waitForCompletion</code> property makes sure that the action goes as long as the sound is. This <a id="id252" class="calibre1"/>might not be the best for a character sound effect though as you might want it stopped midway (that is, the player hits the enemy, canceling their previously started chant, yell, or something to that degree).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec48" class="calibre1"/>Ambience and music</h2></div></div></div><p class="calibre8">To add <a id="id253" class="calibre1"/>music and ambience, we could follow exactly the same method as adding a sound effect to a node: create an <code class="email">SCNAudioSource</code> object; add that to an <code class="email">SCNAudioSource</code> object; and add this to our node with <code class="email">addAudioPlayer</code>. The only difference is that we'd loop the music and set it's <code class="email">positional</code> property to <code class="email">false</code> as follows:</p><div><pre class="programlisting">source.positional = false 
source.loops = true</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec49" class="calibre1"/>SpriteKit scene transitions in SceneKit</h2></div></div></div><p class="calibre8">SpriteKit <a id="id254" class="calibre1"/>has some great scene transitions. We could make it look like a door is opening up or a page is turning. This could add extra character and polish to your game. Before iOS 9, we couldn't do these 2D transitions in our 3D SceneKit, but since Xcode 7 and iOS 9, we can do so in SceneKit and here's how:</p><div><pre class="programlisting">aSCNView.presentScene(aScene, withTransition:aSKTransition,
incomingPointOfView:nil, completionHandler:nil)</pre></div><p class="calibre8">Again, <code class="email">aSCNView</code> is just a general reference to some <code class="email">SCNView</code> object and when we present the scene to that view, we have the option of passing an <code class="email">SKTransition</code> object for the <code class="email">withTransition</code> parameter. The <code class="email">incomingPointofView</code> parameter can be a reference to a camera's point of view during the transition, and the <code class="email">completionHandler</code> parameter is the name of a completion block that is called after the scene transitions. For example, we could call the functions that start the count up of our last stage's score in a score scene that was transitioned to after the stage completed. We might not want to begin the counting and other functions of the new scene until we know that the scene has been 100% transitioned to or, in this case, after we know the total points from the prior scene.</p><p class="calibre8">Check out some more <a id="id255" class="calibre1"/>examples of <code class="email">SKTransition</code> on the class reference page, maybe there's a transition that could help add to your game's design:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html">https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html</a>
</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>Fox demo</h1></div></div></div><p class="calibre8">We've been spending <a id="id256" class="calibre1"/>much of our time in both SpriteKit and here in SceneKit on the boilerplate code that makes up our game logic. As Xcode continues to update, so does the visual design features for iOS game design that don't involve a strong understanding of code. There's always some scripting involved, but one of the key features in game design is, well, the design aspect of it. At the <em class="calibre10">WWDC15</em> event, the introduction to iOS 9 and Xcode 7 was a great game demo that can not only teach us some of the visual design features that Xcode can do, but also gives us a beautiful start to a platforming game in SceneKit. That demo is named <em class="calibre10">Fox</em> and granted, though it actually stars a red panda and not a fox, we could forgive that mixup for how feature-rich and essential it can be to learn how to develop SceneKit-powered iOS games.</p><div><img src="img/00047.jpeg" alt="Fox demo" class="calibre11"/><div><p class="calibre15">The Fox demo image showing our player character and level assets</p></div></div><p class="calibre12"> </p><p class="calibre8">There's much more to this demo than we can show here, so it's encouraged to download it for yourself and check out all of the SceneKit features it provides. We will focus on a few topics yet to be covered in either SceneKit or SpriteKit, such as particles, physics, and the scene graph. The Fox demo also makes use of 3D game/art design features, such as skyboxes, ambient occlusion, cubemap lighting, collision meshes, and more. It really is a nice-quality demo to make beautiful games in iOS.</p><p class="calibre8">Here is the download <a id="id257" class="calibre1"/>link provided by Apple:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html">https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html</a>
</p><div><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre8">At the time of writing, the Fox demo was written only in Objective-C. We have focused on Swift in the entirety of this book, but don't worry too much if some aspects of Objective-C are foreign to you. The goal is to see the visual tools Xcode provides. In a <a id="id258" class="calibre1"/>future date, the Fox demo is bound to be available in Swift, be it by Apple themselves or by third-party programmers.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Particle systems</h1></div></div></div><p class="calibre8">Some of the basic <a id="id259" class="calibre1"/>assets in any game, be it SpriteKit or SceneKit built, are the various particle effects we'd add to characters, objects, or an entire scene. Particles can add to the feel of collecting that item, give the player a signal that something is happening to the player, like they are gaining or losing health, or show the presence and power of an incoming boss fight.</p><div><img src="img/00048.jpeg" alt="Particle systems" class="calibre11"/><div><p class="calibre15">Collectable particle effect from the Fox demo</p></div></div><p class="calibre12"> </p><p class="calibre8">In the past, the process of making a particle effect would be to manually create sometimes rather complex particle emitter shader objects using OpenGL code. This can still be done if we so choose (using either Apple's fast, low-level API, Metal, or OpenGL), but over time, the process of visually creating and editing particle effects has gotten easier. Not too long ago in the iOS development history, frameworks such as Cocos2D/ Cocos3D allowed us to use third-party particle effects builders to import into our games. With both SpriteKit and SceneKit, Xcode as of about iOS 7/iOS 8, a more visual representation of particles was created in Xcode thus saving us a large amount of time and effort in creating the effects we want and expect to see in our games. The image previously shown displays the Xcode particle systems editor with the Fox demo's collectable sparkle effect.</p><p class="calibre8">To create your own <a id="id260" class="calibre1"/>particle effect in SceneKit, follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new file as we did in the past by navigating to <strong class="calibre9">File</strong> | <strong class="calibre9">New</strong> … or simply the keyboard shortcut <em class="calibre10">command</em> + <em class="calibre10">N</em>.</li><li class="listitem" value="2">We then select the <strong class="calibre9">Resource</strong> section under iOS and select the <strong class="calibre9">SceneKit Particle System</strong> template. (If working with SpriteKit, select <strong class="calibre9">SpriteKit Particle File</strong>.)<div><img src="img/00049.jpeg" alt="Particle systems" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">Both the SpriteKit and SceneKit particle options give us a list of basic particle templates we can start from, such as Reactor, Sparkle, or Bokeh. Select one of your choosing or check out a collectable one here in the demo. For SpriteKit, this creates an SKS file and the image mask for the particles. The SceneKit template creates the 3D particle effect via an SCNP file and the image mask.</li></ol><div></div><p class="calibre8">Let's take a look back at the particle system we created for the collectable particle in the demo. If not selected already, click on the attributes inspector to view various controls we can edit to customize our particle effects.</p><div><img src="img/00050.jpeg" alt="Particle systems" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Feel free to test a number of the variables and fields within the inspector. There's the birth rate, which controls how often the particles restart their start and end animation, the image, which can make up the shape and color of the particles, and the various angles that determine the overall direction of the effects. There's also the <strong class="calibre9">Looping</strong> dropdown, which keeps the particles <a id="id261" class="calibre1"/>repeating during the life of the particle system in the scene. Additionally, the <strong class="calibre9">affected by gravity</strong> toggle is what we use to have the <a id="id262" class="calibre1"/>particles fall based on the scene's gravity. The collection particles loop constantly without gravity, and the confetti particles happen once and fall to gravity, as we'd expect confetti to behave. If an object in our scene has a physics field, we can also have the particles react to that.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec50" class="calibre1"/>Placing particles into our pioscene</h2></div></div></div><p class="calibre8">When we create <a id="id263" class="calibre1"/>SpriteKit or SceneKit particles, we can call them in our scene via code in either the SpriteKit or SceneKit:</p><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec11" class="calibre1"/>SpriteKit</h3></div></div></div><p class="calibre8">SpriteKit particles <a id="id264" class="calibre1"/>aren't in the Fox demo but to backtrack a bit to <a id="id265" class="calibre1"/>our talk on SpriteKit, if we'd wanted to add particles to a 2D SpriteKit game, here's an example of how we'd accomplish that:</p><div><pre class="programlisting">//(1)
var path = NSBundle.mainBundle().pathForResource("Spark", ofType: "sks")
//(2)
    var sparkParticle = NSKeyedUnarchiver.unarchiveObjectWithFile(path!) as! SKEmitterNode
//(3)     
    sparkParticle.position = CGPointMake(self.size.width/2, self.size.height)
    sparkParticle.name = "sparkParticle"
    sparkParticle.targetNode = self.scene 
    self.addChild(sparkParticle)</pre></div><div><ol class="orderedlist"><li class="listitem" value="1">We create a path to our app's bundle with the <code class="email">NSBundle.mainBundle().pathForResource()</code> function call, and we pass the string of the particle file's name, in this case, <code class="email">Spark</code>, with the file type, SKS.</li><li class="listitem" value="2">Next, we create the <code class="email">sparkParticle</code> object using the <code class="email">NSKeyedUnarchiver.unarchiveObjectWithFile(path!)</code> call that, as we see, takes the path we created in part <code class="email">(1)</code>. It's casted as the particle object for SpriteKit, <code class="email">SKEmitterNode</code>. <code class="email">NSKeyedUnarchiver</code> is a class used to decode named objects from keyed archives, an encoded hierarchy of archives. This class has some support of what is known type coercion. In short, it can decode objects in files, be it whether in a 32-bit or 64-bit architecture. More on this special file <a id="id266" class="calibre1"/>decoding class here: <a class="calibre1" href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/">https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/</a></li><li class="listitem" value="3">We then set a position and name for this particle effect and target it to the scene while also adding it to the scene node.</li></ol><div></div><p class="calibre8">Though this example isn't <a id="id267" class="calibre1"/>given in the Fox demo, this is a great example of <a id="id268" class="calibre1"/>how we can target specific files in our project's navigation hierarchy.</p></div><div><div><div><div><h3 class="title2"><a id="ch04lvl3sec12" class="calibre1"/>SceneKit</h3></div></div></div><p class="calibre8">SceneKit particles are <a id="id269" class="calibre1"/>members of the <code class="email">SCNParticleSystem</code> <a id="id270" class="calibre1"/>class. We add these particles to our scene with the <code class="email">addParticleSystem</code> function of the <code class="email">SCNNode</code> class. The Fox demo does this in the <code class="email">collectFlower()</code> function with the following Objective-C line:</p><div><pre class="programlisting">[self.gameView.scene addParticleSystem:_collectParticles withTransform:particlePosition];</pre></div><p class="calibre8">What this code is doing is calling the scene in the designated view and adding the particles, which are declared earlier in the class as <code class="email">_collectParticles</code> to our scene. It then tells the scene at which point in space this effect will appear. In this case, it's the <code class="email">particalPosition</code> variable that when traced back is taken from the <code class="email">SCNNode</code> parameter passed into the <code class="email">collectFlower()</code> function.</p><div><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre8">Here's how this would be written in Swift:</p><div><pre class="programlisting">scene.particleEmitNode.addParticleSystem(_collectable!)</pre></div><p class="calibre8">Swift's <code class="email">addParticleSystem</code> API unfortunately doesn't have the <code class="email">withTransform</code> parameter as in Objective-C, so we'd have to add the particle system to the node it will be emitting from, which is denoted by the <code class="email">particleEmitNode</code> variable. This most likely will change in future API changes of Swift 2.x and later.</p></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec39" class="calibre1"/>Introducing SceneKit and SpriteKit physics</h1></div></div></div><p class="calibre8">When we look <a id="id271" class="calibre1"/>at the <code class="email">collectFlower()</code> function from our particle <a id="id272" class="calibre1"/>example, we see that there's an <code class="email">SCNNode</code> parameter passed. This node comes from the function <code class="email">physicsWorld</code>. In both SpriteKit and SceneKit, we can create an overall set of physics rules and handle various physics-related interactions, most notably, contacts between two or more nodes. One of the most basic aspects of any game is to do something when game objects hit each other. This could be when the player touches a collectable, when enemies contact the player or the player hits the enemy with an attack. In iOS development and in game engines, we call these boundaries between 2D sprites or 3D objects as bounding boxes. We mentioned these physics objects briefly in our talk of iOS 9 and later <code class="email">debugOptions</code> property. Bounding boxes for SceneKit objects are created automatically based on the simplified version of an object's <a id="id273" class="calibre1"/>geometry, but we can edit these shapes with the <code class="email">SCNBoundingVolume</code> class.</p><p class="calibre8">More documentation of <a id="id274" class="calibre1"/>this class can be found at <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html">https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html</a>.</p><p class="calibre8">Game physics in iOS and game development in general are much larger topics than we can discuss in this chapter. So for now, let's just see how the Fox demo and iOS games in general handle the simple concept of two nodes contacting their bounding boxes.</p><div><pre class="programlisting">func physicsWorld(world: SCNPhysicsWorld, didUpdateContact contact: SCNPhysicsContact) {
if (contact.nodeA.physicsBody.categoryBitMask == AAPLBitmaskSuperCollectable) {
        self.collectFlower(contact.nodeA)
    }
if (contact.nodeB.physicsBody.categoryBitMask == AAPLBitmaskSuperCollectable) {
        self.collectFlower(contact.nodeB)
}
</pre></div><p class="calibre8">Preceding is a Swift <a id="id275" class="calibre1"/>pseudo code example of the Fox demo's <code class="email">physicsWorld</code> function. The function takes in two parameters, <code class="email">world</code> of the type <code class="email">SCNPhysicsWorld</code> that represents the entire physics environment of a scene and the object representing the physics contact of the type <code class="email">SCNPhysicsContact</code>. The function here checks the bitmask of the nodes in the contact. If the first or second node of the contact (<code class="email">nodeA</code> or <code class="email">nodeB</code>) are in the flower's specific category, then the <code class="email">collectFlower()</code> function is called and that collectable's node is passed as a parameter.</p><p class="calibre8">Bitmasking is when we designate a set of bits for another set of bits that can be combined together using bitwise math. Think of it as using 1s and 0s to not only categorize a range of ones and zeros but also allow us to handle situations where many categories happen in the same context.</p><p class="calibre8">For example, we have different categories of objects/events in our game and we fit them in their own <em class="calibre10">slots</em> in a byte (8 bits). In the Fox demo, the game collisions are a bitshift value of 2, thus they represent 00000100 in binary. The <em class="calibre10">category designation</em> of collectables in the Fox demo a bitshift of 3 or 00001000, the enemies are 4, 00010000.</p><p class="calibre8">In the demo, we see the following code for <code class="email">AAPLBitmaskSuperCollectable</code>:</p><div><pre class="programlisting">// Collision bit masks
typedef NS_OPTIONS(NSUInteger, AAPLBitmask) {
    AAPLBitmaskCollision        = 1UL &lt;&lt; 2,
    AAPLBitmaskCollectable      = 1UL &lt;&lt; 3,
    AAPLBitmaskEnemy            = 1UL &lt;&lt; 4,
<strong class="calibre9">    AAPLBitmaskSuperCollectable = 1UL &lt;&lt; 5,</strong>
    AAPLBitmaskWater            = 1UL &lt;&lt; 6
};</pre></div><p class="calibre8">When the category bitmask in either <code class="email">nodeA</code> or <code class="email">nodeB</code> of the collision match the flower collectable (if the <em class="calibre10">slot</em> is <em class="calibre10">on</em> per say, or equal to 1, then we know the collectable was involved in the collision).</p><p class="calibre8">Swift version 1 didn't really have a similar way to mimic bitmasking as done in Objective-C with <a id="id276" class="calibre1"/>NSOptions, but as of Swift 2.0, we can perform <a id="id277" class="calibre1"/>bitmasking like the demo in the following way:</p><div><pre class="programlisting">struct AAPLBitmask : AAPLBitmaskType {
 let rawValue: Int
 init(rawValue: Int) { self.rawValue = rawValue }

 static var None: AAPLBitmaskType { return AAPLBitmask(rawValue: 0) }
 static var AAPLBitmaskCollision : AAPLBitmask   { return AAPLBitmask(rawValue: 1 &lt;&lt; 2) }
 static var AAPLBitmaskCollectable : AAPLBitmask  { return AAPLBitmask(rawValue: 1 &lt;&lt; 3) }
 static var AAPLBitmaskEnemy : AAPLBitmask   { return AAPLBitmask(rawValue: 1 &lt;&lt; 4) }
static var AAPLBitmaskSuperCollectable : AAPLBitmask   { return AAPLBitmask(rawValue: 1 &lt;&lt; 5) }
static var AAPLBitmaskWater : AAPLBitmask   { return AAPLBitmask(rawValue: 1 &lt;&lt; 6) }
}</pre></div><p class="calibre8">Essentially, it's a struct that returns bitshifted static variables of itself. It's not as elegant as seen in Objective-C and in past C implementation, but if we wish to use bitmasking in boilerplate code in Swift, this should allow you to do so.</p><p class="calibre8">One last note about the <code class="email">physicsWorld()</code> function, in order for the function to be called during the collision of two physics bodies, we need to set the physics world delegate. In most cases, that delegate would be the current game scene.</p><div><pre class="programlisting">scene.physicsWorld.contactDelegate = self</pre></div><p class="calibre8">Xcode will most likely tell you that a physics world delegate wasn't set and if you haven't, this is the code that is usually placed in the <code class="email">viewDidLoad()</code> function of <code class="email">ViewController</code>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec51" class="calibre1"/>Visually composed game scenescgs</h2></div></div></div><p class="calibre8">Getting back to the <a id="id278" class="calibre1"/>visual aspects of the Fox demo, let's look at the game scene objects created in the project and how we can view the nodes in what's known as the <strong class="calibre9">scene graph</strong>.</p><div><img src="img/00051.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We see that game objects and particle effects in the Fox demo can be visually manipulated in Xcode and together in one view. The preceding image shows the flower collectable and its components that consist of the 3D mesh, lighting, bounding boxes, and the particle effects. In SceneKit, we do this with a SceneKit scene file (SCN).</p><div><img src="img/00052.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">To view the scene's scene graph, click on the side window icon found toward the bottom-left of the Xcode window under the visual editor window of the scene, as seen in the following screenshot:</p><div><img src="img/00053.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This is a screenshot of the scene graph. Those familiar with the game engines, such as Unity and Unreal Engine, will be quite familiar with this type of component/game scene view. The scene graph shows the dropdown hierarchy of all the objects in the scene including their own <a id="id279" class="calibre1"/>internal components. The flower power-up consists of a 3D mesh model named <em class="calibre10">flower</em> that has two child particle effects as well as a physics body. All three are denoted by the three symbols seen on the right-hand side of the graph's objects.</p><div><img src="img/00054.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We can move the model around in the scene, using <em class="calibre10">X</em>, <em class="calibre10">Y</em>, and <em class="calibre10">Z</em> markers seen in the preceding image. We can also zoom in, zoom out, rotate the scene, as well as add more objects to the scene.</p><div><img src="img/00055.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">To add more objects to the scene, follow these:</p><div><ol class="orderedlist"><li class="listitem" value="1">Go to the <strong class="calibre9">media library</strong> found in the library windows at the bottom-right of the screen (seen in <a id="id280" class="calibre1"/>the prior image).</li><li class="listitem" value="2">Now search for <code class="email">grass</code> and simply drag and drop it into the scene. Now the premade grass object is in this scene as a reference.<div><img src="img/00056.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">This is actually how the <code class="email">level.scn</code> file was composed.</li><li class="listitem" value="4">There's also the option to add primitive objects to the scene and build them up from there, which is again very similar to the design-centric game engines. Simply select from the object library tab right next to the media library icon and search <code class="email">geometry</code>. There are primitive objects, such as spheres, planes, and boxes.<div><img src="img/00057.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="5">The primitive objects lack the lighting, materials and other details that we can see in the grass and other premade objects in the projects. Use the even more detailed inspector windows for these objects to see and edit various details, such as the physics bodies, materials, baking the lighting, and object name identification for any scripting/coding.<div><img src="img/00058.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="6">There's also actions that can be added to these objects. Click on the secondary editor icon (the upside down triangle in a square at the button right of the flow scene's view). This will open the secondary editor that shows a <code class="email">RotateByEuler</code> <a id="id281" class="calibre1"/>action if the flower asset is selected in the scene graph.<div><img src="img/00059.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="7">What this action does is rotate the flower once every second. To see this in action, click on the Play button seen just above the secondary editor window timeline. We can see how this object will rotate from this action.</li><li class="listitem" value="8">The action can be shortened or extended by expanding or condensing it in the secondary editor timeline. More details about the action can be edited in the Inspector window, and if we'd like, we can use the library to add more actions to this object or remove the one provided to have it act in a different way.</li></ol><div></div><p class="calibre8">Test out a few actions, times, and properties yourself. We can see how, without any code, we can set up a scene visually and dynamically control actions of each object in that scene. Many of these visual features and actions work for both SceneKit and SpriteKit scenes.</p><div><img src="img/00060.jpeg" alt="Visually composed game scenescgs" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Look at the <code class="email">level.scn</code> file to see a scene with a fully composed level camera object (as seen in the previous screenshot). Do you want to make a similar level with maybe more obstacles and a different skybox? Copy the level and change those assets and name it <code class="email">level2</code>. This can save a monumental amount of time in the design of games and levels. From Xcode 7 onwards, we have tools directly in the IDE that originally were only for the multiplatform game <a id="id282" class="calibre1"/>engines. It really puts the design back into game design. </p><p class="calibre8">Much of the manual code we've gone over could get daunting, especially for those of us who may want to get into game design but are still relatively new to coding.</p><div><pre class="programlisting">//Objective-C
SCNScene *scene = [SCNScene sceneNamed:@"game.scnassets/level.scn"];
//Swift 
let scene = SCNScene(named: "game.scnassets/level.scn")!</pre></div><p class="calibre8">This is all we need to reference a scene from the visually designed tools. Add it to the view's root node like we spoke about in the SceneKit basic template and it's ready to go. Use code to add spawning enemies, the player, and the 2D SpriteKit overlay (which can itself have actions and visual designs in its SKS file), and it's a full-fledged game.</p><p class="calibre8">For more information on the SceneKit framework as well as the latest updates and additions to its library, see <a id="id283" class="calibre1"/>the full documentation link as follows:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/</a>
</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">At the start of this chapter, we first spoke briefly about the history of 3D game design in iOS and how SceneKit came to be from the necessity to have a first-party, dynamically robust framework aimed at the complexities of 3D game development. We then went over the basic structure of SceneKit and how it and SpriteKit from the previous chapter work off the concept of nodes, starting from the view and moving on to the scene node and child nodes in that scene. Next, we went over how SpriteKit and SceneKit can be used together in the same scene as we then moved on to dissecting the default SceneKit template given to us in Xcode, and its various assets. In addition to a review of template project's code, we also reviewed some of the features, code, and assets, such as the audio nodes, lend modes, and debug options that became available as of iOS 9 / Xcode 7. Finally, for the remainder of the chapter, we spoke much about the Fox demo shown during the <em class="calibre10">WWDC15</em> convention and the various visual game design features that became available since the announcement of Xcode 7.</p><p class="calibre8">For our next chapter, we will go into the features of the GameplayKit framework, which we introduced briefly when we went over the benefits of using composite-based structuring when building our games. With GameplayKit, we can duplicate and reuse premade game actions and rules as we did here in this chapter with the visual components of our games.</p></div></body></html>