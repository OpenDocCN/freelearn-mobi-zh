<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Synchronizing Data</h1></div></div></div><div><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p>
<em>"How we need another soul to cling to."</em>
</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Sylvia Plath</em></td></tr></table></div><p>In the previous chapter, we walked you through creating a standalone wearable app. In this chapter, we introduce the idea of a companion handheld app, and why it is needed. We then walk you through the steps required to pair a handheld device with an Android Wear emulator to expand your environment for wearable app development.</p><p>We will then augment the <code class="literal">Today</code> app we started in the previous chapter with the ability to display <em>this day in history</em> by having it pull content from a public feed page via the companion app.</p><div><h3 class="title"><a id="note10"/>Note</h3><p>The code samples for this chapter are available on GitHub (<a class="ulink" href="https://github.com/siddii/mastering-android-wear/tree/master/Chapter_5">https://github.com/siddii/mastering-android-wear/tree/master/Chapter_5</a>). Please use the actual code for reference as you follow along.</p></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>What is a companion app anyway?</h1></div></div></div><p>Wearable apps run directly on the wearable device and in this way let you access the device's hardware, activities, and services all on the device itself. The breadth of operations that may be performed on a wearable device is limited by design, owing to the smaller scale and the need to efficiently manage processing power and memory. In addition to that, wearables don't support the Google Play store. In addition to that, Android Wear 1.x does not allow direct install of apps from the Google Play Store.</p><p>A companion handheld app addresses these concerns to let us benefit from a rich user experience on our wearable device. The point to remember is that a wearable app is packaged within a companion handheld app. The companion app is what gets published to the Google Play store, as described in the following figure:</p><p>
</p><div><img src="img/image00166.jpeg" alt="What is a companion app anyway?"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>When users download the companion app to a handheld device, the wearable app within it is automatically pushed to all connected wearables, as described in the following figure:</p><p>
</p><div><img src="img/image00167.jpeg" alt="What is a companion app anyway?"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Furthermore, the companion app running on the handheld device is better suited to doing the heavy lifting involved when an app performs network actions, intensive computation, and other resource-intensive work. The companion app then sends results to the wearable, thus communicating the outcome of its operations.</p><p>Before we can create a project housing a companion app module along with its wearable app module, we need to set up our development environment to let us work with a wearable device on our handheld device.</p><div><h3 class="title"><a id="tip11"/>Tip</h3><p>It is expected that Android Wear 2.0 will change the way Wear apps are packaged and installed from Google Play store. The auto-installation for Wear apps in Wear 1.x is to be retired. Instead, Wear 2.0 apps are expected to have full network access and their installation is to be completely separate from that of handheld apps. Google is moving towards standalone wearable apps as the preferred packaging approach, but it is not clear yet whether standalone apps will be required (with no option for auto-installation) or if they will simply be supported as an additional feature.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Setting up an Android Wear virtual device</h1></div></div></div><p>These steps are published on the Android Developers site (<a class="ulink" href="https://developer.android.com/training/wearables/apps/creating.html">https://developer.android.com/training/wearables/apps/creating.html</a>), in the <strong>Creating and Running a Wearable App</strong> section. They are repeated here and expanded upon for convenience.</p><p>To set up an Android Wear virtual device, click <strong>Tools</strong> | <strong>Android</strong> | <strong>AVD Manager</strong> in Android Studio and perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the <strong>Create virtual device...</strong> option.</li><li class="listitem">Click <strong>Wear</strong> in the Category list:<div><ol class="orderedlist arabic"><li class="listitem">Select <strong>Android Wear Square</strong> or <strong>Android Wear Round</strong>.</li><li class="listitem">Click on the <strong>Next</strong> button.</li><li class="listitem">Select a release name (for example, KitKat Wear).</li><li class="listitem">Click <strong>Next</strong>.</li><li class="listitem">Change any preferences for your virtual device (optional).</li><li class="listitem">Click <strong>Finish</strong>.</li></ol><div></div><p>
</p></li><li class="listitem">Start the emulator:<div><ol class="orderedlist arabic"><li class="listitem">Select the virtual device you just created.</li><li class="listitem">Click the green play button.</li><li class="listitem">Wait until the emulator initializes and shows the Android Wear home screen.</li></ol><div></div><p>
</p></li><li class="listitem">Pair the Android handheld device with the Wearable emulator:<div><ol class="orderedlist arabic"><li class="listitem">On your handheld device, install the Android Wear app provided by Google from Google Play.</li><li class="listitem">Connect the handheld device to your machine via USB.</li><li class="listitem">Forward the AVD's communication port to the connected handheld device (you must do this every time the device is connected). If we don't see any errors after the following command run, then everything is fine:<p>
</p><div><img src="img/image00168.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li><li class="listitem">Start the Android Wear app on your handheld device and connect to the emulator by selecting <strong>Connect Emulator</strong><em>,</em> as shown in the following image:<p>
</p><div><img src="img/image00169.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>A successful connection is depicted in the following image:</p><p>
</p><div><img src="img/image00170.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li><li class="listitem">Launch the Settings menu and select  <strong>Try out watch notifications</strong><em>:</em><p>
</p><div><img src="img/image00171.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></li></ol><div></div></li><li class="listitem">Select <strong>Reminder (by time)</strong> option from the list:</li></ol><div></div><p>
</p><div><img src="img/image00172.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The following screen appears on the wearable emulator:</p><p>
</p><div><img src="img/image00173.jpeg" alt="Setting up an Android Wear virtual device"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Revisiting the Today app</h1></div></div></div><p>Now that we have the ability to work with a wearable device on our handheld, let's revisit the <code class="literal">Today</code> app we developed in the previous chapter.</p><p>That simplistic version of the app helped gets us started, no doubt. But it doesn't really cut it for us. In order to enjoy a fuller experience of a wearable device's capabilities, we need to expand our requirements. So, we've decided to devote the rest of this chapter to augmenting our <code class="literal">Today</code> app significantly.</p><p>We'll describe the features of the new app in a bit, but first, let's get started by creating a new project in Android Studio—one that includes a wearable app as well as a companion app; and setting it up with the sample code for this chapter.</p><p>We thought it might be refreshing to start over; that is why our new app is still named <code class="literal">Today</code>. Feel free to call it whatever you like:</p><p>
</p><div><img src="img/image00174.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Be sure to select the form factors for the app as shown in the following screenshot—<strong>Phone and Tablet</strong>, and <strong>Wear</strong> :</p><p>
</p><div><img src="img/image00175.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Add an empty activity to the <strong>Mobile</strong> module by clicking on <strong>Empty Activity</strong> :</p><p>
</p><div><img src="img/image00176.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Give a suitable name to your activity in the following screen:</p><p>
</p><div><img src="img/image00177.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>For now, choose the <strong>Add No Activity</strong> option in the <strong>Wear</strong> module, and click <strong>Finish</strong> :</p><p>

</p><div><img src="img/image00178.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>

</p><p>Android Studio creates the <strong>Wear</strong> and <strong>Mobile</strong> modules depicted in the following screenshot:</p><p>
</p><div><img src="img/image00179.jpeg" alt="Revisiting the Today app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The preceding screenshot shows the state of our project. Note that Android Studio created two modules—mobile and wear. It also created Gradle scripts for them and added the necessary dependencies. Furthermore, the <em>run target</em> configuration for both modules was created as well.</p><p>We copied our code (that is, activities, resources, icons, and so on) from the <code class="literal">Today</code> project we created in <a class="link" title="Chapter 4.  Developing Watch UI" href="part0034.xhtml#aid-10DJ41">Chapter 4</a>, <em>Developing Watch UI</em>, into the wear module of this newly created project, and then augmented it to meet our expanded requirements. This is a good time to examine what those requirements are.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec8"/>Scope of the new Today app</h2></div></div></div><p>We all know how important dates are. Who doesn't get a kick out of learning that their significant other shares a birthday with a famous celebrity, or better yet, an infamous one? With that in mind, let's spruce up our <code class="literal">Today</code> app to do more than simply display the current date. Let's have it pull content from a public feed paged named <em>On This Day</em> (<a class="ulink" href="https://en.wikipedia.org/wiki/Special:FeedItem/onthisday/20160615000000/en">https://en.wikipedia.org/wiki/Special:FeedItem/onthisday/20160615000000/en</a>), which shares one or more historically important events/occurrences whose anniversary happens to coincide with today.</p><p>This seems like a larger enough bite into the Wearable API stack that will let us study the interplay between a wearable device and its companion app without too much additional complexity.</p><p>Before we dive into the application code, it behooves us to cover a few concepts, tools, and API objects that are essential to our application. The intent here is to get you enough information to understand the core portions of the sample code. You can always come back and refer to this chapter and the documentation referenced in it.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec9"/>The Wearable data layer API</h2></div></div></div><p>Google Play services include a Wearable data layer API (<a class="ulink" href="https://developer.android.com/training/wearables/data-layer/index.html">https://developer.android.com/training/wearables/data-layer/index.html</a>), through which your handheld and wearable apps may communicate with each other.</p><p>We encourage you to study the data layer API documentation located at the preceding page on Android developers site, but certain key data objects in the API deserve special attention.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec0"/>MessageApi</h3></div></div></div><p>This interface exposes methods for the wearables and handheld device to send messages to each other. Messages sent to connected network nodes (that is, paired devices) are queued for delivery. It is important to keep in mind that a message created by an application is private to that application and accessible only by that application running on other nodes.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec1"/>WearableListenerService</h3></div></div></div><p>This class should be extended by applications that expect to be notified of events while running in the background. Events include when a message is received, when data changes, and when nodes connect to or disconnect from the Android Wear network, which is the constantly shifting network of wearable devices and the handheld devices that they can connect to and/or interact with.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec2"/>DataListener</h3></div></div></div><p>While the <code class="literal">WearableListenerService</code> class notifies applications while they run in the background, the <code class="literal">DataListener</code> interface notifies applications implementing it of data layer events while they run in the foreground.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec3"/>Cloud Node</h3></div></div></div><p>Along with all of the user's connected devices (nodes), Google's servers implicitly host a cloud node in the network of devices. The purpose of the cloud nodes is to synchronize data between directly connected devices. Changes to an application's state on a handheld device are pushed to all of the user's wearable devices and vice versa as depicted in the following figure:</p><p>
</p><div><img src="img/image00180.jpeg" alt="Cloud Node"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec10"/>The GoogleApiClient class</h2></div></div></div><p>We need to create an instance of the <code class="literal">GoogleApiClient</code> class, any time you want to make a connection to one of the Google APIs provided in the Google Play services library. The Google API client provides a common entry point to all Google Play services and manages the network connection between the user's device and each Google service.</p><p>We use this class to let our mobile device connect to the Wearable API in the Google Play services library in order to get access to connected wearables.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec11"/>The Volley library</h2></div></div></div><p>We will be using Volley to fetch HTML content from Wikipedia. You can read all about this HTTP library on the developer's web page (<a class="ulink" href="https://developer.android.com/training/volley/index.html">https://developer.android.com/training/volley/index.html</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec12"/>The JSoup library</h2></div></div></div><p>The JSoup library (<a class="ulink" href="https://jsoup.org">https://jsoup.org</a>) will be our preferred library to parse the HTML content feed that we pull from Wikipedia. Now, let's take a look at the code.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec13"/>The Build Script</h2></div></div></div><p>Study the dependencies specified in the <code class="literal">build.gradle</code> file of the mobile and companion apps respectively. Note how the mobile app's <code class="literal">build.gradle</code> file has the additional dependencies for <code class="literal">Volley</code> and <code class="literal">JSoup</code> libraries. Remember that the companion app has to do the heavy lifting:</p><pre class="programlisting">dependencies {     &#13;
  compile fileTree(dir: 'libs', include: ['*.jar'])     &#13;
  wearApp project(':wear')     &#13;
  testCompile 'junit:junit:4.12'&#13;
  compile 'com.android.support:appcompat-v7:23.4.0'&#13;
  compile 'com.google.android.support:wearable:2.0.0-alpha1'&#13;
  &#13;
  // This version should match the same version in wearable app&#13;
  compile 'com.google.android.gms:play-services-wearable:8.1.0'&#13;
  &#13;
  // Use volley to make HTTP requests&#13;
  compile 'com.android.volley:volley:1.0.0'&#13;
  &#13;
  // Use JSoup for parsing HTML data&#13;
  compile "org.jsoup:jsoup:1.8.1"&#13;
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec14"/>Companion app's Android manifest file</h2></div></div></div><p>Please have a look at the <code class="literal">AndroidManifest.xml</code> file<em> </em>of the companion app with a basic <code class="literal">TodayMobileActivity</code> and <code class="literal">HandheldListenerService</code> activities:</p><pre class="programlisting">&lt;manifest &#13;
package="com.siddique.androidwear.today"&gt;     &#13;
  &lt;uses-permission android:name="android.permission.INTERNET" /&gt;       &#13;
  &lt;application&#13;
    android:allowBackup="true"&#13;
    android:icon="@mipmap/ic_launcher"&#13;
    android:label="@string/app_name"&#13;
    android:supportsRtl="true"&#13;
    android:theme="@style/AppTheme"&gt;         &#13;
&#13;
  &lt;meta-data &#13;
    android:name="com.google.android.gms.version"   &#13;
    android:value="@integer/google_play_services_version" /&gt;         &#13;
&#13;
  &lt;activity&#13;
    android:name=".TodayMobileActivity"&#13;
    android:label="@string/app_name"&#13;
    android:windowSoftInputMode="stateHidden"&#13;
    android:configChanges="keyboardHidden|orientation|screenSize"  &gt;             &#13;
&#13;
    &lt;intent-filter&gt;                 &#13;
      &lt;action android:name="android.intent.action.MAIN" /&gt;                    &#13;
      &lt;category android:name="android.intent.category.LAUNCHER" /&gt;             &#13;
    &lt;/intent-filter&gt;&#13;
         &#13;
  &lt;/activity&gt;&#13;
&#13;
&lt;!— Listens for incoming messages from Wearable devices—&gt;&#13;
&#13;
  &lt;service android:name=".HandheldListenerService"&gt;             &#13;
    &lt;intent-filter&gt;                 &#13;
      &lt;action android:name="com.google.android.gms.wearable.DATA_CHANGED" /&gt;                 &#13;
      &lt;action android:name="com.google.android.gms.wearable.MESSAGE_RECEIVED" /&gt;                 &#13;
      &lt;data &#13;
        android:scheme="wear" &#13;
        android:host="*" &#13;
        android:pathPrefix="/today" /&gt;             &#13;
    &lt;/intent-filter&gt;         &#13;
  &lt;/service&gt;     &#13;
  &lt;/application&gt; &#13;
&lt;/manifest&gt;</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec15"/>The TodayMobileActivity class</h2></div></div></div><p>The <code class="literal">TodayMobileActivity</code> class is a convenience activity at this time, intended only to connect to any existing wearable devices paired with the mobile device. We will be running the mobile/companion app target on a mobile device:</p><pre class="programlisting">public class TodayMobileActivity extends Activity implements GoogleApiClient.ConnectionCallbacks,         GoogleApiClient.OnConnectionFailedListener &#13;
{&#13;
  private GoogleApiClient mGoogleApiClient;&#13;
  public static final String TAG = TodayMobileActivity.class.getName();&#13;
  private int CONNECTION_TIME_OUT_MS = 15000;&#13;
  private TextView devicesConnectedTextView = null;&#13;
  @Override&#13;
  protected void onCreate(Bundle savedInstanceState) &#13;
  {&#13;
    super.onCreate(savedInstanceState);         &#13;
    setContentView(R.layout.main);         &#13;
    Log.i(<em>TAG</em>, "Creating Google Api Client");&#13;
    mGoogleApiClient = new GoogleApiClient.Builder(this)                 &#13;
      .addApi(Wearable.<em>API</em>)                 &#13;
      .addConnectionCallbacks(this)                 &#13;
      .addOnConnectionFailedListener(this)                 &#13;
      .build();&#13;
    devicesConnectedTextView = (TextView) findViewById(R.id.devicesConnected);     &#13;
  }&#13;
&#13;
  @Override&#13;
  protected void onStart() &#13;
  {&#13;
    super.onStart();&#13;
    if (!mGoogleApiClient.isConnected()) &#13;
    {&#13;
      mGoogleApiClient.connect();         &#13;
    }     &#13;
  }&#13;
  @Override&#13;
  public void onConnected(Bundle connectionHint) &#13;
  {         &#13;
    Log.i(TAG, "Google Api Client Connected");&#13;
    new Thread(new Runnable() &#13;
    {&#13;
      @Override&#13;
      public void run() &#13;
      {&#13;
        mGoogleApiClient.blockingConnect(CONNECTION_TIME_OUT_MS, TimeUnit.MILLISECONDS);                 &#13;
        NodeApi.GetConnectedNodesResult result =                         Wearable.<em>NodeApi</em>.getConnectedNodes(mGoogleApiClient).await();&#13;
        final List&lt;Node&gt; nodes = result.getNodes();                 &#13;
        runOnUiThread(new Runnable() &#13;
        {&#13;
        public void run() &#13;
        {                         &#13;
          Log.i(<em>TAG</em>, "Connected devices = " + nodes.size());&#13;
        devicesConnectedTextView.setText(String.valueOf(nodes.size()));                     &#13;
        }                 &#13;
      });             &#13;
    }         &#13;
  }).&#13;
  start();     &#13;
  }      &#13;
  ...    &#13;
}</pre><p>Once we successfully connect with the wearable device, we should be able to see a confirmation that at least one device is connected, as shown in the following figure:</p><p>
</p><div><img src="img/image00181.jpeg" alt="The TodayMobileActivity class"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Users can launch the <code class="literal">TodayMobileActivity</code> class to see if the devices are connected or not. If the value shown against Devices connected is not greater than zero, then the mobile device is not paired successfully, meaning it is not connected to the wearable device or emulator. We will be expanding this activity more in future chapters.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec16"/>Wearable app's Android manifest file</h2></div></div></div><p>Here is the <code class="literal">AndroidManifest.xml</code> file for the wearable app with the three activities for the menu items, such as the <code class="literal">TodayActivity</code>, <code class="literal">DayOfYearActivity</code>, and <code class="literal">OnThisDayActivity</code> activities:</p><pre class="programlisting">&lt;manifest package="com.siddique.androidwear.today"&gt;     &#13;
  &lt;uses-feature android:name="android.hardware.type.watch" /&gt;       &#13;
  &lt;application&#13;
    android:allowBackup="true"&#13;
    android:icon="@mipmap/ic_launcher"&#13;
    android:label="@string/app_name"&#13;
    android:supportsRtl="true"&#13;
    android:theme="@android:style/Theme.DeviceDefault"&gt;&#13;
&#13;
&lt;!— We need this entry to use Google Play Services —&gt;&#13;
&#13;
  &lt;meta-data &#13;
    android:name="com.google.android.gms.version"   &#13;
    android:value="@integer/google_play_services_version" /&gt;         &#13;
&#13;
  &lt;activity&#13;
    android:name=".TodayActivity"&#13;
    android:label="@string/app_name"&gt;             &#13;
    &lt;intent-filter&gt;                 &#13;
      &lt;action android:name="android.intent.action.MAIN" /&gt;                 &#13;
      &lt;category android:name="android.intent.category.LAUNCHER" /&gt;             &#13;
    &lt;/intent-filter&gt;         &#13;
  &lt;/activity&gt;         &#13;
&#13;
  &lt;activity&#13;
    android:name=".DayOfYearActivity"&#13;
    android:label="@string/day_of_year_card_title" /&gt;         &#13;
&#13;
  &lt;activity&#13;
    android:name=".OnThisDayActivity"&#13;
    android:label="@string/on_this_day_title" /&gt;     &#13;
  &lt;/application&gt; &#13;
&lt;/manifest&gt;</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec17"/>The OnThisDayActivity class</h2></div></div></div><p>The <code class="literal">OnThisDayActivity</code> class sends a message to the mobile device (that is, the companion app) using the <code class="literal">GoogleApiClient</code> API, saying that it needs to fetch content from Wikipedia.</p><p>Take note of the <code class="literal">onDataChanged</code> handler method defined in this activity. The <code class="literal">onDataChanged</code> method is the callback listener that gets processed when the companion app sends data packets back to the wearable device:</p><pre class="programlisting">public class OnThisDayActivity extends Activity implementsDataApi.DataListener, GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener &#13;
{&#13;
  private GoogleApiClient mGoogleApiClient;private boolean mResolvingError;&#13;
  private static final String TAG = OnThisDayActivity.class.getName();&#13;
  private OnThisDay onThisDay = null;&#13;
  @Override&#13;
  protected void onCreate(Bundle savedInstanceState) &#13;
  {&#13;
    super.onCreate(savedInstanceState);         &#13;
    setContentView(R.layout.activity_on_this_day);&#13;
    if (onThisDay == null) &#13;
    {             &#13;
      Toast.makeText(this, "Fetching from Wikipedia...", Toast.LENGTH_LONG).show();&#13;
      mGoogleApiClient = new GoogleApiClient.Builder(this)                     &#13;
        .addApi(Wearable.API)                     &#13;
        .addConnectionCallbacks(this)                     &#13;
        .addOnConnectionFailedListener(this)                     &#13;
        .build();         &#13;
    } &#13;
    else &#13;
    {             &#13;
      showOnThisDay(onThisDay);         &#13;
    }     &#13;
  }&#13;
  @Override&#13;
  protected void onStart() &#13;
  {&#13;
    super.onStart();&#13;
    if (!mResolvingError &amp;&amp; onThisDay == null) &#13;
    {             &#13;
      Log.i(TAG, "Connecting to Google Api Client");&#13;
      mGoogleApiClient.connect();&#13;
    } &#13;
    else &#13;
    {             &#13;
      showOnThisDay(onThisDay);         &#13;
    }     &#13;
  }&#13;
  @Override&#13;
  public void onConnected(Bundle connectionHint) &#13;
  {         &#13;
    Log.i(TAG, "Connected to Data Api");         &#13;
    Wearable.DataApi.addListener(mGoogleApiClient, this);&#13;
<em>// send a message to the companion app that it needs to fetch data </em>&#13;
    sendMessage(Constants.ON_THIS_DAY_REQUEST, "OnThisDay".getBytes());        &#13;
  }&#13;
  private void sendMessage(final String path, final byte[] data) &#13;
  {         &#13;
    Log.i(TAG, "Sending message to path " + path);          &#13;
 Wearable.NodeApi.getConnectedNodes(mGoogleApiClient).setResultCallback (new ResultCallback&lt;NodeApi.GetConnectedNodesResult&gt;() &#13;
    {&#13;
    @Override&#13;
    public void onResult(NodeApi.GetConnectedNodesResult nodes) &#13;
    {&#13;
      for (Node node : nodes.getNodes()) &#13;
      {                             &#13;
        Wearable.MessageApi.sendMessage(mGoogleApiClient, node.getId(), path, data);                         &#13;
      }                     &#13;
    }                 &#13;
  });     &#13;
}&#13;
&#13;
@Override&#13;
public void onConnectionSuspended(int i) &#13;
{         &#13;
  Log.i(TAG, "Connection Suspended");     &#13;
}&#13;
&#13;
@Override&#13;
protected void onStop() &#13;
{&#13;
  if (null != mGoogleApiClient &amp;&amp; mGoogleApiClient.isConnected()) &#13;
  {             &#13;
    Wearable.DataApi.removeListener(mGoogleApiClient, this);&#13;
    mGoogleApiClient.disconnect();         &#13;
  }&#13;
  super.onStop();     &#13;
}&#13;
@Override&#13;
public void onDataChanged(DataEventBuffer dataEvents) &#13;
{         &#13;
  Log.i(TAG, "###### onDataChanged");&#13;
  for (DataEvent event : dataEvents) &#13;
  {&#13;
  if (event.getType() == DataEvent.TYPE_CHANGED) &#13;
  {                 &#13;
    DataItem dataItem = event.getDataItem();                 &#13;
    DataMap dataMap = DataMapItem.fromDataItem(dataItem).getDataMap();                 &#13;
    String heading = dataMap.get(Constants.ON_THIS_DAY_DATA_ITEM_HEADER);                 &#13;
    ArrayList&lt;String&gt; listItems = dataMap.get(Constants.ON_THIS_DAY_DATA_ITEM_CONTENT);&#13;
    onThisDay = new OnThisDay(heading, listItems);                 &#13;
    showOnThisDay(onThisDay);             &#13;
    }         &#13;
  }     &#13;
}&#13;
private void showOnThisDay(OnThisDay onThisDay) &#13;
{         &#13;
  TextView heading = (TextView) findViewById(R.id.on_this_day_heading);         &#13;
  heading.setText(Html.fromHtml(onThisDay.getHeadingHtml()));         &#13;
  TextView content = (TextView) findViewById(R.id.on_this_day_content);         &#13;
  content.setText(Html.fromHtml(onThisDay.getListItemsHtml()));     &#13;
}&#13;
&#13;
@Override&#13;
public void onConnectionFailed(@NonNull ConnectionResult connectionResult) &#13;
{         &#13;
  Log.i(TAG, "Connection Failed " + connectionResult);&#13;
  mResolvingError = true;     &#13;
  } &#13;
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec18"/>The HandheldListenerService class</h2></div></div></div><p>The <code class="literal">HandheldListenerService</code> class listens for messages coming from the wearable device. When a message is received, the <code class="literal">onMessageReceived</code> handler checks to see if the message is a request for content and if it is, it invokes a helper to read the feed and parse the response accordingly:</p><pre class="programlisting">public class HandheldListenerService extends WearableListenerService implements GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener &#13;
{&#13;
  ...&#13;
  @Override&#13;
  public void onMessageReceived(MessageEvent messageEvent)   &#13;
  {&#13;
    super.onMessageReceived(messageEvent);     &#13;
    Log.i(TAG, "Message received" + messageEvent);&#13;
    if (Constants.ON_THIS_DAY_REQUEST.equals(messageEvent.getPath()))   &#13;
    {&#13;
      //read Today's content from Wikipedia&#13;
      getOnThisDayContentFromWikipedia();     &#13;
    } &#13;
  }&#13;
  private void getOnThisDayContentFromWikipedia() &#13;
  {&#13;
    // Instantiate the RequestQueue&#13;
    RequestQueue queue = Volley.newRequestQueue(this);     &#13;
    String url = "https://en.wikipedia.org/wiki/Special:FeedItem/onthisday/" + DATE_FORMAT.format(new Date()) + "000000/en";&#13;
    // Request a string response from the provided URL.&#13;
    StringRequest stringRequest = new StringRequest(Request.Method.GET, url,new Response.Listener&lt;String&gt;() &#13;
    {&#13;
      @Override&#13;
      public void onResponse(String response) &#13;
      {                     &#13;
        Log.i(TAG, "Wikipedia response  = " + response);                      &#13;
        Document doc = Jsoup.parse(response);                     &#13;
        Element heading = doc.select("h1").first();                     &#13;
        Log.i(TAG, "Heading node = " + heading);if (heading != null) &#13;
        {&#13;
          Log.i(TAG, "Wikipedia page heading = " + heading);                          &#13;
          PutDataMapRequest dataMapRequest = PutDataMapRequest.create(Constants.ON_THIS_DAY_DATA_ITEM_HEADER);                         &#13;
          DataMap dataMap = dataMapRequest.getDataMap();&#13;
// We add a timestamp is to make this dataMap 'dirty'. This lets the wearable get updates&#13;
         dataMap.putLong(Constants.ON_THIS_DAY_TIMESTAMP, new Date().getTime());                          &#13;
         dataMap.putString(Constants.ON_THIS_DAY_DATA_ITEM_HEADER, heading.text());                         &#13;
         Element listNode = doc.select("ul").first();if (listNode != null) &#13;
      {                             &#13;
        Elements itemNodes = listNode.select("li");int size = itemNodes.size();                             &#13;
        ArrayList&lt;String&gt; items = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; size; i++) &#13;
       {                                   &#13;
         items.add(itemNodes.get(i).text());                             &#13;
       }                             &#13;
    dataMap.putStringArrayList(Constants.ON_THIS_DAY_DATA_ITEM_CONTENT, items);                         &#13;
    }                         &#13;
    Log.i(TAG, "Sending dataMap request ...");                         &#13;
    PendingResult&lt;DataApi.DataItemResult&gt; pendingResult = Wearable.DataApi.putDataItem(mGoogleApiClient,   dataMapRequest.asPutDataRequest());                         &#13;
    PendingResult.setResultCallback(new ResultCallback&lt;DataApi.DataItemResult&gt;() &#13;
    {&#13;
      @Override&#13;
      public void onResult(final DataApi.DataItemResult result) &#13;
      {&#13;
        if (result.getStatus().isSuccess()) &#13;
        {                                     &#13;
         Log.d(TAG, "Data item set: " + result.getDataItem().getUri());                                      &#13;
        }                             &#13;
      }                         &#13;
    });                     &#13;
  }                 &#13;
}             &#13;
}, &#13;
new Response.ErrorListener() &#13;
{&#13;
  @Override&#13;
  public void onErrorResponse(VolleyError error) &#13;
  {             &#13;
    Log.e(TAG, "Error reading online content = " + error);         &#13;
  }     &#13;
});&#13;
// Add the request to the RequestQueue.&#13;
queue.add(stringRequest); &#13;
}</pre><p>As you can see, the code snippets provided here are incomplete and are intended only as a quick reference. You are encouraged to download and play with the latest code from GitHub.</p><p>If you run the app on your wearable device, this is what you will see:</p><p>
</p><div><img src="img/image00182.jpeg" alt="The HandheldListenerService class"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see in the preceding screenshot, we show a <em>Toast</em> message while requesting to fetch <em>On This Day </em>content from Wikipedia using the handheld device's companion app:</p><p>
</p><div><img src="img/image00183.jpeg" alt="The HandheldListenerService class"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Note that in our <code class="literal">activity_on_this_day</code> XML layout, we nest our <code class="literal">TextView</code> layout within a <code class="literal">ScrollView</code> layout, which effectively allows us to scroll through all of our feed items. This begs a discussion of the UX aspects of wearable app development. We can certainly utilize better UI components to do what we just did. More on this in future chapters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Messages not coming through to your Wear app?</h1></div></div></div><p>This can be frustrating, which is why we thought to mention it. If you see any synchronization issues whereby messages are not coming through to your wear application, check that the version of your Google Play services module matches between your companion app and wearable app <code class="literal">AndroidManifest.xml</code> files. Having different versions can lead to this sort of unexpected behavior and cost you hours in wasteful debugging. Consider the following screenshot of the Android Studio window:</p><p>
</p><div><img src="img/image00184.jpeg" alt="Messages not coming through to your Wear app?"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>We described the need for a companion handheld app and stepped through creating an Android Wear virtual device and pairing a handheld device with it. We then created a new <code class="literal">Today</code> app that pulls content from a public feed page via the companion app and pushes results to the wearable device.</p><p>In the next chapter, we will introduce context-aware notifications and voice interactions, which power a rich user experience with Android Wear.</p></div></body></html>