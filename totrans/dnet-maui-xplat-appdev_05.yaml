- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring MVVM and Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored how to construct **user interfaces** (**UIs**)
    using XAML. In this chapter, we will dive into the **Model-View-View-Model** (**MVVM**)
    pattern and data binding. The MVVM pattern, a widely adopted architectural pattern,
    is key in creating maintainable, scalable, and testable applications. In the context
    of .NET MAUI, MVVM separates the user interface logic, data, and the app’s structure
    into three distinct components: Model, View, and ViewModel. This separation leads
    to a clean and organized codebase, making it easier to develop and maintain the
    application. Data binding is a technique that connects the view (UI) with the
    ViewModel in a way that the UI reflects the ViewModel’s data and changes synchronously
    and automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our initial focus will be on introducing **MVVM** and data
    binding. For a better design and cleaner code, we will employ the MVVM Toolkit,
    part of the .NET Community Toolkit. The use of the MVVM Toolkit results in more
    concise and clean ViewModel code.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, a majority of the logic is implemented in the model
    and service layers. Without a more complex model layer, we cannot delve into complicated
    topics about MVVM and data binding. Therefore, in the second half of this chapter,
    we present the actual model layer, which includes two .NET libraries, **KPCLib**
    and **PassXYZLib**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the real model layer in place, we introduce two advanced topics in data
    binding: binding to collections and using custom views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **MVVM** and **MVC**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Community Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the data model and service layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MVVM and MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software design, we usually follow and reuse good practices and design patterns.
    The **Model-View-Controller** (**MVC**) pattern is an approach to decoupling the
    responsibilities of a system. It can help to separate the implementation of the
    UI and the business logic into different parts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The MVC pattern](img/B21554_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The MVC pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC pattern, as shown in *Figure 4.1*, divides the responsibilities of
    the system into three distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model:** The model represents the data and the business logic of the application.
    It is responsible for storing the app’s data, handling data validation, and performing
    any necessary data processing. Model classes typically interact with data sources,
    such as databases, web APIs, or file storage, to fetch and store data. Model classes
    usually can be implemented as **Plain Old CLR Objects** (**POCOs**) or **Data
    Transfer Objects** (**DTOs**). POCO is a class that doesn’t depend on any framework-specific
    classes, so POCO classes can be used with LINQ or Entity Framework well. DTO is
    a subset of a POCO class that only contains data without logic or behavior. DTO
    classes can be used to pass data between layers. The model has no dependency on
    the view or the controller so it can be implemented and tested separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View:** The view is responsible for the app’s user interface and user interaction.
    The view should not contain any business logic or direct data processing. Instead,
    it displays data and interface elements to the user and captures their input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller:** The controller updates the model and view in response to the
    user’s action. Our understanding of the model and the view hasn’t changed too
    much over time, but there have been different understandings and implementations
    of the controller since the MVC pattern was introduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVVM pattern was inspired by the MVC pattern, but it aimed to provide an
    improved approach specifically for UI development in XAML-based applications.
    With the rise of XAML-based UI frameworks, MVVM gained traction and became the
    de facto pattern for WPF, Silverlight, and later Xamarin.Forms applications.
  prefs: []
  type: TYPE_NORMAL
- en: With the evolution of Xamarin.Forms into .NET MAUI, MVVM continues to be a prominent
    pattern in multi-platform mobile and desktop application development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: The MVVM pattern](img/B21554_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The MVVM pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in *Figure 4.2*, in MVVM, the ViewModel is used to replace the
    controller. The differences between MVVM and MVC are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoupling of view and model**: The ViewModel is used to handle the communication
    between the view and the model. The view accesses the data and logic in the model
    via the ViewModel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data binding between the view and ViewModel**: Using data binding, changes
    to the view or ViewModel can automatically be updated in the other one. This can
    help to reduce the complexity of implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both MVC and MVVM, the model can be tested separately. In MVVM, it is possible
    to design unit tests for the ViewModel as well.
  prefs: []
  type: TYPE_NORMAL
- en: When the view changes, the changes will be reflected in the ViewModel via data
    binding. The ViewModel will process the data changes in the model. Similarly,
    when the data changes in the model, the ViewModel is notified to update the view.
    The common solution for notifications is to install event handlers that prompt
    the notifications. With data binding, the implementation is simplified significantly.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM in PassXYZ.Vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our app, `PassXYZ.Vault`, we use MVVM to handle the data exchange between
    the view and the ViewModel. As we can see in *Figure 4.3*, we have five XAML content
    pages and the same number of ViewModels defined. In our model, we have an `Item`
    class, which is our model class, and it can be accessed through the **IDataStore**
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: MVVM in PassXYZ.Vault](img/B21554_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: MVVM in PassXYZ.Vault'
  prefs: []
  type: TYPE_NORMAL
- en: Data binding is used as the communication channel between views and ViewModels.
    The ViewModel will update the `Item` model via the **IDataStore** service interface.
    We will learn how to use data binding in the next section by analyzing the `ItemDetailPage`
    and `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s explore how MVVM and data binding works. We can use an item detail page
    implementation in our app to analyze **how data binding works**. The following
    list includes the view, ViewModel, and model that we are going to explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: `ItemDetailPage`, see *Listing 3.4* in the previous chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**: `ItemDetailViewModel`, see *Listing 4.1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: `Item` (access through the **IDataStore** interface), see *Listing
    3.3* in the previous chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ItemDetailPage` is a view used to display the content of an instance of `Item`.
    The data is retrieved from the ViewModel. The UI elements presenting the content
    of `Item` are connected to the ViewModel instance through data binding.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a binding object  Description automatically generated](img/B21554_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Data binding'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4.4*, data binding is used to synchronize the properties
    of target and source objects. There are three objects involved in data binding
    and they are the `binding target`, `binding source`, and `binding object`.
  prefs: []
  type: TYPE_NORMAL
- en: Binding object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 4.4*, the object of the `Binding` class (`Microsoft.Maui.Controls.Binding`)
    represents the connection between the target property (in the View) and the source
    property (in the ViewModel). It manages the synchronization of property values
    and handles the communication between the source and the target. The binding object
    is created when you define a binding expression in your XAML markup or create
    a binding in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of creating a binding object in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of creating a binding object in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Binding target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 4.4*, the target refers to the UI element (control) in the view that
    is bound to the ViewModel property. More specifically, the target is the property
    of the UI element involved in the binding. Examples of target properties include
    `Text` on a `Label` or `Entry`, `Source` on an `Image`, and `IsEnabled` on a `Button`.
    The target property must be a bindable property to participate in data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Binding source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source is the object containing the property that is bound to the target
    property in the view. Typically, the source object is the ViewModel, which should
    be set as the `BindingContext` of the view or one of its parents. The ViewModel
    exposes properties that define their data type, getter, and setter methods. The
    source property is identified through the Binding Path in the binding expression.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a binding expression in XAML or create a binding object in code,
    a binding object is created and set for the specified target property. The XAML
    parser or the binding system creates the binding object and initializes it with
    the provided binding properties, such as `Path`, `Source`, `Mode`, `Converter`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of involved properties of target and source objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target** – This is the UI element involved and this UI element has to be
    a child of `BindableObject`. The UI element used in `ItemDetailPage` is `Label`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target property** – This is the property of the target object. It is a `BindableProperty`.
    If the target is `Label`, as we mentioned here, the target property can be the
    `Text` property of `Label`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source** – This is the source object referenced by data binding. It is `ItemDetailViewModel`
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source object value path** – This is the path to the value in the source
    object. Here, the path is a `ViewModel` property, such as `Name` or `Description`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the following code in `ItemDetailPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the XAML here, there are two data binding source paths, which are `Name`,
    **(1)**, and `Description`, **(2)**. The binding target is `Label` and the target
    property is the `Text` property of `Label`. If we review the inheritance hierarchy
    of `Label`, it looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `Element`, `VisualElement`, and `View` are the derivatives of
    `BindableObject`. The data binding target has to be a child of `BindableObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding source is the `Name`, **(1)**, and `Description`, **(2)**, properties
    of the ViewModel as shown in *Listing 4.1* here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.1: `ItemDetailViewModel.cs` ([https://epa.ms/ItemDetailViewModel4-1](https://epa.ms/ItemDetailViewModel4-1))'
  prefs: []
  type: TYPE_NORMAL
- en: The values of `Name`, **(1)**, and `Description`, **(2)**, are loaded from the
    model in the `LoadItemId()` method, **(3)**. You may notice that the class is
    decorated by a `QueryPropertyAttribute` attribute. This is used to pass parameters
    during page navigation, and it will be introduced in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the following, *Table 4.1*, to summarize the data binding components
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data binding elements** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Target | `Label` |'
  prefs: []
  type: TYPE_TB
- en: '| Target property | `Text` |'
  prefs: []
  type: TYPE_TB
- en: '| Source object | `ItemDetailViewModel` |'
  prefs: []
  type: TYPE_TB
- en: '| Source object value path | `Name` or `Description` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Data binding settings'
  prefs: []
  type: TYPE_NORMAL
- en: Properties of a Binding object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having analyzed the preceding code, let us have a look at the syntax of the
    binding expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Binding properties can be set as a series of name-value pairs in the form of
    `bindProp=value`. For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Path` property is the default property, and it can be omitted if it is
    the first one in the property list as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The binding properties that we mentioned here are the properties of the `Binding`
    class, and you can find the details by referring to the Microsoft document about
    the `Binding` class here: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding](https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding).'
  prefs: []
  type: TYPE_NORMAL
- en: As well as the `Path` property, let’s review another two important binding properties,
    `Source` and `Mode`.
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Source` property represents the object containing the source property (which
    will be bound to the target property). By default, the source object is the `BindingContext`
    of the element, which is typically the ViewModel. However, you can use the `Source`
    property to bind to other objects if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we set data binding to the target, we can use the following two members
    of the target class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `BindingContext` property gives us the source object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SetBinding` method specifies the target property and source property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we set the `BindingContext` property to an instance of `ItemDetailViewModel`,
    **(1)**, in the C# code-behind file of `ItemDetailPage`, as shown in *Listing
    4.2* here. It is set at the page level, and it applies to all binding targets
    on this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.2: `ItemDetailPage.xaml.cs` ([https://epa.ms/ItemDetailPage4-2](https://epa.ms/ItemDetailPage4-2))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `Binding` markup extension, we can also create the binding
    using the `SetBinding` method directly, as done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**(2)** In the XAML code, we removed the `Binding` markup extension and specified
    the instance name as `labelText`. In the C# code-behind file, we can call the
    `SetBinding` method, **(3)**, in the constructor of `ItemDetailPage` to create
    the data binding for the `Text` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Binding mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Mode` property specifies the direction of data flow in the binding, such
    as if data flows only from the ViewModel to the UI or if it flows in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: In `ItemDetailPage`, all UI elements are `Label` objects, which are not editable
    for the user. This is one-way binding from the source to the target. The changes
    in the source object will cause updates in the target object.
  prefs: []
  type: TYPE_NORMAL
- en: There are four binding modes supported in .NET MAUI. Let’s review them by referring
    to *Figure 4.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Binding mode](img/B21554_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Binding mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the binding modes supported in `.NET MAUI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OneWay` binding is usually used in the case of presenting data to the user.
    In our app, we will retrieve a list of password entries and display this list
    on `ItemsPage`. When the user clicks an item in the list, the password details
    will show on `ItemDetailPage`. `OneWay` binding is used in both cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoWay` binding causes changes to either the source property or the target
    property to automatically update the other. In our app, when the user edits the
    fields of a password entry or when the user enters a username and password on
    `LoginPage`, the target UI `Entry` component and the source view model object
    are set with `TwoWay`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneWayToSource` is the reverse of the `OneWay` binding mode. When the target
    property is changed, the source property will be updated. When we add a new password
    entry on `NewItemPage`, we can use `OneWayToSource` instead of the `TwoWay` binding
    mode to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneTime` binding is a binding mode that is not shown in *Figure 4.4*. The
    target properties are initialized from the source properties, but any further
    changes to the source properties won’t update the target properties. It is a simpler
    form of the `OneWay` binding mode with better performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we don’t specify the binding mode in data binding, the default binding mode
    is used. We can overwrite the default binding mode if it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ItemsPage` code, we use the `ListView` control to display the list
    of password groups and entries, so we should set the `IsRefreshing` attribute
    to the `OneWay` binding mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add a new item in `NewItemPage`, we use the `Entry` and `Editor` controls
    to edit the properties. We can use the `OneWayToSource` or `TwoWay` binding modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Changing notifications in ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 4.5*, we can see the data binding target is a derived class of `BindableObject`.
    Besides this requirement, in the data binding setup, the data source (ViewModel)
    needs to implement the `INotifyPropertyChanged` interface so that when the property
    changes, a `PropertyChanged` event is raised to notify the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an MVVM pattern, the ViewModel is usually the data binding source so we
    need to implement the `INotifyPropertyChanged` interface in our ViewModels. If
    we do this for each ViewModel class, there will be a lot of duplicated code. In
    a Visual Studio template, a `BaseViewModel` class, as we can see in *Listing 4.3*,
    is included in the boilerplate code and we use it in our app. Other ViewModels
    inherit this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Listing 4.3 `BaseViewModel.cs` ([https://epa.ms/BaseViewModel4-3](https://epa.ms/BaseViewModel4-3))
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BaseViewModel` class (*Listing 4.3*), we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `BaseViewModel` implements the `INotifyPropertyChanged` interface and
    this interface defines a single event, `PropertyChanged`, **(4)**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** When a property is changed in the setter, the `OnPropertyChanged` method
    is called. In `OnPropertyChanged`, the `PropertyChanged` event is fired. A copy
    of the `PropertyChanged` event handler is stored in the **changed** local variable,
    so this implementation is safe in a multi-thread environment. When the `PropertyChanged`
    event is fired, it needs to pass the property name as a parameter to indicate
    which property is changed. The `CallerMemberName` attribute can be used to find
    the method name or property name of the caller, so we don’t need to hardcode the
    property name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** When we define a property in the ViewModel, the `OnPropertyChanged`
    method is called in the setter – but as you can see, in our code, we call `SetProperty<T>`
    instead of `OnPropertyChanged` directly. `SetProperty<T>` will do additional work
    before it calls `OnPropertyChanged`. It checks whether the value is changed. If
    there is no change, it will return and do nothing. If the value is changed, it
    will update the backing field and call `OnPropertyChanged` to fire the change
    event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we recall `ItemDetailViewModel` in *Listing 4.1*, it inherits from the `BaseViewModel`
    class. In the setter of the `Name` and `Description` properties, we call `SetProperty<T>`
    to set the values and fire the `PropertyChanged` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned about data binding and the `INotifyPropertyChanged`
    interface. We need to create boilerplate code to define a property with change
    notification support. To simplify the code and autogenerate boilerplate code behind
    the scenes, we can use the MVVM Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Community Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the MVVM Toolkit to refactor our ViewModel code.
    The MVVM Toolkit is a module within the .NET Community Toolkit, specifically designed
    for building applications following the MVVM design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Community Toolkit (formerly Windows Community Toolkit) is a collection
    of helper functions, custom controls, and app services designed to simplify and
    accelerate .NET app development. The toolkit is open source and maintained by
    the community, offering a suite of tools for various .NET development platforms,
    such as .NET MAUI, Xamarin, UWP, WPF, and WinUI. The toolkit provides useful components
    that developers can use out of the box to easily build applications with a rich
    user interface, common app services, animations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit supplies a set of base classes, utilities, and attributes
    that make implementing the MVVM pattern in your .NET applications more efficient
    and straightforward. The MVVM Toolkit provides the following key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ObservableObject`: A base class that simplifies the implementation of objects
    that raise PropertyChanged events, such as ViewModels. It implements the `INotifyPropertyChanged`
    interface and provides the `SetProperty` method to handle property change notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelayCommand` and `AsyncRelayCommand`: Classes implementing the `ICommand`
    interface, designed to handle executing methods and checking if a command can
    execute. They make it easy to create commands for your ViewModel that react to
    UI actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency** **Injection** **support**: The MVVM Toolkit offers built-in
    support for dependency injection, making it simple to integrate services into
    your ViewModels using popular dependency injection libraries like `Microsoft.Extensions.DependencyInjection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messenger** (**Event Aggregator**): The MVVM Toolkit provides a lightweight
    messenger service that enables decoupled, message-based communication between
    components, like different ViewModels. This promotes a separation of concerns
    and makes each component more testable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please find more information about the MVVM Toolkit in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to use the MVVM Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the MVVM Toolkit in .NET MAUI, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the .NET `CommunityToolkit.Mvvm` NuGet package to our project file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refactor ViewModel using MVVM Toolkit Source Generators. Source Generators is
    a C# compiler feature that allows executing custom code at compile time to modify
    the compilation output. The MVVM Toolkit supports using Source Generators to automatically
    generate ViewModel and `ICommand` boilerplate code based on attributes, which
    can simplify ViewModel creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit can help us to simplify ViewModel by using Source Generators.
    If we want to add a property in ViewModel as a data binding source, we need to
    implement the `INotifyPropertyChanged` interface. For example, in `ItemDetailViewModel`,
    we implement the `Description` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the Setter, the `SetProperty` method is called, and it will update the backing
    field and call `OnPropertyChanged` to fire the change event. Both `SetProperty`
    and `OnPropertyChanged` are defined in the `BaseViewModel` class, as we can see
    in *Listing 4.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the MVVM Toolkit, we can inherit from `ObservableObject` instead of `BaseViewModel`.
    `ObservableObject` implements the `INotifyPropertyChanged` interface similar to
    what we have done in `BaseViewModel`. With `ObservableObject`, we can simplify
    the above implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, using the `ObservableProperty`attribute, we can define the backing
    field only in the code. Source Generators will help us to generate boilerplate
    code. We can use the `Description` property in XAML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the MVVM pattern, we can define a ViewModel property as an observable property
    to support TwoWay binding. We can also define a ViewModel property as an `ICommand`
    interface to handle UI events using data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we display a list of items in `ItemsPage`. In `ItemsPage`, we need
    to load a list of items from the data source, and we also need to support adding
    a new item. We need to define two `ICommand` interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the above implementation, we define two properties, `LoadItemsCommand`**(1)**
    and `AddItemCommand`**(2)**, as the type `Microsoft.Maui.Controls.Command`. In
    the constructor of ViewModel, we initialize them**(3)(4)** with the private methods
    `LoadItems`**(5)** and `AddItem`**(6)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the MVVM Toolkit, we can simplify the implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we just need to add `RelayCommandAttribute` in front of `AddItem`
    `(1)` and `LoadItems` `(2)` to implement `ICommand` properties. Source Generators
    will help us generate the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced the basic knowledge of XAML UI design, the MVVM pattern, and
    data binding, we can improve our app using the knowledge we just learned.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the data model and service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing the MVVM pattern, data binding, and the MVVM Toolkit, we have
    the fundamental knowledge of how to use data binding. In the rest of this chapter,
    we will explore advanced topics about data binding. We will discuss how to bind
    to collections first and then we will introduce custom views. Using custom views,
    we can make XAML code cleaner and more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine these topics, a more intricate model layer is required. Instead
    of creating a hypothetical model layer, we’ll work with the actual model layer
    in our app, which includes two .NET libraries: **KPCLib** and **PassXYZLib**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce the model layer of our app, let us review the use cases again.
    We are developing a cross-platform password manager app that is compatible with
    the popular **KeePass** database format. We have the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case 1**: `LoginPage` – As a password manager user, I want to log in
    to the password manager app so that I can access my password data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 2**: `AboutPage` – As a password manager user, I want to have an
    overview of my database and the app that I am using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 3**: `ItemsPage` – As a password manager user, I want to see a list
    of groups and entries so that I can explore and examine my password data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 4**: `ItemDetailPage` – As a password manager user, I want to see
    the details of a password entry after I select it in the list of password entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 5**: `NewItemPage` – As a password manager user, I want to add a
    password entry or create a new group in my database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These five use cases are inherited from the Visual Studio template, and they
    are sufficient for the user stories of our password manager app for the moment.
    We will improve our app using these user stories in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented our app using the MVVM pattern, but the `Item` model below is
    too simple and is not sufficient to be used in a password manager app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The major functionalities of our password manager app are encapsulated in the
    model layer. We will build our model using two .NET packages, KPCLib and PassXYZLib.
    These two packages include all the password management features we need.
  prefs: []
  type: TYPE_NORMAL
- en: KPCLib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model that we will use is a library from **KeePass** called `KeePassLib`.
    Both KeePass and `KeePassLib` are built for .NET Framework, so they can only be
    used on Windows. I ported `KeePassLib` and rebuilt it as a .NET Standard 2.0 library
    packaged as KPCLib. KPCLib can be found on NuGet and GitHub here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NuGet: [https://www.nuget.org/packages/KPCLib/](https://www.nuget.org/packages/KPCLib/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/passxyz/KPCLib](https://github.com/passxyz/KPCLib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KPCLib is used both as a package name and a namespace. The package of KPCLib
    includes two namespaces, `KeePassLib` and `KPCLib`. The `KeePassLib` namespace
    is the original one from KeePass with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Updated and built for .NET Standard 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated `PwEntry` and `PwGroup` to be classes derived from the `Item` abstract
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the KPCLib namespace, an `Item` abstract class is defined. The reason I created
    a new class and made it the parent class of `PwEntry` and `PwGroup` is due to
    the navigation design difference between `KeePass` and `PassXYZ.Vault`.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the UI of KeePass in *Figure 4.5*, we can see that it is a classic
    Windows desktop UI. The navigation is designed around a tree view like Windows
    Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: KeePass UI](img/B21554_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: KeePass UI'
  prefs: []
  type: TYPE_NORMAL
- en: Two classes, `PwGroup` and `PwEntry`, behave like directories and files. A `PwGroup`
    instance is just like a directory, and it includes a list of children – `PwGroup`
    and `PwEntry`. All `PwGroup` instances are displayed in a tree view on the right-hand
    panel. When a `PwGroup` instance is selected, the list of `PwEntry` in this group
    is shown on the right-hand panel. `PwEntry` includes the content of a password
    entry, such as a username and password. The content of `PwEntry` is displayed
    on the bottom panel.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PassXYZ.Vault` UI design, we use a .NET MAUI Shell template. It is an
    implementation of the stacked Master-Detail pattern. In the stacked Master-Detail
    pattern, a single list is used to display items. In this case, the instances of
    both `PwGroup` and `PwEntry` can be displayed in the same list. After an item
    is selected, we will take an action according to the type of the item.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of PwGroup and PwEntry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with the PassXYZ.Vault UI design better, we can abstract `PwGroup` and
    `PwEntry` as the `Item` abstract class, as shown in *Figure 4.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Class diagram of Item](img/B21554_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Class diagram of Item'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the UML class diagram in *Figure 4.7* and the source code of `Item.cs`
    in *Listing 4.4*, we can see the following properties are defined in the `Item`
    abstract class. These properties are implemented in both `PwEntry` and `PwGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `Name`: the `Item` name'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** `Description`: the `Item` description'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `Notes`: `Item` comments defined by the user'
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** `IsGroup`: `true` if the instance is `PwGroup` or `false` if it is
    `PwEntry`'
  prefs: []
  type: TYPE_NORMAL
- en: '**(5)** `Id`: ID of the instance (a unique value that is like the primary key
    in a database)'
  prefs: []
  type: TYPE_NORMAL
- en: '**(6)** `ImgSource`: image source of the icon (both `PwGroup` and `PwEntry`
    can have an associated icon)'
  prefs: []
  type: TYPE_NORMAL
- en: '**(7)** `LastModificationTime`: the last modification time of the item'
  prefs: []
  type: TYPE_NORMAL
- en: '**(8)** `Item`: implements the `INotifyPropertyChanged` interface, and it can
    work well in the MVVM model for data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.4: `Item.cs` ([https://epa.ms/Item4-4](https://epa.ms/Item4-4))'
  prefs: []
  type: TYPE_NORMAL
- en: PassXYZLib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use KeePassLib in `PassXYZ.Vault`, we need to use some .NET MAUI APIs to
    extend the functionalities required of our app. To separate the business logic
    from the UI and extend the functionalities of `KeePassLib` for .NET MAUI, a .NET
    MAUI class library, PassXYZLib, is created to encapsulate the extended model in
    a separate library. PassXYZLib is both a package name and a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add PassXYZLib to our project, we can add it to a `PassXYZ.Vault.csproj`
    project file, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add a PassXYZLib package from the command line here. From the command
    line, go to the project folder and execute this command to add the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Updating the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we add a PassXYZLib package to the project, we can access the KPCLib,
    `KeePassLib`, and `PassXYZLib` namespaces. To replace the current model, we need
    to remove the `Models/Item.cs` file from the project.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to replace the `PassXYZ.Vault.Models` namespace with KPCLib.
    In *Figure 4.8a*, we can see that the `Item` in namespace `PassXYZ.Vault.Models`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_04_08a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8a: PassXYZ.Vault.Models before update to KPCLib'
  prefs: []
  type: TYPE_NORMAL
- en: After the `PassXYZ.Vault.Models` namespace is replaced, in *Figure 4.8b*, the
    `Item` from the `KBCLib` namespace is utilized. Comparing the implementation before
    and after the transition, we can observe that the rest of the code remains largely
    unchanged. By adopting the MVVM pattern, most of the business logic is encapsulated
    within the model layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_04_08b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8b: Updated to KPCLib'
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining changes in view models and views, all modifications pertain
    to namespace changes, so further explanations aren’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The major changes can be found in `MockDataStore.cs`. In the `MockDataStore`
    class, we changed the namespace and the mock data initialization.
  prefs: []
  type: TYPE_NORMAL
- en: To decouple the model from the rest of the system, we use an `IDataStore` interface
    to encapsulate the actual implementation. At this stage, we use mock data to implement
    the service for testing, so the `MockDataStore` class is used. We will replace
    it with the actual implementation in *Chapter 6*, *Software Design with Dependency
    Injection,* using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency inversion and dependency injection**'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about the **Dependency Inversion Principle** (**DIP**), which
    is one of the SOLID design principles, in *Chapter 6*, *Software Design with Dependency
    Injection*. We will learn how to use dependency injection to manage the mapping
    of the `IDataStore` interface to the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the original code, we created new instances of `PassXYZ.Vault.Models.Item`
    to initialize mock data. After we replace the model, we cannot create `KPCLib.Item`
    directly, since it is an abstract class. Instead, we can create new instances
    of `PxEntry` using JSON data and assign `PxEntry` instances to the `Item` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To create the instances of an abstract class, the factory pattern can be used.
    To make the testing code simple, we did not use it here. The factory pattern is
    used in the actual implementation later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have replaced the model in the sample code with our own model now. With this
    change, we can improve `ItemsPage` and `ItemDetailPage` to reflect the updated
    model.
  prefs: []
  type: TYPE_NORMAL
- en: We will update the view and ViewModel using data binding to collections in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we replaced the model using PassXYZLib. When we introduced
    data binding, we used `ItemDetailPage` and `ItemDetailViewModel` to explain how
    to bind the source property to the target property.
  prefs: []
  type: TYPE_NORMAL
- en: For the item detail page, we created data binding from one source to one target.
    However, there are many cases in which we need to bind a data collection to the
    UI, such as `ListView` or `CollectionView`, to display a group of data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Binding to collections](img/B21554_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Binding to collections'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4.9*, when we create a data binding from a collection
    object to a collection view, the `ItemsSource` property is the one to use. In
    .NET MAUI, collection views such as `ListView` and `CollectionView` can be used,
    and both have an `ItemsSource` property.
  prefs: []
  type: TYPE_NORMAL
- en: For the collection object, we can use any collection that implements the `IEnumerable`
    interface. However, the changes to the collection object may not be able to update
    the UI automatically. In order to update the UI automatically, the source object
    needs to implement the `INotifyCollectionChanged` interface.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement our collection object with the `INotifyCollectionChanged` interface,
    but the simplest approach is to use the `ObservableCollection<T>` class. If any
    item in the observable collection is changed, the bound UI view is notified automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s review the class diagram of our **models**, **ViewModels**,
    and **views** as shown in *Figure 4.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: `Item`, `PwEntry`, `PwGroup`, `Field`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Model**: `ItemsViewModel`, `ItemDetailViewModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: `ItemsPage`, `ItemDetailPage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we display a list of items to the user, the user may act on the selected
    item. If the item is a group, we will show the groups and entries in an instance
    of `ItemsPage`. If the item is an entry, we will show the content of the entry
    on a content page, which is an instance of `ItemDetailPage`. On `ItemDetailPage`,
    we display a list of fields to the user. Each field is a key value pair and is
    implemented as an instance of the `Field` class.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we display two kinds of lists to the user – a list of items or a
    list of fields. The list of items is shown in `ItemsPage` and the list of fields
    is shown in `ItemDetailPage`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Class diagram of the model, view, and viewmodel](img/B21554_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Class diagram of the model, view, and ViewModel'
  prefs: []
  type: TYPE_NORMAL
- en: In this class diagram, we can see both `PwEntry` and `PwGroup` are derived from
    `Item`. There is a list of items in `ItemsViewModel` and there is a list of fields
    in `ItemDetailViewModel`. In the views, `ItemsPage` contains a reference to `ItemsViewModel`,
    and `ItemDetailPage` contains a reference to `ItemDetailViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we refine our design, we can look at the implementation. We will review
    the implementation of `ItemDetailViewModel` and `ItemDetailPage` to verify the
    design change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the code here, we can see the difference in `ItemDetailViewModel`
    compared to *Listing 4.1* at the beginning of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** A `Fields` property is defined as the `ObservableCollection<Field>`
    type to hold the `Field` list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** The `Fields` variable is initialized in the constructor of `ItemDetailViewModel`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** We can cast `item` to a `PwEntry` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** We can get the list of fields by calling an extension method, `GetFields`,
    which is defined in the PassXYZLib library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having reviewed the changes in `ItemDetailViewModel`, let’s review the changes
    in `ItemDetailPage` in *Listing 4.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.5: `ItemDetailPage.xaml` ([https://epa.ms/ItemDetailPage4-5](https://epa.ms/ItemDetailPage4-5))'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ItemDetailPage`, we can see there are many changes compared to *Listing
    3.4* in *Chapter 3**,* *User Interface Design with XAML*. `ListView` is used to
    display the fields in an entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** To use `Field` in `DataTemplate`, an `xmlns:model` namespace is added.
    Since the `Field` class is in a different assembly, we need to specify the assembly’s
    name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**(2)** We bind the `Fields` property to the `ItemsSource` property of `ListView`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `DataTemplate` is used to define the appearance of each item in `ListView`.
    It is collapsed in *Listing 4.5*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand it and review the implementation of `DataTemplate` in this code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In `DataTemplate`, the layout of each field is defined in a `ViewCell` element.
    In the `ViewCell` element, we defined a 2x2 `Grid` layout. The first column is
    used to display the field icon. The key and value in the field are displayed in
    the second column with two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `x:DataType` attribute in the `Grid` layout is set to `Field` and
    the following data binding in `Grid` will refer to the property of `Field`. The
    `Field` class is defined in our model, which is in the KPCLib package.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** To display the field icon, the `Source` property of the `Image` control
    is set to the `ImgSource` property of `Field`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Key` property and the `Value` property of `Field` are assigned to the `Text`
    property of the `Label` control.
  prefs: []
  type: TYPE_NORMAL
- en: With this analysis, we learned how to create data binding for a collection.
    The data binding used in `ItemsPage` and `ItemsViewModel` is similar to this implementation.
    The difference is we use a collection of `Field` here and a collection of `Item`
    classes is used in `ItemsPage`. Having completed the changes, we can see the improvement
    of the UI in *Figure 4.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screens screenshot of a phone  Description automatically generated](img/B21554_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Improved ItemsPage and ItemDetailPage'
  prefs: []
  type: TYPE_NORMAL
- en: In the improved UI, we display a list of items on `ItemsPage` (on the left).
    The items in the list can be entries (such as on Facebook, Twitter, or Amazon),
    or groups, which we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on an item, such as **GitHub**, details about **GitHub**
    are displayed on `ItemDetailPage` (on the right). On the item detail page, the
    information about this account (**GitHub**) is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implement an instance of `ViewCell` in `DataTemplate` in *Listing 4.5*. This
    `ViewCell` is used to display a key-value pair with an icon. The same implementation
    is employed in both `ItemsPage` and `ItemDetailPage`, with the sole distinction
    being the data binding. We have duplicated code here. To refactor the implementation,
    we can create a custom view (or custom control).
  prefs: []
  type: TYPE_NORMAL
- en: A custom view in .NET MAUI is a user interface component created by developers
    to meet custom requirements, provide reusable UI logic, or extend the functionality
    of existing UI components. Custom views can be built by combining existing controls,
    deriving from base classes like `View`, `ViewCell`, or `ContentView`, and overriding
    specific methods to customize rendering or behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom view that can be reused in both `ItemsPage` and `ItemDetailPage`,
    we should first create a new folder called `Templates` within the `Views` directory.
    In Visual Studio, we can right-click on the *Templates* folder to add a new item
    based on the **.NET MAUI ContentView** (**XAML**) template, naming it `KeyValueView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.6: `KeyValueView.xaml` ([https://epa.ms/KeyValueView4-6](https://epa.ms/KeyValueView4-6))'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Listing 4.6* that the class name is `KeyValueView` **(1)** and
    we have created a 2x2 grid **(2)**. In this grid, there are two rows used to display
    key **(3)** and value **(4)** with an icon **(5)**.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `KeyValueView`, we can establish data binding for the key, value,
    and icon. To support data binding, we need to define the key, value, and icon
    as bindable properties. Let’s review the implementation shown in *Listing 4.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4.7: `KeyValueView.xaml.cs` ([https://epa.ms/KeyValueView4-7](https://epa.ms/KeyValueView4-7))'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the bindable properties key **(1)**, Value **(2)**, and Source
    **(3)** within our custom control class, we must define the `BindableProperty`
    using the static `BindableProperty.Create` method. This method should include
    the property name, property type, declaring type, and a default value as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to implement the corresponding property with a getter and
    setter. They will interact with the `BindableProperty` through the `GetValue`
    and `SetValue` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created the custom view `KeyValueView`, and are able to refactor
    the previous `DataTemplate` implementation accordingly. The revised implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After introducing the new data model, the design has not experienced significant
    changes. We have enhanced the UI to make it more meaningful, but the majority
    of the complexity remains concealed within our model libraries – KPCLib and PassXYZLib.
    This is the advantage we observe by employing the MVVM pattern, which allows us
    to separate the model (business logic) from the UI design.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the MVVM pattern and applied it to our app
    development. One key feature of the MVVM pattern is data binding between the view
    and ViewModel. We delved into data binding and utilized it in the implementation
    of our app.
  prefs: []
  type: TYPE_NORMAL
- en: To delve deeper into the complexities of data binding, we examined binding to
    collections and the utilization of data binding in custom views. By employing
    data binding and custom views, we’re able to refactor XAML code, resulting in
    a cleaner and more concise codebase.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate advanced data binding usage, we need a more intricate model layer.
    We enhanced the model in this chapter by introducing two packages – KPCLib and
    PassXYZLib. We replaced the model in the sample code with the models found in
    these two packages. Subsequently, we updated the UIs of `ItemsPage` and `ItemDetailPage`
    to reflect the changes made to the model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will refine our user stories and continue improving
    the UI, drawing upon our knowledge of Shell and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Introduction to the MVVM Toolkit*: [https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KeePass is a free open source password manager: [https://keepass.info/](https://keepass.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
