- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring MVVM and Data Binding
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored how to construct **user interfaces** (**UIs**)
    using XAML. In this chapter, we will dive into the **Model-View-View-Model** (**MVVM**)
    pattern and data binding. The MVVM pattern, a widely adopted architectural pattern,
    is key in creating maintainable, scalable, and testable applications. In the context
    of .NET MAUI, MVVM separates the user interface logic, data, and the app’s structure
    into three distinct components: Model, View, and ViewModel. This separation leads
    to a clean and organized codebase, making it easier to develop and maintain the
    application. Data binding is a technique that connects the view (UI) with the
    ViewModel in a way that the UI reflects the ViewModel’s data and changes synchronously
    and automatically.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, our initial focus will be on introducing **MVVM** and data
    binding. For a better design and cleaner code, we will employ the MVVM Toolkit,
    part of the .NET Community Toolkit. The use of the MVVM Toolkit results in more
    concise and clean ViewModel code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, a majority of the logic is implemented in the model
    and service layers. Without a more complex model layer, we cannot delve into complicated
    topics about MVVM and data binding. Therefore, in the second half of this chapter,
    we present the actual model layer, which includes two .NET libraries, **KPCLib**
    and **PassXYZLib**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'With the real model layer in place, we introduce two advanced topics in data
    binding: binding to collections and using custom views.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Understanding **MVVM** and **MVC**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Community Toolkit
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the data model and service layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to collections
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom views
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter04).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MVVM and MVC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software design, we usually follow and reuse good practices and design patterns.
    The **Model-View-Controller** (**MVC**) pattern is an approach to decoupling the
    responsibilities of a system. It can help to separate the implementation of the
    UI and the business logic into different parts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The MVC pattern](img/B21554_04_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The MVC pattern'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：MVC模式
- en: 'The MVC pattern, as shown in *Figure 4.1*, divides the responsibilities of
    the system into three distinct parts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.1*所示，MVC模式将系统的职责分为三个不同的部分：
- en: '**Model:** The model represents the data and the business logic of the application.
    It is responsible for storing the app’s data, handling data validation, and performing
    any necessary data processing. Model classes typically interact with data sources,
    such as databases, web APIs, or file storage, to fetch and store data. Model classes
    usually can be implemented as **Plain Old CLR Objects** (**POCOs**) or **Data
    Transfer Objects** (**DTOs**). POCO is a class that doesn’t depend on any framework-specific
    classes, so POCO classes can be used with LINQ or Entity Framework well. DTO is
    a subset of a POCO class that only contains data without logic or behavior. DTO
    classes can be used to pass data between layers. The model has no dependency on
    the view or the controller so it can be implemented and tested separately.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型代表应用程序的数据和业务逻辑。它负责存储应用程序的数据，处理数据验证，并执行任何必要的数据处理。模型类通常与数据源（如数据库、Web
    API或文件存储）交互，以获取和存储数据。模型类通常可以实施为**纯旧CLR对象**（**POCOs**）或**数据传输对象**（**DTOs**）。POCO是一个不依赖于任何框架特定类的类，因此POCO类可以很好地与LINQ或Entity
    Framework一起使用。DTO是POCO类的子集，仅包含数据而没有逻辑或行为。DTO类可用于在层之间传递数据。模型不依赖于视图或控制器，因此它可以单独实现和测试。'
- en: '**View:** The view is responsible for the app’s user interface and user interaction.
    The view should not contain any business logic or direct data processing. Instead,
    it displays data and interface elements to the user and captures their input.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图负责应用程序的用户界面和用户交互。视图不应包含任何业务逻辑或直接的数据处理。相反，它向用户显示数据和界面元素，并捕获他们的输入。'
- en: '**Controller:** The controller updates the model and view in response to the
    user’s action. Our understanding of the model and the view hasn’t changed too
    much over time, but there have been different understandings and implementations
    of the controller since the MVC pattern was introduced.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器根据用户的操作更新模型和视图。我们对模型和视图的理解在时间上并没有太大的变化，但自从MVC模式被引入以来，对控制器就有不同的理解和实现。'
- en: The MVVM pattern was inspired by the MVC pattern, but it aimed to provide an
    improved approach specifically for UI development in XAML-based applications.
    With the rise of XAML-based UI frameworks, MVVM gained traction and became the
    de facto pattern for WPF, Silverlight, and later Xamarin.Forms applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式受MVC模式的启发，但其目标是提供一种针对基于XAML的应用程序UI开发的改进方法。随着基于XAML的UI框架的兴起，MVVM获得了动力，并成为WPF、Silverlight以及后来的Xamarin.Forms应用程序的事实上的模式。
- en: With the evolution of Xamarin.Forms into .NET MAUI, MVVM continues to be a prominent
    pattern in multi-platform mobile and desktop application development.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Xamarin.Forms演变为.NET MAUI，MVVM在多平台移动和桌面应用程序开发中继续是一个突出的模式。
- en: '![Figure 4.2: The MVVM pattern](img/B21554_04_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：MVVM模式](img/B21554_04_02.png)'
- en: 'Figure 4.2: The MVVM pattern'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：MVVM模式
- en: 'As we can see in *Figure 4.2*, in MVVM, the ViewModel is used to replace the
    controller. The differences between MVVM and MVC are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4.2*所示，在MVVM中，ViewModel用于替代控制器。MVVM与MVC之间的区别如下：
- en: '**Decoupling of view and model**: The ViewModel is used to handle the communication
    between the view and the model. The view accesses the data and logic in the model
    via the ViewModel.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图和模型的解耦**：ViewModel用于处理视图和模型之间的通信。视图通过ViewModel访问模型中的数据和逻辑。'
- en: '**Data binding between the view and ViewModel**: Using data binding, changes
    to the view or ViewModel can automatically be updated in the other one. This can
    help to reduce the complexity of implementation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图和ViewModel之间的数据绑定**：使用数据绑定，视图或ViewModel中的更改可以自动更新到另一个中。这有助于减少实现的复杂性。'
- en: In both MVC and MVVM, the model can be tested separately. In MVVM, it is possible
    to design unit tests for the ViewModel as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC和MVVM中，模型都可以单独测试。在MVVM中，还可以为ViewModel设计单元测试。
- en: When the view changes, the changes will be reflected in the ViewModel via data
    binding. The ViewModel will process the data changes in the model. Similarly,
    when the data changes in the model, the ViewModel is notified to update the view.
    The common solution for notifications is to install event handlers that prompt
    the notifications. With data binding, the implementation is simplified significantly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图发生变化时，这些变化将通过数据绑定反映在ViewModel中。ViewModel将处理模型中的数据变化。同样，当模型中的数据发生变化时，ViewModel会收到通知以更新视图。通知的常见解决方案是安装事件处理器来触发通知。使用数据绑定，实现大大简化。
- en: MVVM in PassXYZ.Vault
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PassXYZ.Vault中的MVVM
- en: In our app, `PassXYZ.Vault`, we use MVVM to handle the data exchange between
    the view and the ViewModel. As we can see in *Figure 4.3*, we have five XAML content
    pages and the same number of ViewModels defined. In our model, we have an `Item`
    class, which is our model class, and it can be accessed through the **IDataStore**
    interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用`PassXYZ.Vault`中，我们使用MVVM来处理视图和ViewModel之间的数据交换。正如我们在*图4.3*中可以看到的，我们有五个XAML内容页面和相同数量的ViewModel定义。在我们的模型中，我们有一个`Item`类，这是我们模型类，并且可以通过**IDataStore**接口访问。
- en: '![Figure 4.3: MVVM in PassXYZ.Vault](img/B21554_04_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：PassXYZ.Vault中的MVVM](img/B21554_04_03.png)'
- en: 'Figure 4.3: MVVM in PassXYZ.Vault'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：PassXYZ.Vault中的MVVM
- en: Data binding is used as the communication channel between views and ViewModels.
    The ViewModel will update the `Item` model via the **IDataStore** service interface.
    We will learn how to use data binding in the next section by analyzing the `ItemDetailPage`
    and `ViewModel`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定用作视图和ViewModel之间的通信通道。ViewModel将通过**IDataStore**服务接口更新`Item`模型。我们将在下一节通过分析`ItemDetailPage`和`ViewModel`来学习如何使用数据绑定。
- en: Data binding
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'Let’s explore how MVVM and data binding works. We can use an item detail page
    implementation in our app to analyze **how data binding works**. The following
    list includes the view, ViewModel, and model that we are going to explore:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索MVVM和数据绑定是如何工作的。我们可以在我们的应用中使用一个项目详情页面实现来分析**数据绑定是如何工作的**。以下列表包括了我们将要探索的视图、ViewModel和模型：
- en: '**View**: `ItemDetailPage`, see *Listing 3.4* in the previous chapter'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：`ItemDetailPage`，参见前一章的*列表3.4*'
- en: '**ViewModel**: `ItemDetailViewModel`, see *Listing 4.1*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：`ItemDetailViewModel`，参见前一章的*列表4.1*'
- en: '**Model**: `Item` (access through the **IDataStore** interface), see *Listing
    3.3* in the previous chapter'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：`Item`（通过**IDataStore**接口访问），参见前一章的*列表3.3*'
- en: '`ItemDetailPage` is a view used to display the content of an instance of `Item`.
    The data is retrieved from the ViewModel. The UI elements presenting the content
    of `Item` are connected to the ViewModel instance through data binding.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemDetailPage`是一个用于显示`Item`实例内容的视图。数据是从ViewModel中检索的。展示`Item`内容的UI元素通过数据绑定连接到ViewModel实例。'
- en: '![A diagram of a binding object  Description automatically generated](img/B21554_04_04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![绑定对象的图解 自动生成的描述](img/B21554_04_04.png)'
- en: 'Figure 4.4: Data binding'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：数据绑定
- en: As we can see in *Figure 4.4*, data binding is used to synchronize the properties
    of target and source objects. There are three objects involved in data binding
    and they are the `binding target`, `binding source`, and `binding object`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图4.4*中看到的，数据绑定用于同步目标和源对象的属性。数据绑定中有三个对象参与，它们是`绑定目标`、`绑定源`和`绑定对象`。
- en: Binding object
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定对象
- en: In *Figure 4.4*, the object of the `Binding` class (`Microsoft.Maui.Controls.Binding`)
    represents the connection between the target property (in the View) and the source
    property (in the ViewModel). It manages the synchronization of property values
    and handles the communication between the source and the target. The binding object
    is created when you define a binding expression in your XAML markup or create
    a binding in code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.4*中，`Binding`类（`Microsoft.Maui.Controls.Binding`）的对象代表了目标属性（在视图）和源属性（在ViewModel）之间的连接。它管理属性值的同步并处理源和目标之间的通信。绑定对象是在你定义XAML标记中的绑定表达式或创建代码中的绑定时创建的。
- en: 'Example of creating a binding object in XAML:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中创建绑定对象的示例：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Example of creating a binding object in C#:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中创建绑定对象的示例：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Binding target
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定目标
- en: In *Figure 4.4*, the target refers to the UI element (control) in the view that
    is bound to the ViewModel property. More specifically, the target is the property
    of the UI element involved in the binding. Examples of target properties include
    `Text` on a `Label` or `Entry`, `Source` on an `Image`, and `IsEnabled` on a `Button`.
    The target property must be a bindable property to participate in data binding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Binding source
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source is the object containing the property that is bound to the target
    property in the view. Typically, the source object is the ViewModel, which should
    be set as the `BindingContext` of the view or one of its parents. The ViewModel
    exposes properties that define their data type, getter, and setter methods. The
    source property is identified through the Binding Path in the binding expression.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: When you define a binding expression in XAML or create a binding object in code,
    a binding object is created and set for the specified target property. The XAML
    parser or the binding system creates the binding object and initializes it with
    the provided binding properties, such as `Path`, `Source`, `Mode`, `Converter`,
    and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of involved properties of target and source objects:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Target** – This is the UI element involved and this UI element has to be
    a child of `BindableObject`. The UI element used in `ItemDetailPage` is `Label`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target property** – This is the property of the target object. It is a `BindableProperty`.
    If the target is `Label`, as we mentioned here, the target property can be the
    `Text` property of `Label`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source** – This is the source object referenced by data binding. It is `ItemDetailViewModel`
    here.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source object value path** – This is the path to the value in the source
    object. Here, the path is a `ViewModel` property, such as `Name` or `Description`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the following code in `ItemDetailPage`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the XAML here, there are two data binding source paths, which are `Name`,
    **(1)**, and `Description`, **(2)**. The binding target is `Label` and the target
    property is the `Text` property of `Label`. If we review the inheritance hierarchy
    of `Label`, it looks like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that `Element`, `VisualElement`, and `View` are the derivatives of
    `BindableObject`. The data binding target has to be a child of `BindableObject`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding source is the `Name`, **(1)**, and `Description`, **(2)**, properties
    of the ViewModel as shown in *Listing 4.1* here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4.1: `ItemDetailViewModel.cs` ([https://epa.ms/ItemDetailViewModel4-1](https://epa.ms/ItemDetailViewModel4-1))'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The values of `Name`, **(1)**, and `Description`, **(2)**, are loaded from the
    model in the `LoadItemId()` method, **(3)**. You may notice that the class is
    decorated by a `QueryPropertyAttribute` attribute. This is used to pass parameters
    during page navigation, and it will be introduced in the next chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the following, *Table 4.1*, to summarize the data binding components
    in the code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data binding elements** | **Example** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| Target | `Label` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Target property | `Text` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Source object | `ItemDetailViewModel` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Source object value path | `Name` or `Description` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Data binding settings'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Properties of a Binding object
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having analyzed the preceding code, let us have a look at the syntax of the
    binding expression:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Binding properties can be set as a series of name-value pairs in the form of
    `bindProp=value`. For example, see the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Path` property is the default property, and it can be omitted if it is
    the first one in the property list as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The binding properties that we mentioned here are the properties of the `Binding`
    class, and you can find the details by referring to the Microsoft document about
    the `Binding` class here: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding](https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.controls.binding).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: As well as the `Path` property, let’s review another two important binding properties,
    `Source` and `Mode`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Source
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Source` property represents the object containing the source property (which
    will be bound to the target property). By default, the source object is the `BindingContext`
    of the element, which is typically the ViewModel. However, you can use the `Source`
    property to bind to other objects if needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we set data binding to the target, we can use the following two members
    of the target class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The `BindingContext` property gives us the source object
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SetBinding` method specifies the target property and source property
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, we set the `BindingContext` property to an instance of `ItemDetailViewModel`,
    **(1)**, in the C# code-behind file of `ItemDetailPage`, as shown in *Listing
    4.2* here. It is set at the page level, and it applies to all binding targets
    on this page:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4.2: `ItemDetailPage.xaml.cs` ([https://epa.ms/ItemDetailPage4-2](https://epa.ms/ItemDetailPage4-2))'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `Binding` markup extension, we can also create the binding
    using the `SetBinding` method directly, as done here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**(2)** In the XAML code, we removed the `Binding` markup extension and specified
    the instance name as `labelText`. In the C# code-behind file, we can call the
    `SetBinding` method, **(3)**, in the constructor of `ItemDetailPage` to create
    the data binding for the `Text` property:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Binding mode
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Mode` property specifies the direction of data flow in the binding, such
    as if data flows only from the ViewModel to the UI or if it flows in both directions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In `ItemDetailPage`, all UI elements are `Label` objects, which are not editable
    for the user. This is one-way binding from the source to the target. The changes
    in the source object will cause updates in the target object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There are four binding modes supported in .NET MAUI. Let’s review them by referring
    to *Figure 4.5*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Binding mode](img/B21554_04_05.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Binding mode'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the binding modes supported in `.NET MAUI`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`OneWay` binding is usually used in the case of presenting data to the user.
    In our app, we will retrieve a list of password entries and display this list
    on `ItemsPage`. When the user clicks an item in the list, the password details
    will show on `ItemDetailPage`. `OneWay` binding is used in both cases.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoWay` binding causes changes to either the source property or the target
    property to automatically update the other. In our app, when the user edits the
    fields of a password entry or when the user enters a username and password on
    `LoginPage`, the target UI `Entry` component and the source view model object
    are set with `TwoWay`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneWayToSource` is the reverse of the `OneWay` binding mode. When the target
    property is changed, the source property will be updated. When we add a new password
    entry on `NewItemPage`, we can use `OneWayToSource` instead of the `TwoWay` binding
    mode to improve performance.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneTime` binding is a binding mode that is not shown in *Figure 4.4*. The
    target properties are initialized from the source properties, but any further
    changes to the source properties won’t update the target properties. It is a simpler
    form of the `OneWay` binding mode with better performance.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we don’t specify the binding mode in data binding, the default binding mode
    is used. We can overwrite the default binding mode if it is needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ItemsPage` code, we use the `ListView` control to display the list
    of password groups and entries, so we should set the `IsRefreshing` attribute
    to the `OneWay` binding mode:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we add a new item in `NewItemPage`, we use the `Entry` and `Editor` controls
    to edit the properties. We can use the `OneWayToSource` or `TwoWay` binding modes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Changing notifications in ViewModels
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 4.5*, we can see the data binding target is a derived class of `BindableObject`.
    Besides this requirement, in the data binding setup, the data source (ViewModel)
    needs to implement the `INotifyPropertyChanged` interface so that when the property
    changes, a `PropertyChanged` event is raised to notify the change.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In an MVVM pattern, the ViewModel is usually the data binding source so we
    need to implement the `INotifyPropertyChanged` interface in our ViewModels. If
    we do this for each ViewModel class, there will be a lot of duplicated code. In
    a Visual Studio template, a `BaseViewModel` class, as we can see in *Listing 4.3*,
    is included in the boilerplate code and we use it in our app. Other ViewModels
    inherit this class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 4.3 `BaseViewModel.cs` ([https://epa.ms/BaseViewModel4-3](https://epa.ms/BaseViewModel4-3))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BaseViewModel` class (*Listing 4.3*), we can see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `BaseViewModel` implements the `INotifyPropertyChanged` interface and
    this interface defines a single event, `PropertyChanged`, **(4)**.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** When a property is changed in the setter, the `OnPropertyChanged` method
    is called. In `OnPropertyChanged`, the `PropertyChanged` event is fired. A copy
    of the `PropertyChanged` event handler is stored in the **changed** local variable,
    so this implementation is safe in a multi-thread environment. When the `PropertyChanged`
    event is fired, it needs to pass the property name as a parameter to indicate
    which property is changed. The `CallerMemberName` attribute can be used to find
    the method name or property name of the caller, so we don’t need to hardcode the
    property name.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** When we define a property in the ViewModel, the `OnPropertyChanged`
    method is called in the setter – but as you can see, in our code, we call `SetProperty<T>`
    instead of `OnPropertyChanged` directly. `SetProperty<T>` will do additional work
    before it calls `OnPropertyChanged`. It checks whether the value is changed. If
    there is no change, it will return and do nothing. If the value is changed, it
    will update the backing field and call `OnPropertyChanged` to fire the change
    event.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'If we recall `ItemDetailViewModel` in *Listing 4.1*, it inherits from the `BaseViewModel`
    class. In the setter of the `Name` and `Description` properties, we call `SetProperty<T>`
    to set the values and fire the `PropertyChanged` event:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we learned about data binding and the `INotifyPropertyChanged`
    interface. We need to create boilerplate code to define a property with change
    notification support. To simplify the code and autogenerate boilerplate code behind
    the scenes, we can use the MVVM Toolkit.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: .NET Community Toolkit
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the MVVM Toolkit to refactor our ViewModel code.
    The MVVM Toolkit is a module within the .NET Community Toolkit, specifically designed
    for building applications following the MVVM design pattern.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Community Toolkit (formerly Windows Community Toolkit) is a collection
    of helper functions, custom controls, and app services designed to simplify and
    accelerate .NET app development. The toolkit is open source and maintained by
    the community, offering a suite of tools for various .NET development platforms,
    such as .NET MAUI, Xamarin, UWP, WPF, and WinUI. The toolkit provides useful components
    that developers can use out of the box to easily build applications with a rich
    user interface, common app services, animations, and more.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit supplies a set of base classes, utilities, and attributes
    that make implementing the MVVM pattern in your .NET applications more efficient
    and straightforward. The MVVM Toolkit provides the following key components:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`ObservableObject`: A base class that simplifies the implementation of objects
    that raise PropertyChanged events, such as ViewModels. It implements the `INotifyPropertyChanged`
    interface and provides the `SetProperty` method to handle property change notifications.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelayCommand` and `AsyncRelayCommand`: Classes implementing the `ICommand`
    interface, designed to handle executing methods and checking if a command can
    execute. They make it easy to create commands for your ViewModel that react to
    UI actions.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency** **Injection** **support**: The MVVM Toolkit offers built-in
    support for dependency injection, making it simple to integrate services into
    your ViewModels using popular dependency injection libraries like `Microsoft.Extensions.DependencyInjection`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messenger** (**Event Aggregator**): The MVVM Toolkit provides a lightweight
    messenger service that enables decoupled, message-based communication between
    components, like different ViewModels. This promotes a separation of concerns
    and makes each component more testable.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please find more information about the MVVM Toolkit in the *Further reading*
    section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: How to use the MVVM Toolkit
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the MVVM Toolkit in .NET MAUI, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the .NET `CommunityToolkit.Mvvm` NuGet package to our project file as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Refactor ViewModel using MVVM Toolkit Source Generators. Source Generators is
    a C# compiler feature that allows executing custom code at compile time to modify
    the compilation output. The MVVM Toolkit supports using Source Generators to automatically
    generate ViewModel and `ICommand` boilerplate code based on attributes, which
    can simplify ViewModel creation.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit can help us to simplify ViewModel by using Source Generators.
    If we want to add a property in ViewModel as a data binding source, we need to
    implement the `INotifyPropertyChanged` interface. For example, in `ItemDetailViewModel`,
    we implement the `Description` property as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the Setter, the `SetProperty` method is called, and it will update the backing
    field and call `OnPropertyChanged` to fire the change event. Both `SetProperty`
    and `OnPropertyChanged` are defined in the `BaseViewModel` class, as we can see
    in *Listing 4.3*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the MVVM Toolkit, we can inherit from `ObservableObject` instead of `BaseViewModel`.
    `ObservableObject` implements the `INotifyPropertyChanged` interface similar to
    what we have done in `BaseViewModel`. With `ObservableObject`, we can simplify
    the above implementation as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see, using the `ObservableProperty`attribute, we can define the backing
    field only in the code. Source Generators will help us to generate boilerplate
    code. We can use the `Description` property in XAML as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the MVVM pattern, we can define a ViewModel property as an observable property
    to support TwoWay binding. We can also define a ViewModel property as an `ICommand`
    interface to handle UI events using data binding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we display a list of items in `ItemsPage`. In `ItemsPage`, we need
    to load a list of items from the data source, and we also need to support adding
    a new item. We need to define two `ICommand` interfaces as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the above implementation, we define two properties, `LoadItemsCommand`**(1)**
    and `AddItemCommand`**(2)**, as the type `Microsoft.Maui.Controls.Command`. In
    the constructor of ViewModel, we initialize them**(3)(4)** with the private methods
    `LoadItems`**(5)** and `AddItem`**(6)**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the MVVM Toolkit, we can simplify the implementation as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that we just need to add `RelayCommandAttribute` in front of `AddItem`
    `(1)` and `LoadItems` `(2)` to implement `ICommand` properties. Source Generators
    will help us generate the rest of the code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Having introduced the basic knowledge of XAML UI design, the MVVM pattern, and
    data binding, we can improve our app using the knowledge we just learned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Improving the data model and service
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing the MVVM pattern, data binding, and the MVVM Toolkit, we have
    the fundamental knowledge of how to use data binding. In the rest of this chapter,
    we will explore advanced topics about data binding. We will discuss how to bind
    to collections first and then we will introduce custom views. Using custom views,
    we can make XAML code cleaner and more concise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine these topics, a more intricate model layer is required. Instead
    of creating a hypothetical model layer, we’ll work with the actual model layer
    in our app, which includes two .NET libraries: **KPCLib** and **PassXYZLib**.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To introduce the model layer of our app, let us review the use cases again.
    We are developing a cross-platform password manager app that is compatible with
    the popular **KeePass** database format. We have the following use cases:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case 1**: `LoginPage` – As a password manager user, I want to log in
    to the password manager app so that I can access my password data.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 2**: `AboutPage` – As a password manager user, I want to have an
    overview of my database and the app that I am using.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 3**: `ItemsPage` – As a password manager user, I want to see a list
    of groups and entries so that I can explore and examine my password data.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 4**: `ItemDetailPage` – As a password manager user, I want to see
    the details of a password entry after I select it in the list of password entries.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case 5**: `NewItemPage` – As a password manager user, I want to add a
    password entry or create a new group in my database.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These five use cases are inherited from the Visual Studio template, and they
    are sufficient for the user stories of our password manager app for the moment.
    We will improve our app using these user stories in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented our app using the MVVM pattern, but the `Item` model below is
    too simple and is not sufficient to be used in a password manager app:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The major functionalities of our password manager app are encapsulated in the
    model layer. We will build our model using two .NET packages, KPCLib and PassXYZLib.
    These two packages include all the password management features we need.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: KPCLib
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The model that we will use is a library from **KeePass** called `KeePassLib`.
    Both KeePass and `KeePassLib` are built for .NET Framework, so they can only be
    used on Windows. I ported `KeePassLib` and rebuilt it as a .NET Standard 2.0 library
    packaged as KPCLib. KPCLib can be found on NuGet and GitHub here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'NuGet: [https://www.nuget.org/packages/KPCLib/](https://www.nuget.org/packages/KPCLib/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/passxyz/KPCLib](https://github.com/passxyz/KPCLib)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KPCLib is used both as a package name and a namespace. The package of KPCLib
    includes two namespaces, `KeePassLib` and `KPCLib`. The `KeePassLib` namespace
    is the original one from KeePass with the following changes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Updated and built for .NET Standard 2.0
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated `PwEntry` and `PwGroup` to be classes derived from the `Item` abstract
    class
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the KPCLib namespace, an `Item` abstract class is defined. The reason I created
    a new class and made it the parent class of `PwEntry` and `PwGroup` is due to
    the navigation design difference between `KeePass` and `PassXYZ.Vault`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the UI of KeePass in *Figure 4.5*, we can see that it is a classic
    Windows desktop UI. The navigation is designed around a tree view like Windows
    Explorer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: KeePass UI](img/B21554_04_06.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: KeePass UI'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Two classes, `PwGroup` and `PwEntry`, behave like directories and files. A `PwGroup`
    instance is just like a directory, and it includes a list of children – `PwGroup`
    and `PwEntry`. All `PwGroup` instances are displayed in a tree view on the right-hand
    panel. When a `PwGroup` instance is selected, the list of `PwEntry` in this group
    is shown on the right-hand panel. `PwEntry` includes the content of a password
    entry, such as a username and password. The content of `PwEntry` is displayed
    on the bottom panel.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the `PassXYZ.Vault` UI design, we use a .NET MAUI Shell template. It is an
    implementation of the stacked Master-Detail pattern. In the stacked Master-Detail
    pattern, a single list is used to display items. In this case, the instances of
    both `PwGroup` and `PwEntry` can be displayed in the same list. After an item
    is selected, we will take an action according to the type of the item.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of PwGroup and PwEntry
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with the PassXYZ.Vault UI design better, we can abstract `PwGroup` and
    `PwEntry` as the `Item` abstract class, as shown in *Figure 4.7*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Class diagram of Item](img/B21554_04_07.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Class diagram of Item'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the UML class diagram in *Figure 4.7* and the source code of `Item.cs`
    in *Listing 4.4*, we can see the following properties are defined in the `Item`
    abstract class. These properties are implemented in both `PwEntry` and `PwGroup`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** `Name`: the `Item` name'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** `Description`: the `Item` description'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `Notes`: `Item` comments defined by the user'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** `IsGroup`: `true` if the instance is `PwGroup` or `false` if it is
    `PwEntry`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**(5)** `Id`: ID of the instance (a unique value that is like the primary key
    in a database)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**(6)** `ImgSource`: image source of the icon (both `PwGroup` and `PwEntry`
    can have an associated icon)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**(7)** `LastModificationTime`: the last modification time of the item'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**(8)** `Item`: implements the `INotifyPropertyChanged` interface, and it can
    work well in the MVVM model for data binding:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4.4: `Item.cs` ([https://epa.ms/Item4-4](https://epa.ms/Item4-4))'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: PassXYZLib
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use KeePassLib in `PassXYZ.Vault`, we need to use some .NET MAUI APIs to
    extend the functionalities required of our app. To separate the business logic
    from the UI and extend the functionalities of `KeePassLib` for .NET MAUI, a .NET
    MAUI class library, PassXYZLib, is created to encapsulate the extended model in
    a separate library. PassXYZLib is both a package name and a namespace.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'To add PassXYZLib to our project, we can add it to a `PassXYZ.Vault.csproj`
    project file, as seen here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also add a PassXYZLib package from the command line here. From the command
    line, go to the project folder and execute this command to add the package:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Updating the model
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we add a PassXYZLib package to the project, we can access the KPCLib,
    `KeePassLib`, and `PassXYZLib` namespaces. To replace the current model, we need
    to remove the `Models/Item.cs` file from the project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to replace the `PassXYZ.Vault.Models` namespace with KPCLib.
    In *Figure 4.8a*, we can see that the `Item` in namespace `PassXYZ.Vault.Models`
    is used.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_04_08a.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8a: PassXYZ.Vault.Models before update to KPCLib'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: After the `PassXYZ.Vault.Models` namespace is replaced, in *Figure 4.8b*, the
    `Item` from the `KBCLib` namespace is utilized. Comparing the implementation before
    and after the transition, we can observe that the rest of the code remains largely
    unchanged. By adopting the MVVM pattern, most of the business logic is encapsulated
    within the model layer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_04_08b.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8b: Updated to KPCLib'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining changes in view models and views, all modifications pertain
    to namespace changes, so further explanations aren’t necessary.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Updating the service
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The major changes can be found in `MockDataStore.cs`. In the `MockDataStore`
    class, we changed the namespace and the mock data initialization.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: To decouple the model from the rest of the system, we use an `IDataStore` interface
    to encapsulate the actual implementation. At this stage, we use mock data to implement
    the service for testing, so the `MockDataStore` class is used. We will replace
    it with the actual implementation in *Chapter 6*, *Software Design with Dependency
    Injection,* using dependency injection.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency inversion and dependency injection**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about the **Dependency Inversion Principle** (**DIP**), which
    is one of the SOLID design principles, in *Chapter 6*, *Software Design with Dependency
    Injection*. We will learn how to use dependency injection to manage the mapping
    of the `IDataStore` interface to the actual implementation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'In the original code, we created new instances of `PassXYZ.Vault.Models.Item`
    to initialize mock data. After we replace the model, we cannot create `KPCLib.Item`
    directly, since it is an abstract class. Instead, we can create new instances
    of `PxEntry` using JSON data and assign `PxEntry` instances to the `Item` list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To create the instances of an abstract class, the factory pattern can be used.
    To make the testing code simple, we did not use it here. The factory pattern is
    used in the actual implementation later in this book.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We have replaced the model in the sample code with our own model now. With this
    change, we can improve `ItemsPage` and `ItemDetailPage` to reflect the updated
    model.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We will update the view and ViewModel using data binding to collections in the
    next section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Binding to collections
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we replaced the model using PassXYZLib. When we introduced
    data binding, we used `ItemDetailPage` and `ItemDetailViewModel` to explain how
    to bind the source property to the target property.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: For the item detail page, we created data binding from one source to one target.
    However, there are many cases in which we need to bind a data collection to the
    UI, such as `ListView` or `CollectionView`, to display a group of data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Binding to collections](img/B21554_04_09.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Binding to collections'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4.9*, when we create a data binding from a collection
    object to a collection view, the `ItemsSource` property is the one to use. In
    .NET MAUI, collection views such as `ListView` and `CollectionView` can be used,
    and both have an `ItemsSource` property.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: For the collection object, we can use any collection that implements the `IEnumerable`
    interface. However, the changes to the collection object may not be able to update
    the UI automatically. In order to update the UI automatically, the source object
    needs to implement the `INotifyCollectionChanged` interface.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We can implement our collection object with the `INotifyCollectionChanged` interface,
    but the simplest approach is to use the `ObservableCollection<T>` class. If any
    item in the observable collection is changed, the bound UI view is notified automatically.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s review the class diagram of our **models**, **ViewModels**,
    and **views** as shown in *Figure 4.9*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: `Item`, `PwEntry`, `PwGroup`, `Field`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Model**: `ItemsViewModel`, `ItemDetailViewModel`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: `ItemsPage`, `ItemDetailPage`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we display a list of items to the user, the user may act on the selected
    item. If the item is a group, we will show the groups and entries in an instance
    of `ItemsPage`. If the item is an entry, we will show the content of the entry
    on a content page, which is an instance of `ItemDetailPage`. On `ItemDetailPage`,
    we display a list of fields to the user. Each field is a key value pair and is
    implemented as an instance of the `Field` class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we display two kinds of lists to the user – a list of items or a
    list of fields. The list of items is shown in `ItemsPage` and the list of fields
    is shown in `ItemDetailPage`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Class diagram of the model, view, and viewmodel](img/B21554_04_10.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Class diagram of the model, view, and ViewModel'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In this class diagram, we can see both `PwEntry` and `PwGroup` are derived from
    `Item`. There is a list of items in `ItemsViewModel` and there is a list of fields
    in `ItemDetailViewModel`. In the views, `ItemsPage` contains a reference to `ItemsViewModel`,
    and `ItemDetailPage` contains a reference to `ItemDetailViewModel`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'After we refine our design, we can look at the implementation. We will review
    the implementation of `ItemDetailViewModel` and `ItemDetailPage` to verify the
    design change:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As shown in the code here, we can see the difference in `ItemDetailViewModel`
    compared to *Listing 4.1* at the beginning of this chapter:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** A `Fields` property is defined as the `ObservableCollection<Field>`
    type to hold the `Field` list.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** The `Fields` variable is initialized in the constructor of `ItemDetailViewModel`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** We can cast `item` to a `PwEntry` instance.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**(4)** We can get the list of fields by calling an extension method, `GetFields`,
    which is defined in the PassXYZLib library.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Having reviewed the changes in `ItemDetailViewModel`, let’s review the changes
    in `ItemDetailPage` in *Listing 4.5*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 4.5: `ItemDetailPage.xaml` ([https://epa.ms/ItemDetailPage4-5](https://epa.ms/ItemDetailPage4-5))'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ItemDetailPage`, we can see there are many changes compared to *Listing
    3.4* in *Chapter 3**,* *User Interface Design with XAML*. `ListView` is used to
    display the fields in an entry:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** To use `Field` in `DataTemplate`, an `xmlns:model` namespace is added.
    Since the `Field` class is in a different assembly, we need to specify the assembly’s
    name as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**(2)** We bind the `Fields` property to the `ItemsSource` property of `ListView`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**(3)** `DataTemplate` is used to define the appearance of each item in `ListView`.
    It is collapsed in *Listing 4.5*.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand it and review the implementation of `DataTemplate` in this code
    block:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `DataTemplate`, the layout of each field is defined in a `ViewCell` element.
    In the `ViewCell` element, we defined a 2x2 `Grid` layout. The first column is
    used to display the field icon. The key and value in the field are displayed in
    the second column with two rows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** The `x:DataType` attribute in the `Grid` layout is set to `Field` and
    the following data binding in `Grid` will refer to the property of `Field`. The
    `Field` class is defined in our model, which is in the KPCLib package.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** To display the field icon, the `Source` property of the `Image` control
    is set to the `ImgSource` property of `Field`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The `Key` property and the `Value` property of `Field` are assigned to the `Text`
    property of the `Label` control.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: With this analysis, we learned how to create data binding for a collection.
    The data binding used in `ItemsPage` and `ItemsViewModel` is similar to this implementation.
    The difference is we use a collection of `Field` here and a collection of `Item`
    classes is used in `ItemsPage`. Having completed the changes, we can see the improvement
    of the UI in *Figure 4.11*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Screens screenshot of a phone  Description automatically generated](img/B21554_04_11.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Improved ItemsPage and ItemDetailPage'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the improved UI, we display a list of items on `ItemsPage` (on the left).
    The items in the list can be entries (such as on Facebook, Twitter, or Amazon),
    or groups, which we will see in the next chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on an item, such as **GitHub**, details about **GitHub**
    are displayed on `ItemDetailPage` (on the right). On the item detail page, the
    information about this account (**GitHub**) is shown.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Using custom views
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We implement an instance of `ViewCell` in `DataTemplate` in *Listing 4.5*. This
    `ViewCell` is used to display a key-value pair with an icon. The same implementation
    is employed in both `ItemsPage` and `ItemDetailPage`, with the sole distinction
    being the data binding. We have duplicated code here. To refactor the implementation,
    we can create a custom view (or custom control).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A custom view in .NET MAUI is a user interface component created by developers
    to meet custom requirements, provide reusable UI logic, or extend the functionality
    of existing UI components. Custom views can be built by combining existing controls,
    deriving from base classes like `View`, `ViewCell`, or `ContentView`, and overriding
    specific methods to customize rendering or behavior.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom view that can be reused in both `ItemsPage` and `ItemDetailPage`,
    we should first create a new folder called `Templates` within the `Views` directory.
    In Visual Studio, we can right-click on the *Templates* folder to add a new item
    based on the **.NET MAUI ContentView** (**XAML**) template, naming it `KeyValueView`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 4.6: `KeyValueView.xaml` ([https://epa.ms/KeyValueView4-6](https://epa.ms/KeyValueView4-6))'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Listing 4.6* that the class name is `KeyValueView` **(1)** and
    we have created a 2x2 grid **(2)**. In this grid, there are two rows used to display
    key **(3)** and value **(4)** with an icon **(5)**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: When we use `KeyValueView`, we can establish data binding for the key, value,
    and icon. To support data binding, we need to define the key, value, and icon
    as bindable properties. Let’s review the implementation shown in *Listing 4.7*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4.7: `KeyValueView.xaml.cs` ([https://epa.ms/KeyValueView4-7](https://epa.ms/KeyValueView4-7))'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the bindable properties key **(1)**, Value **(2)**, and Source
    **(3)** within our custom control class, we must define the `BindableProperty`
    using the static `BindableProperty.Create` method. This method should include
    the property name, property type, declaring type, and a default value as parameters:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After that, we need to implement the corresponding property with a getter and
    setter. They will interact with the `BindableProperty` through the `GetValue`
    and `SetValue` methods:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have now created the custom view `KeyValueView`, and are able to refactor
    the previous `DataTemplate` implementation accordingly. The revised implementation
    is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After introducing the new data model, the design has not experienced significant
    changes. We have enhanced the UI to make it more meaningful, but the majority
    of the complexity remains concealed within our model libraries – KPCLib and PassXYZLib.
    This is the advantage we observe by employing the MVVM pattern, which allows us
    to separate the model (business logic) from the UI design.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the MVVM pattern and applied it to our app
    development. One key feature of the MVVM pattern is data binding between the view
    and ViewModel. We delved into data binding and utilized it in the implementation
    of our app.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: To delve deeper into the complexities of data binding, we examined binding to
    collections and the utilization of data binding in custom views. By employing
    data binding and custom views, we’re able to refactor XAML code, resulting in
    a cleaner and more concise codebase.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate advanced data binding usage, we need a more intricate model layer.
    We enhanced the model in this chapter by introducing two packages – KPCLib and
    PassXYZLib. We replaced the model in the sample code with the models found in
    these two packages. Subsequently, we updated the UIs of `ItemsPage` and `ItemDetailPage`
    to reflect the changes made to the model.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will refine our user stories and continue improving
    the UI, drawing upon our knowledge of Shell and navigation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Introduction to the MVVM Toolkit*: [https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KeePass is a free open source password manager: [https://keepass.info/](https://keepass.info/)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
