<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Physics Simulation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Physics Simulation</h1></div></div></div><p class="calibre8">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Introduction to physics simulation</li><li class="listitem">Integrating physics engine with games</li><li class="listitem">Adding real-world simulation</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Physics Simulation">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec35" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 5. Adding Music to iOS Games and an Introduction to iCloud" href="part0036_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre9">Adding Music to iOS Games and an Introduction to iCloud</em></span> we learned various ways to add music to our games along with iCloud integration. Now in this chapter, our major focus will be on adding reality to the games by introducing physics simulation. SpriteKit has a seamlessly bundled physics engine and in this chapter we will be exploring and working to add physics to our games. Basically, the SpriteKit has been divided into the following two major components:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The graphical interface that you see on the screen including UI interface, animations, sound effects, and so on</li><li class="listitem">The second is the physical physics world, which determines the interaction and behaviors of game objects</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Introduction to physics simulation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec36" class="calibre1"/>Introduction to physics simulation</h1></div></div></div><p class="calibre8">We all like games that<a id="id239" class="calibre1"/> have realistic effects and actions. In this chapter we will learn about the ways to make our games more realistic. Have you ever wondered how to provide realistic effect to game objects? It is physics that provides a realistic effect to the games and their characters. In this chapter, we will learn how to use physics in our games.</p><p class="calibre8">While developing the <a id="id240" class="calibre1"/>game using SpriteKit, you will need to change the world of your game frequently. The world is the main object in the game that holds all the other game objects and physics simulations. We can also update the gravity of the gaming world according to our need. The default world gravity is 9.8, which is also the earth's gravity, World gravity makes<a id="id241" class="calibre1"/> all bodies fall down to the ground as soon as they are created.</p><p class="calibre8">More about SpriteKit can be explored using the following link:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html">https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html</a>
</p></div>

<div class="book" title="Introduction to physics simulation">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec95" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">The first task is to create the world and then add bodies to it, which can interact according to the principles of physics. You can create game objects in the form of sprites and associate physics bodies to them. You can also set various properties of the object to specify its behavior. </p></div></div>

<div class="book" title="Introduction to physics simulation">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec96" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">In this section, we will learn about the basic components that are used to develop games. We will also learn how to set game configurations, including the world settings such as gravity and boundary.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The initial step is to apply the gravity to the scene. Every scene has a physics world associated with it. We can update the gravity of the physics world in our scene using the following line of code:<div class="informalexample"><pre class="programlisting">self.physicsWorld.gravity = CGVectorMake(0.0f, 0.0f);</pre></div><p class="calibre15">Currently we have set the gravity of the scene to 0, which means the bodies will be in a state of free fall. They will not experience any force due to gravity in the world.</p></li><li class="listitem" value="2">In several games we also need to set a boundary to the games. Usually, the bounds of the view can serve as the bounds for our physics world. The following code will help us to set up the boundary for our game, which will be as per the bounds of our game scene:<div class="informalexample"><pre class="programlisting">// 1 Create a physics body that borders the screen
SKPhysicsBody* gameBorderBody = [SKPhysicsBody bodyWithEdgeLoopFromRect:self.frame];
// 2 Set physicsBody of scene to gameBorderBody
self.physicsBody = gameBorderBody;
// 3 Set the friction of that physicsBody to 0
self.physicsBody.friction = 0.0f;</pre></div><p class="calibre15">In the first line of code we are initializing a <code class="email">SKPhysicsBody</code> object. This object is used to add the physics simulation to any <code class="email">SKSpriteNode</code>. We have created the <code class="email">gameBorderBody</code> as a rectangle with the dimensions equal to the current scene frame.</p><p class="calibre15">Then we assign that physics object to the <code class="email">physicsBody</code> of our current scene (every <code class="email">SKSpriteNode</code> object has the <code class="email">physicsBody</code> property through which we can associate physics bodies to any node).</p><p class="calibre15">After this we update the <code class="email">physicsBody.friction</code>. This line of code updates the friction property of our world. The friction property defines the friction value of one physics body with another physics body. Here we have set this to <code class="email">0</code>, in order to make the objects move freely, without slowing down.</p></li><li class="listitem" value="3">Every<a id="id242" class="calibre1"/> game object is inherited from the <code class="email">SKSpriteNode</code> class, which allows the physics body to hold on to the node. Let us take an example and create a game object using the following code:<div class="informalexample"><pre class="programlisting">// 1
SKSpriteNode* gameObject = [SKSpriteNode spriteNodeWithImageNamed: @"object.png"];
gameObject.name = @"game_object";
gameObject.position = CGPointMake(self.frame.size.width/3, self.frame.size.height/3);
[self addChild:gameObject];

// 2
gameObject.physicsBody = [SKPhysicsBody bodyWithCircleOfRadius:gameObject.frame.size.width/2];
// 3
gameObject.physicsBody.friction = 0.0f;</pre></div><p class="calibre15">We are already familiar with the first few lines of code wherein we are creating the sprite reference and then adding it to the scene. Now in the next line of code, we are associating a physics body with that sprite. We are initializing the circular physics body with radius and associating it with the sprite object.</p><p class="calibre15">Then we can update various other properties of the physics body such as friction, restitution, linear damping, and so on.</p></li><li class="listitem" value="4">The physics body properties also allow you to apply force. To apply force you need to provide the direction where you want to apply force.<div class="informalexample"><pre class="programlisting">[gameObject.physicsBody applyForce:CGVectorMake(10.0f, -10.0f)];</pre></div><p class="calibre15">In the code we are applying force in the bottom-right corner of the world. To provide the direction coordinates we have used <code class="email">CGVectorMake</code>, which accepts the vector coordinates of the physics world.</p></li><li class="listitem" value="5">You <a id="id243" class="calibre1"/>can also apply impulse instead of force. Impulse can be defined as a force that acts for a specific interval of time and is equal to the change in linear momentum produced over that interval.<div class="informalexample"><pre class="programlisting">[gameObject.physicsBody applyImpulse:CGVectorMake(10.0f, -10.0f)];</pre></div></li><li class="listitem" value="6">While creating games, we frequently use static objects. To create a rectangular static object we can use the following code:<div class="informalexample"><pre class="programlisting">SKSpriteNode* box = [[SKSpriteNode alloc] initWithImageNamed: @"box.png"];
box.name = @"box_object";
box.position = CGPointMake(CGRectGetMidX(self.frame), box.frame.size.height * 0.6f);
[self addChild:box];
box.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:box.frame.size];
box.physicsBody.friction = 0.4f;
// make physicsBody static
box.physicsBody.dynamic = NO;</pre></div><p class="calibre15">So all the code is the same except one special property, which is dynamic. By default this property is set to <code class="email">YES</code>, which means that all the physics bodies will be dynamic by default and can be converted to static after setting this Boolean to <code class="email">NO</code>. Static bodies do not react to any force or impulse. Simply put, dynamic physics bodies can move while the static physics bodies cannot .</p></li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Integrating physics engine with games"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec37" class="calibre1"/>Integrating physics engine with games</h1></div></div></div><p class="calibre8">From<a id="id244" class="calibre1"/> this <a id="id245" class="calibre1"/>section onwards, we will develop a mini game that will have a dynamic moving body and a static body. The basic concept of the game will be to create an infinite bouncing ball with a moving paddle that will be used to give direction to the ball.</p></div>

<div class="book" title="Integrating physics engine with games">
<div class="book" title="Getting ready..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec97" class="calibre1"/>Getting ready...</h2></div></div></div><p class="calibre8">To develop<a id="id246" class="calibre1"/> a mini game using the physics engine, start by creating a new project. Open Xcode and go to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">Project</strong></span> and then <a id="id247" class="calibre1"/>navigate to <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Application</strong></span> | <span class="strong"><strong class="calibre2">SpriteKit Game</strong></span>. In the pop-up screen, provide the <span class="strong"><strong class="calibre2">Product Name</strong></span> as <code class="email">PhysicsSimulation</code>, navigate to <span class="strong"><strong class="calibre2">Devices</strong></span> | <span class="strong"><strong class="calibre2">iPhone</strong></span> and click on <span class="strong"><strong class="calibre2">Next</strong></span> as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00096.jpeg" alt="Getting ready..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Click on <span class="strong"><strong class="calibre2">Next</strong></span> and save the project on your hard drive.</p><p class="calibre8">Once the project is saved, you should be able to see something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00097.jpeg" alt="Getting ready..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the project <a id="id248" class="calibre1"/>settings page, just uncheck the <span class="strong"><strong class="calibre2">Portrait</strong></span> from <span class="strong"><strong class="calibre2">Device</strong></span> <span class="strong"><strong class="calibre2">Orientation</strong></span> section as we are supporting only landscape mode for this game.</p><p class="calibre8">Graphics<a id="id249" class="calibre1"/> and games cannot be separated for long; you will also need some graphics for this game. Download the graphics folder, drag it and import it into the project. Make sure that the <span class="strong"><strong class="calibre2">Copy items into destination group's folder (if needed)</strong></span> is checked and then click on <span class="strong"><strong class="calibre2">Finish</strong></span> button. It should be something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00098.jpeg" alt="Getting ready..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Integrating physics engine with games">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec98" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Now your <a id="id250" class="calibre1"/>project template is ready for a physics-based mini game. We <a id="id251" class="calibre1"/>need to update the game template project to get started with code game logic. Take the following steps to integrate the basic physics object in the game.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the file <code class="email">GameScene.m</code> .This class creates a scene that will be plugged into the games. Remove all code from this class and just add the following function:<div class="informalexample"><pre class="programlisting">-(id)initWithSize:(CGSize)size {
    if (self = [super initWithSize:size]) {
        SKSpriteNode* background = [SKSpriteNode spriteNodeWithImageNamed:@"bg.png"];
        background.position = CGPointMake(self.frame.size.width/2, self.frame.size.height/2);
        [self addChild:background];
    }
}</pre></div><p class="calibre15">This <code class="email">initWithSize</code> method creates an blank scene of the specified size. The code written inside the <code class="email">init</code> function allows you to add the background image at the center of the screen in your game.</p></li><li class="listitem" value="2">Now<a id="id252" class="calibre1"/> when you compile and run the code, you<a id="id253" class="calibre1"/> will observe that the background image is not placed correctly on the scene. To resolve this, open <code class="email">GameViewController.m</code>. Remove all code from this file and add the following function;<div class="informalexample"><pre class="programlisting">-(void)viewWillLayoutSubviews {
    [super viewWillLayoutSubviews];
    
    // Configure the view.
    SKView * skView = (SKView *)self.view;
    if (!skView.scene) {
        skView.showsFPS = YES;
        skView.showsNodeCount = YES;
        
        // Create and configure the scene.
        GameScene * scene = [GameScene sceneWithSize:skView.bounds.size];
        scene.scaleMode = SKSceneScaleModeAspectFill;
        
        // Present the scene.
        [skView presentScene:scene];
    }
}</pre></div><p class="calibre15">To ensure that the view hierarchy is properly laid out, we have implemented the <code class="email">viewWillLayoutSubviews</code> method. It does not work perfectly in <code class="email">viewDidLayoutSubviews</code> method because the size of the scene is not known at that time.</p></li><li class="listitem" value="3">Now compile and run the app. You should be able to see the background image correctly. It will look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00099.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">So <a id="id254" class="calibre1"/>now that we have the background image in place, let us add gravity to the world. Open <code class="email">GameScene.m</code> and add the following line of code at the end of the <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">self.physicsWorld.gravity = CGVectorMake(0.0f, 0.0f);</pre></div><p class="calibre15">This line of code will set the gravity of the world to 0, which means there will be no gravity.</p></li><li class="listitem" value="5">Now as we<a id="id255" class="calibre1"/> have removed the gravity to make the object fall freely, it's important to create a boundary around the world, which will hold all the objects of the world and prevent them to go off the screen. Add the following line of code to add the invisible boundary around the screen to hold the physics objects:<div class="informalexample"><pre class="programlisting">// 1 Create a physics body that borders the screen
SKPhysicsBody* gameborderBody = [SKPhysicsBody bodyWithEdgeLoopFromRect:self.frame];
// 2 Set physicsBody of scene to borderBody
self.physicsBody = gameborderBody;
// 3 Set the friction of that physicsBody to 0
self.physicsBody.friction = 0.0f;</pre></div><p class="calibre15">In the first line, we are are creating an edge-based physics boundary object, with a screen size frame. This type of a physics body does not have any mass or volume and also remains unaffected by force and impulses. Then we associate the object with the physics body of the scene. In the last line we set the friction of the body to 0, for a seamless interaction between objects and the boundary surface. The final file should look something like the following screenshot:</p><div class="mediaobject"><img src="../images/00100.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">Now<a id="id256" class="calibre1"/> we<a id="id257" class="calibre1"/> have our surface ready to hold the physics world objects. Let us create a new physics world object using the following line of code:<div class="informalexample"><pre class="programlisting">// 1
SKSpriteNode* circlularObject = [SKSpriteNode spriteNodeWithImageNamed: @"ball.png"];
circlularObject.name = ballCategoryName;
circlularObject.position = CGPointMake(self.frame.size.width/3, self.frame.size.height/3);
[self addChild:circlularObject];

// 2
circlularObject.physicsBody = [SKPhysicsBody bodyWithCircleOfRadius:circlularObject.frame.size.width/2];
// 3
circlularObject.physicsBody.friction = 0.0f;
// 4
circlularObject.physicsBody.restitution = 1.0f;
// 5
circlularObject.physicsBody.linearDamping = 0.0f;
// 6
circlularObject.physicsBody.allowsRotation = NO;</pre></div><p class="calibre15">Here we have created the sprite and then we have added it to the scene. Then in the later steps we associate the circular physics body with the sprite object. Finally, we alter the properties of that physics body.</p></li><li class="listitem" value="7">Now<a id="id258" class="calibre1"/> compile and run the application; you <a id="id259" class="calibre1"/>should be able to see the circular ball on the screen as shown in screenshot below:<div class="mediaobject"><img src="../images/00101.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="8">The circular ball is added to the screen, but it does nothing. So it's time to add some action in the code. Add the following line of code at the end of the <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">[circlularObject.physicsBody applyImpulse:CGVectorMake(10.0f, -10.0f)];</pre></div><p class="calibre15">This will apply the force on the physics body, which in turn will move the associated ball sprite as well.</p></li><li class="listitem" value="9">Now compile and run the project. You should be able to see the ball moving and then collide with the boundary and bounce back, as there is no friction between the boundary and the ball. So now we have the infinite bouncing ball in the game.<div class="mediaobject"><img src="../images/00102.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Integrating physics engine with games">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec99" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre8">There<a id="id260" class="calibre1"/> are several<a id="id261" class="calibre1"/> properties used while creating physics bodies to define their behavior in the physics world. The following is a detailed description of the properties used in the preceding code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Restitution property</strong></span> defines<a id="id262" class="calibre1"/> the bounciness of an object. Setting the restitution to <code class="email">1.0f</code>, means that the ball collision will be perfectly elastic with any object. This means that the ball will bounce back with a force equal to the impact.</li><li class="listitem"><span class="strong"><strong class="calibre2">Linear Damping</strong></span><span class="strong"><strong class="calibre2"> property</strong></span> <a id="id263" class="calibre1"/>allows the simulation of fluid or air friction. This is accomplished by reducing the linear velocity of the body. In our case, we do not want the ball to slow down while moving and hence we have set the restitution to <code class="email">0.</code><code class="email">0f</code>.</li></ul></div></div></div>

<div class="book" title="Integrating physics engine with games">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec100" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre8">You can read about all these properties in detail at Apple's developer documentation: <a class="calibre1" href="https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html">https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding real-world simulation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec38" class="calibre1"/>Adding real-world simulation</h1></div></div></div><p class="calibre8">Now <a id="id264" class="calibre1"/>we will be <a id="id265" class="calibre1"/>adding some real simulation in the game. We will add more physics bodies and make them interact with each other. This will help us to understand the physics interaction between various physics objects.</p></div>

<div class="book" title="Adding real-world simulation">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec101" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Now we have <a id="id266" class="calibre1"/>the infinite bouncing ball in place. To add more fun to the game, let us add some more elements to the it.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First we will add the static block to the game. To accomplish this, add the following line of code at the end of the <code class="email">initWithSize</code> method:<div class="informalexample"><pre class="programlisting">SKSpriteNode* block = [[SKSpriteNode alloc] initWithImageNamed: @"block.png"];
block.name = paddleCategoryName;
block.position = CGPointMake(CGRectGetMidX(self.frame), block.frame.size.height * 0.6f);
[self addChild:block];
block.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:block.frame.size];
block.physicsBody.restitution = 0.1f;
block.physicsBody.friction = 0.4f;
// make physicsBody static
block.physicsBody.dynamic = NO;</pre></div><p class="calibre15">First we create the block sprite. After that we associate a physics body to it and change the various parameters of the physics body object as well. The most important thing to note here is <code class="email">block.physicsBody.dynamic = NO</code>. By default all the physics bodies are dynamic; so to create static bodies, we just need to set the <code class="email">physicsBody.dynamic</code> Boolean to <code class="email">NO</code>.</p></li><li class="listitem" value="2">After adding the code, the final file should look something similar to the following screenshot:<div class="mediaobject"><img src="../images/00103.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Now<a id="id267" class="calibre1"/> compile and run the code. You <a id="id268" class="calibre1"/>should be able to see the block on the screen with a static body. Observe closely that when the ball collides with the block, it bounces back and you can play with it endlessly.<div class="mediaobject"><img src="../images/00104.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">It's time to add some more action to make the game exciting. Now we will make the <a id="id269" class="calibre1"/>block paddle move based on touch. The following functions will help us to accomplish this:<div class="informalexample"><pre class="programlisting">-(void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event;
-(void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event;
-(void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event;</pre></div><p class="calibre15">These methods provide the callback when you touch the screen and also provide the list of the objects which were touched. There are three callbacks for touch begin, touch move and touch end action.</p></li><li class="listitem" value="5">Now <a id="id270" class="calibre1"/>add the following code just before the <code class="email">@implementation</code> line in <code class="email">GameScene.m</code> file:<div class="informalexample"><pre class="programlisting">@interface GameScene()

@property (nonatomic) BOOL isPaddleTapped;

@end</pre></div><p class="calibre15">We have thus created a property to hold the user's state of touch on the paddle.</p></li><li class="listitem" value="6">Now we will implement <code class="email">touchesBegan:withEvent</code> function in our <code class="email">GameScene.m</code> file. Add the following function just next to the <code class="email">init</code> method:<div class="informalexample"><pre class="programlisting">-(void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    
    UITouch* touch = [touches anyObject];
    CGPoint touchLocation = [touch locationInNode:self];
    
    SKPhysicsBody* body = [self.physicsWorld bodyAtPoint:touchLocation];
    if (body &amp;&amp; [body.node.name isEqualToString: paddleCategoryName]) {
        NSLog(@"touch began on paddle");
        self.isPaddleTapped = YES;
    }
}</pre></div><p class="calibre15">This function will listen for the touch begin event and use it to find the body at the location where the user taps on the scene. In the next line, we get the physics body at the touch location.</p></li><li class="listitem" value="7">Now <a id="id271" class="calibre1"/>compile and run the code. When you touch on the paddle, you should be able to see the logs demonstrating the touch working on the paddle.<div class="mediaobject"><img src="../images/00105.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="8">Now let <a id="id272" class="calibre1"/>us go ahead and implement <code class="email">touchesMoved:withEvent</code> and add the following function just next to <code class="email">touchesBegan</code>:<div class="informalexample"><pre class="programlisting">-(void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event {

    if (self.isPaddleTapped) {
        // 2 Get touch location
        UITouch* touch = [touches anyObject];
        CGPoint touchLocation = [touch locationInNode:self];
        CGPoint previousLocation = [touch previousLocationInNode:self];
        // 3 Get node for paddle
        SKSpriteNode* paddle = (SKSpriteNode*)[self childNodeWithName: paddleCategoryName];
        // 4 Calculate new position along x for paddle
        int paddleX = paddle.position.x + (touchLocation.x - previousLocation.x);
        // 5 Limit x so that the paddle will not leave the screen to left or right
        paddleX = MAX(paddleX, paddle.size.width/2);
        paddleX = MIN(paddleX, self.size.width - paddle.size.width/2);
        // 6 Update position of paddle
        paddle.position = CGPointMake(paddleX, paddle.position.y);
    }
}</pre></div><p class="calibre15">Initially, check if the paddle is tapped. If yes, then update the paddle position based on the user's touch location. While repositioning, we just need to make sure that the position <span class="strong"><em class="calibre9">y</em></span> of the paddle does not change.</p></li><li class="listitem" value="9">Finally <a id="id273" class="calibre1"/>add the following function <a id="id274" class="calibre1"/>after <code class="email">touchedMoved</code> in the <code class="email">GameScene.m</code> file:<div class="informalexample"><pre class="programlisting">-(void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event {
    self.isPaddleTapped = NO;
}</pre></div><p class="calibre15">Just turn the <code class="email">isPaddleTapped</code> flag off in the touch end function.</p></li><li class="listitem" value="10">Now compile and run the game. You should be able to move the paddle block to hit the ball and keep it moving. You should tap on the paddle to move it to the left and right sides of the screen.</li></ol><div class="calibre14"/></div></div></div></body></html>