<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Evolution &#x2013; From Objective-C to RubyMotion"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Evolution – From Objective-C to RubyMotion</h1></div></div></div><p>
<span class="emphasis"><em>"Actually, I'm trying to make Ruby natural, not simple."</em></span>
</p><p>
<span class="emphasis"><em>— Matz</em></span>
</p><p>In this chapter, we will have a detailed discussion on how Ruby is implemented in RubyMotion<a id="id126" class="indexterm"/>. We will also understand how we can use the various Objective-C objects in our Ruby code. As we know, the iOS SDK is written in Objective-C, which is a simple extension of the C language. Since this is a book on learning RubyMotion, we will not focus too much on this. However, we will make sure you have enough knowledge on Objective-C to program in RubyMotion. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Ruby and Objective-C work together in RubyMotion</li><li class="listitem" style="list-style-type: disc">In what ways are RubyMotion objects inherited from Objective-C</li><li class="listitem" style="list-style-type: disc">Interfacing with C and Objective-C – learning about data types</li><li class="listitem" style="list-style-type: disc">Memory management with RubyMotion</li></ul></div><div class="section" title="Ruby and Objective-C – a partnership"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Ruby and Objective-C – a partnership</h1></div></div></div><p>You must be<a id="id127" class="indexterm"/> wondering how Objective-C and Ruby can work together, as Objective-C is a compiled language and Ruby is an interpreted language. Then how come they work together in RubyMotion?</p><p>In reality, Objective-C <a id="id128" class="indexterm"/>in the iOS SDK not only has a compiler, but also has a runtime system to execute the compiled code. This runtime system acts as an interface for the Objective-C language; this is what makes the language work. RubyMotion takes advantage of the Objective-C runtime and our Ruby code interacts through this runtime system in just the same way as an Objective-C code does. That means Ruby and Objective-C are effectively working on top of the Objective-C runtime.</p><div class="mediaobject"><img src="graphics/5220OT_03_01.jpg" alt="Ruby and Objective-C – a partnership"/></div><p>The <a id="id129" class="indexterm"/>preceding diagram represents the way RubyMotion and Objective-C work together in an iOS SDK<a id="id130" class="indexterm"/> ecosystem. In simple terms, this means we can access all iOS SDK classes with RubyMotion through the Objective-C runtime. The <span class="strong"><strong>Foundation Framework</strong></span> <a id="id131" class="indexterm"/> is an Objective-C framework, but the great news is that RubyMotion is, in fact, based on Objective-C runtime; therefore, the classes that are defined can naturally be re-used in RubyMotion.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The runtime library is written mainly in the C language and is open source. This is available at <a class="ulink" href="http://opensource.apple.com">http://opensource.apple.com</a>.</p></div></div><div class="section" title="Ruby and Objective-C share the same ancestor"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Ruby and Objective-C share the same ancestor</h2></div></div></div><p>Some of the built-in classes of RubyMotion are based on the Foundation Framework. To better understand this, let's fire up REPL in our console for our existing RubyMotion application from the previous <a id="id132" class="indexterm"/>chapter. As you may remember, in that chapter we had learned how to use REPL. Run the <code class="literal">rake</code> command<a id="id133" class="indexterm"/> to start REPL and then run the following commands in REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(main)&gt; a = 5</strong></span>
<span class="strong"><strong>=&gt; 5</strong></span>
<span class="strong"><strong>(main)&gt; a.class</strong></span>
<span class="strong"><strong>=&gt; Fixnum</strong></span>
<span class="strong"><strong>(main)&gt; a.superclass</strong></span>
<span class="strong"><strong>=&gt; NSNumber</strong></span>
<span class="strong"><strong>(main)&gt; name = ""Abhishek""</strong></span>
<span class="strong"><strong>=&gt; ""Abhishek""</strong></span>
<span class="strong"><strong>(main)&gt; name.class</strong></span>
<span class="strong"><strong>=&gt; String</strong></span>
<span class="strong"><strong>(main)&gt; name.superclass</strong></span>
<span class="strong"><strong>=&gt; NSMutableString</strong></span>
<span class="strong"><strong>(main)&gt; a.superclass.superclass</strong></span>
<span class="strong"><strong>=&gt; NSString</strong></span>
<span class="strong"><strong>(main)&gt; a.superclass.superclass.superclass</strong></span>
<span class="strong"><strong>=&gt; NSObject</strong></span>
</pre></div><p>In the preceding example, we have found the root for the Ruby <code class="literal">integer</code> and <code class="literal">string</code> classes. Firstly, we declared a variable and assigned an integer value to it. When we trace its class, we see a familiar name, <code class="literal">Fixnum</code>, which is a Ruby data type. But when we trace back to the super class for <code class="literal">Fixnum</code>, we see that it's an Objective-C Integer type. This shows that the RubyMotion <code class="literal">Fixnum</code> data type is inherited from <code class="literal">NSNumber</code>.</p><p>Similarly, when we declare a string variable name and then trace its class, we see a recognizable Ruby class, <code class="literal">String</code>. Moreover, this string class is inherited from <code class="literal">NSMutableString</code>. This means the <code class="literal">String</code> Ruby class is a subclass of the Objective-C <code class="literal">String</code> class in RubyMotion.</p><div class="mediaobject"><img src="graphics/5220OT_03_02.jpg" alt="Ruby and Objective-C share the same ancestor"/></div><p>A direct consequence of hosting the Ruby built-in classes over Foundation is that their instances respond <a id="id134" class="indexterm"/>to more messages. For example, the <code class="literal">NSString</code> class<a id="id135" class="indexterm"/> defines the uppercase <code class="literal">String</code> method. Since the <code class="literal">String</code> class<a id="id136" class="indexterm"/> is a subclass of <code class="literal">NSString</code>, strings created in Ruby also respond to that method, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>''hello''.uppercaseString # =&gt; ''HELLO''</strong></span>
</pre></div><p>This gives us immense flexibility to not only use Ruby methods, but also access thousands of classes and methods from the Foundation Framework, making it possible to create any app one can imagine.</p><p>Other data types are also inherited in the same fashion. Just have a look at the following table (source – <a class="ulink" href="http://www.rubymotion.com/developer-center/guides/runtime">http://www.rubymotion.com/developer-center/guides/runtime</a>):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Ruby class</p>
</th><th style="text-align: left" valign="bottom">
<p>Ancestors</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">foo</code>
<a id="id137" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">NSObject</code> → <code class="literal">Kernel</code>
<a id="id138" class="indexterm"/>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">String</code>
<a id="id139" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<a id="id140" class="indexterm"/>
<p>
<code class="literal">NSMutableString</code> → <code class="literal">NSString</code> → <code class="literal">Comparable</code> → <code class="literal">NSObject</code> → <code class="literal">Kernel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Array</code>
<a id="id141" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<a id="id142" class="indexterm"/>
<p>
<code class="literal">NSMutableArray</code> → <code class="literal">NSArray</code> → <code class="literal">Enumerable</code> → <code class="literal">NSObject</code> → <code class="literal">Kernel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Hash</code>
<a id="id143" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<a id="id144" class="indexterm"/>
<p>
<code class="literal">NSMutableDictionary</code> → <code class="literal">NSDictionary</code> → <code class="literal">Enumerable</code> → <code class="literal">NSObject</code> → <code class="literal">Kernel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Numeric</code>
<a id="id145" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<a id="id146" class="indexterm"/>
<p>
<code class="literal">Comparable</code> → <code class="literal">NSNumber</code> → <code class="literal">NSValue</code> → <code class="literal">NSObject</code> → <code class="literal">Kernel</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Time</code>
<a id="id147" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<a id="id148" class="indexterm"/>
<p>
<code class="literal">Comparable</code> → <code class="literal">NSDate</code> → <code class="literal">NSObject</code> → <code class="literal">Kernel</code>
</p>
</td></tr></tbody></table></div><p>You must have noticed that strings created in RubyMotion inherit from <code class="literal">NSMutableString</code> instead of <code class="literal">NSMutable</code>. Isn't that strange? It will be good to know the difference between these two. <code class="literal">NSMutableString</code> objects provide us with methods to change the underlying array of characters that they represent, while <code class="literal">NSString</code> objects do not. For example, <code class="literal">NSMutableString</code> provides us methods such as <code class="literal">appendString</code>, <code class="literal">deleteCharactersInRange</code>, <code class="literal">insertString</code>, and <code class="literal">replaceOccurencesWithString</code>. All these methods operate directly on the <code class="literal">NSMutableString</code> object in memory, which means we can modify the original value. On the other hand, <code class="literal">NSString</code> is a create-once-then-read-only<a id="id149" class="indexterm"/> string. We have many manipulation methods (<code class="literal">substring</code>, <code class="literal">uppercaseString</code>, and so on) for <code class="literal">NSString</code> objects. However, they return a new <code class="literal">NSString</code> object and never actually modify the existing string in memory, as shown here:</p><div class="informalexample"><pre class="programlisting">NSString.new.strip!           # raises RuntimeError: can't 
 # modify frozen/immutable string

NSMutableString.new.strip!    # works</pre></div><p>As there is no read-only string in Ruby and we need to update the string too, we are using <code class="literal">NSMutableString</code> by default. The same goes for arrays and hashes that are inherited from <code class="literal">NSMutableArray</code> and <code class="literal">NSMutableDictionary</code> respectively.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Foundation comes with the <code class="literal">NSObject</code> root object class, as well as a set of other primitive object classes. In RubyMotion, <code class="literal">Object</code> is an alias of <code class="literal">NSObject</code>, making <code class="literal">NSObject</code> the root class of all Ruby classes.</p></div></div></div></div></div>
<div class="section" title="Interfacing with C and Objective-C"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Interfacing with C and Objective-C</h1></div></div></div><p>Although working with RubyMotion does not require one to learn Objective-C, or even C for that matter, sometimes when you want to use the iOS API, knowledge of its Ruby equivalent is beneficial. Objective-C is a superset of the C language. Objective-C methods can therefore accept and return C-language types.</p><div class="section" title="Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Types</h2></div></div></div><p>C language—<a id="id150" class="indexterm"/>and indirectly Objective-C—has a set of <a id="id151" class="indexterm"/>basic data types that are used in the iOS SDK APIs. In order to accept or return these data types, we need some equivalent data types for Ruby.</p><p>For example, let's create a function named <code class="literal">foo</code> that accepts a C integer type as a parameter and returns the <code class="literal">some_number</code> integer:</p><div class="informalexample"><pre class="programlisting">int foo(int some_number)
{
  return some_number;
}</pre></div><p>So, if we <a id="id152" class="indexterm"/>want to call the preceding function from Ruby, we will require some equivalent Ruby type. Basic C types cannot be created from Ruby directly, but are automatically converted from and to equivalent Ruby types. You don't <a id="id153" class="indexterm"/>have to worry, RubyMotion will take care of this for you.</p><p>Let's discuss all of the basic C types and discuss how they are converted from C data types to Ruby data types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">void</code>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From Ruby to C – <code class="literal">nil</code> is similar to <code class="literal">void</code>.</li><li class="listitem" style="list-style-type: disc">From C to Ruby – <code class="literal">void</code> is similar to <code class="literal">nil</code>.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">char</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and <code class="literal">long_long</code>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From Ruby to C – If the object is <code class="literal">Fixnum</code> or <code class="literal">Bignum</code>, the value is returned. If the object is <code class="literal">true</code> or <code class="literal">false</code>, <code class="literal">1</code> or <code class="literal">0</code> are returned respectively. The <code class="literal">char</code> data type is mapped with <code class="literal">string</code> and the value returned is the same.</li><li class="listitem" style="list-style-type: disc">From C to Ruby – Either a <code class="literal">Fixnum</code> or <code class="literal">Bignum</code> object is returned.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Bool</code>/<code class="literal">BOOL</code>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From Ruby to C – If the value of an object is <code class="literal">false</code> or <code class="literal">nil</code>, <code class="literal">false</code> will be returned, else <code class="literal">true</code> will be returned. Whereas, for <code class="literal">0</code>, <code class="literal">Fixnum true</code> will be returned.</li><li class="listitem" style="list-style-type: disc">From C to Ruby – <code class="literal">true</code> or <code class="literal">false</code> will be returned.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">float</code> and <code class="literal">double</code>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">From Ruby to C:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For a <code class="literal">float</code> object, a value is returned.</li><li class="listitem" style="list-style-type: disc">For <code class="literal">true</code> or <code class="literal">false</code>, <code class="literal">1.0</code> or <code class="literal">0.0</code> are returned respectively.</li><li class="listitem" style="list-style-type: disc">If the object responds to the <code class="literal">to_f</code> message, the message is sent and the result is returned.</li></ul></div></li><li class="listitem" style="list-style-type: disc">From C to Ruby – it is the <code class="literal">float</code> object.</li></ul></div></li></ul></div></div><div class="section" title="Enumerations and constants"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Enumerations and constants</h2></div></div></div><p>Generally, C code uses enumerations and constants extensively, but we don't have these in Ruby. So they are mapped to constants of the <code class="literal">Object</code> class<a id="id154" class="indexterm"/>. Both enumerations and constants defined by the Foundation can be directly accessed.</p><p>For example, <code class="literal">NSNotFound</code> is an enumeration and we can directly access it as shown here:</p><div class="informalexample"><pre class="programlisting">if ary.indexOfObject(obj) == NSNotFound
  # Some Code
end</pre></div><p>Also, a constant such as <code class="literal">AVMediaTypeAudio</code> can be directly accessed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>There<a id="id155" class="indexterm"/> are many enumerations or constants defined in the iOS SDK that start with a lowercase letter, such as <code class="literal">kCLLocationAccuracyNearestTenMeters</code>, which starts with <code class="literal">k</code>. But since Ruby constants always begin with a capital letter, their names must be changed by making the lowercase of the first letter uppercase. Therefore, the constant from the preceding example becomes <code class="literal">KCLLocationAccuracyNearestTenMeters;</code> (starting with a capital <code class="literal">K</code>) in Ruby.</p><div class="informalexample"><pre class="programlisting">locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;
# NameError: undefined local variable or method
locationManager.desiredAccuracy = KCLLocationAccuracyNearestTenMeters; # works</pre></div></div></div></div><div class="section" title="Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Functions</h2></div></div></div><p>C functions <a id="id156" class="indexterm"/>are available as methods to be used in Ruby code in RubyMotion.</p><p>For example, the <code class="literal">CGPointMake</code> function<a id="id157" class="indexterm"/> can be used in Ruby to create a rectangular structure.</p><div class="informalexample"><pre class="programlisting">pt = CGPointMake(100, 200)
''Hello''.drawAtPoint(pt, withFont: font)</pre></div><p>Many functions in the iOS SDK start with a capital letter. And there is also a possibility that a few of <a id="id158" class="indexterm"/>them accept no arguments; in such cases, it can create confusion and the compiler may treat such expressions as constants. So it is very important to use parentheses explicitly when calling such functions, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">NSHomeDirectory   # NameError: uninitialized constant  
 # NSHomeDirectory
NSHomeDirectory() # works</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Inline functions, which are implemented in the framework's header, are also supported by RubyMotion.</p></div></div></div><div class="section" title="Structures"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Structures</h2></div></div></div><p>A structure is a <a id="id159" class="indexterm"/>collection of one or more variables, possibly of different data types, grouped together under a single name for convenient handling. To map C structures with Ruby, RubyMotion uses classes, which means structures can be created in Ruby and then passed to APIs that expect C structures. Similarly, APIs returning C structures will return an instance of the appropriate structure class.</p><p>A structure class has an <code class="literal">accessor</code> method<a id="id160" class="indexterm"/> for each field of the corresponding C structure it wraps.</p><p>For example, the following piece of code creates a <code class="literal">CGPoint</code> structure, sets its <code class="literal">x</code> and <code class="literal">y</code> fields, and then passes it to the <code class="literal">drawAtPoint:withFont:</code> method<a id="id161" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">pt = CGPoint.new
pt.x = 100
pt.y = 200
''Hello''.drawAtPoint(pt, withFont: font)</pre></div><p>We can also pass this value directly to the constructor:</p><div class="informalexample"><pre class="programlisting">pt = CGPoint.new(100, 200)
''Hello''.drawAtPoint(pt, withFont: font)</pre></div><p>RubyMotion will also accept arrays for our convenience. They must contain the same number and type of objects expected in the structure. Here is an example:</p><div class="informalexample"><pre class="programlisting">''Hello''.drawAtPoint([100, 200], withFont: font)</pre></div></div><div class="section" title="Pointers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Pointers</h2></div></div></div><p>C and Objective-C both commonly make use of pointers and therefore it is extensively used in the iOS SDK too. In the iOS SDK, pointers are usually used as arguments to return objects by reference.<a id="id162" class="indexterm"/> For example, the <code class="literal">NSData</code> method expects an error pointer that will be set to an <code class="literal">NSError</code> object in case of a failure.</p><p>As there is no pointer concept in Ruby, RubyMotion uses the <code class="literal">Pointer</code> class in order to create and manipulate pointers. To create a new pointer, use the following syntax:</p><div class="informalexample"><pre class="programlisting">name = Pointer.new(:char)</pre></div><p>We can see that we have passed <code class="literal">char</code> in a <code class="literal">new</code> initializer, which will create a string pointer. Similarly, to create a different type of pointer, we can pass the following parameters in the <code class="literal">Pointer</code> class (source – <a class="ulink" href="http://www.rubymotion.com/developer-center/guides/runtime/#_pointers">http://www.rubymotion.com/developer-center/guides/runtime/#_pointers</a>):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>C type pointer</p>
</th><th style="text-align: left" valign="bottom">
<p>Runtime type string</p>
</th><th style="text-align: left" valign="bottom">
<p>Shortcut symbol</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">id*</code>
<a id="id163" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""@""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:object</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Char</code>
<a id="id164" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""c""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:char</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned char*</code>
<a id="id165" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""C""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:uchar</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">short*</code>
<a id="id166" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""s""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:short</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned short*</code>
<a id="id167" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""S""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:ushort</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int*</code>
<a id="id168" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""i""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:int</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned int*</code>
<a id="id169" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""I""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:uint</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">long*</code>
<a id="id170" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""l""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:long</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned long*</code>
<a id="id171" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""L""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:ulong</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">long long*</code>
<a id="id172" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""q""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:long_long</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">unsigned long long*</code>
<a id="id173" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""Q""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:ulong_long</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float</code>
<a id="id174" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""f""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:float</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">double*</code>
<a id="id175" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">""d""</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:double</code>
</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Pointers to C characters, which are also called <span class="strong"><strong>C strings</strong></span><a id="id176" class="indexterm"/>, are automatically converted from and to <code class="literal">String</code> objects by RubyMotion.</p></div></div></div><div class="section" title="Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Classes</h2></div></div></div><p>Creating a class in Ruby is simple, but since the iOS SDK is written in Objective-C, it is necessary<a id="id177" class="indexterm"/> to understand Objective-C interfaces and learn how to use them with Ruby.</p><p>An Objective-C<a id="id178" class="indexterm"/> interface always starts with a minus or a plus sign, which is used to declare an instance or class method.</p><p>For example, the following interface declares the <code class="literal">foo</code> instance method on the <code class="literal">Foo</code> class<a id="id179" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">@class Foo
- (id)foo;
 @end</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>The methods that instances of a class can use are called <span class="strong"><strong>instance methods</strong></span>
<a id="id180" class="indexterm"/> and are marked with a minus sign.</p></div></div><p>The following declares the <code class="literal">foo</code> class method<a id="id181" class="indexterm"/> on the same class:</p><div class="informalexample"><pre class="programlisting">@class Foo
+ (id)foo;
 @end</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The names of the methods that can be used by class objects are preceded by a plus sign.</p></div></div><p>As seen in the previous section, arguments in Objective-C methods can be named with a keyword. The following interface declares the <code class="literal">sharedInstanceWithObject:andObject:</code> class<a id="id182" class="indexterm"/> method on the <code class="literal">Test</code> class:</p><div class="informalexample"><pre class="programlisting">@class Test
+ (id)sharedInstanceWithObject:(id)obj1 andObject:(id)obj2;
 @end</pre></div><p>The corresponding Ruby method for the preceding code will be as follows:</p><div class="informalexample"><pre class="programlisting">instance = Test.sharedInstanceWithObject(obj1, andObject:obj2)</pre></div><p>It will call the <code class="literal">sharedInstanceWithObject</code> method<a id="id183" class="indexterm"/> of the <code class="literal">Test</code> class, where <code class="literal">obj1</code> and <code class="literal">obj2</code> are variables of the arguments.</p></div><div class="section" title="Objective-C messages"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Objective-C messages</h2></div></div></div><p>We can send and define Objective-C messages using RubyMotion. As Objective-C uses named arguments, which is unlike Ruby methods, it looks different from a typical Ruby method if it <a id="id184" class="indexterm"/>contains more than one argument.</p><p>Each argument in Objective-C has a keyword associated with it and the final Objective-C message is the combination of all these keywords.</p><div class="informalexample"><pre class="programlisting">UIColor *myColor = [UIColor colorWithRed:0.5f green:0.5f blue:0.5f alpha:1.0f];</pre></div><p>Objective-C messages can be sent from RubyMotion using a similar syntax.</p><div class="informalexample"><pre class="programlisting">myColor = UIColor.colorWithRed(0.5, green:0.5, blue:0.5, alpha:1)</pre></div><p>The message keywords are <code class="literal">colorWithRed:</code>, <code class="literal">green:</code>, <code class="literal">blue:</code>, and <code class="literal">alpha:</code>. The complete message is the combination of these keywords. If you are a Ruby developer, you will probably find it strange to see the colon in the Ruby code. The reason is that this is called a <span class="strong"><strong>named parameter</strong></span>
<a id="id185" class="indexterm"/> and it is very common in RubyMotion applications. As we interact a lot with Objective-C methods and these receive named parameters, we have to pass them in this way.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The syntax used to define Objective-C selectors was added to RubyMotion and is not part of the Ruby standard.</p></div></div></div><div class="section" title="RubyMotion selectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>RubyMotion selectors</h2></div></div></div><p>The Ruby<a id="id186" class="indexterm"/>Motion runtime provides convenient shortcuts for certain Objective-C selectors (source – <a class="ulink" href="http://www.rubymotion.com">http://www.rubymotion.com</a>).</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Selector</p>
</th><th style="text-align: left" valign="bottom">
<p>Shortcut</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setFoo:</code>
<a id="id187" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">foo=</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isFoo</code>
<a id="id188" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">foo?</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">objectForKey:</code>
<a id="id189" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setObject:forKey:</code>
<a id="id190" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[]=</code>
</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Memory management"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Memory management</h1></div></div></div><p>Memory management is an important programming principle of handling the life cycles of objects and releasing them when they are no longer needed in your application. Management of object memory is necessary to have good performance; if an application doesn't free unneeded objects, its memory footprint grows and performance suffers.</p><p>RubyMotion<a id="id191" class="indexterm"/> provides automatic memory management; you do not need to reclaim unused objects. Also, as memory in any iOS device is limited, the bad acting application would just be killed at some point.</p><p>Memory management in a Cocoa application that doesn't use garbage collection is based on a reference-counting method. RubyMotion also uses reference-counting ways to reclaim memory. When you create or copy an object, its retain count is <code class="literal">1</code>. Thereafter, other objects may express an ownership interest in your object, which increments its retain count. The owners of an object may also surrender their possession interest in it, which reduces the retain count. When the retain count becomes zero, the object is deallocated (destroyed).</p><p>Objects created by Objective-C or the Core-Foundation-style APIs are automatically managed by RubyMotion. There is no need to send the retain, release, or auto-release messages to them, or to use the <code class="literal">CFRetain</code> or <code class="literal">CFRelease</code> functions.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>Let's recap what we have just learned in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Objective-C and Ruby work together</li><li class="listitem" style="list-style-type: disc">How RubyMotion objects are inherited from Objective-C</li><li class="listitem" style="list-style-type: disc">How RubyMotion interfaces with C and Objective-C</li><li class="listitem" style="list-style-type: disc">Memory management offered with RubyMotion</li></ul></div><p>In the next chapter, we will learn how we can use the <span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) design principle in our RubyMotion application. We will discuss in detail about the MVC architecture. Later in the chapter, we will have some hands-on examples to learn how to integrate our mobile application with an external API.</p></div></body></html>