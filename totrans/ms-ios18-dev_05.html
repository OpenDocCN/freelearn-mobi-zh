<html><head></head><body>
		<div id="_idContainer030">
			<h1 id="_idParaDest-91" class="chapter-number"><a id="_idTextAnchor186"/><st c="0">5</st></h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor187"/><st c="2">Enhancing iOS Applications with WidgetKit</st></h1>
			<p><st c="43">As iPhones have evolved over the years, new capabilities have been added to take advantage of the big screen, the memory capacity, and the </st><span class="No-Break"><st c="183">powerful processor.</st></span></p>
			<p><st c="202">One of those capabilities is the home screen widgets – a great way to extend our apps and provide information and even interaction in </st><span class="No-Break"><st c="337">new places.</st></span></p>
			<p><st c="348">In this chapter, we will cover the </st><span class="No-Break"><st c="384">following topics:</st></span></p>
			<ul>
				<li><st c="401">The idea </st><span class="No-Break"><st c="411">of widgets</st></span></li>
				<li><st c="421">Understanding how </st><span class="No-Break"><st c="440">widgets work</st></span></li>
				<li><st c="452">Add our first widget and build a timeline </st><span class="No-Break"><st c="495">of entries</st></span></li>
				<li><st c="505">Add a </st><span class="No-Break"><st c="512">user-configurable widget</st></span></li>
				<li><st c="536">Ensure our widgets are up </st><span class="No-Break"><st c="563">to date</st></span></li>
				<li><st c="570">Customize the </st><span class="No-Break"><st c="585">widget animations</st></span></li>
				<li><st c="602">Add user interactions such as buttons </st><span class="No-Break"><st c="641">and toggles</st></span></li>
				<li><st c="652">Add a control widget to the control center and </st><span class="No-Break"><st c="700">lock screen</st></span></li>
			</ul>
			<p><st c="711">So, let’s start with the basics – what is the idea </st><span class="No-Break"><st c="763">of widgets?</st></span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor188"/><st c="774">Technical requirements</st></h1>
			<p><st c="797">For this chapter, it’s essential to download Xcode version 15.0 or higher from the </st><span class="No-Break"><st c="881">App Store.</st></span></p>
			<p><st c="891">Ensure you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="972">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1070">Open Xcode and complete any further setup instructions that appear. </st><st c="1138">After Xcode is completely up and running, you </st><span class="No-Break"><st c="1184">can begin.</st></span></p>
			<p><st c="1194">To gain additional capabilities, such as sharing data between the widget and the app, you must set up AppGroups and define your AppGroups in </st><span class="No-Break"><st c="1336">your profile.</st></span></p>
			<p><st c="1349">Download the sample code from the following </st><span class="No-Break"><st c="1394">GitHub link:</st></span></p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205"><span class="No-Break"><st c="1406">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205</st></span></a></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor189"/><st c="1492">The idea of widgets</st></h1>
			<p><st c="1512">Adding a widget is not a new concept in iOS or, in fact, in the </st><span class="No-Break"><st c="1577">Apple ecosystem.</st></span></p>
			<p><st c="1593">Widgets existed </st><a id="_idIndexMarker214"/><st c="1610">long ago in 2005 in the </st><em class="italic"><st c="1634">Tiger</st></em><st c="1639"> version of macOS, as part of the Dashboard feature. </st><st c="1692">Apple took that idea and introduced </st><em class="italic"><st c="1728">Today Widgets</st></em><st c="1741"> in the </st><em class="italic"><st c="1749">Notification Center</st></em><st c="1768"> in iOS 8, and in iOS 14, Apple introduced the home screen widgets, similar to the widgets that already exist in the Android operating system. </st><st c="1911">In iOS 18, Apple added the ability for third-party applications to add widgets to the control center and the </st><span class="No-Break"><st c="2020">home screen.</st></span></p>
			<p><st c="2032">The idea of widgets is not to act as a full-blown application – widgets are not supposed to be a mini-version of our app or one of its screens, but rather an extension of our current </st><span class="No-Break"><st c="2216">app’s capabilities.</st></span></p>
			<p><st c="2235">Widgets exist to enhance user convenience and productivity and, in general, the </st><span class="No-Break"><st c="2316">overall experience.</st></span></p>
			<p><st c="2335">There are </st><a id="_idIndexMarker215"/><st c="2346">three key roles for widgets </st><span class="No-Break"><st c="2374">in iOS:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="2381">Information at a glance</st></strong><st c="2405"> – Widgets provide up-to-date and important information to the user about our app. </st><st c="2488">It can be a delivery status, stock values, event calendars, or any other information that is useful on a </st><span class="No-Break"><st c="2593">day-to-day basis.</st></span></li>
				<li><strong class="bold"><st c="2610">A shortcut to our app</st></strong><st c="2632"> – Tapping on a widget opens our app, and in many cases, a specific screen of our app. </st><st c="2719">Opening our app using widgets is even more important in watchOS, where, unlike iOS, the springboard is not the user’s default view. </st><st c="2851">For many app developers, it’s a great way of promoting their app and </st><em class="italic"><st c="2920">fighting</st></em><st c="2928"> for the user’s attention on the </st><span class="No-Break"><st c="2961">home screen.</st></span></li>
				<li><strong class="bold"><st c="2973">Performing basic actions</st></strong><st c="2998"> – Starting iOS 17, Apple added interactive widgets, allowing users to perform basic actions without opening their app, such as completing a task, opening the garage door, or accepting a payment request. </st><st c="3202">In iOS 18, this capability </st><a id="_idIndexMarker216"/><st c="3229">went even further, and it’s possible to add our widgets to the control center, or open them using the action button on iPhone </st><span class="No-Break"><st c="3355">15 devices.</st></span></li>
			</ul>
			<p><st c="3366">Going over the different Apple platforms, we can see that the idea of showing information </st><a id="_idIndexMarker217"/><st c="3457">at a glance is widespread – we’ve got home and lock screen widgets, complications, and live activities in iOS, padOS, macOS, </st><span class="No-Break"><st c="3582">and watchOS.</st></span></p>
			<p><st c="3594">For example, the Yahoo! </st><st c="3619">Weather app shows the weather in the user’s current location and Apple’s Reminders app shows the user’s </st><span class="No-Break"><st c="3723">uncompleted reminders.</st></span></p>
			<p><st c="3745">It’s only natural for Apple to straighten the line between the different platforms into a single framework – </st><span class="No-Break"><em class="italic"><st c="3855">WidgetK</st><a id="_idTextAnchor190"/><a id="_idTextAnchor191"/><st c="3862">it</st></em></span><span class="No-Break"><st c="3865">.</st></span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor192"/><st c="3866">Understanding how widgets work</st></h1>
			<p><st c="3897">As mentioned at the beginning of this chapter, widgets are not mini applications. </st><st c="3980">Instead, widgets are simple views that show relevant information and are updated according to a declared timeline or </st><span class="No-Break"><st c="4097">app events.</st></span></p>
			<p><st c="4108">Widgets run </st><a id="_idIndexMarker218"/><st c="4121">on a different process than the app. </st><st c="4158">They receive a runtime to perform any code, so they work as static views, showing pre-made information to our users. </st><st c="4275">But, since our user’s data is being constantly updated, we can create an array of entries, each with information and a date. </st><st c="4400">The </st><em class="italic"><st c="4404">WidgetCenter</st></em><st c="4416"> is responsible for creating a different view for each one of the entries, storing it, and replacing the </st><a id="_idIndexMarker219"/><st c="4521">widget UI according to the entries’ dates. </st><st c="4564">This array of entries is called </st><span class="No-Break"><st c="4596">a </st></span><span class="No-Break"><strong class="bold"><st c="4598">timeline</st></strong></span><span class="No-Break"><st c="4606">.</st></span></p>
			<p><st c="4607">One good example is the </st><em class="italic"><st c="4632">Next Event</st></em><st c="4642"> widget. </st><st c="4651">The </st><em class="italic"><st c="4655">Next Event</st></em><st c="4665"> widget shows the next event in our calendar, and since we have access to our user’s calendar, we can build a timeline and refresh the widget data based on the calendar event’s list. </st><st c="4848">All we need to provide is the timeline including the different data for each </st><span class="No-Break"><st c="4925">timeline entry.</st></span></p>
			<p><st c="4940">Using a timeline to update the widget’s content makes the widget an extremely effective way to present information to the user, both in battery usage and </st><span class="No-Break"><st c="5095">processing time.</st></span></p>
			<p><st c="5111">However, the timeline also produces some challenges in the way we work with widgets because, unlike the </st><em class="italic"><st c="5216">Next Event</st></em><st c="5226"> widget, not every timeline can be built </st><span class="No-Break"><st c="5267">up front.</st></span></p>
			<p><st c="5276">But let’s wait before we dive into the solution to our problems and try to add our </st><span class="No-Break"><st c="5360">first widget.</st></span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor193"/><st c="5373">Adding a widget</st></h1>
			<p><st c="5389">Widgets operate </st><a id="_idIndexMarker220"/><st c="5406">and live outside of our app, therefor they are considered to be an </st><em class="italic"><st c="5473">extension</st></em><st c="5482"> of </st><span class="No-Break"><st c="5486">our app.</st></span></p>
			<p><st c="5494">To add a new widget – we need to a new </st><strong class="bold"><st c="5534">Widget Extension</st></strong><st c="5550"> target by selecting </st><strong class="bold"><st c="5571">File</st></strong><st c="5575"> -&gt; </st><strong class="bold"><st c="5579">New</st></strong><st c="5582"> -&gt; </st><span class="No-Break"><strong class="bold"><st c="5586">Target…</st></strong></span><span class="No-Break"><st c="5593">.</st></span></p>
			<p><st c="5594">Then, in the </st><strong class="bold"><st c="5608">Choose a template for your new target</st></strong><st c="5645"> window, we search for a widget and add the widget extension (see </st><span class="No-Break"><em class="italic"><st c="5711">Figure 5</st></em></span><span class="No-Break"><em class="italic"><st c="5719">.1</st></em></span><span class="No-Break"><st c="5721">):</st></span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B21795_05_1.jpg" alt="Figure 5.1: The Choose a template for your new target window"/><st c="5724"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5870">Figure 5.1: The Choose a template for your new target window</st></p>
			<p><st c="5930">After clicking on </st><strong class="bold"><st c="5949">Next</st></strong><st c="5953">, we should provide a name for our widget, just like any target we add. </st><st c="6025">In addition, uncheck the </st><em class="italic"><st c="6050">Include Configuration App </st></em><span class="No-Break"><em class="italic"><st c="6076">Intent</st></em></span><span class="No-Break"><st c="6082"> checkbox.</st></span></p>
			<p><st c="6092">Once the widget is added, we can see a new target with the name we provided. </st><st c="6170">Xcode creates a few files for us as part of the widget template (assuming that the target name </st><span class="No-Break"><st c="6265">is </st></span><span class="No-Break"><strong class="source-inline"><st c="6268">MyWidget</st></strong></span><span class="No-Break"><st c="6276">):</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="6279">MyWidgetBundle</st></strong><st c="6294"> – The widget bundle is a container for the different widgets our extension holds. </st><st c="6377">Currently, we have only one widget, but it is possible to </st><span class="No-Break"><st c="6435">add more.</st></span></li>
				<li><strong class="source-inline"><st c="6444">MyWidget</st></strong><st c="6453"> – Contains the widget code itself, including its UI </st><span class="No-Break"><st c="6506">and configuration.</st></span></li>
				<li><strong class="source-inline"><st c="6524">Assets</st></strong><st c="6531"> – An asset catalog specifically for the </st><span class="No-Break"><st c="6572">widget extension.</st></span></li>
				<li><strong class="source-inline"><st c="6589">Info.plist</st></strong><st c="6600"> – Just like any target, the widget extension contains a </st><strong class="source-inline"><st c="6657">plist</st></strong><st c="6662"> file with general information about the </st><span class="No-Break"><st c="6703">widget extension.</st></span></li>
			</ul>
			<p><st c="6720">Now, it’s time to </st><a id="_idIndexMarker221"/><st c="6739">clarify what a widget is – the fact that we have different sizes for a widget doesn’t mean they are different widgets, as the same widget can have multiple sizes. </st><st c="6902">A different widget is usually a different product, a different UI, and a different use case. </st><st c="6995">In our case, the widget bundle describes the different widgets and not the different </st><span class="No-Break"><st c="7080">widget sizes.</st></span></p>
			<p><st c="7093">Now that we have added a widget to our project, we can run our app and add the new widget to our springboard (</st><span class="No-Break"><em class="italic"><st c="7204">Figure 5</st></em></span><span class="No-Break"><em class="italic"><st c="7213">.2</st></em></span><span class="No-Break"><st c="7215">):</st></span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21795_05_2.jpg" alt="Figure 5.2: Our new template widget in the springboard"/><st c="7218"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7220">Figure 5.2: Our new template widget in the springboard</st></p>
			<p><st c="7274">We can see in </st><span class="No-Break"><em class="italic"><st c="7289">Figure 5</st></em></span><em class="italic"><st c="7297">.2</st></em><st c="7299"> that the new widget consists of the current time and some emoji. </st><st c="7365">This is a </st><a id="_idIndexMarker222"/><st c="7375">good time to play with it and to try adding additional </st><span class="No-Break"><st c="7430">widget sizes.</st></span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor194"/><st c="7443">Configuring our widget</st></h2>
			<p><st c="7466">The way we set up our widget’s look and behavior is by determining its configuration. </st><st c="7553">We have </st><a id="_idIndexMarker223"/><st c="7561">several configurations to work with, and they all conform to a protocol </st><span class="No-Break"><st c="7633">named </st></span><span class="No-Break"><strong class="source-inline"><st c="7639">WidgetConfiguration</st></strong></span><span class="No-Break"><st c="7658">.</st></span></p>
			<p><st c="7659">One of the configurations available for us is </st><strong class="source-inline"><st c="7706">StaticConfiguration</st></strong><st c="7725">. </st><strong class="source-inline"><st c="7727">StaticConfiguration</st></strong><st c="7746"> allows us to create a widget that has no </st><span class="No-Break"><st c="7788">user-configurable options.</st></span></p>
			<p><st c="7814">Let’s have a look at the </st><strong class="source-inline"><st c="7840">StaticConfiguration</st></strong><st c="7859"> that Xcode provides when we add a </st><span class="No-Break"><st c="7894">new widget:</st></span></p>
			<pre class="source-code"><st c="7905">
struct MyWidget: Widget {
    let kind: String = "MyWidget"
    var body: some WidgetConfiguration {
        </st><strong class="bold"><st c="7999">StaticConfiguration(kind: kind, provider:</st></strong>
<strong class="bold"><st c="8040">          Provider()) { entry in</st></strong>
<strong class="bold"><st c="8063">            MyWidgetEntryView(entry: entry)</st></strong>
<strong class="bold"><st c="8095">                .containerBackground(.fill.tertiary, for:</st></strong>
<strong class="bold"><st c="8136">                  .widget)</st></strong>
<strong class="bold"><st c="8144">        }</st></strong>
<strong class="bold"><st c="8146">        .configurationDisplayName("My Widget")</st></strong><st c="8184">
        .description("This is an example widget.")
    }
}</st></pre>			<p><st c="8230">We can </st><a id="_idIndexMarker224"/><st c="8238">see that </st><strong class="source-inline"><st c="8247">StaticConfiguration</st></strong><st c="8266"> has several properties shared with all configuration types. </st><st c="8327">Let’s see them in </st><span class="No-Break"><st c="8345">depth, here:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="8357">kind</st></strong><st c="8362"> – This is the widget configuration unique identifier. </st><st c="8417">It helps us send requests to a specific widget configuration using </st><span class="No-Break"><st c="8484">the </st></span><span class="No-Break"><em class="italic"><st c="8488">WidgetCenter</st></em></span><span class="No-Break"><st c="8500">.</st></span></li>
				<li><strong class="source-inline"><st c="8501">configurationDisplayName</st></strong><st c="8526"> – This is the widget display name as it appears for the user when he wants to pick the right widget </st><span class="No-Break"><st c="8627">to add.</st></span></li>
				<li><strong class="source-inline"><st c="8634">description</st></strong><st c="8646"> – This is the widget’s description that is shown to the user, next to its </st><span class="No-Break"><st c="8721">display name.</st></span></li>
			</ul>
			<p><st c="8734">Besides these three parameters, we have additional important parameters.</st><strong class="source-inline"><st c="8807"> supportedFamilies</st></strong><st c="8825"> determines the different sizes the widget supports. </st><st c="8878">Here’s an example of how to limit the widget to appear only in </st><span class="No-Break"><st c="8941">medium size:</st></span></p>
			<pre class="source-code"><st c="8953">
.supportedFamilies([.systemMedium])</st></pre>			<p><st c="8988">Another property is </st><strong class="source-inline"><st c="9009">backgroundTask</st></strong><st c="9023">, which allows our widget to perform a background operation when the system gives </st><span class="No-Break"><st c="9105">it time.</st></span></p>
			<p><st c="9113">Notice that </st><strong class="source-inline"><st c="9126">WidgetConfiguration</st></strong><st c="9145"> is just a protocol – when creating a widget, we need to return, in the widget body, a structure that conforms to that protocol, and </st><strong class="source-inline"><st c="9278">StaticConfiguration</st></strong><st c="9297"> is just one way to </st><span class="No-Break"><st c="9317">do that.</st></span></p>
			<p><st c="9325">Currently, there are three configurations available </st><span class="No-Break"><st c="9378">for us:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="9385">StaticConfiguration</st></strong><st c="9405"> – As mentioned earlier, this configuration allows us to create a non-user </st><span class="No-Break"><st c="9480">configurable widget</st></span></li>
				<li><strong class="source-inline"><st c="9499">AppIntentConfiguration</st></strong><st c="9522"> – This enables the user to customize their widget, for example, selecting a city for a weather widget, or a specific list for the </st><span class="No-Break"><st c="9653">reminders app</st></span></li>
				<li><strong class="source-inline"><st c="9666">ActivityConfiguration</st></strong><st c="9688"> – This configuration shows live data for the Live </st><span class="No-Break"><st c="9739">Activity widget</st></span></li>
			</ul>
			<p><st c="9754">A widget can </st><a id="_idIndexMarker225"/><st c="9768">contain only one configuration. </st><st c="9800">If we need to have more than one configuration, that’s a good sign we need to create several widgets with different configurations and share some of our code </st><span class="No-Break"><st c="9958">between them.</st></span></p>
			<p><st c="9971">All these widget configurations sound exciting! </st><st c="10020">Let’s start exploring them by starting with </st><span class="No-Break"><st c="10064">the </st></span><span class="No-Break"><strong class="source-inline"><st c="10068">StaticConfiguration</st></strong></span><span class="No-Break"><st c="10087">.</st></span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor195"/><st c="10088">Working with static configuration</st></h2>
			<p><st c="10122">A static widget is a widget that has no user-configurable options. </st><st c="10190">For example, a widget that shows </st><a id="_idIndexMarker226"/><st c="10223">the current time in a specific city cannot be static because the user needs to specify a city or a location for </st><span class="No-Break"><st c="10335">the widget.</st></span></p>
			<p><st c="10346">However, a good example of a static widget is a calendar widget that shows a view of the whole month and marks the current day, or a music app widget that shows the songs that have been </st><span class="No-Break"><st c="10533">played recently.</st></span></p>
			<p><st c="10549">Even though both the calendar and the music app widgets show information not updated by the user, they need to update themselves every once in </st><span class="No-Break"><st c="10693">a while.</st></span></p>
			<p><st c="10701">If we look back at the static configuration example (in the </st><em class="italic"><st c="10762">Configuring our widget</st></em><st c="10784"> section), we can see a parameter called </st><strong class="source-inline"><st c="10825">provider</st></strong><st c="10833">, which contains a parameter for the view builder closure </st><span class="No-Break"><st c="10891">named </st></span><span class="No-Break"><strong class="source-inline"><st c="10897">entry</st></strong></span><span class="No-Break"><st c="10902">.</st></span></p>
			<p><st c="10903">Using </st><strong class="source-inline"><st c="10910">provider</st></strong><st c="10918"> and </st><strong class="source-inline"><st c="10923">entry</st></strong><st c="10928">, we can provide data to our widget across time in an </st><span class="No-Break"><st c="10982">efficient way.</st></span></p>
			<p><st c="10996">One key aspect of Widgets is providing data over time, and we do that using the Timeline provider. </st><st c="11096">Now, let’s understand what Timeline </st><span class="No-Break"><st c="11132">Provider means.</st></span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor196"/><st c="11147">Understanding the Timeline Provider for Widgets</st></h2>
			<p><st c="11195">There’s a reason why it took Apple almost 14 years to support widgets on the iOS home screen. </st><st c="11290">The </st><a id="_idIndexMarker227"/><st c="11294">primary reason is performance, both power and memory performance. </st><st c="11360">While today’s devices are highly capable, having numerous </st><a id="_idIndexMarker228"/><st c="11418">active widgets on the </st><em class="italic"><st c="11440">Springboard</st></em><st c="11451"> can consume a significant amount of power. </st><st c="11495">Hence, we need to find more efficient ways to load our </st><span class="No-Break"><st c="11550">widgets efficiently.</st></span></p>
			<p><st c="11570">We mentioned efficiency in the </st><em class="italic"><st c="11602">Understanding how widgets work</st></em><st c="11632"> section, so let’s get down to the details. </st><st c="11676">Unlike apps, widgets are not active even when they are visible. </st><st c="11740">We can “wake” these widgets at specific times to reload their views. </st><st c="11809">To set the specific periods, we need to create a timeline – an array of entries that contain points in time and </st><span class="No-Break"><st c="11921">relevant data.</st></span></p>
			<p><st c="11935">For example, if we want to reload a calendar widget that displays the next event, we can create a timeline that holds an array of entries, one for each event. </st><st c="12095">Each entry holds an event time and the name of the event that </st><span class="No-Break"><st c="12157">comes afterward.</st></span></p>
			<p><st c="12173">Conversely, if we want a calendar widget that displays full-day information, we may want to create a timeline with an entry for each day. </st><st c="12312">In this case, each entry holds the time of the beginning of the day and the list of events </st><span class="No-Break"><st c="12403">that day.</st></span></p>
			<p><st c="12412">Creating a longer timeline can maximize the frequency of updates for </st><span class="No-Break"><st c="12482">our widget.</st></span></p>
			<p><st c="12493">Now, let’s turn to code and create our first timeline. </st><st c="12549">Here is an example of a timeline provider that displays the </st><span class="No-Break"><st c="12609">next event:</st></span></p>
			<pre class="source-code"><st c="12620">
struct EventEntry: TimelineEntry {
    let date: Date
    let nextEvent: String
}
struct Provider: TimelineProvider {
    func placeholder(in context: Context) -&gt; EventEntry {
        EventEntry(date: Date(), nextEvent: "Loading")
    }
    func getSnapshot(in context: Context, completion:
      @escaping (EventEntry) -&gt; Void) {
        let entry = EventEntry(date: Date(), nextEvent: "Go
          to the book store")
        completion(entry)
    }
    func getTimeline(in context: Context, completion:
      @escaping (Timeline&lt;EventEntry&gt;) -&gt; Void) {
        let entries: [EventEntry] = getListOfEnties()
        let timeline = Timeline(entries: entries, policy:
          .atEnd)
        completion(timeline)
    }
    func getListOfEnties()-&gt;[EventEntry] {
      …
    }
}</st></pre>			<p><st c="13275">The preceding code consists of two structs – </st><strong class="source-inline"><st c="13321">EventEntry</st></strong> <span class="No-Break"><st c="13331">and </st></span><span class="No-Break"><strong class="source-inline"><st c="13336">Provider</st></strong></span><span class="No-Break"><st c="13344">.</st></span></p>
			<p><strong class="source-inline"><st c="13345">EventEntry</st></strong><st c="13356"> is a struct that conforms to </st><strong class="source-inline"><st c="13386">TimeLineEntry</st></strong><st c="13399"> protocol. </st><st c="13410">The </st><strong class="source-inline"><st c="13414">TimeLineEntry</st></strong><st c="13427"> protocol represents a single entry in the widget timeline. </st><st c="13487">The protocol contains a required variable </st><span class="No-Break"><st c="13529">named date:</st></span></p>
			<pre class="source-code"><st c="13540">
var date: Date { get }</st></pre>			<p><st c="13563">The </st><strong class="source-inline"><st c="13568">date</st></strong><st c="13572"> variable contains the entry point in time where we expect our widget to reload. </st><st c="13653">Other than </st><strong class="source-inline"><st c="13664">date</st></strong><st c="13668">, we added another variable that represents the entry’s next event title </st><span class="No-Break"><st c="13741">named </st></span><span class="No-Break"><strong class="source-inline"><st c="13747">nextEvent</st></strong></span><span class="No-Break"><st c="13756">.</st></span></p>
			<p><st c="13757">Our second </st><a id="_idIndexMarker229"/><st c="13769">struct is </st><strong class="source-inline"><st c="13779">Provider</st></strong><st c="13787">. The </st><strong class="source-inline"><st c="13793">Provider</st></strong><st c="13801"> struct conforms to </st><strong class="source-inline"><st c="13821">TimeLineProvider</st></strong><st c="13837">. The goal of the </st><strong class="source-inline"><st c="13855">Provider</st></strong><st c="13863"> struct is to generate a timeline so the </st><em class="italic"><st c="13904">WidgetCenter</st></em><st c="13916"> can reload the widget when needed. </st><st c="13952">Let’s see how the </st><strong class="source-inline"><st c="13970">Provider</st></strong> <span class="No-Break"><st c="13978">does that.</st></span></p>
			<h3><st c="13989">Generating a timeline</st></h3>
			<p><st c="14011">I mentioned earlier that a timeline is an array of timeline entries, but the reality is a little bit more </st><a id="_idIndexMarker230"/><st c="14118">complex than that. </st><st c="14137">Looking at the timeline provider implementation, we can see several functions that help us to deliver a static UI at any </st><span class="No-Break"><st c="14258">given time.</st></span></p>
			<p class="callout-heading"><st c="14269">The Provider struct is a protocol implementation</st></p>
			<p class="callout"><st c="14318">There’s no </st><a id="_idIndexMarker231"/><st c="14330">need to call the </st><strong class="source-inline"><st c="14347">Provider</st></strong><st c="14355"> functions directly. </st><st c="14376">We pass the timeline provider to the widget configuration, and the configuration uses the </st><strong class="source-inline"><st c="14466">Provider</st></strong><st c="14474"> functions </st><span class="No-Break"><st c="14485">when needed.</st></span></p>
			<p><st c="14497">The first and primary function is </st><strong class="source-inline"><st c="14532">getTimeLine</st></strong><st c="14543">. Let’s look at the implementation of the </st><strong class="source-inline"><st c="14585">getTimeline</st></strong> <span class="No-Break"><st c="14596">function here:</st></span></p>
			<pre class="source-code"><st c="14611">
func getTimeline(in context: Context, completion: @escaping
    (Timeline&lt;EventEntry&gt;) -&gt; Void) {
        let entries: [EventEntry] = getListOfEntries()
        let timeline = Timeline(entries: entries, policy:
          .atEnd)
        completion(timeline)
    }</st></pre>			<p><st c="14833">The </st><strong class="source-inline"><st c="14838">getTimeline()</st></strong><st c="14851"> function </st><a id="_idIndexMarker232"/><st c="14861">creates an array of entries, wraps them in a </st><strong class="source-inline"><st c="14906">Timeline</st></strong><st c="14914"> struct, and returns it using the </st><strong class="source-inline"><st c="14948">completion</st></strong><st c="14958"> closure. </st><st c="14968">There </st><a id="_idIndexMarker233"/><st c="14974">are two interesting things </st><a id="_idIndexMarker234"/><st c="15001">we can see here – the </st><strong class="source-inline"><st c="15023">Context</st></strong><st c="15030"> parameter and the </st><strong class="bold"><st c="15049">Timeline </st></strong><span class="No-Break"><strong class="bold"><st c="15058">reload policy</st></strong></span><span class="No-Break"><st c="15071">:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="15073">Context</st></strong><st c="15080"> – The </st><strong class="source-inline"><st c="15087">Context</st></strong><st c="15094"> parameter contains information about the widget environment, such </st><a id="_idIndexMarker235"/><st c="15161">as the widget family (is it a small widget? </st><st c="15205">Perhaps medium?), or the actual widget size. </st><st c="15250">If the widget UI shows more information when it is large, we probably want to load more data into our timeline entry. </st><st c="15368">But the most important information here is probably the </st><strong class="source-inline"><st c="15424">isPreview</st></strong><st c="15433"> property, which indicates whether the widget appears in the widget gallery. </st><st c="15510">Generally speaking, it is best practice to show real user data in our widget in the widget gallery, but that’s not only possible due to security or networking issues. </st><st c="15677">Therefore, we can provide mock data for the widget gallery by checking the </st><span class="No-Break"><strong class="source-inline"><st c="15752">isPreview</st></strong></span><span class="No-Break"><st c="15761"> property.</st></span></li>
				<li><strong class="source-inline"><st c="15771">policy</st></strong><st c="15778"> – The timeline we provide to our widget has a final number of entries. </st><st c="15850">So, what happens when they are done, and the timeline reaches its end? </st><st c="15921">That’s exactly the </st><a id="_idIndexMarker236"/><st c="15940">role of the </st><strong class="source-inline"><st c="15952">policy</st></strong><st c="15958"> parameter when it describes the timeline reload behavior. </st><st c="16017">There are several options – </st><strong class="source-inline"><st c="16045">atEnd</st></strong><st c="16050"> (</st><em class="italic"><st c="16052">WidgetKit </st></em><st c="16062">requests a new timeline), </st><strong class="source-inline"><st c="16088">never</st></strong><st c="16093"> (</st><em class="italic"><st c="16095">WidgetKit </st></em><st c="16105">doesn’t ask for a new timeline), and </st><strong class="source-inline"><st c="16142">after(date:Date)</st></strong><st c="16158"> (</st><em class="italic"><st c="16160">WidgetKit </st></em><st c="16170">generates a new timeline in a specific date). </st><st c="16216">The policy helps the </st><em class="italic"><st c="16237">WidgetCenter</st></em><st c="16249"> to optimize the timeline reloading </st><span class="No-Break"><st c="16285">mechanism better.</st></span></li>
			</ul>
			<p><st c="16302">Before we continue, a few words about timeline reloading optimization. </st><st c="16374">The fact that we want to build our timeline as long as possible doesn’t mean that our widget needs to constantly reload. </st><st c="16495">The </st><em class="italic"><st c="16499">WidgetCenter</st></em><st c="16511"> has a “budget” for each widget on the home screen, specifying times during the day when it performs refreshes. </st><st c="16623">It’s in our interest to optimize the way our timeline is structured and to “save” the system budget. </st><st c="16724">Carefully planning the timeline entries and reload policy can help us achieve relevant, event-driven </st><span class="No-Break"><st c="16825">refresh intervals.</st></span></p>
			<p><st c="16843">Going back to the </st><strong class="source-inline"><st c="16862">TimelineProvider</st></strong><st c="16878"> protocol, we can see additional two functions – </st><strong class="source-inline"><st c="16927">placeholder</st></strong><st c="16938"> and </st><strong class="source-inline"><st c="16943">getSnapshot</st></strong><st c="16954">. Let’s </st><span class="No-Break"><st c="16962">implement them.</st></span></p>
			<p><st c="16977">The first function is </st><strong class="source-inline"><st c="17000">getTimeline</st></strong><st c="17011">, which returns a </st><strong class="source-inline"><st c="17029">Timeline</st></strong><st c="17037"> structure containing a list of entries with actual data for specific periods. </st><st c="17116">But is it enough for our widget to be </st><span class="No-Break"><st c="17154">fully functional?</st></span></p>
			<p><st c="17171">The answer is no – there are two more cases when providing actual data may not </st><span class="No-Break"><st c="17251">be sufficient.</st></span></p>
			<p><st c="17265">The </st><strong class="source-inline"><st c="17270">placeholder</st></strong><st c="17281"> function answers the first use case. </st><st c="17319">When the user adds a widget to their home screen, </st><em class="italic"><st c="17369">WidgetKit </st></em><st c="17379">needs to display something immediately, before the widget fetches </st><a id="_idIndexMarker237"/><st c="17445">or updates real data from our app. </st><st c="17480">The </st><strong class="source-inline"><st c="17484">placeholder</st></strong><st c="17495"> function returns temporary data just to show something to </st><span class="No-Break"><st c="17554">the user:</st></span></p>
			<pre class="source-code"><st c="17563">
    func placeholder(in context: Context) -&gt; EventEntry {
        EventEntry(date: Date(), nextEvent: "English
          class")
    }</st></pre>			<p><st c="17672">In our example, we can see a </st><strong class="source-inline"><st c="17702">placeholder</st></strong><st c="17713"> function that returns the </st><strong class="source-inline"><st c="17740">English </st></strong><span class="No-Break"><strong class="source-inline"><st c="17748">class</st></strong></span><span class="No-Break"><st c="17753"> text.</st></span></p>
			<p><st c="17759">It is important to return temporary data instead of a loading indicator, for example, and that’s because we want our user experience to be consistent and smooth. </st><st c="17922">It is also better to be creative and come up with elegant information. </st><st c="17993">For example, if our widget has a timer or a time, it is a good idea to show 00:00 to indicate to the user that a timer should </st><span class="No-Break"><st c="18119">appear here.</st></span></p>
			<p><st c="18131">The second function is </st><strong class="source-inline"><st c="18155">getSnapshot</st></strong><st c="18166">. The </st><strong class="source-inline"><st c="18172">getSnapShot</st></strong><st c="18183"> function is even more important than </st><strong class="source-inline"><st c="18221">placeholder</st></strong><st c="18232">. When the user browses the widget gallery, the system presents the different widgets. </st><st c="18319">These widgets are being presented without the </st><span class="No-Break"><st c="18365">system-generated timelines.</st></span></p>
			<p><st c="18392">The </st><strong class="source-inline"><st c="18397">getSnapshot</st></strong><st c="18408"> function returns a </st><strong class="source-inline"><st c="18428">TimelineEntry</st></strong><st c="18441">-based struct with data to present in the </st><span class="No-Break"><st c="18484">widget gallery.</st></span></p>
			<p><st c="18499">Here’s an example of a </st><span class="No-Break"><strong class="source-inline"><st c="18523">getSnapshot</st></strong></span><span class="No-Break"><st c="18534"> function:</st></span></p>
			<pre class="source-code"><st c="18544">
    func getSnapshot(in context: Context, completion:
      @escaping (EventEntry) -&gt; Void) {
        let entry = EventEntry(date: Date(), nextEvent: "Go
          to the book store")
        completion(entry)
    }</st></pre>			<p><st c="18720">In this code, the </st><strong class="source-inline"><st c="18739">getSnapshot</st></strong><st c="18750"> function returns an example event with the current date. </st><st c="18808">This snapshot demonstrates to the user the purpose of our </st><span class="No-Break"><st c="18866">widget easily.</st></span></p>
			<p><st c="18880">Note that in both </st><strong class="source-inline"><st c="18899">placeholder</st></strong><st c="18910"> and </st><strong class="source-inline"><st c="18915">getSnapshot</st></strong><st c="18926">, we have the same </st><strong class="source-inline"><st c="18945">Context</st></strong><st c="18952"> parameter </st><a id="_idIndexMarker238"/><st c="18963">as the one we had in the </st><strong class="source-inline"><st c="18988">getTimeline</st></strong><st c="18999"> function. </st><st c="19010">We need the </st><strong class="source-inline"><st c="19022">Context</st></strong><st c="19029"> for the same reason as before – to understand the environment surrounding </st><span class="No-Break"><st c="19104">our widget.</st></span></p>
			<p><st c="19115">Now that we understand how to generate a timeline provider, let’s discuss </st><span class="No-Break"><st c="19190">the </st></span><span class="No-Break"><strong class="source-inline"><st c="19194">TimelineEntry</st></strong></span><span class="No-Break"><st c="19207">.</st></span></p>
			<h3><st c="19208">Building our TimelineEntry structure</st></h3>
			<p><st c="19245">We can see by now that the </st><strong class="source-inline"><st c="19273">TimelineProvider</st></strong><st c="19289"> protocol is straightforward as there are only </st><a id="_idIndexMarker239"/><st c="19336">three functions to implement. </st><st c="19366">One of the things we need to design here is </st><strong class="source-inline"><st c="19410">TimelineEntry</st></strong><st c="19423">, and the </st><a id="_idIndexMarker240"/><st c="19433">reason for its importance is that it holds the information we need not only to determine when to present information but also what </st><span class="No-Break"><st c="19564">to present.</st></span></p>
			<p><st c="19575">The structure of </st><strong class="source-inline"><st c="19593">TimelineEntry</st></strong><st c="19606"> needs to fit our widget goal and be aligned with its UI. </st><st c="19664">Because we pre-generate all the entries according to a timeline, we should perform all the calculations in advance and generate a structure that can help update the widget </st><span class="No-Break"><st c="19836">content easily.</st></span></p>
			<p><st c="19851">In fact, </st><strong class="source-inline"><st c="19861">TimelineEntry</st></strong><st c="19874"> may consist of </st><span class="No-Break"><st c="19890">four components:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="19906">date</st></strong><st c="19911"> – The date </st><a id="_idIndexMarker241"/><st c="19923">when we want our widget to reload the specific entry information. </st><st c="19989">Notice that in most cases, the </st><strong class="source-inline"><st c="20020">date</st></strong><st c="20024"> property is not part of the information presented on the screen. </st><st c="20090">For example, in a calendar widget, we probably have a date property as part of the </st><strong class="source-inline"><st c="20173">TimelineEntry</st></strong><st c="20186"> protocol, and something like </st><strong class="source-inline"><st c="20216">eventDate</st></strong><st c="20225"> for the actual </st><span class="No-Break"><st c="20241">event time.</st></span></li>
				<li><strong class="bold"><st c="20252">Information to display</st></strong><st c="20275"> – It is better to add properties that will make rendering our widget easier later on. </st><st c="20362">For example, adding properties such as </st><strong class="source-inline"><st c="20401">title</st></strong><st c="20406">, </st><strong class="source-inline"><st c="20408">bodyText</st></strong><st c="20416">, and </st><strong class="source-inline"><st c="20422">timeString</st></strong><st c="20432">, can simplify our code and even </st><span class="No-Break"><st c="20465">increase performance.</st></span></li>
				<li><strong class="bold"><st c="20486">Metadata</st></strong><st c="20495"> – If we want to support some interaction with the widget, we need to hold some metadata related to the widget data model. </st><st c="20618">For example, a calendar widget might </st><a id="_idIndexMarker242"/><st c="20655">hold some metadata containing the event ID, a contacts widget might have metadata containing the contact ID, and so on. </st><st c="20775">Remember that once the widget is presented, </st><strong class="source-inline"><st c="20819">TimelineEntry</st></strong><st c="20832"> is all that we have when the user interacts </st><span class="No-Break"><st c="20877">with it.</st></span></li>
				<li><strong class="bold"><st c="20885">Relevance</st></strong><st c="20895"> – The </st><strong class="source-inline"><st c="20902">relevance</st></strong><st c="20911"> property is an optional property that we have as part of the </st><strong class="source-inline"><st c="20973">TimelineEntry</st></strong><st c="20986"> protocol. </st><st c="20997">In the </st><strong class="source-inline"><st c="21004">relevance</st></strong><st c="21013"> property, we can determine the relevance priority of the entry to the user. </st><st c="21090">For example, a to-do app that shows the next task to the user may want to set a high score to an entry with a critical task. </st><st c="21215">Or, a sports app that shows the latest news in a widget may want to set a high score for entries that contain news about the user’s favorite team. </st><st c="21362">The entries’ relevance values help </st><em class="italic"><st c="21397">WidgetKit </st></em><st c="21407">to decide how and when to present widgets in the system. </st><st c="21464">For example, </st><em class="italic"><st c="21477">WidgetKit </st></em><st c="21487">may decide to rotate the stack widget and show a widget with high-relevance information. </st><st c="21576">Let’s see an example how to set </st><strong class="source-inline"><st c="21608">relevance</st></strong><st c="21617"> for </st><span class="No-Break"><st c="21622">a </st></span><span class="No-Break"><strong class="source-inline"><st c="21624">TimeLineEntry</st></strong></span><span class="No-Break"><st c="21637">:</st></span><pre class="source-code"><st c="21639">
struct EventEntry: TimelineEntry {
    let date: Date
    let nextEvent: String
    var relevance: TimelineEntryRelevance?
</st><st c="21751">}
let entry = EventEntry(date: date, nextEvent: "Go to
  the book store", </st><strong class="bold"><st c="21823">relevance:</st></strong>
<strong class="bold"><st c="21833">    TimelineEntryRelevance(score: 1.0))</st></strong></pre><p class="list-inset"><st c="21869">In this code, we added the </st><strong class="source-inline"><st c="21897">relevance</st></strong><st c="21906"> property to our </st><strong class="source-inline"><st c="21923">EventEntry</st></strong><st c="21933"> struct and set a score of </st><strong class="source-inline"><st c="21960">1.0</st></strong><st c="21963">. It is worth noting that any efforts to manipulate the system and </st><a id="_idIndexMarker243"/><st c="22030">set high scores for all entries won’t succeed – Apple has built an algorithm that filters out widgets that have unrealistic </st><a id="_idIndexMarker244"/><st c="22154">values. </st><st c="22162">As with many iOS frameworks, this is a situation where we need to follow the platform’s intended </st><span class="No-Break"><st c="22259">usage guidelines.</st></span></p></li>			</ul>
			<p><st c="22276">Now that we have created a timeline, let’s turn to the main topic, which is building our </st><span class="No-Break"><st c="22366">widget UI.</st></span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor197"/><st c="22376">Building our widget UI</st></h1>
			<p><st c="22399">Creating a timeline of entries is critical for our widget to provide accurate and relevant information </st><a id="_idIndexMarker245"/><st c="22503">to the user. </st><st c="22516">But to do that, we also need to render the widget UI. </st><st c="22570">The place where we do that is in the widget’s structure, as we saw at the beginning of this chapter in the </st><em class="italic"><st c="22677">Configuring our </st></em><span class="No-Break"><em class="italic"><st c="22693">widget</st></em></span><span class="No-Break"><st c="22699"> section.</st></span></p>
			<p><st c="22708">Let’s see the </st><span class="No-Break"><st c="22723">configuration again:</st></span></p>
			<pre class="source-code"><st c="22743">
StaticConfiguration(kind: kind, provider: Provider()) {
    entry in
            </st><strong class="bold"><st c="22809">MyWidgetEntryView(entry: entry)</st></strong>
<strong class="bold"><st c="22840">                .containerBackground(.fill.tertiary, for:</st></strong>
<strong class="bold"><st c="22881">                  .widget)</st></strong><st c="22889">
        }</st></pre>			<p><st c="22891">As we can see, the </st><strong class="source-inline"><st c="22910">StaticConfiguration</st></strong><st c="22929"> has a view builder that returns a SwiftUI view, and this is probably the first thing we need to understand in </st><em class="italic"><st c="23040">WidgetKit </st></em><st c="23050">– widgets are built with SwiftUI only. </st><st c="23089">If you still haven’t got any experience with SwiftUI, </st><em class="italic"><st c="23143">WidgetKit </st></em><st c="23153">is a great opportunity </st><span class="No-Break"><st c="23176">to start.</st></span></p>
			<p><st c="23185">Something that might have caught your attention is the </st><strong class="source-inline"><st c="23241">containerBackground</st></strong><st c="23260"> view modifier. </st><st c="23276">If you remember, we have discussed how widgets now can be shown in different places in the Apple ecosystem – </st><em class="italic"><st c="23385">iOS</st></em><st c="23388"> (both home screen and lock screen), </st><em class="italic"><st c="23425">padOS</st></em><st c="23430">, </st><em class="italic"><st c="23432">macOS</st></em><st c="23437">, and </st><em class="italic"><st c="23443">watchOS</st></em><st c="23450">. But the primary issue with having our widgets on different platforms might be the </st><span class="No-Break"><st c="23534">widget’s background.</st></span></p>
			<p><st c="23554">Adding the </st><strong class="source-inline"><st c="23566">containerBackground</st></strong><st c="23585"> view modifier ensures that the widget’s background adjusts itself to its container and always looks good, no matter where </st><span class="No-Break"><st c="23708">it appears.</st></span></p>
			<p><st c="23719">If we look at </st><a id="_idIndexMarker246"/><st c="23734">our code example again, we can see that </st><strong class="source-inline"><st c="23774">MyWidgetEntryView</st></strong><st c="23791"> receives one parameter, which is the current timeline entry. </st><st c="23853">Let’s see what we can learn </st><span class="No-Break"><st c="23881">from it.</st></span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor198"/><st c="23889">Working with timeline entries</st></h2>
			<p><st c="23919">Connecting the timeline entry to the widget view is the core of how widgets work. </st><st c="24002">The main role of </st><em class="italic"><st c="24019">WidgetCenter</st></em><st c="24031"> is to generate a timeline and provide our widget with the right timeline entry at the </st><span class="No-Break"><st c="24118">right time.</st></span></p>
			<p><st c="24129">The widget </st><a id="_idIndexMarker247"/><st c="24141">configuration view builder has one parameter, a specific timeline entry, so we can return a widget view with </st><span class="No-Break"><st c="24250">relevant data.</st></span></p>
			<p><st c="24264">Here’s an example of a widget view that uses a specific </st><span class="No-Break"><st c="24321">timeline entry:</st></span></p>
			<pre class="source-code"><st c="24336">
struct MyWidgetEntryView: View {
</st><strong class="bold"><st c="24370">    let entry: </st></strong><st c="24381">EventEntry
    var body: some View {
        VStack(alignment: .leading) {
            Text("Next Event:")
                .font(.headline)
            Text(</st><strong class="bold"><st c="24486">entry.nextEventTitle</st></strong><st c="24507">)
                .font(.title)
                .foregroundColor(.blue)
            Text("Time: \(</st><strong class="bold"><st c="24562">entry.nextEventTime</st></strong><st c="24582">)")
                .font(.subheadline)
            Spacer()
        }
        .padding()
    }
}</st></pre>			<p><st c="24632">This code </st><a id="_idIndexMarker248"/><st c="24643">example shows a simple view that shows the next event title and time while using the </st><span class="No-Break"><st c="24728">timeline entry.</st></span></p>
			<p><st c="24743">There are two things we can learn from the way the timeline entry works with the </st><span class="No-Break"><st c="24825">widget view:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="24837">The entry should contain all the widget’s data</st></strong><st c="24884"> – We discussed it when we talked about the timeline provider, but now we can see why. </st><st c="24971">Widgets need to be as static and simple as possible. </st><st c="25024">We don’t want to perform any data fetching operations while the view </st><span class="No-Break"><st c="25093">is displayed.</st></span></li>
				<li><strong class="bold"><st c="25106">There is no state</st></strong><st c="25124"> – Unlike regular SwiftUI views, our widget view doesn’t have a state. </st><st c="25195">There are cases where we probably would want to see different views for different situations. </st><st c="25289">For example, in our </st><em class="italic"><st c="25309">next event</st></em><st c="25319"> widget example, maybe we want to show a </st><em class="italic"><st c="25360">connect to your calendar</st></em><st c="25384"> message if the user hasn’t approved his calendar permissions. </st><st c="25447">To do that, we need to generate different timeline entries and perhaps show a different view in the static configuration closure. </st><st c="25577">Either way, we should do these checks </st><span class="No-Break"><st c="25615">in advance.</st></span></li>
			</ul>
			<p><st c="25626">Even though the widgets are naturally static, their UI doesn’t have to stay static and bold. </st><st c="25720">In </st><strong class="source-inline"><st c="25723">WidgetKit</st></strong><st c="25732">, it is possible to bring life to our widget by animating </st><span class="No-Break"><st c="25790">the changes.</st></span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor199"/><st c="25802">Adding animations</st></h2>
			<p><st c="25820">We already </st><a id="_idIndexMarker249"/><st c="25832">know how animations in iOS development work – view animations work by transitioning between two or more states. </st><st c="25944">For example, if a specific view has an opacity of </st><strong class="source-inline"><st c="25994">1.0</st></strong><st c="25997"> and we change it to </st><strong class="source-inline"><st c="26018">0.5</st></strong><st c="26021">, UIKit and SwiftUI can animate that change if </st><span class="No-Break"><st c="26068">we like.</st></span></p>
			<p><st c="26076">Widgets are written in SwiftUI, and in SwiftUI, we can animate state changes. </st><st c="26155">However, widgets don’t use state at all. </st><st c="26196">Instead, we change the widget content using the timeline provider (perhaps we can say that, in a way, the timeline entry is our </st><span class="No-Break"><st c="26324">widget state).</st></span></p>
			<p><st c="26338">Starting with iOS 16, whenever the </st><em class="italic"><st c="26374">WidgetCenter</st></em><st c="26386"> reloads a widget and changes its content using a new entry, it performs this </st><span class="No-Break"><st c="26464">transition automatically.</st></span></p>
			<p><st c="26489">Can we </st><a id="_idIndexMarker250"/><st c="26497">customize this animation even if we don’t have a state in widgets? </st><st c="26564">Of course we can, </st><span class="No-Break"><st c="26582">using </st></span><span class="No-Break"><strong class="source-inline"><st c="26588">contentTransition</st></strong></span><span class="No-Break"><st c="26605">.</st></span></p>
			<p><st c="26606">As mentioned, in most cases, SwiftUI performs animations based on a state change. </st><st c="26689">For example, look at the </st><span class="No-Break"><st c="26714">following code:</st></span></p>
			<pre class="source-code"><st c="26729">
    @State private var isRed = false
    var body: some View {
        VStack {
            Color(isRed ? .</st><st c="26809">red : .blue)
                .frame(width: 100, height: 100)
                .cornerRadius(10)
            Button("Change Color") {
                </st><strong class="bold"><st c="26898">withAnimation {</st></strong>
<strong class="bold"><st c="26913">                    self.isRed.toggle()</st></strong>
<strong class="bold"><st c="26933">                }</st></strong><st c="26935">
            }
        }
    }</st></pre>			<p><st c="26941">In this code example, we have a view and a button. </st><st c="26993">Tapping on the button changes the view color, and it does that using the </st><strong class="source-inline"><st c="27066">withAnimation</st></strong><st c="27079"> function. </st><st c="27090">Clearly, that can’t work in a widget because we need a state to </st><span class="No-Break"><st c="27154">do that.</st></span></p>
			<p><st c="27162">Instead, what we </st><a id="_idIndexMarker251"/><st c="27180">need to do is define how the content changes when it’s animated. </st><st c="27245">To do that, we can </st><span class="No-Break"><st c="27264">use </st></span><span class="No-Break"><strong class="source-inline"><st c="27268">contentTransition</st></strong></span><span class="No-Break"><st c="27285">:</st></span></p>
			<pre class="source-code"><st c="27287">
            Color(isRed ? .</st><st c="27303">red : .blue)
                .frame(width: 100, height: 100)
                .cornerRadius(10)
</st><strong class="bold"><st c="27367">                .contentTransition(.opacity)</st></strong><st c="27395">
            Button("Change Color") {
                withAnimation() {
                    self.isRed.toggle()
                }
            }</st></pre>			<p><strong class="source-inline"><st c="27462">contentTransition</st></strong><st c="27480"> is a view modifier we can add to views to define their transition method. </st><st c="27555">Imagine that all content changes in widgets are done with </st><strong class="source-inline"><st c="27613">withAnimation</st></strong><st c="27626"> in mind and all we have to do is to change the </st><span class="No-Break"><st c="27674">transition method.</st></span></p>
			<p><st c="27692">Take, for example, the following </st><span class="No-Break"><st c="27726">code snippet:</st></span></p>
			<pre class="source-code"><st c="27739">
Text(text)</st><strong class="bold"><st c="27750">.contentTransition(.numericText())</st></strong></pre>			<p><st c="27784">When changing the text using the </st><strong class="source-inline"><st c="27818">withAnimation()</st></strong><st c="27833"> function, it will change its content with a nice numeric transition (you can try it yourself). </st><st c="27929">If you are not familiar with the </st><strong class="source-inline"><st c="27962">withAnimation</st></strong><st c="27975"> function, </st><a href="B21795_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic"><st c="27986">Chapter 6</st></em></span></a><st c="27995"> provides a brief discussion </st><span class="No-Break"><st c="28024">on it.</st></span></p>
			<p><st c="28030">In widgets, all we need to do is to add these to views with content that is based on our timeline entry, and SwiftUI will take care of the </st><span class="No-Break"><st c="28170">animation itself.</st></span></p>
			<p><st c="28187">Look at our widget again, now </st><span class="No-Break"><st c="28218">with </st></span><span class="No-Break"><strong class="source-inline"><st c="28223">contentTransition</st></strong></span><span class="No-Break"><st c="28240">:</st></span></p>
			<pre class="source-code"><st c="28242">
struct MyWidgetEntryView : View {
    var entry: Provider.Entry
    var body: some View {
        VStack {
            Text("Time:")
            Text(entry.nextEventTime, style: .time)
            Text("Next Event")
            Text(entry.nextEvent)
</st><strong class="bold"><st c="28429">                .contentTransition(.numericText())</st></strong><st c="28463">
        }
    }
}</st></pre>			<p><st c="28469">Even though </st><a id="_idIndexMarker252"/><st c="28482">there is no state or </st><strong class="source-inline"><st c="28503">withAnimation</st></strong><st c="28516"> function, the </st><strong class="source-inline"><st c="28531">nextEvent</st></strong><st c="28540"> title will animate its transition. </st><st c="28576">The </st><strong class="source-inline"><st c="28580">contentTransiton</st></strong><st c="28596"> view modifier has additional options, such as opacity and symbol effects. </st><st c="28671">Despite the fact that it is not designed explicitly for widgets, it’s the best way to make our widgets </st><span class="No-Break"><st c="28774">more alive.</st></span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor200"/><st c="28785">Customize our widget</st></h2>
			<p><st c="28806">Up until now, we have discussed widgets based on a </st><strong class="source-inline"><st c="28858">staticConfiguration</st></strong><st c="28877">. The </st><strong class="source-inline"><st c="28883">staticConfiguration</st></strong><st c="28902"> set is great for most widgets. </st><st c="28934">However, there are cases where we </st><a id="_idIndexMarker253"/><st c="28968">want to provide our users the ability to customize </st><a id="_idIndexMarker254"/><st c="29019">and configure t</st><a id="_idTextAnchor201"/><a id="_idTextAnchor202"/><st c="29034">heir widgets with </st><span class="No-Break"><st c="29053">additional entities.</st></span></p>
			<p><st c="29073">Going back to our calendar widget, we want to allow the user to filter the next event information based on a </st><span class="No-Break"><st c="29183">specific calendar.</st></span></p>
			<p><st c="29201">To do that, we’ll start by creating a new file and add a struct called </st><strong class="source-inline"><st c="29273">CalendarWidgetIntent</st></strong><st c="29293"> that conforms </st><span class="No-Break"><st c="29308">to </st></span><span class="No-Break"><strong class="source-inline"><st c="29311">WidgetConfigurationIntent</st></strong></span><span class="No-Break"><st c="29336">.</st></span></p>
			<h3><st c="29337">Adding intent</st></h3>
			<p><st c="29351">A </st><strong class="source-inline"><st c="29354">WidgetConfigurationIntent</st></strong><st c="29379"> is an App Intent we can use to configure widgets, and our </st><strong class="source-inline"><st c="29438">CalendarWidgetIntent</st></strong><st c="29458"> contains all the configuration information </st><span class="No-Break"><st c="29502">we need.</st></span></p>
			<p><st c="29510">Here is </st><a id="_idIndexMarker255"/><st c="29519">a basic </st><span class="No-Break"><strong class="source-inline"><st c="29527">CalendarWidgetIntent</st></strong></span><span class="No-Break"><st c="29547"> implementation:</st></span></p>
			<pre class="source-code"><st c="29563">
struct CalendarWidgetIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "Select
      Calendar"
    @Parameter(title: "Calendar") var calendar:
      CalendarEntity
}</st></pre>			<p><st c="29743">In the preceding code, we can see </st><span class="No-Break"><st c="29778">two properties:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="29793">title</st></strong><st c="29799"> – The title of the intent. </st><st c="29827">It is important to note that we don’t see the title in the widget configuration string but rather in Siri Shortcuts. </st><st c="29944">But we must add it since it is part of the </st><strong class="source-inline"><st c="29987">AppIntent</st></strong><st c="29996"> protocol (the </st><strong class="source-inline"><st c="30011">WidgetConfigurationIntent</st></strong><st c="30036"> inheritance from </st><span class="No-Break"><strong class="source-inline"><st c="30054">AppIntent</st></strong></span><span class="No-Break"><st c="30063"> protocol).</st></span></li>
				<li><strong class="source-inline"><st c="30074">calendar</st></strong><st c="30083">– This is the widget parameter that allows the user to configure the calendar the event belongs to. </st><st c="30184">We can see that the </st><strong class="source-inline"><st c="30204">calendar</st></strong><st c="30212"> variable is prefixed by the </st><strong class="source-inline"><st c="30241">@Parameter</st></strong><st c="30251"> macro, which manages this property for the </st><span class="No-Break"><st c="30295">user’s configuration.</st></span></li>
			</ul>
			<p><st c="30316">Now, let’s add the </st><span class="No-Break"><st c="30336">App Intent.</st></span></p>
			<h3><st c="30347">Adding AppEntity</st></h3>
			<p><st c="30364">As you </st><a id="_idIndexMarker256"/><st c="30372">have noticed, the calendar variable is based on a type </st><span class="No-Break"><st c="30427">called </st></span><span class="No-Break"><strong class="source-inline"><st c="30434">CalendarEntity</st></strong></span><span class="No-Break"><st c="30448">.</st></span></p>
			<p><st c="30449">If we want to support our own entity type, it needs to conform to </st><strong class="source-inline"><st c="30516">AppEntity</st></strong><st c="30525">. Let’s see the </st><strong class="source-inline"><st c="30541">CalendarEntity</st></strong> <span class="No-Break"><st c="30555">type implementation:</st></span></p>
			<pre class="source-code"><st c="30576">
struct CalendarEntity: AppEntity {
    let id: String
    let name: String
    static var typeDisplayRepresentation:
      TypeDisplayRepresentation = "Calendar"
    static var defaultQuery = CalendarQuery()
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(title: name)
    }
}</st></pre>			<p><st c="30852">The </st><strong class="source-inline"><st c="30857">CalendarEntity</st></strong><st c="30871"> struct represents the data model for the </st><strong class="source-inline"><st c="30913">intent</st></strong><st c="30919"> parameter. </st><st c="30931">First, we need to add the parameters we need in order to support the item when displaying </st><a id="_idIndexMarker257"/><st c="31021">the widget, such as </st><strong class="source-inline"><st c="31041">id</st></strong><st c="31043"> and </st><strong class="source-inline"><st c="31048">name</st></strong><st c="31052">. Next, we’ll add some representation variables, such as </st><strong class="source-inline"><st c="31109">typeDisplayRepresentation</st></strong> <span class="No-Break"><st c="31134">and </st></span><span class="No-Break"><strong class="source-inline"><st c="31139">displayRepresentation</st></strong></span><span class="No-Break"><st c="31160">.</st></span></p>
			<p><st c="31161">Finally, we’ll add a static variable that handles the actual data fetching, and that’s the </st><strong class="source-inline"><st c="31253">defaultQuery</st></strong><st c="31265"> property. </st><st c="31276">Remember that the user needs to select the desired calendar based on a list of calendars. </st><st c="31366">To do that, we need to provide </st><em class="italic"><st c="31397">WidgetKit </st></em><st c="31407">with a way to query our data to support the selection </st><span class="No-Break"><st c="31461">UI flow.</st></span></p>
			<p><st c="31469">So, what does the query look like? </st><st c="31505">Let’s </st><span class="No-Break"><st c="31511">find out.</st></span></p>
			<h3><st c="31520">Building the EntityQuery</st></h3>
			<p><st c="31545">Sometimes, having a </st><a id="_idIndexMarker258"/><st c="31566">list of options for the user relies on a data store, and sometimes on </st><span class="No-Break"><st c="31636">static information.</st></span></p>
			<p><st c="31655">Regardless of the model type, if we want to provide options to the user, we need to have a simple and effective interface to work with, and that’s what the </st><strong class="source-inline"><st c="31812">EntityQuery</st></strong><st c="31823"> protocol </st><span class="No-Break"><st c="31833">is for.</st></span></p>
			<p><st c="31840">In our current </st><strong class="source-inline"><st c="31856">AppIntent</st></strong><st c="31865"> example, we let the user choose one of its calendars, so we need to build a struct named </st><strong class="source-inline"><st c="31955">CalendarQuery</st></strong><st c="31968"> that conforms </st><span class="No-Break"><st c="31983">to </st></span><span class="No-Break"><strong class="source-inline"><st c="31986">EntityQuery</st></strong></span><span class="No-Break"><st c="31997">.</st></span></p>
			<p><st c="31998">Let’s look </st><a id="_idIndexMarker259"/><st c="32010">at a simple </st><span class="No-Break"><strong class="source-inline"><st c="32022">CalendarQuery</st></strong></span><span class="No-Break"><st c="32035"> example:</st></span></p>
			<pre class="source-code"><st c="32044">
struct CalendarQuery: EntityQuery {
    func entities(for identifiers: [CalendarEntity.ID])
      async throws -&gt; [CalendarEntity] {
        allCalendars.filter { identifiers.contains($0.id) }
    }
    func suggestedEntities() async throws -&gt;
      [CalendarEntity] {
        allCalendars
    }
    func defaultResult() async -&gt; CalendarEntity? </st><st c="32343">{
        nil
    }
}</st></pre>			<p><st c="32352">Assume that </st><strong class="source-inline"><st c="32365">allCalendars</st></strong><st c="32377"> is an array containing all the </st><span class="No-Break"><st c="32409">user calendars.</st></span></p>
			<p><st c="32424">In this case, </st><strong class="source-inline"><st c="32439">CalendarQuery</st></strong><st c="32452"> implements three methods. </st><st c="32479">Let’s quickly go </st><span class="No-Break"><st c="32496">over them:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="32506">entities(for identifiers:)</st></strong><st c="32533"> – This function returns calendar entities based on a list of IDs. </st><em class="italic"><st c="32600">WidgetKit </st></em><st c="32610">uses it to show the </st><span class="No-Break"><st c="32630">selected calendar</st></span></li>
				<li><strong class="source-inline"><st c="32647">suggestedEntities()</st></strong><st c="32667"> – This returns the list of entities in the </st><span class="No-Break"><st c="32711">pop-up menu</st></span></li>
				<li><strong class="source-inline"><st c="32722">defaultResult()</st></strong><st c="32738"> – This returns the value when nothing </st><span class="No-Break"><st c="32777">is selected</st></span></li>
			</ul>
			<p><st c="32788">Now, let’s </st><a id="_idIndexMarker260"/><st c="32800">see how it looks (</st><span class="No-Break"><em class="italic"><st c="32818">Figure 5</st></em></span><span class="No-Break"><em class="italic"><st c="32827">.3</st></em></span><span class="No-Break"><st c="32829">):</st></span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21795_05_3.jpg" alt="Figure 5.3: The widget configuration menu"/><st c="32832"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32885">Figure 5.3: The widget configuration menu</st></p>
			<p><st c="32926">In </st><span class="No-Break"><em class="italic"><st c="32930">Figure 5</st></em></span><em class="italic"><st c="32938">.3</st></em><st c="32940">, we can see the </st><strong class="bold"><st c="32957">Widget</st></strong><st c="32963"> configuration screen with the parameter we declared (</st><strong class="bold"><st c="33017">Calendar</st></strong><st c="33026">) and the calendar names in the pop-up menu. </st><st c="33072">It is worth mentioning that we can define different types of parameters, such as </st><strong class="source-inline"><st c="33153">Bool</st></strong><st c="33157"> or </st><strong class="source-inline"><st c="33161">String</st></strong><st c="33167">, and </st><em class="italic"><st c="33173">WidgetKit </st></em><st c="33183">will create their corresponding </st><span class="No-Break"><st c="33215">input control.</st></span></p>
			<p><st c="33229">Let’s flip to the other side now and go to the widget UI to use the </st><strong class="source-inline"><st c="33298">AppEntity</st></strong><st c="33307"> the </st><span class="No-Break"><st c="33312">user selected.</st></span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor203"/><st c="33326">Using the AppEntity in our Widget</st></h2>
			<p><st c="33360">Going back </st><a id="_idIndexMarker261"/><st c="33372">to our widget code, let’s examine the widget configuration </st><span class="No-Break"><st c="33431">code again:</st></span></p>
			<pre class="source-code"><st c="33442">
AppIntentConfiguration(kind: kind, </st><strong class="bold"><st c="33478">intent:</st></strong>
<strong class="bold"><st c="33485">    CalendarWidgetIntent.self,</st></strong><st c="33512"> provider:
    ConfigurableProvider(), content: { entry in
            ConfigurableWidgetView(entry: entry)
        })</st></pre>			<p><st c="33606">The </st><strong class="source-inline"><st c="33611">AppIntentConfiguration</st></strong><st c="33633"> struct has an important property, which is the intent type it uses, and in this case, it is </st><strong class="source-inline"><st c="33726">CalendarWidgetIntent</st></strong><st c="33746">. If we go back to the </st><em class="italic"><st c="33769">Customize our widget</st></em><st c="33789"> section, we can see that </st><strong class="source-inline"><st c="33815">CalendarWidgetIntent</st></strong><st c="33835"> contains all the information we need to present our widget according to the </st><span class="No-Break"><st c="33912">user configuration.</st></span></p>
			<p><st c="33931">Indeed, the timeline provider is now conforming to a different protocol, </st><strong class="source-inline"><st c="34005">AppIntentTimelineProvider</st></strong><st c="34030">, which supports the intent configuration now. </st><st c="34077">Let’s see how it creates </st><span class="No-Break"><st c="34102">a timeline:</st></span></p>
			<pre class="source-code"><st c="34113">
struct ConfigurableProvider: AppIntentTimelineProvider {
    func timeline(for configuration: CalendarWidgetIntent,
      in context: Context) async -&gt;
        Timeline&lt;ConfiguredNextEventEntry&gt;</st></pre>			<p><st c="34290">We can see that the timeline function inside </st><strong class="source-inline"><st c="34336">ConfigurableProvider</st></strong><st c="34356"> now receives the configuration parameter. </st><st c="34399">From this point, all we need to do is use the information we have inside the configuration and create the relevant </st><span class="No-Break"><st c="34514">timeline entries.</st></span></p>
			<p><st c="34531">By now, we know how to set up a new widget, animate it, create its timeline, and even let the user configure it. </st><st c="34645">Next, we’ll learn how to ensure our widgets stay up </st><span class="No-Break"><st c="34697">to date.</st></span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor204"/><st c="34705">Keeping our widgets up to date</st></h1>
			<p><st c="34736">We have learned that we need to look ahead and create a timeline with different entries and dates to </st><a id="_idIndexMarker262"/><st c="34838">keep our widget up to date. </st><st c="34866">But how does our widget work under </st><span class="No-Break"><st c="34901">the hood?</st></span></p>
			<p><st c="34910">Widgets don’t get any running time – once we generate the timeline entries, </st><em class="italic"><st c="34987">WidgetCenter</st></em><st c="34999"> generates their different views, keeps them persistently, and just switches them according to the </st><span class="No-Break"><st c="35098">provided timeline.</st></span></p>
			<p><st c="35116">So, there’s no way to update our widget without reloading the timeline, and when we created our timeline, we had to define its </st><span class="No-Break"><st c="35244">reload policy:</st></span></p>
			<pre class="source-code"><st c="35258">
let timeline = Timeline(entries: entries, </st><strong class="bold"><st c="35301">policy: .atEnd</st></strong><st c="35315">)</st></pre>			<p><st c="35317">However, sometimes, we want to instruct </st><strong class="source-inline"><st c="35357">WidgetCenter</st></strong><st c="35369"> to reload the timeline immediately, due to data changes or any </st><span class="No-Break"><st c="35433">other alterations.</st></span></p>
			<p><st c="35451">Let’s see how </st><span class="No-Break"><st c="35466">it happens.</st></span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor205"/><st c="35477">Reload widgets using the WidgetCenter</st></h2>
			<p><st c="35515">Throughout </st><a id="_idIndexMarker263"/><st c="35527">the chapter, I have mentioned </st><em class="italic"><st c="35557">WidgetCenter</st></em><st c="35569"> frequently but I haven’t explained what </st><span class="No-Break"><st c="35610">it means.</st></span></p>
			<p><em class="italic"><st c="35619">WidgetCenter</st></em><st c="35632"> is an object that holds information about the different configured widgets currently used, and it also provides an option to </st><span class="No-Break"><st c="35758">reload them.</st></span></p>
			<p><st c="35770">To use </st><strong class="source-inline"><st c="35778">WidgetCenter</st></strong><st c="35790">, we need to call the </st><strong class="source-inline"><st c="35812">shared</st></strong><st c="35818"> property to access its </st><span class="No-Break"><st c="35842">singleton reference:</st></span></p>
			<pre class="source-code"><st c="35862">
WidgetCenter.shared</st></pre>			<p><st c="35882">The difference between </st><em class="italic"><st c="35906">WidgetCenter</st></em><st c="35918"> and the rest of the code we have handled up until now is the fact that we call </st><em class="italic"><st c="35998">WidgetCenter</st></em><st c="36010"> from the app and not the </st><span class="No-Break"><st c="36036">widget extension.</st></span></p>
			<p><st c="36053">Let’s see how we can call the </st><strong class="source-inline"><st c="36084">WidgetCenter</st></strong><st c="36096"> to get a list of </st><span class="No-Break"><st c="36114">active widgets:</st></span></p>
			<pre class="source-code"><st c="36129">
func getConfigurations() {
    </st><strong class="bold"><st c="36157">WidgetCenter.shared.getCurrentConfigurations</st></strong><st c="36201"> { result
      in
        if let widgets = try? </st><st c="36236">result.get() {
            // handle our widgets
        }
    }
}</st></pre>			<p><st c="36278">The </st><strong class="source-inline"><st c="36283">getCurrentConfigurations</st></strong><st c="36307"> function uses a closure to return an array of active widgets. </st><st c="36370">Each one of them is the </st><strong class="source-inline"><st c="36394">WidgetInfo</st></strong><st c="36404"> type – a structure that contains information </st><a id="_idIndexMarker264"/><st c="36450">about a specific </st><span class="No-Break"><st c="36467">configured widget.</st></span></p>
			<p><st c="36485">The </st><strong class="source-inline"><st c="36490">WidgetInfo</st></strong><st c="36500"> structure has three properties – kind, family, </st><span class="No-Break"><st c="36548">and configuration:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="36566">kind</st></strong><st c="36571"> – This is the string we set when we created the widget configuration (look again at the </st><em class="italic"><st c="36660">Configuring our </st></em><span class="No-Break"><em class="italic"><st c="36676">widget</st></em></span><span class="No-Break"><st c="36682"> section).</st></span></li>
				<li><strong class="source-inline"><st c="36692">family</st></strong><st c="36699"> – The family size of the widget – small, medium, </st><span class="No-Break"><st c="36749">or large.</st></span></li>
				<li><strong class="source-inline"><st c="36758">configuration</st></strong><st c="36772"> – The intent that contains user configuration information. </st><st c="36832">The </st><strong class="source-inline"><st c="36836">configuration</st></strong><st c="36849"> property </st><span class="No-Break"><st c="36859">is optional.</st></span></li>
			</ul>
			<p><st c="36871">If needed, we can use that information to reload the timeline of a specific kind of widget. </st><st c="36964">For example, if we want to reload widgets with the kind of </st><strong class="source-inline"><st c="37023">MyWidget</st></strong><st c="37031">, we need to call </st><span class="No-Break"><st c="37049">the following:</st></span></p>
			<pre class="source-code"><st c="37063">
WidgetCenter.shared.reloadTimelines(ofKind: "MyWidget")</st></pre>			<p><st c="37119">Notice that the function says </st><strong class="source-inline"><st c="37150">Timelines</st></strong><st c="37159"> and not </st><strong class="source-inline"><st c="37168">Timeline</st></strong><st c="37176">, as it is possible to have several widgets of the </st><span class="No-Break"><st c="37227">same kind.</st></span></p>
			<p><st c="37237">If we want to reload all our app widgets, we can call the </st><span class="No-Break"><strong class="source-inline"><st c="37296">reloadAllTimelines()</st></strong></span><span class="No-Break"><st c="37316"> function:</st></span></p>
			<p><span class="No-Break"><strong class="source-inline"><st c="37326">WidgetCenter.shared.reloadAllTimelines()</st></strong></span></p>
			<p><st c="37367">There are several great use cases for reloading our widget timeline, such as when we get a push notification, or when the user data or settings have changed. </st><st c="37526">If you remember, when we discussed the widget timeline in the </st><em class="italic"><st c="37588">Generating a timeline</st></em><st c="37609"> section, we talked about the fact that widgets have a certain budget for the amount of reloading they can do each day. </st><st c="37729">But the good news is that calling the </st><strong class="source-inline"><st c="37767">reloadTimelines</st></strong><st c="37782"> or </st><strong class="source-inline"><st c="37786">reloadAllTimelines</st></strong><st c="37804"> functions doesn’t count in this budget if our app is in the foreground or uses some other technique, such as playing audio in </st><span class="No-Break"><st c="37931">the background.</st></span></p>
			<p><st c="37946">In most </st><a id="_idIndexMarker265"/><st c="37955">cases, </st><strong class="source-inline"><st c="37962">reloadTimelines</st></strong><st c="37977"> works well when the updated data is already on the device or in our app. </st><st c="38051">But what should we do when the local persistent store is </st><span class="No-Break"><st c="38108">not updated?</st></span></p>
			<p><st c="38120">We perform a network request, </st><span class="No-Break"><st c="38151">of course!</st></span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor206"/><st c="38161">Go to the network for updates</st></h2>
			<p><st c="38191">Performing a network request to update local data is a typical operation in mobile apps. </st><st c="38281">But how </st><a id="_idIndexMarker266"/><st c="38289">does it work </st><span class="No-Break"><st c="38302">in widgets?</st></span></p>
			<p><st c="38313">Let’s look at the </st><strong class="source-inline"><st c="38332">getTimeline</st></strong> <span class="No-Break"><st c="38343">function again:</st></span></p>
			<pre class="source-code"><st c="38359">
func getTimeline(in context: Context, </st><strong class="bold"><st c="38398">completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()</st></strong><st c="38443">)</st></pre>			<p><st c="38445">We can see that the </st><strong class="source-inline"><st c="38465">getTimeline</st></strong><st c="38476"> function is an asynchronous function. </st><st c="38515">It means that when we build our timeline, we can perform async operations such as open URL sessions and </st><span class="No-Break"><st c="38619">fetching data.</st></span></p>
			<p><st c="38633">Let’s see an example of requesting the next </st><span class="No-Break"><st c="38678">calendar events:</st></span></p>
			<pre class="source-code"><st c="38694">
func getTimeline(in context: Context, completion: @escaping
    (Timeline&lt;SimpleEntry&gt;) -&gt; Void) {
        var entries: [SimpleEntry] = []
        </st><strong class="bold"><st c="38822">calendarService.fetchNextEvents { result in</st></strong><st c="38865">
            switch result {
            case .success(let events):
                for event in events {
                    let entry = SimpleEntry(date:
                      event.alertTime, nextEvent:
                        event.title, nextEventTime:
                          event.date)
                    entries.append(entry)
                }
            case .failure(let error):
                print("Error fetching next events:
                  \(error.localizedDescription)")
            }
        let timeline = Timeline(entries: entries, policy:
          .atEnd)
        completion(timeline)
}
    }</st></pre>			<p><st c="39230">The </st><strong class="source-inline"><st c="39235">getTimeline</st></strong><st c="39246"> function implementation is similar to the previous </st><strong class="source-inline"><st c="39298">getTimeline</st></strong><st c="39309"> implementation we saw in the </st><em class="italic"><st c="39339">Generating a timeline</st></em><st c="39360"> section, and this time, we are fetching the </st><a id="_idIndexMarker267"/><st c="39405">events using the </st><strong class="source-inline"><st c="39422">calendarService</st></strong><st c="39437"> instance. </st><st c="39448">The </st><strong class="source-inline"><st c="39452">calendarService</st></strong><st c="39467"> goes to our server and returns an array of events. </st><st c="39519">Afterward, we loop the events, generate timeline entries, and return a timeline using the </st><span class="No-Break"><strong class="source-inline"><st c="39609">completion</st></strong></span><span class="No-Break"><st c="39619"> block.</st></span></p>
			<p><st c="39626">Up until now, we have seen how to create a widget, animate it, and ensure it is updated as much as we can. </st><st c="39734">But if we want to make our widget shine, we need to add some </st><span class="No-Break"><st c="39795">user-interactive capabilities.</st></span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor207"/><st c="39825">Interacting with our widget</st></h1>
			<p><st c="39853">Besides </st><a id="_idIndexMarker268"/><st c="39862">providing us with a glance at our app information, widgets are a great way to open our app in a specific location or manipulate data without even opening </st><span class="No-Break"><st c="40016">the app.</st></span></p>
			<p><st c="40024">As mobile developers, we sometimes wonder why implementing user interaction with a widget is such a big deal. </st><st c="40135">After all, our users interact with our app daily, so why is it such a problem? </st><st c="40214">But when we remember that widgets don’t really run, we can understand </st><span class="No-Break"><st c="40284">the challenge.</st></span></p>
			<p><st c="40298">The most basic way we have to allow interaction with our widgets is by using </st><span class="No-Break"><st c="40376">deep links.</st></span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor208"/><st c="40387">Opening a specific screen using links</st></h2>
			<p><st c="40425">If you are not familiar with the concept of deep links, now is the time to straighten things out. </st><st c="40524">A deep </st><a id="_idIndexMarker269"/><st c="40531">link is a link that opens our app on a specific screen. </st><st c="40587">Today’s deep links format is similar to website URLs. </st><st c="40641">For example, a deep link that opens our app in a specific calendar event screen can look something </st><span class="No-Break"><st c="40740">like this:</st></span></p>
			<pre class="source-code"><st c="40750">
http://www.myGreatCalendarAp.com/event/&lt;eventID&gt;/</st></pre>			<p><st c="40800">To do that, the app needs to do </st><span class="No-Break"><st c="40833">three things:</st></span></p>
			<ul>
				<li><em class="italic"><st c="40846">Register to that specific domain</st></em><st c="40879"> by placing a special JSON file on the </st><span class="No-Break"><st c="40918">relevant server</st></span></li>
				<li><st c="40933">Add the domain </st><em class="italic"><st c="40949">entitlement</st></em><st c="40960"> to </st><span class="No-Break"><st c="40964">our app</st></span></li>
				<li><st c="40971">Respond to </st><em class="italic"><st c="40983">launching the app from a deep link</st></em><st c="41017">, parse the URL, and direct the user to the corresponding location within </st><span class="No-Break"><st c="41091">the app</st></span></li>
			</ul>
			<p><st c="41098">To learn more about deep links, I recommend reading about it in the Apple </st><span class="No-Break"><st c="41173">Developer website:</st></span></p>
			<p><a href="https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content"><span class="No-Break"><st c="41191">https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content</st></span></a></p>
			<p><st c="41290">Going back to our topic, let’s see an example of adding a deep link to our </st><strong class="source-inline"><st c="41366">Next </st></strong><span class="No-Break"><strong class="source-inline"><st c="41371">Event</st></strong></span><span class="No-Break"><st c="41376"> widget:</st></span></p>
			<pre class="source-code"><st c="41384">
struct MyWidgetEntryView : View {
    var entry: Provider.Entry
    var body: some View {
        VStack {
            Text("Time:")
            Text(entry.nextEventTime, style: .time)
            Text("Next Event")
            Text(entry.nextEvent)
</st><strong class="bold"><st c="41571">                .widgetURL(URL(string:</st></strong>
<strong class="bold"><st c="41593">"</st></strong><st c="41595">https://www.myGreatCalendarApp.com/event/\(entry.eventID)/"</st><strong class="bold"><st c="41654">))</st></strong><st c="41657">
        }
    }
}</st></pre>			<p><st c="41663">In the </st><a id="_idIndexMarker270"/><st c="41671">preceding code example, we can see that we added a view modifier called </st><strong class="source-inline"><st c="41743">widgetURL</st></strong><st c="41752"> to the </st><strong class="source-inline"><st c="41760">Next Event</st></strong> <span class="No-Break"><strong class="source-inline"><st c="41770">Text</st></strong></span><span class="No-Break"><st c="41775"> component.</st></span></p>
			<p><st c="41786">The </st><strong class="source-inline"><st c="41791">Next Event</st></strong> <strong class="source-inline"><st c="41801">Text</st></strong><st c="41806"> component is indeed the view that accepts the user’s touch and opens the app in the specific deep link. </st><st c="41911">But when the widget is small (</st><strong class="source-inline"><st c="41941">.systemSmall</st></strong><st c="41953">), we can add only one deep link that is acceptable in the </st><span class="No-Break"><st c="42013">whole widget.</st></span></p>
			<p><st c="42026">In widgets with medium and large sizes, we can add multiple links to </st><span class="No-Break"><st c="42096">multiple components.</st></span></p>
			<p><st c="42116">It is worth noting that in terms of security, deep links work even when the device is locked, but require </st><em class="italic"><st c="42223">FaceID</st></em><st c="42229"> or passcode when tapping </st><span class="No-Break"><st c="42255">on them.</st></span></p>
			<p><st c="42263">In iOS 17, deep links are not the only option we have to allow users to interact with our widget, as it is possible to add buttons and toggles </st><span class="No-Break"><st c="42407">as well.</st></span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor209"/><st c="42415">Adding interactive capabilities</st></h2>
			<p><st c="42447">Deep links </st><a id="_idIndexMarker271"/><st c="42459">in widgets are great, but they have one big problem – tapping on the widget always opens the app. </st><st c="42557">But, sometimes, we want to update data or confirm something without entering the app. </st><st c="42643">For example, maybe we want to accept a calendar invitation, approve a payment, or mark a task </st><span class="No-Break"><st c="42737">as completed.</st></span></p>
			<p><st c="42750">Because </st><a id="_idIndexMarker272"/><st c="42759">widgets don’t actually run, it’s a challenge to respond to a user interaction. </st><st c="42838">Fortunately, there is a solution that we have already encountered in configurable widgets, and that’s </st><span class="No-Break"><st c="42940">App Intents.</st></span></p>
			<h3><st c="42952">Using App Intents to add interactive widgets</st></h3>
			<p><st c="42997">App Intents </st><a id="_idIndexMarker273"/><st c="43010">made especially for this kind of use case – to allow runtime for </st><span class="No-Break"><st c="43075">specific actions.</st></span></p>
			<p><st c="43092">So, how do App Intents help us? </st><st c="43125">Let’s look at </st><span class="No-Break"><em class="italic"><st c="43139">Figure 5</st></em></span><span class="No-Break"><em class="italic"><st c="43147">.4</st></em></span><span class="No-Break"><st c="43149">:</st></span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21795_05_4.jpg" alt="Figure 5.4: App Intent event flow"/><st c="43151"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="43315">Figure 5.4: App Intent event flow</st></p>
			<p><st c="43348">In </st><span class="No-Break"><em class="italic"><st c="43352">Figure 5</st></em></span><em class="italic"><st c="43360">.4</st></em><st c="43362">, we can see that the first stage is tapping on a button inside the widget. </st><st c="43438">Starting from iOS 17, the </st><em class="italic"><st c="43464">WidgetKit </st></em><st c="43474">framework has its own type of button, which can be linked to a specific </st><span class="No-Break"><st c="43546">App Intent:</st></span></p>
			<pre class="source-code"><st c="43557">
Button("Turn \(entry.isAlarm ? </st><st c="43589">"Off" : "On") Alarm" , role:
  nil, </st><strong class="bold"><st c="43623">intent: MyWidgetIntent(eventID: entry.eventID))</st></strong></pre>			<p><st c="43670">The goal of the button here is to toggle the alarm for the event on and off. </st><st c="43748">We can see that the title is changed according to the </st><strong class="source-inline"><st c="43802">entry.isAlaram</st></strong><st c="43816"> value. </st><st c="43824">But what’s more interesting here is that we have an additional parameter called </st><strong class="source-inline"><st c="43904">Intent</st></strong><st c="43910">, where we pass a struct named </st><strong class="source-inline"><st c="43941">MyWidgetIntent</st></strong><st c="43955"> along with </st><span class="No-Break"><st c="43967">the </st></span><span class="No-Break"><strong class="source-inline"><st c="43971">eventID</st></strong></span><span class="No-Break"><st c="43978">.</st></span></p>
			<p><st c="43979">Let’s talk about the App Intent, but this time, in the context of </st><span class="No-Break"><st c="44046">user interaction.</st></span></p>
			<h3><st c="44063">Performing the data change using the intent</st></h3>
			<p><st c="44107">We have already said that the widget doesn’t manage any state. </st><st c="44171">Therefore, the real widgets </st><a id="_idIndexMarker274"/><st c="44199">state is some kind of a combination between a local store and the </st><span class="No-Break"><st c="44265">timeline provider.</st></span></p>
			<p><st c="44283">The </st><strong class="source-inline"><st c="44288">MyWidgetIntent</st></strong><st c="44302"> receives an </st><strong class="source-inline"><st c="44315">eventID</st></strong><st c="44322"> and is responsible for reaching out to </st><strong class="source-inline"><st c="44362">EventKit</st></strong><st c="44370"> and updating the actual event </st><span class="No-Break"><st c="44401">alarm information.</st></span></p>
			<p><st c="44419">Let’s look at the </st><span class="No-Break"><st c="44438">App Intent:</st></span></p>
			<pre class="source-code"><st c="44449">
struct MyWidgetIntent: AppIntent {
    init() {
    }
    var eventID: String = ""
    init(eventID: String) {
        self.eventID = eventID
    }
    static var title: LocalizedStringResource = "Changing '
      event alarm settings."
    </st><st c="44649">func perform() async throws -&gt; some IntentResult {
        // working with EventKit and updating the event alarm data.
        </st><st c="44760">return .result()
    }
}</st></pre>			<p><st c="44780">Besides the </st><strong class="source-inline"><st c="44793">LocalizedStringResource</st></strong><st c="44816"> static property that we discussed in the </st><em class="italic"><st c="44858">Customize our widget</st></em><st c="44878"> section, we have one primary function called </st><strong class="source-inline"><st c="44924">perform()</st></strong><st c="44933">. The </st><strong class="source-inline"><st c="44939">perform()</st></strong><st c="44948"> function executes when the user taps on the button that is linked to that App Intent. </st><st c="45035">Notice that the </st><strong class="source-inline"><st c="45051">perform()</st></strong><st c="45060"> function is also an async function that lets us perform </st><a id="_idIndexMarker275"/><st c="45117">heavier tasks, such as writing to the database or even performing a </st><span class="No-Break"><st c="45185">URL request.</st></span></p>
			<p><st c="45197">Once the </st><strong class="source-inline"><st c="45207">perform()</st></strong><st c="45216"> function completes its execution, the App Intent triggers </st><span class="No-Break"><st c="45275">the </st></span><span class="No-Break"><em class="italic"><st c="45279">WidgetCenter</st></em></span><span class="No-Break"><st c="45291">.</st></span></p>
			<h3><st c="45292">Updating the widget UI</st></h3>
			<p><st c="45315">Now that the local store is updated, it’s time for the </st><em class="italic"><st c="45371">WidgetCenter</st></em><st c="45383"> to reload the Timeline </st><a id="_idIndexMarker276"/><st c="45407">Provider. </st><st c="45417">We should already be familiar with that process – the Timeline Provider fetches the relevant local data and builds a timeline based on the changes we just performed. </st><st c="45583">At the end, the widget UI is </st><span class="No-Break"><st c="45612">being updated.</st></span></p>
			<p><st c="45626">Working with App Intent is also great if we want to share code execution between different app components. </st><st c="45734">For example, we can share logic code between our widget and the </st><span class="No-Break"><st c="45798">Siri Shortcut.</st></span></p>
			<p><st c="45812">We should remember that even if the widget could have a runtime of its own, it is still a good practice to separate our code for better flexibility </st><span class="No-Break"><st c="45961">and modularity.</st></span></p>
			<p><st c="45976">Another great usage for App Intent is the control widget, another great addition to iOS 18. </st><st c="46069">Let’s go over </st><span class="No-Break"><st c="46083">it now.</st></span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor210"/><st c="46090">Adding a control widget</st></h1>
			<p><em class="italic"><st c="46114">WidgetKit </st></em><st c="46125">provides ways </st><a id="_idIndexMarker277"/><st c="46139">to present our apps in the springboard. </st><st c="46179">However, it doesn’t stop there. </st><st c="46211">Starting iOS 18, it is possible to present widgets in the control center and on the lock screen and even attach an App Intent to the action button in iPhone </st><span class="No-Break"><st c="46368">15 Pro.</st></span></p>
			<p><st c="46375">Adding a widget to the control center or the lock screen </st><span class="No-Break"><st c="46433">is easy.</st></span></p>
			<p><st c="46441">Similar to how we create a widget by conforming to the Widget protocol, we need to conform to the </st><strong class="source-inline"><st c="46540">ControlWidget</st></strong><st c="46553"> protocol to create a control widget. </st><st c="46591">For example, imagine we have an app that helps us control smart home accessories, and we want to create a widget </st><a id="_idIndexMarker278"/><st c="46704">that opens and closes our home’s main door. </st><st c="46748">Let’s start by creating a simple control widget </st><span class="No-Break"><st c="46796">called </st></span><span class="No-Break"><strong class="source-inline"><st c="46803">MaindoorControl</st></strong></span><span class="No-Break"><st c="46818">:</st></span></p>
			<pre class="source-code"><st c="46820">
struct MaindoorControl: ControlWidget {
    var body: some ControlWidgetConfiguration {
        StaticControlConfiguration(
            kind: "com.avitsadok.MaindoorControl"
        ) {
// rest of the widget goes here
        }
    }
}</st></pre>			<p><st c="47012">In this code example, the </st><strong class="source-inline"><st c="47039">MaindoorControl</st></strong><st c="47054"> widget contains the </st><strong class="source-inline"><st c="47075">body</st></strong><st c="47079"> variable from the time of </st><strong class="source-inline"><st c="47106">ControlWidgetConfiguration</st></strong><st c="47132">. This is very similar to how we created a home screen widget under the </st><em class="italic"><st c="47204">Configuring our </st></em><span class="No-Break"><em class="italic"><st c="47220">widget</st></em></span><span class="No-Break"><st c="47226"> section.</st></span></p>
			<p><st c="47235">In this case, we return an instance of the </st><strong class="source-inline"><st c="47279">StaticControlConfiguration</st></strong><st c="47305"> type, which means we don’t give the user the ability to configure it. </st><st c="47376">However, similar to the home screen widget, we can also add a user-configurable control widget by returning </st><strong class="source-inline"><st c="47484">AppIntentControlConfiguration</st></strong><st c="47513"> (look in the </st><em class="italic"><st c="47527">Customize our </st></em><span class="No-Break"><em class="italic"><st c="47541">widget</st></em></span><span class="No-Break"><st c="47547"> section).</st></span></p>
			<p><st c="47557">We can add two control widget controls – a toggle and a button. </st><st c="47622">In the case of controlling our home’s main door state, we need to add a toggle. </st><st c="47702">Let’s modify our code and add a </st><span class="No-Break"><strong class="source-inline"><st c="47734">ControlWidgetToggle</st></strong></span><span class="No-Break"><st c="47753"> instance:</st></span></p>
			<pre class="source-code"><st c="47763">
struct MaindoorControl: ControlWidget {
    var body: some ControlWidgetConfiguration {
        StaticControlConfiguration(
            kind: "com.avitsadok.MaindoorControl"
        ) {
</st><strong class="bold"><st c="47918">            ControlWidgetToggle(</st></strong>
<strong class="bold"><st c="47938">                "Main door control",</st></strong>
<strong class="bold"><st c="47959">                isOn: HouseManager.shared.isOpen,</st></strong>
<strong class="bold"><st c="47993">                action: MaindoorIntent()</st></strong>
<strong class="bold"><st c="48018">            ) { isOn in</st></strong>
<strong class="bold"><st c="48030">                Label(isOn ? </st><st c="48044">"Opened" : "Closed",</st></strong>
<strong class="bold"><st c="48064">                      systemImage: isOn ?</st></strong>
<strong class="bold"><st c="48084">                        "door.left.hand.open" :</st></strong>
<strong class="bold"><st c="48108">                          "door.left.hand.closed")</st></strong>
<strong class="bold"><st c="48133">            }</st></strong><st c="48135">
        }
    }
}</st></pre>			<p><st c="48141">In this </st><a id="_idIndexMarker279"/><st c="48150">code example, we add the </st><strong class="source-inline"><st c="48175">ControlWidgetToggle</st></strong><st c="48194">, containing the </st><span class="No-Break"><st c="48211">following parameters:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="48232">A title</st></strong><st c="48240"> – The widget title that appears for the widget in the </st><span class="No-Break"><st c="48295">widget gallery.</st></span></li>
				<li><strong class="source-inline"><st c="48310">isOn</st></strong><st c="48315"> – Here, we connect the widget to the actual state in </st><span class="No-Break"><st c="48369">our app.</st></span></li>
				<li><strong class="source-inline"><st c="48377">action</st></strong><st c="48384"> – The App Intent that runs when the user taps our control widget. </st><st c="48451">We’ll cover that later in </st><span class="No-Break"><st c="48477">this section.</st></span></li>
				<li><strong class="bold"><st c="48490">A view builder</st></strong><st c="48505"> – In the view builder, we define how a </st><strong class="source-inline"><st c="48545">Label</st></strong><st c="48550"> displays the control state’s title and </st><span class="No-Break"><st c="48590">an image.</st></span></li>
			</ul>
			<p><st c="48599">The widget instance is straightforward. </st><st c="48640">Let’s see how it looks in our control center (</st><span class="No-Break"><em class="italic"><st c="48686">Figure 5</st></em></span><span class="No-Break"><em class="italic"><st c="48695">.5</st></em></span><span class="No-Break"><st c="48697">):</st></span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21795_05_5.jpg" alt="Figure 5.5: Our control widget in the control center"/><st c="48700"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="48702">Figure 5.5: Our control widget in the control center</st></p>
			<p><span class="No-Break"><em class="italic"><st c="48754">Figure 5</st></em></span><em class="italic"><st c="48763">.5</st></em><st c="48765"> shows the control center’s main door control widget. </st><st c="48819">However, there’s another side </st><a id="_idIndexMarker280"/><st c="48849">to our control widget – connecting the control widget to the action of opening and closing the main door. </st><st c="48955">Let’s look at the </st><strong class="source-inline"><st c="48973">MaindoorIntent</st></strong><st c="48987"> struct we saw in the </st><span class="No-Break"><strong class="source-inline"><st c="49009">action</st></strong></span><span class="No-Break"><st c="49015"> parameter:</st></span></p>
			<pre class="source-code"><st c="49026">
struct MaindoorIntent: SetValueIntent {
    static let title: LocalizedStringResource = "Maindoor
      opening"
    @Parameter(title: "is open")
    var value: Bool
    func perform() throws -&gt; some IntentResult {
      HouseManager.shared.isOpen = value
        return .result()
    }
}</st></pre>			<p><st c="49275">In this code example, we see the </st><strong class="source-inline"><st c="49309">MaindoorIntent</st></strong><st c="49323"> implementation. </st><st c="49340">The </st><strong class="source-inline"><st c="49344">MaindoorIntent</st></strong><st c="49358"> structure conforms to the </st><strong class="source-inline"><st c="49385">SetValueIntent</st></strong><st c="49399"> protocol, which contains a value we can set. </st><st c="49445">In this example, the value is from the </st><strong class="source-inline"><st c="49484">Bool</st></strong><st c="49488"> type, which we can use to perform the </st><span class="No-Break"><st c="49527">desired operation.</st></span></p>
			<p><st c="49545">Adding a </st><a id="_idIndexMarker281"/><st c="49555">control widget to our app involves similar practices that we saw when we added a home screen widget and app intents that allow us to share code between widgets and other </st><span class="No-Break"><st c="49725">app components.</st></span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor211"/><st c="49740">Summary</st></h1>
			<p><st c="49748">Widgets are enjoyable and fun UI elements we can work with in iOS development. </st><st c="49828">They provide sleek UI, great animation, and a glanceable user experience. </st><st c="49902">We have seen that each iOS version has added interesting new widget capabilities to make widgets more powerful </st><span class="No-Break"><st c="50013">than ever.</st></span></p>
			<p><st c="50023">In this chapter, we learned about the idea of widgets, how to add widgets, creating a timeline, and adding user-configurable options. </st><st c="50158">Also, we learned how to create custom animations and even add user interaction. </st><em class="italic"><st c="50238">WidgetKit </st></em><st c="50248">has become a fascinating framework to work with. </st><st c="50297">In the next chapter, we’ll continue to discover how to improve the user experience, this time with </st><span class="No-Break"><st c="50396">SwiftUI animations.</st></span></p>
		</div>
	<div id="charCountTotal" value="50415"/></body></html>