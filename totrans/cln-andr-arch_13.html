<html><head></head><body>
		<div><h1 id="_idParaDest-100"><em class="italic"><a id="_idTextAnchor105"/>Chapter 10</em>: Putting It All Together</h1>
			<p>In this chapter, we will analyze what we have done so far in the previous chapters and look at different ways we can improve the layers of the application. Later, we will explore the benefit of clean architecture when we integrate instrumented testing into the application, where we will swap the data source dependencies with mock dependencies to ensure the reliability of the tests.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Inspecting module dependencies</li>
				<li>Instrumentation testing</li>
			</ul>
			<p>By the end of the chapter, you will be able to identify and remove external dependencies in the use case layer of the application to enforce the <strong class="bold">Common Closure Principle</strong> (<strong class="bold">CCP</strong>) and know how to create instrumented tests on Android with mock data sources.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3sLr0HS">https://bit.ly/3sLr0HS</a></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor107"/>Inspecting module dependencies</h1>
			<p>In this<a id="_idIndexMarker673"/> section, we will analyze the dependencies used across the different modules in the application created in the previous chapters.</p>
			<p>Following <em class="italic">Exercise 09.01 – Transitioning to MVI</em> from <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, we now have a fully functioning application split into separate modules, representing different layers. We can analyze the relationship between the different<a id="_idIndexMarker674"/> modules by looking at the <code>dependencies</code> block in the <code>build.gradle</code> file in each module and focusing in particular on the <code>implementation(project(path: "{module}"))</code> lines. If we were to draw a diagram, it would look like the following:</p>
			<div><div><img src="img/Figure_10.01_B18320.jpg" alt="Figure 10.1 – A module dependency diagram for exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – A module dependency diagram for exercise 09.01</p>
			<p>In the preceding figure, we can see that the <code>:domain</code> module, which is part of the domain layer, is at the center, with the modules from the other layers having a dependency toward it. The <code>:app</code> module is responsible for assembling all of the dependencies, and this means that it will have a dependency on all the other modules. This means<a id="_idIndexMarker675"/> that we are in a good clean architecture position because we want the entities and use cases to have minimal dependencies on other components. If we continue analyzing the <code>build.gradle</code> files for each module and include the external dependencies as well, we will see additional dependencies on external libraries for each module: </p>
			<div><div><img src="img/Figure_10.02_B18320.jpg" alt="Figure 10.2 – A module dependency diagram with external dependencies for exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – A module dependency diagram with external dependencies for exercise 09.01</p>
			<p>In <em class="italic">Figure 10.2</em>, we can see some of the relevant external dependencies our modules use. <code>:data-remote</code> uses dependencies toward Retrofit and OkHttp for networking, the <code>:data-local</code> module has dependencies toward Room and DataStore, while the presentation layer modules depend on things such as Compose, ViewModel, and the Android framework. Dependencies that were used used across the entire project were coroutines, flows, and Hilt. </p>
			<p>Having <a id="_idIndexMarker676"/>dependencies on Hilt and coroutines might pose a problem for the <code>:domain</code> and <code>:data-repository</code> modules. We want these two modules to be as stable as possible, and having external dependencies will create problems every time we update the versions for those libraries. We decided to use flows because of their threading benefits, the reactive approach, and because they were developed as an extension to the Kotlin framework. They might still pose a problem if we wanted to adapt our use cases for multiple platforms using Kotlin Multiplatform. A solution for this would be to develop a reactive plugin that would abstract the usage of flows and use this abstraction across the different modules. This would allow us to swap different reactive libraries without changing the code inside the module. While this solution would fix the problem, it comes with lots of baggage because we would need to abstract both the streams of data and the operators that the project requires from the flows framework, which would give us more code to maintain. </p>
			<p>When it comes to the Hilt dependency, we can remove the references to Hilt from the <code>:domain</code> and <code>:data-repository</code> modules and move the Hilt modules into <code>:app</code>. Another solution would be to create new Gradle modules that would be responsible for providing the necessary dependency. For example, a <code>:domain-hilt</code> module could be created, where it would have a <code>@Module</code> annotated class that would provide all of the dependencies that the <code>:domain</code> module would need to expose. This approach can be used for other modules that we wish to export into applications that use different dependency injection frameworks to avoid the dependency on Hilt in those projects.</p>
			<p>Module dependencies will increase as applications develop new features and evolve; this means we should take time and assess the dependencies used in a project. This will help us identify potential issues and whether we can scale an application properly. We should also account for external dependencies and analyze the influence they have over our project. In the following section, we will look at an exercise on how to reduce the dependencies that the domain and repository modules have on Hilt.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>Exercise 10.01 – Reduce dependencies</h2>
			<p>Modify <em class="italic">Exercise 09.01 – transitioning to MVI </em> in <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, so <a id="_idIndexMarker677"/>that the <code>domain</code> and <code>data-repository</code> modules will no longer depend on Hilt and instead provide the dependencies from those modules inside the <code>app</code> module. </p>
			<p>Before <a id="_idIndexMarker678"/>completing this exercise, you will need to do the following:</p>
			<ol>
				<li>Remove Hilt from the <code>domain</code> module.</li>
				<li>Remove the <code>@Inject</code> annotation from the <code>GetPostsWithUsersWithInteractionUseCase</code>, <code>GetPostUseCase</code>, <code>GetUserUseCase</code>, and <code>UpdateInteractionUseCase</code> classes.</li>
				<li>Rename the <code>AppModule</code> class <code>UseCaseModule</code> and use <code>@Provides</code> to provide dependencies to the preceding objects.</li>
				<li>Remove Hilt from the <code>data-repository</code> module and delete the use of the <code>@Inject</code> annotation.</li>
				<li>Move <code>RepositoryModule</code> from the <code>data-repository</code> module into <code>app</code> and use <code>@Provides</code> to provide the dependencies to <code>PostRepository</code>, <code>UserRepository</code>, and <code>InteractionRepository</code>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the <code>build.gradle</code> file of the <code>domain</code> module, remove the use of the <code>kapt</code> and Hilt plugins:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
}</pre></li>
				<li>In the same file, delete the usages of Hilt from the <code>dependencies</code> block:<pre>dependencies {
    implementation coroutines.coroutinesAndroid
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>Delete<a id="_idIndexMarker679"/> the use of <code>@Inject</code> from <code>GetPostsWithUsersWithInteractionUseCase</code>:<pre>class GetPostsWithUsersWithInteractionUseCase(
    configuration: Configuration,
    private val postRepository: PostRepository,
    private val userRepository: UserRepository,
    private val interactionRepository: 
        InteractionRepository
) : UseCase&lt;GetPostsWithUsersWithInteractionUseCase.
    Request,
        GetPostsWithUsersWithInteractionUseCase.
            Response&gt;(configuration) {
    …
}</pre></li>
				<li>Delete the use of <code>@Inject</code> from <code>GetPostUseCase</code>:<pre>class GetPostUseCase(
    configuration: Configuration,
    private val postRepository: PostRepository
) : UseCase&lt;GetPostUseCase.Request, GetPostUseCase.
    Response&gt;(configuration) {
    …
}</pre></li>
				<li>Delete the use of <code>@Inject</code> from <code>GetUserUseCase</code>:<pre>class GetUserUseCase(
    configuration: Configuration,
    private val userRepository: UserRepository
) : UseCase&lt;GetUserUseCase.Request, GetUserUseCase.
    Response&gt;(configuration) {
    …
}</pre></li>
				<li>Delete <a id="_idIndexMarker680"/>the use of <code>@Inject</code> from <code>UpdateInteractionUseCase</code>:<pre>class UpdateInteractionUseCase(
    configuration: Configuration,
    private val interactionRepository: 
        InteractionRepository
) : UseCase&lt;UpdateInteractionUseCase.Request, 
   UpdateInteractionUseCase.Response&gt;(configuration) {
    …
}</pre></li>
				<li>In the app module, rename <code>AppModule</code> <code>UseCaseModule</code>.</li>
				<li>In the app module in the <code>UseCaseModule</code> class, provide a dependency to <code>GetPostsWithUsersWithInteractionUseCase</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class UseCaseModule {
    …
    @Provides
    fun   
    provideGetPostsWithUsersWithInteractionUseCase(
        configuration: UseCase.Configuration,
        postRepository: PostRepository,
        userRepository: UserRepository,
        interactionRepository: InteractionRepository
    ): GetPostsWithUsersWithInteractionUseCase = 
       GetPostsWithUsersWithInteractionUseCase(
        configuration,
        postRepository,
        userRepository,
        interactionRepository
    ) 
}</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker681"/>need to use <code>@Provides</code> because we are no longer in the same module, which means we should treat this as an external dependency, which needs the <code>@Provides</code> annotation, similar to how we provided the Room and Retrofit dependencies.</p>
			<ol>
				<li value="9">In the same class, provide a dependency to <code>GetPostUseCase</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class UseCaseModule {
    …
    @Provides
    fun provideGetPostUseCase(
        configuration: UseCase.Configuration,
        postRepository: PostRepository
    ): GetPostUseCase = GetPostUseCase(
        configuration,
        postRepository
    )
}</pre></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="10">In the <a id="_idIndexMarker682"/>same class, provide a dependency to <code>GetUserUseCase</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class UseCaseModule {
    …
    @Provides
    fun provideGetUserUseCase(
        configuration: UseCase.Configuration,
        userRepository: UserRepository
    ): GetUserUseCase = GetUserUseCase(
        configuration,
        userRepository
    )
}</pre></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="11">In the same class, provide a dependency to <code>UpdateInteractionUseCase</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class UseCaseModule {
    …
    @Provides
    fun provideUpdateInteractionUseCase(
        configuration: UseCase.Configuration,
        interactionRepository: InteractionRepository
    ): UpdateInteractionUseCase = 
       UpdateInteractionUseCase(
        configuration,
        interactionRepository
    )
}</pre></li>
			</ol>
			<p>In this<a id="_idIndexMarker683"/> snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="12">In the <code>build.gradle</code> file of the <code>data-repository</code> module, remove the use of the <code>kapt</code> and Hilt plugins:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
}</pre></li>
				<li>In the same file, delete the usages of Hilt from the <code>dependencies</code> block:<pre>dependencies {
    implementation(project(path: ":domain"))
    implementation coroutines.coroutinesAndroid
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>Move<a id="_idIndexMarker684"/> the <code>RepositoryModule</code> class from the injection package in the <code>data-repository</code> module into the injection package in the <code>app</code> module and make the class not abstract.</li>
				<li>Delete the use of <code>@Inject</code> from <code>InteractionRepositoryImpl</code>:<pre>class InteractionRepositoryImpl(
    private val interactionDataSource: LocalInteractionDataSource
) : InteractionRepository {
    …
}</pre></li>
				<li>Delete the use of <code>@Inject</code> from <code>PostRepositoryImpl</code>:<pre>class PostRepositoryImpl(
    private val remotePostDataSource: 
        RemotePostDataSource,
    private val localPostDataSource: 
        LocalPostDataSource
) : PostRepository {
    …
}</pre></li>
				<li>Delete the use of <code>@Inject</code> from <code>UserRepositoryImpl</code>:<pre>class UserRepositoryImpl(
    private val remoteUserDataSource: 
        RemoteUserDataSource,
    private val localUserDataSource: 
        LocalUserDataSource
) : UserRepository {
    …
}</pre></li>
				<li>In <a id="_idIndexMarker685"/>the <code>RepositoryModule</code> class, replace the <code>bindPostRespository</code> method with a <code>@Provides</code> method:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Provides
    fun providePostRepository(
        remotePostDataSource: RemotePostDataSource,
        localPostDataSource: LocalPostDataSource
    ): PostRepository = PostRepositoryImpl(
        remotePostDataSource,
        localPostDataSource
    )
    …
}</pre></li>
			</ol>
			<p>Here, we are no longer able to use the <code>@Binds</code> annotation because we removed the <code>@Inject</code> annotation from the <code>PostRepositoryImpl</code> class, and because it is an external dependency, we will need to use <code>@Provides</code>.</p>
			<ol>
				<li value="19">In the <a id="_idIndexMarker686"/>same file, replace the <code>bindUserRepository</code> method with a <code>@Provides</code> method:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    …
    @Provides
    fun provideUserRepository(
        remoteUserDataSource: RemoteUserDataSource,
        localUserDataSource: LocalUserDataSource
    ): UserRepository = UserRepositoryImpl(
        remoteUserDataSource,
        localUserDataSource
    )
    …
}</pre></li>
				<li>In the same file, replace <code>bindInteractionRepositorymethod</code> with a <code>@Provides</code> method:<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    …
    @Provides
    fun provideInteractionRepository(
        interactionDataSource: 
            LocalInteractionDataSource
    ): InteractionRepository = 
       InteractionRepositoryImpl(
        interactionDataSource
    )
    …
}</pre></li>
			</ol>
			<p>If we run the application, we <a id="_idIndexMarker687"/>should see the same output that we got in <em class="italic">Exercise 09.01 – Transitioning to MVI</em>:</p>
			<div><div><img src="img/Figure_10.03_B18320_Merged.jpg" alt="Figure 10.3 – The output of exercise 10.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The output of exercise 10.01</p>
			<p>The project is now in a state where the <code>domain</code> and <code>data-repository</code> modules no longer depend on Hilt. This means that all the other modules that depend on these two will be less <a id="_idIndexMarker688"/>exposed to potential issues caused by updates to Hilt. It also means that in the future, if we want to change the dependency injection framework used across the application, the <code>domain</code> and <code>data-repository</code> modules will remain unaffected by the change. In the section that follows, we will look at how we can create instrumentation tests with mock data to test that the modules are well integrated and that the data being passed is processed appropriately. </p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>Instrumentation testing</h1>
			<p>In this section, we will<a id="_idIndexMarker689"/> look at how to perform instrumentation testing for an Android application and how we can take advantage of dependency injection to inject either mock data or add test-related logic without modifying the structure of an application's code.</p>
			<p>Instrumentation testing <a id="_idIndexMarker690"/>is a set of tests that are run on an Android device or emulator and is represented by the tests written in the <code>androidTest</code> directory. Just like other parts of Android development, instrumentation testing evolved across the years to improve the quality of test code and to provide the ability to create better tests and assertions. Initially, testing was done using test classes such as <code>ActivityTestCase</code>, <code>ContentProviderTestCase</code>, and <code>ServiceTestCase</code>, which were mainly used to test individual components of an application in isolation. The addition of the Espresso testing libraries allows us to easily test multiple activities as part of the journey a user would undertake. </p>
			<p>In order to add Espresso and the associated libraries into a project, the following will need to be added to any module's <code>build.gradle</code> file:</p>
			<pre>dependencies {
    …
    androidTestImplementation "androidx.test:core:1.4.0"
    androidTestImplementation "androidx.test:runner:1.4.0 "
    androidTestImplementation "androidx.test:rules:1.4.0 "
    androidTestImplementation 
        "androidx.test.ext:junit:1.1.3 "
    androidTestImplementation 
        "androidx.test.espresso:espresso-core:3.4.0 "
    androidTestImplementation "androidx.test.espresso.
        idling:idling-concurrent:3.4.0 "
}</pre>
			<p>The following<a id="_idIndexMarker691"/> is an example of a test written using Espresso:</p>
			<pre>    @Test
    fun myTest(){
        ActivityScenario.launch(MainActivity::class.java).
            moveToState(Lifecycle.State.RESUMED)
        onView(withId(R.id.my_id))
            .perform(click())
            .check(isDisplayed())
    }</pre>
			<p>In the preceding example, we use the <code>ActivityScenario</code> launch method to start <code>MainActivity</code> and transition <code>Activity</code> to the <code>RESUMED</code> state. We then use <code>onView</code>, which requires <code>ViewMatcher</code>, and <code>withId</code> looks up <code>View</code> by its ID and returns <code>ViewMatcher</code> holding that information. We then have the option to use <code>perform</code>, which requires <code>ViewAction</code>. This is for when we want to interact with certain views. We can also perform <code>ViewAssertion</code> using the <code>check</code> method. In this case, we are checking whether a view is displayed. </p>
			<p>Another useful addition to help with testing is the orchestrator. The orchestrator is useful when we want to delete the data generated by the tests that might be kept in memory or persisted on the device and that in turn might impact other tests and cause them to malfunction. What the orchestrator does is uninstall the application before each executed test so that every test will be on a freshly installed app. In order to add the orchestrator to the application, you will need to add it to the module's <code>build.gradle</code> file:</p>
			<pre>android {
    …
    defaultConfig {
        …
        testInstrumentationRunnerArguments 
            clearPackageData: 'true'
        testOptions {
            execution 'ANDROIDX_TEST_ORCHESTRATOR'
        }
        …
    }
}</pre>
			<p>This will add the<a id="_idIndexMarker692"/> orchestrator configuration into the test execution and pass the instruction to delete the application data after each test. To add the orchestrator dependency into the project, the following is required:</p>
			<pre>dependencies {
    …
    androidTestUtil "androidx.test:orchestrator: 1.4.1"
}</pre>
			<p>Espresso also comes with many extensions, one of which is the concept of <code>IdlingResource</code>. When both local tests (tests that are run on the development machine) and instrumented tests are run, they are run on a dedicated set of threads for testing. The Espresso testing library will monitor the main thread of the application, and when it is idle, it will make the assertions required. If the application uses background threads, Espresso will need a way to be informed by this. We can use <code>IdlingResource</code> to indicate to Espresso wait for an action to complete before continuing its execution. An example of <code>IdlingResource</code> is <code>CountingIdlingResource</code>, which will hold a counter for each operation Espresso will need to wait for. The counter is incremented before each long-running operation and then decremented after the operation is completed. Before each test, <code>IdlingResource</code> will<a id="_idIndexMarker693"/> need to be registered and then unregistered when the test finishes:</p>
			<pre>class MyClass(private val countingIdlingResource: 
    CountingIdlingResource) {
    fun doOperation() {
        countingIdlingResource.increment()
        // Perform long running operation
        countingIdlingResource.decrement()
    }
}</pre>
			<p>In the preceding example, we have <code>CountingIdlingResource</code> being incremented at the beginning of the <code>doOperation</code> method and decremented after the long operation we intend to perform. To register and unregister <code>IdlingResource</code>, we can perform the following:</p>
			<pre>    lateinit var countingIdlingResource : CountingIdlingResource
    @Before
    fun setUp(){
        IdlingRegistry.getInstance().register
            (countingIdlingResource)
    }
    @After
    fun tearDown(){
        IdlingRegistry.getInstance().
            unregister(countingIdlingResource)
    }</pre>
			<p>In this<a id="_idIndexMarker694"/> example, we register <code>IdlingResource</code> in the <code>setUp</code> method, which is called before each test because of the <code>@Before</code> annotation, and unregister it in the <code>tearDown</code> method, which is called after each test because of the <code>@After</code> annotation. </p>
			<p>Because <code>IdlingResource</code> is a part of Espresso but needs to be used when operations inside the application's code are executed, we want to avoid using <code>IdlingResource</code> alongside that code. A solution for this is to decorate the class that contains the operation and then use dependency injection to inject the decorated dependency into the test. To decorate the code, we will need to have an abstraction for the operation. An example of this is as follows:</p>
			<pre>interface MyInterface {
    fun doOperation()
}
class MyClass : MyInterface {
    override fun doOperation() {
        // Implement long running operation
    }
}</pre>
			<p>In the preceding example, we have created an interface that defines the <code>doOperation</code> method, and then we implement the interface with the long-running operation into a class. We can now create a class that will belong to the <code>androidTest</code> folder, which<a id="_idIndexMarker695"/> will decorate the current implementation of the class:</p>
			<pre>class MyDecoratedClass(
    private val myInterface: MyInterface,
    private val countingIdlingResource: 
        CountingIdlingResource
) : MyInterface {
    override fun doOperation() {
        countingIdlingResource.increment()
        myInterface.doOperation()
        countingIdlingResource.decrement()
    }
}</pre>
			<p>Here, we have another implementation of <code>MyInterface</code>, which will hold a reference to the abstraction and <code>CountingIdlingResource</code>. When <code>doOperation</code> is called, we will increment <code>IdlingResource</code>, call the operation, and then, when it's done, decrement <code>IdlingResource</code>.</p>
			<p>If we want to inject the new dependency into the test, we will need first to define a new class that extends <code>Application</code>, which will hold the dependency graph containing the test dependencies. If we are using Hilt, it already provides such a class in the form of <code>HiltTestApplication</code>. If we want to integrate Hilt into the instrumented tests, we will need the following dependencies to be added to the module's <code>build.gradle</code> file:</p>
			<pre>dependencies {
    androidTestImplementation "com.google.dagger:hilt-
        android-testing:2.40.5"
    kaptAndroidTest "com.google.dagger:hilt-android-
        compiler: 2.40.5"
}</pre>
			<p>To <a id="_idIndexMarker696"/>provide the <code>HiltTestApplication</code> class to the test, we will need to change the instrumented test runner. An example of a new test runner will look like the following:</p>
			<pre>class MyTestRunner : AndroidJUnitRunner() {
    override fun newApplication(cl: ClassLoader?, name: 
        String?, context: Context?): Application {
        return super.newApplication(cl, 
            <strong class="bold">HiltTestApplication</strong>::class.java.name, context)
    }
}</pre>
			<p>In this example, we are extending from <code>AndroidJUnitRunner</code>, and in the <code>newApplication</code> method, we invoke the <code>super</code> method, and we pass <code>HiltTestApplication</code> as the <code>name</code>. This means that when the test is executed, <code>HiltTestApplication</code> will be used instead of the <code>Application</code> class we defined in our main code. We will now need to change the configuration in the module's <code>build.gradle</code> file to use the preceding runner:</p>
			<pre>android {
    …
    defaultConfig {
        …
        testInstrumentationRunner "com.test.MyTestRunner"
        …
        }
    }
}</pre>
			<p>This allows the instrumented test to use the runner we have created. Let's now assume that we have <a id="_idIndexMarker697"/>the following module, which will provide the initial dependency:</p>
			<pre>@Module
@InstallIn(SingletonComponent::class)
abstract class MyModule {
    @Binds
    abstract fun bindMyClass(myClass: MyClass): MyInterface
}</pre>
			<p>Here, we are using a simple binding to connect an implementation to the abstraction. In the <code>androidTest</code> folder, we can create a new module in which we replace this instance with the decorated one:</p>
			<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [MyModule::class]
)
class MyDecoratedModule {
    @Provides
    fun provideIdlingResource() = 
        CountingIdlingResource("my-idling-resource")
    @Provides
    fun provideMyDecoratedClass(countingIdlingResource:  
        CountingIdlingResource) =
        MyDecoratedClass(MyClass(), countingIdlingResource)
}</pre>
			<p>In this<a id="_idIndexMarker698"/> example, we use the <code>@TestInstallIn</code> annotation, which will make the dependencies in this module live as long as the test application and replace the dependencies in the previous module. We can then provide dependencies for <code>IdlingResource</code> and <code>MyDecoratedClass</code>, which will wrap <code>MyClass</code> and use <code>IdlingResource</code>. If we want these changes to take effect in the tests, we will need the following changes: </p>
			<pre>@HiltAndroidTest
class MyActivityTest {
    @get:Rule(order = 0)
    var hiltAndroidRule = HiltAndroidRule(this)
    @Inject
    lateinit var idlingResource: CountingIdlingResources
    @Before
    fun setUp(){
        hiltAndroidRule.inject()
        IdlingRegistry.getInstance().register
            (idlingResource)
    }
    @After
    fun tearDown(){
       IdlingRegistry.getInstance().unregister
           (idlingResource)
    }
}</pre>
			<p>In this <a id="_idIndexMarker699"/>example, we have used the <code>@HiltAndroidTest</code> annotation because we want to inject <code>CountingIdlingResources</code> into the test. We then used <code>HiltAndroidTestRule</code> to perform the injection. We also gave it the highest priority in terms of the order of execution for test rules. Finally, we were able to register and unregister <code>CountingIdlingResources</code> for each test in the class.</p>
			<p>Jetpack Compose comes with its own testing libraries, which require the following configuration to the module's <code>build.gradle</code> file:</p>
			<pre>dependencies {
    androidTestImplementation "androidx.compose.ui:ui-test-
        junit4:1.0.5"
    debugImplementation "androidx.compose.ui:ui-test-
        manifest:1.0.5"
}</pre>
			<p>To write tests for Jetpack Compose components, we will need to define a Compose test rule using <code>createComposeRule</code> when we want to test individual composable methods, or <code>createAndroidComposeRule</code> if we want to test the Compose content of an entire activity. An example would look like the following:</p>
			<pre>class MyTest {
    @get:Rule
    var composeTestRule = createAndroidComposeRule
        (MyActivity::class.java)
}</pre>
			<p>In the <a id="_idIndexMarker700"/>preceding example, we have defined a test rule that will be responsible for testing the Compose content inside <code>MyActivity</code>. If we want the test to interact with the user interface or assert that it displays the correct information, we have the following structure:</p>
			<pre>    @Test
    fun testDisplayList() {
        composeTestRule.onNode()
            .assertIsDisplayed()
            .performClick()
    }</pre>
			<p>In this example we use the <code>onNode</code> method to locate a particular element, such as <code>Text</code> or <code>Button</code>. We then have the <code>assertIsDisplayed</code> method, which is used to check whether the node is displayed. Finally, we have the <code>performClick</code> method, which will click on the element. Jetpack Compose uses its own <code>IdlingResource</code> type, which can be registered in the Compose test rule, similar to the following example:</p>
			<pre>    lateinit var idlingResource: IdlingResource
    @Before
    fun setUp() {
        composeTestRule.registerIdlingResource
            (idlingResource)
    }
    @After
    fun tearDown() {
        composeTestRule.unregisterIdlingResource
            (idlingResource)
    }</pre>
			<p>From a <a id="_idIndexMarker701"/>clean architecture perspective, we should strive to make our application's code as testable as possible. This applies to both local tests such as unit tests and instrumented tests. We want to be able to ensure that the tests are reliable; this usually means that we will need to remove the dependency on network calls, which means we will need to provide a way to inject mock data into the application without modifying the application's code. We also need to be able to either inject <code>IdlingResources</code> into the application or use decorated dependencies to verify that the data inserted by the user is the correct data received in the data layer. This also involves the ability to decorate these dependencies to add extra logic without modifying the application's code. In the following section, we will look at an exercise in which we will inject various dependencies containing testing logic into the application and assess the difficulty it takes to introduce them.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Exercise 10.02 – Instrumented testing</h2>
			<p>Add one instrumented test to <em class="italic">Exercise 10.01 – Reduce dependencies</em>, which will assert that the following data is displayed onscreen:</p>
			<div><div><img src="img/Figure_10.04_B18320.jpg" alt="Figure 10.4 – The expected output of exercise 10.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The expected output of exercise 10.02</p>
			<p>To achieve this, you <a id="_idIndexMarker702"/>will need to create a new implementation of <code>RemotePostDataSource</code>, which will return a list of four posts; two posts will belong to one user and the other two will belong to another user. The same thing will need to be done for <code>RemoteUserDataSource</code>, which will return the two users. These implementations will need to be injected into the test. To ensure that the test will wait for the background work to complete, you will need to decorate each repository with  <code>IdlingResource</code>, which will also need to be injected into the test.</p>
			<p>Before completing <a id="_idIndexMarker703"/>this exercise, you will need to do the following:</p>
			<ol>
				<li value="1">Integrate the testing libraries into the app module.</li>
				<li>Create <code>PostAppTestRunner</code>, which will be used to provide <code>HiltTestApplication</code> to the Android instrumentation test runner.</li>
				<li>Create a <code>ComposeCountingIdlingResource</code> class, which will wrap an Espresso <code>CountingIndlingResource</code> and implement the Compose <code>IdlingResource</code>.</li>
				<li>Create <code>MockRemotePostDataSource</code> and <code>MockRemoteUserDataSource</code>, which will be responsible for returning the users and posts in presented in <em class="italic">Figure 10.4</em>.</li>
				<li>Create <code>IdlingInteractionRepository</code>, <code>IdlingUserRepository</code>, and <code>IdlingPostRespository</code>, which will decorate <code>InteractionRepository</code>, <code>UserRepository</code>, and <code>PostRepository</code>, and use the <code>ComposeCountingIdlingResource</code>, which will be incremented when new data is loaded and decremented when data loading is done.</li>
				<li>Create <code>IdlingRepositoryModule</code> and <code>MockRemoteDataSourceModule</code>, which will replace <code>RepositoryModule</code> and <code>RemoteDataSourceModule</code> respectively in the tests.</li>
				<li>Create <code>MainActivityTest</code>, which will have one test, and use <code>createAndroidComposeRule</code> to assert that the list of mock data is displayed.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the top-level <code>build.gradle</code> file, add the following library versions:<pre>buildscript {
    ext {
        …
        versions = [
                …
                androidTestCore      : "1.4.0",
                androidTestJunit     : "1.1.3",
                orchestrator         : "1.4.1"
        ]
        …
}</pre></li>
				<li>In the same file, make <a id="_idIndexMarker704"/>sure that the following <code>androidTest</code> dependencies are added:<pre>buildscript {
    ext {
       …
        androidTest = [
                junit             : "androidx.test.ext
                    :junit:${versions.espressoJunit}",
                espressoCore      : "androidx.test.
                    espresso:espresso-core:${versions.
                        espressoCore}",
                idlingResource    : "androidx.test.
                    espresso:espresso-idling-resource
                        :${versions.espressoCore}",
                composeUiTestJunit: "androidx.compose.
                    ui:ui-test-junit4:$
                        {versions.compose}",
                composeManifest   : "androidx.compose
                    .ui:ui-test-manifest:$
                        {versions.compose}",
                hilt              : "com.google.
                    dagger:hilt-android-testing:$
                        {versions.hilt}",
                hiltCompiler      : "com.google.
                     dagger:hilt-android-compiler:$
                        {versions.hilt}",
                core              : "androidx.test:
                    core:${versions.androidTestCore}",
                runner            : "androidx.test:
                    runner:$
                        {versions.androidTestCore}",
                rules             : "androidx.test:
                   rules:${versions.androidTestCore}",
                orchestrator      : "androidx.test:
                    orchestrator:$
                        {versions.orchestrator}"
        ]
    }
    …
}</pre></li>
			</ol>
			<p>Here, we are defining the mappings for all the testing libraries we will be using so that they will be available across multiple modules.</p>
			<ol>
				<li value="3">In the <code>build.gradle</code> file of <a id="_idIndexMarker705"/>the app module, add the required test dependencies:<pre>dependencies{
    …
    androidTestImplementation androidTest.junit
    androidTestImplementation androidTest.espressoCore
    androidTestImplementation 
        androidTest.idlingResource
    androidTestImplementation androidTest.core
    androidTestImplementation androidTest.rules
    androidTestImplementation androidTest.runner
    androidTestImplementation androidTest.hilt
    kaptAndroidTest androidTest.hiltCompiler
    androidTestImplementation 
        androidTest.composeUiTestJunit
    debugImplementation androidTest.composeManifest
    androidTestUtil androidTest.orchestrator
}</pre></li>
				<li>In the <code>androidTest</code> folder of the app module, create the <code>PostAppTestRunner</code> class inside the <code>java/{package-name}</code> folder:<pre>class PostAppTestRunner : AndroidJUnitRunner() {
    override fun newApplication(cl: ClassLoader?, 
        name: String?, context: Context?): Application {
        return super.newApplication(cl, 
            HiltTestApplication::class.java.name, 
                context)
    }
}</pre></li>
				<li>In the <code>build.gradle</code> file of the app module, set the following test configuration. Make <a id="_idIndexMarker706"/>sure to replace <code>{package-name}</code> with the package that the <code>PostAppTestRunner</code> is in:<pre>android {
    …
    defaultConfig {
        …
        testInstrumentationRunner "{package-name}.
            PostAppTestRunner"
        testInstrumentationRunnerArguments 
            clearPackageData: 'true'
        testOptions {
            execution 'ANDROIDX_TEST_ORCHESTRATOR'
        }
    }
}</pre></li>
				<li>In the <code>androidTest</code> folder of the app module, create the following packages inside the <code>java/{package-name}</code> folder – <code>idling</code>, <code>injection</code>, <code>remote</code>, <code>repository</code>, and <code>test</code>.</li>
				<li>Inside<a id="_idIndexMarker707"/> the <code>idling</code> package, create a new class called <code>ComposeCountingIdlingResource</code>:<pre>class ComposeCountingIdlingResource(name: String) : 
    IdlingResource {
    private val countingIdlingResource = 
        CountingIdlingResource(name)
    override val isIdleNow: Boolean
        get() = countingIdlingResource.isIdleNow
    fun increment() = countingIdlingResource.
        increment()
    fun decrement() = countingIdlingResource.
        decrement()
}</pre></li>
			</ol>
			<p>Here, we have used the <code>CountingIdlingResource</code> class from Espresso to perform the logic for incrementing, decrementing, and providing its current idling state through the <code>isIdleNow</code> method, which is used by Jetpack Compose.</p>
			<ol>
				<li value="8">In the same package, create a file called <code>IdlingUtils</code> with the following method:<pre>fun &lt;T&gt; Flow&lt;T&gt;.attachIdling(
    countingIdlingResource:  
        ComposeCountingIdlingResource
): Flow&lt;T&gt; {
    return onStart {
        countingIdlingResource.increment()
    }.onEach {
        countingIdlingResource.decrement()
    }
}</pre></li>
			</ol>
			<p>This is <a id="_idIndexMarker708"/>an extension function that we can use to increment <code>IdlingResource</code> before <code>Flow</code> is collected and decrement it when the first value of <code>Flow</code> is being emitted.</p>
			<ol>
				<li value="9">In the <code>repository</code> package, create a class called <code>IdlingInteractionRepository</code>:<pre>class IdlingInteractionRepository(
    private val interactionRepository: InteractionRepository,
    private val countingIdlingResource: ComposeCountingIdlingResource
) : InteractionRepository {
    override fun getInteraction(): Flow&lt;Interaction&gt; {
        return interactionRepository.getInteraction()
            .attachIdling(countingIdlingResource)
    }
    override fun saveInteraction(interaction: 
        Interaction): Flow&lt;Interaction&gt; {
        return interactionRepository.
            saveInteraction(interaction)
            .attachIdling(countingIdlingResource)
    }
}</pre></li>
			</ol>
			<p>This class has a reference to the <code>ComposeCountingIdlingResource</code> object <a id="_idIndexMarker709"/>and the <code>attachIdling</code> method created previously to increment when the data is loaded or saved and to decrement when it's done performing these operations.</p>
			<ol>
				<li value="10">In the same package, create a class called <code>IdlingPostRepository</code>:<pre>class IdlingPostRepository(
    private val postRepository: PostRepository,
    private val countingIdlingResource: 
        ComposeCountingIdlingResource
) : PostRepository {
    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; =
        postRepository.getPosts().attachIdling
            (countingIdlingResource)
    override fun getPost(id: Long): Flow&lt;Post&gt; =
        postRepository.getPost(id).
            attachIdling(countingIdlingResource)
}</pre></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="11">In the <a id="_idIndexMarker710"/>same package, create a class called <code>IdlingUserRepository</code>:<pre>class IdlingUserRepository(
    private val userRepository: UserRepository,
    private val countingIdlingResource: 
        ComposeCountingIdlingResource
) : UserRepository {
    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; =
        userRepository.getUsers()
            .attachIdling(countingIdlingResource)
    override fun getUser(id: Long): Flow&lt;User&gt; =
        userRepository.getUser(id)
            .attachIdling(countingIdlingResource)
}</pre></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="12">In the <code>injection</code> package, create the <code>IdlingRepositoryModule</code> class:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
class IdlingRepositoryModule {
}</pre></li>
				<li>In the <code>IdlingRepositoryModule</code> class, provide a dependency for <code>ComposeCountingIdlingResource</code>, which will be a single instance across all the repositories:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
class IdlingRepositoryModule {
    @Singleton
    @Provides
    fun provideIdlingResource(): 
        ComposeCountingIdlingResource =
        ComposeCountingIdlingResource
            ("repository-idling")
}</pre></li>
			</ol>
			<p>In this snippet, we are providing a single instance of <code>ComposeCountingIdlingResource</code> so that when multiple repositories load data at <a id="_idIndexMarker711"/>the same time, the same counter will be used for all of them.</p>
			<ol>
				<li value="14">In the same file, provide a dependency for <code>IdlingPostRepository</code>:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
class IdlingRepositoryModule {
    …
    @Provides
    fun providePostRepository(
        remotePostDataSource: RemotePostDataSource,
        localPostDataSource: LocalPostDataSource,
        countingIdlingResource: 
            ComposeCountingIdlingResource
    ): PostRepository = IdlingPostRepository(
        PostRepositoryImpl(
            remotePostDataSource,
            localPostDataSource
        ),
        countingIdlingResource
    )
}</pre></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker712"/> are providing an instance of the <code>IdlingPostRepository</code>, which will wrap an instance of <code>PostRepositoryImpl</code> and have a reference to the <code>ComposeCountingIdlingResource</code> instance defined previously.</p>
			<ol>
				<li value="15">In the same file, provide a dependency for <code>IdlingUserRepository</code>:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
class IdlingRepositoryModule {
    …
    @Provides
    fun provideUserRepository(
        remoteUserDataSource: RemoteUserDataSource,
        localUserDataSource: LocalUserDataSource,
        countingIdlingResource: 
            ComposeCountingIdlingResource
    ): UserRepository = IdlingUserRepository(
        UserRepositoryImpl(
            remoteUserDataSource,
            localUserDataSource
        ),
        countingIdlingResource
    )
}</pre></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker713"/> are providing an instance of <code>IdlingUserRepository</code>, which will wrap an instance of <code>UserRepositoryImpl</code> and have a reference to the <code>ComposeCountingIdlingResource</code> instance defined previously.</p>
			<ol>
				<li value="16">In the same file, provide a dependency for <code>IdlingInteractionRepository</code>:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
class IdlingRepositoryModule {
    …
    @Provides
    fun provideInteractionRepository(
        interactionDataSource: 
            LocalInteractionDataSource,
        countingIdlingResource: 
            ComposeCountingIdlingResource
    ): InteractionRepository = 
       IdlingInteractionRepository(
        InteractionRepositoryImpl(
            interactionDataSource
        ),
        countingIdlingResource
    )
}</pre></li>
			</ol>
			<p>In this snippet, we are<a id="_idIndexMarker714"/> providing an instance of <code>IdlingInteractionRepository</code>, which will wrap an instance of <code>InteractionRepositoryImpl</code> and have a reference to the <code>ComposeCountingIdlingResource</code> instance defined previously.</p>
			<ol>
				<li value="17">In the <code>remote</code> package, create a class called <code>MockRemoteUserDataSource</code> and create a list of <code>User</code> objects representing<a id="_idIndexMarker715"/> the test data:<pre>class MockRemoteUserDataSource @Inject constructor() : 
    RemoteUserDataSource {
    private val users = listOf(
        User(
            id = 1L,
            name = "name1",
            username = "username1",
            email = "email1"
        ),
        User(
            id = 2L,
            name = "name2",
            username = "username2",
            email = "email2"
        )
    )
    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = flowOf
        (users)
    override fun getUser(id: Long): Flow&lt;User&gt; = 
        flowOf(users[0])
}</pre></li>
			</ol>
			<p>Here, we have created a list in which we return two users and put it into <code>Flow</code> for the <code>getUsers</code> method.</p>
			<ol>
				<li value="18">In the <a id="_idIndexMarker716"/>same package, create a class called <code>MockRemotePostDataSource</code> and create a list of <code>Post</code> objects representing the test data:<pre>class MockRemotePostDataSource @Inject constructor() : 
    RemotePostDataSource {
    private val posts = listOf(
        Post(
            id = 1L,
            userId = 1L,
            title = "title1",
            body = "body1"
        ),
        Post(
            id = 2L,
            userId = 1L,
            title = "title2",
            body = "body2"
        ),
        Post(
            id = 3L,
            userId = 2L,
            title = "title3",
            body = "body3"
        ),
        Post(
            id = 4L,
            userId = 2L,
            title = "title4",
            body = "body4"
        )
    )
    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = 
        flowOf(posts)
    override fun getPost(id: Long): Flow&lt;Post&gt; = 
        flowOf(posts[0])
}</pre></li>
			</ol>
			<p>Similar to <a id="_idIndexMarker717"/>what we did with the users, we create a list of posts and connect the first two posts to the first user and the last two posts to the second user.</p>
			<ol>
				<li value="19">In the <code>injection</code> package, create a class called <code>MockRemoteDataSourceModule</code>, which will be responsible for binding the previous two implementations to the abstractions:<pre>@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RemoteDataSourceModule::class]
)
abstract class MockRemoteDataSourceModule {
    @Binds
    abstract fun bindPostDataSource(
        postDataSourceImpl: MockRemotePostDataSource): 
            RemotePostDataSource
    @Binds
    abstract fun bindUserDataSource(userDataSourceImpl
          : MockRemoteUserDataSource): 
              RemoteUserDataSource
}</pre></li>
				<li>In the <code>test</code> package, create<a id="_idIndexMarker718"/> a class called <code>MainActivityTest</code>:<pre>@HiltAndroidTest
class MainActivityTest {
    @get:Rule(order = 0)
    var hiltAndroidRule = HiltAndroidRule(this)
    @get:Rule(order = 1)
    var composeTestRule = createAndroidComposeRule
        (MainActivity::class.java)
    @Inject
    lateinit var idlingResource: 
        ComposeCountingIdlingResource
    @Before
    fun setUp() {
        hiltAndroidRule.inject()
        composeTestRule.
            registerIdlingResource(idlingResource)
    }
    @After
    fun tearDown() {
        composeTestRule.unregisterIdlingResource
            (idlingResource)
    }
}</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker719"/>are initializing our test rules, which are for Hilt and Compose, in that exact order. Then, we inject <code>ComposeCountingIdlingResource</code> into the test class so that we can register it into the Compose test rule.</p>
			<ol>
				<li value="21">In the <code>MainActivityTest</code> class, add a test that will assert that the required data is displayed on the screen:<pre>@HiltAndroidTest
class MainActivityTest {
    …
    @Test
    fun testDisplayList() {
        composeTestRule.onNodeWithText("Total click 
            count: 0")
            .assertIsDisplayed()
        composeTestRule.onAllNodesWithText("Author: 
            name1")
            .assertCountEquals(2)
        composeTestRule.onAllNodesWithText("Author: 
            name2")
            .assertCountEquals(2)
        composeTestRule.onNodeWithText("Title: 
            title1")
            .assertIsDisplayed()
        composeTestRule.onNodeWithText("Title: 
            title2")
            .assertIsDisplayed()
        composeTestRule.onNodeWithText("Title: 
            title3")
            .assertIsDisplayed()
        composeTestRule.onNodeWithText("Title: 
            title4")
            .assertIsDisplayed()
    }
}</pre></li>
			</ol>
			<p>Here, we have added a test that asserts that the header text is displayed, the two users are <a id="_idIndexMarker720"/>displayed for each of their posts, and that each post is displayed.</p>
			<p>If we run the test, we should see the following output:</p>
			<div><div><img src="img/Figure_10.05_B18320.jpg" alt="Figure 10.5 – The test output for exercise 10.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – The test output for exercise 10.02</p>
			<p>As part of this exercise, we were able to provide mock data to the application without changing any of its existing code by changing the remote data sources and building upon existing functionality, by adding <code>IdlingResources</code> to our repositories. Both techniques were possible using dependency injection, and because of abstractions, we introduced different layers of the application when we performed dependency inversion. This makes the application's code testable and provides us with the opportunity to test different scenarios and create various types of tests to ensure the integration of different components. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we analyzed the exercises we've done in previous chapters and found potential issues with the dependencies that the modules of the application have. We looked at potential solutions for these problems. Then, we looked at a practical application of clean architecture, which is the implementation of instrumented tests, and how we can change the data sources of an application to ensure testing reliability. We looked at how we can implement instrumented tests using Jetpack Compose and Hilt to provide dependency injection, and then we applied them in an exercise in which we changed the dependencies for the tests. This serves as just one example of the benefits of clean architecture. Other benefits will come in situations where multiple flavors are used to publish similar applications and want to inject different implementations or configurations for each application we want to build. Another benefit comes when dealing with multiple platforms (such as Android and iOS), where we can define entities, use cases and repositories agnostically of the platforms using cross platform frameworks and then inject the implementations for retrieving and persisting the data for each platform.</p>
			<p>In <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, we showed how we can change an application's presentation layer without impacting other layers. In a clean application, this should be possible for the data layer as well. We saw how libraries have changed and evolved over time. When networking libraries change, we should be able to transition to new libraries without causing issues in the other modules of an application. The same principle can be applied to local storage. We should be able to change from Room to other ways of persisting data locally. A good rule of thumb for how modules should be created is to view each module as a library that can be released and imagine yourself as the end user. You should have now a good idea of how clean architecture is supposed to work, the problems it is trying to solve, and how you can apply it to an Android application. </p>
		</div>
	</body></html>