<html><head></head><body>
		<div id="_idContainer060">
			<h1 id="_idParaDest-100"><em class="italic"><a id="_idTextAnchor105"/>Chapter 10</em>: Putting It All Together</h1>
			<p>In this chapter, we will analyze what we have done so far in the previous chapters and look at different ways we can improve the layers of the application. Later, we will explore the benefit of clean architecture when we integrate instrumented testing into the application, where we will swap the data source dependencies with mock dependencies to ensure the reliability of the tests.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Inspecting module dependencies</li>
				<li>Instrumentation testing</li>
			</ul>
			<p>By the end of the chapter, you will be able to identify and remove external dependencies in the use case layer of the application to enforce the <strong class="bold">Common Closure Principle</strong> (<strong class="bold">CCP</strong>) and know how to create instrumented tests on Android with mock data sources.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter10</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3sLr0HS">https://bit.ly/3sLr0HS</a></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor107"/>Inspecting module dependencies</h1>
			<p>In this<a id="_idIndexMarker673"/> section, we will analyze the dependencies used across the different modules in the application created in the previous chapters.</p>
			<p>Following <em class="italic">Exercise 09.01 – Transitioning to MVI</em> from <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, we now have a fully functioning application split into separate modules, representing different layers. We can analyze the relationship between the different<a id="_idIndexMarker674"/> modules by looking at the <strong class="source-inline">dependencies</strong> block in the <strong class="source-inline">build.gradle</strong> file in each module and focusing in particular on the <strong class="source-inline">implementation(project(path: "{module}"))</strong> lines. If we were to draw a diagram, it would look like the following:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_10.01_B18320.jpg" alt="Figure 10.1 – A module dependency diagram for exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – A module dependency diagram for exercise 09.01</p>
			<p>In the preceding figure, we can see that the <strong class="source-inline">:domain</strong> module, which is part of the domain layer, is at the center, with the modules from the other layers having a dependency toward it. The <strong class="source-inline">:app</strong> module is responsible for assembling all of the dependencies, and this means that it will have a dependency on all the other modules. This means<a id="_idIndexMarker675"/> that we are in a good clean architecture position because we want the entities and use cases to have minimal dependencies on other components. If we continue analyzing the <strong class="source-inline">build.gradle</strong> files for each module and include the external dependencies as well, we will see additional dependencies on external libraries for each module: </p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_10.02_B18320.jpg" alt="Figure 10.2 – A module dependency diagram with external dependencies for exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – A module dependency diagram with external dependencies for exercise 09.01</p>
			<p>In <em class="italic">Figure 10.2</em>, we can see some of the relevant external dependencies our modules use. <strong class="source-inline">:data-remote</strong> uses dependencies toward Retrofit and OkHttp for networking, the <strong class="source-inline">:data-local</strong> module has dependencies toward Room and DataStore, while the presentation layer modules depend on things such as Compose, ViewModel, and the Android framework. Dependencies that were used used across the entire project were coroutines, flows, and Hilt. </p>
			<p>Having <a id="_idIndexMarker676"/>dependencies on Hilt and coroutines might pose a problem for the <strong class="source-inline">:domain</strong> and <strong class="source-inline">:data-repository</strong> modules. We want these two modules to be as stable as possible, and having external dependencies will create problems every time we update the versions for those libraries. We decided to use flows because of their threading benefits, the reactive approach, and because they were developed as an extension to the Kotlin framework. They might still pose a problem if we wanted to adapt our use cases for multiple platforms using Kotlin Multiplatform. A solution for this would be to develop a reactive plugin that would abstract the usage of flows and use this abstraction across the different modules. This would allow us to swap different reactive libraries without changing the code inside the module. While this solution would fix the problem, it comes with lots of baggage because we would need to abstract both the streams of data and the operators that the project requires from the flows framework, which would give us more code to maintain. </p>
			<p>When it comes to the Hilt dependency, we can remove the references to Hilt from the <strong class="source-inline">:domain</strong> and <strong class="source-inline">:data-repository</strong> modules and move the Hilt modules into <strong class="source-inline">:app</strong>. Another solution would be to create new Gradle modules that would be responsible for providing the necessary dependency. For example, a <strong class="source-inline">:domain-hilt</strong> module could be created, where it would have a <strong class="source-inline">@Module</strong> annotated class that would provide all of the dependencies that the <strong class="source-inline">:domain</strong> module would need to expose. This approach can be used for other modules that we wish to export into applications that use different dependency injection frameworks to avoid the dependency on Hilt in those projects.</p>
			<p>Module dependencies will increase as applications develop new features and evolve; this means we should take time and assess the dependencies used in a project. This will help us identify potential issues and whether we can scale an application properly. We should also account for external dependencies and analyze the influence they have over our project. In the following section, we will look at an exercise on how to reduce the dependencies that the domain and repository modules have on Hilt.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>Exercise 10.01 – Reduce dependencies</h2>
			<p>Modify <em class="italic">Exercise 09.01 – transitioning to MVI </em> in <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, so <a id="_idIndexMarker677"/>that the <strong class="source-inline">domain</strong> and <strong class="source-inline">data-repository</strong> modules will no longer depend on Hilt and instead provide the dependencies from those modules inside the <strong class="source-inline">app</strong> module. </p>
			<p>Before <a id="_idIndexMarker678"/>completing this exercise, you will need to do the following:</p>
			<ol>
				<li>Remove Hilt from the <strong class="source-inline">domain</strong> module.</li>
				<li>Remove the <strong class="source-inline">@Inject</strong> annotation from the <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong>, <strong class="source-inline">GetPostUseCase</strong>, <strong class="source-inline">GetUserUseCase</strong>, and <strong class="source-inline">UpdateInteractionUseCase</strong> classes.</li>
				<li>Rename the <strong class="source-inline">AppModule</strong> class <strong class="source-inline">UseCaseModule</strong> and use <strong class="source-inline">@Provides</strong> to provide dependencies to the preceding objects.</li>
				<li>Remove Hilt from the <strong class="source-inline">data-repository</strong> module and delete the use of the <strong class="source-inline">@Inject</strong> annotation.</li>
				<li>Move <strong class="source-inline">RepositoryModule</strong> from the <strong class="source-inline">data-repository</strong> module into <strong class="source-inline">app</strong> and use <strong class="source-inline">@Provides</strong> to provide the dependencies to <strong class="source-inline">PostRepository</strong>, <strong class="source-inline">UserRepository</strong>, and <strong class="source-inline">InteractionRepository</strong>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">domain</strong> module, remove the use of the <strong class="source-inline">kapt</strong> and Hilt plugins:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">}</p></li>
				<li>In the same file, delete the usages of Hilt from the <strong class="source-inline">dependencies</strong> block:<p class="source-code">dependencies {</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>Delete<a id="_idIndexMarker679"/> the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong>:<p class="source-code">class GetPostsWithUsersWithInteractionUseCase(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val postRepository: PostRepository,</p><p class="source-code">    private val userRepository: UserRepository,</p><p class="source-code">    private val interactionRepository: </p><p class="source-code">        InteractionRepository</p><p class="source-code">) : UseCase&lt;GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">    Request,</p><p class="source-code">        GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">            Response&gt;(configuration) {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Delete the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">GetPostUseCase</strong>:<p class="source-code">class GetPostUseCase(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val postRepository: PostRepository</p><p class="source-code">) : UseCase&lt;GetPostUseCase.Request, GetPostUseCase.</p><p class="source-code">    Response&gt;(configuration) {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Delete the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">GetUserUseCase</strong>:<p class="source-code">class GetUserUseCase(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val userRepository: UserRepository</p><p class="source-code">) : UseCase&lt;GetUserUseCase.Request, GetUserUseCase.</p><p class="source-code">    Response&gt;(configuration) {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Delete <a id="_idIndexMarker680"/>the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">UpdateInteractionUseCase</strong>:<p class="source-code">class UpdateInteractionUseCase(</p><p class="source-code">    configuration: Configuration,</p><p class="source-code">    private val interactionRepository: </p><p class="source-code">        InteractionRepository</p><p class="source-code">) : UseCase&lt;UpdateInteractionUseCase.Request, </p><p class="source-code">   UpdateInteractionUseCase.Response&gt;(configuration) {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the app module, rename <strong class="source-inline">AppModule</strong> <strong class="source-inline">UseCaseModule</strong>.</li>
				<li>In the app module in the <strong class="source-inline">UseCaseModule</strong> class, provide a dependency to <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class UseCaseModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun   </p><p class="source-code">    provideGetPostsWithUsersWithInteractionUseCase(</p><p class="source-code">        configuration: UseCase.Configuration,</p><p class="source-code">        postRepository: PostRepository,</p><p class="source-code">        userRepository: UserRepository,</p><p class="source-code">        interactionRepository: InteractionRepository</p><p class="source-code">    ): GetPostsWithUsersWithInteractionUseCase = </p><p class="source-code">       GetPostsWithUsersWithInteractionUseCase(</p><p class="source-code">        configuration,</p><p class="source-code">        postRepository,</p><p class="source-code">        userRepository,</p><p class="source-code">        interactionRepository</p><p class="source-code">    ) </p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker681"/>need to use <strong class="source-inline">@Provides</strong> because we are no longer in the same module, which means we should treat this as an external dependency, which needs the <strong class="source-inline">@Provides</strong> annotation, similar to how we provided the Room and Retrofit dependencies.</p>
			<ol>
				<li value="9">In the same class, provide a dependency to <strong class="source-inline">GetPostUseCase</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class UseCaseModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideGetPostUseCase(</p><p class="source-code">        configuration: UseCase.Configuration,</p><p class="source-code">        postRepository: PostRepository</p><p class="source-code">    ): GetPostUseCase = GetPostUseCase(</p><p class="source-code">        configuration,</p><p class="source-code">        postRepository</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="10">In the <a id="_idIndexMarker682"/>same class, provide a dependency to <strong class="source-inline">GetUserUseCase</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class UseCaseModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideGetUserUseCase(</p><p class="source-code">        configuration: UseCase.Configuration,</p><p class="source-code">        userRepository: UserRepository</p><p class="source-code">    ): GetUserUseCase = GetUserUseCase(</p><p class="source-code">        configuration,</p><p class="source-code">        userRepository</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="11">In the same class, provide a dependency to <strong class="source-inline">UpdateInteractionUseCase</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class UseCaseModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUpdateInteractionUseCase(</p><p class="source-code">        configuration: UseCase.Configuration,</p><p class="source-code">        interactionRepository: InteractionRepository</p><p class="source-code">    ): UpdateInteractionUseCase = </p><p class="source-code">       UpdateInteractionUseCase(</p><p class="source-code">        configuration,</p><p class="source-code">        interactionRepository</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this<a id="_idIndexMarker683"/> snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="12">In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">data-repository</strong> module, remove the use of the <strong class="source-inline">kapt</strong> and Hilt plugins:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">}</p></li>
				<li>In the same file, delete the usages of Hilt from the <strong class="source-inline">dependencies</strong> block:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>Move<a id="_idIndexMarker684"/> the <strong class="source-inline">RepositoryModule</strong> class from the injection package in the <strong class="source-inline">data-repository</strong> module into the injection package in the <strong class="source-inline">app</strong> module and make the class not abstract.</li>
				<li>Delete the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">InteractionRepositoryImpl</strong>:<p class="source-code">class InteractionRepositoryImpl(</p><p class="source-code">    private val interactionDataSource: LocalInteractionDataSource</p><p class="source-code">) : InteractionRepository {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Delete the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">PostRepositoryImpl</strong>:<p class="source-code">class PostRepositoryImpl(</p><p class="source-code">    private val remotePostDataSource: </p><p class="source-code">        RemotePostDataSource,</p><p class="source-code">    private val localPostDataSource: </p><p class="source-code">        LocalPostDataSource</p><p class="source-code">) : PostRepository {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>Delete the use of <strong class="source-inline">@Inject</strong> from <strong class="source-inline">UserRepositoryImpl</strong>:<p class="source-code">class UserRepositoryImpl(</p><p class="source-code">    private val remoteUserDataSource: </p><p class="source-code">        RemoteUserDataSource,</p><p class="source-code">    private val localUserDataSource: </p><p class="source-code">        LocalUserDataSource</p><p class="source-code">) : UserRepository {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In <a id="_idIndexMarker685"/>the <strong class="source-inline">RepositoryModule</strong> class, replace the <strong class="source-inline">bindPostRespository</strong> method with a <strong class="source-inline">@Provides</strong> method:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class RepositoryModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun providePostRepository(</p><p class="source-code">        remotePostDataSource: RemotePostDataSource,</p><p class="source-code">        localPostDataSource: LocalPostDataSource</p><p class="source-code">    ): PostRepository = PostRepositoryImpl(</p><p class="source-code">        remotePostDataSource,</p><p class="source-code">        localPostDataSource</p><p class="source-code">    )</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are no longer able to use the <strong class="source-inline">@Binds</strong> annotation because we removed the <strong class="source-inline">@Inject</strong> annotation from the <strong class="source-inline">PostRepositoryImpl</strong> class, and because it is an external dependency, we will need to use <strong class="source-inline">@Provides</strong>.</p>
			<ol>
				<li value="19">In the <a id="_idIndexMarker686"/>same file, replace the <strong class="source-inline">bindUserRepository</strong> method with a <strong class="source-inline">@Provides</strong> method:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class RepositoryModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUserRepository(</p><p class="source-code">        remoteUserDataSource: RemoteUserDataSource,</p><p class="source-code">        localUserDataSource: LocalUserDataSource</p><p class="source-code">    ): UserRepository = UserRepositoryImpl(</p><p class="source-code">        remoteUserDataSource,</p><p class="source-code">        localUserDataSource</p><p class="source-code">    )</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the same file, replace <strong class="source-inline">bindInteractionRepositorymethod</strong> with a <strong class="source-inline">@Provides</strong> method:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">abstract class RepositoryModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideInteractionRepository(</p><p class="source-code">        interactionDataSource: </p><p class="source-code">            LocalInteractionDataSource</p><p class="source-code">    ): InteractionRepository = </p><p class="source-code">       InteractionRepositoryImpl(</p><p class="source-code">        interactionDataSource</p><p class="source-code">    )</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>If we run the application, we <a id="_idIndexMarker687"/>should see the same output that we got in <em class="italic">Exercise 09.01 – Transitioning to MVI</em>:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_10.03_B18320_Merged.jpg" alt="Figure 10.3 – The output of exercise 10.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The output of exercise 10.01</p>
			<p>The project is now in a state where the <strong class="source-inline">domain</strong> and <strong class="source-inline">data-repository</strong> modules no longer depend on Hilt. This means that all the other modules that depend on these two will be less <a id="_idIndexMarker688"/>exposed to potential issues caused by updates to Hilt. It also means that in the future, if we want to change the dependency injection framework used across the application, the <strong class="source-inline">domain</strong> and <strong class="source-inline">data-repository</strong> modules will remain unaffected by the change. In the section that follows, we will look at how we can create instrumentation tests with mock data to test that the modules are well integrated and that the data being passed is processed appropriately. </p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>Instrumentation testing</h1>
			<p>In this section, we will<a id="_idIndexMarker689"/> look at how to perform instrumentation testing for an Android application and how we can take advantage of dependency injection to inject either mock data or add test-related logic without modifying the structure of an application's code.</p>
			<p>Instrumentation testing <a id="_idIndexMarker690"/>is a set of tests that are run on an Android device or emulator and is represented by the tests written in the <strong class="source-inline">androidTest</strong> directory. Just like other parts of Android development, instrumentation testing evolved across the years to improve the quality of test code and to provide the ability to create better tests and assertions. Initially, testing was done using test classes such as <strong class="source-inline">ActivityTestCase</strong>, <strong class="source-inline">ContentProviderTestCase</strong>, and <strong class="source-inline">ServiceTestCase</strong>, which were mainly used to test individual components of an application in isolation. The addition of the Espresso testing libraries allows us to easily test multiple activities as part of the journey a user would undertake. </p>
			<p>In order to add Espresso and the associated libraries into a project, the following will need to be added to any module's <strong class="source-inline">build.gradle</strong> file:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    androidTestImplementation "androidx.test:core:1.4.0"</p>
			<p class="source-code">    androidTestImplementation "androidx.test:runner:1.4.0 "</p>
			<p class="source-code">    androidTestImplementation "androidx.test:rules:1.4.0 "</p>
			<p class="source-code">    androidTestImplementation </p>
			<p class="source-code">        "androidx.test.ext:junit:1.1.3 "</p>
			<p class="source-code">    androidTestImplementation </p>
			<p class="source-code">        "androidx.test.espresso:espresso-core:3.4.0 "</p>
			<p class="source-code">    androidTestImplementation "androidx.test.espresso.</p>
			<p class="source-code">        idling:idling-concurrent:3.4.0 "</p>
			<p class="source-code">}</p>
			<p>The following<a id="_idIndexMarker691"/> is an example of a test written using Espresso:</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    fun myTest(){</p>
			<p class="source-code">        ActivityScenario.launch(MainActivity::class.java).</p>
			<p class="source-code">            moveToState(Lifecycle.State.RESUMED)</p>
			<p class="source-code">        onView(withId(R.id.my_id))</p>
			<p class="source-code">            .perform(click())</p>
			<p class="source-code">            .check(isDisplayed())</p>
			<p class="source-code">    }</p>
			<p>In the preceding example, we use the <strong class="source-inline">ActivityScenario</strong> launch method to start <strong class="source-inline">MainActivity</strong> and transition <strong class="source-inline">Activity</strong> to the <strong class="source-inline">RESUMED</strong> state. We then use <strong class="source-inline">onView</strong>, which requires <strong class="source-inline">ViewMatcher</strong>, and <strong class="source-inline">withId</strong> looks up <strong class="source-inline">View</strong> by its ID and returns <strong class="source-inline">ViewMatcher</strong> holding that information. We then have the option to use <strong class="source-inline">perform</strong>, which requires <strong class="source-inline">ViewAction</strong>. This is for when we want to interact with certain views. We can also perform <strong class="source-inline">ViewAssertion</strong> using the <strong class="source-inline">check</strong> method. In this case, we are checking whether a view is displayed. </p>
			<p>Another useful addition to help with testing is the orchestrator. The orchestrator is useful when we want to delete the data generated by the tests that might be kept in memory or persisted on the device and that in turn might impact other tests and cause them to malfunction. What the orchestrator does is uninstall the application before each executed test so that every test will be on a freshly installed app. In order to add the orchestrator to the application, you will need to add it to the module's <strong class="source-inline">build.gradle</strong> file:</p>
			<p class="source-code">android {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    defaultConfig {</p>
			<p class="source-code">        …</p>
			<p class="source-code">        testInstrumentationRunnerArguments </p>
			<p class="source-code">            clearPackageData: 'true'</p>
			<p class="source-code">        testOptions {</p>
			<p class="source-code">            execution 'ANDROIDX_TEST_ORCHESTRATOR'</p>
			<p class="source-code">        }</p>
			<p class="source-code">        …</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This will add the<a id="_idIndexMarker692"/> orchestrator configuration into the test execution and pass the instruction to delete the application data after each test. To add the orchestrator dependency into the project, the following is required:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    androidTestUtil "androidx.test:orchestrator: 1.4.1"</p>
			<p class="source-code">}</p>
			<p>Espresso also comes with many extensions, one of which is the concept of <strong class="source-inline">IdlingResource</strong>. When both local tests (tests that are run on the development machine) and instrumented tests are run, they are run on a dedicated set of threads for testing. The Espresso testing library will monitor the main thread of the application, and when it is idle, it will make the assertions required. If the application uses background threads, Espresso will need a way to be informed by this. We can use <strong class="source-inline">IdlingResource</strong> to indicate to Espresso wait for an action to complete before continuing its execution. An example of <strong class="source-inline">IdlingResource</strong> is <strong class="source-inline">CountingIdlingResource</strong>, which will hold a counter for each operation Espresso will need to wait for. The counter is incremented before each long-running operation and then decremented after the operation is completed. Before each test, <strong class="source-inline">IdlingResource</strong> will<a id="_idIndexMarker693"/> need to be registered and then unregistered when the test finishes:</p>
			<p class="source-code">class MyClass(private val countingIdlingResource: </p>
			<p class="source-code">    CountingIdlingResource) {</p>
			<p class="source-code">    fun doOperation() {</p>
			<p class="source-code">        countingIdlingResource.increment()</p>
			<p class="source-code">        // Perform long running operation</p>
			<p class="source-code">        countingIdlingResource.decrement()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have <strong class="source-inline">CountingIdlingResource</strong> being incremented at the beginning of the <strong class="source-inline">doOperation</strong> method and decremented after the long operation we intend to perform. To register and unregister <strong class="source-inline">IdlingResource</strong>, we can perform the following:</p>
			<p class="source-code">    lateinit var countingIdlingResource : CountingIdlingResource</p>
			<p class="source-code">    @Before</p>
			<p class="source-code">    fun setUp(){</p>
			<p class="source-code">        IdlingRegistry.getInstance().register</p>
			<p class="source-code">            (countingIdlingResource)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @After</p>
			<p class="source-code">    fun tearDown(){</p>
			<p class="source-code">        IdlingRegistry.getInstance().</p>
			<p class="source-code">            unregister(countingIdlingResource)</p>
			<p class="source-code">    }</p>
			<p>In this<a id="_idIndexMarker694"/> example, we register <strong class="source-inline">IdlingResource</strong> in the <strong class="source-inline">setUp</strong> method, which is called before each test because of the <strong class="source-inline">@Before</strong> annotation, and unregister it in the <strong class="source-inline">tearDown</strong> method, which is called after each test because of the <strong class="source-inline">@After</strong> annotation. </p>
			<p>Because <strong class="source-inline">IdlingResource</strong> is a part of Espresso but needs to be used when operations inside the application's code are executed, we want to avoid using <strong class="source-inline">IdlingResource</strong> alongside that code. A solution for this is to decorate the class that contains the operation and then use dependency injection to inject the decorated dependency into the test. To decorate the code, we will need to have an abstraction for the operation. An example of this is as follows:</p>
			<p class="source-code">interface MyInterface {</p>
			<p class="source-code">    fun doOperation()</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass : MyInterface {</p>
			<p class="source-code">    override fun doOperation() {</p>
			<p class="source-code">        // Implement long running operation</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have created an interface that defines the <strong class="source-inline">doOperation</strong> method, and then we implement the interface with the long-running operation into a class. We can now create a class that will belong to the <strong class="source-inline">androidTest</strong> folder, which<a id="_idIndexMarker695"/> will decorate the current implementation of the class:</p>
			<p class="source-code">class MyDecoratedClass(</p>
			<p class="source-code">    private val myInterface: MyInterface,</p>
			<p class="source-code">    private val countingIdlingResource: </p>
			<p class="source-code">        CountingIdlingResource</p>
			<p class="source-code">) : MyInterface {</p>
			<p class="source-code">    override fun doOperation() {</p>
			<p class="source-code">        countingIdlingResource.increment()</p>
			<p class="source-code">        myInterface.doOperation()</p>
			<p class="source-code">        countingIdlingResource.decrement()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we have another implementation of <strong class="source-inline">MyInterface</strong>, which will hold a reference to the abstraction and <strong class="source-inline">CountingIdlingResource</strong>. When <strong class="source-inline">doOperation</strong> is called, we will increment <strong class="source-inline">IdlingResource</strong>, call the operation, and then, when it's done, decrement <strong class="source-inline">IdlingResource</strong>.</p>
			<p>If we want to inject the new dependency into the test, we will need first to define a new class that extends <strong class="source-inline">Application</strong>, which will hold the dependency graph containing the test dependencies. If we are using Hilt, it already provides such a class in the form of <strong class="source-inline">HiltTestApplication</strong>. If we want to integrate Hilt into the instrumented tests, we will need the following dependencies to be added to the module's <strong class="source-inline">build.gradle</strong> file:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    androidTestImplementation "com.google.dagger:hilt-</p>
			<p class="source-code">        android-testing:2.40.5"</p>
			<p class="source-code">    kaptAndroidTest "com.google.dagger:hilt-android-</p>
			<p class="source-code">        compiler: 2.40.5"</p>
			<p class="source-code">}</p>
			<p>To <a id="_idIndexMarker696"/>provide the <strong class="source-inline">HiltTestApplication</strong> class to the test, we will need to change the instrumented test runner. An example of a new test runner will look like the following:</p>
			<p class="source-code">class MyTestRunner : AndroidJUnitRunner() {</p>
			<p class="source-code">    override fun newApplication(cl: ClassLoader?, name: </p>
			<p class="source-code">        String?, context: Context?): Application {</p>
			<p class="source-code">        return super.newApplication(cl, </p>
			<p class="source-code">            <strong class="bold">HiltTestApplication</strong>::class.java.name, context)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we are extending from <strong class="source-inline">AndroidJUnitRunner</strong>, and in the <strong class="source-inline">newApplication</strong> method, we invoke the <strong class="source-inline">super</strong> method, and we pass <strong class="source-inline">HiltTestApplication</strong> as the <strong class="source-inline">name</strong>. This means that when the test is executed, <strong class="source-inline">HiltTestApplication</strong> will be used instead of the <strong class="source-inline">Application</strong> class we defined in our main code. We will now need to change the configuration in the module's <strong class="source-inline">build.gradle</strong> file to use the preceding runner:</p>
			<p class="source-code">android {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    defaultConfig {</p>
			<p class="source-code">        …</p>
			<p class="source-code">        testInstrumentationRunner "com.test.MyTestRunner"</p>
			<p class="source-code">        …</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This allows the instrumented test to use the runner we have created. Let's now assume that we have <a id="_idIndexMarker697"/>the following module, which will provide the initial dependency:</p>
			<p class="source-code">@Module</p>
			<p class="source-code">@InstallIn(SingletonComponent::class)</p>
			<p class="source-code">abstract class MyModule {</p>
			<p class="source-code">    @Binds</p>
			<p class="source-code">    abstract fun bindMyClass(myClass: MyClass): MyInterface</p>
			<p class="source-code">}</p>
			<p>Here, we are using a simple binding to connect an implementation to the abstraction. In the <strong class="source-inline">androidTest</strong> folder, we can create a new module in which we replace this instance with the decorated one:</p>
			<p class="source-code">@Module</p>
			<p class="source-code">@TestInstallIn(</p>
			<p class="source-code">    components = [SingletonComponent::class],</p>
			<p class="source-code">    replaces = [MyModule::class]</p>
			<p class="source-code">)</p>
			<p class="source-code">class MyDecoratedModule {</p>
			<p class="source-code">    @Provides</p>
			<p class="source-code">    fun provideIdlingResource() = </p>
			<p class="source-code">        CountingIdlingResource("my-idling-resource")</p>
			<p class="source-code">    @Provides</p>
			<p class="source-code">    fun provideMyDecoratedClass(countingIdlingResource:  </p>
			<p class="source-code">        CountingIdlingResource) =</p>
			<p class="source-code">        MyDecoratedClass(MyClass(), countingIdlingResource)</p>
			<p class="source-code">}</p>
			<p>In this<a id="_idIndexMarker698"/> example, we use the <strong class="source-inline">@TestInstallIn</strong> annotation, which will make the dependencies in this module live as long as the test application and replace the dependencies in the previous module. We can then provide dependencies for <strong class="source-inline">IdlingResource</strong> and <strong class="source-inline">MyDecoratedClass</strong>, which will wrap <strong class="source-inline">MyClass</strong> and use <strong class="source-inline">IdlingResource</strong>. If we want these changes to take effect in the tests, we will need the following changes: </p>
			<p class="source-code">@HiltAndroidTest</p>
			<p class="source-code">class MyActivityTest {</p>
			<p class="source-code">    @get:Rule(order = 0)</p>
			<p class="source-code">    var hiltAndroidRule = HiltAndroidRule(this)</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    lateinit var idlingResource: CountingIdlingResources</p>
			<p class="source-code">    @Before</p>
			<p class="source-code">    fun setUp(){</p>
			<p class="source-code">        hiltAndroidRule.inject()</p>
			<p class="source-code">        IdlingRegistry.getInstance().register</p>
			<p class="source-code">            (idlingResource)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @After</p>
			<p class="source-code">    fun tearDown(){</p>
			<p class="source-code">       IdlingRegistry.getInstance().unregister</p>
			<p class="source-code">           (idlingResource)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this <a id="_idIndexMarker699"/>example, we have used the <strong class="source-inline">@HiltAndroidTest</strong> annotation because we want to inject <strong class="source-inline">CountingIdlingResources</strong> into the test. We then used <strong class="source-inline">HiltAndroidTestRule</strong> to perform the injection. We also gave it the highest priority in terms of the order of execution for test rules. Finally, we were able to register and unregister <strong class="source-inline">CountingIdlingResources</strong> for each test in the class.</p>
			<p>Jetpack Compose comes with its own testing libraries, which require the following configuration to the module's <strong class="source-inline">build.gradle</strong> file:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">    androidTestImplementation "androidx.compose.ui:ui-test-</p>
			<p class="source-code">        junit4:1.0.5"</p>
			<p class="source-code">    debugImplementation "androidx.compose.ui:ui-test-</p>
			<p class="source-code">        manifest:1.0.5"</p>
			<p class="source-code">}</p>
			<p>To write tests for Jetpack Compose components, we will need to define a Compose test rule using <strong class="source-inline">createComposeRule</strong> when we want to test individual composable methods, or <strong class="source-inline">createAndroidComposeRule</strong> if we want to test the Compose content of an entire activity. An example would look like the following:</p>
			<p class="source-code">class MyTest {</p>
			<p class="source-code">    @get:Rule</p>
			<p class="source-code">    var composeTestRule = createAndroidComposeRule</p>
			<p class="source-code">        (MyActivity::class.java)</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker700"/>preceding example, we have defined a test rule that will be responsible for testing the Compose content inside <strong class="source-inline">MyActivity</strong>. If we want the test to interact with the user interface or assert that it displays the correct information, we have the following structure:</p>
			<p class="source-code">    @Test</p>
			<p class="source-code">    fun testDisplayList() {</p>
			<p class="source-code">        composeTestRule.onNode()</p>
			<p class="source-code">            .assertIsDisplayed()</p>
			<p class="source-code">            .performClick()</p>
			<p class="source-code">    }</p>
			<p>In this example we use the <strong class="source-inline">onNode</strong> method to locate a particular element, such as <strong class="source-inline">Text</strong> or <strong class="source-inline">Button</strong>. We then have the <strong class="source-inline">assertIsDisplayed</strong> method, which is used to check whether the node is displayed. Finally, we have the <strong class="source-inline">performClick</strong> method, which will click on the element. Jetpack Compose uses its own <strong class="source-inline">IdlingResource</strong> type, which can be registered in the Compose test rule, similar to the following example:</p>
			<p class="source-code">    lateinit var idlingResource: IdlingResource</p>
			<p class="source-code">    @Before</p>
			<p class="source-code">    fun setUp() {</p>
			<p class="source-code">        composeTestRule.registerIdlingResource</p>
			<p class="source-code">            (idlingResource)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @After</p>
			<p class="source-code">    fun tearDown() {</p>
			<p class="source-code">        composeTestRule.unregisterIdlingResource</p>
			<p class="source-code">            (idlingResource)</p>
			<p class="source-code">    }</p>
			<p>From a <a id="_idIndexMarker701"/>clean architecture perspective, we should strive to make our application's code as testable as possible. This applies to both local tests such as unit tests and instrumented tests. We want to be able to ensure that the tests are reliable; this usually means that we will need to remove the dependency on network calls, which means we will need to provide a way to inject mock data into the application without modifying the application's code. We also need to be able to either inject <strong class="source-inline">IdlingResources</strong> into the application or use decorated dependencies to verify that the data inserted by the user is the correct data received in the data layer. This also involves the ability to decorate these dependencies to add extra logic without modifying the application's code. In the following section, we will look at an exercise in which we will inject various dependencies containing testing logic into the application and assess the difficulty it takes to introduce them.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Exercise 10.02 – Instrumented testing</h2>
			<p>Add one instrumented test to <em class="italic">Exercise 10.01 – Reduce dependencies</em>, which will assert that the following data is displayed onscreen:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_10.04_B18320.jpg" alt="Figure 10.4 – The expected output of exercise 10.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The expected output of exercise 10.02</p>
			<p>To achieve this, you <a id="_idIndexMarker702"/>will need to create a new implementation of <strong class="source-inline">RemotePostDataSource</strong>, which will return a list of four posts; two posts will belong to one user and the other two will belong to another user. The same thing will need to be done for <strong class="source-inline">RemoteUserDataSource</strong>, which will return the two users. These implementations will need to be injected into the test. To ensure that the test will wait for the background work to complete, you will need to decorate each repository with  <strong class="source-inline">IdlingResource</strong>, which will also need to be injected into the test.</p>
			<p>Before completing <a id="_idIndexMarker703"/>this exercise, you will need to do the following:</p>
			<ol>
				<li value="1">Integrate the testing libraries into the app module.</li>
				<li>Create <strong class="source-inline">PostAppTestRunner</strong>, which will be used to provide <strong class="source-inline">HiltTestApplication</strong> to the Android instrumentation test runner.</li>
				<li>Create a <strong class="source-inline">ComposeCountingIdlingResource</strong> class, which will wrap an Espresso <strong class="source-inline">CountingIndlingResource</strong> and implement the Compose <strong class="source-inline">IdlingResource</strong>.</li>
				<li>Create <strong class="source-inline">MockRemotePostDataSource</strong> and <strong class="source-inline">MockRemoteUserDataSource</strong>, which will be responsible for returning the users and posts in presented in <em class="italic">Figure 10.4</em>.</li>
				<li>Create <strong class="source-inline">IdlingInteractionRepository</strong>, <strong class="source-inline">IdlingUserRepository</strong>, and <strong class="source-inline">IdlingPostRespository</strong>, which will decorate <strong class="source-inline">InteractionRepository</strong>, <strong class="source-inline">UserRepository</strong>, and <strong class="source-inline">PostRepository</strong>, and use the <strong class="source-inline">ComposeCountingIdlingResource</strong>, which will be incremented when new data is loaded and decremented when data loading is done.</li>
				<li>Create <strong class="source-inline">IdlingRepositoryModule</strong> and <strong class="source-inline">MockRemoteDataSourceModule</strong>, which will replace <strong class="source-inline">RepositoryModule</strong> and <strong class="source-inline">RemoteDataSourceModule</strong> respectively in the tests.</li>
				<li>Create <strong class="source-inline">MainActivityTest</strong>, which will have one test, and use <strong class="source-inline">createAndroidComposeRule</strong> to assert that the list of mock data is displayed.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the top-level <strong class="source-inline">build.gradle</strong> file, add the following library versions:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        versions = [</p><p class="source-code">                …</p><p class="source-code">                androidTestCore      : "1.4.0",</p><p class="source-code">                androidTestJunit     : "1.1.3",</p><p class="source-code">                orchestrator         : "1.4.1"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">}</p></li>
				<li>In the same file, make <a id="_idIndexMarker704"/>sure that the following <strong class="source-inline">androidTest</strong> dependencies are added:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">       …</p><p class="source-code">        androidTest = [</p><p class="source-code">                junit             : "androidx.test.ext</p><p class="source-code">                    :junit:${versions.espressoJunit}",</p><p class="source-code">                espressoCore      : "androidx.test.</p><p class="source-code">                    espresso:espresso-core:${versions.</p><p class="source-code">                        espressoCore}",</p><p class="source-code">                idlingResource    : "androidx.test.</p><p class="source-code">                    espresso:espresso-idling-resource</p><p class="source-code">                        :${versions.espressoCore}",</p><p class="source-code">                composeUiTestJunit: "androidx.compose.</p><p class="source-code">                    ui:ui-test-junit4:$</p><p class="source-code">                        {versions.compose}",</p><p class="source-code">                composeManifest   : "androidx.compose</p><p class="source-code">                    .ui:ui-test-manifest:$</p><p class="source-code">                        {versions.compose}",</p><p class="source-code">                hilt              : "com.google.</p><p class="source-code">                    dagger:hilt-android-testing:$</p><p class="source-code">                        {versions.hilt}",</p><p class="source-code">                hiltCompiler      : "com.google.</p><p class="source-code">                     dagger:hilt-android-compiler:$</p><p class="source-code">                        {versions.hilt}",</p><p class="source-code">                core              : "androidx.test:</p><p class="source-code">                    core:${versions.androidTestCore}",</p><p class="source-code">                runner            : "androidx.test:</p><p class="source-code">                    runner:$</p><p class="source-code">                        {versions.androidTestCore}",</p><p class="source-code">                rules             : "androidx.test:</p><p class="source-code">                   rules:${versions.androidTestCore}",</p><p class="source-code">                orchestrator      : "androidx.test:</p><p class="source-code">                    orchestrator:$</p><p class="source-code">                        {versions.orchestrator}"</p><p class="source-code">        ]</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are defining the mappings for all the testing libraries we will be using so that they will be available across multiple modules.</p>
			<ol>
				<li value="3">In the <strong class="source-inline">build.gradle</strong> file of <a id="_idIndexMarker705"/>the app module, add the required test dependencies:<p class="source-code">dependencies{</p><p class="source-code">    …</p><p class="source-code">    androidTestImplementation androidTest.junit</p><p class="source-code">    androidTestImplementation androidTest.espressoCore</p><p class="source-code">    androidTestImplementation </p><p class="source-code">        androidTest.idlingResource</p><p class="source-code">    androidTestImplementation androidTest.core</p><p class="source-code">    androidTestImplementation androidTest.rules</p><p class="source-code">    androidTestImplementation androidTest.runner</p><p class="source-code">    androidTestImplementation androidTest.hilt</p><p class="source-code">    kaptAndroidTest androidTest.hiltCompiler</p><p class="source-code">    androidTestImplementation </p><p class="source-code">        androidTest.composeUiTestJunit</p><p class="source-code">    debugImplementation androidTest.composeManifest</p><p class="source-code">    androidTestUtil androidTest.orchestrator</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">androidTest</strong> folder of the app module, create the <strong class="source-inline">PostAppTestRunner</strong> class inside the <strong class="source-inline">java/{package-name}</strong> folder:<p class="source-code">class PostAppTestRunner : AndroidJUnitRunner() {</p><p class="source-code">    override fun newApplication(cl: ClassLoader?, </p><p class="source-code">        name: String?, context: Context?): Application {</p><p class="source-code">        return super.newApplication(cl, </p><p class="source-code">            HiltTestApplication::class.java.name, </p><p class="source-code">                context)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">build.gradle</strong> file of the app module, set the following test configuration. Make <a id="_idIndexMarker706"/>sure to replace <strong class="source-inline">{package-name}</strong> with the package that the <strong class="source-inline">PostAppTestRunner</strong> is in:<p class="source-code">android {</p><p class="source-code">    …</p><p class="source-code">    defaultConfig {</p><p class="source-code">        …</p><p class="source-code">        testInstrumentationRunner "{package-name}.</p><p class="source-code">            PostAppTestRunner"</p><p class="source-code">        testInstrumentationRunnerArguments </p><p class="source-code">            clearPackageData: 'true'</p><p class="source-code">        testOptions {</p><p class="source-code">            execution 'ANDROIDX_TEST_ORCHESTRATOR'</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">androidTest</strong> folder of the app module, create the following packages inside the <strong class="source-inline">java/{package-name}</strong> folder – <strong class="source-inline">idling</strong>, <strong class="source-inline">injection</strong>, <strong class="source-inline">remote</strong>, <strong class="source-inline">repository</strong>, and <strong class="source-inline">test</strong>.</li>
				<li>Inside<a id="_idIndexMarker707"/> the <strong class="source-inline">idling</strong> package, create a new class called <strong class="source-inline">ComposeCountingIdlingResource</strong>:<p class="source-code">class ComposeCountingIdlingResource(name: String) : </p><p class="source-code">    IdlingResource {</p><p class="source-code">    private val countingIdlingResource = </p><p class="source-code">        CountingIdlingResource(name)</p><p class="source-code">    override val isIdleNow: Boolean</p><p class="source-code">        get() = countingIdlingResource.isIdleNow</p><p class="source-code">    fun increment() = countingIdlingResource.</p><p class="source-code">        increment()</p><p class="source-code">    fun decrement() = countingIdlingResource.</p><p class="source-code">        decrement()</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have used the <strong class="source-inline">CountingIdlingResource</strong> class from Espresso to perform the logic for incrementing, decrementing, and providing its current idling state through the <strong class="source-inline">isIdleNow</strong> method, which is used by Jetpack Compose.</p>
			<ol>
				<li value="8">In the same package, create a file called <strong class="source-inline">IdlingUtils</strong> with the following method:<p class="source-code">fun &lt;T&gt; Flow&lt;T&gt;.attachIdling(</p><p class="source-code">    countingIdlingResource:  </p><p class="source-code">        ComposeCountingIdlingResource</p><p class="source-code">): Flow&lt;T&gt; {</p><p class="source-code">    return onStart {</p><p class="source-code">        countingIdlingResource.increment()</p><p class="source-code">    }.onEach {</p><p class="source-code">        countingIdlingResource.decrement()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This is <a id="_idIndexMarker708"/>an extension function that we can use to increment <strong class="source-inline">IdlingResource</strong> before <strong class="source-inline">Flow</strong> is collected and decrement it when the first value of <strong class="source-inline">Flow</strong> is being emitted.</p>
			<ol>
				<li value="9">In the <strong class="source-inline">repository</strong> package, create a class called <strong class="source-inline">IdlingInteractionRepository</strong>:<p class="source-code">class IdlingInteractionRepository(</p><p class="source-code">    private val interactionRepository: InteractionRepository,</p><p class="source-code">    private val countingIdlingResource: ComposeCountingIdlingResource</p><p class="source-code">) : InteractionRepository {</p><p class="source-code">    override fun getInteraction(): Flow&lt;Interaction&gt; {</p><p class="source-code">        return interactionRepository.getInteraction()</p><p class="source-code">            .attachIdling(countingIdlingResource)</p><p class="source-code">    }</p><p class="source-code">    override fun saveInteraction(interaction: </p><p class="source-code">        Interaction): Flow&lt;Interaction&gt; {</p><p class="source-code">        return interactionRepository.</p><p class="source-code">            saveInteraction(interaction)</p><p class="source-code">            .attachIdling(countingIdlingResource)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class has a reference to the <strong class="source-inline">ComposeCountingIdlingResource</strong> object <a id="_idIndexMarker709"/>and the <strong class="source-inline">attachIdling</strong> method created previously to increment when the data is loaded or saved and to decrement when it's done performing these operations.</p>
			<ol>
				<li value="10">In the same package, create a class called <strong class="source-inline">IdlingPostRepository</strong>:<p class="source-code">class IdlingPostRepository(</p><p class="source-code">    private val postRepository: PostRepository,</p><p class="source-code">    private val countingIdlingResource: </p><p class="source-code">        ComposeCountingIdlingResource</p><p class="source-code">) : PostRepository {</p><p class="source-code">    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; =</p><p class="source-code">        postRepository.getPosts().attachIdling</p><p class="source-code">            (countingIdlingResource)</p><p class="source-code">    override fun getPost(id: Long): Flow&lt;Post&gt; =</p><p class="source-code">        postRepository.getPost(id).</p><p class="source-code">            attachIdling(countingIdlingResource)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="11">In the <a id="_idIndexMarker710"/>same package, create a class called <strong class="source-inline">IdlingUserRepository</strong>:<p class="source-code">class IdlingUserRepository(</p><p class="source-code">    private val userRepository: UserRepository,</p><p class="source-code">    private val countingIdlingResource: </p><p class="source-code">        ComposeCountingIdlingResource</p><p class="source-code">) : UserRepository {</p><p class="source-code">    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; =</p><p class="source-code">        userRepository.getUsers()</p><p class="source-code">            .attachIdling(countingIdlingResource)</p><p class="source-code">    override fun getUser(id: Long): Flow&lt;User&gt; =</p><p class="source-code">        userRepository.getUser(id)</p><p class="source-code">            .attachIdling(countingIdlingResource)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we follow the approach of the previous step.</p>
			<ol>
				<li value="12">In the <strong class="source-inline">injection</strong> package, create the <strong class="source-inline">IdlingRepositoryModule</strong> class:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RepositoryModule::class]</p><p class="source-code">)</p><p class="source-code">class IdlingRepositoryModule {</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">IdlingRepositoryModule</strong> class, provide a dependency for <strong class="source-inline">ComposeCountingIdlingResource</strong>, which will be a single instance across all the repositories:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RepositoryModule::class]</p><p class="source-code">)</p><p class="source-code">class IdlingRepositoryModule {</p><p class="source-code">    @Singleton</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideIdlingResource(): </p><p class="source-code">        ComposeCountingIdlingResource =</p><p class="source-code">        ComposeCountingIdlingResource</p><p class="source-code">            ("repository-idling")</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are providing a single instance of <strong class="source-inline">ComposeCountingIdlingResource</strong> so that when multiple repositories load data at <a id="_idIndexMarker711"/>the same time, the same counter will be used for all of them.</p>
			<ol>
				<li value="14">In the same file, provide a dependency for <strong class="source-inline">IdlingPostRepository</strong>:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RepositoryModule::class]</p><p class="source-code">)</p><p class="source-code">class IdlingRepositoryModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun providePostRepository(</p><p class="source-code">        remotePostDataSource: RemotePostDataSource,</p><p class="source-code">        localPostDataSource: LocalPostDataSource,</p><p class="source-code">        countingIdlingResource: </p><p class="source-code">            ComposeCountingIdlingResource</p><p class="source-code">    ): PostRepository = IdlingPostRepository(</p><p class="source-code">        PostRepositoryImpl(</p><p class="source-code">            remotePostDataSource,</p><p class="source-code">            localPostDataSource</p><p class="source-code">        ),</p><p class="source-code">        countingIdlingResource</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker712"/> are providing an instance of the <strong class="source-inline">IdlingPostRepository</strong>, which will wrap an instance of <strong class="source-inline">PostRepositoryImpl</strong> and have a reference to the <strong class="source-inline">ComposeCountingIdlingResource</strong> instance defined previously.</p>
			<ol>
				<li value="15">In the same file, provide a dependency for <strong class="source-inline">IdlingUserRepository</strong>:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RepositoryModule::class]</p><p class="source-code">)</p><p class="source-code">class IdlingRepositoryModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUserRepository(</p><p class="source-code">        remoteUserDataSource: RemoteUserDataSource,</p><p class="source-code">        localUserDataSource: LocalUserDataSource,</p><p class="source-code">        countingIdlingResource: </p><p class="source-code">            ComposeCountingIdlingResource</p><p class="source-code">    ): UserRepository = IdlingUserRepository(</p><p class="source-code">        UserRepositoryImpl(</p><p class="source-code">            remoteUserDataSource,</p><p class="source-code">            localUserDataSource</p><p class="source-code">        ),</p><p class="source-code">        countingIdlingResource</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker713"/> are providing an instance of <strong class="source-inline">IdlingUserRepository</strong>, which will wrap an instance of <strong class="source-inline">UserRepositoryImpl</strong> and have a reference to the <strong class="source-inline">ComposeCountingIdlingResource</strong> instance defined previously.</p>
			<ol>
				<li value="16">In the same file, provide a dependency for <strong class="source-inline">IdlingInteractionRepository</strong>:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RepositoryModule::class]</p><p class="source-code">)</p><p class="source-code">class IdlingRepositoryModule {</p><p class="source-code">    …</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideInteractionRepository(</p><p class="source-code">        interactionDataSource: </p><p class="source-code">            LocalInteractionDataSource,</p><p class="source-code">        countingIdlingResource: </p><p class="source-code">            ComposeCountingIdlingResource</p><p class="source-code">    ): InteractionRepository = </p><p class="source-code">       IdlingInteractionRepository(</p><p class="source-code">        InteractionRepositoryImpl(</p><p class="source-code">            interactionDataSource</p><p class="source-code">        ),</p><p class="source-code">        countingIdlingResource</p><p class="source-code">    )</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are<a id="_idIndexMarker714"/> providing an instance of <strong class="source-inline">IdlingInteractionRepository</strong>, which will wrap an instance of <strong class="source-inline">InteractionRepositoryImpl</strong> and have a reference to the <strong class="source-inline">ComposeCountingIdlingResource</strong> instance defined previously.</p>
			<ol>
				<li value="17">In the <strong class="source-inline">remote</strong> package, create a class called <strong class="source-inline">MockRemoteUserDataSource</strong> and create a list of <strong class="source-inline">User</strong> objects representing<a id="_idIndexMarker715"/> the test data:<p class="source-code">class MockRemoteUserDataSource @Inject constructor() : </p><p class="source-code">    RemoteUserDataSource {</p><p class="source-code">    private val users = listOf(</p><p class="source-code">        User(</p><p class="source-code">            id = 1L,</p><p class="source-code">            name = "name1",</p><p class="source-code">            username = "username1",</p><p class="source-code">            email = "email1"</p><p class="source-code">        ),</p><p class="source-code">        User(</p><p class="source-code">            id = 2L,</p><p class="source-code">            name = "name2",</p><p class="source-code">            username = "username2",</p><p class="source-code">            email = "email2"</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">    override fun getUsers(): Flow&lt;List&lt;User&gt;&gt; = flowOf</p><p class="source-code">        (users)</p><p class="source-code">    override fun getUser(id: Long): Flow&lt;User&gt; = </p><p class="source-code">        flowOf(users[0])</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have created a list in which we return two users and put it into <strong class="source-inline">Flow</strong> for the <strong class="source-inline">getUsers</strong> method.</p>
			<ol>
				<li value="18">In the <a id="_idIndexMarker716"/>same package, create a class called <strong class="source-inline">MockRemotePostDataSource</strong> and create a list of <strong class="source-inline">Post</strong> objects representing the test data:<p class="source-code">class MockRemotePostDataSource @Inject constructor() : </p><p class="source-code">    RemotePostDataSource {</p><p class="source-code">    private val posts = listOf(</p><p class="source-code">        Post(</p><p class="source-code">            id = 1L,</p><p class="source-code">            userId = 1L,</p><p class="source-code">            title = "title1",</p><p class="source-code">            body = "body1"</p><p class="source-code">        ),</p><p class="source-code">        Post(</p><p class="source-code">            id = 2L,</p><p class="source-code">            userId = 1L,</p><p class="source-code">            title = "title2",</p><p class="source-code">            body = "body2"</p><p class="source-code">        ),</p><p class="source-code">        Post(</p><p class="source-code">            id = 3L,</p><p class="source-code">            userId = 2L,</p><p class="source-code">            title = "title3",</p><p class="source-code">            body = "body3"</p><p class="source-code">        ),</p><p class="source-code">        Post(</p><p class="source-code">            id = 4L,</p><p class="source-code">            userId = 2L,</p><p class="source-code">            title = "title4",</p><p class="source-code">            body = "body4"</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">    override fun getPosts(): Flow&lt;List&lt;Post&gt;&gt; = </p><p class="source-code">        flowOf(posts)</p><p class="source-code">    override fun getPost(id: Long): Flow&lt;Post&gt; = </p><p class="source-code">        flowOf(posts[0])</p><p class="source-code">}</p></li>
			</ol>
			<p>Similar to <a id="_idIndexMarker717"/>what we did with the users, we create a list of posts and connect the first two posts to the first user and the last two posts to the second user.</p>
			<ol>
				<li value="19">In the <strong class="source-inline">injection</strong> package, create a class called <strong class="source-inline">MockRemoteDataSourceModule</strong>, which will be responsible for binding the previous two implementations to the abstractions:<p class="source-code">@Module</p><p class="source-code">@TestInstallIn(</p><p class="source-code">    components = [SingletonComponent::class],</p><p class="source-code">    replaces = [RemoteDataSourceModule::class]</p><p class="source-code">)</p><p class="source-code">abstract class MockRemoteDataSourceModule {</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindPostDataSource(</p><p class="source-code">        postDataSourceImpl: MockRemotePostDataSource): </p><p class="source-code">            RemotePostDataSource</p><p class="source-code">    @Binds</p><p class="source-code">    abstract fun bindUserDataSource(userDataSourceImpl</p><p class="source-code">          : MockRemoteUserDataSource): </p><p class="source-code">              RemoteUserDataSource</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">test</strong> package, create<a id="_idIndexMarker718"/> a class called <strong class="source-inline">MainActivityTest</strong>:<p class="source-code">@HiltAndroidTest</p><p class="source-code">class MainActivityTest {</p><p class="source-code">    @get:Rule(order = 0)</p><p class="source-code">    var hiltAndroidRule = HiltAndroidRule(this)</p><p class="source-code">    @get:Rule(order = 1)</p><p class="source-code">    var composeTestRule = createAndroidComposeRule</p><p class="source-code">        (MainActivity::class.java)</p><p class="source-code">    @Inject</p><p class="source-code">    lateinit var idlingResource: </p><p class="source-code">        ComposeCountingIdlingResource</p><p class="source-code">    @Before</p><p class="source-code">    fun setUp() {</p><p class="source-code">        hiltAndroidRule.inject()</p><p class="source-code">        composeTestRule.</p><p class="source-code">            registerIdlingResource(idlingResource)</p><p class="source-code">    }</p><p class="source-code">    @After</p><p class="source-code">    fun tearDown() {</p><p class="source-code">        composeTestRule.unregisterIdlingResource</p><p class="source-code">            (idlingResource)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker719"/>are initializing our test rules, which are for Hilt and Compose, in that exact order. Then, we inject <strong class="source-inline">ComposeCountingIdlingResource</strong> into the test class so that we can register it into the Compose test rule.</p>
			<ol>
				<li value="21">In the <strong class="source-inline">MainActivityTest</strong> class, add a test that will assert that the required data is displayed on the screen:<p class="source-code">@HiltAndroidTest</p><p class="source-code">class MainActivityTest {</p><p class="source-code">    …</p><p class="source-code">    @Test</p><p class="source-code">    fun testDisplayList() {</p><p class="source-code">        composeTestRule.onNodeWithText("Total click </p><p class="source-code">            count: 0")</p><p class="source-code">            .assertIsDisplayed()</p><p class="source-code">        composeTestRule.onAllNodesWithText("Author: </p><p class="source-code">            name1")</p><p class="source-code">            .assertCountEquals(2)</p><p class="source-code">        composeTestRule.onAllNodesWithText("Author: </p><p class="source-code">            name2")</p><p class="source-code">            .assertCountEquals(2)</p><p class="source-code">        composeTestRule.onNodeWithText("Title: </p><p class="source-code">            title1")</p><p class="source-code">            .assertIsDisplayed()</p><p class="source-code">        composeTestRule.onNodeWithText("Title: </p><p class="source-code">            title2")</p><p class="source-code">            .assertIsDisplayed()</p><p class="source-code">        composeTestRule.onNodeWithText("Title: </p><p class="source-code">            title3")</p><p class="source-code">            .assertIsDisplayed()</p><p class="source-code">        composeTestRule.onNodeWithText("Title: </p><p class="source-code">            title4")</p><p class="source-code">            .assertIsDisplayed()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have added a test that asserts that the header text is displayed, the two users are <a id="_idIndexMarker720"/>displayed for each of their posts, and that each post is displayed.</p>
			<p>If we run the test, we should see the following output:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_10.05_B18320.jpg" alt="Figure 10.5 – The test output for exercise 10.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – The test output for exercise 10.02</p>
			<p>As part of this exercise, we were able to provide mock data to the application without changing any of its existing code by changing the remote data sources and building upon existing functionality, by adding <strong class="source-inline">IdlingResources</strong> to our repositories. Both techniques were possible using dependency injection, and because of abstractions, we introduced different layers of the application when we performed dependency inversion. This makes the application's code testable and provides us with the opportunity to test different scenarios and create various types of tests to ensure the integration of different components. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we analyzed the exercises we've done in previous chapters and found potential issues with the dependencies that the modules of the application have. We looked at potential solutions for these problems. Then, we looked at a practical application of clean architecture, which is the implementation of instrumented tests, and how we can change the data sources of an application to ensure testing reliability. We looked at how we can implement instrumented tests using Jetpack Compose and Hilt to provide dependency injection, and then we applied them in an exercise in which we changed the dependencies for the tests. This serves as just one example of the benefits of clean architecture. Other benefits will come in situations where multiple flavors are used to publish similar applications and want to inject different implementations or configurations for each application we want to build. Another benefit comes when dealing with multiple platforms (such as Android and iOS), where we can define entities, use cases and repositories agnostically of the platforms using cross platform frameworks and then inject the implementations for retrieving and persisting the data for each platform.</p>
			<p>In <a href="B18320_09_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing an MVI Architecture</em>, we showed how we can change an application's presentation layer without impacting other layers. In a clean application, this should be possible for the data layer as well. We saw how libraries have changed and evolved over time. When networking libraries change, we should be able to transition to new libraries without causing issues in the other modules of an application. The same principle can be applied to local storage. We should be able to change from Room to other ways of persisting data locally. A good rule of thumb for how modules should be created is to view each module as a library that can be released and imagine yourself as the end user. You should have now a good idea of how clean architecture is supposed to work, the problems it is trying to solve, and how you can apply it to an Android application. </p>
		</div>
	</body></html>