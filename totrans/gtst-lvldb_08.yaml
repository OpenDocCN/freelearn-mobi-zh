- en: Chapter 8. Richer Keys and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。更丰富的键和数据结构
- en: In this chapter of the book we will review some classical database theory as
    it relates to LevelDB. The motivation for this starts with a richer application
    study. [Chapter 6](ch06.html "Chapter 6. Integrating with a Cocoa UI") *Integrating
    with a Cocoa UI*, introduced the basics of how to connect a database to a GUI
    with record addition. Most applications also need to deal with changing or deleting
    data. This chapter's code adds these actions to `Sample06`, in a copy which keeps
    the same filenames, for easy comparison with the simpler sample. The first part
    of the chapter is structured similarly to [Chapter 6](ch06.html "Chapter 6. Integrating
    with a Cocoa UI"), *Integrating with a Cocoa UI*, to help further with this comparison.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章中，我们将回顾一些与 LevelDB 相关的经典数据库理论。这种动机始于更丰富的应用研究。[第 6 章](ch06.html "第 6 章。与
    Cocoa UI 集成") *与 Cocoa UI 集成* 介绍了如何将数据库连接到 GUI 并添加记录的基本方法。大多数应用程序还需要处理更改或删除数据。本章的代码将这些操作添加到
    `Sample06` 中，在一个保持相同文件名的副本中，以便与更简单的示例进行比较。本章的前一部分结构与 [第 6 章](ch06.html "第 6 章。与
    Cocoa UI 集成") *与 Cocoa UI 集成* 类似，以帮助进一步进行比较。
- en: '`Sample06x` also improves searching via case-insensitive names and smart phone
    numbers. Searching needs support by customizing the indexing features of LevelDB.
    As part of that `Comparator` discussion we will look at ways to cope with binary
    integer keys.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample06x` 还通过不区分大小写的名称和智能电话号码改进了搜索。搜索需要通过自定义 LevelDB 的索引功能来支持。作为 `Comparator`
    讨论的一部分，我们将探讨处理二进制整数键的方法。'
- en: Completing the data source for a rich GUI
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成丰富 GUI 的数据源
- en: 'The extended version of `Sample06` adds two major aspects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample06` 的扩展版本增加了两个主要方面：'
- en: Changing the data listed in the `tableview`, viewing a secondary index
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改 `tableview` 中列出的数据，查看二级索引
- en: Deleting and renaming records, implying key updates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除和重命名记录，意味着键更新
- en: When it comes to updates, `Sample06` showed how a **Save** button can simply
    trigger writing the record values back for the current key. Our first version
    was quite flawed as it created visible copies of records each time we changed
    a name. We need to ensure renaming occurs, rather than **Save** behaving as if
    it's really **Save a Copy As**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更新时，`Sample06` 展示了如何一个 **保存** 按钮可以简单地触发将当前键的记录值写回。我们的第一个版本相当有缺陷，因为它每次更改名称时都会创建记录的可见副本。我们需要确保重命名发生，而不是让
    **保存** 行为像真的 **另存为** 一样。
- en: Adding the phone number secondary index for listing implies writing a second
    key, each time we save from the GUI. This is easy for new records. However, when
    we save an existing record there are old key values which may need to be removed
    because they point to obsolete data. This implies a smart cleanup in the model
    that knows when to remove keys and when to rewrite. If these concepts are familiar,
    skim this part but still have a look at how the key prefix is used as a flag to
    track the current listing mode.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为列出添加电话号码二级索引意味着每次从 GUI 保存时都要写入第二个键。对于新记录来说，这很简单。然而，当我们保存现有记录时，可能需要删除旧键值，因为它们指向过时的数据。这意味着在模型中需要智能清理，知道何时删除键和何时重写。如果这些概念是熟悉的，可以快速浏览这部分，但仍需查看如何使用键前缀作为标志来跟踪当前列出模式。
- en: Extending the OS X GUI to fully support editing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 OS X 图形用户界面扩展以完全支持编辑
- en: 'The full OS X GUI adds more action buttons for editing and sorting the list.
    The following screenshot shows a choice of lists:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 OS X 图形用户界面增加了更多用于编辑和排序列表的动作按钮。以下截图显示了列表的选择：
- en: '![Extending the OS X GUI to fully support editing](img/1015OS_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![将 OS X 图形用户界面扩展以完全支持编辑](img/1015OS_08_01.jpg)'
- en: An OS X sample app showing a list with choice of lists and more editing controls
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 OS X 示例应用程序，显示具有列表选择和更多编辑控制的列表
- en: 'The extended OS X app is also a single window that adds:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的 OS X 应用程序也是一个单窗口，它增加了：
- en: More buttons and menu items to provide the **View** commands
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多按钮和菜单项以提供 **视图** 命令
- en: Buttons and menu items for the **Revert** and **Delete** commands
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**还原** 和 **删除** 命令的按钮和菜单项'
- en: Connecting the database to the NSTableView
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库连接到 NSTableView
- en: In simple OS X apps, the `AppDelegate` object takes the role of the `ViewController`
    class in iOS apps. So, all of these interface methods and outlets are in `GSwLDB06osxAppDelegate`.
    The graphical interface is in `MainMenu06.xib`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的 OS X 应用程序中，`AppDelegate` 对象在 iOS 应用程序中扮演着 `ViewController` 类的角色。因此，所有这些界面方法和出口都在
    `GSwLDB06osxAppDelegate` 中。图形界面在 `MainMenu06.xib` 中。
- en: The **View All** button and the **View – All Records with Prefixes** menu item
    are connected to the `(IBAction)viewAllRecords`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看所有**按钮和**查看 – 带前缀的所有记录**菜单项连接到 `(IBAction)viewAllRecords`'
- en: The **View Names** button and **View – Names** menu item are connected to the
    `(IBAction)viewNamesOnly`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看名称**按钮和**查看 – 名称**菜单项连接到 `(IBAction)viewNamesOnly`'
- en: The **View Phones** button and the **View – Phone numbers** menu item are connected
    to the `(IBAction)viewPhonesOnly`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看电话**按钮和**查看 – 电话号码**菜单项连接到 `(IBAction)viewPhonesOnly`'
- en: The action of the `NSSearchField` class, and the `datasource` and `delegate`
    outlets of the `NSTableView` class are connected as in `Sample06`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSSearchField` 类的动作和 `NSTableView` 类的 `datasource` 和 `delegate` 输出连接方式与 `Sample06`
    相同'
- en: 'The expanded declaration of `GSwLDB06osxAppDelegate` is shown in the following
    code. We will discuss the other actions and outlets below when we talk about editing
    records:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`GSwLDB06osxAppDelegate` 的扩展声明如下代码所示。我们将在讨论编辑记录时讨论其他动作和输出：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The mechanism for loading a set of rows and copying them to the `tableview`
    object is the same as the simpler example of `Sample06`. All the knowledge of
    what it means to be viewing by phone, or by name, is hidden in the model class.
    So, to change the entire list to phones, we have an action invoked `viewPhonesOnly`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 加载一组行并将它们复制到 `tableview` 对象的机制与 `Sample06` 的简单示例相同。所有关于通过电话或通过名称查看的含义的知识都隐藏在模型类中。因此，要更改整个列表为电话，我们有一个调用的
    `viewPhonesOnly` 动作：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expanded public interface of the model is in `Sample06_Model.h`, adding:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的扩展公共接口位于 `Sample06_Model.h` 中，添加了：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The class extension in `Sample06_Model.m` is also a little different, adding
    some methods and properties and replacing `addRecord` with a more complex one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample06_Model.m` 中的类扩展也略有不同，添加了一些方法和属性，并用更复杂的一个替换了 `addRecord`：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The database creation and loading from `sample50000.txt` are very similar to
    `Sample05`, and the same as `Sample06`, except that we''re using 50,000 records
    to see performance implications. We will look at record addition in detail later,
    when discussing editing. Continuing with our focus on loading the table, the big
    difference between this model code and `Sample05` is that it caches results in
    an array rather than just printing keys as they are iterated (costing 200 MB of
    memory for 50,000 records). It has the same use of a prefix `N~` or `P~` to distinguish
    key types. Added to `Sample05` simple model, support for the GUI means the model
    remembers `lastPrefixUsed`, which depends on the user''s choice of **Names** or
    **Phones**. The two load methods we saw called from the GUI are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库创建和从 `sample50000.txt` 加载与 `Sample05` 非常相似，与 `Sample06` 相同，除了我们使用 50,000
    条记录来查看性能影响。我们将在讨论编辑时详细查看记录添加。继续关注加载表格，与 `Sample05` 的模型代码相比，最大的不同是它在数组中缓存结果而不是在迭代时仅打印键（对于
    50,000 条记录消耗 200 MB 的内存）。它使用相同的 `N~` 或 `P~` 前缀来区分键类型。添加到 `Sample05` 简单模型中，支持 GUI
    意味着模型会记住 `lastPrefixUsed`，这取决于用户对 **名称** 或 **电话** 的选择。我们看到的两个从 GUI 调用的加载方法如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These both use a method which was added to APLevelDB in the class category `APLevelDB_ADSearches`,
    alongside the `enumerateKeysWithPrefix` we saw in `Sample05`. It extends that
    method with the `strippingFirst` parameter to let a caller specify the length
    of a non-printing prefix on the key. When we are getting all records of a given
    type, the prefix length will be the same two characters as we have seen (`N~`
    or `P~`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都使用了一个添加到 APLevelDB 类别 `APLevelDB_ADSearches` 中的方法，与我们在 `Sample05` 中看到的 `enumerateKeysWithPrefix`
    相同。它通过 `strippingFirst` 参数扩展了该方法，允许调用者指定键上非打印前缀的长度。当我们获取给定类型的所有记录时，前缀长度将与我们所见的相同两个字符（`N~`
    或 `P~`）。
- en: 'However, when responding to the GUI `viewMatches` action, we are searching
    for a prefix that includes their search term, for example, `N~Smith` for names
    starting with `Smith`. Our prefix is seven characters long but we want to strip
    two for display. Looking in `APLevelDB_APLevelDB_ADSearches.mm` we see the search
    implemented as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当响应 GUI 的 `viewMatches` 动作时，我们正在搜索包含其搜索词的前缀，例如，以 `Smith` 开头的 `N~Smith`。我们的前缀是七个字符长，但我们想显示时去掉两个。在
    `APLevelDB_APLevelDB_ADSearches.mm` 中查看，我们看到搜索实现如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this understanding of the keys array generation, let''s review `Sample06_Model.m`
    and see how the array of keys is used to provide values for the tableview. The
    `Sample06` `countRows` and `keyForRow` methods are unchanged but our list is now
    smarter. The following code snippet shows how an array of keys is used to provide
    values for the `tableview` object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了键数组生成的方式之后，让我们回顾`Sample06_Model.m`，看看如何使用键数组为`tableview`对象提供值。`Sample06`的`countRows`和`keyForRow`方法没有改变，但我们的列表现在更智能了。以下代码片段显示了如何使用键数组为`tableview`对象提供值：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Did you notice the slight cheat? We are only displaying a single column table
    but the `Name` key is a combination of last and first name with a tab between.
    We just get that as a single string and allow the GUI to have a waver down the
    middle, rather than splitting into two columns. That makes it easier to flip to
    the single-column phone list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这个小技巧了吗？我们只显示单列表格，但`Name`键是姓氏和名字的组合，中间用制表符分隔。我们只获取这个作为单个字符串，并允许GUI在中间有一个波浪线，而不是分成两列。这使得切换到单列电话列表更容易。
- en: Connecting record details to the editing form
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将记录详情连接到编辑表单
- en: 'The extended editing behaviors are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的编辑行为包括：
- en: '**Revert**: To discard any charged details and reload the current record'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**还原**：丢弃任何已输入的详细信息并重新加载当前记录'
- en: '**Save**: To copy the details entered back to the database, including changing
    keys and refreshing the list'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存**：将输入的详细信息复制回数据库，包括更改键和刷新列表'
- en: '**Delete**: To remove the current record and secondary key from the database'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：从数据库中移除当前记录和次要键'
- en: Allowing and responding to selection changes is no different from `Sample06`
    with a horizontal array of values from the record being copied to the entry fields.
    The core logic in the `fieldsForRow` method in `Sample06_Model` is the same—the
    basic record structure hasn't changed. However, the code has been split out into
    the separate `fieldsForKey` method which is used from several places.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 允许并响应用户选择的变化与`Sample06`中的处理方式相同，即从被复制的记录中获取值并填充到输入字段中。`Sample06_Model`中的`fieldsForRow`方法的核心逻辑保持不变——基本的记录结构没有改变。然而，代码已经被拆分成了单独的`fieldsForKey`方法，该方法在多个地方被使用。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's one bit of complexity introduced because our GUI allows the user to
    list either the main `Name` index or `Phone` keys. We need a `Name` key to get
    the detailed record from the database but it's possible that the current table
    is showing `Phones`. This means that the selected value in the list is not the
    type of key we need. Or, to think in database terms, we are listing it by a foreign
    key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的GUI允许用户列出主`Name`索引或`Phone`键，因此引入了一点复杂性。我们需要一个`Name`键来从数据库中获取详细记录，但当前表可能显示的是`Phones`。这意味着列表中选定的值不是我们需要的键类型。或者，用数据库术语来说，我们是通过外键来列出它的。
- en: 'This is where it is vital for the model to remember the type of list, which
    it sees as the `lastPrefixUsed` set by a method such as `loadPhones`. The model
    doesn''t know anything about the GUI. It just knows it was last asked for phones
    or names. If we have a `Phone` key, we need to read its record to get the main
    key (remember this **secondary index** in `Sample05`). It is done in the following
    way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于模型来说，记住列表的类型至关重要，它将其视为由`loadPhones`等方法设置的`lastPrefixUsed`集合。模型对GUI一无所知。它只知道它最后被要求获取电话或名称。如果我们有一个`Phone`键，我们需要读取其记录以获取主键（记住`Sample05`中的这个**次要索引**）。以下是完成此操作的方式：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of `mainKeyFrom` is about key construction, as string prefixing. The last
    line uses `stringForKey` to get the main key as a foreign key operation; the same
    relational searches we discussed in [Chapter 4](ch04.html "Chapter 4. Iteration
    and Searching Keys"), *Iteration and Searching Keys*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainKeyFrom`的大部分内容是关于键构建，如字符串前缀。最后一行使用`stringForKey`获取主键作为外键操作；这与我们在[第4章](ch04.html
    "第4章。迭代和搜索键")中讨论的相同关系搜索，*迭代和搜索键*。'
- en: Saving data with key updates
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键更新保存数据
- en: We've seen data loading extended to cope with listing and searching by different
    indexes. As seen in the original `Sample06`, to save we will need to send an array
    of fields back to the model to update the database. This time we're going to update
    the indexes properly. This starts with `GSwLDB06osxAppDelegate` knowing when it
    is saving a new record or an old one—the model needs to know what it replaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到数据加载被扩展以处理通过不同索引进行列表和搜索。正如原始的`Sample06`所示，为了保存，我们需要将字段数组发送回模型以更新数据库。这次我们将正确更新索引。这始于`GSwLDB06osxAppDelegate`知道它正在保存新记录还是旧记录——模型需要知道它替换了什么。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The simple save case is when a new record has been saved, so the model knows
    it is creating a new record. We now see our common `addRecord` method works like
    `Sample05`, adding a phone record pointing to the main key and using JSON for
    the body, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简单保存的情况是当保存了一个新记录，因此模型知道它正在创建一个新记录。我们现在看到我们的常见`addRecord`方法像`Sample05`一样工作，添加一个指向主键的电话记录，并使用JSON作为主体，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The complex case of saving an existing record has to cope with the need to
    change the secondary index of the `Phone` key, if either the phone number or the
    main key has changed. As shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 保存现有记录的复杂情况必须应对需要更改`Phone`键的二级索引的需求，如果电话号码或主键发生了变化。如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The save method could be as simple as just one record being written, if all
    the keys stayed the same but only some non-key values changed, such as e-mail.
    In the worst case, the previous code performs two deletions and two writes, if
    both the phone number and one of the names changed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有键保持不变，但只有一些非键值改变，例如电子邮件，则保存方法可能只是简单地写入一个记录。在最坏的情况下，如果电话号码和其中一个名称都改变了，则之前的代码执行两次删除和两次写入。
- en: Responding to the new and delete commands
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对新和删除命令的响应
- en: 'A `new` command is just a GUI action clearing all the entry fields. It sets
    a property of the delegate `isNewRecord`, as you saw used previously in `saveRecord`.
    The model doesn''t know it''s a new record until you invoke the simple save shown
    earlier. The following code shows the `new` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`命令只是一个GUI动作，清除所有输入字段。它设置委托`isNewRecord`的属性，正如你在`saveRecord`中之前看到的。模型不知道它是一个新记录，直到你调用之前展示的简单保存。以下代码显示了`new`命令：'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `delete` command removes the current record and tries to keep the selection
    in the same place, reloading data to suit. As you saw earlier in methods such
    as `viewPhonesOnly`, we need to explicitly call `loadFieldsForCurrentSelectedRow`
    when the list content changes, but the selection may have stayed on the same row
    number. The following code shows the `delete` command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`命令删除当前记录，并尝试保持选择在同一位置，重新加载数据以适应。正如你之前在`viewPhonesOnly`等方法中看到的，当列表内容改变时，我们需要显式调用`loadFieldsForCurrentSelectedRow`，但选择可能仍然停留在同一行号。以下代码显示了`delete`命令：'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `model` method just needs to delete the main and secondary phone index
    records as shown:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`model`方法只需要删除主和次要电话索引记录，如下所示：'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how we read the main record to get the phone key. There's a possible optimization
    that you could do depending on the current list being by phone but this is clearer
    code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何读取主记录以获取电话键。根据当前列表是否按电话排序，你可以进行可能的优化，但这样代码更清晰。
- en: Key design for LevelDB versus relational theory and SQL
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LevelDB的关键设计相对于关系理论和SQL
- en: 'A key should exist in LevelDB because:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个键应该存在于LevelDB中，因为：
- en: You want to directly use the associated value.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想直接使用相关值。
- en: The key itself provides information without a value.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键本身提供信息，而不需要值。
- en: You can navigate from the key via a portion of it, or the associated value,
    to another key. Ultimately, this chain of keys leads to the value you want.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过键的一部分或相关值导航到另一个键。最终，这个键链将引导到你想要的价值。
- en: 'There is a limitation in the design of the keys and values we''ve been storing
    so far for phone numbers—the problem of uniqueness. Our pair of keys and values
    looks like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止为电话号码设计的键和值存在一个限制——唯一性问题。我们的键和值对看起来如下：
- en: '![Key design for LevelDB versus relational theory and SQL](img/1015OS_08_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![LevelDB与关系理论和SQL的关键设计](img/1015OS_08_02.jpg)'
- en: Current keys and values in the Sample06 names and addresses database
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Sample06名称和地址数据库中的当前键和值
- en: The convention used in this and other diagrams in this chapter is that keys
    by themselves will be in plain rectangles with the associated values in a 3D box
    pointed to by a diamond and arrow (UML style for contained relationship). So,
    if you see a rectangle which doesn't point to a 3D box, then that's a key without
    a value (as seen in the next image).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的惯例是，键本身将位于普通矩形中，相关值位于由菱形和箭头指向的3D框中（UML风格表示包含关系）。因此，如果你看到一个不指向3D框的矩形，那么它就是一个没有值的键（如下一张图片所示）。
- en: The problem with this naive key design is that it only allows a given phone
    number to occur once in the entire database, as we're composing a key just from
    the phone number. That's an obvious flaw—people share phone numbers. A similar
    problem occurs with the names—there's only one *Andy Dent* allowed. If this seems
    confusing, remember that the key-value store in LevelDB works like a giant dictionary—**keys
    are unique** and the only way to have keys repeat values is to add more information
    so that each key is still unique.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种天真键设计的缺点在于，它只允许整个数据库中有一个特定的电话号码出现一次，因为我们只是从电话号码中构建键。这是一个明显的缺陷——人们会共享电话号码。类似的问题也出现在名字上——只允许一个*安迪·邓特*存在。如果这让你感到困惑，请记住，LevelDB中的键值存储就像一个巨大的字典——**键是唯一的**，唯一让键重复值的方法是添加更多信息，以确保每个键仍然是唯一的。
- en: Names can be fixed by simply adding a unique suffix to the end of the key, such
    as an integer incremented for each record. To make phone numbers work, we need
    to move the associated name out of the value and into the key, so we have the
    phone key with **no value**. That move by itself would just allow for a single
    phone key per unique name, so if we want many phones we must also add a unique
    suffix to the end of each phone key.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在键的末尾简单地添加一个唯一的后缀，可以固定名字，例如为每个记录递增一个整数。为了让电话号码工作，我们需要将相关的名字从值中移出并放入键中，这样我们就有了一个没有值的电话键。这个移动本身只会允许每个唯一名字有一个电话键，所以如果我们想要很多电话号码，我们还必须在每个电话键的末尾添加一个唯一的后缀。
- en: '![Key design for LevelDB versus relational theory and SQL](img/1015OS_08_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![LevelDB的键设计与关系理论和SQL的比较](img/1015OS_08_03.jpg)'
- en: Changes to key structures to support duplicate names and phone numbers in the
    names and addresses database
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 改变键结构以支持在名称和地址数据库中重复的名字和电话号码
- en: If you have studied relational theory or **normal forms**, in your use of SQL
    databases, this will be starting to seem familiar. There's a simple principle
    we can apply here—when in doubt, regard your LevelDB keys as equivalent to relational
    tables and only move non-key attributes into the associated value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经研究了关系理论或**范式**，在你的SQL数据库使用中，这开始变得熟悉起来。我们可以应用一个简单的原则——当不确定时，将你的LevelDB键视为等同于关系表，并且只将非键属性移动到相关的值中。
- en: Deciding when to store one record or split values
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时存储一条记录或拆分值
- en: 'Our record so far has been a simple array encoded with a JSON serializer. As
    you saw earlier, when we update any fields in the GUI, we need to rewrite that
    record. If we change the phone number or names, we also need to rewrite the phone
    number secondary index record. We can make it more flexible for updates by moving
    data into the keys as shown in the following figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止的记录是一个简单的数组，使用JSON序列化器编码。正如你之前看到的，当我们更新GUI中的任何字段时，我们需要重写这个记录。如果我们更改电话号码或名字，我们也需要重写电话号码二级索引记录。我们可以通过以下图中的方式将数据移动到键中，使其更新更加灵活：
- en: '![Deciding when to store one record or split values](img/1015OS_08_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![决定何时存储一条记录或拆分值](img/1015OS_08_04.jpg)'
- en: Keys and values if the refactored Sample06 database to allow multiple phones
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重构Sample06数据库以允许多个电话号码，键和值
- en: In the previous diagram, it looks like we have a bit of an explosion of keys,
    from two to four. Phone numbers are now paired keys, prefixed with `P~` and `R~`.
    This is a common pattern for building a **graph database** on top of a Key-value
    store. A single fact of two things being related must be described by at least
    two keys, so you can search by either related item. As the phones are not in the
    main data, we need to be able to go back to them via the nameId when they are
    updated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图中，看起来我们有了从两个到四个键的爆炸性增长。电话号码现在是成对的键，以`P~`和`R~`为前缀。这是在键值存储之上构建**图数据库**的常见模式。两个事物相关的事实至少需要两个键来描述，这样你就可以通过任一相关项进行搜索。由于电话号码不在主数据中，我们需要能够在它们更新时通过nameId回到它们。
- en: Another consideration is that duplicating the names in many keys costs a lot
    of storage. In order to avoid the storage overhead of the name being part of the
    phone key, we need a unique nameId that can be used with the phone. We can use
    that instead of the unique suffix that was part of the name key before, so our
    name key is still almost identical. However, the main value is no longer associated
    directly with that name key. Instead, the nameId is used as the key for the detailed
    record. The immediate implication is that we have doubled the reads to get more
    details when listing people by name. This is not actually very expensive if we
    consider the usage patterns in `Sample06`—the list of items for the `tableview`
    object still comes from a single iteration through name keys. It just adds a bit
    of overhead to load the details when we select a given name.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，在许多键中重复名称会消耗大量存储空间。为了避免名称作为电话键一部分带来的存储开销，我们需要一个独特的nameId，它可以与电话一起使用。我们可以用这个来代替之前作为名称键一部分的唯一后缀，这样我们的名称键仍然几乎相同。然而，主要价值不再直接与那个名称键相关联。相反，nameId被用作详细记录的键。直接的后果是我们列出按名称排列的人时，读取次数翻倍以获取更多详细信息。如果我们考虑`Sample06`中的使用模式——`tableview`对象的物品列表仍然来自对名称键的单次迭代。这实际上并不昂贵，因为我们选择特定名称时只需增加一点加载详细信息的开销。
- en: We will no longer store the phone number in the JSON array, but we will rely
    on a key to supply that number. This means we have to be able to retrieve the
    Phone number from a name. Hence we have the paired keys that use the P~ and R~
    prefixes. People change phone numbers frequently so by pulling the phone number
    out of the main details, we have avoided a rewrite of the major key and associated
    value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再在JSON数组中存储电话号码，而是将依赖一个键来提供该号码。这意味着我们必须能够从名称中检索电话号码。因此，我们有了使用P~和R~前缀的成对键。人们经常更换电话号码，因此通过将电话号码从主要详细信息中提取出来，我们避免了主要键及其相关值的重写。
- en: We can now trivially extend the database to allow for multiple phone numbers,
    although that would require significant GUI rework, like Apple's contacts for
    editing the numbers. [Chapter 10](ch10.html "Chapter 10. Tuning and Key Policies"),
    *Tuning and Key Policies*, discusses the implications of this key refactoring
    in more detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻易地扩展数据库以允许多个电话号码，尽管这需要重大的GUI重写，就像苹果的联系人编辑号码一样。[第10章](ch10.html "第10章。调整和键策略")，*调整和键策略*，更详细地讨论了这种键重构的影响。
- en: If you are familiar with relational database normalization, the reasons for
    the factoring out above should be common patterns for you. The apparent difference
    is that a single relational table would allow querying from either aspect, for
    example, a single row (tuple) linking phone number, nameId, and phone role. However,
    on most database servers, a DBA will usually specify an index on at least two
    of those columns, for better search performance, so the actual data stored in
    a SQL database would start resembling our key diagram.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉关系型数据库规范化，上述分解的原因对你来说应该是常见模式。明显的区别是，单个关系型表可以允许从任一方面进行查询，例如，一个包含电话号码、nameId和电话角色的单行（元组）。然而，在大多数数据库服务器上，数据库管理员通常会指定至少两个这些列的索引，以提高搜索性能，因此实际存储在SQL数据库中的数据将开始类似于我们的键图。
- en: A relational database forces you to factor data out into separate tables whenever
    you need to represent multiples, such as, our phone numbers. We can store multiple
    items in JSON values in our record to have much more flexibility. Thousands of
    individual details could be buried in an individual's record without requiring
    complex table structures. The only downside is that searching by those details
    would require reading the entire database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库强制你在需要表示多个值时，例如我们的电话号码，将数据分解到单独的表中。我们可以在记录中存储多个JSON值以获得更大的灵活性。数千个详细信息可以隐藏在个人的记录中，而不需要复杂的表结构。唯一的缺点是，通过这些详细信息进行搜索需要读取整个数据库。
- en: Implementing schemas for LevelDB
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现LevelDB的模式
- en: In a classical relational database, the schema definition describes each table.
    The tables have strict data types and every row has the same content. A lot of
    work has been done on **ORM** (**Object-Relational Mapping**) products and there
    are multiple patterns that can be applied. See *Scott Ambler's* [http://www.agiledata.org/essays/mappingObjects.html](http://www.agiledata.org/essays/mappingObjects.html)
    and *Martin Fowler's* [http://martinfowler.com/eaaCatalog/](http://martinfowler.com/eaaCatalog/)
    for detailed discussions on ORM.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的数据库中，模式定义描述了每个表。表有严格的数据类型，并且每一行都有相同的内容。在 **ORM**（**对象关系映射**）产品上已经做了很多工作，并且有多个模式可以应用。参见
    *Scott Ambler* 的 [http://www.agiledata.org/essays/mappingObjects.html](http://www.agiledata.org/essays/mappingObjects.html)
    和 *Martin Fowler* 的 [http://martinfowler.com/eaaCatalog/](http://martinfowler.com/eaaCatalog/)，以获取关于
    ORM 的详细讨论。
- en: One of the reasons for the rise of NoSQL databases is the flexibility they add.
    While we have been storing quite uniform data in our records, just using the JSON
    serialization approach allows us to easily map a complex dictionary into a record.
    Nothing in LevelDB cares about the structure of one record being different from
    the next. Remember that, while we've been talking as if our different keys are
    in different indexes, they are really just in the one key-value store with only
    our prefixing convention differentiating them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库兴起的一个原因是它们增加的灵活性。虽然我们一直在我们的记录中存储相当一致的数据，但仅使用 JSON 序列化方法就允许我们轻松地将复杂的字典映射到记录中。LevelDB
    对一条记录的结构与另一条记录不同并不关心。记住，虽然我们一直在谈论好像我们的不同键位于不同的索引中，但实际上它们只是在单个键值存储中，只是我们的前缀约定将它们区分开来。
- en: So, what value can schema support provide in LevelDB? It's not a constraining
    or mandatory thing, but as an extension to APLevelDB, provides helpers to manage
    complex keys. All that work we added in the first part of this chapter was just
    to maintain two keys pointing to the main record. Imagine adding another five
    keys into the mix and also having to generate unique identifiers. It would be
    nice to just declare the relationships between keys and how they are derived,
    supplying the minimum amount of code for any custom key assembly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，模式支持在 LevelDB 中能提供什么价值呢？它不是一个约束性或强制性的东西，但作为 APLevelDB 的扩展，提供了管理复杂键的辅助工具。我们在本章的第一部分添加的所有工作只是为了维护指向主记录的两个键。想象一下，在混合中添加另外五个键，并且还需要生成唯一标识符。如果能简单地声明键之间的关系以及它们是如何派生的，提供任何自定义键组装的最小代码量，那将是非常好的。
- en: The schema support also helps map to the content of the detail record or to
    data stored in associated keys, such as the phone number. The original `Sample06`
    used enums to index the JSON array of values. Using a schema allows us to supplement
    those by key paths in the dotted style of Apple's key-value coding. The schema
    also provides a generic interface to read those details to help you include a
    REPL for debugging. Each schema entry is stored in the database with a simple
    key such as `~~Person` with the entire schema entry details in a JSON dictionary
    in the value for the key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模式支持还有助于将内容映射到详细记录或存储在相关键中的数据，例如电话号码。原始的 `Sample06` 使用枚举来索引值的 JSON 数组。使用模式允许我们通过苹果的键值编码的点式风格的关键路径来补充这些枚举。模式还提供了一个通用的接口来读取这些详细信息，以帮助您包括一个
    REPL 进行调试。每个模式条目都存储在数据库中，使用一个简单的键，例如 `~~Person`，其整个模式条目详细信息存储在键的值的 JSON 字典中。
- en: All of the changes to-date in APLevelDB plus schema support have been rolled
    up and published online at [https://github.com/AndyDentFree/APLevelDBSS](https://github.com/AndyDentFree/APLevelDBSS)
    and shown in another copy of `Sample06`. The extended functionality of `Sample06`
    is combined with the refactored key structure in the previous figure with `Sample06sch`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，APLevelDB 以及模式支持的所有更改都已汇总并发布在 [https://github.com/AndyDentFree/APLevelDBSS](https://github.com/AndyDentFree/APLevelDBSS)
    上，并在 `Sample06` 的另一个副本中展示。`Sample06` 的扩展功能与上一图中的 `Sample06sch` 中的重构键结构相结合。
- en: Dealing with integer key endianness
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理整数键的端序
- en: LevelDB doesn't actually care if you store string values or arbitrary binary
    bytes—we've already seen how you can just push the structure into a record and
    that the `Slice` structure works with binary for keys and values. If you want
    an efficient, unique, compact key, storing a binary integer is an obvious choice
    for all or part of a key, such as our nameId.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 实际上并不关心您存储的是字符串值还是任意二进制字节——我们已经看到您可以将结构推入记录中，并且 `Slice` 结构与二进制键和值一起工作。如果您想要一个高效、唯一、紧凑的键，将二进制整数存储为键的全部或部分是一个明显的选择，例如我们的
    nameId。
- en: However, the `BytewiseComparator`, used by default, will cause problems if you
    try making keys using integers straight from memory. Both Intel and ARM chips
    (Mac and iPhone) store integers in **Little Endian** order which means the least-significant
    byte is to the left and sorting of an integer key by bytes won't work. This is
    only a problem if you want the keys sorted. If your binary integers just provide
    a unique suffix, ignore this.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认使用的 `BytewiseComparator` 如果你尝试使用从内存中直接获取的整数来创建键，将会引起问题。Intel 和 ARM 芯片（Mac
    和 iPhone）以 **小端序** 存储整数，这意味着最低有效字节在左边，按字节排序整数键将不会工作。这只有在你想对键进行排序时才是一个问题。如果你的二进制整数只是提供了一个唯一的后缀，那么忽略这一点。
- en: 'The code for this chapter includes a file, `Log of Listing Binary Keys Sample08
    OSX.txt`, that shows the effect of this and how it can be fixed by a custom comparator
    (see *Using comparators to vary key ordering* section) or simply by flipping the
    order of bytes in the integer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包括一个文件，`Log of Listing Binary Keys Sample08 OSX.txt`，它展示了这种情况的影响以及如何通过自定义比较器（见
    *使用比较器来改变键的顺序* 部分）或简单地通过翻转整数中的字节顺序来修复它：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same code generates both lists—a simple function that loops to add a bunch
    of keys and then iterates the database, reading back those keys that were added:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同一段代码生成了两个列表——一个简单的函数，它循环添加一些键，然后迭代数据库，读取那些已添加的键：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We get the same ordered result by using a database with a default `BytewiseComparator,`
    but flipping keys to store bytes in Little Endian order. If we were doing searches
    we would also need to flip the search value entered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用默认的 `BytewiseComparator` 的数据库并翻转键以存储小端序的字节，我们得到相同的有序结果。如果我们正在进行搜索，我们还需要翻转输入的搜索值：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The system function `htonl` is a very efficient byte swapper. It has siblings
    `htnoll` and `htons` for 64 and 16 bit integers. If your key has more than one
    integer component, maybe mixing binary integers with strings, you would swap each
    integer individually.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 系统函数 `htonl` 是一个非常高效的字节交换器。它有兄弟函数 `htnoll` 和 `htons` 用于64位和16位整数。如果你的键有多个整数组件，可能混合了二进制整数和字符串，那么你需要单独交换每个整数。
- en: Using comparators to vary key ordering
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用比较器来改变键的顺序
- en: The LevelDB documentation discusses the use of custom comparators, and they
    can be a powerful addition to your database toolkit, but people often misunderstand
    their role. Comparators are like the sort functions you pass into standard library
    sorts but they have a **lasting effect on the database**. The core data structures
    of LevelDB tables store keys sorted by the `Comparator`. When you are searching,
    the comparator's `Compare` function is called as part of the tree traversal. Writing
    a comparator is a lifetime commitment, for the lifetime of that database. Your
    code provides the comparator, so to open and use the database, you have to keep
    supplying that comparator. Comparator objects supply a `Name` through a virtual
    function, checked on opening to confirm you have specified a matching comparator
    for that used to create the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 文档讨论了自定义比较器的使用，它们可以成为你的数据库工具包的有力补充，但人们经常误解它们的作用。比较器就像你传递给标准库排序的排序函数，但它们对数据库有**持久的影响**。LevelDB
    表的核心数据结构按 `Comparator` 排序存储键。当你搜索时，比较器的 `Compare` 函数作为树遍历的一部分被调用。编写比较器是一项终身承诺，即该数据库的终身承诺。你的代码提供了比较器，因此要打开和使用数据库，你必须持续提供那个比较器。比较器对象通过一个虚拟函数提供一个
    `Name`，在打开时进行检查，以确认你已指定了一个与用于创建数据库的比较器相匹配的比较器。
- en: 'As we have seen already, you can accomplish a lot with careful use of key prefixes
    and flipping the order of integers in binary keys. However, there are some things
    that can only be done with a custom comparator. The enhanced `Sample06` shows
    two examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，你可以通过仔细使用键前缀和翻转二进制键中整数的顺序来完成很多事情。然而，有些事情只能通过自定义比较器来完成。增强的 `Sample06`
    展示了两个例子：
- en: For names, we ignore case. That provides a more natural user experience.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于姓名，我们忽略大小写。这提供了更自然的用户体验。
- en: For Phones, we ignore any non-digits. It won't matter if the number is entered
    with dashes, spaces, dots, or no separator.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于电话号码，我们忽略任何非数字字符。如果号码带有破折号、空格、点或没有分隔符，这都不会影响。
- en: 'These are two distinct roles but only one comparator can be used for a database.
    We''re still using APLevelDB as our basic Objective-C interface, but it needed
    a bit more modification to allow us to specify that comparator which is simply
    passed as a function pointer to the `leveldb::Options` structure that is used
    when we open a database. We start by adding a pointer type into `APLevelDB.h`
    and an extra database factory method that takes a comparator, as shown in the
    following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个角色是不同的，但数据库只能使用一个比较器。我们仍然使用APLevelDB作为我们的基本Objective-C接口，但它需要一些修改才能允许我们指定比较器，这只是一个简单地将函数指针传递给`leveldb::Options`结构，该结构用于打开数据库时。我们首先在`APLevelDB.h`中添加一个指针类型，并添加一个额外的数据库工厂方法，该方法接受一个比较器，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The matching changes in `APLevelDB.mm` include adding an **ivar** to point to
    the comparator and rewriting the original `init` method so it takes a comparator
    as shown in the following code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`APLevelDB.mm`中的匹配更改包括添加一个指向比较器的`ivar`，并重写原始的`init`方法，使其接受一个比较器，如下面的代码所示。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After passing in the comparator function pointer to the options, it will automatically
    be used by the database. However, you must make sure all programs using that database
    continue to use the same comparator. The core of the comparator is the `Compare`
    function which either calls our own case-insensitive `Name` comparison, digit-only
    phone comparison, or defaults to the standard `BytewiseComparator`. I highly recommend
    including a default fallback, if you have key types that are detected like our
    prefixes. We assume from our key scheme that a `~` in the second character indicates
    a special key, the following code shows this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将比较函数指针传递给选项后，数据库会自动使用它。然而，你必须确保所有使用该数据库的程序继续使用相同的比较器。比较器的核心是`Compare`函数，它要么调用我们自己的不区分大小写的`Name`比较，仅数字的电话比较，或者默认使用标准的`BytewiseComparator`。我强烈建议包括一个默认回退，如果你有像我们的前缀那样检测到的键类型。我们根据我们的键方案假设第二个字符中的`~`表示一个特殊键，以下代码展示了这一点：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside LevelDB, the use of a comparator is automatic but in my code for iterating
    keys I fell into a common trap that **bypassed** it. The extension `APLevelDB_ADSearches`
    adds a method that compares two keys and our first implementation used the efficient
    `Slice::starts_with` function. That is only safe with the standard `Comparator`
    function, which uses the same logic as `starts_with`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在LevelDB内部，比较器的使用是自动的，但在我用于迭代键的代码中，我陷入了常见的陷阱，即**绕过了**它。扩展`APLevelDB_ADSearches`添加了一个比较两个键的方法，我们的第一个实现使用了高效的`Slice::starts_with`函数。这只有在使用与`starts_with`相同逻辑的标准`Comparator`函数时才是安全的：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The same bug is exhibited by the sample code on the LevelDB site for iteration
    that compares a string `it->key().ToString() < limit`, and so is not using the
    custom comparator. This example is part of the source so the gotcha has been propagated
    widely!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB网站上用于迭代的示例代码中展示了相同的错误，它比较一个字符串`it->key().ToString() < limit`，并且没有使用自定义比较器。这个例子是源代码的一部分，因此这个陷阱已经被广泛传播！
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The following summarizes this chapter’s techniques, in order of their dependencies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下总结了本章的技术，按其依赖关系排序。
- en: '**Add extra secondary (foreign) keys**:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加额外的二级（外键）**：'
- en: Gain extra search performance without having to read all content
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不读取所有内容的情况下获得额外的搜索性能
- en: Cost added code and disk space
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加了代码和磁盘空间的开销
- en: '**Refactoring data out into Multiple Keys**:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将数据重构到多个键中**：'
- en: Gains and Costs same as other extra keys
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他额外键的收益和成本相同
- en: Gain more stable main data not being rewritten
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得更多稳定的主数据，不会被重写
- en: Cost extra read overhead of initial key then going via another key (maybe the
    ID key) to the main data
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始键之后，通过另一个键（可能是ID键）到主数据时，增加了额外的读取开销
- en: '**Using ID keys to provide indirection to the main record**: Use this if you
    have multiple keys which need to refer to the same data and the primary key is
    long or changeable:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用ID键为主记录提供间接引用**：如果你有多个需要引用相同数据的键，并且主键很长或可变，请使用此方法：'
- en: Gains and Costs same as other extra keys
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他额外键的收益和成本相同
- en: Gain smaller indexes by smaller secondary keys
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过较小的二级键获得更小的索引
- en: Gain stability of secondary keys if the main value is updated with less dependency
    on changed items (such as use of nameId instead of full name)
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主值更新时对更改项的依赖性较小（例如使用nameId而不是全名），则获得二级键的稳定性
- en: Cost extra logic to generate unique ID values
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成唯一ID值时增加了额外的逻辑
- en: Cost extra read overhead even for the most common keys as they have to use the
    ID key to get the data
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使对于最常见的键，也需要额外的读取开销，因为它们必须使用ID键来获取数据
- en: '**Use multiple keys in pairs (graph database) style**: Use this when you have
    factored out a separate key to avoid frequently updated data being included in
    the main record:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以对（图数据库）风格使用多个键**：当你已经将一个单独的键因子化以避免频繁更新的数据包含在主记录中时使用此功能：'
- en: Cost added complexity to maintain keys
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护键增加了复杂性
- en: Cost index space doubled for paired key
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对键的成本索引空间加倍
- en: '**Endian flipping of integers in keys**: Use this when you have binary integer
    values in keys and care about their impact on sorting order but don’t want to
    use a custom comparator'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数键的端序翻转**：当你在键中有二进制整数值且关心它们对排序顺序的影响，但不想使用自定义比较器时使用此功能'
- en: '**Custom comparators (use)**: Reasons to use custom comparators are:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义比较器（使用）**：使用自定义比较器的理由包括：'
- en: Sorting needs custom logic such as locale dependencies like some European languages
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序需要自定义逻辑，例如依赖于地区依赖性，如某些欧洲语言
- en: If you want to use keys directly in the GUI so can’t tolerate the loss of information
    from preprocessing, such as forcing all incoming keys to lowercase
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在GUI中直接使用键，因此不能容忍预处理中信息丢失，例如强制所有传入键转换为小写
- en: If you can optimize the way the delta to the next key is calculated, a custom
    Comparator might save significant index space
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以优化计算下一个键的delta的方式，自定义比较器可能会节省大量的索引空间
- en: When the key contains significant data that should be ignored as it doesn’t
    aid sorting
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当键包含应被忽略的重要数据，因为它不帮助排序时
- en: '**Custom comparators (avoid)**: Reasons to avoid using custom comparators are:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义比较器（避免）**：避免使用自定义比较器的理由包括：'
- en: If you are using multiple languages or frameworks and some don’t have support
    for setting the comparator on database open
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用多种语言或框架，并且其中一些没有在数据库打开时设置比较器的支持
- en: When the database will be shared with others and you have no way to supply them
    with the comparator code
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据库将与其他人共享，而你又无法向他们提供比较器代码时
- en: We rounded out the `Sample06` GUI sample with more complex scenarios of editing
    and saving data. With the ability to flip the list between names and phones we
    saw again how a secondary index can be used in LevelDB. We also saw the burden
    of maintaining that index when data changes or it is deleted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过更多复杂的编辑和保存数据场景完善了`Sample06` GUI示例。有了在名称和电话之间翻转列表的能力，我们再次看到了二级索引在LevelDB中的应用。我们还看到了当数据更改或被删除时维护该索引的负担。
- en: After gaining a slightly painful awareness of how much work there is for just
    one table and two indexes, we took a more theoretical look at designing a key
    structure and learned how much more complex a database could have been used for
    `Sample06`. Schema support from APLevelDBSS was introduced to make using a complex
    key structure easier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在对仅一个表和两个索引的工作量有了一定的痛苦认识之后，我们更理论性地研究了设计键结构，并了解到数据库在`Sample06`中可以有多复杂。APLevelDBSS的架构支持被引入，以使使用复杂的键结构更加容易。
- en: Revisiting binary values in keys, we finished with a look at how comparators
    support binary values or just making the searching experience more user-friendly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾键中的二进制值，我们最后查看比较器如何支持二进制值或仅使搜索体验更加用户友好。
- en: In the next chapter, we will build a different real-world sample with a complex
    database using all these techniques and LevelDB extensions, tracking and finding
    documents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个使用所有这些技术和LevelDB扩展的复杂数据库的不同真实世界示例，跟踪和查找文档。
