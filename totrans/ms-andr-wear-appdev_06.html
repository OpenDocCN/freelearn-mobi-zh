<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6.  Contextual Notifications </h1></div></div></div><div><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p>
<em>"Life is about timing."</em>
</p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Carl Lewis</em></td></tr></table></div><p>In this chapter, we will discuss notifications in Android Wear. After a quick comparison between notifications in wearable and handheld devices, we will continue extending the <code class="literal">Today</code> app from the previous chapter to demonstrate the Android Wear notifications API.</p><div><h3 class="title"><a id="note12"/>Note</h3><p>The code accompanying this chapter is available for reference on GitHub (<a class="ulink" href="https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6">https://github.com/siddii/mastering-android-wear/tree/master/Chapter_6</a>). For the sake of brevity, only code snippets are included as needed. The reader is encouraged to download the referenced code from GitHub and follow along as they progress through the chapter.</p></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Getting notified</h1></div></div></div><p>It should come as no surprise that wearable devices are naturally superior to handheld devices in their capacity to deliver notifications to the user. With a handheld device, you hear a beep, and you need to draw your device out from your purse or pocket or whatever choice holster you snagged at that recent eBay auction.</p><p>But with a smartwatch, things are quite different. When you hear that beep, you simply glance at your wrist. This ease is a hallmark feature of wearable device technology.</p><p>And it doesn't end there. With the help of voice interactions, the user can act on that notification by issuing a recognizable voice command. The voice interactions API, of course, predates the Wear API and has been in use on handheld devices for some time. But there is no denying the immense value it brings to wearable devices, fitting in perfectly with that ease of access. We'll deal with voice interactions in the next chapter.</p><p>So central is the notification model to wearable devices that most tutorials often introduce notifications as the core use case of Android Wear; the other features come later. We, obviously, chose a different treatment in this book. Here we are, spanning the halfway point in our book as we encounter the first serious discussion on notifications.</p><p>We did that, because notification, no matter how important or central they may be, are still an application feature, and thus secondary to the core functionality of an app. Delving into notifications without the benefit of being exposed to the nuts and bolts of an Android Wear app, in our opinion, would be putting the cart before the horse.</p><p>You've seen the barebones <code class="literal">Today</code> app, and you've augmented it to work with a companion handheld app. That's some good exposure to the Wear API. Now, you're ready to build upon that knowledge. Rest assured, if you've followed along so far, you will not find the notifications API intimidating by any means.</p><p>Enough talk; let's begin by introducing the core classes in the API before we get to see them in action in our sample application.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec19"/>Core classes of the notifications API</h2></div></div></div><p>Here are the core classes of the notifications API that we will be using in our application.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec4"/>NotificationCompat.Builder</h3></div></div></div><p>One thing you want when working with notifications on wearable devices is some sort of assurance that your notifications appear acceptable on the significantly reduced scale of a smart watch. That is where the notification builder class comes in. This class takes care of displaying notifications properly, whether they appear on a handheld or wearable device.</p><p>To use the notification builder, you will have to add the following line to your <code class="literal">build.gradle</code> file:</p><pre class="programlisting">compile "com.android.support:support-v4:20.0.+" 
</pre><p>Then you'll need to import the following core classes from the support library:</p><pre class="programlisting">import android.support.v4.app.NotificationCompat; 
import android.support.v4.app.NotificationManagerCompat; 
import android.support.v4.app.NotificationCompat.WearableExtender; 
</pre><p>Creating a notification then becomes a matter of instantiating the <code class="literal">NotificationCompat.Builder</code> class and issuing the notification, as we will see in our sample application.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec5"/>Action buttons in your notification</h3></div></div></div><p>The <code class="literal">addAction</code> method lets you add an action to the notification. Simply pass in a <code class="literal">PendingIntent</code> instance to the <code class="literal">addAction</code> method. While this action appears on a handheld as an additional button attached to the notification, on a wearable device it appears as a large button when the user swipes the notification to the left. Tapping the action invokes the associated intent on the handheld.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec6"/>Wearable-only actions</h3></div></div></div><p>If you want the actions available on the wearable to be different than those on the handheld, use the <code class="literal">addAction</code> method on the <code class="literal">NotificationCompat.WearableExtender</code> class. Doing so ensures that the wearable does not display actions added to the <code class="literal">NotificationCompat.Builder.addAction</code> class.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec7"/>Delivery</h3></div></div></div><p>Use the <code class="literal">NotificationManagerCompat</code> API instead of <code class="literal">NotificationManager</code> to deliver your notification, shown as follows. This ensures compatibility with older platforms:</p><pre class="programlisting">// Get an instance of the NotificationManager service 
NotificationManagerCompat notificationManager = NotificationManagerCompat.from(mContext); 
 
// Issue the notification with notification manager 
notificationManager.notify(notificationId, notif); 
</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Today app with to-do notifications</h1></div></div></div><p>We are going to augment our <code class="literal">Today</code> app with a to-do activity that lets the user add to-do items and associate them with specific locations, such as home, or work. The locations then provide the context, which drives the notifications. This, in effect, makes our notifications <em>context-aware</em>.</p><p>For example, if the system detects that the user is in close proximity to the Home location, then to-do items associated with the <code class="literal">Home</code> category are presented to the user via the notifications API.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec20"/>Geofencing</h2></div></div></div><p>We'll be using the <code class="literal">Geofencing</code> API to figure out the location, that is, the context. In essence, this API lets us draw a circle of some agreed-upon radius around a coordinate. In effect, the latitude, longitude, and radius together define a <em>geofence</em>, a circular region around the coordinates of interest. Entrance and exit events signal when the device enters or exits the geofence location. An optional duration attribute delays the triggering of an event for that time interval once the device has entered and remained within the geofence.</p><p>You can study the <code class="literal">Geofencing</code> API in detail by visiting <a class="ulink" href="https://developer.android.com/training/location/geofencing.html">https://developer.android.com/training/location/geofencing.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec21"/>Mocking a GPS</h2></div></div></div><p>It is important to mention at the outset that it is not easy to simulate the location/GPS sensor behavior on a wearable device emulator, which all our sample code uses. A physical device equipped with GPS is needed for that. Furthermore, even if we did have access to a fully functional GPS, we could potentially run into frustrating scenarios testing our app—consider having to move physically to a different location in order to trigger the GPS sensors.</p><p>Hence, for the purposes of demonstrating context-aware notifications, we need a GPS mocking service that lets us use our wearable device emulator along with the physical handheld device, yet simulate different locations on demand.</p><p>This is where ByteRev's <strong>FakeGPS</strong> application comes into play (<a class="ulink" href="https://play.google.com/store/apps/details?id=com.lexa.fakegps&amp;hl=en">https://play.google.com/store/apps/details?id=com.lexa.fakegps&amp;hl=en</a>).</p><p>This free app lets us mock different locations and effectively gives us the equivalent experience of working with a fully functional GPS unit on a physical device. The downside is that the user may need to rerun the app in order to simulate the intended behavior. But that is an acceptable trade-off for flexibility.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec22"/>The build.gradle file on wear and mobile apps</h2></div></div></div><p>The <code class="literal">build.gradle</code> file of the mobile handheld app should contain the following line for location services:</p><pre class="programlisting">compile 'com.google.android.gms:play-services-location:9.0.2' 
</pre><p>Both wear and mobile apps should contain the following compile dependencies for notification support:</p><pre class="programlisting">compile 'com.android.support:support-v13:23.4.0' 
</pre><p>
</p><div><img src="img/image00185.jpeg" alt="The build.gradle file on wear and mobile apps"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec23"/>Handheld app's Android manifest file</h2></div></div></div><p>Note the permission grant that allows the app to access a precise location, that is, a latitude and longitude coordinate:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;manifest   
  package="com.siddique.androidwear.today"&gt; 
 
  &lt;uses-sdk  android:minSdkVersion = "18" android:targetSdkVersion="22"/&gt; 
 
  &lt;uses-permission  android:name = "android.permission.INTERNET"/&gt; 
 
  &lt;uses-permission  android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; 
 
&lt;application 
  android:allowBackup="true" 
  android:icon="@mipmap/ic_launcher" 
  android:label="@string/app_name" 
  android:supportsRtl="true" 
  android:theme="@style/AppTheme"&gt; 
  &lt;meta-data 
    android:name="com.google.android.gms.version" 
    android:value="@integer/google_play_services_version" 
  /&gt; 
 
  &lt;activity 
    android:name=".TodayMobileActivity" 
    android:configChanges="keyboardHidden|orientation|screenSize" 
    android:label="@string/app_name" 
    android:windowSoftInputMode="stateHidden"&gt; 
  &lt;/activity&gt; 
 
&lt;!— Listens for incoming messages from Wearable devices —&gt; 
  &lt;service android:name=".HandheldListenerService"&gt; 
    &lt;intent-filter&gt; 
 
      &lt;action  android:name="com.google.android.gms.wearable.DATA_CHANGED"/&gt; 
      &lt;action  android:name="com.google.android.gms.wearable.MESSAGE_RECEIVED"/&gt; 
 
      data 
        android:host="*" 
        android:pathPrefix="/today" 
        android:scheme="wear" /&gt; 
    &lt;/intent-filter&gt; 
  &lt;/service&gt; 
 
  &lt;activity 
    android:name=".TodoMobileActivity" 
    android:label="@string/title_activity_todo_mobile" 
    android:theme="@style/AppTheme.NoActionBar"&gt; 
    &lt;intent-filter&gt; 
      &lt;action android:name="android.intent.action.MAIN" /&gt; 
 
  &lt;category android:name="android.intent.category.LAUNCHER" /&gt; 
    &lt;/intent-filter&gt; 
  &lt;/activity&gt; 
 
  &lt;service 
    android:name=".GeofenceTransitionsIntentService" 
    android:exported="false"&gt; 
  &lt;/service&gt; 
  &lt;/application&gt; 
&lt;/manifest&gt; 
</pre><p>We added new activity called <code class="literal">TodoMobileActivity</code> to let us add to-do items. Since we will need to access the GPS sensor, the <code class="literal">ACCESS_FINE_LOCATION</code> permission becomes necessary to this new activity.</p><p>The <code class="literal">GeofenceTransitionsIntentService</code> service will react to the changes in location.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>The TodoMobileActivity class</h2></div></div></div><p>The <code class="literal">TodoMobileActivity</code> class is a simple activity that presents the user with a list view and capability to add to-do items. Each item added might be associated with a known set of locations (home or work), each of which is hardwired to a GPS coordinate:</p><pre class="programlisting">public class TodoMobileActivity extends AppCompatActivity implements GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener 
{ 
  private ListView mTaskListView; 
  private ArrayAdapter&lt;String&gt; mAdapter; 
 
    public static final String TAG =  TodoMobileActivity.class.getName(); 
  private List&lt;Geofence&gt; geofenceList; 
  private PendingIntent mGeofencePendingIntent;   private GoogleApiClient mGoogleApiClient; 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_todo_mobile); 
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); 
    setSupportActionBar(toolbar); 
 
    mTaskListView = (ListView) findViewById(R.id.list_todo);     refreshItems(); 
 
    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.addTodo); 
    if (fab != null) { 
    fab.setOnClickListener(new View.OnClickListener() 
    { 
      @Override       public void onClick(View view) 
      { 
        LayoutInflater inflater = (LayoutInflater)  getSystemService(Context.LAYOUT_INFLATER_SERVICE); 
        final View addTodoItemView =  inflater.inflate(R.layout.add_todo_item, null); 
 
        final Spinner spinner = (Spinner)  addTodoItemView.findViewById(R.id.todoItemType); 
        ArrayAdapter&lt;CharSequence&gt; adapter =  ArrayAdapter.createFromResource(TodoMobileActivity.this,  R.array.todoItemTypes, android.R.layout.simple_spinner_item); 
        adapter.setDropDownViewResource( android.R.layout.simple_spinner_dropdown_item); 
        spinner.setAdapter(adapter); 
 
        AlertDialog dialog = new  AlertDialog.Builder(TodoMobileActivity.this) 
       .setTitle("Add a new todo item")        .setView(addTodoItemView)        .setPositiveButton("Add", new  DialogInterface.OnClickListener() 
        { 
          @Override 
          public void onClick(DialogInterface dialog, int which) 
          { 
            EditText taskEditText = (EditText)  addTodoItemView.findViewById(R.id.todoItem); 
            Log.i(TAG, "Todo Item = " + taskEditText.getText()); 
 
            Spinner todoItemTypeSpinner = (Spinner)  addTodoItemView.findViewById(R.id.todoItemType); 
            String todoItemType = (String)  todoItemTypeSpinner.getSelectedItem(); 
            Log.i(TAG, "Todo Item type = " + todoItemType); 
 
            String task = String.valueOf(taskEditText.getText()); 
            Set&lt;String&gt; todoItems =  TodoItems.readItems(TodoMobileActivity.this, todoItemType);             todoItems.add(task); 
            TodoItems.saveItems(TodoMobileActivity.this, todoItemType, todoItems); 
            refreshItems(); 
          } 
        }) 
        .setNegativeButton("Cancel", null) 
        .create(); 
         dialog.show(); 
      } 
    }); 
  } 
 
  if(null == mGoogleApiClient) 
  { 
    mGoogleApiClient = new GoogleApiClient.Builder(this) 
    .addApi(LocationServices.API) 
    .addConnectionCallbacks(this) 
    .addOnConnectionFailedListener(this) 
    .build(); 
     Log.i(TAG, "GoogleApiClient created"); 
  } 
 
  if(!mGoogleApiClient.isConnected()) 
  { 
    mGoogleApiClient.connect(); 
    Log.i(TAG, "Connecting to GoogleApiClient.."); 
  } 
} 
 
private void createGeofences() 
{ 
  Log.i(TAG, "Creating geo fences"); 
  geofenceList = new ArrayList&lt;Geofence&gt;(); 
  geofenceList.add(new SimpleGeofence( 
    Constants.HOME_GEOFENCE_ID, 
    Constants.HOME_LATITUDE, 
    Constants.HOME_LONGITUDE).toGeofence()); 
 
  geofenceList.add(new SimpleGeofence( 
    Constants.WORK_GEOFENCE_ID, 
    Constants.WORK_LATITUDE, 
    Constants.WORK_LONGITUDE).toGeofence()); 
} 
 
private void refreshItems() 
{ 
  ArrayList&lt;String&gt; taskList = new ArrayList&lt;&gt;(); 
 
  String[] todoItemTypes = 
getResources().getStringArray(R.array.todoItemTypes); 
  for (String todoItemType : todoItemTypes) 
  { 
    Set&lt;String&gt; todoItems = TodoItems.readItems(this, 
todoItemType); 
    for (String todoItem : todoItems) 
    { 
      taskList.add(todoItemType + " - " + todoItem); 
    } 
  } 
 
  if (mAdapter == null) { 
    mAdapter = new ArrayAdapter&lt;&gt;(this, 
    R.layout.item_todo, 
    R.id.task_title, 
    taskList); 
    mTaskListView.setAdapter(mAdapter);   } 
  else 
  { 
    mAdapter.clear(); 
    mAdapter.addAll(taskList); 
    mAdapter.notifyDataSetChanged(); 
  } 
} 
 
public void deleteTodoItem(View view) 
{ 
  View parent = (View) view.getParent(); 
  TextView textView = (TextView)  parent.findViewById(R.id.task_title); 
 
  String removingItem = (String) textView.getText(); 
  Log.i(TAG, "Removing Item = " + removingItem); 
 
  String[] todoItemTypes =  getResources().getStringArray(R.array.todoItemTypes); 
  TodoItems.removeItem(this, todoItemTypes, removingItem); 
  refreshItems(); 
} 
 
@Override public void onConnected(@Nullable Bundle bundle) 
{ 
  if(mGoogleApiClient != null) 
  { 
    mGeofencePendingIntent = getGeofenceTransitionPendingIntent(); 
    createGeofences(); 
    Log.i(TAG, "Adding geofences to API location services"); 
     LocationServices.GeofencingApi.addGeofences(mGoogleApiClient, geofenceList,mGeofencePendingIntent);   } 
} 
 
private PendingIntent getGeofenceTransitionPendingIntent() 
{ 
  Intent intent = new Intent(this,  GeofenceTransitionsIntentService.class); 
  return PendingIntent.getService(this, 0, intent,  PendingIntent.FLAG_UPDATE_CURRENT); 
} 
 
@Override public void onConnectionSuspended(int i) 
{ 
  Log.i(TAG, "onConnectionSuspended called"); 
} 
 
@Override public void onConnectionFailed(@NonNull ConnectionResult connectionResult) 
{ 
  Log.i(TAG, "onConnectionFailed called");   } 
} 
</pre><p>Note that the <code class="literal">SimpleGeofence</code> class we use takes three arguments; it internally sets the radius to 50 meters. See the sample code on GitHub for more implementation details.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>To-do list view</h1></div></div></div><p>The following figure depicts what the to-do list view looks like. Users can add to-do items, and delete existing ones. Each item in the list is displayed, along with its location:</p><p>
</p><div><img src="img/image00186.jpeg" alt="To-do list view"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Adding to-do items</h1></div></div></div><p>The following image shows sample input for adding a new to-do item to the <code class="literal">Today-Todo</code> app:</p><p>
</p><div><img src="img/image00187.jpeg" alt="Adding to-do items"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>Mock locations</h2></div></div></div><p>You may have noticed that we chose to define two locations—home and work. Now, because we have high aspirations, we have ventured to build this app with the most deserving individual in mind, namely the President of the United States. So, that is why the home coordinates correspond to that of the White House, and the work coordinates correspond to that of Capitol Hill (Okay, bad example, we know. The President works in the Oval office in the west wing of the White House complex. But then, imagine how pointless our sample code would be if <code class="literal">Work</code> and <code class="literal">Home</code> had the same coordinates?). The <code class="literal">Constants</code> file with these values is shown in the following figure:</p><p>
</p><div><img src="img/image00188.jpeg" alt="Mock locations"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec26"/>Mocking locations using FakeGPS app</h2></div></div></div><p>Launch the FakeGPS app and search for the location <code class="literal">White House</code> as follows:</p><p>
</p><div><img src="img/image00189.jpeg" alt="Mocking locations using FakeGPS app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>After you tap the <strong>Set location</strong> button, FakeGPS will proceed to simulate the location we set. Take note of the latitude and longitude in the preceding figure. See how close they are to what we defined in <code class="literal">Constants.HOME_LATITUDE</code> and <code class="literal">Constants.HOME_LONGITUDE</code> in the <code class="literal">Constant</code> file:</p><p>
</p><div><img src="img/image00190.jpeg" alt="Mocking locations using FakeGPS app"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec27"/>The GeofenceTransitionIntentService class</h2></div></div></div><p>You may recall from the <code class="literal">TodoMobileActivity</code> activity, which we covered previously, that the <code class="literal">GeofenceIntentService</code> class will be called anytime there are changes in location. The <code class="literal">onHandleIntent</code> method is where we place code that will notify the user about any to-do items based on the <code class="literal">geofence</code> location that the user may have entered:</p><pre class="programlisting">public class GeofenceTransitionsIntentService extends IntentService 
{ 
  private static final String TAG =  GeofenceTransitionsIntentService.class.getName(); 
 
  public GeofenceTransitionsIntentService() 
  { 
    super(GeofenceTransitionsIntentService.class.getSimpleName()); 
  } 
 
  @Override 
  public void onCreate() 
  { 
    super.onCreate(); 
  }  
  /* 
  *Handles incoming intents.* 
  * @param intent The Intent sent by Location Services. This Intent is provided to Location 
  *Services (inside a PendingIntent) when addGeofences() is called. 
  */ 
  @Override 
  protected void onHandleIntent(Intent intent) 
  { 
    Log.i(TAG, "Location changed " + intent); 
    GeofencingEvent geoFenceEvent =  GeofencingEvent.fromIntent(intent); 
    if (geoFenceEvent.hasError()) 
    { 
      int errorCode = geoFenceEvent.getErrorCode(); 
      Log.e(TAG, "Location Services error: " + errorCode); 
    } 
    else 
    { 
      int transitionType = geoFenceEvent.getGeofenceTransition(); 
     // Get an instance of the NotificationManager service 
     NotificationManagerCompat notificationManager =  NotificationManagerCompat.from(this); 
 
    Log.i(TAG, "Notifying home todo items"); 
    String triggeredGeoFenceId =  geoFenceEvent.getTriggeringGeofences().get(0) 
   .getRequestId(); 
    switch (triggeredGeoFenceId) 
    { 
      case Constants.HOME_GEOFENCE_ID: 
      if (Geofence.GEOFENCE_TRANSITION_ENTER == transitionType)  
      { 
        Log.i(TAG, "Notifying home todo items"); 
        notifyTodoItems(notificationManager, "Home", Constants.HOME_TODO_NOTIFICATION_ID, R.drawable.white_house); 
      } 
      break; 
 
      case Constants.WORK_GEOFENCE_ID: 
        if (Geofence.GEOFENCE_TRANSITION_ENTER == transitionType) 
        { 
          Log.i(TAG, "Notifying work todo items"); 
          notifyTodoItems(notificationManager, "Work", Constants.WORK_TODO_NOTIFICATION_ID, R.drawable.capitol_hill); 
        } 
        break; 
      } 
    } 
  } 
 
  private void notifyTodoItems(NotificationManagerCompat notificationManager, String todoItemType, int notificationId, int background) 
{ 
  Set&lt;String&gt; todoItems = TodoItems.readItems(this, todoItemType); 
  Intent viewIntent = new Intent(this, TodoMobileActivity.class); 
  PendingIntent viewPendingIntent =  PendingIntent.getActivity(this, 0, viewIntent,  PendingIntent.FLAG_UPDATE_CURRENT); 
 
  NotificationCompat.Builder notificationBuilder =  new NotificationCompat.Builder(this) 
  .setSmallIcon(R.drawable.ic_today_notification) 
  .setLargeIcon(BitmapFactory.decodeResource( 
  getResources(), background)) 
  .setContentTitle(todoItems.size() + " " + todoItemType + " todo  items found!")   .setContentText(todoItems.toString()    ) 
  .setContentIntent(viewPendingIntent); 
 
// Build the notification and issues it with notification manager. 
  notificationManager.notify(notificationId,  notificationBuilder.build()); 
  } 
} 
</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec28"/>Handheld app notification</h2></div></div></div><p>The following figure shows a run of the application with FakeGPS app set to <code class="literal">Home</code>. See the notification display on the handheld device showing three to-do items tied to the Home location:</p><p>
</p><div><img src="img/image00191.jpeg" alt="Handheld app notification"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec29"/>Wearable app notifications</h2></div></div></div><p>The following figure shows the same notification on the wearable device:</p><p>
</p><div><img src="img/image00192.jpeg" alt="Wearable app notifications"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now, if we change the location in the FakeGPS app to <code class="literal">Capitol Hill</code> and relaunch the <code class="literal">Today-Todo</code> app, we get a different notification, as expected, in the wearable device, as shown in the following screenshot:</p><p>
</p><div><img src="img/image00193.jpeg" alt="Wearable app notifications"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we extended the <code class="literal">Today</code> app to have a to-do activity. We use that extension to demonstrate context-aware notifications using the <code class="literal">Notifications</code> API. The notifications were displayed on the mobile device as well as the wearable device emulator. We introduced the concept of geofencing and used the <code class="literal">Geofencing</code> API along with a FakeGPS app to simulate our location.</p></div></body></html>