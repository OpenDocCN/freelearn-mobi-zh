<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. AI and Logic</h1></div></div></div><p>In this chapter, we will cover the following points:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Processing AI waypoints</li><li class="listitem" style="list-style-type: disc">Firing projectiles at moving targets</li><li class="listitem" style="list-style-type: disc">AI line of sight</li><li class="listitem" style="list-style-type: disc">AI flocking using Boids</li><li class="listitem" style="list-style-type: disc">A* pathfinding on a grid</li><li class="listitem" style="list-style-type: disc">A* pathfinding in a Box2D world</li><li class="listitem" style="list-style-type: disc">A* pathfinding on a TMX tilemap</li><li class="listitem" style="list-style-type: disc">A* pathfinding in a side-scroller</li><li class="listitem" style="list-style-type: disc">Running a Lua script</li><li class="listitem" style="list-style-type: disc">Dynamically loading Lua scripts</li><li class="listitem" style="list-style-type: disc">Using Lua for dialogue trees</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Introduction</h1></div></div></div><p>All games that simulate intelligent behavior use a form of<strong> Artificial Intelligence</strong> (AI). Different techniques are used to simulate behavior for different gameplay requirements. In this chapter, we will implement a few of these techniques.<a id="id485" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Processing AI waypoints</h1></div></div></div><p>One of the most basic AI processes involves moving an AI actor around in a physical environment. To do this, we will create a<strong> queue</strong> of<strong> waypoints</strong>. Each waypoint represents the next position we want our actor to move to.<a id="id486" class="indexterm"/>
</p><div><img src="img/4002_07_01.jpg" alt="Processing AI waypoints"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec01"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.<a id="id487" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "GameWaypoint.h"
@interface GameActor : GameObject {
NSMutableArray *waypoints;
float runSpeed;
}
@end
@implementation GameActor
-(void) processWaypoints {
bool removeFirstWaypoint = NO;
//The actor's position onscreen
CGPoint worldPosition = CGPointMake(self.body-&gt;GetPosition().x * PTM_RATIO, self.body-&gt;GetPosition().y * PTM_RATIO);
//Process waypoints
for(GameWaypoint *wp in waypoints){
float distanceToNextPoint = [GameHelper distanceP1:worldPosition toP2:CGPointMake(wp.position.x, wp.position.y)];
//If we didn't make progress to the next point, increment timesBlocked
if(distanceToNextPoint &gt;= wp.lastDistance){
timesBlocked++;
//Drop this waypoint if we failed to move a number of times
if(timesBlocked &gt; TIMES_BLOCKED_FAIL){
distanceToNextPoint = 0.0f;
}
}else{
//If we are just starting toward this point we run our pre-callback
wp.lastDistance = distanceToNextPoint;
[wp processPreCallback];
}
//If we are close enough to the waypoint we move onto the next one
if(distanceToNextPoint &lt;= WAYPOINT_DIST_THRESHOLD){
removeFirstWaypoint = YES;
[self stopRunning];
//Run post callback
[wp processPostCallback];
}else{
//Keep running toward the waypoint
float speedMod = wp.speedMod;
//Slow down close to the waypoint
if(distanceToNextPoint &lt; [self runSpeed]/PTM_RATIO){
speedMod = (distanceToNextPoint)/([self runSpeed]/PTM_RATIO);
}
[self runWithVector:ccp(wp.position.x - worldPosition.x, wp.position.y - worldPosition.y) withSpeedMod:speedMod withConstrain:NO ];
break;
}
}
if(removeFirstWaypoint){
[waypoints removeObjectAtIndex:0];
timesBlocked = 0;
}
}
@end
@implementation Ch7_Waypoints
-(CCLayer*) runRecipe {
//Add polygons
[self addRandomPolygons:10];
//Create Actor
[self addActor];
/* CODE OMITTED */
return self;
}
-(void) step: (ccTime) dt {
[super step:dt];
//Process actor waypoints
[actor processWaypoints];
//Turn actor toward next waypoint
if(actor.waypoints.count &gt; 0){
CGPoint movementVector = ccp(actor.body-&gt;GetLinearVelocity().x, actor.body-&gt;GetLinearVelocity().y);
actor.body-&gt;SetTransform(actor.body-&gt;GetPosition(), -1 * [GameHelper vectorToRadians:movementVector] + PI_CONSTANT/2);
}
}
/* Draw all waypoint lines */
-(void) drawLayer {
glColor4ub(255,255,0,32);
CGPoint actorPosition = ccp(actor.body-&gt;GetPosition().x*PTM_RATIO, actor.body-&gt;GetPosition().y*PTM_RATIO);
if(actor.waypoints.count == 1){
GameWaypoint *gw = (GameWaypoint*)[actor.waypoints objectAtIndex:0];
ccDrawLine(actorPosition, gw.position);
}else if(actor.waypoints.count &gt; 1){
for(int i=0; i&lt;actor.waypoints.count-1; i++){
GameWaypoint *gw = (GameWaypoint*)[actor.waypoints objectAtIndex:i];
GameWaypoint *gwNext = (GameWaypoint*)[actor.waypoints objectAtIndex:i+1];
if(i == 0){
//From actor to first waypoint
ccDrawLine(actorPosition, gw.position);
ccDrawLine(gw.position, gwNext.position);
}else{
//From this waypoint to next one
ccDrawLine(gw.position, gwNext.position);
}
}
}
glColor4ub(255,255,255,255);
}
/* Add a new waypoint when you touch the screen */
-(void) tapWithPoint:(CGPoint)point {
ObjectCallback *goc1 = [ObjectCallback createWithObject:self withCallback:@"movingToWaypoint"];
ObjectCallback *goc2 = [ObjectCallback createWithObject:self withCallback:@"reachedWaypoint"];
GameWaypoint *wp = [GameWaypoint createWithPosition:[self convertTouchCoord:point] withSpeedMod:1.0f];
wp.preCallback = goc1;
wp.postCallback = goc2;
[actor addWaypoint:wp];
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec03"/>How it works...</h2></div></div></div><p>Waypoint processing involves moving the actor toward the next waypoint at every step. If the actor stops making progress toward the next point, that point is dropped.<a id="id488" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GameWaypoint:</code><p>The <code class="literal">GameWaypoint</code> class consists of a number of variables including, most importantly, the waypoint's position as well as how fast the actor should move toward that point.
<a id="id489" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc">Processing waypoints:<p>A list of <code class="literal">GameWaypoint</code> objects are stored in the <code class="literal">GameActor</code> class. The <code class="literal">processWaypoints</code> method is called in every frame. This moves the actor toward the next waypoint. The pseudocode for this process is as follows:
</p><div><pre class="programlisting">for all waypoints
if we didn't make progress, increment timesBlocked
if we have reached this waypoint we remove it and move to the next
else keep running toward this waypoint and break the loop
</pre></div><p>Using this basic logic, we move the actor toward each subsequent waypoint in 2D space.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">ObjectCallback:</code><p>Additional functionality is included to allow for method callbacks before and after the actor reaches specific waypoints. These use the <code class="literal">ObjectCallback</code> class that simply calls a method on an existing class using the following line:
<a id="id490" class="indexterm"/>
</p><div><pre class="programlisting">[preCallback.obj performSelector:NSSelectorFromString(preCallback.callback)];
</pre></div><p>This allows us to combine logic and AI character movement.
</p></li><li class="listitem" style="list-style-type: disc">Creating random polygons using the Convex Hull algorithm:<p>To populate our physical world with randomly generated polygons, we use the Monotone Chain Convex Hull algorithm to generate our polygon vertices:
<a id="id491" class="indexterm"/>
</p><div><pre class="programlisting">NSMutableArray *convexPolygon = [GameHelper convexHull:points];
</pre></div><p>This method takes in a set of randomly generated points and returns an array of vertices that surround these points. Although we have a fairly simple reason for using this, the algorithm has a number of other applications ranging from simple AI to advanced computer vision. More information about this algorithm can be found here: <a class="ulink" href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain</a>.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Firing projectiles at moving targets</h1></div></div></div><p>For AI actors to interact with their environment realistically, they must make calculations that human players make naturally. One common interaction involves firing a projectile at a moving target.<a id="id492" class="indexterm"/>
</p><div><img src="img/4002_07_02.jpg" alt="Firing projectiles at moving targets"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec04"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec05"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@implementation Ch7_ProjectileAiming
-(void) step: (ccTime) dt {
[super step:dt];
/* CODE OMITTED */
//Firing projectiles
fireCount += dt;
if(fireCount &gt; 1.0f){
fireCount = 0;
[self fireMissiles];
}
}
/* Each enemy fires a missile object */
-(void) fireMissiles {
for(int i=0; i&lt;enemies.count; i++){
GameActor *enemy = [enemies objectAtIndex:i];
//Create missile
GameMisc *missile = [[GameMisc alloc] init];
missile.gameArea = self;
missile.tag = GO_TAG_MISSILE;
missile.bodyDef-&gt;type = b2_dynamicBody;
missile.bodyDef-&gt;position.Set( enemy.body-&gt;GetPosition().x, enemy.body-&gt;GetPosition().y );
missile.bodyDef-&gt;userData = missile;
missile.body = world-&gt;CreateBody(missile.bodyDef);
missile.polygonShape = new b2PolygonShape();
missile.polygonShape-&gt;SetAsBox(0.5f, 0.2f);
missile.fixtureDef-&gt;density = 10.0f;
missile.fixtureDef-&gt;shape = missile.polygonShape;
missile.fixtureDef-&gt;filter.categoryBits = CB_MISSILE;
missile.fixtureDef-&gt;filter.maskBits = CB_EVERYTHING &amp; ~CB_MISSILE &amp; ~CB_ENEMY;
missile.body-&gt;CreateFixture(missile.fixtureDef);
//Calculate intercept trajectory
Vector3D *point = [self interceptSrc:missile dst:actor projSpeed:20.0f];
if(point){
//Align missile
CGPoint pointToFireAt = CGPointMake(point.x, point.y);
CGPoint directionVector = CGPointMake(pointToFireAt.x - missile.body-&gt;GetPosition().x, pointToFireAt.y - missile.body-&gt;GetPosition().y);
float radians = [GameHelper vectorToRadians:directionVector];
missile.body-&gt;SetTransform(missile.body-&gt;GetPosition(), -1 * radians + PI_CONSTANT/2);
//Fire missile
CGPoint normalVector = [GameHelper radiansToVector:radians];
missile.body-&gt;SetLinearVelocity( b2Vec2(normalVector.x*20.0f, normalVector.y*20.0f) );
}
[missiles addObject:missile];
}
}
/* Find the intercept angle given projectile speed and a moving target */
-(Vector3D*) interceptSrc:(GameObject*)src dst:(GameObject*)dst projSpeed:(float)projSpeed {
float tx = dst.body-&gt;GetPosition().x - src.body-&gt;GetPosition().x;
float ty = dst.body-&gt;GetPosition().y - src.body-&gt;GetPosition().y;
float tvx = dst.body-&gt;GetLinearVelocity().x;
float tvy = dst.body-&gt;GetLinearVelocity().y;
//Get quadratic equation components
float a = tvx*tvx + tvy*tvy - projSpeed*projSpeed;
float b = 2 * (tvx * tx + tvy * ty);
float c = tx*tx + ty*ty;
//Solve quadratic equation
Vector3D *ts = [GameHelper quadraticA:a B:b C:c];
//Find the smallest positive solution
Vector3D *solution = nil;
if(ts){
float t0 = ts.x;
float t1 = ts.y;
float t = MIN(t0,t1);
if(t &lt; 0){ t = MAX(t0,t1); }
if(t &gt; 0){
float x = dst.body-&gt;GetPosition().x + dst.body-&gt;GetLinearVelocity().x*t;
float y = dst.body-&gt;GetPosition().y + dst.body-&gt;GetLinearVelocity().y*t;
solution = [Vector3D x:x y:y z:0];
}
}
return solution;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec06"/>How it works...</h2></div></div></div><p>In this recipe, we create three enemy actors that fire projectiles at the player. Each projectile is fired with the speed and direction to hit the player even when it's moving.<a id="id493" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculating intercept trajectory:<p>If we are given the actor and enemy positions and velocities as well as how fast we can fire the projectile, we can then calculate the 'intercept angle' by creating a distance over time equation for both the player and the projectile. We then use the <strong>quadratic formula</strong> to find the time when these lines intersect. The formula is as follows:
<a id="id494" class="indexterm"/>
</p><div><pre class="programlisting">x = (-b +/- sqrt(b2 - 4ac)) / 2a
</pre></div><p>To get our a, b, and c variables we do the following, where <code class="literal">tx</code> and <code class="literal">ty</code> are position vector components and <code class="literal">tvx </code>and <code class="literal">tvy</code> are velocity vector components:
</p><div><pre class="programlisting">float a = tvx*tvx + tvy*tvy - projSpeed*projSpeed;
float b = 2 * (tvx * tx + tvy * ty);
float c = tx*tx + ty*ty;
</pre></div><p>We then use our <code class="literal">GameHelper</code> quadratic formula method:
</p><div><pre class="programlisting">Vector3D *ts = [GameHelper quadraticA:a B:b C:c];
</pre></div><p>The quadratic method returns a <code class="literal">Vector3D</code> object to conveniently store two float primitives inside an <code class="literal">NSObject</code>. If the object is nil, the formula's discriminant was <code class="literal">&lt;= 0.0f</code>. Otherwise we take the smallest non-zero solution. We use this to finally calculate the firing solution:
</p><div><pre class="programlisting">float x = dst.body-&gt;GetPosition().x + dst.body-&gt;GetLinearVelocity().x*t;
float y = dst.body-&gt;GetPosition().y + dst.body-&gt;GetLinearVelocity().y*t;
solution = [Vector3D x:x y:y z:0];
</pre></div><p>The projectile can be fired in this direction with the originally specified speed. If the moving target stays on course, the projectile will collide with it.
</p></li><li class="listitem" style="list-style-type: disc">Box2D filtering using Boolean algebra:<p>Like in Chapter 4, Physics, here we use category bits and mask bits to prevent certain physical object types from colliding. In this recipe, we expand our use of this technique by using the 'everything bit' <code class="literal">(0xFFFF) </code>as well as some more advanced Boolean logic:
</p><div><pre class="programlisting">missile.fixtureDef-&gt;filter.categoryBits = CB_MISSILE;
missile.fixtureDef-&gt;filter.maskBits = CB_EVERYTHING &amp; ~CB_MISSILE &amp; ~CB_ENEMY;
</pre></div><p>This keeps missiles from colliding with the enemy that fired them as well as from each other.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec04"/>AI line of sight</h1></div></div></div><p>Human beings employ five distinct senses to interact with the environment. One of these, vision, is its own branch of Computer Science entitled<strong> Computer Vision</strong>. In this example, we implement basic vision testing in a Box2D environment using a<strong> Ray Cast</strong> to see if there is another object in-between the player and an enemy AI actor.
</p><div><img src="img/4002_07_03.jpg" alt="AI line of sight"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec07"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec08"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">class RayCastAnyCallback : public b2RayCastCallback
{
public:
RayCastAnyCallback()
{
m_hit = false;
}
float32 ReportFixture( b2Fixture* fixture, const b2Vec2&amp; point,
const b2Vec2&amp; normal, float32 fraction)
{
b2Body* body = fixture-&gt;GetBody();
void* userData = body-&gt;GetUserData();
if (userData)
{
int32 index = *(int32*)userData;
if (index == 0)
{
// filter
return -1.0f;
}
}
m_hit = true;
m_point = point;
m_normal = normal;
m_fraction = fraction;
m_fixture = fixture;
return 0.0f;
}
bool m_hit;
b2Vec2 m_point;
b2Vec2 m_normal;
float32 m_fraction;
b2Fixture *m_fixture;
};
@implementation Ch7_LineOfSight
-(void) step: (ccTime) dt {
[super step:dt];
/* CODE OMITTED */
//Make the enemies follow the actor
[self followActorWithEnemies];
}
-(void) followActorWithEnemies {
//If enemies can see the actor they follow
for(int i=0; i&lt;enemies.count; i++){
//Align enemies
GameActor *enemy = [enemies objectAtIndex:i];
CGPoint directionVector = CGPointMake(actor.body-&gt;GetPosition().x - enemy.body-&gt;GetPosition().x, actor.body-&gt;GetPosition().y - enemy.body-&gt;GetPosition().y);
float radians = [GameHelper vectorToRadians:directionVector];
enemy.body-&gt;SetTransform(enemy.body-&gt;GetPosition(), -1 * radians + PI_CONSTANT/2);
RayCastClosestCallback callback;
world-&gt;RayCast(&amp;callback, enemy.body-&gt;GetPosition(), actor.body-&gt;GetPosition());
//Did the raycast hit anything?
enemy.tag = 0; //Assume it didn't
//Note that in this case we are using the 'tag' property for something other than its intended purpose.
if(callback.m_hit){
//Is the closest point the actor?
if(callback.m_fixture-&gt;GetBody() == actor.body){
//If so, follow the actor
b2Vec2 normal = b2Vec2( callback.m_normal.x * -5.0f, callback.m_normal.y * -5.0f);
enemy.body-&gt;ApplyForce(normal, actor.body-&gt;GetPosition());
enemy.tag = 1; //Set seeing flag to true
}
}
}
}
/* Draw each enemy 'sight line' if they can see you */
-(void) drawLayer {
for(int i=0; i&lt;enemies.count; i++){
GameActor *enemy = [enemies objectAtIndex:i];
if(enemy.tag == 1){
glColor4ub(255,255,0,32);
CGPoint actorPosition = ccp(actor.body-&gt;GetPosition().x*PTM_RATIO, actor.body-&gt;GetPosition().y*PTM_RATIO);
CGPoint enemyPosition = ccp(enemy.body-&gt;GetPosition().x*PTM_RATIO, enemy.body-&gt;GetPosition().y*PTM_RATIO);
ccDrawLine(actorPosition, enemyPosition);
glColor4ub(255,255,255,255);
}
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec09"/>How it works...</h2></div></div></div><p>When a line can be drawn between an enemy actor and the player without going through level geometry, then we consider the player to be visible to the enemy and the enemy then begins to follow the player.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using<code class="literal"> RayCastClosest:</code><p>We use the following method to perform a ray test against our Box2D world:
</p><div><pre class="programlisting">RayCastClosestCallback callback;
world-&gt;RayCast(&amp;callback, enemy.body-&gt;GetPosition(), actor.body-&gt;GetPosition());
</pre></div><p>The class <code class="literal">RayCastClosestCallback</code> wraps the class <code class="literal">b2RayCastCallback</code>. When we call the <code class="literal">RayCast</code> method and pass in an instance of this class, we are then able to tell whether or not our ray touched a Box2D fixture. It also maintains a pointer to the first fixture it touches. This is the closest fixture to our source point.
</p></li><li class="listitem" style="list-style-type: disc">Filtering out the first fixture found:<p>Because ray casts most often involve casting from inside one fixture to another, the first fixture found is filtered out.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">RayCast.h:</code><p>Our <code class="literal">RayCast.h</code> file also contains the classes <code class="literal">RayCastAnyCallback</code> and <code class="literal">RayCastMultipleCallback</code>. The any class finds any fixture along the ray while the <code class="literal">multiple</code> class maintains a list of fixtures.
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec10"/>There's more...</h2></div></div></div><p>There are many uses for ray casts. One simple example is a cover mechanic. When an enemy feels vulnerable, it can find the nearest fixture that the player can't see through. Another use involves using the<strong> normal</strong> point returned by the ray cast. This is the exact point of collision with the specified fixture. This can be used to create laser weapons or instant bullet impacts.
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec05"/>AI flocking using Boids</h1></div></div></div><p>By placing many more enemies in a game we begin to require some group-based AI. A popular algorithm used in both video games and films is the<strong> Boids</strong> algorithm. It simulates<strong> flocking</strong> behavior. In this recipe, we will create a large number of enemies who flock together and chase the player.<a id="id495" class="indexterm"/>
</p><div><img src="img/4002_07_04.jpg" alt="AI flocking using Boids"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec11"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec12"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@interface Ch7_AIFlocking : Ch7_LineOfSight {}
/* CODE OMITTED */
@end
@implementation Ch7_AIFlocking
-(void) step:(ccTime)delta {
[super step:delta];
//Process the 'boids' flocking algorithm
[self processBoids];
}
/* Make the flock of 'boids' follow the actor */
-(void) followActorWithEnemies {
//All enemies constantly follow the actor
for(int i=0; i&lt;enemies.count; i++){
//Align enemies
GameActor *enemy = [enemies objectAtIndex:i];
CGPoint directionVector = CGPointMake(actor.body-&gt;GetPosition().x - enemy.body-&gt;GetPosition().x, actor.body-&gt;GetPosition().y - enemy.body-&gt;GetPosition().y);
float radians = [GameHelper vectorToRadians:directionVector];
enemy.body-&gt;SetTransform(enemy.body-&gt;GetPosition(), -1 * radians + PI_CONSTANT/2);
b2Vec2 normal = actor.body-&gt;GetPosition() - enemy.body-&gt;GetPosition();
CGPoint vector = ccp(normal.x, normal.y);
CGPoint normalVector = [GameHelper radiansToVector:[GameHelper vectorToRadians:vector]];
//If so, follow the actor
b2Vec2 v = enemy.body-&gt;GetLinearVelocity();
enemy.body-&gt;SetLinearVelocity(b2Vec2(v.x + normalVector.x*0.2f, v.y + normalVector.y*0.2f));
}
}
/* Process boids algorithm */
-(void) processBoids {
for(int i=0; i&lt;enemies.count; i++){
GameActor *b = [enemies objectAtIndex:i];
b2Vec2 v1 = b2Vec2(0,0);
b2Vec2 v2 = b2Vec2(0,0);
b2Vec2 v3 = b2Vec2(0,0);
v1 = [self boidRule1:b];
v2 = [self boidRule2:b];
v3 = [self boidRule3:b];
b2Vec2 v = b.body-&gt;GetLinearVelocity();
b2Vec2 newV = v+v1+v2+v3;
/* Limit velocity */
float vLimit = 7.5f;
b2Vec2 absV = b2Vec2([GameHelper absoluteValue:newV.x], [GameHelper absoluteValue:newV.y]);
if(absV.x &gt; vLimit || absV.y &gt; vLimit){
float ratio;
if(absV.x &gt; absV.y){
ratio = vLimit / absV.x;
}else{
ratio = vLimit / absV.y;
}
newV = b2Vec2( newV.x*ratio, newV.y*ratio );
}
b.body-&gt;SetLinearVelocity(newV);
}
}
/* Clump the Boids together */
-(b2Vec2) boidRule1:(GameActor*)bJ {
//The variable 'pcJ' represents the center point of the flock
b2Vec2 pcJ = b2Vec2(0,0);
float N = enemies.count;
//Add up all positions
for(int i=0; i&lt;enemies.count; i++){
GameActor *b = [enemies objectAtIndex:i];
if(b != bJ){
pcJ += b.body-&gt;GetPosition();
}
}
//Average them out
pcJ = b2Vec2(pcJ.x/(N-1), pcJ.y/(N-1));
//Return 1/100 of the velocity required to move to this point
return b2Vec2( (pcJ.x - bJ.body-&gt;GetPosition().x)/100.0f, (pcJ.y - bJ.body-&gt;GetPosition().y)/100.0f );
}
/* Keep the Boids apart from each other */
-(b2Vec2) boidRule2:(GameActor*)bJ {
//Set optimal distance boids should keep between themselves (padding)
float padding = 1.5f;
//The variable 'c' represents the velocity required to move away from any other boids in this one's personal space
b2Vec2 c = b2Vec2(0,0);
//If an ememy is too close we add velocity required to move away from it
for(int i=0; i&lt;enemies.count; i++){
GameActor *b = [enemies objectAtIndex:i];
if(b != bJ){
CGPoint bPos = ccp(b.body-&gt;GetPosition().x, b.body-&gt;GetPosition().y);
CGPoint bJPos = ccp(bJ.body-&gt;GetPosition().x, bJ.body-&gt;GetPosition().y);
if([GameHelper distanceP1:bPos toP2:bJPos] &lt; padding){
c = c - (b.body-&gt;GetPosition() - bJ.body-&gt;GetPosition());
}
}
}
return c;
}
/* Match up all Boid velocities */
-(b2Vec2) boidRule3:(GameActor*)bJ {
//The variable 'pvJ' represents the total velocity of all the boids combined
b2Vec2 pvJ = b2Vec2(0,0);
//Get the total velocity
for(int i=0; i&lt;enemies.count; i++){
GameActor *b = [enemies objectAtIndex:i];
if(b != bJ){
pvJ += b.body-&gt;GetLinearVelocity();
}
}
//Get this boid's velocity
b2Vec2 v = bJ.body-&gt;GetLinearVelocity();
//Return the difference averaged out over the flock then divided by 30
return b2Vec2((pvJ.x - v.x)/30.0f/enemies.count, (pvJ.y - v.y)/30.0f/enemies.count);
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec13"/>How it works...</h2></div></div></div><p>The Boids algorithm uses a few simple concepts to create realistic actor flocking. It uses three rules that act on each actor's velocity in each frame. These adjust their behavior to maintain flocking without overpowering other forces.<a id="id496" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Boids rule 1—keeping</strong> the flock together:<p>To keep the flock of actors together we first get the center of mass of the flock by averaging all actor positions. We then adjust actor velocity to move each actor 1 percent toward the center of the flock.
</p></li><li class="listitem" style="list-style-type: disc"><strong>Boids rule 2—give</strong> the actors some personal space:<p>To keep the flock from clumping together too much, we inspect each actor. If there are other actors within a certain threshold of space, then we move this actor that distance away from the other actor. When this is applied across all actors, a nice equilibrium arises.
</p></li><li class="listitem" style="list-style-type: disc"><strong>Boids rule 3—match</strong> all actor velocities:<p>Finally, all actors should move together at roughly the same pace. In rule 1, we averaged all actor positions. In this rule we average all velocities then add a fraction (1/30) of that velocity to each actor. This ensures the uniform movement speed of all the actors.
</p></li><li class="listitem" style="list-style-type: disc">Moving the actors toward the player:<p>Moving the enemy actors toward the player involves finding a normalized vector in the direction of the player and then adding that vector with a certain magnitude to the actor's linear velocity:
</p><div><pre class="programlisting">enemy.body-&gt;SetLinearVelocity(b2Vec2(v.x + normalVector.x*0.2f, v.y + normalVector.y*0.2f));
</pre></div><p>We also limit the velocity of each actor so they don't go careening off in a direction too quickly:
</p><div><pre class="programlisting">float vLimit = 7.5f;
b2Vec2 absV = b2Vec2([GameHelper absoluteValue:newV.x], [GameHelper absoluteValue:newV.y]);
if(absV.x &gt; vLimit || absV.y &gt; vLimit){
float ratio;
if(absV.x &gt; absV.y){
ratio = vLimit / absV.x;
}else{
ratio = vLimit / absV.y;
}
newV = b2Vec2( newV.x*ratio, newV.y*ratio );
}
b.body-&gt;SetLinearVelocity(newV);
</pre></div><p>When all these methods are combined, we get a realistic flocking effect that works for a swarm of birds, bees, or even zombies.
<a id="id497" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec06"/>A* pathfinding on a grid</h1></div></div></div><p>A classic video game problem is that of pathfinding. Intelligent actors are often required to navigate around obstacles during gameplay. The<strong> A* search algorithm</strong> (also known as<strong> A Star)</strong> is commonly used to solve pathfinding by efficiently traversing a constructed node graph. In this recipe, we will demonstrate grid-based A* pathfinding.<a id="id498" class="indexterm"/>
</p><div><img src="img/4002_07_05.jpg" alt="A* pathfinding on a grid"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec14"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec15"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id499" class="indexterm"/>
</p><div><pre class="programlisting">/* AStarNode */
@interface AStarNode : NSObject
{
CGPoint position; //The node's position on our map
NSMutableArray *neighbors; //An array of neighbor AStarNode objects
bool active; //Is this node active?
float costMultiplier; //Use this to multiply the normal cost to reach this node.
}
@end
@implementation AStarNode
/* Cost to node heuristic */
-(float) costToNode:(AStarNode*)node {
CGPoint src = ccp(self.position.x, self.position.y);
CGPoint dst = ccp(node.position.x, node.position.y);
float cost = [GameHelper distanceP1:src toP2:dst] * node.costMultiplier;
return cost;
}
@end
/* AStarPathNode */
@interface AStarPathNode : NSObject
{
AStarNode *node; //The actual node this "path" node points to
AStarPathNode *previous; //The previous node on our path
float cost; //The cumulative cost of reaching this node
}
@end
@implementation AStarPathNode
/* Our implementation of the A* search algorithm */
+(NSMutableArray*) findPathFrom:(AStarNode*)fromNode to:(AStarNode*)toNode {
NSMutableArray *foundPath = [[NSMutableArray alloc] init];
if(fromNode.position.x == toNode.position.x &amp;&amp; fromNode.position.y == toNode.position.y){
return nil;
}
NSMutableArray *openList = [[[NSMutableArray alloc] init] autorelease];
NSMutableArray *closedList = [[[NSMutableArray alloc] init] autorelease];
AStarPathNode *currentNode = nil;
AStarPathNode *aNode = nil;
AStarPathNode *startNode = [AStarPathNode createWithAStarNode:fromNode];
AStarPathNode *endNode = [AStarPathNode createWithAStarNode:toNode];
[openList addObject:startNode];
while(openList.count &gt; 0){
currentNode = [AStarPathNode lowestCostNodeInArray:openList];
if( currentNode.node.position.x == endNode.node.position.x &amp;&amp;
currentNode.node.position.y == endNode.node.position.y){
//Path Found!
aNode = currentNode;
while(aNode.previous != nil){
//Mark path
[foundPath addObject:[NSValue valueWithCGPoint: CGPointMake(aNode.node.position.x, aNode.node.position.y)]];
aNode = aNode.previous;
}
[foundPath addObject:[NSValue valueWithCGPoint: CGPointMake(aNode.node.position.x, aNode.node.position.y)]];
return foundPath;
}else{
//Still searching
[closedList addObject:currentNode];
[openList removeObject:currentNode];
for(int i=0; i&lt;currentNode.node.neighbors.count; i++){
AStarPathNode *aNode = [AStarPathNode createWithAStarNode:[currentNode.node.neighbors objectAtIndex:i]];
aNode.cost = currentNode.cost + [currentNode.node costToNode:aNode.node] + [aNode.node costToNode:endNode.node];
aNode.previous = currentNode;
if(aNode.node.active &amp;&amp; ![AStarPathNode isPathNode:aNode inList:openList] &amp;&amp; ![AStarPathNode isPathNode:aNode inList:closedList]){
[openList addObject:aNode];
}
}
}
}
//No Path Found
return nil;
}
@end
/* Ch7_GridPathfinding */
@implementation Ch7_GridPathfinding
-(CCLayer*) runRecipe {
//Initial variables
gridSize = ccp(25,15);
nodeSpace = 16.0f;
touchedNode = ccp(0,0);
startCoord = ccp(2,2);
endCoord = ccp(gridSize.x-3, gridSize.y-3);
foundPath = [[NSMutableArray alloc] init];
//Create 2D array (grid)
grid = [[NSMutableArray alloc] initWithCapacity:((int)gridSize.x)];
for(int x=0; x&lt;gridSize.x; x++){
[grid addObject:[[NSMutableArray alloc] initWithCapacity:((int)gridSize.y)]];
}
//Create AStar nodes and place them in the grid
for(int x=0; x&lt;gridSize.x; x++){
for(int y=0; y&lt;gridSize.y; y++){
//Add a node
AStarNode *node = [[AStarNode alloc] init];
node.position = ccp(x*nodeSpace + nodeSpace/2, y*nodeSpace + nodeSpace/2);
[[grid objectAtIndex:x] addObject:node];
}
}
//Add neighbor nodes
for(int x=0; x&lt;gridSize.x; x++){
for(int y=0; y&lt;gridSize.y; y++){
//Add a node
AStarNode *node = [[grid objectAtIndex:x] objectAtIndex:y];
//Add self as neighbor to neighboring nodes
[self addNeighbor:node toGridNodeX:x-1 Y:y-1]; //Top-Left
[self addNeighbor:node toGridNodeX:x-1 Y:y]; //Left
[self addNeighbor:node toGridNodeX:x-1 Y:y+1]; //Bottom-Left
[self addNeighbor:node toGridNodeX:x Y:y-1]; //Top
[self addNeighbor:node toGridNodeX:x Y:y+1]; //Bottom
[self addNeighbor:node toGridNodeX:x+1 Y:y-1]; //Top-Right
[self addNeighbor:node toGridNodeX:x+1 Y:y]; //Right
[self addNeighbor:node toGridNodeX:x+1 Y:y+1]; //Bottom-Right
}
}
/* CODE OMITTED */
return self;
}
/* Find a path from the startNode to the endNode */
-(void) findPath:(id)sender {
AStarNode *startNode = [[grid objectAtIndex:(int)startCoord.x] objectAtIndex:(int)startCoord.y];
AStarNode *endNode = [[grid objectAtIndex:(int)endCoord.x] objectAtIndex:endCoord.y];
if(foundPath){
[foundPath removeAllObjects];
[foundPath release];
}
foundPath = nil;
//Run the pathfinding algorithm
foundPath = [AStarPathNode findPathFrom:startNode to:endNode];
if(!foundPath){
[self showMessage:@"No Path Found"];
}else{
[self showMessage:@"Found Path"];
}
}
/* Helper method for adding neighbor nodes */
-(void) addNeighbor:(AStarNode*)node toGridNodeX:(int)x Y:(int)y {
if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; gridSize.x &amp;&amp; y &lt; gridSize.y){
AStarNode *neighbor = [[grid objectAtIndex:x] objectAtIndex:y];
[node.neighbors addObject:neighbor];
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec16"/>How it works...</h2></div></div></div><p>The A* algorithm uses a heuristic to perform a best-first search over a node graph. First, we must create this node graph.<a id="id500" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AStarNode:</code><a id="id501" class="indexterm"/><p>The node graph consists of a collection of nodes, each representing a real world position. This is encapsulated within the <code class="literal">AStarNode</code> class.
</p></li><li class="listitem" style="list-style-type: disc">Storing the nodes:<p>For this recipe, we store our nodes in a nested 2D <code class="literal">NSArray</code> structure. This is not required by the A* algorithm, but, merely a convention used to store the nodes. With this structure, we can quickly identify the closest <code class="literal">AStarNode</code> to a point. We can also link the nodes to each other in a simple, logical way.
</p></li><li class="listitem" style="list-style-type: disc">Connecting the nodes:<p>Nodes are connected to each other by having each one maintain a list of its neighboring nodes. In this grid setup, each node links to eight other nodes in eight different directions. To remove diagonal movement, nodes would only be connected in four directions instead of eight.
</p></li><li class="listitem" style="list-style-type: disc">Creating 'walls':<p>In this recipe, darker colored 'walls' represent non-navigable areas. These nodes are simply set to <code class="literal">active = NO</code>. When the A* algorithm is run, they are skipped over.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">AStarPathNode:</code><a id="id502" class="indexterm"/><p>The data structure used to find and store the optimal path is a linked list of <code class="literal">AStarPathNode</code> objects. This class stores a node, the previous node, and a total estimated cost to the goal from this node.
</p></li><li class="listitem" style="list-style-type: disc">Finding the path:<p>Once our nodes are created and linked up, we call the following method to find a path:
</p><div><pre class="programlisting">+(NSMutableArray*) findPathFrom:(AStarNode*)fromNode to:(AStarNode*)toNode;
</pre></div><p>This performs a <strong>greedy best-first</strong> search for the best path. The greedy heuristic used is the simple absolute "as the crow flies" distance to the goal:
</p><div><pre class="programlisting">/* Cost to node heuristic */
-(float) costToNode:(AStarNode*)node {
CGPoint src = ccp(self.position.x, self.position.y);
CGPoint dst = ccp(node.position.x, node.position.y);
float cost = [GameHelper distanceP1:src toP2:dst] * node.costMultiplier;
return cost;
}
</pre></div><p>Depending on assumptions relating to the construction of the node graph and how it relates to movement costs, other heuristics can be used. For example, a slight improvement might be to use the diagonal distance to the goal across the nodes instead of the absolute 2D space distance. If we disabled diagonal movement, then we would want to use the Manhattan heuristic to estimate movement cost on a grid.
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec17"/>There's more...</h2></div></div></div><p>The<code class="literal"> AStarNode</code> class contains a<code class="literal"> costModifier</code> variable. This can be used to increase the relative cost to this specific node. A node with an increased movement cost could represent rough terrain like mud or shallow water. Other AI concepts could also be mixed into the pathfinding algorithm. For example, a specific area or group of nodes could be considered more dangerous than others. AI actors would then have to weigh speed versus danger when determining a path.<a id="id503" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec07"/>A* pathfinding in a Box2D world</h1></div></div></div><p>The real fun of the A* algorithm comes from applying it to more complex scenarios. In this recipe, we will apply the grid-based technique of the last recipe to a Box2D world filled with randomly generated polygons.<a id="id504" class="indexterm"/>
</p><div><img src="img/4002_07_06.jpg" alt="A* pathfinding in a Box2D world"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec18"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.<a id="id505" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec19"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">@interface Ch7_Box2DPathfinding : GameArea2D
{
NSMutableArray *grid;
float nodeSpace; //The space between each node, increase this to increase A* efficiency at the cost of accuracy
int gridSizeX;
int gridSizeY;
}
@end
@implementation Ch7_Box2DPathfinding
-(CCLayer*) runRecipe {
//Initial variables
nodeSpace = 32.0f;
actorRadius = nodeSpace/PTM_RATIO/3;
/* CODE OMITTED */
//Remove neighbors from positive TestPoint and RayCast tests
for(int x=0; x&lt;gridSizeX; x++){
for(int y=0; y&lt;gridSizeY; y++){
//Add a node
AStarNode *node = [[grid objectAtIndex:x] objectAtIndex:y];
//If a node itself is colliding with an object we cut off all connections
for (b2Body* b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()){
if (b-&gt;GetUserData() != NULL) {
GameObject *obj = (GameObject*)b-&gt;GetUserData();
if(obj-&gt;polygonShape){
b2Vec2 nodePosition = b2Vec2(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);
//Test this node point against this polygon
if(obj-&gt;polygonShape-&gt;TestPoint(b-&gt;GetTransform(), nodePosition)){
for(int i=0; i&lt;node.neighbors.count; i++){
//Remove connections
AStarNode *neighbor = [node.neighbors objectAtIndex:i];
[node.neighbors removeObject:neighbor];
[neighbor.neighbors removeObject:node];
}
}
}
}
}
//Test all node to neighbor connections using a RayCast test
for(int i=0; i&lt;node.neighbors.count; i++){
AStarNode *neighbor = [node.neighbors objectAtIndex:i];
//Do a RayCast from the node to the neighbor.
//If there is something in the way, remove the link
b2Vec2 nodeP = b2Vec2(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);
b2Vec2 neighborP = b2Vec2(neighbor.position.x/PTM_RATIO, neighbor.position.y/PTM_RATIO);
//Do 4 tests (based on actor size)
for(float x = -actorRadius; x &lt;= actorRadius; x+= actorRadius*2){
for(float y = -actorRadius; y &lt;= actorRadius; y+= actorRadius*2){
RayCastAnyCallback callback;
world-&gt;RayCast(&amp;callback, b2Vec2(nodeP.x+x,nodeP.y+y), b2Vec2(neighborP.x+x,neighborP.y+y));
if(callback.m_hit){
//Remove connections
[node.neighbors removeObject:neighbor];
[neighbor.neighbors removeObject:node];
break; break;
}
}
}
}
}
}
return self;
}
/* Find a path and add it (as a set of waypoints) when we tap the screen */
-(void) tapWithPoint:(CGPoint)point {
//Convert touch coordinate to physical coordinate
CGPoint endPoint = [self convertTouchCoord:point];
if(endPoint.x &lt; 0 || endPoint.y &lt; 0 || endPoint.x &gt;= gameAreaSize.x*PTM_RATIO || endPoint.y &gt;= gameAreaSize.y*PTM_RATIO){
return;
}
//Actor position
CGPoint actorPosition = ccp(actor.body-&gt;GetPosition().x*PTM_RATIO, actor.body-&gt;GetPosition().y*PTM_RATIO);
//We use the last waypoint position if applicable
if(actor.waypoints.count &gt; 0){
actorPosition = [[actor.waypoints objectAtIndex:actor.waypoints.count-1] position];
}
//Starting node
AStarNode *startNode = [[grid objectAtIndex:(int)(actorPosition.x/nodeSpace)] objectAtIndex:(int)(actorPosition.y/nodeSpace)];
//Make sure the start node is actually properly connected
if(startNode.neighbors.count == 0){
bool found = NO; float n = 1;
while(!found){
//Search the nodes around this point for a properly connected starting node
for(float x = -n; x&lt;= n; x+= n){
for(float y = -n; y&lt;= n; y+= n){
if(x == 0 &amp;&amp; y == 0){ continue; }
float xIndex = ((int)(actorPosition.x/nodeSpace))+x;
float yIndex = ((int)(actorPosition.y/nodeSpace))+y;
if(xIndex &gt;= 0 &amp;&amp; yIndex &gt;= 0 &amp;&amp; xIndex &lt; gridSizeX &amp;&amp; yIndex &lt; gridSizeY){
AStarNode *node = [[grid objectAtIndex:xIndex] objectAtIndex:yIndex];
if(node.neighbors.count &gt; 0){
startNode = node;
found = YES;
break; break;
}
}
}
}
n += 1;
}
}
//End node
AStarNode *endNode = [[grid objectAtIndex:(int)(endPoint.x/nodeSpace)] objectAtIndex:(int)(endPoint.y/nodeSpace)];
//Run the pathfinding algorithm
NSMutableArray *foundPath = [AStarPathNode findPathFrom:startNode to:endNode];
if(!foundPath){
[self showMessage:@"No Path Found"];
}else{
[self showMessage:@"Found Path"];
//Add found path as a waypoint set to the actor
for(int i=foundPath.count-1; i&gt;=0; i--){
CGPoint pathPoint = [[foundPath objectAtIndex:i] CGPointValue];
[actor addWaypoint:[GameWaypoint createWithPosition:pathPoint withSpeedMod:1.0f]];
}
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec20"/>How it works...</h2></div></div></div><p>Just like in the last recipe, we first create a 2D nested<code class="literal"> NSArray</code> container for our<code class="literal"> AStarNode</code> objects. After linking all the nodes together, we need to adjust the graph to accurately reflect the 2D geometry in the Box2D world.<a id="id506" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Culling neighbor nodes:<p>To properly represent 2D world geometry we need to cull edges of the node graph that lead into these static fixtures. To do this, we first find all nodes that are located inside a shape. This involves using the following method:
</p><div><pre class="programlisting">obj-&gt;polygonShape-&gt;TestPoint(b-&gt;GetTransform(), nodePosition);
</pre></div></li><li class="listitem" style="list-style-type: disc">This will return whether or not that point exists within the shape. If so, we cut off all connections to this node. In addition to this, we also do ray cast tests for each neighbor connection:<div><pre class="programlisting">world-&gt;RayCast(&amp;callback, b2Vec2(nodeP.x+x,nodeP.y+y), b2Vec2(neighborP.x+x,neighborP.y+y));
</pre></div></li><li class="listitem" style="list-style-type: disc">Four tests are performed for each connection. We do this to approximate the actor's circular shape. If this ray cast hits a fixture, we remove the connection.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec21"/>There's more...</h2></div></div></div><p>This technique works well for a small level. However, generating a node graph for a large level can possibly be a very time consuming process.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Speeding up load times:<a id="id507" class="indexterm"/><p>To decrease map load times, neighbor culling should be done by the level editor and the neighbor connections should be stored in the map file along with the nodes and the geometry. We do this at run time within our application to give you an idea of the process without having to create a Cocos2d level editor that implements this technique.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec08"/>A* pathfinding on a TMX tilemap</h1></div></div></div><p>If you've skipped ahead to<a class="link" href="ch08.html" title="Chapter 8. Tips, Tools, and Ports"> Chapter 8</a>,<em> Tips, Tools, and Ports</em>, you'll see a recipe showing how to use the Tiled application with the TMX tilemap toolset. In this recipe, we create a 2.5D adventure game. To see our grid based pathfinding technique in action, we overload the<a class="link" href="ch08.html" title="Chapter 8. Tips, Tools, and Ports"> Chapter 8</a>,<em> Tips, Tools, and Ports</em> recipe entitled<em> Creating levels using Tiled</em>.<a id="id508" class="indexterm"/>
</p><div><img src="img/4002_07_07.jpg" alt="A* pathfinding on a TMX tilemap"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec22"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec23"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id509" class="indexterm"/>
</p><div><pre class="programlisting">@interface Ch7_TileMapPathfinding : Ch8_TMXTilemap
{
NSMutableArray *grid;
float actorRadius;
}
@end
@implementation Ch7_TileMapPathfinding
-(CCLayer*) runRecipe {
//Shorter variable names
float mw = tileMap.mapSize.width;
float mh = tileMap.mapSize.height;
float tw = tileMap.tileSize.width;
float th = tileMap.tileSize.height;
/* CODE OMITTED */
//Create active and inactive nodes determined by the "Collidable" TMX layer
CCTMXLayer *collidableLayer = [tileMap layerNamed:@"Collidable"];
for(int x=0; x&lt;mw; x++){
for(int y=0; y&lt;mh; y++){
//Add a node
AStarNode *node = [[AStarNode alloc] init];
node.position = ccp(x*tw + tw/2, y*th + th/2);
if([collidableLayer tileAt:ccp(x,y)]){ node.active = NO; }
[[grid objectAtIndex:x] addObject:node];
}
}
/* CODE OMITTED */
return self;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec24"/>How it works...</h2></div></div></div><p>In this recipe, we can see our algorithm come to life with some nice animated AI character movement. We simply replace<code class="literal"> nodeSpace</code> with<code class="literal"> tileMap.tileSize.width/height</code> and replace<code class="literal"> gridSizeX/Y</code> with<code class="literal"> tileMap.mapSize.width/height</code>. Our character can now move around the forest and other obstacles.<a id="id510" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec09"/>A* pathfinding in a side-scroller</h1></div></div></div><p>The A* algorithm is a generic node-graph traversal routine which can be applied to many abstract problems. In a 2D side-scroller, space is traversed in a complex, non-linear fashion. Actors are expected to run across platforms and jump from platform to platform. With some extra math, we can tailor our A* technique to this problem.<a id="id511" class="indexterm"/>
</p><div><img src="img/4002_07_08.jpg" alt="A* pathfinding in a side-scroller"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec25"/>Getting ready</h2></div></div></div><p>The code listed as follows is heavily edited for the sake of brevity. Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec26"/>How to do it...</h2></div></div></div><p>Execute the following code:<a id="id512" class="indexterm"/>
</p><div><pre class="programlisting">/* SSAStarNode */
@implementation SSAStarNode
-(float) costToNeighbor:(SSNeighborNode*)nn {
SSAStarNode *node = nn.node;
//Here we use jumping/running to determine cost. We could also possibly use a heuristic.
CGPoint src = ccp(self.position.x/PTM_RATIO, self.position.y/PTM_RATIO);
CGPoint dst = ccp(node.position.x/PTM_RATIO, node.position.y/PTM_RATIO);
float cost;
if(node.body == self.body){
//Compute simple distance
float runTime = ([GameHelper distanceP1:src toP2:dst]) / actor.runSpeed;
cost = runTime * node.costMultiplier;
}else{
//Compute a jump
float y = dst.y - src.y;
if(y == 0){ y = 0.00001f; } //Prevent divide by zero
CGPoint launchVector = nn.launchVector;
float gravity = actor.body-&gt;GetWorld()-&gt;GetGravity().y;
Vector3D *at = [GameHelper quadraticA:gravity*0.5f B:launchVector.y C:y*-1];
float airTime;
if(at.x &gt; at.y){
airTime = at.x;
}else{
airTime = at.y;
}
cost = airTime * node.costMultiplier;
}
return cost;
}
@end
/* SSGameActor */
@implementation SSGameActor
+(Vector3D*) canJumpFrom:(CGPoint)src to:(CGPoint)dst radius:(float)radius world:(b2World*)world maxSpeed:(CGPoint)maxSpeed {
float x = dst.x - src.x;
float y = dst.y - src.y;
if(y == 0){ y = 0.00001f; } //Prevent divide by zero
bool foundJumpSolution = NO;
bool triedAngles = NO;
CGPoint launchVector;
float jumpHeightMod = 0.5f;
while(!triedAngles){
//Gravity
float gravity = world-&gt;GetGravity().y;
if(gravity == 0){ gravity = 0.00001f; } //Prevent divide by zero
launchVector = [SSGameActor getLaunchVector:CGPointMake(x,y) jumpHeightMod:jumpHeightMod gravity:gravity];
bool hitObject = NO;
bool movingTooFast = NO;
/* Make sure jump doesn't hit an object */
Vector3D *at = [GameHelper quadraticA:gravity*0.5f B:launchVector.y C:y*-1];
float airTime;
if(at.x &gt; at.y){ airTime = at.x; }else{ airTime = at.y; }
//Do a ray test sequence (from 0.1 to 0.9 of airTime)
for(float t=airTime/10; t&lt;airTime-airTime/10; t+= airTime/10){
if(hitObject){ break; }
float t1 = t + airTime/10;
float x1 = launchVector.x * t + src.x;
float y1 = launchVector.y * t + (0.5f) * gravity * pow(t,2) + src.y;
float x2 = launchVector.x * t1 + src.x;
float y2 = launchVector.y * t1 + (0.5f) * gravity * pow(t1,2) + src.y;
//Point Test
/* CODE OMITTED */
//RayCast Test
/* CODE OMITTED */
}
//Make sure the launchVector is not too fast for this actor
if(!hitObject){
if([GameHelper absoluteValue:launchVector.x] &gt; maxSpeed.x || [GameHelper absoluteValue:launchVector.y] &gt; maxSpeed.y){
movingTooFast = YES;
}
}
if(hitObject || movingTooFast){
//This jump failed, try another
if(jumpHeightMod &lt;= 0.5f &amp;&amp; jumpHeightMod &gt;= 0.2f){ //First, try 0.5f to 0.1f
jumpHeightMod -= 0.1f;
}else if(jumpHeightMod &gt; 0.5f &amp;&amp; jumpHeightMod &lt; 1.0f){ //Then try 0.6f to 1.0f
jumpHeightMod += 0.1f;
}else if(jumpHeightMod &lt; 0.2f){
jumpHeightMod = 0.6f;
}else if(jumpHeightMod &gt;= 1.0f){
//FAIL
triedAngles = YES;
}
}else{
//SUCCESS
foundJumpSolution = YES;
triedAngles = YES;
}
}
if(foundJumpSolution){
return [Vector3D x:launchVector.x y:launchVector.y z:0];
}else{
return nil;
}
}
+(CGPoint) getLaunchVector:(CGPoint)vect jumpHeightMod:(float)jumpHeightMod gravity:(float)gravity {
//Gravity
if(gravity == 0){ gravity = 0.00001f; } //Prevent divide by zero
//The angle between the points
float directionAngle = [GameHelper vectorToRadians:ccp(vect.x, vect.y)];
//Jump height is a percentage of X distance, usually 0.5f
float apexX;
if(vect.y &gt; 0){ apexX = vect.x - (vect.x*0.5f*pow([GameHelper absoluteValue:sinf(directionAngle)],0.5f/jumpHeightMod));
}else{ apexX = vect.x*0.5f*pow([GameHelper absoluteValue:sinf(directionAngle)],0.5f/jumpHeightMod); }
float apexY;
if(vect.y &gt; 0){ apexY = vect.y + [GameHelper absoluteValue:vect.x*jumpHeightMod]*[GameHelper absoluteValue:sinf(directionAngle)];
}else{ apexY = [GameHelper absoluteValue:vect.x*jumpHeightMod]*[GameHelper absoluteValue:sinf(directionAngle)]; }
//Get launch vector
float vectY = sqrtf(2*(-1)*gravity*apexY);
float vectX = (apexX*(-1)*gravity) / vectY;
return CGPointMake(vectX, vectY);
}
@end
/* Ch7_SideScrollingPathfinding */
@implementation Ch7_SideScrollingPathfinding
-(CCLayer*) runRecipe {
/* CODE OMITTED */
//Distance between nodes that the actor can run between
float nodeRunDistInterval = 100.0f;
//How far to search for nodes the actor can jump to
float maxJumpSearchDist = 500.0f;
//Add some nodes to the bottom of the level
for(float x=20.0f; x&lt;=gameAreaSize.x*PTM_RATIO-20.0f; x+=nodeRunDistInterval){
//Add node
/* CODE OMITTED */
}
//Link those nodes together as 'run neighbors'
for(int i=0; i&lt;nodes.count-1; i++){
SSAStarNode *n1 = (SSAStarNode*)[nodes objectAtIndex:i];
SSAStarNode *n2 = (SSAStarNode*)[nodes objectAtIndex:i+1];
[self linkRunNeighbor:n1 with:n2];
}
/* Add nodes to all level platforms */
for(b2Body *b = world-&gt;GetBodyList(); b; b = b-&gt;GetNext()){
if (b-&gt;GetUserData() != NULL) {
GameObject *obj = (GameObject*)b-&gt;GetUserData();
if(obj.tag == GO_TAG_WALL &amp;&amp; obj-&gt;polygonShape){
//Nodes on this body only
NSMutableArray *nodesThisBody = [[[NSMutableArray alloc] init] autorelease];
//Process each polygon vertex
for(int i=0; i&lt;obj-&gt;polygonShape-&gt;m_vertexCount; i++){
b2Vec2 vertex = obj-&gt;polygonShape-&gt;m_vertices[i];
//All nodes are 1 unit above their corresponding platform
b2Vec2 nodePosition = b2Vec2(vertex.x + b-&gt;GetPosition().x,vertex.y + b-&gt;GetPosition().y+1.0f);
//Move nodes inward to lessen chance of missing a jump
if(obj-&gt;polygonShape-&gt;m_centroid.x &lt; vertex.x){
nodePosition = b2Vec2(nodePosition.x-0.5f, nodePosition.y);
}else{
nodePosition = b2Vec2(nodePosition.x+0.5f, nodePosition.y);
}
//If this node position is not inside the polygon we create an SSAStarNode
if(!obj-&gt;polygonShape-&gt;TestPoint(b-&gt;GetTransform(), nodePosition)){
//Add node
/* CODE OMITTED */
}
}
//Add in-between nodes (for running)
bool done = NO;
while(!done){
if(nodesThisBody.count == 0){ break; }
done = YES;
for(int i=0; i&lt;nodesThisBody.count-1; i++){
SSAStarNode *n1 = (SSAStarNode*)[nodesThisBody objectAtIndex:i];
SSAStarNode *n2 = (SSAStarNode*)[nodesThisBody objectAtIndex:i+1];
if([GameHelper absoluteValue:n1.position.y-n2.position.y] &gt; 0.1f){
//These are not side by side
continue;
}
if( [GameHelper distanceP1:n1.position toP2:n2.position] &gt; nodeRunDistInterval ){
CGPoint midPoint = [GameHelper midPointP1:n1.position p2:n2.position];
b2Vec2 mp = b2Vec2(midPoint.x/PTM_RATIO, midPoint.y/PTM_RATIO);
//If node is not in the polygon, add it
if(!obj-&gt;polygonShape-&gt;TestPoint(b-&gt;GetTransform(), mp)){
//Add node
/* CODE OMITTED */
break;
}
}
}
}
//Link all of the neighboring nodes on this body
for(int i=0; i&lt;nodesThisBody.count-1; i++){
if(nodesThisBody.count == 0){ break; }
SSAStarNode *n1 = (SSAStarNode*)[nodesThisBody objectAtIndex:i];
SSAStarNode *n2 = (SSAStarNode*)[nodesThisBody objectAtIndex:i+1];
if([GameHelper absoluteValue:n1.position.y-n2.position.y] &gt; 0.1f){
//These are not side by side
continue;
}
//Two-way link
[self linkRunNeighbor:n1 with:n2];
}
}
}
}
//Neighbor all other nodes (for jumping)
for(int i=0; i&lt;nodes.count; i++){
for(int j=0; j&lt;nodes.count; j++){
if(i==j){ continue; }
SSAStarNode *n1 = (SSAStarNode*)[nodes objectAtIndex:i];
SSAStarNode *n2 = (SSAStarNode*)[nodes objectAtIndex:j];
if(n1.body == n2.body){ continue; }
if( [GameHelper distanceP1:n1.position toP2:n2.position] &lt;= maxJumpSearchDist ){
CGPoint src = ccp(n1.position.x/PTM_RATIO, n1.position.y/PTM_RATIO);
CGPoint dst = ccp(n2.position.x/PTM_RATIO, n2.position.y/PTM_RATIO);
//Calculate our jump "launch" vector
Vector3D *launchVector3D = [SSGameActor canJumpFrom:src to:dst radius:actor.circleShape-&gt;m_radius*1.5f world:world maxSpeed:actor.maxSpeed];
if(launchVector3D){
//Only neighbor up if a jump can be made
//1-way link
if(![n1 containsNeighborForNode:n2]){
//Add neighbor
/* CODE OMITTED */
}
}
}
}
}
return self;
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec27"/>How it works...</h2></div></div></div><p>First, we must create our node graph. In a top-down 2D environment, we simply use a grid and then cull out any colliding edges. In a side-scrolling environment, we need to think differently. Actors in such an environment must stand on top of the level geometry at all times. In addition to this, they have two different ways of traversing through the level:<strong> running</strong> and<strong> jumping</strong>.<a id="id513" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running across a platform:<p>To allow an actor to run across a platform, we need to create a string of A* nodes on top of each platform. Starting at one of these nodes, the actor can easily move to the other nodes on that same body.
</p></li><li class="listitem" style="list-style-type: disc">Jumping from platform to platform:<p>To reach another platform, the actor must jump there. This adds more complexity. We need to perform the calculations required to launch the actor safely to the other platform. We also need to check for geometry in the actor's jump trajectory and adjust the angle of the jump as necessary. Before we can implement this functionality, we need to encapsulate it in a new set of classes we create as sub-classes of our current ones.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">SSAStarNode:</code><a id="id514" class="indexterm"/><p>The <code class="literal">SSAStarNode</code> contains references to a b2Body object as well as a <code class="literal">SSGameActor</code> object. The body object represents the body the actor is resting on when at this node. A reference to the actor is maintained because actor information such as size, jumping speed, and running speed are required to make some of the aformentioned calculations.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">SSGameWaypoint:</code><a id="id515" class="indexterm"/><p>Our new waypoint class contains a <code class="literal">moveType</code> enumeration that specifies whether or not the actor should RUN or JUMP to the waypoint's location. It also contains a <code class="literal">launchVector</code> that specifies the impulse vector required if a jump is to be performed.
<a id="id516" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">SSGameActor:</code><a id="id517" class="indexterm"/><p>The new actor class has a <code class="literal">maxSpeed</code> variable that determines both how fast the actor can run and how high the actor can jump. This class also encapsulates our newly modified <code class="literal">processWaypoints</code> method as well as a few others:
</p><div><pre class="programlisting">-(void) runToWaypoint:(SSGameWaypoint*)wp speedMod:(float)speedMod constrain:(bool)constrain;
-(void) jumpToWaypoint:(SSGameWaypoint*)wp;
+(Vector3D*) canJumpFrom:(CGPoint)src to:(CGPoint)dst radius:(float)radius world:(b2World*)world maxSpeed:(CGPoint)maxSpeed;
+(CGPoint) getLaunchVector:(CGPoint)vect jumpHeightMod:(float)jumpHeightMod gravity:(float)gravity;
</pre></div><p>The <code class="literal">runToWaypoint</code> method simply sets the actor's velocity to make it run left or right. The <code class="literal">jumpToWaypoint</code> method launches the actor using the waypoint's <code class="literal">launchVector</code>. The <code class="literal">canJumpFrom</code> method determines whether or not a jump is possible to a certain point. This involves testing multiple jump angles against the geometry of the Box2D world. Each jump parabola is broken up into 10 straight-line sections that are ray tested against map geometry. This approximates collision detection well enough for our purposes. Finally, the getLaunchVector method, which is employed by the <code class="literal">canJumpFrom</code> method, determines the <code class="literal">launchVector</code> for the actor given a location to land on and given a Y jump height relative to the X jump width.
<a id="id518" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">SSAStarPathNode:</code><a id="id519" class="indexterm"/><p>This class is similar to <code class="literal">AStarPathNode</code>. It contains a <code class="literal">SSGameWaypoint</code> pointer for convenience. In the updated <code class="literal">findPathFrom</code> method, we create this waypoint and set its <code class="literal">launchVector</code>. This ensures that <code class="literal">launchVector</code> is only calculated at load time.
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">SSNeighborNode:</code><a id="id520" class="indexterm"/><p>As now we have two methods of moving from one node to another, we need a more complex way of storing graph edge information. Instead of simply storing a pointer to a neighboring node, this class encapsulates that node along with a <code class="literal">moveType, cost,</code> and <code class="literal">launchVector</code>.
</p></li><li class="listitem" style="list-style-type: disc">Creating our node graph—run nodes:<p>First we must create our key nodes. These are like keyframes in an animation. They are located slightly above each vertex on the top side of every platform. We then add nodes in-between these nodes. Finally, these "run nodes" are linked together with the moveType variable set to <code class="literal">MOVE_TYPE_RUN</code>.
</p></li><li class="listitem" style="list-style-type: disc">Creating our node graph—jump nodes:<p>Once the run nodes are set over each platform, we create jump nodes. This involves searching the immediate area around each node, determining whether or not the actor can jump from that node to a found node, and then finally creating the neighbor link. We create these links one at a time as jumping up to reach a node is very different from jumping down.
</p></li><li class="listitem" style="list-style-type: disc">Tweaking side-scrolling pathfinding:<p>This technique required a lot of tweaking to get working properly. For example, the X and Y distance thresholds, used to determine whether or not a waypoint has been reached, vary greatly. Another tweak involves the fact that, if a waypoint is blocked, the entire set of waypoints must be discarded. Perhaps another revision could salvage the second half of the path of nodes by prepending a new path to the missed node.
<a id="id521" class="indexterm"/>
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec10"/>Running a Lua script</h1></div></div></div><p>Many commercial games make use of a<strong> scripting language</strong> to isolate and abstract their<strong> game logic</strong>. The most popular of these is<strong> Lua</strong>. In this recipe, we will integrate Lua into our project.<a id="id522" class="indexterm"/>
</p><div><img src="img/4002_07_09.jpg" alt="Running a Lua script"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec28"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec29"/>How to do it...</h2></div></div></div><p>Lua can be added to your project in a few simple steps:</p><div><ol class="orderedlist"><li class="listitem"> Highlight your project in the Navigator. At the bottom of your window in the middle, click<strong> Add Target:</strong><a id="id523" class="indexterm"/><div><img src="img/4002_07_10.jpg" alt="How to do it..."/></div></li><li class="listitem"> Name the target "Lua". This will create a new folder inside your project folder next to your main target's similarly named folder. It should also create a new group.</li><li class="listitem"> Download the Lua source from<a class="ulink" href="http://www.lua.org"> http://www.lua.org</a> and copy it to this folder.</li><li class="listitem"> Right-click the<strong> Lua</strong> group and select<strong> Add Files to "Your</strong><div><img src="img/4002_07_11.jpg" alt="How to do it..."/></div></li><li class="listitem"> Navigate to the<code class="literal"> src</code> directory and add all the files located there except for<code class="literal"> lua.c, luac.c, Makefile</code>, and<code class="literal"> print.c</code>. Also, be sure to uncheck<strong> Copy items into destination groups folder</strong> and select only<strong> Lua</strong> under the<strong> Add to Targets</strong> section.</li><li class="listitem"> At this point, you should be able to build the Lua target with no errors.</li><li class="listitem"> In the middle pane, click your project's main target. Expand<strong> Link Binary With Libraries</strong>. Click the<strong> +</strong> symbol at the bottom-left and add the<strong> libLua.a</strong> library to the list:<a id="id524" class="indexterm"/><div><img src="img/4002_07_12.jpg" alt="How to do it..."/></div></li><li class="listitem"> Collapse this and expand<strong> Target Dependencies</strong>. Add the target<strong> Lua</strong> as a dependency of this target:<div><img src="img/4002_07_13.jpg" alt="How to do it..."/></div></li><li class="listitem"> That's it. Lua is now integrated. Clean and build your project to make sure it was integrated properly.<a id="id525" class="indexterm"/></li></ol></div><p>Execute the following code:</p><div><pre class="programlisting">#import "mcLua.hpp"
@interface Ch7_LuaScripting : Recipe
{
class mcLuaManager * lua_;
mcLuaScript * sc;
}
@end
//Callback pointer
Ch7_LuaScripting *lsRecipe = nil;
//Static append message C function
static int lsAppendMessage(lua_State * l)
{
//Pass lua string into append message method
[lsRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];
return 0;
}
@implementation Ch7_LuaScripting
-(CCLayer*) runRecipe {
//Set callback pointer
lsRecipe = self;
//Lua initialization
lua_ = new mcLuaManager;
//Lua function wrapper library
static const luaL_reg scriptLib[] =
{
{"appendMessage", lsAppendMessage },
{NULL, NULL}
};
lua_-&gt;LuaOpenLibrary("scene",scriptLib);
//Open Lua script
sc = lua_-&gt;CreateScript();
NSString *filePath = [[NSBundle mainBundle] pathForResource:@"show_messages.lua" ofType:@""];
sc-&gt;LoadFile([filePath UTF8String]);
//Set initial update method counter
lua_-&gt;Update(0);
//Schedule step method
[self schedule: @selector(step:)];
//Resume button
CCMenuItemFont *resumeItem = [CCMenuItemFont itemFromString:@"Resume Script" target:self selector:@selector(resumeScript:)];
CCMenu *menu = [CCMenu menuWithItems:resumeItem, nil];
[self addChild:menu];
return self;
}
-(void) step:(ccTime)delta {
//Update Lua script runner
lua_-&gt;Update(delta);
}
/* Resume script callback */
-(void) resumeScript:(id)sender {
sc-&gt;YieldResume();
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec30"/>How it works...</h2></div></div></div><p>This and subsequent recipes use Robert Grzesek's<code class="literal"> mcLua</code> API to facilitate the loading and execution of Lua scripts. It also allows for concurrent execution of multiple scripts.<a id="id526" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> mcLuaManager</code> class:<p>The <code class="literal">mcLuaManager </code>class is the top-level class that manages all running scripts:
</p><div><pre class="programlisting">class mcLuaManager lua_ = new mcLuaManager;
</pre></div><p>It is in charge of running the scripts as well as their creation and destruction.
</p></li><li class="listitem" style="list-style-type: disc">Loading and starting a script:<p>Loading a Lua script is a fairly straightforward process:
</p><div><pre class="programlisting">mcLuaScript *sc = lua_-&gt;CreateScript();
NSString *filePath = [[NSBundle mainBundle] pathForResource:@"show_messages.lua" ofType:@""];
sc-&gt;LoadFile([filePath UTF8String]);
</pre></div><p>Once the file is loaded, we make a call to the <code class="literal">mcLuaManager</code> class's <code class="literal">Update</code> method:
</p><div><pre class="programlisting">lua_-&gt;Update(0);
</pre></div><p>This starts the loaded scripts off and running.
</p></li><li class="listitem" style="list-style-type: disc">Static function libraries:<p>Inside the Lua script, global methods can be called according to function libraries assigned to object identifiers. The mcLua API assigns a few functions to the script object by default. These include <code class="literal">waitSeconds, waitFrames</code>, and <code class="literal">pause</code>. They can be called inside the Lua script:
</p><div><pre class="programlisting">script.waitSeconds(1);
</pre></div><p>In this example, we also create a callback method named <code class="literal">appendMessage</code> and assign it to an object named <code class="literal">scene</code>. To do this, we first create a static C function:
</p><div><pre class="programlisting">static int lsAppendMessage(lua_State * l)
{
[lsRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];
return 0;
}
</pre></div><p>When the recipe is loaded, we create a Lua script library linker array and load it into memory using the <code class="literal">LuaOpenLibrary </code>provided by the <code class="literal">mcLua</code> API:
</p><div><pre class="programlisting">lua_ = new mcLuaManager;
static const luaL_reg scriptLib[] =
{
{"appendMessage", lsAppendMessage },
{NULL, NULL}
};
lua_-&gt;LuaOpenLibrary("scene", scriptLib);
</pre></div><p>Once this is loaded, we can call that function from the Lua script itself:
</p><div><pre class="programlisting">scene.appendMessage("This is a Lua script.");
</pre></div><p>Finally, if the script is paused (from inside or outside the script itself) it can be resumed (only from outside the script):
</p><div><pre class="programlisting">sc-&gt;YieldResume();
</pre></div><p>Together this library lets your Lua script interact with your application.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec11"/>Dynamically loading Lua scripts</h1></div></div></div><p>Part of the power of a scripting language like Lua, is that scripts can be loaded and re-loaded at<strong> run-time</strong>. This means you can test your game logic without having to re-compile your Objective-C++ code. In this recipe, we will load a remote script from a local<strong> web server</strong>.<a id="id527" class="indexterm"/>
</p><div><img src="img/4002_07_14.jpg" alt="Dynamically loading Lua scripts"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.<a id="id528" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec32"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">#import "mcLua.hpp"
#import "Reachability.h"
@interface Ch7_DynamicScriptLoading : Recipe
{
class mcLuaManager * lua_;
}
@end
//Callback pointer
Ch7_DynamicScriptLoading *dslRecipe = nil;
//Static append message C function
static int dslAppendMessage(lua_State * l)
{
//Pass lua string into append message method
[dslRecipe appendMessage:[NSString stringWithUTF8String:lua_tostring(l,1)]];
return 0;
}
@implementation Ch7_DynamicScriptLoading
-(CCLayer*) runRecipe {
//Superclass initialization
[super runRecipe];
//Set callback pointer
dslRecipe = self;
//Lua initialization
lua_ = new mcLuaManager;
//Lua function wrapper library
static const luaL_reg scriptLib[] =
{
{"appendMessage", dslAppendMessage },
{NULL, NULL}
};
lua_-&gt;LuaOpenLibrary("scene",scriptLib);
//Load Lua script
[self loadScript];
//Set initial update method counter
lua_-&gt;Update(0);
//Schedule step method
[self schedule: @selector(step:)];
//Reload script button
CCMenuItemFont *reloadItem = [CCMenuItemFont itemFromString:@"Reload Script" target:self selector:@selector(loadScript)];
CCMenu *menu = [CCMenu menuWithItems:reloadItem, nil];
[self addChild:menu];
return self;
}
-(void) step:(ccTime)delta {
//Update Lua script runner
lua_-&gt;Update(delta);
}
-(void) loadScript{
//Reset message
[self resetMessage];
//Make sure localhost is reachable
Reachability* reachability = [Reachability reachabilityWithHostName:@"localhost"];
NetworkStatus remoteHostStatus = [reachability currentReachabilityStatus];
if(remoteHostStatus == NotReachable) {
[self showMessage:@"Script not reachable."];
}else{
[self appendMessage:@"Loading script from http://localhost/ch7_remote_script.lua"];
//Load script via NSURL
mcLuaScript *sc = lua_-&gt;CreateScript();
NSString *remoteScriptString = [NSString stringWithContentsOfURL:[NSURL URLWithString:@"http://localhost/ch7_remote_script.lua"]
encoding:NSUTF8StringEncoding error:nil];
sc-&gt;LoadString([remoteScriptString UTF8String]);
}
}
@end
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec33"/>How it works...</h2></div></div></div><p>The simplest way to load a remote script is to use a local web server. This way we can bypass<code class="literal"> NSBundle</code> and the somewhat restricted iOS filesystem. Mac OSX ships with a built-in Apache HTTP webserver. It can be enabled and configured by going to<strong> System Preferences</strong> |<strong> Internet and Wireless</strong> |<strong> Sharing</strong> |<strong> Web Sharing:</strong>
<a id="id529" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading a remote script:<a id="id530" class="indexterm"/><p>Instead of reading our script off the filesystem, we load it over HTTP using <code class="literal">NSURL</code>:
</p><div><pre class="programlisting">mcLuaScript *sc = lua_-&gt;CreateScript();
NSString *remoteScriptString = [NSString stringWithContentsOfURL:[NSURL URLWithString:@"http://localhost/ch7_remote_script.lua"] encoding:NSUTF8StringEncoding error:nil];
sc-&gt;LoadString([remoteScriptString UTF8String]);
</pre></div><p>Editing the file on your local web server and hitting the re-load button simply loads the script again. This is a simple but effective way to rapidly develop and test game logic.
</p></li><li class="listitem" style="list-style-type: disc">Reachability:<p>In this example, we use Apple's Reachability library to help us determine whether or not we can access the script over the network. Without this tool our <code class="literal">stringWithContentsOfURL </code>method would throw errors.
</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec12"/>Using Lua for dialogue trees</h1></div></div></div><p>Lua lets the programmer write against a generic<strong> interface</strong> and worry about the<strong> implementation</strong> later. This separation between game logic, and the nuts and bolts of presenting the audio/visual elements of the game, is an important part of any game engine. In this recipe, we will use Lua to create a small story-based adventure game.<a id="id531" class="indexterm"/>
</p><div><img src="img/4002_07_15.jpg" alt="Using Lua for dialogue trees"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec34"/>Getting ready</h2></div></div></div><p>Please refer to the project<em> RecipeCollection03</em> for full working code of this recipe.<a id="id532" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec35"/>How to do it...</h2></div></div></div><p>Execute the following code:</p><div><pre class="programlisting">//Static C functions
static int ldtLogic(lua_State * l) {
int num = [ldtRecipe logic:[NSString stringWithUTF8String:lua_tostring(l,1)]];
lua_pushnumber(l,num);
return 1;
}
static int ldtPresentOptions(lua_State * l) {
[ldtRecipe presentOptions];
ldtRecipe.sc-&gt;YieldPause();
return (lua_yield(l, 0));
}
@implementation Ch7_LuaDecisionTree
/* Logic callback */
-(int) logic:(NSString*)str {
int num = 0;
if([str isEqualToString:@"Put guns down"]){
gunsDown = YES;
}else if([str isEqualToString:@"Are guns down?"]){
if(gunsDown){
num = 1;
}else{
num = 0;
}
}else if([str isEqualToString:@"You win"]){
[self showMessage:@"You WIN!!"];
}
return num;
}
/* Present options callback */
-(void) presentOptions {
text = @"";
[textLabel setString:text];
optionsNode.visible = YES;
}
/* Select option callback */
-(void) selectOption:(id)sender {
/* CODE OMITTED */
//Resume the script
sc-&gt;YieldResume();
}
@end
/* decision_tree.lua */
function start()
scene.desc("You are deep undercover with the mafia.");
scene.anim("Open door");
scene.anim("Enter officer");
scene.anim("Louie looks away");
scene.dialog("Officer: Alright Big Louie. This is a raid. You're under arrest for the murder of Frankie Boy Caruso.");
scene.anim("Pull guns");
scene.dialog("Big Louie: Murder? What's a murder?");
scene.dialog("Officer: Don't play dumb with me.");
scene.dialog("Big Louie: A one-man raid? You must have a death wish.");
scene.anim("Louie looks at you");
scene.dialog("Big Louie: What do YOU think we should do with him?");
scene.dialogOption("You can't take him out now. There are too many witnesses.");
scene.dialogOption("I say take him out. He's here alone.");
scene.dialogOption("He's a cop. We'll have a mess on our hands if we take him down.");
scene.presentOptions();
if scene.getResponse() == 1 then
tooManyWitnesses();
elseif scene.getResponse() == 2 then
hereAlone();
elseif scene.getResponse() == 3 then
bigMess();
end
end
function tooManyWitnesses()
scene.dialog("Big Louie: Whaddya mean too many witnesses? These are all my men...");
scene.anim("Louie scowls");
scene.dialog("Big Louie: ...and YOU! Blast him boys.");
script.waitSeconds(1);
scene.anim("Gun pointed at you");
scene.desc("You are dead.");
end
function bigMess()
scene.dialog("Big Louie: I don't like it, but, you're right.");
scene.dialog("Big Louie: Men, you can put your guns down.");
scene.logic("Put guns down");
scene.anim("Put guns down");
scene.desc("Louie's men lower their weapons");
scene.anim("Louie looks away");
scene.dialog("Big Louie: Cop, looks like you have a new lease on life.");
scene.actionOption("Pull your gun on Big Louie");
scene.actionOption("Pull your gun on Big Louie's men");
scene.presentOptions();
if scene.getResponse() == 1 then
pullGunOnLouie();
elseif scene.getResponse() == 2 then
pullGunOnMen();
end
end
function hereAlone()
scene.anim("Officer shocked");
script.waitSeconds(1);
scene.dialog("Officer: Jerry! What the hell are you doing?!");
scene.anim("Louie scowls");
scene.dialog("Big Louie: Jerry? You lying scumbag! We trusted you...blast him boys.");
script.waitSeconds(1);
scene.anim("Gun pointed at you");
scene.desc("You are dead.");
end
function pullGunOnLouie()
scene.anim("Pull gun on Louie");
scene.anim("Louie scowl");
scene.dialog("Big Louie: This guy's a Fed! Blast him!");
script.waitSeconds(1);
scene.anim("Gun pointed at you");
scene.desc("You are dead.");
end
function pullGunOnMen()
gunsDown = scene.logic("Are guns down?");
scene.anim("Pull gun on men");
if gunsDown == 1 then
scene.anim("Louie scowls");
scene.dialog("Big Louie: You played me for a fool!");
scene.anim("Louie looks away");
scene.dialog("Officer: You're under arrest Big Louie.");
scene.dialog("Big Louie: I'll be back on the streets in twenty-four hours!");
scene.dialog("Officer: We'll try to make it twelve.");
scene.anim("Louie looks at you");
scene.logic("You win");
scene.desc("You win!");
else
scene.anim("Louie scowls");
scene.dialog("Big Louie: This guy's a Fed! Blast him!");
script.waitSeconds(1);
scene.anim("Gun pointed at you");
scene.desc("You are dead.");
end
end
start();
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec36"/>How it works...</h2></div></div></div><p>For this recipe, we create a number of callback functions to process animation, dialog, and logic. Some of these, like option prompts, wait for user response before the script is resumed. Other functions, like<code class="literal"> ldtLogic</code>, have a return value.<a id="id533" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Passing and returning variables using Lua:<p>Lua's variable passing mechanism is fairly simple. Functions are passed a lua_State pointer. Data can then be retrieved off of the stack pointed to by this:
</p><div><pre class="programlisting">lua_State * l;
NSString *str = [NSString stringWithUTF8String:lua_tostring(l,1)];
</pre></div><p>Lua supports multiple return variables at one time. To return a variable from one of our callback functions, we must first push the variable onto the stack:
</p><div><pre class="programlisting">int num = 7;
lua_pushnumber(l,num);
</pre></div><p>We then specify the number of variables we are returning as an integer:
</p><div><pre class="programlisting">return 1;
</pre></div><p>All basic C types can be passed and returned using Lua.
</p></li><li class="listitem" style="list-style-type: disc">Local Lua functions:<a id="id534" class="indexterm"/><p>Inside of our script file we use a number of local Lua functions. Everything is encapsulated in a function except for the initial <code class="literal">start()</code> function call. Local functions also support returning multiple
<a id="id535" class="indexterm"/>
</p></li></ul></div></div></div></body></html>