<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Introduction to Swift</h1></div></div></div><p class="calibre8">Apple held their <strong class="calibre2">Worldwide Developers Conference</strong> (<strong class="calibre2">WWDC</strong>)<a id="id246" class="calibre1"/> for 2014 on June 2 at Moscone West in San Francisco, which was the same venue as previous years. They announced a slew of new APIs, technologies for games such as <a id="id247" class="calibre1"/>Metal, new operating systems for iOS (iOS 8) and Mac (Yosemite), and the most important announcement for iOS developers in 2014, that is, the announcement of Swift, a new programming language, which some say is meant to replace Objective-C, as Objective-C<a id="id248" class="calibre1"/> was introduced in 1983 and is showing its age due to its long history. Swift is meant to be an easy and simple to learn programming language that will lower the barrier to entry for developers who are intimidated by Objective-C. However, what is Swift and what is good about it? How far does it differ from Objective-C, and finally, how easy is it to learn Swift? These are the questions that we will cover in this chapter, and to start things off, here is a list of topics we will cover:</p><div><ul class="itemizedlist"><li class="listitem">Welcome to Swift</li><li class="listitem">Swift basics</li><li class="listitem">Memory management</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec62" class="calibre1"/>Welcome to Swift</h1></div></div></div><p class="calibre8">Swift <a id="id249" class="calibre1"/>is actually not a new language, as Apple started the development of Swift back in 2010. Since programming languages such as Ruby, Python, Haskell, Rust, and so on have surged in popularity, Swift was developed using language ideas from these popular languages. As Apple describes Swift as <em class="calibre9">Objective-C without the C</em>, you can consider Swift as a language that is a reimagining of Objective-C using modern concepts and syntax borrowed from languages such as JavaScript, but still keeping the essence and spirit of Objective-C.</p><p class="calibre8">Swift does away with pointers and makes memory management opaque to the developer through the use of ARC so that they can focus on their iOS application creation and not worry about memory management most of the time. Swift uses ARC and not the GC method found in Java. This means that Swift can still leak memory if you are not careful by using cyclic strong references. Smalltalk is a programming language released in 1972 that has heavily influenced Objective-C in terms of architecture, such as message passing. And the Smalltalk aspect of Objective-C, such as method calls, has been replaced with dot notation and a namespace system that is reminiscent of Java and C#. However, Swift is not a totally radical departure from Objective-C. Key Objective-C concepts such as protocols, closures, and categories are still present in Swift, except that the syntax is much cleaner and crisper.</p><p class="calibre8">Swift's<a id="id250" class="calibre1"/> approach to memory management is that it uses ARC, and one problem with ARC is that a developer can unintentionally create a strong reference cycle where instances of two different classes include a reference to the other. So, Swift provides the weak and unowned keyboards to prevent strong reference cycles from occurring.</p><p class="calibre8">For a seasoned <a id="id251" class="calibre1"/>Objective-C programmer who comes from a C or C++ background, Swift may seem like a totally new language as it does away with some aspects of Objective-C such as verbosity. I am sure that a lot of Objective-C developers have experienced "square brackets hell", where simple functionalities need to be wrapped with a lot of square brackets, thus rendering the code hard to read, and which also runs the risk of introducing bugs into your application. The goal of Swift is to let developers harness the power of Objective-C without C. So, there are some aspects of Swift that indeed make it easier for a developer, but conversely, there are some parts of Swift that do not seem to be fully fleshed out yet. However, bear in mind that at the time of writing this, Swift is still in beta and Apple may still introduce a lot of changes in the following weeks and months. However, with Apple putting its full weight behind Swift, now is a good time to start learning some Swift basics. As with all new technology that Apple introduces, you will require Xcode 6 beta and higher to run and build your Swift code as Xcode 5 does not support Swift. Your Swift code can also run on iOS 7 and Mac OS 10.9.3. So, if you are an Apple developer, you can download Xcode 6 beta and install it on your Mac as it will be installed side by side with your Xcode 5 and will not override anything or break your current Xcode projects. So, let's get cracking.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec63" class="calibre1"/>Basics of Swift</h1></div></div></div><p class="calibre8">Swift syntax<a id="id252" class="calibre1"/> is very different to Objective-C, while Objective-C has a lot of reliance on C and C++ components such as pointers, strong typing, and so on. Swift is very similar to popular scripting languages such as Python and Ruby with regards to terseness and variable declaration. So, let's look at some basics of Swift to get acquainted with it.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec32" class="calibre1"/>Variable declaration</h2></div></div></div><p class="calibre8">Swift does away with the<a id="id253" class="calibre1"/> need to<a id="id254" class="calibre1"/> remember ints, floats, NSStrings, and so on and consolidates all of these type of variables under one type, and that is of the type <code class="email">var</code>. If you are familiar with JavaScript, then the <code class="email">var</code> keyword should not be unfamiliar to you. Swift supports the type inference, where depending on the value that you assign to a variable, it will infer its type:</p><div><pre class="programlisting">var welcome
welcome = "Hello world"</pre></div><p class="calibre8">This means that the variable, <code class="email">welcome</code>, is inferred to have a string type as I assigned the text <code class="email">Hello world</code> to it. However, if you want to be specific, you can annotate a variable like this:</p><div><pre class="programlisting">var welcome: String.</pre></div><p class="calibre8">Then to append two strings together in Swift, you can do the following:</p><div><pre class="programlisting">welcome += " Bob"</pre></div><p class="calibre8">If you were using Objective-C, you will need to type out the longer syntax:</p><div><pre class="programlisting">NSString *hello = @"Hello world";
str = [str stringByAppendingString:@" Bob];</pre></div><p class="calibre8">Swift also supports constants with the keyword <code class="email">let</code>. So, to declare a constant, you can just type the following syntax:</p><div><pre class="programlisting">let LIFE_MEANING = 42</pre></div><p class="calibre8">Note that Swift now infers that <code class="email">LIFE_MEANING</code> is an integer as you have assigned the value <code class="email">42</code> to it. To print out a line of text for logging, which is analogous to NSLog from Apple's Cocoa framework, you can use the <code class="email">println</code> keyword, whereas with NSLog, you need to specify the format specifier such as <code class="email">%d</code> for integers, <code class="email">%@</code> for NSStrings, or <code class="email">%f</code> for float/double. </p><p class="calibre8">There is no need to do this for Swift; you can just use the following syntactical examples:</p><div><pre class="programlisting">println("The text is \(welcome)") //print out the value of variable welcome
println("The meaning of life is \(LIFE_MEANING)")//print out the meaning of life</pre></div><p class="calibre8">One thing that has not changed from Objective-C is that comments in Swift are denoted by the <code class="email">//</code> for single line comments and <code class="email">/*</code> and <code class="email">*/</code> for multiline comments.</p><p class="calibre8">Semicolons are also optional. Some of you may want to be pedantic and put a semicolon, but personally, I don't like any additional typing than is necessary, so I tend to omit the semicolon (;) for my Swift code.</p><div><img src="img/00034.jpeg" alt="Variable declaration" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">As with all programming<a id="id255" class="calibre1"/> languages, Swift supports an array of operators <a id="id256" class="calibre1"/>for arithmetic comparison and assignment.</p><p class="calibre8">All the operators such as <code class="email">/</code>, <code class="email">*</code>, <code class="email">+</code>, and so on perform the same function as in Objective-C except that the <code class="email">+</code> operator serves a dual function as a string concatenation operator if you need to concatenate multiple strings.</p><p class="calibre8">Swift introduces the concept of closed range operators, which defines a range that runs from <em class="calibre9">x</em> to <em class="calibre9">y</em> and includes the values <em class="calibre9">x</em> and <em class="calibre9">y</em> if you use it like this (<em class="calibre9">x...y</em>). For example:</p><div><pre class="programlisting">for index in 1...5 { print("Value is \(index)") }</pre></div><p class="calibre8">This will print out the values <strong class="calibre2">1</strong>, <strong class="calibre2">2</strong>, <strong class="calibre2">3</strong>, <strong class="calibre2">4</strong>, and <strong class="calibre2">5</strong>. As you may have noticed by now, this can be used to replace the more verbose tradition for loop in Objective-C, which is represented by these lines of code:</p><div><pre class="programlisting">for (int i = 0; i &lt;= 5, i ++)
NSLog(@"Value is %d", i);</pre></div><p class="calibre8">However, what if you want to do some common <code class="email">for</code> loop code to loop through an array? Then, you will need a half-closed range operator, which is similar to a closed range operator except that there is one dot less (<em class="calibre9">x..y</em>):</p><div><pre class="programlisting">let breeds = ["Pitbull", "Terrier", Bull dog", "Maltese"]
let count = breeds.count
for i in 0..count { println("This breed is \(breeds[i])") }</pre></div><p class="calibre8">As you have seen earlier, Swift also has support for collection types such as arrays as shown earlier and dictionaries, which we will cover in the next few pages. To start off declaring an array, you just use the following syntax:</p><div><pre class="programlisting">var catBreeds = ["Siamese", "Scottish"]</pre></div><p class="calibre8">Then, there are some <a id="id257" class="calibre1"/>properties that can come in handy, among<a id="id258" class="calibre1"/> others, such as:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">count</code>: This returns the number of items in the array</li><li class="listitem"><code class="email">isEmpty</code>: This is a Boolean variable that returns true if the count property is <code class="email">0</code></li><li class="listitem"><code class="email">append</code>: This property will allow you to add an item to the end of an array</li></ul></div><p class="calibre8">Swift provides some helper code to iterating over an array instead of using a <code class="email">for</code> loop, <code class="email">while</code> loop, or <code class="email">do-while</code> loop. Array iteration is easier in Swift as you just need to do this to do the iteration:</p><div><pre class="programlisting">for item in catBreeds{
  println(item)
}//prints out "Siamese" and "Scottish"</pre></div><p class="calibre8">No longer do you need to write any verbose and unnecessary code for a <code class="email">for</code>, <code class="email">while</code>, or <code class="email">do-while</code> loop as you can use the item variable to access the array.</p><p class="calibre8">Next, we will cover dictionary. The dictionary in Swift is similar to <code class="email">NSDictionary</code> in Cocoa, in terms of functionality and usage. However, there is a major difference in that, whereas in <code class="email">NSDictionary</code> and <code class="email">NSMutableDictionary</code>, you are allowed to use any object as the key and value, which does not provide any information about the object nature. In Swift, the type of keys and values in a dictionary are always made explicitly clear using explicit type annotation or via type inference.</p><p class="calibre8">The syntax for a dictionary in Swift is quite straightforward, as shown here:</p><div><pre class="programlisting">var breeds = Dictionary&lt;String, String&gt; = ["Breed1": "Bull Dog", "Breed2": "Terrier"]</pre></div><p class="calibre8">The preceding code uses explicit type notation as you can see that the key and value are explicitly defined as <code class="email">String</code> and <code class="email">String</code> respectively. This is very similar to how you declare dictionaries in Javascript or Maps in Java, by running the following:</p><div><pre class="programlisting">var breeds = ["Breed1": "Bull Dog", "Breed2": "Terrier"]</pre></div><p class="calibre8">The preceding <a id="id259" class="calibre1"/>code uses type inference where once we assign <code class="email">Breed1</code> to <a id="id260" class="calibre1"/>the key and <code class="email">Bull Dog</code> to the value, Swift automatically infers that our dictionary will hold two strings.</p><p class="calibre8">Modifying a dictionary in Swift is similar to how you access an array except that instead of using an index, you use the key, which in our case is a String. So, if you want to modify the value that maps to the <code class="email">Breed1</code> key, you can do it as shown here:</p><div><pre class="programlisting">breeds["Breed1"] = "Dalmatian"</pre></div><p class="calibre8">Alternatively, Swift allows us to update a value another way, which is the <code class="email">updateValue</code> method as demonstrated here:</p><div><pre class="programlisting">breeds.updateValue("Breed2", forKey: "Bloodhound")</pre></div><p class="calibre8">Both ways will allow you to update a value using the key, but I prefer the first way as it is less verbose, yet equally easy to read and understand.</p><p class="calibre8">Iteration over a dictionary is similar to the iteration of an array in Swift where we can forgo the old Objective-C <code class="email">for</code>, <code class="email">while</code>, or <code class="email">do-while</code> loop methods. To do a dictionary iteration in Swift, we just use the following code:</p><div><pre class="programlisting">for (breed, breedname) in breeds{
  println("\(breed) is \(breedname)")
}//prints Breed1 is Dalmation, Breed2 is Bloodhound</pre></div><p class="calibre8">In any general purpose programming language, control flow statements are a necessity in order to control the flow of your code and your app. So, although Swift is a big departure from Objective-C, it still allows for control flow constructs of C-like languages such as C++.</p><p class="calibre8">Here is a list of control flow constructs available for you to use in Swift:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">for</code> loop</li><li class="listitem">The <code class="email">for-in</code> loop</li><li class="listitem">The <code class="email">while</code> loop</li><li class="listitem">The <code class="email">do-while</code> loop</li><li class="listitem">The <code class="email">if</code> statement</li><li class="listitem">The <code class="email">switch</code> statement</li></ul></div><p class="calibre8">These control flow<a id="id261" class="calibre1"/> statements serve the same purpose as they will in <a id="id262" class="calibre1"/>Objective-C, but there are a few improvements to them, which I will explain briefly.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec33" class="calibre1"/>Iterating statements</h2></div></div></div><p class="calibre8">For statements that<a id="id263" class="calibre1"/> iterate over<a id="id264" class="calibre1"/> and over again, such as <code class="email">for</code> loops, Swift emphasizes the <code class="email">for-in</code> loop for iteration. This is also known as an enhanced for loop in other programming languages such as Java. This improves readability and adds terseness to your code. For example:</p><div><pre class="programlisting">var dogs = ["Bulldog", "Terrier", "Dalmatian"]
for dog in dogs {
  println("This dog is a \(dog)");
}</pre></div><p class="calibre8">However, if you have the need for a Objective-C traditional style <code class="email">for</code> loop, you can do it with Swift, as follows:</p><div><pre class="programlisting">for index = 0; index &lt; 3; ++index {
//do something here
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec34" class="calibre1"/>Conditional statements</h2></div></div></div><p class="calibre8">If statements behave the <a id="id265" class="calibre1"/>same <a id="id266" class="calibre1"/>way as they do in Objective-C, except for a minor change of syntax as shown here. Do note that the brackets are optional, so we did not put it around the conditional expression:</p><div><pre class="programlisting">if temperatureInCelsius &lt; 10 {
  println("It is cold here");
}</pre></div><p class="calibre8">Note that in the preceding example, we have a very simple condition, so we have opted to eliminate our brackets. However, what if you have multiple conditions? Then, Swift will use the normal rules of precedence that you are familiar with, but the lack of brackets can make the operations hard to understand. So, in this case, I would prefer to use brackets for multiple conditions and operations like the following:</p><div><pre class="programlisting">if (temperatureInCelsius &lt; 10) &amp;&amp; (temperatureinCelsius &gt; 0)
{
  println("It is chilly here");
}</pre></div><p class="calibre8">However, in Swift, Switch<a id="id267" class="calibre1"/> statements have now been made easier for debugging by not having to fall through the next case. So now the entire switch statement finishes its execution as soon as the first matching switch case is completed. So, the following statement will show the following output:</p><div><pre class="programlisting">let number = 2
switch number {
  case 1:
    println("Number is 1");
  case 2:
    println("Number is 2");
  case 3:
    println("Number is 3");
}</pre></div><p class="calibre8">The output will be <code class="email">"Number is 2"</code> in Swift instead of <code class="email">"Number is 1"</code> and <code class="email">"Number is 3"</code>, which you will see in Objective-C.</p><p class="calibre8">Control flows in Swift have <a id="id268" class="calibre1"/>been made better where the syntax has been improved to add readability and to prevent developers from creating non-obvious bugs such as a Switch case fallthrough due to a missing <code class="email">break</code> statement.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec35" class="calibre1"/>Functions</h2></div></div></div><p class="calibre8">Functions are the fundamental<a id="id269" class="calibre1"/> building blocks of every programming language, and it is<a id="id270" class="calibre1"/> also the same in Swift, but there are some improvements made, which we will go through now. The syntax for a function has changed quite a bit, so a function in Swift now has the following syntax:</p><div><pre class="programlisting">func animalType(animalName: String)-&gt; String {
  let text = "This is a " + animalName
  return text;
}</pre></div><p class="calibre8">So, you can call it using <code class="email">println(animalType("Dog"))</code>. If the function does not have a return value, you can avoid adding the arrow (<code class="email">-&gt;</code>) like this:</p><div><pre class="programlisting">func animalType(animalName: String) {
  println("This is a \(animalName)")
}</pre></div><p class="calibre8">Functions in Swift can now have multiple return values as part of a compound return value where you can use a tuple return type.</p><p class="calibre8">A tuple type is just a <a id="id271" class="calibre1"/>fancy term for a comma separated list of zero or types, which<a id="id272" class="calibre1"/> are enclosed in a parenthesis. So, to let a function have multiple return values, a tuple is what you need as shown here:</p><div><pre class="programlisting">func myFunc(iCount: Int) -&gt; (intA: Int, intB: int) {
  var intX = 1, intY = 2
  intA = iCount + intX
  intB = iCount + intY
  return (intA, intB)
}</pre></div><p class="calibre8">Then to use the return value, you need to assign it to a variable:</p><div><pre class="programlisting">let num = myFunction(10)
println("Value is \(num.intA) and \(num.intB)")</pre></div><p class="calibre8">Swift allows the default values in a function where a default value is used if a function parameter is not used:</p><div><pre class="programlisting">func add(num1: Int, num2: Int = 0)
{
  var total = num1 + num2
}</pre></div><p class="calibre8">So, in the preceding example, <code class="email">num2</code> will have a default value of 0 if you do not pass in a parameter for the second parameter in the add function, as shown here:</p><div><pre class="programlisting">add(1)</pre></div><p class="calibre8">Swift functions also allow the function to accept a variable number of arguments, which is useful when you need to pass in a varying number of parameters to a function. To enable a function to accept a varying number of parameters, you just need to add three full stops (<code class="email">...</code>) in your function, shown as follows:</p><div><pre class="programlisting">func getAverage(numbers: Double...) -&gt; Double
{
  var total: Double = 0
  for num in numbers {
    total += num
  }
  
  total = total&amp;/Double(num.count)
  return total
}</pre></div><p class="calibre8">So, you can call <a id="id273" class="calibre1"/>the <code class="email">getAverage</code> function using a varying number of parameters <a id="id274" class="calibre1"/>such as <code class="email">getAverage(1, 2, 3)</code> or <code class="email">getAverage(1, 2, 3, 4, 5)</code>. By default, Swift makes all function parameters as constant to promote good programming practice. This is one of the more unique features of Swift, which you do not find in other procedural programming languages such as C++, Objective-C, and so on. So trying to modify a function parameter will result in an error. However, if you need to modify a function parameter in your code, you just need to add the <code class="email">var</code> keyword to tell Swift to treat that function parameter as a variable, not as a constant, shown as follows:</p><div><pre class="programlisting">//num is now a variable and can be modified inside the function myFunction
func myFunction(var num: Int)
{
}</pre></div><p class="calibre8">One of the important changes that functions in Swift, different from Objective-C, is that you can have nested functions where a function is created inside another function. But do note that the inner function is only available to the enclosing function. To declare a nested function, you can just use a normal function call:</p><div><pre class="programlisting">func adder(num: Int)
{
  func addOne(number: Int) -&gt; Int   { return number + 1 }
}</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec36" class="calibre1"/>Classes and structures in Swift</h2></div></div></div><p class="calibre8">As you know, classes and <a id="id275" class="calibre1"/>structures are general purpose data structures that form the building block of the code of your application. You can define properties and methods to add functionality to these classes and structures using the same syntax as you will for the variables, functions, and so on.</p><p class="calibre8">Classes <a id="id276" class="calibre1"/>and structures<a id="id277" class="calibre1"/> in Swift have many common points such as:</p><div><ul class="itemizedlist"><li class="listitem">Defining properties to store values</li><li class="listitem">Defining methods to provide <a id="id278" class="calibre1"/>added functionalities</li><li class="listitem">The ability to be extended to expand their functionalities</li><li class="listitem">The possibility to conform to protocols to provide standard functionalities</li></ul></div><p class="calibre8">However, classes have other differences that structures do not possess; they are:</p><div><ul class="itemizedlist"><li class="listitem">Inheritance to allow a subclass to inherit the characteristic of another</li><li class="listitem">Type casting, which allows you to check and interpret the type of a class instance during runtime</li><li class="listitem">Reference counting, which allows more than one reference to a class instance</li><li class="listitem">Deinitializers, which allow a class to do resource freeing</li><li class="listitem">Structures are copied when they are passed around in your code</li></ul></div><p class="calibre8">To declare a <a id="id279" class="calibre1"/>class or <a id="id280" class="calibre1"/>structure, use the <code class="email">class</code> <a id="id281" class="calibre1"/>and <code class="email">struct</code> keyword<a id="id282" class="calibre1"/> respectively:</p><div><pre class="programlisting">class myClass {
  var x = 0
  var y = 0
}

struct myStruct {
  var x = 0
  var y = 0
}</pre></div><p class="calibre8">As in Objective-C, to use a <code class="email">struct</code> or <code class="email">class</code>, you need to create an instance of it before you can use it. So, for <code class="email">struct</code> and <code class="email">class</code>, you need to use the <code class="email">()</code> to create an instance of a <code class="email">class</code> or <code class="email">struct</code>.</p><div><pre class="programlisting">let classA = myClass()//creating an instance of a class
let structB = myStruc()//creating an instance of a struct</pre></div><p class="calibre8">To access a property in a <code class="email">class</code> or <code class="email">struct</code>, you can use the "<code class="email">.</code>" operator to access it, as shown here:</p><div><pre class="programlisting">var myX = classA.x
var myY = structB.y</pre></div><p class="calibre8">For classes, you can<a id="id283" class="calibre1"/> define your own custom initializer and deinitializer in your<a id="id284" class="calibre1"/> class file. Initializers for your struct members are <a id="id285" class="calibre1"/>automatically created for you, which you can use, as <a id="id286" class="calibre1"/>shown here:</p><div><pre class="programlisting">let yourStruct = myStruct(x: 50, y: 80)</pre></div><p class="calibre8">Generally, you do not need to do any manual cleanup of your allocated instances as Swift will do it for you using ARC. However, if you are using some custom resources, then you may need to do the additional cleanup yourself. One use case will be when you have a class that opens a text file and writes or appends some data to it. So, in this situation, you may need to close the file before your instance is deallocated. An example syntax of deinitialization is as follows:</p><div><pre class="programlisting">deinit{
//Your deinitialization code here which could be closing an open file etc
}</pre></div><p class="calibre8">One of the most important differences between a Swift class and Swift struct is that Swift classes are passed by reference, which means that a reference to the existing class instance is created when you assign it to another instance, and any change to the new instance will affect the original instance. This is in contrast with pass by value where a copy of the value is passed to the variable so that what happens in the new variable will not affect the original variable.</p><p class="calibre8">So, depending on this difference, sometimes using a class is more useful in some situations while in other situations using a struct would be better. It all depends on the context of your program or application. So, let's use some code to help us understand this better:</p><div><pre class="programlisting">classA = myClass()
classA.x = 80
classB = classA
classB.x = 100</pre></div><p class="calibre8">If you use the following code, you will notice that the <code class="email">classA</code> member <code class="email">x</code> will also be set to the value of <code class="email">100</code> as a reference to <code class="email">classA</code> is passed when you run the code <code class="email">classB = classA</code>. So, whatever affects <code class="email">classB</code> will also affect <code class="email">classA</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec37" class="calibre1"/>Closures</h2></div></div></div><p class="calibre8">Closures in Swift are<a id="id287" class="calibre1"/> known as blocks in <a id="id288" class="calibre1"/>Objective-C. Both have the same concept of creating self-contained blocks of code that can be passed around and used.</p><p class="calibre8">Closures use <code class="email">{</code> and <code class="email">}</code> to denote the beginning and end respectively. So, a very simple example of creating a closure and calling it would be something like this:</p><div><pre class="programlisting">  var name = "Gibson"
      var greet = {  println("Hello \(name)")   }
      greet()</pre></div><p class="calibre8">You can see the output <strong class="calibre2">Hello Gibson</strong> appearing in your debug console.</p><p class="calibre8">Of course, you will need to pass in arguments and get return values from your closures. You also need to use <code class="email">(</code> and <code class="email">)</code> to enclose your arguments and <code class="email">-&gt;</code> to denote your return values as you can see here:</p><div><pre class="programlisting">  var s1: String = "Howdy"
      var name: String = "Gibby"
      var holler = { (s1: String, name: String) -&gt; String in
            return s1 + " " + name
        }
        var ret = holler(s1, name)
        println(ret)</pre></div><p class="calibre8">If you run the code, you will get the output <strong class="calibre2">Howdy Gibby</strong> because I passed in two string variables of the names <code class="email">s1</code> and <code class="email">name</code> respectively as you can see from the line <code class="email">(s1: String, name: String)</code>, while I ask a return value of the type string using <code class="email">-&gt; String</code>.</p><p class="calibre8">Next, let's move on to memory management in Swift, which you still need to take note of as ARC frees you from a lot of memory management techniques, but you still need to take note of some memory management techniques in Swift as Swift can still leak memory if you are not careful.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec64" class="calibre1"/>Memory management in Swift</h1></div></div></div><p class="calibre8">Swift was created to avoid some of the <a id="id289" class="calibre1"/>downsides of C, one of which being memory<a id="id290" class="calibre1"/> management. Notice that nowhere in this chapter did I mention anything about pointers, memory allocation, deallocation, and so on. This is because in Swift, memory management is made to be as painless as possible so that you, the developer, can focus more on your application development than on debugging memory leaks. Every time a new instance of a class is created, ARC will allocate a chunk of the memory to be used to store information about that instance. This chunk of memory holds information such as the instance type (string, integer, and so on) along with the values of the properties that are associated with that instance. ARC will free up the memory used by that instance when it is no longer needed or referenced. This is to avoid a situation where instances still occupy precious memory space when they are no longer being used or needed.</p><p class="calibre8">However, if you try to access an instance's properties or methods after ARC has deallocated it, then a crash will be the likely result that you will see. So, to make sure that this does not happen to you, ARC will track how many properties, variables, and constants are currently referencing a class instance, and ARC will not allow deallocation as long as there is at least one active reference to that instance from another object in your code somewhere. A strong reference is created when you assign a class instance to a property, constant, or variable, and this strong reference keeps a strong hold on that class instance, and ARC will not make a deallocation call as long as that strong reference remains. Let's illustrate this with some code to understand this further:</p><div><ol class="orderedlist"><li class="listitem" value="1">Let's declare a class called <code class="email">Dog</code>:<div><pre class="programlisting">class Dog {
  let type: String
  init(_type: String) {
    self.type = _type
    println("Init done")
  }
  deinit {
    println("Deinit done")
  } 
}</pre></div></li><li class="listitem" value="2">Then, we will create two references to the <code class="email">Dog</code> class:<div><pre class="programlisting">var dog1: Dog?
Var dog2: Dog?</pre></div><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">Note that there is a <code class="email">?</code> keyword, which means that <code class="email">dog1</code> is of an optional type, which means that it could be nil. In Swift, any variable with a <code class="email">?</code> keyword means that there is a possibility that it can hold a nil value. Since we declared <code class="email">dog1</code> and <code class="email">dog2</code> as an optional type, it means that <code class="email">dog1</code> and <code class="email">dog2</code> are initialized with a value of nil and do not have a reference to the <code class="email">Dog</code> class.</p></div></li><li class="listitem" value="3">Next, we will <a id="id291" class="calibre1"/>create an instance and assign two <a id="id292" class="calibre1"/>variables, <code class="email">dog1</code> and <code class="email">dog2</code> respectively:<div><pre class="programlisting">dog1 = Dog(type: "Bulldog")
dog2 = dog1//1 strong reference to dog1 is created</pre></div><p class="calibre25">So, now there are two strong references to the <code class="email">Dog</code> instance. One is through <code class="email">dog1</code> and the other is from <code class="email">dog2</code> to <code class="email">dog1</code>.</p><p class="calibre25">One thing to note about Swift is that the type inference only works for the initial assignment; assigning another type to the same variable will throw an error. This is quite different from other languages such as JavaScript, where no error will be thrown. Let me illustrate what I mean with an example:</p><div><pre class="programlisting">var hello = "Hello World"//this means hello is inferred to have a type of string 
hello = 42 
//This will throw an error as now you are assigning an integer to a string variable</pre></div></li><li class="listitem" value="4">So, you can try assigning <code class="email">dog1</code> to nil, as shown here:<div><pre class="programlisting">dog1 = nil</pre></div><p class="calibre25">ARC will see that <code class="email">dog2</code> still holds a strong reference and will not deallocate the <code class="email">Dog</code> instance. The only time that the <code class="email">Dog</code> instance will be deallocated will be when <code class="email">dog2</code> is set to nil as shown here:</p><div><pre class="programlisting">dog2 = nil //this will let ARC deallocate the Dog instance</pre></div></li></ol><div></div><p class="calibre8">Conversely, Swift <a id="id293" class="calibre1"/>also supports weak references where the reference does<a id="id294" class="calibre1"/> not have a strong reference onto the instance that it references. So, ARC will dispose of an instance even if it has a weak reference. To create a weak reference, you need to use the <code class="email">weak</code> keyword as shown here:</p><div><pre class="programlisting">weak var cat: String?</pre></div><p class="calibre8">Notice that the <code class="email">?</code> keyword is added at the end of the <code class="email">String</code> keyword as a weak reference can be allowed to have a value of nil, so all weak references must be declared as optional using the <code class="email">?</code> keyword. Notice that it is also declared as a variable as weak references will have their values changed in the code during runtime. So, a weak reference cannot be declared as a constant as a weak reference does not have a strong hold on the instance it refers to. So, when this instance is going to be deallocated while the weak reference is still referring to it, ARC will set the weak reference to nil when that situation arises and you can check the value of a weak reference to see if that object has been deallocated. This way you can avoid a situation where you end up with a reference to an invalid instance that has already been deallocated by ARC.</p><p class="calibre8">In between strong and weak references, there is another type of reference that keeps a weak hold on an instance it refers to, but it cannot be set to nil, so it is always assumed to have a value. This is known as an <a id="id295" class="calibre1"/>unowned reference. It can be used as a replacement for a weak reference and for some use cases as we will see here:</p><div><pre class="programlisting">class Country {
  let name: String
  let capital: City!
  init(name: String, capital: String) {
    self.name = name
    self.capital = City(name: name, country: self)
  }

class City {
  let name: String
  unowned let country: Country
  init(name: String, country: Country) {
    self.name = name
    self.country = country
  }
}</pre></div><p class="calibre8">Notice that we initialize <code class="email">City</code> within the initializer method for <code class="email">Country</code>, but we also need to initialize <code class="email">Country</code> within the initializer method of <code class="email">City</code>, and this presents itself as a conundrum since <code class="email">Country</code> depends on the initializer of <code class="email">City</code> and <code class="email">City</code> depends on the initializer of <code class="email">Country</code>. To get a solution to this, you can declare the <code class="email">capital</code> variable of <code class="email">Country</code> as an implicit unwrapped optional property, which you denote by using <code class="email">!</code>. This means that the <code class="email">capital</code> property will have a default value as nil.</p><p class="calibre8">The <code class="email">!</code> keyword<a id="id296" class="calibre1"/> also serves as a unwrapping function where you can get the value of the property without assigning that property to a local variable. As mentioned earlier, a variable that is denoted with the optional symbol, which is a <code class="email">?</code> keyword, can either contain a value or nothing. So, when you are testing against this variable of the type denoted as optional, you need to know whether there is a value without directly accessing the underlying value. The <code class="email">!</code> keyword means that you can unwrap the variable to get access to the value.</p><p class="calibre8">However, this does not absolve you from checking whether that property is nil as you still need to check for nil in your code.</p><p class="calibre8">So, now what happens<a id="id297" class="calibre1"/> is that <code class="email">capital</code> has a default nil value and the <code class="email">Country</code> instanced <a id="id298" class="calibre1"/>is considered as fully initialized as soon as the <code class="email">Country</code> instance sets its <code class="email">name</code> property within its own initializer method. This means that the <code class="email">Country</code> initializer method can start to reference and pass around its <code class="email">self</code> property as soon as the <code class="email">name</code> property is set. So now the <code class="email">Country</code> initializer can therefore pass the <code class="email">self</code> property as one of the parameters for the <code class="email">City</code> initializer when the <code class="email">Country</code> initializer is setting its own <code class="email">city</code> property.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec65" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">As you can see, Swift is a big departure in terms of syntax, style, and paradigm from Objective-C. Swift was developed to move away from the C paradigm of programming where we need to wrap our heads around memory management, allocation, and deallocation. We went through some of the basic features of Swift and noted that Swift features more terse code, has made memory management, and is also fuss free, since ARC takes care of memory management for us in Swift. However, Swift is still in the beta stage at the time of this writing, so it can still be subject to changes in its journey to alpha and release status. Therefore, you can expect that some features will be added or removed during this period. However, the fundamentals of Swift will not be changed significantly, and I hope that this chapter has given you a better understanding of Swift and has prepared you for programming in Swift in the near future. </p><p class="calibre8">To find out more information about Swift, the best resource to refer to is Apple's website on Swift programming at <a class="calibre1" href="https://developer.apple.com/swift/blog/">https://developer.apple.com/swift/blog/</a> as it has been updated constantly since Swift was announced.</p><p class="calibre8">In the next chapter, we will look at memory management techniques using some of the excellent tools in Xcode, such as Static Analyzer, and we will also cover more details on the various techniques so that you will know which debugging tool is the best tool to use in different situations.</p></div></body></html>