- en: Chapter 7. Debugging with REPLs and Command Lines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。使用 REPL 和命令行进行调试
- en: This chapter takes a break from programming the database API by looking at two
    different support tools and how to include a debugging web server in your iOS
    apps. This server can be used in any app to provide additional access supplementing
    the normal user interface. Being able to dump data is an important feature expected
    by most database developers—SQL systems usually have a way to execute raw SQL
    against the server. Including the server is more work than using the tools, but
    they can't be run against data on a device; only on OS X (which includes data
    in your simulator working directory).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章暂时放下对数据库 API 的编程，通过查看两个不同的支持工具以及如何在您的 iOS 应用中包含一个调试 web 服务器来休息。这个服务器可以用于任何应用，以提供补充正常用户界面的额外访问。能够导出数据是大多数数据库开发者期望的重要功能——SQL
    系统通常有在服务器上执行原始 SQL 的方法。包含服务器比使用工具要麻烦，但它们不能在设备上的数据上运行；只能在 OS X（包括您的模拟器工作目录中的数据）上运行。
- en: Building and running the LevelDB dump utility
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行 LevelDB 导出工具
- en: 'The standard LevelDB source distribution includes a dump utility, but it is
    not built by default with the `Makefile`. This dump lets you see a raw copy of
    the content of your tables. After you have built LevelDB for a given setting,
    you can build the dump with the following command:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 LevelDB 源代码分发包括一个导出工具，但它不是通过默认的 `Makefile` 构建的。这个导出工具让您可以看到您表内容的原始副本。在您为给定设置构建了
    LevelDB 之后，您可以使用以下命令构建导出：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you built your LevelDB using a `CXXFlags` setting, then you need to build
    the `util` with the same settings and repeat them in `LDFlags` to ensure LevelDB
    builds. The single command line looks like the following (without wrapping):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `CXXFlags` 设置构建了 LevelDB，那么您需要使用相同的设置构建 `util` 并在 `LDFlags` 中重复它们以确保 LevelDB
    构建。单个命令行看起来如下（没有换行）：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you have already seen, a LevelDB database creates a number of files within
    a folder. The roles of these files are explained further in [Chapter 10](ch10.html
    "Chapter 10. Tuning and Key Policies"), *Tuning and Key Policies*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，LevelDB 数据库在文件夹内创建了许多文件。这些文件的作用在 [第 10 章](ch10.html "第 10 章。调整和关键策略")
    *调整和关键策略* 中进一步解释。
- en: Depending on what you have been doing with a database, it may not have generated
    any `.sst` files. Some of our quick operations which only add a few records will
    only create `.log` files. `Sample06x` uses 50,000 records and writes in batches
    of 1,000 so it guarantees writing more than one `.sst` file to give us a much
    more interesting dump. You will see `Sample06x` discussed in more detail in the
    next chapter, but for now it has two key types, prefixed by `N~` and `P~`, which
    are added in an alternating sequence in our code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对数据库的操作，它可能没有生成任何 `.sst` 文件。我们的一些快速操作，仅添加少量记录，只会创建 `.log` 文件。`Sample06x`
    使用 50,000 条记录，以每批 1,000 条的方式写入，因此它保证了写入多个 `.sst` 文件，给我们一个更有趣的导出。您将在下一章中更详细地讨论
    `Sample06x`，但现在它有两个关键类型，以 `N~` 和 `P~` 开头，它们在我们的代码中以交替的顺序添加。
- en: The accompanying code contains a log of the build of the `leveldbutil` as well
    as several logs of running it. A heavily elided one for the large `Sample06x`
    is in the file `log of dump` `testLeveldb06x.txt` and shows the utility being
    run over the database folder created by running `Sample06x` on OS X.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的代码包含 `leveldbutil` 构建日志以及运行它的几个日志。对于大型 `Sample06x` 的一个高度省略的日志在文件 `log of
    dump` `testLeveldb06x.txt` 中，显示了在 OS X 上运行 `Sample06x` 创建的数据库文件夹上运行的工具。
- en: The first file that we will look at is the `MANIFEST` file which shows how the
    number of writing passes was batched and also that a special comparator was used
    (explained in the next chapter). Your main concern with comparators for now, is
    that the dump utility ignores them, but other tools such as lev (see the following
    code) cannot open a database using a custom comparator. So, using `leveldbutil`
    to check the `MANIFEST` file lets you check for this as a point of failure, if
    you have other programs getting errors on opening.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个文件是 `MANIFEST` 文件，它显示了写入遍历是如何分批的，以及使用了特殊的比较器（下一章中解释）。目前您对比较器的关注主要是，导出工具忽略了它们，但其他工具如
    lev（见以下代码）无法使用自定义比较器打开数据库。因此，使用 `leveldbutil` 检查 `MANIFEST` 文件让您可以检查这一点作为失败点，如果您有其他程序在打开时出错。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next file is the log file—there's only one active log file so you can use
    a command using `*.log` as shown here. The log contains the last lot of records
    written, from line 42001 in the input file onwards.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文件是日志文件——只有一个活动日志文件，因此您可以使用`*.log`作为此处所示命令。日志包含最后一批写入的记录，从输入文件的42001行开始。
- en: The log then shows an elided dump of two `.sst` files which are the sorted tables.
    The LevelDB processing creates these as an immutable store, leaving only recent
    entries in the `.log` file. Note how the two tables have an apparently interleaved
    set of keys.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 日志随后显示了两个`.sst`文件的省略输出，这两个文件是排序表。LevelDB处理创建这些不可变存储，只留下`.log`文件中的最近条目。注意这两个表有一个看似交织的键集。
- en: Installing Node.js and the lev utility
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.js和lev实用工具
- en: The popular node environment provides a server-side or command-line environment
    for running JavaScript programs that also supports console and even desktop programs
    (using packagers such as `AppJS`). Among the many libraries created for node are
    LevelUP and LevelDOWN. LevelDOWN is a simple wrapper for the C++ binding to LevelDB,
    providing the standard LevelDB API mapped to JavaScript functions. LevelUP started
    as a high-level interface to LevelDOWN but is now also an abstraction layer allowing
    other backends to be used that provide the LevelDB functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的node环境提供了一个服务器端或命令行环境，用于运行JavaScript程序，同时也支持控制台甚至桌面程序（使用`AppJS`等打包器）。为node创建的许多库中包括LevelUP和LevelDOWN。LevelDOWN是LevelDB
    C++绑定的简单包装器，提供了映射到JavaScript函数的标准LevelDB API。LevelUP最初是LevelDOWN的高级接口，但现在也是一个抽象层，允许使用提供LevelDB函数的其他后端。
- en: The **lev** utility , from [https://github.com/hij1nx/lev](https://github.com/hij1nx/lev)
    provides a commandline and GUI for directly working with a LevelDB database using
    these libraries. It installs both LevelUP and LevelDOWN. We are just concerned
    with using lev as a utility without caring about how it is implemented. The installer
    for node is available from [http://nodejs.org/](http://nodejs.org/) and is a simple
    GUI installer putting both node and the **npm** (**Node Package Manager**) into
    `/usr/local/bin`. You will also need to install Python 2.7 from [http://www.python.org/download/releases/2.7.5/](http://www.python.org/download/releases/2.7.5/)
    in order to build LevelDown (ironically, yes, Python is used to script building
    a C++ binding for a JavaScript tool).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[https://github.com/hij1nx/lev](https://github.com/hij1nx/lev)的**lev**实用工具提供了一个命令行和GUI，可以直接使用这些库与LevelDB数据库进行工作。它安装了LevelUP和LevelDOWN。我们只关心将lev作为一个实用工具使用，而不关心其实现方式。Node.js的安装器可以从[http://nodejs.org/](http://nodejs.org/)获取，是一个简单的GUI安装器，将node和**npm**（Node包管理器）放入`/usr/local/bin`。您还需要从[http://www.python.org/download/releases/2.7.5/](http://www.python.org/download/releases/2.7.5/)安装Python
    2.7，以便构建LevelDown（讽刺的是，是的，Python用于脚本构建JavaScript工具的C++绑定）。
- en: 'The accompanying `log of lev install with node package manager.txt` shows the
    installation of these packages in detail including the errors that occur if you
    have not upgraded the default Python version in your OS X. The install is triggered
    by a single command which automates downloading, building, and installing the
    packages in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随的`使用node包管理器安装lev的日志.txt`详细显示了这些包的安装过程，包括如果您未升级OS X中的默认Python版本时发生的错误。安装由单个命令触发，自动下载、构建和安装以下包：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you have lev installed, it offers command-line dumping of keys, deleting
    records, and adding new ones. See `log of dump testLeveldb06x.txt` for more examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了lev，它就提供了命令行导出键、删除记录和添加新记录的功能。请参阅`dump testLeveldb06x.txt的日志`以获取更多示例。
- en: Adding a REPL for debugging inside your iOS app
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的iOS应用内添加REPL进行调试
- en: The term **REPL** is commonly used in scripting languages and means **Read Eval
    Print Loop**. A REPL typically accepts commands and prints their result, then
    loops to accept the next command. It's like the terminal command line but embedded
    in an app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**REPL**这个术语在脚本语言中常用，意味着**读取-评估-打印-循环**。REPL通常接受命令并打印其结果，然后循环接受下一个命令。它就像终端命令行，但嵌入在应用中。'
- en: 'The `Sample07` code provides an example of an iPhone app that includes a small
    web server and provides a REPL for database operations. This app can be run on
    a simulator as well as a device. The following screenshot shows it running on
    the simulator, so the IP address shown is that of the OS X development system
    running the simulator:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample07`代码提供了一个包含小型Web服务器并为数据库操作提供REPL的iPhone应用的示例。该应用可以在模拟器和设备上运行。以下截图显示了它在模拟器上的运行，因此显示的IP地址是运行模拟器的OS
    X开发系统的地址：'
- en: '![Adding a REPL for debugging inside your iOS app](img/1015OS_07_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在你的iOS应用程序内添加REPL进行调试](img/1015OS_07_01.jpg)'
- en: The status report when debugging in Simulator, showing the address used to browse
    to the device
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中进行调试时的状态报告，显示用于浏览设备的地址
- en: 'Once you are running the application, you can launch a web browser and type
    in this address, **192.168.0.51:8080,** as shown in the preceding screenshot.
    You can connect multiple browsers to the server from anything—use an iPad to query
    the database on an iPhone or iPod Touch! The web server is running totally in
    the background so your normal app behavior can continue. This makes it a debugging
    tool you can drop into any application (warning: this will be a security hole
    if included in distributed apps, unless you add authentication).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正在运行应用程序，你可以打开一个网页浏览器并输入此地址，**192.168.0.51:8080**，如前一张截图所示。你可以从任何设备连接多个浏览器到服务器——使用iPad在iPhone或iPod
    Touch上查询数据库！网络服务器完全在后台运行，因此你的正常应用程序行为可以继续。这使得它成为一个可以插入任何应用程序的调试工具（警告：如果包含在分布式应用程序中，这将是一个安全漏洞，除非你添加了身份验证）。
- en: 'The first version of the REPL looks for known commands, or if it doesn''t recognize
    a command, it assumes you''re entering a partial key to be searched. The results
    of entering `Am` are shown in the following screenshot. Some server commands are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: REPL的第一个版本会寻找已知的命令，或者如果它没有识别出命令，它假定你正在输入一个要搜索的部分键。输入`Am`的结果如下所示。一些服务器命令包括：
- en: '`help` lists commands and their syntax, see the `readme.md` document'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help`列出命令及其语法，请参阅`readme.md`文档'
- en: '`prefix aKey` sets `aKey` as the prefix on any keys from now'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix aKey`将`aKey`设置为从现在起任何键的前缀'
- en: '`unprefix` clears the key prefix'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unprefix`清除键前缀'
- en: '`put akey aValue`adds key `aKey` value `aValue`, quoted to include spaces,
    using `\` to embed quotes, for example `put Author "Andy Dent"`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put akey aValue`添加键`aKey`的值`aValue`，使用引号包含空格，使用`\`嵌入引号，例如`put Author "Andy
    Dent"`'
- en: '`get akey` returns the full value associated with `akey`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get akey`返回与`akey`关联的完整值'
- en: '`del akey` deletes the key `akey`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del akey`删除键`akey`'
- en: '`count fromPart toPart` just counts records, with both `fromPart` and `toPart`
    being optional (it runs an iterator over that range of partial keys)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count fromPart toPart`仅计算记录，其中`fromPart`和`toPart`都是可选的（它在该部分键范围内运行迭代器）'
- en: '`keys fromPart toPart` lists keys, both `fromPart` and `toPart` being optional'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys fromPart toPart`列出键，其中`fromPart`和`toPart`都是可选的'
- en: '`stats` displays the database statistics'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stats`显示数据库统计信息'
- en: '![Adding a REPL for debugging inside your iOS app](img/1015OS_07_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![在你的iOS应用程序内添加REPL进行调试](img/1015OS_07_02.jpg)'
- en: The browser result after entering Am as a command, connected to iPhone
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输入Am作为命令后的浏览器结果
- en: The web server engine being used is the open source `GCDWebServer` from [https://github.com/swisspol/GCDWebServer](https://github.com/swisspol/GCDWebServer)
    and templated page generation uses `GRMustache` from [https://github.com/groue/GRMustache](https://github.com/groue/GRMustache)
    to provide templates using the common **Mustache** syntax of double braces `{{bracketing}}`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正在使用的是开源的`GCDWebServer`，来自[https://github.com/swisspol/GCDWebServer](https://github.com/swisspol/GCDWebServer)，模板页面生成使用`GRMustache`，来自[https://github.com/groue/GRMustache](https://github.com/groue/GRMustache)，以提供使用双大括号`{{括号}}`的通用**Mustache**语法模板。
- en: The combination of these two source suites are being rolled up into one product
    adds code to make it easier to write your own REPL for embedded debugging, at
    [https://github.com/AndyDentFree/REPLierGCDWebServer](https://github.com/AndyDentFree/REPLierGCDWebServer)
    that will continue to be maintained after the book launch as a generic REPL toolkit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个源套件的组合正在合并成一个产品，增加了代码，使编写自己的嵌入式调试REPL更容易，在[https://github.com/AndyDentFree/REPLierGCDWebServer](https://github.com/AndyDentFree/REPLierGCDWebServer)上，该工具包将在本书发布后继续维护，作为一个通用的REPL工具包。
- en: The `Sample07` logic to provide web templates is inside `ASDLevelDBREPL.m` and
    can be added very easily to any app with just one property. Add a `ASDLevelDBREPL`
    `*` property then start it and set its db property to the `APLevelDB*` property
    that you created in `Sample06`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提供Web模板的`Sample07`逻辑在`ASDLevelDBREPL.m`中，并且可以非常容易地添加到任何应用程序中，只需添加一个`ASDLevelDBREPL`
    `*`属性，然后启动它并将它的db属性设置为在`Sample06`中创建的`APLevelDB*`属性。
- en: 'In `Sample07`, this is done in `GSdLDB07ViewController.m` in `viewDidLoad`,
    a slightly simplified version being:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Sample07`中，这是在`GSdLDB07ViewController.m`的`viewDidLoad`中完成的，一个稍微简化的版本如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Summary
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a couple of pre-built utilities for looking at different aspects
    of a database and learned a valuable way to add a debugging REPL to any iOS app.
    Next, we will go back to the intricacies of our GUI support with a richer version
    of `Sample06`. The next chapter will also discuss ways to store more information
    making our databases self-describing, so a more powerful database layer can be
    built up to abstract away some of these responsibilities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几种预构建的实用工具，用于查看数据库的不同方面，并学习了一种向任何iOS应用添加调试REPL的有价值方法。接下来，我们将回到我们GUI支持的复杂性，使用更丰富的`Sample06`版本。下一章还将讨论存储更多信息的方法，使我们的数据库能够自我描述，从而可以构建一个更强大的数据库层，以抽象掉一些这些责任。
