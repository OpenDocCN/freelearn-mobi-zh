- en: Chapter 2. Failing Faster with Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is all about getting a wireframe of the project going so that
    you can fill in the "meat" of the game later. You''ll be getting baseline graphics,
    menus, and the game''s flow structure outlined for testing faster than you can
    blink. Test sooner, fail faster—this is your new motto as a game developer. Even
    though it may seem very simple to code, that''s our intent: to create the minimum
    viable product—something tangible and working—as soon as possible in order to
    get a feel of the overall project. We''re going to cover the following in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why prototype?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a scene up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating text (labels)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning using sprite sheets with TexturePacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating menus, scenes, and scene transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating nodes and units (sprites)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout this book, a complete game will be created from beginning to end,
    starting with this chapter. Creating an ongoing project will serve two purposes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Show how each section can fit within a full project and not just as a piece
    of code all on its own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualize the process of an entire project from the beginning to the end without
    skipping any step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the files included with this book, you can find the finished project to see
    what it's going to look and feel like. Also, at the beginning of each chapter,
    there will be a reference to the version of the project up to that point in the
    book so that you can follow along with the complete explanation/examples in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, the project is created as a fresh project by following the tutorial
    in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d Knowledge"),
    *Refreshing Our Cocos2d Knowledge*. If you would rather use a default starting
    point, you can use the project in the blank `Project` folder in the files included
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the code from [https://github.com/keitzer/MasteringCocos2d](https://github.com/keitzer/MasteringCocos2d).
  prefs: []
  type: TYPE_NORMAL
- en: File suffixes versus directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Cocos2d and SpriteBuilder became integrated in Cocos2d 3.0, they changed
    the way textures are read in by Cocos2d. In previous versions, if you wanted to
    make a game for the iPhone and the iPad, you had to add various suffixes to your
    file. For example, if your image was named `btnPlay.png`, you had to create variously
    sized files in your project, which were named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`btnPlay.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btnPlay-hd.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btnPlay-ipad.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`btnPlay-ipadhd.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This methodology of getting your files saved is typically referred to as using
    **file suffixes**.
  prefs: []
  type: TYPE_NORMAL
- en: In the newer iteration of Cocos2d with SpriteBuilder, one of the ways you can
    manage your textures is by dragging a file of the largest possible size (for example,
    Retina iPad) into SpriteBuilder. When you click on **Publish**, SpriteBuilder
    will take care of the file size variations for you. This way of handling files
    is referred to as using **directories**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a warning: if you decide to manually add files to the `Published-iOS`
    folder, do not click on **Clean Cache** in SpriteBuilder, or else you will lose
    all of those files.'
  prefs: []
  type: TYPE_NORMAL
- en: However, using directories has its drawbacks. For example, you may want to use
    TexturePacker (which we will use later in this chapter, as well as throughout
    the book), but there is no easy way to use it and the new directory style of saving
    files. You technically can, but it's such a pain that any advantage TexturePacker
    has is negated by the extra work you have to do. So TexturePacker can work with
    the directory style of file reading. Thus, it's just easier to drag the files
    into SpriteBuilder if you're going to use the directory style.
  prefs: []
  type: TYPE_NORMAL
- en: So how will we work around this problem if we want to take advantage of TexturePacker?
    Well, until there exists a version of Cocos2d and SpriteBuilder that integrates
    the use of TexturePacker, we have to go back to the file suffix method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you do not wish to purchase TexturePacker, don't worry; it's not
    required. The later code will stay the same, as Cocos2d searches for the image,
    whether it was loaded via sprite sheets or as an individual file. If you do not
    wish to use TexturePacker, feel free to avoid changing your search mode (as mentioned
    next) and just go ahead with the directory method. Whenever this book mentions
    adding a file to the sprite sheet, that's your queue to add it to SpriteBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Cocos2d 3.0 and higher versions use the directory method by default,
    and since we''re going to switch to using file extensions, we must look up the
    Xcode project for **CCFileUtilsSearchModeDirectory**. One of the results should
    be a file called `CCBReader.m`. Click on the result and it should take you to
    approximately line 109, where you''ll see the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re going to change that line to use the suffix search mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, we're ready to begin the prototype phase of our project.
    But first, why is it important to make a prototype? And why is it important to
    create it quickly? Why not just code the game slowly and eventually get the core
    mechanics of the game in whenever it's time?
  prefs: []
  type: TYPE_NORMAL
- en: Why prototype?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the obvious reason of asking your friends "is it fun?!" before it''s
    fully complete, prototyping your game, especially quickly and early on in development,
    can be very useful for a few different reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can ask about the originality/innovation of your game from the perspective
    of an end user instead of just your own views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate ideas on how to improve the game way before it's too late to
    make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get a feel of how the game actually flows from one stage to the next,
    and conceive a tangible product instead of just an idea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If shown to the public, it could be a great way to begin the marketing of your
    game and beginning the snowball of exposure needed to succeed on iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus, this is the best way to start a project, especially a project that includes
    new concepts or ideas that might be hard to get fully coded and work as intended.
    You might have heard of the term **proof of concept**; this chapter is exactly
    what that is. It's a very quick overview of your entire game that you can show
    to others and ask, "This is proof that I can make this concept into a full-blown
    game. What do you think?"
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've understood why making a prototype for your game is a good idea,
    let's quickly go over the project this book will be covering.
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting and feedback analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have your prototype ready for others to experience, it's best to go
    out and actually get some people to play your game. Ideally, you should find playtesters
    who are knowledgeable in that game's genre as well as within the age range of
    your game's target audience so that they can give quality feedback.
  prefs: []
  type: TYPE_NORMAL
- en: The feedback you receive will vary from "Wow! This is amazing!" to "I don't
    understand how to play this game." You have to be prepared to hear all kinds of
    responses. Also, just because someone says your game is bad might not necessarily
    mean it is bad. However, if what they're saying is objectively true, and implementing
    what they have to say will improve your players' experience, then you should listen
    to their opinion as it will make not only your current game but also future games
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, let's get into actually making a project that others can play.
  prefs: []
  type: TYPE_NORMAL
- en: Project for the book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get an idea of the project this book will be going through, imagine a 9 x
    9 grid with your "base" at the center and enemies spawning around the squares
    at the edges. It's a turn-based game. On each turn, every unit moves one square.
    Each unit has a number that increases by one every turn. If your unit collides
    with the enemy's unit, the two numbers subtract and whichever unit has a positive
    result stays alive. Your goal is to protect your main base from an enemy unit,
    surviving an attack on your main base for as many turns as you can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few screenshots of the finished game (by the end of [Chapter 7](part0057.xhtml
    "Chapter 7. Reaching Our Destination"), *Reaching Our Destination*):'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the game first starts up, it will look like what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project for the book](img/image00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The game midway through a session will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project for the book](img/image00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The game over screen, when the central square is taken, will look like what
    is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project for the book](img/image00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A quick mock-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether it's Photoshop, Illustrator, MS Paint, a paper and a pencil, a whiteboard,
    crayons, or any other creative way to draw your ideas, it's best to get a visual
    of the project so that when you begin to code, you at least have a basis for why
    you're choosing the colors and text positions that you are choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, even though we have screenshots of the finished product, which we
    just saw, we need to imagine where to start. For example, in the following screenshot,
    you'll see a quick mock-up made for this book's project, as described earlier.
    The dimensions are 2048 x 1536 (iPad landscape). It was done relatively quickly
    for the purpose of showing the game as a concept, not as a finished product that
    is meant for marketing purposes. Don't worry; yours doesn't have to look as good
    as this if your art skills are lacking.
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick mock-up](img/image00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of a great starting point because it doesn't have any menus
    or fancy transitions; just the game. I know there's a button that says **Menu**,
    but that's intended for later use, when we actually implement the menu. Remember,
    a prototype is supposed to be quick. It doesn't matter if the graphics, colors,
    fonts, or even the menu placements or word choices change. The point is to get
    it up as fast as possible. *Test sooner, fail faster*.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of how the Cocos2d engine works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go too deep into the code, let's quickly go over how the Cocos2d engine
    works. If you're using Cocos2d for the first time, this should be helpful. If
    you've used Cocos2d before, feel free to read through this, as it might be a refresher
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Cocos2d is essentially a series of parents and children. The base parent is
    the currently running scene. You can have only one scene displayed at any given
    time. Within the scene, there will be children, all of which have to be of the
    `CCNode` type. A `CCNode` object is an object that has a position, rotation, scale,
    color, and various other properties. A `CCNode` object can have other `CCNode`
    objects added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Each subclass of `CCNode` inherits from it and adds functionality on top of
    the `CCNode` class. For example, if we want to draw an image on the screen, we'll
    use `CCSprite`, which is essentially a `CCNode` object, but with an image attached.
    Even a scene (type of `CCScene`) is a subclass of `CCNode` (which is how each
    scene can have children).
  prefs: []
  type: TYPE_NORMAL
- en: Here's an image made to help describe the relationship between parents and children
    within Cocos2d. First, we have the individual images we want to display on the
    screen, in a very simple texture atlas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of how the Cocos2d engine works](img/image00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we have a diagram of an example of `CCScene`. Added to the scene are
    five `CCSprite` objects: the sky, the two trees, the road, and the player.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of how the Cocos2d engine works](img/image00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sky is positioned at z-index equal to 0, the trees at z-index equal to 1
    (which means they'll be displayed in front of the sky), the road at z-index equal
    to 2 (which means it'll be displayed in front of both the sky and the trees),
    and the player at z-index equal to 3 (which means it'll be displayed in front
    of everything). The default z-index is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Everything else in Cocos2d is simple—just a `CCNode` object with other `CCNode`
    objects added as children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one thing to remember about the parent-child relationship that Cocos2d
    uses: if you move a parent by 20 points, for example, the children will also be
    moved by the same amount.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've briefly gone over how Cocos2d works, let's get our prototype
    going.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a scene up and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we even start adding anything to the screen, we need to make sure we
    have a game that can be viewed on our device or a simulator. Once you've created
    the project in SpriteBuilder (or gotten the blank project that was listed earlier)
    and opened the project in Xcode, go to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the initial code for the scene to open
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should see a file called `MainScene.h` and another file called `MainScene.m`.
    Open the header file (which has the `.h` extension).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header file, add a few lines of code between the `@interface` line and
    the `@end` line. The header should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the main file (which has the `.m` extension), some lines of code should
    be added between the `@implementation` and `@end` lines. It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open the `AppDelegate.m` file and scroll to the bottom, where you
    should see a line in the `startScene` method that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code might give you an error for this line. This can be fixed by importing
    the `MainScene` header to the AppDelegate''s main file. Simply add this to the
    top of the `AppDelegate.m` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once all of this has been put in place, feel free to run your project on either
    your device or the simulator built into Xcode. You can read more about each option
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Run it on the simulator – doesn't require an iOS developer license
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running on the simulator is good for testing devices you don't own. For example,
    if you own an iPhone 5s and want to test how your game looks on an iPhone 6 or
    6 Plus, simply load that simulator and test to see how the game looks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that it's best to test for performance on the device only. Do not test
    for performance on the simulator. You will never get a perfect representation
    of the device's capabilities when running on the simulator. Also, you should test
    only how the game looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing on the simulator, simply choose which device you wish to simulate
    from the simulators available in Xcode as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Run it on the simulator – doesn''t require an iOS developer license](img/image00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Choose any simulator you want, preferably a simulator that your game will eventually
    be supported on, and either press the play button on the left, or hit *command*
    +*R* to run it. It might take a few minutes to open the simulator, so be patient.
    But once it does, it should automatically open on the simulator. If it doesn't,
    just try rerunning it with the simulator already open.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! If you have used the simulator, you now have a project that
    runs! Next, we are going to go over how to run it on device.
  prefs: []
  type: TYPE_NORMAL
- en: Run it on the device – requires an iOS developer license
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're unsure whether you want to run your game on a device or on the simulator,
    let me explain why the device is the king in terms of testing purposes. Not only
    do you get to see and feel the project just as any other user would, but you also
    get to experience the actual performance of the device rather than a simulated
    version of it. Plus, if your project is heavy on touchscreen usage (which it honestly
    should, or else it probably shouldn't be an iOS title), then you can effectively
    test the feel of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing on the device, simply plug in your device. Its name should be listed
    in Xcode, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Run it on the device – requires an iOS developer license](img/image00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you do not see the name of your device, make sure you select the iOS device
    target, and not any of the simulators. If your device is plugged in and it still
    shows **iOS Device**, make sure you have a developer account subscription in Xcode.
    Refer to [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d Knowledge"),
    *Refreshing Our Cocos2d Knowledge*, for more details on this.
  prefs: []
  type: TYPE_NORMAL
- en: Once you see the name of your device, either press the **Play** button on the
    left, or hit *command* +*R* to run it. It might take a minute or so to build,
    but once it's complete, the project will automatically open on your device.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You now have a project that runs. Now we can start adding some
    content, such as text and buttons, and then move on to creating another scene
    and transitioning to that and back to the original.
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons and text (labels)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to place a line of text on the screen, you need to create a label.
    There are two types of labels in Cocos2d: `CCLabelBMFont` and `CCLabelTTF`. Bitmap
    Font labels are the fancy labels created with Glyph Designer, mentioned earlier
    in this book. TrueType Font labels are regular, unformatted text labels that use
    either a font file that''s already on the phone or a file you''ve added to your
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you have a label that often needs updating, for example, a score
    counter or a health value, it's more efficient to use BMFonts in those cases,
    even if the font is a plain white font and looks exactly the same in TTF format.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some text displayed – CCLabelTTF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, TTF labels are simple, unformatted labels. How are these
    useful? The answer is, you can quickly get the prototype of your game going, and
    so you can better understand the flow of the game. Then, once it's ready, you
    can switch over to using BMFonts to make it look nice. See [Chapter 6](part0049.xhtml
    "Chapter 6. Tidying Up and Polishing"), *Tidying Up and Polishing*, to learn more
    about ways to improve the aesthetics of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a short note about BMFonts: if you want to use them in your game, which
    you should do for performance reasons alone, keep in mind the various limitations
    that BMFonts have and TTF fonts don''t. The first is poor quality when upscaling
    the label. Then, BMFonts can use only the characters that are in the font atlas,
    and any foreign language support might mean a lot of extra BMFonts, which could
    add up quickly in terms of space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''re going to do is get those labels on the left side going.
    The following code should be added to `MainScene.h` (the `lbl` prefix in the front
    of the variable will indicate to us that it''s a label; similarly, `btn` for button,
    `num` for number, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code goes into the `init` method of `MainScene.m` and will create
    the labels. We then want to set the position for each label because the default
    position is in the bottom-left corner. Finally, we add each label to the scene.
    Remember, the scene is just a node that can have as many children as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've used the `winSize` variable for positioning. This is useful
    because it not only keeps things in a relative position on the screen but also
    helps when coding for multiple devices that have different screen sizes (for example,
    iPhone 4, iPhone 5, iPad, and so on have different dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to handle this would be to set the `positionType` of our labels
    to `CCPositionTypeNormalized`. Then we can set our position values anywhere from
    `0` to `1`, `0` being the far left (or bottom) of the screen, and `1` being the
    far right (or top) of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some text displayed – CCLabelBMFont
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you aren''t already familiar, let''s recall: BMFonts are the nice, stylized
    fonts that give your game that extra level of polish without requiring too much
    effort from you. Refer to [Chapter 6](part0049.xhtml "Chapter 6. Tidying Up and
    Polishing"), *Tidying Up and Polishing*, to improve the aesthetics of your game.
    To create BMFont, you have to use a BMFont creator. We''re going to use Glyph
    Designer, as mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your
    Cocos2d Knowledge"), *Refreshing Our Cocos2d Knowledge*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you followed the preceding TTF section, then you can just comment out or
    remove those lines of code, since we are going to redo those fonts and make them
    BMFont labels in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''re going to do is create the fonts on the left side of
    our scene. With Glyph Designer open, select a font from the left panel (I chose
    **Britannic Bold**, the font in the mock-up). You can mess around with the settings
    on the right to get a font suitable for your project, but remember that this is
    only a prototype and you shouldn''t spend too much time on it. Have a look at
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Let''s get some text displayed – CCLabelBMFont](img/image00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure the font size isn't too big or too small. As you can see in the preceding
    screenshot, it's set to 60\. This is a decent size for the project. If it ends
    up being too big or too small, adjusting it is fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: When you're satisfied with the settings you have chosen, click on **Save As**
    at the top, and select where you want to save the Glyph Designer file (not the
    actual font file). Now that it has been saved for later use if we decide to edit
    the font, let's move on to exporting the font so that we can use it in Cocos2d.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which style of file reading you decided to go with, there are two
    different ways you'll need to export the font. Make sure you follow the same style
    as you can use only one of the styles (but not both) within the same project.
    No matter which route you go by, start with the largest font size you'll need;
    for example, the preceding screenshot shows a font size of 60 because it's going
    to be seen on a Retina iPad. If it were only on an iPhone, 60 would be too large.
  prefs: []
  type: TYPE_NORMAL
- en: Saving your BMFont using file suffixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Glyph Designer, click on **Export** at the top and navigate to the `Resources/Published-iOS`
    folder in your project directory (see the following screenshot). This is where
    you'll export the font for use with Cocos2d. Notice that because this is the largest
    font, meant for Retina-sized iPads, the suffix after the filename is `-ipadhd`.
    If you weren't designing for iPad, your largest filename suffix would be `-hd`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you should leave the `.fnt`/`.png` extension (see the following screenshot)
    as it is. Glyph Designer will automatically add that for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving your BMFont using file suffixes](img/image00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you've exported the largest phone, go ahead and adjust the settings for
    each tier you need. For example, since we're exporting `-ipadhd` at the 60-point
    font, we'd also want to make 30-point and 15-point sizes for smaller devices.
    In addition to reducing the font size, we can also modify the stroke and shadow
    settings to give relatively the same look for all sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So overall, if you call your font `bmFont`, you should have the following files
    (each `.fnt` file will also have a `.png` file with it), with the largest font
    size being 60:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bmFont-ipadhd.fnt - 60-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bmFont-ipad.fnt - 30-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bmFont-hd.fnt - 30-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bmFont.fnt - 15-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Saving your BMFont using file suffixes](img/image00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When using the file extension method, as long as you export your files to the
    `Published-iOS` folder, the Xcode project remains set up in a way that includes
    your fonts in the project. In this way, you don't need to worry about copying
    anything. That being said, let's begin displaying labels with this new font we
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Saving your BMFont using directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you chose to go with directories, it''s not as simple as just dragging the
    font files into SpriteBuilder (at the time of writing this book). Instead, you
    must create four folders within the `Published-iOS` folder of your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources-phone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-phonehd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-tablet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-tablethd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Saving your BMFont using directories](img/image00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In Glyph Designer, click on **Export** at the top and navigate to the `Published-iOS/resources-tablethd`
    folder in your project directory (see the following screenshot). This is where
    you'll export the font for use with Cocos2d. The name of the file here is going
    to be the name of the font.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leave the `.fnt`/`.png` extension as it is (see the following screenshot). Glyph
    Designer will automatically add it for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving your BMFont using directories](img/image00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the `tablethd` version has been exported, do the same export but modify
    the font size and any other settings you wish to modify. For example, since we're
    exporting the `tablethd` size at 60-point font, we'd also want to create 30-point
    and 15-point sizes for smaller devices. In addition to reducing the font size,
    we can also modify the stroke and shadow settings to give relatively the same
    look for all sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So overall, if you call your font `bmFont`, you should have the following files
    (each `.fnt` file will also have a `.png` file with it), with the largest font
    size being 60:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources-tablethd/bmFont.fnt - 60-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-tablet/bmFont.fnt - 30-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-phonehd/bmFont.fnt - 30-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources-phone/bmFont.fnt - 15-pt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Saving your BMFont using directories](img/image00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When using the directory method, if you've exported the font files to the folders
    mentioned previously, the Xcode project will be set up in such a way that it will
    automatically include these files, so you don't need to worry about copying anything.
    That being said, let's begin to display labels with this new font we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the BMFont and importing to Xcode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bring up Xcode and open `MainScene.h`. You''re going to add these variables
    below the line that says `CGSize winSize`. Again, if you''ve followed the preceding
    TTF tutorial, you can delete or comment out the variables we created in that tutorial,
    as we will be using the same variable names here. We''re stating the variable
    with `lbl` again so that we can easily identify it as a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open `MainScene.m` and add these lines of code below the code for the
    background layer to display the labels. If you had chosen to export your font
    with a different name, you must change the `fntFile` parameter to match whatever
    you chose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With these lines added, you should be able to run the game and see some fancy-looking
    labels on the left side of the screen, as shown here (this was run on an iPhone
    5):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exporting the BMFont and importing to Xcode](img/image00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's not much of a game if it's just displaying text, so let's add some buttons.
    But first, we must go over how to create sprite sheets using TexturePacker.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide not to use TexturePacker, read the *Not using TexturePacker –
    A brief how-to* section and feel free to skip over the section about using sprite
    sheets with TexturePacker. If that's the case, you should also be using the directory
    method of file reading, as there's almost no benefit of file extensions except
    when using a program that automatically maintains them, such as TexturePacker.
  prefs: []
  type: TYPE_NORMAL
- en: Not using TexturePacker – A brief how-to
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, if you opt against using TexturePacker, any time it's
    mentioned to add the image to the sprite sheet, that's your queue to add it to
    SpriteBuilder and republish it, as it's assumed that you'll be using the directory
    mode of file reading.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, drag the iPad-retina-sized image into SpriteBuilder, and click on
    **Publish**. SpriteBuilder will auto-scale.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, however, that in the later chapters of this book, the sprite sheets will
    be provided (as well as the individual images if you want to do it yourself).
  prefs: []
  type: TYPE_NORMAL
- en: Begin using sprite sheets with TexturePacker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprite sheets are used to improve the performance of your game, not only reducing
    the time it takes for the game to load but also improving the performance while
    the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, TexturePacker works with Cocos2d at the time of writing this
    book, but its use is not supported by SpriteBuilder directly. However, TexturePacker
    is a great solution when it comes to building sprite sheets effectively. If you
    wish to use TexturePacker but are currently using the directory method (the default
    for SpriteBuilder at the time of writing this book), go back and change your style
    to file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d
    Knowledge"), *Refreshing Our Cocos2d Knowledge*, we will be using TexturePacker
    as the go-to for our sprite sheet creator. TexturePacker is nice for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows exporting to Cocos2d with one click
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has auto-scaling (up or down) that supports all resolution types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes updating your images later easier to import the images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, open TexturePacker. Then go to the `Images Pre-Chapter 6` folder, where
    you''ll see the `btnMenu.png` image (our menu button image). Drag it into the
    right column of TexturePacker. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Begin using sprite sheets with TexturePacker](img/image00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before changing any of the file locations, make sure you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Texture format** drop-down box, ensure that **PNG** is selected. This
    format should be fine for most games you'll make. However, if you find yourself
    wanting to make your game's final project size smaller without sacrificing quality,
    a recommendation is to switch to **zlib pvr.ccz compression**. This is the most
    optimal format for Cocos2d, for not only compression per pixel but also performance
    when drawing the images on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box that says **Premultiply Alpha**. It's not entirely important to
    know the details of how this works. For now, just know that in Cocos2d, the texture
    can be rendered faster with this checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving to the project location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the image in TexturePacker, let's modify some of the settings
    to make sure we can effectively manage any future versions of this sprite sheet.
    Click on the little folder icon next to the **Data file** textbox and go to the
    project's `Resources/Published-iOS` directory. Feel free to name the file whatever
    you want, but try to keep it relevant. For this example, we'll call it `buttonSheet`
    because it will be the sprite sheet that contains all the buttons in the game.
    Click on **Save** when you're ready.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that even though the file is being called `buttonSheet.plist`, there is
    `{v}` at the end of the filename. This is important, and is what allows TexturePacker
    to do the auto-scaling for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving to the project location](img/image00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As for image format, it's generally okay to keep it at **RGBA8888**. However,
    if your game has a large number of art assets on the screen and is suffering performance-wise,
    changing this to a lower setting might help.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the images and publishing the sprite sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to make sure TexturePacker will correctly scale what we need. Click
    on the gear icon next to **AutoSD**, and then open the drop-down box at the top
    labeled **Presets**. Choose the option that best suits your needs and click on
    **Apply**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're only making an iPhone game (and not an iPad version), select **cocos2d
    hd/sd**.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise (if you are making an iPad version, which this book's project is),
    select **cocos2d ipad/hd/sd**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the top-left corner of the screen, we click on the **Save defaults**
    button, as it allows us to save these settings for any time when we need to create
    a TexturePacker sprite sheet again. Then click on **Save** (or press *command*
    +*S*). This will ask you where you want to the save the TexturePacker file (not
    the sprite sheet). Generally, you'll save this file in the same folder as all
    your other art assets. For example, we'll have a separate directory for both the
    project and the individual art assets that will be copied later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling the images and publishing the sprite sheet](img/image00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you've saved the TPS file in your location of choice, go ahead and click
    on **Publish**. Publishing will generate the required sprite sheets for the project
    based on the various settings we entered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the sprite sheet and loading it into the memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, once you have published the sprite sheet in the project directory (or
    anywhere really, but it's best if it's located in the project directory for easy
    updating later on), the way the Xcode project is set up should cause them to be
    automatically added to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve published the sprite sheet, open Xcode and go to `AppDelegate.m`.
    Add one line of code right above the return statement in the `startScene` method
    to make it look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now you're ready to start using the sprite sheet. It took a little bit of work
    to set it up, but for now, all you need to do is add images to the TexturePacker
    file, click on **Save**, and then click on Publish. Your changes will be automatically
    reflected the next time you run your project. That being said, let's make use
    of the sprite sheet by turning that menu button image into an actual button.
  prefs: []
  type: TYPE_NORMAL
- en: Creating buttons via CCButton and CCLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cocos2d 3.0 changed the way buttons are displayed. If you've used previous versions
    of Cocos2d, you're probably familiar with `CCMenu`. That is no longer the way
    to create and display tappable buttons in Cocos2d. Instead, we're going to use
    `CCButton` and place them in a node of the `CCLayout` type. If you skipped the
    sprite sheet section, I strongly recommend that you go back and read it. It will
    save you from many frustrating moments as the project progresses.
  prefs: []
  type: TYPE_NORMAL
- en: For the book's project, we'll be adding the menu button in the bottom-left corner.
    Like I said, it's extremely easy to add the buttons once you have the images included
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainScene.m` file, and add these lines of code below the code for
    the labels in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, you should see the menu button appear in the bottom-left corner.
    If you used the `pvr.ccz` format and the button flips horizontally, don''t worry.
    Just go back to TexturePacker, check the box that says **Flip PVR**, save the
    file, and then publish. Go back to Xcode and rerun the project. It should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating buttons via CCButton and CCLayout](img/image00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the Restart button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the **Restart** button (in this case, `btnRestart.png`) to either TexturePacker
    or SpriteBuilder depending on which method you used, click on Save, and then publish
    to update the files so that the **Restart** button can be used. With the **Restart**
    button''s image added, you can modify the `MainScene.m` file''s code to look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will allow the restart button and the menu button to be lined up perfectly.
    Plus, if you ever decide to move both buttons, but you want them at the same distance
    relative to each other, just reposition the layout box. And voilà!
  prefs: []
  type: TYPE_NORMAL
- en: What you can do as a quick learning experience is to try messing around with
    the spacing values; or change the direction, or even the anchor point. You'll
    get a better understanding of why each line of code is absolutely necessary to
    create this effect when you try testing different values.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and modify some of the values. You can always revert to the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, using the initial code that you just saw, if you run the project, this
    is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Restart button](img/image00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating nodes and units (sprites)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, everything in Cocos2d is, at its base, a `CCNode` object. Nodes can
    have other nodes as children. For example, if you wish to create a character with
    a jetpack attached, the character can be a `CCSprite` object (a node object with
    an image) and the jetpack can be a `CCSprite` object as a child of the character.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, this is a chapter about prototypes, and we've yet to create any real
    gameplay. Let's get that going with a few images, some touch controls, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the background image to the sprite sheet (or SpriteBuilder), save, publish,
    and then in the `MainScene.m` file''s `init` method, add the image to the screen
    as a `CCSprite` object below the `CCLayoutBox` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the game, and uh oh! We seem to have run into the first issue with
    our prototype. Although it''s not entirely necessary to get all the bugs and kinks
    out during this phase, this one is important for the gameplay. Plus, it''s a great
    opportunity to learn about device-specific scaling. If you''ll take a look at
    the following screenshots, one of which was taken on an iPhone 5 and the other
    on an iPad Retina, you''ll notice an issue with the game board being a bit too
    big on the phone. Here is a screenshot of the game from an iPhone 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the background](img/image00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'An iPad Retina screenshot of the game appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the background](img/image00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Luckily, it''s not too far off, as the auto-scaling from either TexturePacker
    or SpriteBuilder has given us a relatively accurate scale for the game board.
    The only thing we need to do is modify the scale of the board very slightly on
    only the phone, and not the tablet. This can be done by adding these lines of
    code after you''ve declared the board variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, if you wish to detect an iPad, just use `UIUserInterfaceIdiomPad`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run it on a phone (whether it's your own or the simulator), you'll
    see that the grid is nicely within the screen's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and adding a unit to the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since each unit is basically the same, except with a different color and number,
    we should define ourselves a class. To do that, we follow the same instructions
    regarding a new scene, except that this time, we're going to call the `Unit` class
    and set the subclass as a `CCSprite` type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and adding a unit to the screen](img/image00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `Unit.h`, and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will basically allow us to give our units a move direction. We also get
    a value associated with them, a Boolean to determine whether it's a friendly unit
    or not (needed for both movement as well as collisions), and various other stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open `Unit.m` and add the following code between `@implementation` and
    `@end`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` methods set up some important stuff: position on the grid, color,
    whether it''s a friendly unit or not, the value of the unit when it first spawns,
    the label in which to show the value, and the direction it intends to move on
    the next turn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `MainScene.m` and spawn a friendly unit and an enemy unit on the
    screen. Because we defined the class so well, it''s very simple to spawn two units
    with only a few lines of code. Make sure you include the `Unit.h` at the top too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Defining and adding a unit to the screen](img/image00235.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the positions still need to be calculated, and the fact that we assigned
    a grid coordinate doesn''t mean anything to the game. We need to determine the
    actual positions on the screen. That is, if we say the position is (5, 5), it
    better know that means smack dab in the middle of the grid. However, the only
    place that knows the screen coordinates is the main scene, so open `MainScene.m`
    and add the following method to get the screen position based on a grid coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the following screenshot; this is how your game will now look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining and adding a unit to the screen](img/image00236.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running the game should get you something like what is shown in the preceding
    screenshot. And yes, even though this screenshot is from an iPad, the code works
    equally well on an iPhone of any resolution, as the formula for determining the
    position works on the assumption that (5, 5) is the center of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get these units moving around the screen with some touch mechanics.
    First, place the red unit to the right of the green in the rightmost section of
    the grid—(9, 5), for those who are lazy and don't want to calculate it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the units around with touch controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Touch detection is extremely easy in Cocos2d. From version 3.3 onwards, all
    you need to do is add one line of code and a few methods, and you're good.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, add this line of code to the `initWithFriendlyUnit` method
    of the `Unit` class (we want to enable touch only on the friendly units, not the
    enemies):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These methods are fairly self-descriptive in terms of what they do. The `touchBegan`
    method registers a touch every time a finger touches the screen, the `touchMoved`
    method registers a touch every time the finger is dragged along the screen, and
    the `touchEnded` method registers when the finger is lifted off the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to determine which unit is being dragged and in which direction, add
    these three variables to the `Unit.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add this method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once that's done, open `Unit.m` and add code to the following methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you must create this method, which will set the displayed string of the
    Unit''s label to the Unit''s actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to handle our touches in order to update the label, so the following
    code needs to be added to the `touchBegan` method, which will grab the `CCTouch`
    method''s location relative to where it is inside a given node. For now, we want
    to know where the touch is occurring relative to the `Unit` itself, and we''ll
    set that in our `touchDownPos` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you have to add the following code to the `touchMoved` method. This will
    determine what direction the finger is being dragged, based on the `x` and `y`
    difference from `touchDownPos` and the current `touchPos` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this section of code to the `touchEnded` method. This will actually
    update the grid position of the unit based on what direction it was being dragged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the game, you'll see that when you tap (or click, if running
    on the simulator) and drag that unit… oh my! Why isn't the unit moving? We set
    the grid coordinate and everything! Even the unit's value is being increased properly.
  prefs: []
  type: TYPE_NORMAL
- en: But aye! We didn't tell the main scene that the unit needed to be moved, since
    that's where the unit positioning happens. That being said, we want a way to let
    our main scene know that a unit was moved so that we can update its position.
  prefs: []
  type: TYPE_NORMAL
- en: Talking between scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very common way to do this is by making use of `NSNotificationCenter`. It''s
    broken down into two parts: a sender and a receiver. The sender is called a notification
    and the receiver is called an observer. What we need to do is send a notification
    through `NSNotificationCenter` so that any observer set up can receive the notification.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to declare a constant to reduce human errors when coding. We
    want to do this because the notifications need to be exact, or else they won't
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open `Unit.h` and add this line below `#import` but above `NS_ENUM`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the top of `Unit.m`, below the `#import` statement but above `@implementation`,
    insert this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't entirely matter what the string is; it's just that it has to be something
    unique from any other notification you end up creating later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then go ahead and add this little line of code right below the `[self updateLabel]`
    line in the `touchEnded` method of `Unit.m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will send a notification to the observer that something has happened. In
    this case, we want to notify the main scene that the current unit has been moved
    via dragging and needs its position updated. That's why we pass `self` (the current
    Unit)—so that we can update the position of the specific unit that was moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s hop over to `MainScene.m` and add the following code at the
    bottom of (or top of; it''s your preference) the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following methods: `moveUnit` and `dealloc`. The `moveUnit` method
    is what we want called when the notification gets pushed. We have an `NSNotification`
    parameter that grabs the `NSDictionary` parameter passed from the `Unit` class.
    We also need the `dealloc` to remove the observer, or else it could catch future
    notifications by accident, and that can cause the game to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Hurray! Now when you run the code, you should get the unit shifting from grid
    spot to grid spot with each swipe, in any direction. Now it's starting to feel
    like a game. However, it still lacks interaction with the enemies, and none of
    the scores are being increased. Let's add that next.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with enemies and scoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need some variables to keep track of the numbers. So in `MainScene.h`,
    add this under the BMFont label variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainScene.m`, add the following method to update the label for each counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these lines to the `moveUnit` method to increment the respective numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then initialize the variables somewhere in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now you'll notice that each time your unit moves around, the score and the `turns
    survived` labels increases by 1\. But the unit can still go straight through the
    enemy unit. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to compare the grid locations after a move with all possible
    enemies on the screen to see whether there was a collision. However, if we''re
    going to cycle through all the enemies, it means we''ll need an array to hold
    them all, so we declare an `NSMutableArray` parameter in the `MainScene.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `init` method in the `MainScene.m` file, after you spawn
    the enemy, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `moveUnit` method, we need to cycle through all the enemies
    and check whether the grid location is the same (that is, whether we''re about
    to run into an enemy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the collision comment, we now want to compare the unit values. Whichever
    unit has the higher value will win, and the unit with the lower value will be
    removed from the board (and the array). In the case of a tie, both will be removed.
    It''s also important to update the `unitsKilled` counter here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, move the `[self updateLabels]` method call in the `moveUnit` method
    to the end of the method (that is, after the loop ends), or else the `unitsKilled`
    label won't be updated until the next turn, which might confuse your players.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You can move around, run into enemies, combine your score, have the
    labels updated, and even restart the game if you lose (by going to **Menu** and
    tapping the **Play** button). Here's what the game more or less looks like so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an iPad, the game scene appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interaction with enemies and scoring](img/image00237.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On an iPhone 5, the game scene appears like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interaction with enemies and scoring](img/image00238.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating menus, scenes, and scene transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scenes make up the core of Cocos2d. When you go from the main menu to the **Level
    Select** screen, those are (when done in a best practice coding way) two different
    scenes. You can transition from one scene to another in any way your heart desires.
    However, it's generally done by tapping a button. For example, **Play**, **Settings**,
    and **Shop** are all examples of a menu button that a user might press to trigger
    a scene transition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new file for the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most likely, your game isn't going to have just one screen. If so, then you
    can skim over this as it likely won't pertain to you. However, the vast majority
    of games made have at the very least a main menu, a settings menu, a pause screen,
    and some sort of screen besides the main game screen.
  prefs: []
  type: TYPE_NORMAL
- en: The next few screenshots show how to create a file with a `CCNode` object as
    the parent class. If you already know how to do this, feel free to skip to the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xcode, right-click (or press *Ctrl* and click) on the source folder at the
    top of the project navigator, and then click on **New File** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new file for the scene](img/image00239.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the dialog window that opens, under the iOS **Source** section, select **Cocoa
    Touch Class** and click on **Next** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new file for the scene](img/image00240.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Name the class something relevant, as you may have to go back to it later. We're
    going to use `MenuScene` as the name of our class. Once you've named the class,
    click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you change **Subclass of** to `CCNode`, or else you'll be unable to
    make a new scene out of it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new file for the scene](img/image00241.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Talking about where to save the file, it's recommended to keep all of your project's
    class files in the same directory. As shown in the following screenshot, we're
    saving the **MenuScene** file we wish to create in the `Source` folder, where
    the **MainScene** files are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve chosen a location, click on **Create** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new file for the scene](img/image00242.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Turning a class into an official CCScene subclass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s not officially a scene yet, but that''s what we''re going to add now.
    In the header file of the class you just created, add a similar block of code
    between the `@interface` and `@end` lines—like what we have in the `MainScene.m`
    file. For example, your header might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the main file for the class, add the following between the `@implementation`
    and `@end` lines (yes, it''s a copy-paste job for each scene you create):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, you can now begin to add code to the main menu scene. Let''s
    quickly add a background color to the `init` method so that we know the scene
    works when we eventually link a button and transition to it. We''re going to give
    it a random green color, because the default is black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Linking the button in the game to go to the menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `MainScene.m`, and include the scene you created at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then go to the section of code where you declared the **Menu** button. Right
    after you declare it, add the following line of code. This will connect the menu
    button to a method called `goToMenu`. The `setTarget` method is the way `CCButton`
    knows what to do when it gets tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the `init` method, add the `goToMenu` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With these three things added, you should be able to run the game and click
    on the menu button. Voilà! We have a transition to the `Menu` scene, albeit rather
    ugly at the moment. But there's no way to get back to the game screen, so let's
    add a **Play** button to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and linking a button in the menu to go to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're able to get to the **Menu** scene, let's quickly add a **Play**
    button so that we can start to create the core of the gameplay and round out this
    prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the **Play** button to TexturePacker, save, and publish. Then open
    `MenuScene.m` and add the following to the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the `goToGame` method below `init` so that the button actually has
    a method to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Run the project and click on the **Menu** button. You should see a clickable
    **Play** button that will take you back to the game. Yay, scene transitions! Now
    that the play button is in place and we have the basic layout between scenes,
    we can get working on the core of the game.
  prefs: []
  type: TYPE_NORMAL
- en: One final thing you could do would be to create a `restartGame` method, set
    the target of the **Restart** button to `self`, and set the selector of the restart
    button to the `restartGame` method. Inside the `restartGame` method you have created,
    simply call the `replaceScene` method (like what you just did), but this time,
    use `MainScene` instead of `MenuScene` so that the scene transitions to a fresh/clean/new/whatever
    version of itself. This is a good idea because this is the minimal code for the
    very effect we're trying to achieve here.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go from here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s quite clear that the project is far from complete at this stage. However,
    there are a lot of things that are a core of the game''s implementation: the dragging,
    the scoring, and the grid formation. From here on, it''s probably best to continue
    to iterate on the project and slowly add stuff until it''s a fully working prototype
    with very minimal baseline mechanics working. For example, we could add some enemy
    spawning, **Artificial Intelligence** (**AI**), the user''s units automatically
    moving, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But as far as this book is concerned, we''re going to move on as the point
    of this chapter was to go straight into a prototype. That''s basically what we
    have here—something we can show our friends and family and say, "Hey, this is
    what the concept is, and this is what I''ve got so far." With the prototype, you
    can gauge things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the game board too small for the player's fingers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the concept too confusing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it hard to interact with the character?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With time, all of these will be sorted, but it's better to learn about the biggest
    problems early on rather than find them after your game has been published on
    the App Store and you notice that nobody is downloading it.
  prefs: []
  type: TYPE_NORMAL
- en: Some suggestions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re following the book''s tutorial/example project (which I hope you
    are), try adding the following on your own, all of which will be added outside
    this book for consolidation purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically moving the red unit each turn and increasing its score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning a red unit every three or four turns around the border and adding it
    to the array (and possibly implementing the movement as you did with the previous
    red unit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning another friendly unit with a value of `1` when you move away from (5,
    5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and maintaining a friendly unit array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making all friendly units move in the direction they were last instructed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry if you don't want to take the time to implement these by yourself.
    A later chapter will have them pre-implemented, and you can download the source
    code to get an up-to-date version before you begin that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is highly recommended that you do try coding on your own, as that's
    the entire point of this book—to push you further as a coder. The tutorials are
    here for support, but the main purpose is to show you cool things and let you
    run loose with the tools at your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A prototype for the game, as shown in this chapter, can be done relatively quickly
    (not that many pages compared to how much content was put in). If you have a large-scale
    game (which is almost certainly the case), now would be the best time to go about
    creating the other scenes, adding buttons that link the scenes together, creating
    the characters in the game, and even adding some baseline code for the core of
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the way to prototype quickly and iterate more often is to get the
    simplest parts that draw a wireframe of the project first so that the people holding
    the prototype can fill the gaps with their imagination (or if you hand them a
    near-complete project, they won't have to fill any gaps). It's like drawing a
    person on a piece of paper. First, you draw a rough version of their body position,
    then fill in a bit of the muscle and fat, and finally draw the details such as
    fingers, clothes, facial expressions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover in depth how to create some really awesome
    mechanics and do with Cocos2d what most developers don't do.
  prefs: []
  type: TYPE_NORMAL
