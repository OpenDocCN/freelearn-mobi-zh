- en: Chapter 2. Failing Faster with Prototypes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 使用原型快速失败
- en: 'This chapter is all about getting a wireframe of the project going so that
    you can fill in the "meat" of the game later. You''ll be getting baseline graphics,
    menus, and the game''s flow structure outlined for testing faster than you can
    blink. Test sooner, fail faster—this is your new motto as a game developer. Even
    though it may seem very simple to code, that''s our intent: to create the minimum
    viable product—something tangible and working—as soon as possible in order to
    get a feel of the overall project. We''re going to cover the following in this
    chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于让项目的线框开始运行，这样你就可以在稍后填充游戏的“内容”。你将获得基线图形、菜单和游戏的流程结构，以便快速测试。测试越早，失败越快——这是你作为游戏开发者的新座右铭。尽管编写代码可能看起来非常简单，但我们的意图是尽快创建最小可行产品——一个有形且可工作的产品，以便对整个项目有一个感觉。在本章中，我们将涵盖以下内容：
- en: Why prototype?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用原型？
- en: Getting a scene up and running
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让场景运行起来
- en: Creating text (labels)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文本（标签）
- en: Beginning using sprite sheets with TexturePacker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用TexturePacker中的精灵表
- en: Creating buttons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮
- en: Creating menus, scenes, and scene transitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单、场景和场景转换
- en: Creating nodes and units (sprites)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建节点和单位（精灵）
- en: 'Throughout this book, a complete game will be created from beginning to end,
    starting with this chapter. Creating an ongoing project will serve two purposes,
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，从头到尾创建一个完整游戏，从本章开始。创建一个持续的项目有两个目的，如下：
- en: Show how each section can fit within a full project and not just as a piece
    of code all on its own
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示每个部分如何适合整个项目，而不仅仅是作为单独的代码片段
- en: Visualize the process of an entire project from the beginning to the end without
    skipping any step
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头到尾可视化整个项目的流程，不跳过任何步骤
- en: In the files included with this book, you can find the finished project to see
    what it's going to look and feel like. Also, at the beginning of each chapter,
    there will be a reference to the version of the project up to that point in the
    book so that you can follow along with the complete explanation/examples in the
    book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书附带文件中，你可以找到完成的项目，看看它将看起来和感觉如何。此外，在每一章的开头，都会有一个关于到那时为止书中项目版本的参考，这样你就可以跟随书中的完整解释/示例。 '
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, the project is created as a fresh project by following the tutorial
    in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d Knowledge"),
    *Refreshing Our Cocos2d Knowledge*. If you would rather use a default starting
    point, you can use the project in the blank `Project` folder in the files included
    with this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，项目是通过遵循[第1章](part0014.xhtml "第1章. 刷新您的Cocos2d知识")中的教程创建为一个全新项目的，即*刷新我们的Cocos2d知识*。如果你更愿意使用默认的起点，你可以使用本书附带文件中的空白`Project`文件夹中的项目。
- en: You can also download the code from [https://github.com/keitzer/MasteringCocos2d](https://github.com/keitzer/MasteringCocos2d).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从[https://github.com/keitzer/MasteringCocos2d](https://github.com/keitzer/MasteringCocos2d)下载代码。
- en: File suffixes versus directories
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件后缀与目录
- en: 'When Cocos2d and SpriteBuilder became integrated in Cocos2d 3.0, they changed
    the way textures are read in by Cocos2d. In previous versions, if you wanted to
    make a game for the iPhone and the iPad, you had to add various suffixes to your
    file. For example, if your image was named `btnPlay.png`, you had to create variously
    sized files in your project, which were named as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当Cocos2d和SpriteBuilder在Cocos2d 3.0中集成时，它们改变了Cocos2d读取纹理的方式。在之前的版本中，如果你想为iPhone和iPad制作游戏，你必须给你的文件添加各种后缀。例如，如果你的图像命名为`btnPlay.png`，你必须在你项目中创建不同尺寸的文件，其命名如下：
- en: '`btnPlay.png`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btnPlay.png`'
- en: '`btnPlay-hd.png`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btnPlay-hd.png`'
- en: '`btnPlay-ipad.png`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btnPlay-ipad.png`'
- en: '`btnPlay-ipadhd.png`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btnPlay-ipadhd.png`'
- en: This methodology of getting your files saved is typically referred to as using
    **file suffixes**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存的方法通常被称为使用**文件后缀**。
- en: In the newer iteration of Cocos2d with SpriteBuilder, one of the ways you can
    manage your textures is by dragging a file of the largest possible size (for example,
    Retina iPad) into SpriteBuilder. When you click on **Publish**, SpriteBuilder
    will take care of the file size variations for you. This way of handling files
    is referred to as using **directories**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有SpriteBuilder的Cocos2d新版本中，你可以通过将最大尺寸的文件（例如，Retina iPad）拖入SpriteBuilder来管理你的纹理。当你点击**发布**时，SpriteBuilder会为你处理文件大小的变化。这种处理文件的方式被称为使用**目录**。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here is a warning: if you decide to manually add files to the `Published-iOS`
    folder, do not click on **Clean Cache** in SpriteBuilder, or else you will lose
    all of those files.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个警告：如果你决定手动将文件添加到`Published-iOS`文件夹中，请不要在SpriteBuilder中点击**Clean Cache**，否则你将丢失所有这些文件。
- en: However, using directories has its drawbacks. For example, you may want to use
    TexturePacker (which we will use later in this chapter, as well as throughout
    the book), but there is no easy way to use it and the new directory style of saving
    files. You technically can, but it's such a pain that any advantage TexturePacker
    has is negated by the extra work you have to do. So TexturePacker can work with
    the directory style of file reading. Thus, it's just easier to drag the files
    into SpriteBuilder if you're going to use the directory style.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用目录有其缺点。例如，你可能想使用TexturePacker（我们将在本章后面以及整本书中用到它），但是没有简单的方法来使用它和新的文件保存目录风格。技术上你可以做到，但这样做太麻烦了，以至于TexturePacker的任何优势都被你额外要做的工作所抵消。因此，TexturePacker可以与文件读取的目录风格一起工作。所以，如果你打算使用目录风格，直接将文件拖入SpriteBuilder会更容易。
- en: So how will we work around this problem if we want to take advantage of TexturePacker?
    Well, until there exists a version of Cocos2d and SpriteBuilder that integrates
    the use of TexturePacker, we have to go back to the file suffix method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想利用TexturePacker，我们将如何解决这个问题？嗯，直到存在一个集成TexturePacker使用的Cocos2d和SpriteBuilder版本，我们不得不回到文件后缀方法。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that if you do not wish to purchase TexturePacker, don't worry; it's not
    required. The later code will stay the same, as Cocos2d searches for the image,
    whether it was loaded via sprite sheets or as an individual file. If you do not
    wish to use TexturePacker, feel free to avoid changing your search mode (as mentioned
    next) and just go ahead with the directory method. Whenever this book mentions
    adding a file to the sprite sheet, that's your queue to add it to SpriteBuilder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你不想购买TexturePacker，不用担心；它不是必需的。后面的代码将保持不变，因为Cocos2d搜索图像，无论它是通过精灵图集还是作为单个文件加载的。如果你不想使用TexturePacker，请随意避免更改你的搜索模式（如后文所述），并继续使用目录方法。每当这本书提到将文件添加到精灵图集时，那就是你将其添加到SpriteBuilder的信号。
- en: 'Since Cocos2d 3.0 and higher versions use the directory method by default,
    and since we''re going to switch to using file extensions, we must look up the
    Xcode project for **CCFileUtilsSearchModeDirectory**. One of the results should
    be a file called `CCBReader.m`. Click on the result and it should take you to
    approximately line 109, where you''ll see the following line of code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cocos2d 3.0及以上版本默认使用目录方法，并且我们将切换到使用文件扩展名，我们必须查找**CCFileUtilsSearchModeDirectory**的Xcode项目。其中一个结果应该是一个名为`CCBReader.m`的文件。点击结果，它应该带你到大约第109行，在那里你会看到以下代码行：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You''re going to change that line to use the suffix search mode:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要更改这一行以使用后缀搜索模式：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With that in place, we're ready to begin the prototype phase of our project.
    But first, why is it important to make a prototype? And why is it important to
    create it quickly? Why not just code the game slowly and eventually get the core
    mechanics of the game in whenever it's time?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们准备开始项目的原型阶段。但首先，为什么制作原型很重要？为什么快速制作原型很重要？为什么不慢慢编写代码，最终在适当的时候实现游戏的核心机制呢？
- en: Why prototype?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要原型？
- en: 'Besides the obvious reason of asking your friends "is it fun?!" before it''s
    fully complete, prototyping your game, especially quickly and early on in development,
    can be very useful for a few different reasons:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在游戏完全完成之前询问朋友“好玩吗？！”的明显原因之外，在开发初期快速进行游戏原型，尤其是对于几个不同的原因非常有用：
- en: You can ask about the originality/innovation of your game from the perspective
    of an end user instead of just your own views
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从最终用户的视角来询问你游戏的原创性/创新性，而不仅仅是你的个人观点
- en: You can generate ideas on how to improve the game way before it's too late to
    make changes
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在游戏还来得及做出改变之前，就生成如何改进游戏的点子
- en: You can get a feel of how the game actually flows from one stage to the next,
    and conceive a tangible product instead of just an idea
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以感受到游戏从一阶段到下一阶段是如何实际流转的，并构想出一个具体的产品，而不仅仅是想法
- en: If shown to the public, it could be a great way to begin the marketing of your
    game and beginning the snowball of exposure needed to succeed on iOS
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向公众展示，这可能是开始游戏营销和开始成功在iOS上取得成功所需曝光的雪球效应的绝佳方式。
- en: Plus, this is the best way to start a project, especially a project that includes
    new concepts or ideas that might be hard to get fully coded and work as intended.
    You might have heard of the term **proof of concept**; this chapter is exactly
    what that is. It's a very quick overview of your entire game that you can show
    to others and ask, "This is proof that I can make this concept into a full-blown
    game. What do you think?"
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是开始一个项目，尤其是包含可能难以完全编码并按预期工作的新概念或想法的项目，最好的方式。你可能听说过“概念验证”这个术语；这一章正是这个意思。这是对你整个游戏的一个非常快速的概述，你可以向其他人展示并询问：“这是我能够将这个概念制作成完整游戏的一个证明。你有什么看法？”
- en: Now that you've understood why making a prototype for your game is a good idea,
    let's quickly go over the project this book will be covering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解为什么为你的游戏制作原型是一个好主意，让我们快速了解一下这本书将要介绍的项目。
- en: Playtesting and feedback analysis
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏测试和反馈分析
- en: When you have your prototype ready for others to experience, it's best to go
    out and actually get some people to play your game. Ideally, you should find playtesters
    who are knowledgeable in that game's genre as well as within the age range of
    your game's target audience so that they can give quality feedback.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的原型准备好供其他人体验时，最好是走出去，实际上找一些人来玩你的游戏。理想情况下，你应该找到对该游戏类型以及你的游戏目标受众年龄范围都有所了解的游戏测试者，这样他们才能提供高质量的反馈。
- en: The feedback you receive will vary from "Wow! This is amazing!" to "I don't
    understand how to play this game." You have to be prepared to hear all kinds of
    responses. Also, just because someone says your game is bad might not necessarily
    mean it is bad. However, if what they're saying is objectively true, and implementing
    what they have to say will improve your players' experience, then you should listen
    to their opinion as it will make not only your current game but also future games
    better.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你收到的反馈将各不相同，从“哇！这太棒了！”到“我不懂怎么玩这个游戏。”你必须准备好听到各种各样的回应。此外，即使有人说你的游戏不好，也不一定意味着它真的不好。然而，如果他们说的是客观真实的，并且实施他们的建议将改善玩家的体验，那么你应该听取他们的意见，因为这不仅会使你的当前游戏变得更好，也会使未来的游戏变得更好。
- en: Anyway, let's get into actually making a project that others can play.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们开始制作一个其他人可以玩的项目。
- en: Project for the book
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍的项目
- en: To get an idea of the project this book will be going through, imagine a 9 x
    9 grid with your "base" at the center and enemies spawning around the squares
    at the edges. It's a turn-based game. On each turn, every unit moves one square.
    Each unit has a number that increases by one every turn. If your unit collides
    with the enemy's unit, the two numbers subtract and whichever unit has a positive
    result stays alive. Your goal is to protect your main base from an enemy unit,
    surviving an attack on your main base for as many turns as you can.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这本书将要介绍的项目，想象一个9 x 9的网格，你的“基地”位于中心，敌人围绕着边缘的方块生成。这是一个回合制游戏。在每一回合，每个单位移动一个方块。每个单位在每个回合的数字增加1。如果你的单位与敌人的单位相撞，两个数字相减，结果为正的单位存活。你的目标是保护你的主要基地免受敌人单位的攻击，尽可能多地在主要基地上存活回合。
- en: 'Here are a few screenshots of the finished game (by the end of [Chapter 7](part0057.xhtml
    "Chapter 7. Reaching Our Destination"), *Reaching Our Destination*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成的游戏（到[第7章](part0057.xhtml "第7章. 抵达目的地")，*抵达目的地*）的一些截图：
- en: 'When the game first starts up, it will look like what is shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏首次启动时，它将看起来像以下截图所示：
- en: '![Project for the book](img/image00212.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![书籍的项目](img/image00212.jpeg)'
- en: 'The game midway through a session will look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏进行到一半时的样子如下：
- en: '![Project for the book](img/image00213.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![书籍的项目](img/image00213.jpeg)'
- en: 'The game over screen, when the central square is taken, will look like what
    is shown in this screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当中央广场被占领时，游戏结束屏幕将看起来像以下截图所示：
- en: '![Project for the book](img/image00214.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![书籍的项目](img/image00214.jpeg)'
- en: A quick mock-up
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速原型
- en: Whether it's Photoshop, Illustrator, MS Paint, a paper and a pencil, a whiteboard,
    crayons, or any other creative way to draw your ideas, it's best to get a visual
    of the project so that when you begin to code, you at least have a basis for why
    you're choosing the colors and text positions that you are choosing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是Photoshop、Illustrator、MS Paint、一张纸和一支铅笔、白板、蜡笔，还是任何其他创造性方式来绘制你的想法，最好是将项目的视觉形象化，这样当你开始编码时，至少有一个基础来解释你选择这些颜色和文本位置的原因。
- en: Moreover, even though we have screenshots of the finished product, which we
    just saw, we need to imagine where to start. For example, in the following screenshot,
    you'll see a quick mock-up made for this book's project, as described earlier.
    The dimensions are 2048 x 1536 (iPad landscape). It was done relatively quickly
    for the purpose of showing the game as a concept, not as a finished product that
    is meant for marketing purposes. Don't worry; yours doesn't have to look as good
    as this if your art skills are lacking.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管我们有了我们刚才看到的最终产品的截图，但我们仍需要想象从哪里开始。例如，在下面的截图中，你会看到一个为本书项目快速制作的草图，如之前所述。尺寸为
    2048 x 1536（iPad 横屏）。这是为了展示游戏作为一个概念，而不是作为用于营销目的的成品。不用担心；如果你的艺术技能不足，你的作品不必像这样好。
- en: '![A quick mock-up](img/image00215.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![快速草图](img/image00215.jpeg)'
- en: This is an example of a great starting point because it doesn't have any menus
    or fancy transitions; just the game. I know there's a button that says **Menu**,
    but that's intended for later use, when we actually implement the menu. Remember,
    a prototype is supposed to be quick. It doesn't matter if the graphics, colors,
    fonts, or even the menu placements or word choices change. The point is to get
    it up as fast as possible. *Test sooner, fail faster*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的起点示例，因为它没有任何菜单或花哨的过渡；只有游戏。我知道有一个写着 **菜单** 的按钮，但那是为了稍后使用，当我们真正实现菜单时。记住，原型应该是快速的。图形、颜色、字体，甚至是菜单位置或文字选择的变化都不重要。重点是尽可能快地完成。*尽早测试，快速失败*。
- en: Overview of how the Cocos2d engine works
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cocos2d 引擎工作概述
- en: Before we go too deep into the code, let's quickly go over how the Cocos2d engine
    works. If you're using Cocos2d for the first time, this should be helpful. If
    you've used Cocos2d before, feel free to read through this, as it might be a refresher
    for you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们快速了解一下 Cocos2d 引擎的工作原理。如果你是第一次使用 Cocos2d，这将很有帮助。如果你之前使用过 Cocos2d，请随意阅读，因为这可能对你来说是一个复习。
- en: Cocos2d is essentially a series of parents and children. The base parent is
    the currently running scene. You can have only one scene displayed at any given
    time. Within the scene, there will be children, all of which have to be of the
    `CCNode` type. A `CCNode` object is an object that has a position, rotation, scale,
    color, and various other properties. A `CCNode` object can have other `CCNode`
    objects added to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 实质上是一系列父节点和子节点的集合。基础父节点是当前正在运行的场景。在任何给定时间，你只能显示一个场景。在场景内部，将会有子节点，所有这些子节点都必须是
    `CCNode` 类型。一个 `CCNode` 对象是一个具有位置、旋转、缩放、颜色和其他各种属性的实体。一个 `CCNode` 对象可以添加其他 `CCNode`
    对象到它上面。
- en: Each subclass of `CCNode` inherits from it and adds functionality on top of
    the `CCNode` class. For example, if we want to draw an image on the screen, we'll
    use `CCSprite`, which is essentially a `CCNode` object, but with an image attached.
    Even a scene (type of `CCScene`) is a subclass of `CCNode` (which is how each
    scene can have children).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `CCNode` 的子类都继承自它，并在 `CCNode` 类之上添加功能。例如，如果我们想在屏幕上绘制图像，我们会使用 `CCSprite`，它本质上是一个带有图像附加的
    `CCNode` 对象。甚至场景（类型为 `CCScene`）也是 `CCNode` 的子类（这就是每个场景可以拥有子节点的原因）。
- en: Here's an image made to help describe the relationship between parents and children
    within Cocos2d. First, we have the individual images we want to display on the
    screen, in a very simple texture atlas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张图片，用来描述 Cocos2d 中父节点和子节点之间的关系。首先，我们有我们想在屏幕上显示的单独的图像，在一个非常简单的纹理图集中。
- en: '![Overview of how the Cocos2d engine works](img/image00216.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Cocos2d 引擎工作概述](img/image00216.jpeg)'
- en: 'Next, we have a diagram of an example of `CCScene`. Added to the scene are
    five `CCSprite` objects: the sky, the two trees, the road, and the player.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 `CCScene` 的示例图。场景中添加了五个 `CCSprite` 对象：天空、两棵树、道路和玩家。
- en: '![Overview of how the Cocos2d engine works](img/image00217.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Cocos2d 引擎工作概述](img/image00217.jpeg)'
- en: The sky is positioned at z-index equal to 0, the trees at z-index equal to 1
    (which means they'll be displayed in front of the sky), the road at z-index equal
    to 2 (which means it'll be displayed in front of both the sky and the trees),
    and the player at z-index equal to 3 (which means it'll be displayed in front
    of everything). The default z-index is 0.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 天空位于 z-index 等于 0 的位置，树木位于 z-index 等于 1（这意味着它们将显示在天空前面），道路位于 z-index 等于 2（这意味着它将显示在天空和树木前面），玩家位于
    z-index 等于 3（这意味着它将显示在所有内容前面）。默认的 z-index 是 0。
- en: Everything else in Cocos2d is simple—just a `CCNode` object with other `CCNode`
    objects added as children.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d中的其他一切都很简单——只是一个带有其他`CCNode`对象作为子对象的`CCNode`对象。
- en: 'Here''s one thing to remember about the parent-child relationship that Cocos2d
    uses: if you move a parent by 20 points, for example, the children will also be
    moved by the same amount.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Cocos2d使用的父子关系，有一件事需要记住：例如，如果你移动一个父节点20个单位，那么子节点也会以相同的量移动。
- en: Now that we've briefly gone over how Cocos2d works, let's get our prototype
    going.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要地介绍了Cocos2d的工作原理，让我们开始制作我们的原型。
- en: Getting a scene up and running
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动场景并运行
- en: Before we even start adding anything to the screen, we need to make sure we
    have a game that can be viewed on our device or a simulator. Once you've created
    the project in SpriteBuilder (or gotten the blank project that was listed earlier)
    and opened the project in Xcode, go to the next step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向屏幕添加任何内容之前，我们需要确保我们有一个可以在我们的设备或模拟器上查看的游戏。一旦你在SpriteBuilder中创建了项目（或获取了前面列出的空白项目）并在Xcode中打开了项目，就进行下一步。
- en: Creating the initial code for the scene to open
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建打开场景的初始代码
- en: You should see a file called `MainScene.h` and another file called `MainScene.m`.
    Open the header file (which has the `.h` extension).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`MainScene.h`的文件和另一个名为`MainScene.m`的文件。打开头文件（它具有`.h`扩展名）。
- en: 'In the header file, add a few lines of code between the `@interface` line and
    the `@end` line. The header should look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，在`@interface`行和`@end`行之间添加几行代码。头文件应该看起来像这样：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in the main file (which has the `.m` extension), some lines of code should
    be added between the `@implementation` and `@end` lines. It should look as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在主文件（它具有`.m`扩展名）中，应在`@implementation`和`@end`行之间添加一些代码。它应该看起来如下：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, open the `AppDelegate.m` file and scroll to the bottom, where you
    should see a line in the `startScene` method that looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`AppDelegate.m`文件，滚动到文件底部，你应该在`startScene`方法中看到一行看起来像这样的代码：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re going to change it to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它改为以下内容：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code might give you an error for this line. This can be fixed by importing
    the `MainScene` header to the AppDelegate''s main file. Simply add this to the
    top of the `AppDelegate.m` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会在这一行给出错误。这可以通过将`MainScene`头文件导入到AppDelegate的主文件中来解决。只需将以下内容添加到`AppDelegate.m`文件的顶部：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once all of this has been put in place, feel free to run your project on either
    your device or the simulator built into Xcode. You can read more about each option
    in the following sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些设置都到位，你就可以自由地在你的设备或Xcode内置的模拟器上运行你的项目了。你可以在接下来的章节中了解更多关于每个选项的信息。
- en: Run it on the simulator – doesn't require an iOS developer license
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模拟器上运行它 – 不需要iOS开发者许可证
- en: Running on the simulator is good for testing devices you don't own. For example,
    if you own an iPhone 5s and want to test how your game looks on an iPhone 6 or
    6 Plus, simply load that simulator and test to see how the game looks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行适用于测试你拥有的设备。例如，如果你拥有一部iPhone 5s，并想测试你的游戏在iPhone 6或6 Plus上的外观，只需加载该模拟器并测试游戏的外观。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that it's best to test for performance on the device only. Do not test
    for performance on the simulator. You will never get a perfect representation
    of the device's capabilities when running on the simulator. Also, you should test
    only how the game looks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最好只在设备上测试性能。不要在模拟器上测试性能。当在模拟器上运行时，你永远不会得到设备能力的完美表示。此外，你应该只测试游戏的外观。
- en: 'For testing on the simulator, simply choose which device you wish to simulate
    from the simulators available in Xcode as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在模拟器上的测试，只需从Xcode中可用的模拟器中选择你想要模拟的设备，如以下截图所示：
- en: '![Run it on the simulator – doesn''t require an iOS developer license](img/image00218.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![在模拟器上运行它 – 不需要iOS开发者许可证](img/image00218.jpeg)'
- en: Choose any simulator you want, preferably a simulator that your game will eventually
    be supported on, and either press the play button on the left, or hit *command*
    +*R* to run it. It might take a few minutes to open the simulator, so be patient.
    But once it does, it should automatically open on the simulator. If it doesn't,
    just try rerunning it with the simulator already open.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想要的任何模拟器，最好是最终支持游戏的模拟器，然后按左边的播放按钮，或者按*command* + *R*来运行。打开模拟器可能需要几分钟，所以请耐心等待。但是一旦打开，它应该会自动在模拟器上打开。如果它没有，只需尝试在模拟器已经打开的情况下重新运行它。
- en: Congratulations! If you have used the simulator, you now have a project that
    runs! Next, we are going to go over how to run it on device.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！如果您使用了模拟器，现在您有一个可以运行的项目了！接下来，我们将介绍如何在设备上运行它。
- en: Run it on the device – requires an iOS developer license
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设备上运行 – 需要iOS开发者许可证
- en: If you're unsure whether you want to run your game on a device or on the simulator,
    let me explain why the device is the king in terms of testing purposes. Not only
    do you get to see and feel the project just as any other user would, but you also
    get to experience the actual performance of the device rather than a simulated
    version of it. Plus, if your project is heavy on touchscreen usage (which it honestly
    should, or else it probably shouldn't be an iOS title), then you can effectively
    test the feel of the game.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是想在设备上还是模拟器上运行您的游戏，让我来解释一下为什么在测试目的上设备是王。您不仅可以像其他用户一样看到和感受项目，还可以体验设备的实际性能，而不是它的模拟版本。此外，如果您的项目在触摸屏使用上很重（这确实应该如此，否则可能不应该是一个iOS游戏），那么您可以有效地测试游戏的触感。
- en: 'For testing on the device, simply plug in your device. Its name should be listed
    in Xcode, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设备测试，只需将您的设备连接即可。其名称应列在Xcode中，如下所示：
- en: '![Run it on the device – requires an iOS developer license](img/image00219.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![在设备上运行 – 需要iOS开发者许可证](img/image00219.jpeg)'
- en: If you do not see the name of your device, make sure you select the iOS device
    target, and not any of the simulators. If your device is plugged in and it still
    shows **iOS Device**, make sure you have a developer account subscription in Xcode.
    Refer to [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d Knowledge"),
    *Refreshing Our Cocos2d Knowledge*, for more details on this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到您的设备名称，请确保您选择了iOS设备目标，而不是任何模拟器。如果您的设备已连接，但仍然显示**iOS Device**，请确保您在Xcode中有一个开发者账户订阅。有关此问题的更多详细信息，请参阅[第1章](part0014.xhtml
    "第1章. 刷新您的Cocos2d知识")，*刷新我们的Cocos2d知识*。
- en: Once you see the name of your device, either press the **Play** button on the
    left, or hit *command* +*R* to run it. It might take a minute or so to build,
    but once it's complete, the project will automatically open on your device.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到您的设备名称，您可以按下左侧的**播放**按钮，或者按*command* + *R*来运行它。构建可能需要一分钟左右，但一旦完成，项目将自动在您的设备上打开。
- en: Congratulations! You now have a project that runs. Now we can start adding some
    content, such as text and buttons, and then move on to creating another scene
    and transitioning to that and back to the original.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在有一个可以运行的项目了。现在我们可以开始添加一些内容，例如文本和按钮，然后继续创建另一个场景并过渡到该场景，再返回到原始场景。
- en: Creating buttons and text (labels)
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮和文本（标签）
- en: 'If you want to place a line of text on the screen, you need to create a label.
    There are two types of labels in Cocos2d: `CCLabelBMFont` and `CCLabelTTF`. Bitmap
    Font labels are the fancy labels created with Glyph Designer, mentioned earlier
    in this book. TrueType Font labels are regular, unformatted text labels that use
    either a font file that''s already on the phone or a file you''ve added to your
    project.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在屏幕上放置一行文本，您需要创建一个标签。Cocos2d中有两种标签类型：`CCLabelBMFont`和`CCLabelTTF`。位图字体标签是使用前面在这本书中提到的Glyph
    Designer创建的精美标签。TrueType字体标签是常规的、未格式化的文本标签，它使用手机上已有的字体文件或您添加到项目中的文件。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that if you have a label that often needs updating, for example, a score
    counter or a health value, it's more efficient to use BMFonts in those cases,
    even if the font is a plain white font and looks exactly the same in TTF format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您有一个经常需要更新的标签，例如分数计数器或健康值，在这种情况下使用BM字体会更有效率，即使字体是纯白色且在TTF格式下看起来完全相同。
- en: Let's get some text displayed – CCLabelTTF
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们显示一些文本 – CCLabelTTF
- en: As mentioned earlier, TTF labels are simple, unformatted labels. How are these
    useful? The answer is, you can quickly get the prototype of your game going, and
    so you can better understand the flow of the game. Then, once it's ready, you
    can switch over to using BMFonts to make it look nice. See [Chapter 6](part0049.xhtml
    "Chapter 6. Tidying Up and Polishing"), *Tidying Up and Polishing*, to learn more
    about ways to improve the aesthetics of your game.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TTF标签是简单、未格式化的标签。这些有什么用呢？答案是，您可以快速启动游戏的原型，这样您可以更好地理解游戏的流程。然后，一旦准备好，您就可以切换到使用BM字体来使其看起来更美观。有关改进游戏美学的更多方法，请参阅[第6章](part0049.xhtml
    "第6章. 整理和抛光")，*整理和抛光*。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Here''s a short note about BMFonts: if you want to use them in your game, which
    you should do for performance reasons alone, keep in mind the various limitations
    that BMFonts have and TTF fonts don''t. The first is poor quality when upscaling
    the label. Then, BMFonts can use only the characters that are in the font atlas,
    and any foreign language support might mean a lot of extra BMFonts, which could
    add up quickly in terms of space.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于BMFonts的简要说明：如果您想在游戏中使用它们，出于性能考虑您应该这样做，请注意BMFonts的各种限制，而TTF字体则没有。首先是标签放大时的质量较差。然后，BMFonts只能使用字体图集中的字符，任何外语支持可能意味着需要很多额外的BMFonts，这可能会在空间上迅速增加。
- en: 'The first thing we''re going to do is get those labels on the left side going.
    The following code should be added to `MainScene.h` (the `lbl` prefix in the front
    of the variable will indicate to us that it''s a label; similarly, `btn` for button,
    `num` for number, and so on):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是让左侧的标签动起来。以下代码应添加到`MainScene.h`中（变量前面的`lbl`前缀将指示我们这是一个标签；同样，`btn`用于按钮，`num`用于数字等）：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code goes into the `init` method of `MainScene.m` and will create
    the labels. We then want to set the position for each label because the default
    position is in the bottom-left corner. Finally, we add each label to the scene.
    Remember, the scene is just a node that can have as many children as you want:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将放入`MainScene.m`的`init`方法中，并将创建标签。然后我们想要为每个标签设置位置，因为默认位置在左下角。最后，我们将每个标签添加到场景中。记住，场景只是一个可以有任意多个子节点的节点：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we've used the `winSize` variable for positioning. This is useful
    because it not only keeps things in a relative position on the screen but also
    helps when coding for multiple devices that have different screen sizes (for example,
    iPhone 4, iPhone 5, iPad, and so on have different dimensions).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`winSize`变量进行定位。这很有用，因为它不仅保持了屏幕上的相对位置，而且在为不同屏幕尺寸的多个设备编写代码时也很有帮助（例如，iPhone
    4、iPhone 5、iPad等具有不同的尺寸）。
- en: Another way to handle this would be to set the `positionType` of our labels
    to `CCPositionTypeNormalized`. Then we can set our position values anywhere from
    `0` to `1`, `0` being the far left (or bottom) of the screen, and `1` being the
    far right (or top) of the screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理方式是将我们标签的`positionType`设置为`CCPositionTypeNormalized`。然后我们可以将位置值设置在`0`到`1`之间，其中`0`代表屏幕的左侧（或底部），而`1`代表屏幕的右侧（或顶部）。
- en: Let's get some text displayed – CCLabelBMFont
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示一些文本 - CCLabelBMFont
- en: 'If you aren''t already familiar, let''s recall: BMFonts are the nice, stylized
    fonts that give your game that extra level of polish without requiring too much
    effort from you. Refer to [Chapter 6](part0049.xhtml "Chapter 6. Tidying Up and
    Polishing"), *Tidying Up and Polishing*, to improve the aesthetics of your game.
    To create BMFont, you have to use a BMFont creator. We''re going to use Glyph
    Designer, as mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your
    Cocos2d Knowledge"), *Refreshing Our Cocos2d Knowledge*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉，让我们回顾一下：BMFonts是那些美观、风格化的字体，它们可以为您的游戏增添额外的打磨效果，而无需您付出太多努力。请参考[第6章](part0049.xhtml
    "第6章。整理与打磨")，*整理与打磨*，以提升您游戏的美观度。要创建BMFont，您必须使用BMFont创建器。我们将使用Glyph Designer，如[第1章](part0014.xhtml
    "第1章。刷新您的Cocos2d知识")中提到的，*刷新我们的Cocos2d知识*。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you followed the preceding TTF section, then you can just comment out or
    remove those lines of code, since we are going to redo those fonts and make them
    BMFont labels in this section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经遵循了前面的TTF部分，那么您只需注释掉或删除那些代码行即可，因为我们将在本节中重新制作这些字体，并将它们制作成BMFont标签。
- en: 'The first thing we''re going to do is create the fonts on the left side of
    our scene. With Glyph Designer open, select a font from the left panel (I chose
    **Britannic Bold**, the font in the mock-up). You can mess around with the settings
    on the right to get a font suitable for your project, but remember that this is
    only a prototype and you shouldn''t spend too much time on it. Have a look at
    the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是在场景的左侧创建字体。在Glyph Designer打开的情况下，从左侧面板中选择一个字体（我选择了**Britannic Bold**，这是原型中的字体）。您可以在右侧的设置中调整以获得适合您项目的字体，但请记住，这只是一个原型，您不应该在上面花费太多时间。看看下面的截图：
- en: '![Let''s get some text displayed – CCLabelBMFont](img/image00220.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![显示一些文本 - CCLabelBMFont](img/image00220.jpeg)'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ensure the font size isn't too big or too small. As you can see in the preceding
    screenshot, it's set to 60\. This is a decent size for the project. If it ends
    up being too big or too small, adjusting it is fairly simple.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 确保字体大小不要太大或太小。如前一个截图所示，它设置为 60。这对于项目来说是一个合适的大小。如果它变得太大或太小，调整它相对简单。
- en: When you're satisfied with the settings you have chosen, click on **Save As**
    at the top, and select where you want to save the Glyph Designer file (not the
    actual font file). Now that it has been saved for later use if we decide to edit
    the font, let's move on to exporting the font so that we can use it in Cocos2d.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对所选择的设置满意时，点击顶部的 **另存为**，并选择你想要保存 Glyph Designer 文件的位置（而不是实际的字体文件）。现在，如果决定稍后编辑字体，我们已经保存了它，接下来让我们继续导出字体，以便我们可以在
    Cocos2d 中使用它。
- en: Depending on which style of file reading you decided to go with, there are two
    different ways you'll need to export the font. Make sure you follow the same style
    as you can use only one of the styles (but not both) within the same project.
    No matter which route you go by, start with the largest font size you'll need;
    for example, the preceding screenshot shows a font size of 60 because it's going
    to be seen on a Retina iPad. If it were only on an iPhone, 60 would be too large.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你决定采用的文件读取方式，你需要以两种不同的方式导出字体。确保你遵循相同的风格，因为你可以在同一个项目中只使用一种风格（但不能同时使用两种）。无论你选择哪条路线，都要从你需要的最大字体大小开始；例如，前一个截图显示字体大小为
    60，因为它将在 Retina iPad 上显示。如果它只用于 iPhone，60 就太大了。
- en: Saving your BMFont using file suffixes
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用文件后缀保存你的 BMFont
- en: In Glyph Designer, click on **Export** at the top and navigate to the `Resources/Published-iOS`
    folder in your project directory (see the following screenshot). This is where
    you'll export the font for use with Cocos2d. Notice that because this is the largest
    font, meant for Retina-sized iPads, the suffix after the filename is `-ipadhd`.
    If you weren't designing for iPad, your largest filename suffix would be `-hd`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Glyph Designer 中，点击顶部的 **导出** 并导航到项目目录中的 `Resources/Published-iOS` 文件夹（见以下截图）。这就是你将导出字体以用于
    Cocos2d 的位置。请注意，因为这个字体是最大的，用于 Retina 尺寸的 iPad，所以文件名后的后缀是 `-ipadhd`。如果你不是为 iPad
    设计，你最大的文件名后缀将是 `-hd`。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that you should leave the `.fnt`/`.png` extension (see the following screenshot)
    as it is. Glyph Designer will automatically add that for you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该保留 `.fnt`/`.png` 扩展名（见以下截图）不变。Glyph Designer 将自动为你添加它。
- en: '![Saving your BMFont using file suffixes](img/image00221.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![使用文件后缀保存你的 BMFont](img/image00221.jpeg)'
- en: Once you've exported the largest phone, go ahead and adjust the settings for
    each tier you need. For example, since we're exporting `-ipadhd` at the 60-point
    font, we'd also want to make 30-point and 15-point sizes for smaller devices.
    In addition to reducing the font size, we can also modify the stroke and shadow
    settings to give relatively the same look for all sizes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导出了最大的手机字体，接下来调整每个层级所需的设置。例如，由于我们正在以 60 点字体导出 `-ipadhd`，我们还想为较小的设备制作 30 点和
    15 点大小的字体。除了减小字体大小外，我们还可以修改笔触和阴影设置，以使所有大小看起来相对一致。
- en: 'So overall, if you call your font `bmFont`, you should have the following files
    (each `.fnt` file will also have a `.png` file with it), with the largest font
    size being 60:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，如果你将你的字体命名为 `bmFont`，你应该有以下文件（每个 `.fnt` 文件都将附带一个 `.png` 文件），其中最大的字体大小为
    60：
- en: '`bmFont-ipadhd.fnt - 60-pt`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bmFont-ipadhd.fnt - 60-pt`'
- en: '`bmFont-ipad.fnt - 30-pt`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bmFont-ipad.fnt - 30-pt`'
- en: '`bmFont-hd.fnt - 30-pt`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bmFont-hd.fnt - 30-pt`'
- en: '`bmFont.fnt - 15-pt`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bmFont.fnt - 15-pt`'
- en: '![Saving your BMFont using file suffixes](img/image00222.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用文件后缀保存你的 BMFont](img/image00222.jpeg)'
- en: When using the file extension method, as long as you export your files to the
    `Published-iOS` folder, the Xcode project remains set up in a way that includes
    your fonts in the project. In this way, you don't need to worry about copying
    anything. That being said, let's begin displaying labels with this new font we
    just created.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用文件扩展名方法时，只要将你的文件导出到 `Published-iOS` 文件夹，Xcode 项目就会以包含你的字体在项目中的方式设置。通过这种方式，你不需要担心复制任何内容。话虽如此，让我们开始使用我们刚刚创建的新字体显示标签。
- en: Saving your BMFont using directories
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用目录保存你的 BMFont
- en: 'If you chose to go with directories, it''s not as simple as just dragging the
    font files into SpriteBuilder (at the time of writing this book). Instead, you
    must create four folders within the `Published-iOS` folder of your project directory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用目录，那么将字体文件拖入 SpriteBuilder 并不是那么简单（在撰写本书时）。相反，你必须在项目目录的 `Published-iOS`
    文件夹内创建四个文件夹：
- en: '`resources-phone`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-phone`'
- en: '`resources-phonehd`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-phonehd`'
- en: '`resources-tablet`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-tablet`'
- en: '`resources-tablethd`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-tablethd`'
- en: '![Saving your BMFont using directories](img/image00223.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用目录保存你的 BMFont](img/image00223.jpeg)'
- en: In Glyph Designer, click on **Export** at the top and navigate to the `Published-iOS/resources-tablethd`
    folder in your project directory (see the following screenshot). This is where
    you'll export the font for use with Cocos2d. The name of the file here is going
    to be the name of the font.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Glyph Designer 中，点击顶部的 **导出** 并导航到项目目录中的 `Published-iOS/resources-tablethd`
    文件夹（见以下截图）。这就是你将导出用于 Cocos2d 的字体的地方。这里的文件名将是字体的名称。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Leave the `.fnt`/`.png` extension as it is (see the following screenshot). Glyph
    Designer will automatically add it for you.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `.fnt`/`.png` 扩展名不变（见以下截图）。Glyph Designer 将自动为你添加它。
- en: '![Saving your BMFont using directories](img/image00224.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用目录保存你的 BMFont](img/image00224.jpeg)'
- en: Once the `tablethd` version has been exported, do the same export but modify
    the font size and any other settings you wish to modify. For example, since we're
    exporting the `tablethd` size at 60-point font, we'd also want to create 30-point
    and 15-point sizes for smaller devices. In addition to reducing the font size,
    we can also modify the stroke and shadow settings to give relatively the same
    look for all sizes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导出了 `tablethd` 版本，执行相同的导出操作，但修改字体大小和任何其他你希望修改的设置。例如，由于我们正在导出 `tablethd` 大小为
    60 点的字体，我们还想创建 30 点和 15 点的大小以适应较小的设备。除了减小字体大小外，我们还可以修改描边和阴影设置，以使所有大小看起来相对一致。
- en: 'So overall, if you call your font `bmFont`, you should have the following files
    (each `.fnt` file will also have a `.png` file with it), with the largest font
    size being 60:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，如果你的字体名为 `bmFont`，你应该有以下文件（每个 `.fnt` 文件都将附带一个 `.png` 文件），其中最大的字体大小为
    60：
- en: '`resources-tablethd/bmFont.fnt - 60-pt`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-tablethd/bmFont.fnt - 60-pt`'
- en: '`resources-tablet/bmFont.fnt - 30-pt`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-tablet/bmFont.fnt - 30-pt`'
- en: '`resources-phonehd/bmFont.fnt - 30-pt`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-phonehd/bmFont.fnt - 30-pt`'
- en: '`resources-phone/bmFont.fnt - 15-pt`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources-phone/bmFont.fnt - 15-pt`'
- en: '![Saving your BMFont using directories](img/image00225.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用目录保存你的 BMFont](img/image00225.jpeg)'
- en: When using the directory method, if you've exported the font files to the folders
    mentioned previously, the Xcode project will be set up in such a way that it will
    automatically include these files, so you don't need to worry about copying anything.
    That being said, let's begin to display labels with this new font we just created.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用目录方法时，如果你已经将字体文件导出到之前提到的文件夹中，Xcode 项目将自动设置以包含这些文件，因此你不需要担心复制任何内容。话虽如此，让我们开始使用我们刚刚创建的新字体来显示标签。
- en: Exporting the BMFont and importing to Xcode
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出 BMFont 并导入到 Xcode
- en: 'Bring up Xcode and open `MainScene.h`. You''re going to add these variables
    below the line that says `CGSize winSize`. Again, if you''ve followed the preceding
    TTF tutorial, you can delete or comment out the variables we created in that tutorial,
    as we will be using the same variable names here. We''re stating the variable
    with `lbl` again so that we can easily identify it as a label:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Xcode 并打开 `MainScene.h` 文件。你将在 `CGSize winSize` 这一行下面添加以下变量。再次提醒，如果你已经按照前面的
    TTF 教程操作，你可以删除或注释掉在那个教程中创建的变量，因为我们在这里将使用相同的变量名。我们再次使用 `lbl` 来声明变量，这样我们就可以很容易地将其识别为标签：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then open `MainScene.m` and add these lines of code below the code for the
    background layer to display the labels. If you had chosen to export your font
    with a different name, you must change the `fntFile` parameter to match whatever
    you chose:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开 `MainScene.m` 文件，在背景层的代码下面添加以下代码行以显示标签。如果你选择以不同的名称导出你的字体，你必须将 `fntFile`
    参数更改为你选择的名称：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With these lines added, you should be able to run the game and see some fancy-looking
    labels on the left side of the screen, as shown here (this was run on an iPhone
    5):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些行后，你应该能够运行游戏并在屏幕左侧看到一些看起来很酷的标签，如下所示（这是在 iPhone 5 上运行的）：
- en: '![Exporting the BMFont and importing to Xcode](img/image00226.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![导出 BMFont 并导入到 Xcode](img/image00226.jpeg)'
- en: It's not much of a game if it's just displaying text, so let's add some buttons.
    But first, we must go over how to create sprite sheets using TexturePacker.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是显示文本，那就不算是一个游戏，所以让我们添加一些按钮。但首先，我们必须了解如何使用TexturePacker创建精灵表。
- en: If you decide not to use TexturePacker, read the *Not using TexturePacker –
    A brief how-to* section and feel free to skip over the section about using sprite
    sheets with TexturePacker. If that's the case, you should also be using the directory
    method of file reading, as there's almost no benefit of file extensions except
    when using a program that automatically maintains them, such as TexturePacker.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定不使用TexturePacker，请阅读*不使用TexturePacker – 简要说明*部分，并可以自由跳过关于使用TexturePacker的精灵表的部分。如果是这样，你也应该使用文件读取的目录方法，因为除了使用像TexturePacker这样的自动维护它们的程序之外，文件扩展名几乎没有任何好处。
- en: Not using TexturePacker – A brief how-to
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用TexturePacker – 简要说明
- en: As mentioned earlier, if you opt against using TexturePacker, any time it's
    mentioned to add the image to the sprite sheet, that's your queue to add it to
    SpriteBuilder and republish it, as it's assumed that you'll be using the directory
    mode of file reading.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你选择不使用TexturePacker，每次提到将其图像添加到精灵表时，那就是你将其添加到SpriteBuilder并重新发布的信号，因为它假定你将使用文件读取的目录模式。
- en: To do this, drag the iPad-retina-sized image into SpriteBuilder, and click on
    **Publish**. SpriteBuilder will auto-scale.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，将iPad视网膜分辨率的图像拖入SpriteBuilder，然后点击**发布**。SpriteBuilder将自动缩放。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note, however, that in the later chapters of this book, the sprite sheets will
    be provided (as well as the individual images if you want to do it yourself).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，本书的后续章节中，将提供精灵表（以及如果你想自己完成，也可以提供单个图像）。
- en: Begin using sprite sheets with TexturePacker
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用TexturePacker的精灵表
- en: Sprite sheets are used to improve the performance of your game, not only reducing
    the time it takes for the game to load but also improving the performance while
    the game is running.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite sheets用于提高游戏性能，不仅减少了游戏加载所需的时间，而且在游戏运行时也能提高性能。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unfortunately, TexturePacker works with Cocos2d at the time of writing this
    book, but its use is not supported by SpriteBuilder directly. However, TexturePacker
    is a great solution when it comes to building sprite sheets effectively. If you
    wish to use TexturePacker but are currently using the directory method (the default
    for SpriteBuilder at the time of writing this book), go back and change your style
    to file extensions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截至本书编写时，TexturePacker与Cocos2d兼容，但SpriteBuilder并不直接支持其使用。然而，当需要有效地构建精灵表时，TexturePacker是一个很好的解决方案。如果你希望使用TexturePacker，但目前正在使用目录方法（截至本书编写时的SpriteBuilder默认设置），请返回并更改你的样式为文件扩展名。
- en: 'As mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing Your Cocos2d
    Knowledge"), *Refreshing Our Cocos2d Knowledge*, we will be using TexturePacker
    as the go-to for our sprite sheet creator. TexturePacker is nice for a few reasons:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0014.xhtml "第1章. 刷新你的Cocos2d知识")中提到的，*刷新我们的Cocos2d知识*，我们将使用TexturePacker作为我们的精灵表创建者的首选。TexturePacker有几个优点：
- en: It allows exporting to Cocos2d with one click
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许一键导出到Cocos2d
- en: It has auto-scaling (up or down) that supports all resolution types
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有自动缩放（向上或向下）以支持所有分辨率类型
- en: It makes updating your images later easier to import the images
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得以后更新图像时更容易导入图像
- en: 'First, open TexturePacker. Then go to the `Images Pre-Chapter 6` folder, where
    you''ll see the `btnMenu.png` image (our menu button image). Drag it into the
    right column of TexturePacker. It should look something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开TexturePacker。然后转到`Images Pre-Chapter 6`文件夹，在那里你会看到`btnMenu.png`图像（我们的菜单按钮图像）。将其拖入TexturePacker的右侧列。它应该看起来像这样：
- en: '![Begin using sprite sheets with TexturePacker](img/image00227.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TexturePacker的精灵表](img/image00227.jpeg)'
- en: 'Before changing any of the file locations, make sure you do the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改任何文件位置之前，请确保你做了以下操作：
- en: In the **Texture format** drop-down box, ensure that **PNG** is selected. This
    format should be fine for most games you'll make. However, if you find yourself
    wanting to make your game's final project size smaller without sacrificing quality,
    a recommendation is to switch to **zlib pvr.ccz compression**. This is the most
    optimal format for Cocos2d, for not only compression per pixel but also performance
    when drawing the images on the screen.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**纹理格式**下拉框中，确保已选择**PNG**。这种格式应该适用于您将要制作的多数游戏。然而，如果您发现自己想要在不牺牲质量的情况下使游戏最终项目的大小更小，建议切换到**zlib
    pvr.ccz压缩**。这是Cocos2d最优化格式，不仅适用于每像素的压缩，而且在屏幕上绘制图像时的性能也是最佳的。
- en: Check the box that says **Premultiply Alpha**. It's not entirely important to
    know the details of how this works. For now, just know that in Cocos2d, the texture
    can be rendered faster with this checked.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中表示**预乘Alpha**的复选框。现在不需要完全了解它是如何工作的细节。目前只需知道，在Cocos2d中，勾选此选项可以使纹理渲染更快。
- en: Saving to the project location
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存到项目位置
- en: Now that we have the image in TexturePacker, let's modify some of the settings
    to make sure we can effectively manage any future versions of this sprite sheet.
    Click on the little folder icon next to the **Data file** textbox and go to the
    project's `Resources/Published-iOS` directory. Feel free to name the file whatever
    you want, but try to keep it relevant. For this example, we'll call it `buttonSheet`
    because it will be the sprite sheet that contains all the buttons in the game.
    Click on **Save** when you're ready.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将图像放入TexturePacker中，让我们修改一些设置以确保我们可以有效地管理此精灵表的任何未来版本。点击**数据文件**文本框旁边的文件夹图标，进入项目的`Resources/Published-iOS`目录。您可以随意命名文件，但尽量保持相关性。在这个例子中，我们将它命名为`buttonSheet`，因为它将包含游戏中所有按钮的精灵表。准备好后，点击**保存**。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that even though the file is being called `buttonSheet.plist`, there is
    `{v}` at the end of the filename. This is important, and is what allows TexturePacker
    to do the auto-scaling for us.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管文件被命名为`buttonSheet.plist`，但文件名末尾有`{v}`。这很重要，也是TexturePacker为我们进行自动缩放的原因。
- en: '![Saving to the project location](img/image00228.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![保存到项目位置](img/image00228.jpeg)'
- en: As for image format, it's generally okay to keep it at **RGBA8888**. However,
    if your game has a large number of art assets on the screen and is suffering performance-wise,
    changing this to a lower setting might help.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 至于图像格式，通常保持为**RGBA8888**是合适的。但是，如果您的游戏在屏幕上有大量艺术资产并且性能不佳，将其更改为较低的设置可能会有所帮助。
- en: Scaling the images and publishing the sprite sheet
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整图像并发布精灵表
- en: Now we need to make sure TexturePacker will correctly scale what we need. Click
    on the gear icon next to **AutoSD**, and then open the drop-down box at the top
    labeled **Presets**. Choose the option that best suits your needs and click on
    **Apply**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确保TexturePacker将正确缩放我们需要的内容。点击**AutoSD**旁边的齿轮图标，然后打开顶部标有**预设**的顶部下拉框。选择最适合您需求的选项，然后点击**应用**。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're only making an iPhone game (and not an iPad version), select **cocos2d
    hd/sd**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只制作iPhone游戏（而不是iPad版本），选择**cocos2d hd/sd**。
- en: Otherwise (if you are making an iPad version, which this book's project is),
    select **cocos2d ipad/hd/sd**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 否则（如果您正在制作iPad版本，本书的项目就是这样），选择**cocos2d ipad/hd/sd**。
- en: Finally, in the top-left corner of the screen, we click on the **Save defaults**
    button, as it allows us to save these settings for any time when we need to create
    a TexturePacker sprite sheet again. Then click on **Save** (or press *command*
    +*S*). This will ask you where you want to the save the TexturePacker file (not
    the sprite sheet). Generally, you'll save this file in the same folder as all
    your other art assets. For example, we'll have a separate directory for both the
    project and the individual art assets that will be copied later.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在屏幕的左上角，我们点击**保存默认设置**按钮，因为它允许我们在需要再次创建TexturePacker精灵表时保存这些设置。然后点击**保存**（或按*command*
    +*S*）。这将询问您希望将TexturePacker文件（而不是精灵表）保存的位置。通常，您会将与所有其他艺术资产相同的文件夹保存此文件。例如，我们将为项目以及稍后要复制的单个艺术资产创建一个单独的目录。
- en: '![Scaling the images and publishing the sprite sheet](img/image00229.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![调整图像并发布精灵表](img/image00229.jpeg)'
- en: Once you've saved the TPS file in your location of choice, go ahead and click
    on **Publish**. Publishing will generate the required sprite sheets for the project
    based on the various settings we entered earlier.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在选择的位置保存了 TPS 文件，请继续点击 **发布**。发布将根据我们之前输入的各种设置生成项目所需的精灵表。
- en: Importing the sprite sheet and loading it into the memory
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入精灵表并将其加载到内存中
- en: Finally, once you have published the sprite sheet in the project directory (or
    anywhere really, but it's best if it's located in the project directory for easy
    updating later on), the way the Xcode project is set up should cause them to be
    automatically added to your project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你在项目目录中（或者实际上任何地方，但最好位于项目目录中以便于稍后更新），Xcode 项目的设置应该会导致它们自动添加到你的项目中。
- en: 'Once you''ve published the sprite sheet, open Xcode and go to `AppDelegate.m`.
    Add one line of code right above the return statement in the `startScene` method
    to make it look something like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布了精灵表，打开 Xcode 并转到 `AppDelegate.m` 文件。在 `startScene` 方法中的返回语句上方添加一行代码，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you're ready to start using the sprite sheet. It took a little bit of work
    to set it up, but for now, all you need to do is add images to the TexturePacker
    file, click on **Save**, and then click on Publish. Your changes will be automatically
    reflected the next time you run your project. That being said, let's make use
    of the sprite sheet by turning that menu button image into an actual button.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始使用精灵表了。设置它花了一些时间，但到目前为止，你所需要做的就是将图像添加到 TexturePacker 文件中，点击 **保存**，然后点击
    **发布**。你的更改将在你下次运行项目时自动反映出来。话虽如此，让我们通过将菜单按钮图像转换为实际按钮来利用精灵表。
- en: Creating buttons via CCButton and CCLayout
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 CCButton 和 CCLayout 创建按钮
- en: Cocos2d 3.0 changed the way buttons are displayed. If you've used previous versions
    of Cocos2d, you're probably familiar with `CCMenu`. That is no longer the way
    to create and display tappable buttons in Cocos2d. Instead, we're going to use
    `CCButton` and place them in a node of the `CCLayout` type. If you skipped the
    sprite sheet section, I strongly recommend that you go back and read it. It will
    save you from many frustrating moments as the project progresses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d 3.0 改变了按钮的显示方式。如果你之前使用过 Cocos2d 的早期版本，你可能对 `CCMenu` 很熟悉。在 Cocos2d 中，这不再是创建和显示可点击按钮的方式。相反，我们将使用
    `CCButton` 并将它们放置在 `CCLayout` 类型的节点中。如果你跳过了精灵表部分，我强烈建议你回去阅读它。这将帮助你避免在项目进展过程中遇到许多令人沮丧的时刻。
- en: For the book's project, we'll be adding the menu button in the bottom-left corner.
    Like I said, it's extremely easy to add the buttons once you have the images included
    in the project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的项目，我们将在左下角添加菜单按钮。就像我说的，一旦你将图像包含到项目中，添加按钮就极其简单。
- en: 'Open the `MainScene.m` file, and add these lines of code below the code for
    the labels in the `init` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainScene.m` 文件，并在 `init` 方法中的标签代码下方添加这些代码行：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you run it, you should see the menu button appear in the bottom-left corner.
    If you used the `pvr.ccz` format and the button flips horizontally, don''t worry.
    Just go back to TexturePacker, check the box that says **Flip PVR**, save the
    file, and then publish. Go back to Xcode and rerun the project. It should look
    something like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你应该在左下角看到菜单按钮出现。如果你使用了 `pvr.ccz` 格式，并且按钮水平翻转，不要担心。只需回到 TexturePacker，勾选
    **Flip PVR** 的复选框，保存文件，然后发布。回到 Xcode 并重新运行项目。它应该看起来像这样：
- en: '![Creating buttons via CCButton and CCLayout](img/image00230.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![通过 CCButton 和 CCLayout 创建按钮](img/image00230.jpeg)'
- en: Adding the Restart button
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加重启按钮
- en: 'Add the **Restart** button (in this case, `btnRestart.png`) to either TexturePacker
    or SpriteBuilder depending on which method you used, click on Save, and then publish
    to update the files so that the **Restart** button can be used. With the **Restart**
    button''s image added, you can modify the `MainScene.m` file''s code to look something
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的方法，将 **重启** 按钮（在这种情况下，`btnRestart.png`）添加到 TexturePacker 或 SpriteBuilder
    中，点击 **保存**，然后发布以更新文件，以便 **重启** 按钮可以使用。添加了 **重启** 按钮的图像后，你可以修改 `MainScene.m` 文件的代码，使其看起来像这样：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will allow the restart button and the menu button to be lined up perfectly.
    Plus, if you ever decide to move both buttons, but you want them at the same distance
    relative to each other, just reposition the layout box. And voilà!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使重启按钮和菜单按钮完美对齐。此外，如果你决定移动两个按钮，但希望它们相对于彼此的距离相同，只需重新定位布局框。然后，Voilà！
- en: What you can do as a quick learning experience is to try messing around with
    the spacing values; or change the direction, or even the anchor point. You'll
    get a better understanding of why each line of code is absolutely necessary to
    create this effect when you try testing different values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以作为一个快速的学习体验，尝试调整间距值；或者改变方向，甚至锚点。当你尝试测试不同的值时，你会更好地理解为什么每一行代码对于创建这个效果是绝对必要的。
- en: Go ahead and modify some of the values. You can always revert to the preceding
    code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，修改一些值。你总是可以恢复到前面的代码。
- en: 'So far, using the initial code that you just saw, if you run the project, this
    is what it will look like:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用你刚才看到的初始代码，如果你运行项目，它看起来会是这样：
- en: '![Adding the Restart button](img/image00231.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![添加重启按钮](img/image00231.jpeg)'
- en: Creating nodes and units (sprites)
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建节点和单位（精灵）
- en: Remember, everything in Cocos2d is, at its base, a `CCNode` object. Nodes can
    have other nodes as children. For example, if you wish to create a character with
    a jetpack attached, the character can be a `CCSprite` object (a node object with
    an image) and the jetpack can be a `CCSprite` object as a child of the character.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Cocos2d中的所有内容，在其基础层面，都是一个`CCNode`对象。节点可以有其他节点作为子节点。例如，如果你想创建一个带有喷气背包的角色，角色可以是一个`CCSprite`对象（一个带有图像的节点对象），喷气背包可以是一个作为角色子节点的`CCSprite`对象。
- en: Anyway, this is a chapter about prototypes, and we've yet to create any real
    gameplay. Let's get that going with a few images, some touch controls, and much
    more.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这是一章关于原型的内容，我们还没有创建任何真正的游戏玩法。让我们通过一些图像、一些触摸控制和更多内容来开始。
- en: Setting up the background
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置背景
- en: 'Add the background image to the sprite sheet (or SpriteBuilder), save, publish,
    and then in the `MainScene.m` file''s `init` method, add the image to the screen
    as a `CCSprite` object below the `CCLayoutBox` code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将背景图像添加到精灵图中（或SpriteBuilder），保存、发布，然后在`MainScene.m`文件的`init`方法中，将图像作为`CCSprite`对象添加到屏幕上，位于`CCLayoutBox`代码下方：
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run the game, and uh oh! We seem to have run into the first issue with
    our prototype. Although it''s not entirely necessary to get all the bugs and kinks
    out during this phase, this one is important for the gameplay. Plus, it''s a great
    opportunity to learn about device-specific scaling. If you''ll take a look at
    the following screenshots, one of which was taken on an iPhone 5 and the other
    on an iPad Retina, you''ll notice an issue with the game board being a bit too
    big on the phone. Here is a screenshot of the game from an iPhone 5:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏，哎呀！我们似乎遇到了原型中的第一个问题。虽然在这个阶段完全不需要找出所有的错误和问题，但这个问题对于游戏玩法来说很重要。此外，这是一个了解设备特定缩放的好机会。如果你查看以下截图，其中一个是iPhone
    5拍摄的，另一个是iPad Retina拍摄的，你会注意到游戏板在手机上有点太大。以下是iPhone 5上的游戏截图：
- en: '![Setting up the background](img/image00232.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![设置背景](img/image00232.jpeg)'
- en: 'An iPad Retina screenshot of the game appears as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的iPad Retina截图如下：
- en: '![Setting up the background](img/image00233.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![设置背景](img/image00233.jpeg)'
- en: 'Luckily, it''s not too far off, as the auto-scaling from either TexturePacker
    or SpriteBuilder has given us a relatively accurate scale for the game board.
    The only thing we need to do is modify the scale of the board very slightly on
    only the phone, and not the tablet. This can be done by adding these lines of
    code after you''ve declared the board variable:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，它并不太离谱，因为从TexturePacker或SpriteBuilder的自动缩放已经为我们提供了游戏板的相对准确的缩放。我们唯一需要做的是仅对手机上的板进行非常轻微的缩放修改，而不是平板电脑。这可以通过在声明板变量后添加以下代码来完成：
- en: '[PRE15]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Conversely, if you wish to detect an iPad, just use `UIUserInterfaceIdiomPad`
    instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你想检测iPad，只需使用`UIUserInterfaceIdiomPad`即可。
- en: Now, if you run it on a phone (whether it's your own or the simulator), you'll
    see that the grid is nicely within the screen's bounds.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在手机上运行它（无论是你的手机还是模拟器），你会看到网格很好地位于屏幕边界内。
- en: Defining and adding a unit to the screen
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义并添加屏幕上的单位
- en: Since each unit is basically the same, except with a different color and number,
    we should define ourselves a class. To do that, we follow the same instructions
    regarding a new scene, except that this time, we're going to call the `Unit` class
    and set the subclass as a `CCSprite` type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个单位基本上是相同的，只是颜色和数字不同，我们应该为自己定义一个类。为此，我们遵循有关新场景的相同说明，但这次，我们将调用`Unit`类并将子类设置为`CCSprite`类型。
- en: '![Defining and adding a unit to the screen](img/image00234.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![定义并添加屏幕上的单位](img/image00234.jpeg)'
- en: 'Open `Unit.h`, and make it look like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Unit.h` 文件，使其看起来如下：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will basically allow us to give our units a move direction. We also get
    a value associated with them, a Boolean to determine whether it's a friendly unit
    or not (needed for both movement as well as collisions), and various other stuff.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上允许我们给我们的单位一个移动方向。我们还得到了与它们相关的一个值，一个布尔值用来确定它是否是友军单位（这对于移动和碰撞都是必需的），以及各种其他内容。
- en: 'Now open `Unit.m` and add the following code between `@implementation` and
    `@end`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `Unit.m` 文件，并在 `@implementation` 和 `@end` 之间添加以下代码：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `init` methods set up some important stuff: position on the grid, color,
    whether it''s a friendly unit or not, the value of the unit when it first spawns,
    the label in which to show the value, and the direction it intends to move on
    the next turn.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 方法设置了一些重要内容：网格上的位置、颜色、是否为友军单位、单位首次生成时的值、显示值的标签以及它打算在下个回合移动的方向。'
- en: 'Let''s open `MainScene.m` and spawn a friendly unit and an enemy unit on the
    screen. Because we defined the class so well, it''s very simple to spawn two units
    with only a few lines of code. Make sure you include the `Unit.h` at the top too:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `MainScene.m` 文件，并在屏幕上生成一个友军单位和敌军单位。因为我们定义了类非常出色，所以只用几行代码就可以生成两个单位。确保你也在顶部包含了
    `Unit.h` 文件：
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Defining and adding a unit to the screen](img/image00235.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![定义并添加屏幕上的单位](img/image00235.jpeg)'
- en: 'However, the positions still need to be calculated, and the fact that we assigned
    a grid coordinate doesn''t mean anything to the game. We need to determine the
    actual positions on the screen. That is, if we say the position is (5, 5), it
    better know that means smack dab in the middle of the grid. However, the only
    place that knows the screen coordinates is the main scene, so open `MainScene.m`
    and add the following method to get the screen position based on a grid coordinate:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，位置仍然需要计算，而我们分配的网格坐标对游戏来说没有任何意义。我们需要确定屏幕上的实际位置。也就是说，如果我们说位置是 (5, 5)，它最好知道这意味着正正好在网格的正中央。然而，唯一知道屏幕坐标的地方是主场景，所以打开
    `MainScene.m` 文件，并添加以下方法以根据网格坐标获取屏幕位置：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Have a look at the following screenshot; this is how your game will now look
    like:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图；这就是你的游戏现在的样子：
- en: '![Defining and adding a unit to the screen](img/image00236.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![定义并添加屏幕上的单位](img/image00236.jpeg)'
- en: Running the game should get you something like what is shown in the preceding
    screenshot. And yes, even though this screenshot is from an iPad, the code works
    equally well on an iPhone of any resolution, as the formula for determining the
    position works on the assumption that (5, 5) is the center of the grid.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏应该会得到前面截图所示的内容。是的，尽管这个截图来自 iPad，但代码在任意分辨率的 iPhone 上同样有效，因为确定位置的公式是基于 (5,
    5) 是网格中心的假设。
- en: Now let's get these units moving around the screen with some touch mechanics.
    First, place the red unit to the right of the green in the rightmost section of
    the grid—(9, 5), for those who are lazy and don't want to calculate it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一些触摸机制让这些单位在屏幕上移动。首先，将红色单位放在网格最右侧的绿色单位的右侧——(9, 5)，对于那些懒惰且不想计算的人来说。
- en: Moving the units around with touch controls
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用触摸控制移动单位
- en: Touch detection is extremely easy in Cocos2d. From version 3.3 onwards, all
    you need to do is add one line of code and a few methods, and you're good.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d 中进行触摸检测非常简单。从版本 3.3 开始，你只需要添加一行代码和一些方法，就可以完成了。
- en: 'That being said, add this line of code to the `initWithFriendlyUnit` method
    of the `Unit` class (we want to enable touch only on the friendly units, not the
    enemies):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，向 `Unit` 类的 `initWithFriendlyUnit` 方法添加以下代码行（我们希望在友军单位上启用触摸，而不是在敌人单位上）：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These methods are fairly self-descriptive in terms of what they do. The `touchBegan`
    method registers a touch every time a finger touches the screen, the `touchMoved`
    method registers a touch every time the finger is dragged along the screen, and
    the `touchEnded` method registers when the finger is lifted off the screen.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在描述它们的功能方面相当直观。`touchBegan` 方法在手指触摸屏幕时注册一个触摸，`touchMoved` 方法在手指沿屏幕拖动时注册一个触摸，而
    `touchEnded` 方法在手指从屏幕上抬起时注册。
- en: 'In order to determine which unit is being dragged and in which direction, add
    these three variables to the `Unit.h` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定被拖动的单位及其方向，将以下三个变量添加到 `Unit.h` 文件中：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also add this method declaration:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加以下方法声明：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once that's done, open `Unit.m` and add code to the following methods.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，打开 `Unit.m` 并向以下方法添加代码。
- en: 'First you must create this method, which will set the displayed string of the
    Unit''s label to the Unit''s actual value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须创建此方法，它将设置单位标签显示的字符串为单位的实际值：
- en: '[PRE23]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we need to handle our touches in order to update the label, so the following
    code needs to be added to the `touchBegan` method, which will grab the `CCTouch`
    method''s location relative to where it is inside a given node. For now, we want
    to know where the touch is occurring relative to the `Unit` itself, and we''ll
    set that in our `touchDownPos` variable:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要处理我们的触摸以更新标签，因此需要在 `touchBegan` 方法中添加以下代码，这将获取 `CCTouch` 方法相对于给定节点的位置的坐标。目前，我们想知道触摸相对于
    `Unit` 本身的位置，并将其设置在我们的 `touchDownPos` 变量中：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then you have to add the following code to the `touchMoved` method. This will
    determine what direction the finger is being dragged, based on the `x` and `y`
    difference from `touchDownPos` and the current `touchPos` variables:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须向 `touchMoved` 方法添加以下代码。这将根据 `touchDownPos` 和当前 `touchPos` 变量的 `x` 和 `y`
    差异来确定手指被拖动的方向：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, add this section of code to the `touchEnded` method. This will actually
    update the grid position of the unit based on what direction it was being dragged
    in:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将此代码段添加到 `touchEnded` 方法中。这实际上将根据单位被拖动的方向更新单位的网格位置：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, if you run the game, you'll see that when you tap (or click, if running
    on the simulator) and drag that unit… oh my! Why isn't the unit moving? We set
    the grid coordinate and everything! Even the unit's value is being increased properly.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏，你会看到当你轻触（或在模拟器上运行时点击）并拖动该单位……哦，我的天！为什么单位没有移动？我们设置了网格坐标，并且一切正常！甚至单位的值也在正确增加。
- en: But aye! We didn't tell the main scene that the unit needed to be moved, since
    that's where the unit positioning happens. That being said, we want a way to let
    our main scene know that a unit was moved so that we can update its position.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们没有告诉主场景单位需要移动，因为单位定位是在那里发生的。话虽如此，我们想要一种方式让我们的主场景知道单位已经被移动，这样我们就可以更新其位置。
- en: Talking between scenes
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景间的通信
- en: 'A very common way to do this is by making use of `NSNotificationCenter`. It''s
    broken down into two parts: a sender and a receiver. The sender is called a notification
    and the receiver is called an observer. What we need to do is send a notification
    through `NSNotificationCenter` so that any observer set up can receive the notification.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个非常常见的方法是利用 `NSNotificationCenter`。它分为两部分：发送者和接收者。发送者被称为通知，接收者被称为观察者。我们需要通过
    `NSNotificationCenter` 发送一个通知，以便任何设置的观察者都能接收到该通知。
- en: First, we need to declare a constant to reduce human errors when coding. We
    want to do this because the notifications need to be exact, or else they won't
    work.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明一个常量以减少编码时的人为错误。我们这样做是因为通知需要精确，否则它们将不起作用。
- en: 'So, open `Unit.h` and add this line below `#import` but above `NS_ENUM`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，打开 `Unit.h` 并在 `#import` 语句下方但 `NS_ENUM` 语句上方添加此行代码：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, at the top of `Unit.m`, below the `#import` statement but above `@implementation`,
    insert this line of code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Unit.m` 的顶部，在 `#import` 语句下方但 `@implementation` 语句上方，插入以下代码行：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It doesn't entirely matter what the string is; it's just that it has to be something
    unique from any other notification you end up creating later on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是什么并不完全重要；只是它必须与其他你后来创建的通知中的任何内容都不同。
- en: 'Then go ahead and add this little line of code right below the `[self updateLabel]`
    line in the `touchEnded` method of `Unit.m`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Unit.m` 的 `touchEnded` 方法中 `[self updateLabel]` 行下面添加以下代码行：
- en: '[PRE29]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will send a notification to the observer that something has happened. In
    this case, we want to notify the main scene that the current unit has been moved
    via dragging and needs its position updated. That's why we pass `self` (the current
    Unit)—so that we can update the position of the specific unit that was moved.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向观察者发送一个通知，表示发生了某些事情。在这种情况下，我们想要通知主场景当前单位已被拖动并且需要更新其位置。这就是为什么我们传递 `self`（当前
    Unit）——这样我们就可以更新被移动的具体单位的位置。
- en: 'Finally, let''s hop over to `MainScene.m` and add the following code at the
    bottom of (or top of; it''s your preference) the `init` method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们跳转到 `MainScene.m` 并在 `init` 方法的底部（或顶部；由你选择）添加以下代码：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then add the following methods: `moveUnit` and `dealloc`. The `moveUnit` method
    is what we want called when the notification gets pushed. We have an `NSNotification`
    parameter that grabs the `NSDictionary` parameter passed from the `Unit` class.
    We also need the `dealloc` to remove the observer, or else it could catch future
    notifications by accident, and that can cause the game to crash:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下方法：`moveUnit`和`dealloc`。`moveUnit`方法是我们希望在通知被推送时调用的方法。我们有一个`NSNotification`参数，它获取从`Unit`类传递过来的`NSDictionary`参数。我们还需要`dealloc`来移除观察者，否则它可能会意外地捕获未来的通知，这可能导致游戏崩溃：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hurray! Now when you run the code, you should get the unit shifting from grid
    spot to grid spot with each swipe, in any direction. Now it's starting to feel
    like a game. However, it still lacks interaction with the enemies, and none of
    the scores are being increased. Let's add that next.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！现在当你运行代码时，你应该可以看到单位在每个滑动中从网格位置移动到网格位置，任何方向都可以。现在它开始感觉像是一款游戏了。然而，它仍然缺少与敌人的互动，并且没有任何分数被增加。让我们在下一部分添加这些功能。
- en: Interaction with enemies and scoring
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与敌人互动和得分
- en: 'First, we need some variables to keep track of the numbers. So in `MainScene.h`,
    add this under the BMFont label variables:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些变量来跟踪数字。所以，在`MainScene.h`文件中，在BMFont标签变量下添加以下内容：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `MainScene.m`, add the following method to update the label for each counter:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainScene.m`文件中，添加以下方法来更新每个计数器的标签：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add these lines to the `moveUnit` method to increment the respective numbers:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`moveUnit`方法中以增加相应的数字：
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then initialize the variables somewhere in the `init` method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`init`方法中的某个地方初始化变量：
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now you'll notice that each time your unit moves around, the score and the `turns
    survived` labels increases by 1\. But the unit can still go straight through the
    enemy unit. Let's fix that.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会注意到，每次你的单位移动时，分数和`turns survived`标签都会增加1。但是单位仍然可以直穿敌人单位。让我们修复这个问题。
- en: 'First, we need to compare the grid locations after a move with all possible
    enemies on the screen to see whether there was a collision. However, if we''re
    going to cycle through all the enemies, it means we''ll need an array to hold
    them all, so we declare an `NSMutableArray` parameter in the `MainScene.h` file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要比较移动后的网格位置与屏幕上所有可能的敌人，以查看是否发生了碰撞。然而，如果我们打算遍历所有敌人，这意味着我们需要一个数组来保存它们，因此我们在`MainScene.h`文件中声明了一个`NSMutableArray`参数：
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the bottom of the `init` method in the `MainScene.m` file, after you spawn
    the enemy, add the following lines of code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainScene.m`文件中`init`方法的底部，在你生成敌人之后，添加以下代码行：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the end of the `moveUnit` method, we need to cycle through all the enemies
    and check whether the grid location is the same (that is, whether we''re about
    to run into an enemy):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`moveUnit`方法的末尾，我们需要遍历所有敌人并检查网格位置是否相同（即，我们是否即将遇到敌人）：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Under the collision comment, we now want to compare the unit values. Whichever
    unit has the higher value will win, and the unit with the lower value will be
    removed from the board (and the array). In the case of a tie, both will be removed.
    It''s also important to update the `unitsKilled` counter here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在碰撞注释下，我们现在想要比较单位值。值较高的单位将获胜，值较低的单位将从板上（和数组中）移除。在平局的情况下，双方都将被移除。在这里更新`unitsKilled`计数器也很重要：
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, move the `[self updateLabels]` method call in the `moveUnit` method
    to the end of the method (that is, after the loop ends), or else the `unitsKilled`
    label won't be updated until the next turn, which might confuse your players.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`[self updateLabels]`方法调用在`moveUnit`方法中移动到方法的末尾（即，在循环结束后），否则`unitsKilled`标签不会在下一轮更新，这可能会让玩家感到困惑。
- en: That's it! You can move around, run into enemies, combine your score, have the
    labels updated, and even restart the game if you lose (by going to **Menu** and
    tapping the **Play** button). Here's what the game more or less looks like so
    far.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你可以四处移动，遇到敌人，合并你的分数，更新标签，甚至如果你输了（通过转到**菜单**并点击**播放**按钮）可以重新开始游戏。到目前为止，游戏大致看起来是这样的。
- en: 'On an iPad, the game scene appears as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPad上，游戏场景如下所示：
- en: '![Interaction with enemies and scoring](img/image00237.jpeg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![与敌人互动和得分](img/image00237.jpeg)'
- en: 'On an iPhone 5, the game scene appears like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone 5上，游戏场景如下所示：
- en: '![Interaction with enemies and scoring](img/image00238.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![与敌人互动和得分](img/image00238.jpeg)'
- en: Creating menus, scenes, and scene transitions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单、场景和场景转换
- en: Scenes make up the core of Cocos2d. When you go from the main menu to the **Level
    Select** screen, those are (when done in a best practice coding way) two different
    scenes. You can transition from one scene to another in any way your heart desires.
    However, it's generally done by tapping a button. For example, **Play**, **Settings**,
    and **Shop** are all examples of a menu button that a user might press to trigger
    a scene transition.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是Cocos2d的核心。当你从主菜单转到**关卡选择**屏幕时，那些（当以最佳实践的方式进行编码时）是两个不同的场景。你可以以任何你想要的方式从一个场景切换到另一个场景。然而，通常是通过点击按钮来完成的。例如，**播放**、**设置**和**商店**都是用户可能会按下来触发场景切换的菜单按钮的例子。
- en: Creating a new file for the scene
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为场景创建新文件
- en: Most likely, your game isn't going to have just one screen. If so, then you
    can skim over this as it likely won't pertain to you. However, the vast majority
    of games made have at the very least a main menu, a settings menu, a pause screen,
    and some sort of screen besides the main game screen.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你的游戏不会只有一个屏幕。如果是这样，你可以快速浏览这部分内容，因为它可能与你无关。然而，绝大多数游戏至少都有一个主菜单、设置菜单、暂停屏幕以及除了主游戏屏幕之外的一些屏幕。
- en: The next few screenshots show how to create a file with a `CCNode` object as
    the parent class. If you already know how to do this, feel free to skip to the
    next step.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几幅截图展示了如何以`CCNode`对象作为父类创建文件。如果你已经知道如何操作，可以直接跳到下一步。
- en: 'In Xcode, right-click (or press *Ctrl* and click) on the source folder at the
    top of the project navigator, and then click on **New File** as shown in the following
    screenshot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中，在项目导航器顶部的源文件夹上右键单击（或按*Ctrl*并单击），然后点击**新建文件**，如图所示：
- en: '![Creating a new file for the scene](img/image00239.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![为场景创建新文件](img/image00239.jpeg)'
- en: 'In the dialog window that opens, under the iOS **Source** section, select **Cocoa
    Touch Class** and click on **Next** as shown in the following screenshot:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的对话框中，在iOS **源**部分下，选择**Cocoa Touch类**并点击**下一步**，如图所示：
- en: '![Creating a new file for the scene](img/image00240.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![为场景创建新文件](img/image00240.jpeg)'
- en: Name the class something relevant, as you may have to go back to it later. We're
    going to use `MenuScene` as the name of our class. Once you've named the class,
    click on **Next**.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 给类起一个相关的名字，因为你可能需要稍后返回它。我们将使用`MenuScene`作为我们类的名字。一旦命名了类，点击**下一步**。
- en: Tip
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure you change **Subclass of** to `CCNode`, or else you'll be unable to
    make a new scene out of it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将**子类为**改为`CCNode`，否则你将无法从它创建新的场景。
- en: '![Creating a new file for the scene](img/image00241.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![为场景创建新文件](img/image00241.jpeg)'
- en: Talking about where to save the file, it's recommended to keep all of your project's
    class files in the same directory. As shown in the following screenshot, we're
    saving the **MenuScene** file we wish to create in the `Source` folder, where
    the **MainScene** files are located.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到保存文件的位置，建议将所有项目类文件保存在同一目录下。如图所示，我们将要创建的**MenuScene**文件保存在`Source`文件夹中，其中也存放着**MainScene**文件。
- en: 'Once you''ve chosen a location, click on **Create** as shown in the following
    screenshot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了位置，点击**创建**，如图所示：
- en: '![Creating a new file for the scene](img/image00242.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![为场景创建新文件](img/image00242.jpeg)'
- en: Turning a class into an official CCScene subclass
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类转换为官方CCScene子类
- en: 'It''s not officially a scene yet, but that''s what we''re going to add now.
    In the header file of the class you just created, add a similar block of code
    between the `@interface` and `@end` lines—like what we have in the `MainScene.m`
    file. For example, your header might look something like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它还不是官方的场景，但这是我们接下来要添加的。在你刚刚创建的类的头文件中，在`@interface`和`@end`行之间添加一个类似的代码块——就像我们在`MainScene.m`文件中有的那样。例如，你的头文件可能看起来像这样：
- en: '[PRE40]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, in the main file for the class, add the following between the `@implementation`
    and `@end` lines (yes, it''s a copy-paste job for each scene you create):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在类的主体文件中，在`@implementation`和`@end`行之间添加以下内容（是的，每个创建的场景都需要复制粘贴）：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With that in place, you can now begin to add code to the main menu scene. Let''s
    quickly add a background color to the `init` method so that we know the scene
    works when we eventually link a button and transition to it. We''re going to give
    it a random green color, because the default is black:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，你现在可以开始向主菜单场景添加代码。让我们快速给`init`方法添加一个背景颜色，以便我们知道当最终链接按钮并切换到它时场景是否工作。我们将给它一个随机的绿色颜色，因为默认颜色是黑色：
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Linking the button in the game to go to the menu
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏中链接按钮以跳转到菜单
- en: 'Open `MainScene.m`, and include the scene you created at the top of the file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainScene.m`，并将你创建的场景包含在文件顶部：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then go to the section of code where you declared the **Menu** button. Right
    after you declare it, add the following line of code. This will connect the menu
    button to a method called `goToMenu`. The `setTarget` method is the way `CCButton`
    knows what to do when it gets tapped:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转到你声明**菜单**按钮的代码部分。在你声明之后，添加以下代码行。这将连接菜单按钮到名为`goToMenu`的方法。`setTarget`方法是`CCButton`知道在点击时应该做什么的方式：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, below the `init` method, add the `goToMenu` method, like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`init`方法下面添加`goToMenu`方法，如下所示：
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With these three things added, you should be able to run the game and click
    on the menu button. Voilà! We have a transition to the `Menu` scene, albeit rather
    ugly at the moment. But there's no way to get back to the game screen, so let's
    add a **Play** button to do so.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这三样东西后，你应该能够运行游戏并点击菜单按钮。哇！我们有了到`Menu`场景的过渡，尽管目前看起来相当丑陋。但是没有办法回到游戏屏幕，所以让我们添加一个**播放**按钮来实现这一点。
- en: Creating and linking a button in the menu to go to the game
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在菜单中创建和链接按钮以跳转到游戏
- en: Now that we're able to get to the **Menu** scene, let's quickly add a **Play**
    button so that we can start to create the core of the gameplay and round out this
    prototype.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够到达**菜单**场景了，让我们快速添加一个**播放**按钮，这样我们就可以开始创建游戏的核心玩法并完善这个原型。
- en: 'First, add the **Play** button to TexturePacker, save, and publish. Then open
    `MenuScene.m` and add the following to the `init` method:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将**播放**按钮添加到TexturePacker中，保存并发布。然后打开`MenuScene.m`，并在`init`方法中添加以下内容：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also add the `goToGame` method below `init` so that the button actually has
    a method to call:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还在`init`方法下面添加`goToGame`方法，以便按钮实际上有一个可以调用的方法：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Run the project and click on the **Menu** button. You should see a clickable
    **Play** button that will take you back to the game. Yay, scene transitions! Now
    that the play button is in place and we have the basic layout between scenes,
    we can get working on the core of the game.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并点击**菜单**按钮。你应该看到一个可点击的**播放**按钮，它会带你回到游戏。耶，场景过渡！现在播放按钮已经就位，并且我们有了场景之间的基本布局，我们可以开始着手游戏的核心。
- en: One final thing you could do would be to create a `restartGame` method, set
    the target of the **Restart** button to `self`, and set the selector of the restart
    button to the `restartGame` method. Inside the `restartGame` method you have created,
    simply call the `replaceScene` method (like what you just did), but this time,
    use `MainScene` instead of `MenuScene` so that the scene transitions to a fresh/clean/new/whatever
    version of itself. This is a good idea because this is the minimal code for the
    very effect we're trying to achieve here.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做的一件事是创建一个`restartGame`方法，将**重启**按钮的目标设置为`self`，并将重启按钮的选择器设置为`restartGame`方法。在你创建的`restartGame`方法内部，只需调用`replaceScene`方法（就像你刚才做的那样），但这次使用`MainScene`而不是`MenuScene`，以便场景过渡到一个全新的版本。这是一个好主意，因为这是我们在这里试图实现的最小代码。
- en: Where to go from here?
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来要去哪里？
- en: 'It''s quite clear that the project is far from complete at this stage. However,
    there are a lot of things that are a core of the game''s implementation: the dragging,
    the scoring, and the grid formation. From here on, it''s probably best to continue
    to iterate on the project and slowly add stuff until it''s a fully working prototype
    with very minimal baseline mechanics working. For example, we could add some enemy
    spawning, **Artificial Intelligence** (**AI**), the user''s units automatically
    moving, and so on.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，在这个阶段，项目远未完成。然而，有很多事情是游戏实现的核心：拖动、得分和网格形成。从现在开始，最好继续迭代项目，并逐渐添加内容，直到它成为一个功能齐全的原型，具有非常基本的基线机制。例如，我们可以添加一些敌人生成、**人工智能**（**AI**）、用户单位自动移动等等。
- en: 'But as far as this book is concerned, we''re going to move on as the point
    of this chapter was to go straight into a prototype. That''s basically what we
    have here—something we can show our friends and family and say, "Hey, this is
    what the concept is, and this is what I''ve got so far." With the prototype, you
    can gauge things such as the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 但就这本书而言，我们将继续前进，因为本章的目的是直接进入原型。这基本上就是我们在这里所拥有的东西——我们可以向我们的朋友和家人展示的东西，并说：“嘿，这就是概念，这是我目前所拥有的。”通过原型，你可以评估以下方面：
- en: Is the game board too small for the player's fingers?
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏板对玩家的手指来说太小了吗？
- en: Is the concept too confusing?
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个概念是否过于复杂？
- en: Is it hard to interact with the character?
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与角色交互是否困难？
- en: With time, all of these will be sorted, but it's better to learn about the biggest
    problems early on rather than find them after your game has been published on
    the App Store and you notice that nobody is downloading it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，所有这些都会被整理好，但最好是尽早了解最大的问题，而不是在游戏发布到App Store并注意到没有人下载它之后才发现。
- en: Some suggestions
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些建议
- en: 'If you''re following the book''s tutorial/example project (which I hope you
    are), try adding the following on your own, all of which will be added outside
    this book for consolidation purposes:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随本书的教程/示例项目（我希望你在这样做），请尝试自己添加以下内容，所有这些都将添加到本书之外，用于巩固：
- en: Automatically moving the red unit each turn and increasing its score
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每回合自动移动红色单位并增加其分数
- en: Spawning a red unit every three or four turns around the border and adding it
    to the array (and possibly implementing the movement as you did with the previous
    red unit)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边界周围每三或四个回合生成一个红色单位，并将其添加到数组中（并且可能像处理上一个红色单位那样实现移动）
- en: Spawning another friendly unit with a value of `1` when you move away from (5,
    5)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你从（5，5）位置移开时，生成一个值为`1`的另一个友好单位
- en: Creating and maintaining a friendly unit array
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和维护一个友好的单位数组
- en: Making all friendly units move in the direction they were last instructed
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让所有友好的单位移动到它们最后被指示的方向
- en: Don't worry if you don't want to take the time to implement these by yourself.
    A later chapter will have them pre-implemented, and you can download the source
    code to get an up-to-date version before you begin that chapter.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想花时间自己实现这些，不要担心。后面的章节将预先实现它们，你可以在开始那一章之前下载源代码以获取最新版本。
- en: However, it is highly recommended that you do try coding on your own, as that's
    the entire point of this book—to push you further as a coder. The tutorials are
    here for support, but the main purpose is to show you cool things and let you
    run loose with the tools at your disposal.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，强烈建议你自己尝试编码，因为这就是这本书的全部目的——推动你作为一个程序员更进一步。教程在这里是为了提供支持，但主要目的是展示一些酷炫的东西，并让你利用手头的工具自由发挥。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A prototype for the game, as shown in this chapter, can be done relatively quickly
    (not that many pages compared to how much content was put in). If you have a large-scale
    game (which is almost certainly the case), now would be the best time to go about
    creating the other scenes, adding buttons that link the scenes together, creating
    the characters in the game, and even adding some baseline code for the core of
    the game.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所示，游戏的原型可以相对快速地完成（与放入的内容相比，页面并不多）。如果你有一个大规模的游戏（这几乎肯定是这样），现在就是创建其他场景、添加链接场景的按钮、创建游戏中的角色以及甚至为游戏的核心添加一些基本代码的最佳时机。
- en: In general, the way to prototype quickly and iterate more often is to get the
    simplest parts that draw a wireframe of the project first so that the people holding
    the prototype can fill the gaps with their imagination (or if you hand them a
    near-complete project, they won't have to fill any gaps). It's like drawing a
    person on a piece of paper. First, you draw a rough version of their body position,
    then fill in a bit of the muscle and fat, and finally draw the details such as
    fingers, clothes, facial expressions, and so on.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，快速原型和频繁迭代的办法是先获取最简单的部分，先绘制出项目的线框图，这样持有原型的人就可以用他们的想象力来填补空白（或者如果你给他们一个几乎完成的项目，他们就不需要填补任何空白）。这就像在纸上画人一样。首先，你画出他们身体位置的草图，然后填充一点肌肉和脂肪，最后绘制细节，如手指、衣服、面部表情等。
- en: In the next chapter, we'll cover in depth how to create some really awesome
    mechanics and do with Cocos2d what most developers don't do.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨如何创建一些真正酷炫的机制，并使用Cocos2d做大多数开发者不做的事情。
