- en: Chapter 12. Multitasking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。多任务处理
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Detecting application states
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测应用状态
- en: Receiving notifications for the application states
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收应用状态的通知
- en: Running code in the background
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行代码
- en: Playing audio in the background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台播放音频
- en: Updating data in the background
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台更新数据
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When the iOS platform was introduced in 2007, it brought lots of exciting new
    features for users and drastically changed the concept of mobile devices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iOS 平台在 2007 年推出时，它为用户带来了许多令人兴奋的新功能，并极大地改变了移动设备的概念。
- en: Despite its huge success, it lacked some features at the time, which were considered
    *basic*. One of these features was multitasking, that is, support for running
    multiple processes at the same time. The platform actually did support multitasking
    to system processes internally, but it was not available to developers. Starting
    with iOS 4, Apple provided support for multitasking, although it is still quite
    different from what most developers are accustomed to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它当时取得了巨大的成功，但它缺少一些被认为是*基本*的功能。其中之一就是多任务处理，即同时运行多个进程的支持。实际上，该平台在内部支持系统进程的多任务处理，但这对开发者来说并不可用。从
    iOS 4 开始，苹果提供了对多任务处理的支持，尽管它与大多数开发者习惯的还相当不同。
- en: In this chapter, we will discuss how to make use of the platform's multitasking
    features. We will see under what circumstances we can use these features and what
    functionality we can provide to the users of our apps through multitasking. Specifically,
    we will learn about an application's states and its runtime lifecycle. Through
    a series of detailed example projects, we will be able to execute code while an
    app is in the background, support audio playback, and receive data updates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何利用平台的多任务功能。我们将了解在什么情况下可以使用这些功能，以及我们如何通过多任务为我们的应用用户提供功能。具体来说，我们将了解应用的状态及其运行时生命周期。通过一系列详细的示例项目，我们能够在应用处于后台时执行代码，支持音频播放，并接收数据更新。
- en: Detecting application states
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测应用状态
- en: In this recipe, we will discuss how to detect the state of the application and
    respond accordingly when an application is transited from the active to the inactive
    state and vice versa.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何检测应用的状态，并在应用从活动状态过渡到非活动状态以及相反时相应地做出反应。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `AppStateApp`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的**单视图应用**，并将其命名为 `AppStateApp`。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the following method override to the `AppDelegate` class:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法覆盖添加到 `AppDelegate` 类中：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the app either on the simulator or on the device. Press the
    home button (or press *Shift* + *Command* + *H* on the keyboard for the simulator)
    to suspend the app and watch the **Application Output** pad in Xamarin Studio.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译和运行应用，可以在模拟器或设备上操作。按下主页按钮（或在模拟器上按 *Shift* + *Command* + *H* 键）以挂起应用，并观察 Xamarin
    Studio 中的**应用输出**面板。
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIApplicationDelegate` class contains methods that are triggered at specific
    notifications issued by the runtime. These methods are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIApplicationDelegate` 类包含由运行时发出的特定通知触发的方法。这些方法如下：'
- en: '`OnActivated`: This method is called when the app is made active, for example,
    when unlocking the screen.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivated`：当应用变为活动状态时，此方法被调用，例如，当解锁屏幕时。'
- en: '`OnResignActivation`: This method is called when the app is about to become
    inactive, for example, when the screen is locked or when an incoming call takes
    place.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnResignActivation`：当应用即将变为非活动状态时，此方法被调用，例如，当屏幕锁定或发生来电时。'
- en: '`DidEnterBackground`: This method is called when the app has entered the background,
    for example, when pressing the home button. At this time, the app is suspended.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidEnterBackground`：当应用进入后台时，此方法被调用，例如，当按下主页按钮时。此时，应用处于挂起状态。'
- en: '`WillEnterForeground`: This method is called when the app is about to return
    to the foreground.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WillEnterForeground`：当应用即将返回前台时，此方法被调用。'
- en: Note that when the app is moved to the background, both the `OnResignActivation`
    and `DidEnterBackground` methods are called. Similarly, when the app is moved
    to the foreground, both the `WillEnterForeground` and `OnActivated` methods are
    called.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当应用移动到后台时，`OnResignActivation` 和 `DidEnterBackground` 方法都会被调用。同样，当应用移动到前台时，`WillEnterForeground`
    和 `OnActivated` 方法都会被调用。
- en: 'All these methods contain one parameter, which contains the `UIApplication`
    instance of the app. The `UIApplication` class contains the `ApplicationState`
    property, which returns the state of the app as values of the `UIApplicationState`
    property. These values are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都包含一个参数，该参数包含应用程序的`UIApplication`实例。`UIApplication`类包含`ApplicationState`属性，该属性返回应用程序的状态，作为`UIApplicationState`属性的值。这些值如下：
- en: '**Active**: This indicates that the app is active'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃状态**：这表示应用程序处于活跃状态'
- en: '**Inactive**: This indicates that the app is inactive, for example, when a
    notification alert is displayed'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非活跃状态**：这表示应用程序处于非活跃状态，例如，当显示通知警报时'
- en: '**Background**: This indicates that the app is in the background'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台状态**：这表示应用程序处于后台状态'
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are cases where iOS will kill your app, for example, when a memory warning
    is issued and your app does not free up resources. The `WillTerminate` method
    will be called in these cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候iOS会终止你的应用程序，例如，当发出内存警告而你的应用程序没有释放资源时。在这些情况下，将调用`WillTerminate`方法。
- en: Proper usage
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确使用
- en: The preceding methods are very useful because they allow us to save the current
    data that is presented to the user when the app changes its state. When the app
    is transited to an inactive or background state, each method is given a limited
    amount of time to execute, so we should make sure that it does not perform long-running
    operations, or else, iOS will kill the app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法非常有用，因为它们允许我们在应用程序状态改变时保存向用户展示的当前数据。当应用程序过渡到非活跃或后台状态时，每个方法都有一定的时间来执行，因此我们应该确保它不会执行长时间运行的操作，否则iOS会终止应用程序。
- en: Receiving notifications for app states
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收应用程序状态的通知
- en: In this recipe, we will discuss how to get notified when the application's state
    changes outside the scope of the `UIApplicationDelegate` implementation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论当应用程序的状态在`UIApplicationDelegate`实现的作用域之外发生变化时，如何接收通知。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `NotifyStatesApp`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`NotifyStatesApp`。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the following fields in the `NotifyStatesAppViewController` class:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NotifyStatesAppViewController`类中输入以下字段：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the following methods:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下方法：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `ViewWillAppear` override, call the `AddNotificationObservers` method
    as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewWillAppear`的覆盖方法中，按照以下方式调用`AddNotificationObservers`方法：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `ViewWillDisappear` override, call the `RemoveNotificationObservers`
    method as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewWillDisappear`的覆盖方法中，按照以下方式调用`RemoveNotificationObservers`方法：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile and run the app on the simulator. Press the home button (or press *Shift*
    + *Command* + *H*), and watch the output in the **Application Output** pad.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。按住主页按钮（或按*Shift* + *Command* + *H*），并在**应用程序输出**面板中查看输出。
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Apart from calling the methods of the `UIApplicationDelegate` object for app
    states, iOS issues notifications that we can receive. This is very useful, because
    in most cases, we need to be notified when the app's state changes outside the
    scope of the `AppDelegate` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用应用程序状态的`UIApplicationDelegate`对象的方法之外，iOS还会发出我们可以接收的通知。这非常有用，因为在大多数情况下，我们需要在应用程序状态在`AppDelegate`类的作用域之外改变时收到通知。
- en: 'To accomplish this, we use the `NSNotificationCenter` method through the `UIApplication.Notifications`
    class as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们通过`UIApplication.Notifications`类使用`NSNotificationCenter`方法，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example only adds notification observers for the transition between the
    background and foreground. We can add more notification observers through the
    other available `Observe*` methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅添加了在后台和前台之间转换的通知观察者。我们可以通过其他可用的`Observe*`方法添加更多通知观察者。
- en: The result is similar to the example used in the previous recipe, but in this
    case, we get notified inside the scope of our view controller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前菜谱中使用的示例类似，但在这个情况下，我们在视图控制器的作用域内收到通知。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: To add notification observers when the app is activated or when it resigns activation,
    we use the `UIApplication.Notifications.ObserveDidBecomeActive` and `UIApplication.Notifications.ObserveWillResignActive`
    methods, respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序激活或放弃激活时添加通知观察者，我们分别使用`UIApplication.Notifications.ObserveDidBecomeActive`和`UIApplication.Notifications.ObserveWillResignActive`方法。
- en: Removing notification observers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除通知观察者
- en: In this example, we call `RemoveNotificaitonObservers` inside the `ViewWillAppear`
    method. However, the method is not being called when the app is transited to the
    background but only when we display another view controller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `ViewWillAppear` 方法内部调用 `RemoveNotificationObservers`。然而，当应用过渡到后台时，该方法不会被调用，而只有在显示另一个视图控制器时才会被调用。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Detecting application states* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测应用程序状态* 的配方'
- en: Running code in the background
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行代码
- en: In this recipe, we will learn how to execute code in the background, taking
    full advantage of iOS's multitasking feature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在后台执行代码，充分利用 iOS 的多任务功能。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundCodeApp`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用** 并将其命名为 `BackgroundCodeApp`。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the following code in the `AppDelegate` class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中输入以下代码：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compile and run the app on the simulator. Press the home button (*Command* +
    *Shift* + *H*) to make the app enter the background and watch the **Application
    Output** pad. Before the background task is completed (1 minute), bring the app
    to the foreground by either tapping on its icon in the multitasking bar or on
    its icon on the home screen.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。按住主页按钮（*Command* + *Shift* + *H*）使应用进入后台，并观察 **应用程序输出** 面板。在后台任务完成之前（1
    分钟），可以通过在多任务栏或主屏幕上的图标上轻触来将应用带到前台。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous tasks, we learned how to get informed when an app gets transited
    from the foreground to the background and vice versa.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的任务中，我们学习了如何得知应用从前台过渡到后台以及相反的情况。
- en: Multitasking on iOS is not quite what we are used to on other platforms. The
    iOS platform helps us makes sure that the foreground app will have all the available
    resources at its disposal (and the user's). To accomplish this, when the app enters
    the background, it is being suspended by the operating system. When it is suspended,
    it does not execute any code whatsoever.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 的多任务处理并不完全像我们在其他平台上所习惯的那样。iOS 平台帮助我们确保前台应用将拥有所有可用的资源（以及用户的）。为了实现这一点，当应用进入后台时，它会被操作系统挂起。当它被挂起时，它不会执行任何代码。
- en: If we want to prevent the app from being suspended when the user presses the
    home button, we can ask for background time. The time we ask for is limited to
    600 seconds (10 minutes), which is more than enough for the majority of tasks
    we are likely to perform in the background (for example, saving the UI state,
    completing a file download/upload, closing any open connections, and so on).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止用户按下主页按钮时应用被挂起，我们可以请求后台时间。我们请求的时间限制为 600 秒（10 分钟），这对于我们可能在后台执行的大多数任务来说已经足够了（例如，保存
    UI 状态，完成文件下载/上传，关闭任何打开的连接，等等）。
- en: 'To ask for the background time, we call the `BeginBackgroundTask` method of
    our `UIApplication` instance as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求后台时间，我们按照以下方式调用我们的 `UIApplication` 实例的 `BeginBackgroundTask` 方法：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method accepts one parameter of the `NSAction` type and returns an integer,
    which corresponds to the task ID. The `NSAction` parameter represents the block
    of code that will be executed just before the background time elapses. Inside
    that block of code, we have to call the `EndBackgroundTask` method, passing the
    ID of the task that was started, which will inform the runtime that we no longer
    need the background time. Each call of `BeginBackgroundTask` should be followed
    by a call to `EndBackgroundTask`. If we do not call this method and the background
    time elapses, the app will be terminated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个 `NSAction` 类型的参数并返回一个整数，该整数对应于任务 ID。`NSAction` 参数表示将在后台时间耗尽前执行的代码块。在该代码块内部，我们必须调用
    `EndBackgroundTask` 方法，传递已启动任务的 ID，这将通知运行时我们不再需要后台时间。每次调用 `BeginBackgroundTask`
    都应紧随 `EndBackgroundTask` 的调用。如果我们不调用此方法并且后台时间耗尽，应用将被终止。
- en: After calling the `BeginBackgroundTask` method, we can execute the code we want.
    To allow the `DidEnterBackground` method to complete and to avoid blocking the
    main thread, we just enclose our code to either an asynchronous call or in a separate
    thread. In this example, we use a thread from `ThreadPool`. As this specific task
    will be completed before the time in which we have the elapses, we call the `EndBackgroundTask`
    method to let the system know that the job is done. The block of code that we
    passed to the `BeginBackgroundTask` method will not be executed as we ended the
    task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`BeginBackgroundTask`方法后，我们可以执行我们想要的代码。为了允许`DidEnterBackground`方法完成并避免阻塞主线程，我们只需将我们的代码封装到异步调用或单独的线程中。在这个例子中，我们使用`ThreadPool`中的一个线程。由于这个特定任务将在我们有时间之前完成，我们调用`EndBackgroundTask`方法来让系统知道工作已完成。我们传递给`BeginBackgroundTask`方法的代码块将不会执行，因为我们已经结束了任务。
- en: There are cases however, where the user might bring the app to the foreground
    while a background task is still running. To cover this scenario, we need to override
    the `WillEnterForeground` method and handle it in an appropriate manner. We can
    either stop the background task (by calling `EndBackgroundTask`), or provide some
    sort of feedback to the user that a task is still running. This scenario also
    makes the use of an asynchronous call to our code, which is the best practice.
    If the code of our background task is synchronous, then when the user brings the
    app to the foreground and the task is still running, the app will be frozen until
    the task is completed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在用户在后台任务仍在运行时将应用带到前台的情况。为了覆盖这种场景，我们需要重写`WillEnterForeground`方法，并适当地处理它。我们可以停止后台任务（通过调用`EndBackgroundTask`），或者向用户提供某种反馈，告知任务仍在运行。这种场景也使得异步调用我们的代码成为最佳实践。如果我们的后台任务代码是同步的，那么当用户将应用带到前台且任务仍在运行时，应用将会冻结，直到任务完成。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To know how much time is left to perform the background tasks, we can check
    the value of the `BackgroundTimeRemaining` property as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道执行后台任务剩余多少时间，我们可以检查`BackgroundTimeRemaining`属性的值如下：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important considerations for the background code
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台代码的重要考虑因素
- en: 'The following are the important points to be considered when you are working
    with the background code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理后台代码时，以下是需要考虑的重要点：
- en: Do not update the UI while the app is in the background. Doing so may cause
    your app to terminate or crash. Any updates to UI elements that take place while
    the app is in the background are queued to be performed when it returns to the
    foreground. This will surely make the app unresponsive.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用处于后台时，不要更新UI。这样做可能会导致您的应用终止或崩溃。在应用处于后台时发生的任何UI元素更新都会排队，以便在它返回前台时执行。这肯定会使得应用无响应。
- en: Do not inform the user to bring your app to the foreground just to give more
    time to the task. Doing so will surely get your app rejected from the app store's
    approval process. If a background task is in progress and the user brings the
    app to the foreground, moving the app back to the background again basically continues
    the remaining background time.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要通知用户将您的应用带到前台以给任务更多时间。这样做肯定会使得您的应用在应用商店的审批过程中被拒绝。如果后台任务正在进行中，并且用户将应用带到前台，再次将应用移回后台基本上会继续剩余的后台时间。
- en: Perform lightweight operations in the background to avoid the runtime from killing
    your app.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台执行轻量级操作，以避免运行时杀死您的应用。
- en: Avoid using external resources (for example, resources from the assets library).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用外部资源（例如，来自资源库的资源）。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Detecting application states* recipe
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检测应用程序状态*配方'
- en: Playing audio in the background
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台播放音频
- en: In this recipe, we will learn how to prevent the app from being suspended in
    order to allow audio playback.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何防止应用被挂起，以便允许音频播放。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundAudioApp`.
    Add a button on the view of the controller. You will also need an audio file.
    In this example, an M4A file with a duration of 21 seconds is used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用**，并将其命名为`BackgroundAudioApp`。在控制器的视图中添加一个按钮。您还需要一个音频文件。在这个例子中，使用了一个时长为21秒的M4A文件。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Double-click on the `Info.plist` file to open it. Select the **Source** tab
    at the bottom and add the `UIBackgroundModes` key (**Required background modes**)
    with the string value audio. The following screenshot shows you how the key and
    value are shown in the editor after they have been set:![How to do it...](img/8924OT_12_01.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `Info.plist` 文件以打开它。在底部选择 **Source** 选项卡，并添加 `UIBackgroundModes` 键（**必需的后台模式**）并设置字符串值为
    audio。以下截图显示了在设置后如何在编辑器中显示键和值：![如何操作...](img/8924OT_12_01.jpg)
- en: Add the `MonoTouch.AVFoundation` namespace in the `BackgroundAudioAppViewController.cs`
    file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BackgroundAudioAppViewController.cs` 文件中添加 `MonoTouch.AVFoundation` 命名空间。
- en: 'Enter the following `ViewDidLoad` method in the class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中输入以下 `ViewDidLoad` 方法：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add a sound file to the project and set its **Build Action** to **Content**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将声音文件添加到项目中，并将其 **Build Action** 设置为 **Content**。
- en: Compile and run the app on the device. Tap the **Play sound** button and press
    the home button to make the app enter the background. Notice that the sound continues
    playing.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用。轻触 **播放声音** 按钮并按住主页按钮，使应用进入后台。注意，声音继续播放。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make sure that our app will be able to play the audio while it is in the
    background, we have to set the audio item in the `UIBackgroundModes` key in the
    `Info.plist` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的应用在后台时能够播放音频，我们必须在 `Info.plist` 文件中的 `UIBackgroundModes` 键中设置音频项。
- en: 'In this example, we used the `AVAudioPlayer` class to play a sound file. Just
    creating an instance of the class and calling its `Play` method is not enough,
    though. We have to set a specific type for the audio session category. We will
    do this with the help of the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `AVAudioPlayer` 类来播放声音文件。仅仅创建类的实例并调用其 `Play` 方法是不够的。我们必须为音频会话类别设置一个特定的类型。我们将通过以下代码来完成这项工作：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The static `AVAudioSession.SharedInstance` method returns the current audio
    session object. The audio session category is set to `AVAudioSession.CategoryPlayback`,
    which allows the `AVAudioPlayer` class to play sounds while the app is in the
    background. This requirement is specific to objects in the `MonoTouch.AVFoundation`
    namespace.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法 `AVAudioSession.SharedInstance` 返回当前的音频会话对象。音频会话类别设置为 `AVAudioSession.CategoryPlayback`，允许
    `AVAudioPlayer` 类在应用处于后台时播放声音。这个要求仅适用于 `MonoTouch.AVFoundation` 命名空间中的对象。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following are the available audio session categories:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用的音频会话类别：
- en: '`CategoryAmbient`: In this category, sounds are silenced when the device screen
    is locked or when the device''s silence switch is on. Sounds from external resources
    (such as the iPod app) are mixed with this category.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryAmbient`: 在这个类别中，当设备屏幕锁定或设备的静音开关打开时，声音会被静音。外部资源的声音（如 iPod 应用）会与这个类别混合。'
- en: '`CategorySoloAmbient`: This is the default category. Sounds from external resources
    are silenced with this category. Sounds are silenced when the screen is locked
    or when the device''s silent switch is on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategorySoloAmbient`: 这是默认类别。使用此类别，外部资源的声音会被静音。当屏幕锁定或设备的静音开关打开时，声音会被静音。'
- en: '`CategoryPlayback`: In this category, sounds are not silenced when the screen
    is locked or when the silent switch is on. Sounds from external resources are
    silenced but can be mixed if the `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`
    property is set to `true`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryPlayback`: 在这个类别中，当屏幕锁定或静音开关打开时，声音不会被静音。外部资源的声音会被静音，但如果将 `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`
    属性设置为 `true`，则可以混合。'
- en: '`CategoryRecord`: This category is for recording audio. All the audio playback
    is silenced. The recording continues even when the screen is locked.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryRecord`: 这个类别用于录音。所有音频播放都被静音。即使在屏幕锁定的情况下，录音也会继续。'
- en: '`CategoryPlayAndRecord`: This category is for apps that need to record and
    play audio. Sounds from external resources are silenced but can be mixed if the
    `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers` property is
    set to `tru`e. Sounds continue to play when the screen is locked or when the silent
    switch is on.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryPlayAndRecord`: 这个类别用于需要录音和播放音频的应用。外部资源的声音会被静音，但如果将 `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`
    属性设置为 `true`，则可以混合。当屏幕锁定或静音开关打开时，声音会继续播放。'
- en: '`CategoryAudioProcessing`: This category is specific to processing audio. Sound
    playback and recording is disabled in this category.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CategoryAudioProcessing`: 这个类别专门用于处理音频。在此类别中，声音播放和录音被禁用。'
- en: The background state for audio
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频的后台状态
- en: Even when the app is configured through the `Info.plist` file to support the
    background audio playback, the app will be suspended when the playback is completed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序通过`Info.plist`文件配置为支持后台音频播放，播放完成后应用程序也会被挂起。
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Location services in the background* recipe in [Chapter 10](ch10.html "Chapter 10. Location
    Services and Maps"), *Location Services and Maps*
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第10章中，*位置服务和地图*的*后台位置服务*菜谱
- en: Updating data in the background
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台更新数据
- en: In this recipe, we will learn how to make use of iOS 7's **background fetch**
    feature. This feature automatically wakes up the app at system-managed intervals,
    giving it a specific amount of time to retrieve data and update the UI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何利用iOS 7的**后台获取**功能。这个功能会在系统管理的间隔自动唤醒应用程序，给它一定的时间来检索数据和更新UI。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundFetchApp`.
    Add a label to the controller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`BackgroundFetchApp`。向控制器中添加一个标签。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We need access to the label from outside of the scope of the `BackgroundFetchAppViewController`
    class, so create a public property for it as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从`BackgroundFetchAppViewController`类的范围外访问标签，因此创建一个公共属性，如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open the `Info.plist` file and under the **Source** tab, add the `UIBackgroundModes`
    key (**Required background modes**) with the string value, `fetch`. The following
    screenshot shows you the editor after it has been set:![How to do it...](img/8924OT_12_02.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Info.plist`文件，在**源**选项卡下，添加`UIBackgroundModes`键（**必需的后台模式**）并设置字符串值为`fetch`。以下截图显示了设置后的编辑器：![如何做...](img/8924OT_12_02.jpg)
- en: 'In the `FinishedLaunching` method of the `AppDelegate` class, enter the following
    line:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类的`FinishedLaunching`方法中，输入以下行：
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enter the following code, again, in the `AppDelegate` class:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在`AppDelegate`类中输入以下代码：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run the app on the simulator or on the device. Press the home button
    (or *Command* + *Shift* + *H*) to move the app to the background and wait for
    an output. This might take a while, though.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。按下主页按钮（或*Command* + *Shift* + *H*）将应用程序移至后台并等待输出。但这可能需要一段时间。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIBackgroundModes` key with the `fetch` value enables the background fetch
    functionality for our app. Without setting it, the app will not wake up in the
    background.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`fetch`值的`UIBackgroundModes`键启用了我们应用程序的后台获取功能。如果不设置它，应用程序将不会在后台唤醒。
- en: 'After setting the key in `Info.plist`, we override the `PerformFetch` method
    in the `AppDelegate` class, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Info.plist`中设置键后，我们覆盖`AppDelegate`类中的`PerformFetch`方法，如下所示：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method is called whenever the system wakes up the app. Inside this method,
    we can connect to a server and retrieve the data we need. An important thing to
    note here is that we do not have to use iOS-specific APIs to connect to a server.
    In this example, a simple `HttpWebRequest` method is used to fetch the contents
    of this blog: [http://software.tavlikos.com](http://software.tavlikos.com).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统唤醒应用程序时，会调用此方法。在这个方法内部，我们可以连接到服务器并检索所需的数据。在这里需要注意的一个重要事项是，我们不需要使用iOS特定的API来连接到服务器。在这个例子中，使用了简单的`HttpWebRequest`方法来获取这个博客的内容：[http://software.tavlikos.com](http://software.tavlikos.com)。
- en: 'After we have received the data we need, we must call the callback that is
    passed to the method, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收到所需的数据后，我们必须调用传递给方法的事件处理程序，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to pass the result of the fetch. In this example, we pass `UIBackgroundFetchResult.NewData`
    if the update is successful and `UIBackgroundFetchResult.Failed` if an exception
    occurs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要传递获取的结果。在这个例子中，如果更新成功，我们传递`UIBackgroundFetchResult.NewData`；如果发生异常，我们传递`UIBackgroundFetchResult.Failed`。
- en: If we do not call the callback in the specified amount of time, the app will
    be terminated. Furthermore, it might get fewer opportunities to fetch the data
    in the future.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在指定的时间内调用回调，应用程序将被终止。此外，它可能在未来获取数据的次数更少。
- en: 'Lastly, to make sure that everything works correctly, we have to set the interval
    at which the app will be woken up, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了确保一切正常工作，我们必须设置应用程序将被唤醒的间隔，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The default interval is `UIApplication.BackgroundFetchIntervalNever`, so if
    we do not set an interval, the background fetch will never be triggered.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认间隔是`UIApplication.BackgroundFetchIntervalNever`，所以如果我们不设置间隔，后台获取永远不会被触发。
- en: There's more
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: Except for the functionality we added in this project, the background fetch
    is completely managed by the system. The interval we set is merely an indication
    and the only guarantee we have is that it will not be triggered sooner than the
    interval. In general, the system monitors the usage of all apps and will make
    sure to trigger the background fetch according to how often the apps are used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在本项目添加的功能外，后台获取完全由系统管理。我们设置的间隔只是一个指示，我们唯一能保证的是它不会早于间隔被触发。一般来说，系统会监控所有应用程序的使用情况，并确保根据应用程序的使用频率来触发后台获取。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from the predefined values, we can pass whatever value we want in seconds.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定义的值之外，我们可以传递我们想要的任何秒数值。
- en: UI updates
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI更新
- en: We can update the UI in the `PerformFetch` method. iOS allows this so that the
    app's screenshot is updated while the app is in the background. However, note
    that we need to keep UI updates to the absolute minimum.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`PerformFetch`方法中更新UI。iOS允许这样做，以便在应用程序处于后台时更新应用程序的截图。然而，请注意，我们需要将UI更新保持在绝对最小化。
- en: See also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Running code in the background* recipe
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景运行代码的配方
