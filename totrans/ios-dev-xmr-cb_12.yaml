- en: Chapter 12. Multitasking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting application states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving notifications for the application states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running code in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the iOS platform was introduced in 2007, it brought lots of exciting new
    features for users and drastically changed the concept of mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its huge success, it lacked some features at the time, which were considered
    *basic*. One of these features was multitasking, that is, support for running
    multiple processes at the same time. The platform actually did support multitasking
    to system processes internally, but it was not available to developers. Starting
    with iOS 4, Apple provided support for multitasking, although it is still quite
    different from what most developers are accustomed to.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to make use of the platform's multitasking
    features. We will see under what circumstances we can use these features and what
    functionality we can provide to the users of our apps through multitasking. Specifically,
    we will learn about an application's states and its runtime lifecycle. Through
    a series of detailed example projects, we will be able to execute code while an
    app is in the background, support audio playback, and receive data updates.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting application states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to detect the state of the application and
    respond accordingly when an application is transited from the active to the inactive
    state and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `AppStateApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method override to the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app either on the simulator or on the device. Press the
    home button (or press *Shift* + *Command* + *H* on the keyboard for the simulator)
    to suspend the app and watch the **Application Output** pad in Xamarin Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIApplicationDelegate` class contains methods that are triggered at specific
    notifications issued by the runtime. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnActivated`: This method is called when the app is made active, for example,
    when unlocking the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnResignActivation`: This method is called when the app is about to become
    inactive, for example, when the screen is locked or when an incoming call takes
    place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidEnterBackground`: This method is called when the app has entered the background,
    for example, when pressing the home button. At this time, the app is suspended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WillEnterForeground`: This method is called when the app is about to return
    to the foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that when the app is moved to the background, both the `OnResignActivation`
    and `DidEnterBackground` methods are called. Similarly, when the app is moved
    to the foreground, both the `WillEnterForeground` and `OnActivated` methods are
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these methods contain one parameter, which contains the `UIApplication`
    instance of the app. The `UIApplication` class contains the `ApplicationState`
    property, which returns the state of the app as values of the `UIApplicationState`
    property. These values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: This indicates that the app is active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inactive**: This indicates that the app is inactive, for example, when a
    notification alert is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background**: This indicates that the app is in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where iOS will kill your app, for example, when a memory warning
    is issued and your app does not free up resources. The `WillTerminate` method
    will be called in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Proper usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding methods are very useful because they allow us to save the current
    data that is presented to the user when the app changes its state. When the app
    is transited to an inactive or background state, each method is given a limited
    amount of time to execute, so we should make sure that it does not perform long-running
    operations, or else, iOS will kill the app.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving notifications for app states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to get notified when the application's state
    changes outside the scope of the `UIApplicationDelegate` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `NotifyStatesApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following fields in the `NotifyStatesAppViewController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewWillAppear` override, call the `AddNotificationObservers` method
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewWillDisappear` override, call the `RemoveNotificationObservers`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Press the home button (or press *Shift*
    + *Command* + *H*), and watch the output in the **Application Output** pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from calling the methods of the `UIApplicationDelegate` object for app
    states, iOS issues notifications that we can receive. This is very useful, because
    in most cases, we need to be notified when the app's state changes outside the
    scope of the `AppDelegate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we use the `NSNotificationCenter` method through the `UIApplication.Notifications`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example only adds notification observers for the transition between the
    background and foreground. We can add more notification observers through the
    other available `Observe*` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The result is similar to the example used in the previous recipe, but in this
    case, we get notified inside the scope of our view controller.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add notification observers when the app is activated or when it resigns activation,
    we use the `UIApplication.Notifications.ObserveDidBecomeActive` and `UIApplication.Notifications.ObserveWillResignActive`
    methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Removing notification observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we call `RemoveNotificaitonObservers` inside the `ViewWillAppear`
    method. However, the method is not being called when the app is transited to the
    background but only when we display another view controller.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Detecting application states* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running code in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to execute code in the background, taking
    full advantage of iOS's multitasking feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundCodeApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Press the home button (*Command* +
    *Shift* + *H*) to make the app enter the background and watch the **Application
    Output** pad. Before the background task is completed (1 minute), bring the app
    to the foreground by either tapping on its icon in the multitasking bar or on
    its icon on the home screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous tasks, we learned how to get informed when an app gets transited
    from the foreground to the background and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Multitasking on iOS is not quite what we are used to on other platforms. The
    iOS platform helps us makes sure that the foreground app will have all the available
    resources at its disposal (and the user's). To accomplish this, when the app enters
    the background, it is being suspended by the operating system. When it is suspended,
    it does not execute any code whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to prevent the app from being suspended when the user presses the
    home button, we can ask for background time. The time we ask for is limited to
    600 seconds (10 minutes), which is more than enough for the majority of tasks
    we are likely to perform in the background (for example, saving the UI state,
    completing a file download/upload, closing any open connections, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'To ask for the background time, we call the `BeginBackgroundTask` method of
    our `UIApplication` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The method accepts one parameter of the `NSAction` type and returns an integer,
    which corresponds to the task ID. The `NSAction` parameter represents the block
    of code that will be executed just before the background time elapses. Inside
    that block of code, we have to call the `EndBackgroundTask` method, passing the
    ID of the task that was started, which will inform the runtime that we no longer
    need the background time. Each call of `BeginBackgroundTask` should be followed
    by a call to `EndBackgroundTask`. If we do not call this method and the background
    time elapses, the app will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: After calling the `BeginBackgroundTask` method, we can execute the code we want.
    To allow the `DidEnterBackground` method to complete and to avoid blocking the
    main thread, we just enclose our code to either an asynchronous call or in a separate
    thread. In this example, we use a thread from `ThreadPool`. As this specific task
    will be completed before the time in which we have the elapses, we call the `EndBackgroundTask`
    method to let the system know that the job is done. The block of code that we
    passed to the `BeginBackgroundTask` method will not be executed as we ended the
    task.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases however, where the user might bring the app to the foreground
    while a background task is still running. To cover this scenario, we need to override
    the `WillEnterForeground` method and handle it in an appropriate manner. We can
    either stop the background task (by calling `EndBackgroundTask`), or provide some
    sort of feedback to the user that a task is still running. This scenario also
    makes the use of an asynchronous call to our code, which is the best practice.
    If the code of our background task is synchronous, then when the user brings the
    app to the foreground and the task is still running, the app will be frozen until
    the task is completed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To know how much time is left to perform the background tasks, we can check
    the value of the `BackgroundTimeRemaining` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Important considerations for the background code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the important points to be considered when you are working
    with the background code:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not update the UI while the app is in the background. Doing so may cause
    your app to terminate or crash. Any updates to UI elements that take place while
    the app is in the background are queued to be performed when it returns to the
    foreground. This will surely make the app unresponsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not inform the user to bring your app to the foreground just to give more
    time to the task. Doing so will surely get your app rejected from the app store's
    approval process. If a background task is in progress and the user brings the
    app to the foreground, moving the app back to the background again basically continues
    the remaining background time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform lightweight operations in the background to avoid the runtime from killing
    your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using external resources (for example, resources from the assets library).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Detecting application states* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to prevent the app from being suspended in
    order to allow audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundAudioApp`.
    Add a button on the view of the controller. You will also need an audio file.
    In this example, an M4A file with a duration of 21 seconds is used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `Info.plist` file to open it. Select the **Source** tab
    at the bottom and add the `UIBackgroundModes` key (**Required background modes**)
    with the string value audio. The following screenshot shows you how the key and
    value are shown in the editor after they have been set:![How to do it...](img/8924OT_12_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `MonoTouch.AVFoundation` namespace in the `BackgroundAudioAppViewController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following `ViewDidLoad` method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a sound file to the project and set its **Build Action** to **Content**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the device. Tap the **Play sound** button and press
    the home button to make the app enter the background. Notice that the sound continues
    playing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make sure that our app will be able to play the audio while it is in the
    background, we have to set the audio item in the `UIBackgroundModes` key in the
    `Info.plist` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we used the `AVAudioPlayer` class to play a sound file. Just
    creating an instance of the class and calling its `Play` method is not enough,
    though. We have to set a specific type for the audio session category. We will
    do this with the help of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The static `AVAudioSession.SharedInstance` method returns the current audio
    session object. The audio session category is set to `AVAudioSession.CategoryPlayback`,
    which allows the `AVAudioPlayer` class to play sounds while the app is in the
    background. This requirement is specific to objects in the `MonoTouch.AVFoundation`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the available audio session categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoryAmbient`: In this category, sounds are silenced when the device screen
    is locked or when the device''s silence switch is on. Sounds from external resources
    (such as the iPod app) are mixed with this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategorySoloAmbient`: This is the default category. Sounds from external resources
    are silenced with this category. Sounds are silenced when the screen is locked
    or when the device''s silent switch is on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategoryPlayback`: In this category, sounds are not silenced when the screen
    is locked or when the silent switch is on. Sounds from external resources are
    silenced but can be mixed if the `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers`
    property is set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategoryRecord`: This category is for recording audio. All the audio playback
    is silenced. The recording continues even when the screen is locked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategoryPlayAndRecord`: This category is for apps that need to record and
    play audio. Sounds from external resources are silenced but can be mixed if the
    `MonoTouch.AudioToolbox.AudioSession.OverrideCategoryMixWithOthers` property is
    set to `tru`e. Sounds continue to play when the screen is locked or when the silent
    switch is on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CategoryAudioProcessing`: This category is specific to processing audio. Sound
    playback and recording is disabled in this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background state for audio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even when the app is configured through the `Info.plist` file to support the
    background audio playback, the app will be suspended when the playback is completed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Location services in the background* recipe in [Chapter 10](ch10.html "Chapter 10. Location
    Services and Maps"), *Location Services and Maps*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make use of iOS 7's **background fetch**
    feature. This feature automatically wakes up the app at system-managed intervals,
    giving it a specific amount of time to retrieve data and update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundFetchApp`.
    Add a label to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need access to the label from outside of the scope of the `BackgroundFetchAppViewController`
    class, so create a public property for it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `Info.plist` file and under the **Source** tab, add the `UIBackgroundModes`
    key (**Required background modes**) with the string value, `fetch`. The following
    screenshot shows you the editor after it has been set:![How to do it...](img/8924OT_12_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `FinishedLaunching` method of the `AppDelegate` class, enter the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code, again, in the `AppDelegate` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator or on the device. Press the home button
    (or *Command* + *Shift* + *H*) to move the app to the background and wait for
    an output. This might take a while, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIBackgroundModes` key with the `fetch` value enables the background fetch
    functionality for our app. Without setting it, the app will not wake up in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the key in `Info.plist`, we override the `PerformFetch` method
    in the `AppDelegate` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called whenever the system wakes up the app. Inside this method,
    we can connect to a server and retrieve the data we need. An important thing to
    note here is that we do not have to use iOS-specific APIs to connect to a server.
    In this example, a simple `HttpWebRequest` method is used to fetch the contents
    of this blog: [http://software.tavlikos.com](http://software.tavlikos.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have received the data we need, we must call the callback that is
    passed to the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We also need to pass the result of the fetch. In this example, we pass `UIBackgroundFetchResult.NewData`
    if the update is successful and `UIBackgroundFetchResult.Failed` if an exception
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not call the callback in the specified amount of time, the app will
    be terminated. Furthermore, it might get fewer opportunities to fetch the data
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to make sure that everything works correctly, we have to set the interval
    at which the app will be woken up, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The default interval is `UIApplication.BackgroundFetchIntervalNever`, so if
    we do not set an interval, the background fetch will never be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Except for the functionality we added in this project, the background fetch
    is completely managed by the system. The interval we set is merely an indication
    and the only guarantee we have is that it will not be triggered sooner than the
    interval. In general, the system monitors the usage of all apps and will make
    sure to trigger the background fetch according to how often the apps are used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the predefined values, we can pass whatever value we want in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: UI updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can update the UI in the `PerformFetch` method. iOS allows this so that the
    app's screenshot is updated while the app is in the background. However, note
    that we need to keep UI updates to the absolute minimum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running code in the background* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
