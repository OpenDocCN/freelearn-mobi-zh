<html><head></head><body>
		<div><h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor317"/>Chapter 11</em>: Creating Infinite Lists with Jetpack Paging and Kotlin Flow</h1>
			<p>In the previous chapters, we built the great Restaurants App that displayed content from our own backend. However, the number of restaurants displayed in the Restaurants App was fixed, and the user was only able to browse through the few restaurants that we added to our Firebase database.</p>
			<p>In this chapter, we will understand how pagination can help us display large datasets of items without putting pressure on our backend and without huge network bandwidth consumption. We will create the impression of an infinite list of items inside a new app that we will be working on called the Repositories App, and we will achieve<a id="_idIndexMarker855"/> that with the help of yet<a id="_idIndexMarker856"/> another Jetpack library called <strong class="bold">Paging</strong>.</p>
			<p>In the first section, <em class="italic">Why do we need pagination?</em>, we will explore what data pagination is and how it can help us break large datasets into pages of data, thereby optimizing the communication between our app and the backend server. Up next, in the <em class="italic">Importing and exploring the Repositories App</em> section, we will explore a project in which we will integrate pagination: the Repositories App that displays information about GitHub repositories.</p>
			<p>Then, in the <em class="italic">Using Kotlin Flow to handle streams of data</em> section, we will cover how paginated content can be expressed as a data stream and how Kotlin Flow is a great solution to handle such content. In the last section, <em class="italic">Exploring pagination with Jetpack Paging</em>, we will first explore the Jetpack Paging library as a solution to working with paginated content in our Android app, and then, with the help of this new library, we will integrate paging in our Repositories App to create the illusion of an infinite list of repositories.</p>
			<p>To summarize, in this chapter, we will be covering the following sections:</p>
			<ul>
				<li>Why do we need pagination?</li>
				<li>Importing and exploring the Repositories App</li>
				<li>Using Kotlin Flow to handle streams of data</li>
				<li>Exploring pagination with Jetpack Paging</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The existing Repositories App from the GitHub repository of the book</li>
			</ul>
			<p>The starting point for this chapter is represented by the Repositories App that you can find by navigating to the <code>Chapter_11</code> directory of the GitHub repository of the book, and then by importing the <code>repositories_app_starting_point_ch11</code> directory from within Android Studio. Don't worry, as we will do this together later in this chapter.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_11</code> directory and then import the <code>repositories_app_solution_ch11</code> directory from within Android Studio.</p>
			<p>You can find the <code>Chapter_11</code> directory by following this link:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11</a></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor319"/>Why do we need pagination?</h1>
			<p>Let's say we have an Android application<a id="_idIndexMarker857"/> that allows you to explore GitHub repositories by displaying<a id="_idIndexMarker858"/> a list of projects. It does<a id="_idIndexMarker859"/> that by querying the GitHub <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) with Retrofit and obtaining a fixed number of repositories inside the app. While the REST API serves the application with detailed information for each repository, the app only uses and displays the title and description of the repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don't confuse the Repository classes in our project architecture that abstract data logic with the GitHub repositories that are displayed in our Repositories App.</p>
			<p>Now, let's imagine<a id="_idIndexMarker860"/> that this application retrieves and displays 20 repository elements. Because of this, the user will be able to scroll the content until the 20th element, and therefore will be able to visualize no more than 20 elements.</p>
			<p>But what if we wanted to allow the user to explore more repositories inside our list? In the end, the purpose of the app is to browse a larger number of repositories and not just 20.</p>
			<p>We could update the network call and request a larger list of elements from one single shot. In other words, we could refactor our app to obtain and display a list of 10,000 repositories on one occasion—that is, when the app is launched.</p>
			<p>However, with such an approach, we can think of three main issues, as outlined here:</p>
			<ul>
				<li><code>LazyColumn</code> composable to render UI elements in a lazy manner (when needed), so we can conclude that this issue can be easily fixed.</li>
				<li><strong class="bold">The app would put a lot of pressure on the backend</strong>—Imagine what would happen if every Android application client requested 10,000 database records from the backend server—these services would have to consume quite some resources to query and return so many elements.</li>
				<li>Such a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request and response would cause a high network<a id="_idIndexMarker861"/> bandwidth consumption caused by the huge <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) payload that would have to be transferred. All 10,000 elements<a id="_idIndexMarker862"/> could contain a lot of fields and nested information—it's clear that having such a payload sent around between our apps and the server would be highly inefficient.</li>
			</ul>
			<p>While we can easily address the first issue, we can conclude that the second and third issues are very concerning. Many real-world applications<a id="_idIndexMarker863"/> and systems face these problems, and in order to alleviate them, the concept of pagination was adopted for most client-server communication-based relationships where large datasets had to be displayed to the end user.</p>
			<p><strong class="bold">Pagination</strong> is a server-friendly communication approach that breaks a huge result into multiple smaller chunks. In other words, if your backend supports pagination, your application can request<a id="_idIndexMarker864"/> only a portion of data (often called a <strong class="bold">page</strong>) and receive a partial response, thereby allowing the transfer to be faster and more efficient on both sides.</p>
			<p>When the application needs more results, it just requests another page, and another page, and so on. This approach is beneficial both for the app and backend service since only small portions of data are served and interpreted at a certain moment in time.</p>
			<p>With pagination, if the user decides to visualize only a small portion of items and then switch to another app, your app would have requested only this small portion of data. Without pagination, in the same case, your backend would have served your app with the entire collection of items, while some of your users wouldn't have had a chance to see all of them. This would be a waste of resources from the perspective of your app, but especially from the perspective of your backend service. Also, only a small portion out of the huge payload sent over the internet was needed.</p>
			<p>To implement such a pagination behavior on the UI, there are two well-known UI approaches for mobile apps, as follows:</p>
			<ul>
				<li>A fixed number of items are displayed on a screen that resembles a web page. On this page, there is a fixed amount of scrolling space because if the user wants to see new items, a button must be pressed to switch pages (often representing the number of a specific page), and then a new set of data is loaded and displayed, replacing the existing content.</li>
			</ul>
			<p>From a mobile <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) perspective, this is a poor design choice because, as opposed<a id="_idIndexMarker865"/> to monitor screens used for web pages, scrolling over contents is more natural on smaller-sized devices such as phones.</p>
			<ul>
				<li>The list of items displayed grows as the user scrolls, thereby creating the impression that the list is infinite—such an approach<a id="_idIndexMarker866"/> is often referred to as infinite scrolling. While there is no such thing as an infinite list, this approach mimics one. It starts with a few requests for the initial page/s, and as the user scrolls to see more elements, it requests more pages with more content on the fly. This approach relies heavily on scrolling and usually creates a better UX.</li>
			</ul>
			<p>In this chapter, we will go for the second<a id="_idIndexMarker867"/> option—in other words, we will implement paging in an attempt to mimic the infinite list effect. Let's also try to visualize how the app could request more items as the user scrolls in the following simplified example, where <strong class="bold">Page 1</strong> contains only six elements:</p>
			<div><div><img src="img/B17788_11_01.jpg" alt="Figure 11.1 – Observing how infinite lists can be achieved with pagination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Observing how infinite lists can be achieved with pagination</p>
			<p>For the app to request the second page with items, the users must scroll further down, thereby informing the app about their intention of wanting to see more elements.</p>
			<p>When the app catches on to this intention (because the user reached the end of the list), it asks for the second page with items from the backend, making the list of repositories grow and allowing<a id="_idIndexMarker868"/> the user to browse through the new content. This process repeats on and on, as the user keeps on reaching the end of the list.</p>
			<p>Before implementing this pagination approach, let's first get to know our starting point—the GitHub Repositories App!</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor320"/>Importing and exploring the Repositories App</h1>
			<p>The Repositories App project<a id="_idIndexMarker869"/> is a simple application that displays a list of repositories obtained<a id="_idIndexMarker870"/> from the GitHub Search API. This project is a simplified version of a Compose-based application that incorporates only a few concepts from the previous chapters as it tries to be a good candidate for implementing pagination with the Jetpack Paging library rather than being a fully-fledged sample app that applies all the concepts taught in the book.</p>
			<p>Nevertheless, we will see how<a id="_idIndexMarker871"/> the Repositories App follows a <code>ViewModel</code> class to hold state and present data, coroutines for the <strong class="bold">asynchronous</strong> (<strong class="bold">async</strong>) operation of obtaining data<a id="_idIndexMarker872"/> from the server, and Compose for the UI layer.</p>
			<p>Let's start off by importing this project into Android Studio, as follows:</p>
			<ol>
				<li>Navigate to the GitHub repository page of the book, located at <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin</a>.</li>
				<li>Download the repository files. You can do that by pressing the <strong class="bold">Code</strong> button and then by selecting <strong class="bold">Download zip</strong>.</li>
				<li>Unzip the downloaded files and remember the location where you did this.</li>
				<li>Open Android Studio, press on the <strong class="bold">File</strong> tab option, and then select <strong class="bold">Open</strong>.</li>
				<li>Search for the directory where you unzipped the project files. Once you have found it, navigate to the <code>Chapter_11</code> directory, select the <code>repositories_app_starting_point_ch11</code> directory, and press <strong class="bold">Open</strong>.</li>
				<li>Run the application on your test device.</li>
			</ol>
			<p>You should notice that our Repositories App displays a list of repositories, and the index of each repository item from the list is displayed on the left side, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B17788_11_02.jpg" alt="Figure 11.2 – Observing the Repositories App without pagination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Observing the Repositories App without pagination</p>
			<p>If you scroll further down, you will notice<a id="_idIndexMarker873"/> that only 20 elements can be viewed. This means that our app<a id="_idIndexMarker874"/> doesn't support paging and the user can only browse through 20 repositories.</p>
			<p>If we have a look inside the <code>RepositoriesApiService.kt</code> file, we will notice that our app instructs the REST API through the <code>@GET()</code> endpoint <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) to obtain the first page<a id="_idIndexMarker875"/> of repositories while fetching only 20 items per page, as illustrated in the following code snippet:</p>
			<pre>interface RepositoriesApiService {
   @GET("repositories?q=mobile&amp;sort=stars&amp;page=1&amp;per_page=20")
   suspend fun getRepositories(): RepositoriesResponse
}</pre>
			<p>If you have a look at the parameters hardcoded within the request, you will notice that our app always requests the first page of repositories. Also, because it can specify the page number, this clearly means that the backend we're accessing supports pagination, but because we always ask for page <code>1</code>, our app doesn't take advantage of it.</p>
			<p>More specifically, when the app<a id="_idIndexMarker876"/> performs this request, it will always retrieve 20 records from the backend <a id="_idIndexMarker877"/>from the page with index <code>1</code>. Later in this chapter, we will learn how to make multiple network calls requesting different page numbers, therefore adopting pagination.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're looking to build an app that supports pagination, you must first make sure that your backend supports pagination, just as the GitHub Search API does. Remember that the whole purpose of pagination is to ease the workload of the backend API and to minimize the network bandwidth consumption associated with retrieving a huge JSON payload, so if your backend doesn't support pagination, you can't implement pagination in your app.</p>
			<p>Let's have a brief look over the response we receive from the GitHub API by navigating to the <code>Repository.kt</code> file. Basically, we get a list of <code>Repository</code> objects, and we parse the <code>id</code>, <code>name</code>, and <code>description</code> values of the repository, as illustrated in the following code snippet:</p>
			<pre>data class RepositoriesResponse(
    @SerializedName("items") val repos: List&lt;Repository&gt;
)
data class Repository(
    @SerializedName("id")
    val id: String,
    @SerializedName("full_name")
    val name: String,
    @SerializedName("description")
    val description: String)</pre>
			<p>As mentioned before, our app makes use of the GitHub Search API, and this can be better observed inside the <code>DependencyContainer.kt</code> class where the Retrofit <code>RepositoriesApiService</code> dependency is manually<a id="_idIndexMarker878"/> constructed, and the base URL of this API is passed. You can view<a id="_idIndexMarker879"/> the code for this process in the following snippet:</p>
			<pre>object DependencyContainer {
    val repositoriesRetrofitClient: RepositoriesApiService =         
        Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl("https://api.github.com/search/")
            .build().create(RepositoriesApiService::class.java)
}</pre>
			<p>If you're looking to find out more about the API we're using in this chapter, head over to the official documentation<a id="_idIndexMarker880"/> of the GitHub Search API, at <a href="https://docs.github.com/en/rest/search#search-repositories">https://docs.github.com/en/rest/search#search-repositories</a>.</p>
			<p>Now, going back to our Repositories App, if we navigate to the <code>RepositoriesViewModel.kt</code> file, we will see that our <code>ViewModel</code> class uses the <code>RepositoriesApiService</code> dependency to obtain a list of repositories by launching a coroutine and setting the result to a Compose <code>State</code> object holding a list of <code>Repository</code> objects. The code is illustrated in the following snippet:</p>
			<pre>class RepositoriesViewModel(
    private val restInterface: RepositoriesApiService
    = DependencyContainer.repositoriesRetrofitClient
) : ViewModel() {
    val repositories = mutableStateOf(emptyList&lt;Repository&gt;())
    init {
        viewModelScope.launch {
            repositories.value =
                restInterface.getRepositories().repos
        }
    }
}</pre>
			<p>The approach of having a Jetpack ViewModel launch a coroutine to obtain data with the help of Retrofit is very similar to what we've done in the Restaurants App.</p>
			<p>The UI level is also similar<a id="_idIndexMarker881"/> to the Restaurants App. If we navigate to the <code>MainActivity.kt</code> file, we can see that our <code>Activity</code> class creates a <code>ViewModel</code> instance, retrieves a Compose <code>State</code> object, obtains its value of type <code>List&lt;Repository&gt;</code>, and passes it to a composable function<a id="_idIndexMarker882"/> to consume it, as illustrated in the following code snippet:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                val viewModel: RepositoriesViewModel = 
                    viewModel()
                val repos = viewModel.repositories.value
                RepositoriesScreen(repos)
            }
        }
    }
}</pre>
			<p>The composable function that consumes the list of <code>Repository</code> objects resides inside the <code>RepositoriesScreen.kt</code> file, as illustrated in the following code snippet:</p>
			<pre>@Composable
fun RepositoriesScreen(repos: List&lt;Repository&gt;) {
    LazyColumn(
        contentPadding = PaddingValues(
            vertical = 8.dp,
            horizontal = 8.dp)
    ) {
        itemsIndexed(repos) { index, repo -&gt;
            RepositoryItem(index, repo) 
        }
    }
}</pre>
			<p>Just as in the Restaurants App, our screen-level composable uses the <code>LazyColumn</code> composable<a id="_idIndexMarker883"/> to optimize the way the UI renders<a id="_idIndexMarker884"/> elements in the list.</p>
			<p><code>LazyColumn</code> usage is important for our use case of trying to implement pagination because we don't want our UI to render thousands of UI elements. Luckily, as we know already, <code>LazyColumn</code> has us covered because it only composes and lays out visible elements on the screen.</p>
			<p>Now, you might have noticed that the <code>RepositoriesScreen</code> composable uses the <code>itemsIndexed()</code> <code>items()</code> function that we used<a id="_idIndexMarker885"/> in the Restaurants App. This is because, since our app will support pagination, we want to paint the index of the element displayed on the screen to better understand where we are at right now. To get the index of the composable item visible on the screen, the <code>itemsIndexed()</code> function provides us with this information out of the box.</p>
			<p>Finally, let's have a brief look over the structure of the <code>RepositoryItem</code> composable that displays the contents of a <code>Repository</code> object, while also rendering the index of the repository, as follows:</p>
			<pre>@Composable
fun RepositoryItem(index: Int, item: Repository) {
    Card(
        elevation = 4.dp,
        modifier = Modifier.padding(8.dp).height(120.dp)
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.padding(8.dp)
        ) {
            Text(
                text = index.toString(),
                style = MaterialTheme.typography.h6,
                modifier = Modifier
                    .weight(0.2f)
                    .padding(8.dp))
            Column(modifier = Modifier.weight(0.8f)) {
                Text(
                    text = item.name,
                    style = MaterialTheme.typography.h6)
                Text(
                    text = item.description,
                    style = MaterialTheme.typography.body2,
                    overflow = TextOverflow.Ellipsis,
                    maxLines = 3)
            }
        }
    }
}</pre>
			<p>Now that we have briefly covered the current state of the Repositories App, we can conclude that it could really use pagination<a id="_idIndexMarker886"/> to show more repositories, especially when the GitHub Search API<a id="_idIndexMarker887"/> supports that. It's time to cover another important aspect that pagination forces us to be aware of, and that's the concept of streams of data.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor321"/>Using Kotlin Flow to handle streams of data</h1>
			<p>If we want our app to support pagination<a id="_idIndexMarker888"/> in the form of an infinite list, it's clear that our existing approach<a id="_idIndexMarker889"/> of having a single one-shot request to the backend that results in one UI update will not suffice.</p>
			<p>Let's first have a look in the following code snippet at how our <code>RepositoriesViewModel</code> class requests data:</p>
			<pre>class RepositoriesViewModel(
    private val restInterface: RepositoriesApiService =  [...]
) : ViewModel() {
    val repositories = mutableStateOf(emptyList&lt;Repository&gt;())
    init {
        viewModelScope.launch {
            <strong class="bold">repositories.value =</strong>
<strong class="bold">                restInterface.getRepositories().repos</strong>
        }
    }
}</pre>
			<p>When the <code>ViewModel</code> is initialized, it executes the <code>getRepositories()</code> suspending function inside a coroutine. The suspending function returns a list of <code>Repository</code> objects that is passed to the <code>repositories</code> variable. This means that our <code>ViewModel</code> performs a one-shot request for data<a id="_idIndexMarker890"/> in the form of a one-time call to the suspending<a id="_idIndexMarker891"/> function—no other request is done over time to get new repositories as the user scrolls through the list. That's why our app receives a single event with data (an initial list of objects) from the backend as a single result.</p>
			<p>We can imagine that calling a similar <code>getRepositories()</code> suspending function with the one in our app would just as well return a one-time response as its return type would be <code>List&lt;Repository&gt;</code>, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B17788_11_03.jpg" alt="Figure 11.3 – Observing one-shot data result with suspending function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Observing one-shot data result with suspending function</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While our <code>ViewModel</code> contains a <code>repositories</code> variable whose type is <code>MutableState</code>, meaning that it can change its value over time, we aren't going to use Compose <code>State</code> objects to observe changes coming from the data layer as this would break the responsibilities of layers. Right now, in our code, we are calling a suspending function that returns only one result or one set of data asynchronously. This result is passed to the <code>repositories</code> variable, so even though our UI state can change over time, it only receives one update.</p>
			<p>To support an infinite list, we must somehow design our app to receive multiple results over time, just as with a stream of data. In other words, our app must request new <code>Repository</code> objects as the user scrolls, thereby receiving multiple events with data, and not just one. With every new data event coming in, our app should get a new list of <code>Repository</code> objects that now contains the newly received repositories as well.</p>
			<p>To make our <code>ViewModel</code> receive multiple events of data in the form of a stream of data, we can use Flow. Kotlin <strong class="bold">Flow</strong> is a data type built on top of coroutines that exposes a stream of multiple, asynchronously computed values.</p>
			<p>As opposed to suspending<a id="_idIndexMarker892"/> functions, which emit a single result, Flow<a id="_idIndexMarker893"/> allows us to emit multiple values sequentially over time. However, just as a suspending function emits a result in an asynchronous manner that you can later obtain from within a coroutine, Flow also emits results asynchronously, so you must observe its results from within a launched coroutine.</p>
			<p>You could use Flow to listen for events coming from various sources; for example, you could use Flow to get location updates every time the location of the user changes. Or, you could use Flow to get sequential updates from your Room database—instead of manually querying the database every time you insert or update items, you can tell Room to return a flow that will emit updates with its most up-to-date content whenever you perform insertions, updates, and so on.</p>
			<p>Getting back to our example with repositories, let's imagine that our <code>getRepositories()</code> function is no longer a suspending function, but instead returns a flow whose contained data is of type <code>List&lt;Repository&gt;</code>, as illustrated in the following screenshot:</p>
			<div><div><img src="img/B17788_11_04.jpg" alt="Figure 11.4 – Observing multiple results over time with Kotlin Flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Observing multiple results over time with Kotlin Flow</p>
			<p>Just as the Compose <code>State</code> object holds data of a certain type (for example, <code>State&lt;Int&gt;</code> emits values of type <code>Int</code>), Flow also holds data of a certain type; in our previous example, that type was the data we're interested in emitting—that is, <code>List&lt;Repository&gt;</code>.</p>
			<p>But how can we observe the emitted values of a flow?</p>
			<p>Let's take the previous<a id="_idIndexMarker894"/> example where the <code>getRepositories()</code> method returned a <code>Flow&lt;List&lt;Repository&gt;&gt;</code> instance, and let's imagine<a id="_idIndexMarker895"/> that we're trying to observe its values in a UI component, as follows:</p>
			<pre>class SomeViewModel(…) : ViewModel() {
    init {
        viewModelScope.launch {
            getRepositories().collect { repos -&gt;
                // Update UI
            }
        }
    }
    […]
}</pre>
			<p>Since a flow emits values asynchronously, we obtained the <code>Flow&lt;List&lt;Repository&gt;&gt;</code> instance inside a launched coroutine and then called the <code>.collect()</code> method, which in turn provided us with a block of code where we can consume the <code>List&lt;Repository&gt;</code> values.</p>
			<p>As opposed to obtaining such a list from a suspending function call, it's important to remember that the values emitted by the flow change (or, at least, should change) over time. In other words, for every callback that provides us with a value stored in the <code>repos</code> variable, the content of its value of type <code>List&lt;Repository&gt;</code> could be different, allowing us to update the UI on every new emission.</p>
			<p>In this section, we have explored what a flow is and how we can consume it. However, Kotlin Flow is a very complex subject; for example, we aren't going to cover the manner in which you can create a flow, or how you can modify the produced stream. If you're looking to find out more about Flow, check the official<a id="_idIndexMarker896"/> Android documentation at <a href="https://developer.android.com/kotlin/flow">https://developer.android.com/kotlin/flow</a>.</p>
			<p>Let's now explore<a id="_idIndexMarker897"/> the last missing piece<a id="_idIndexMarker898"/> of the puzzle—the Paging library.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor322"/>Exploring pagination with Jetpack Paging</h1>
			<p>To implement an infinite<a id="_idIndexMarker899"/> list of repositories in our Repositories App, we must find<a id="_idIndexMarker900"/> a way to request more repositories as the user scrolls through the existing list and reaches its bottom, thereby adding new elements on the fly. Instead of manually deciding when the user is approaching the bottom of the current list of repositories and then triggering a network request to get new items, we can use the Jetpack Paging library, which hides all this complexity from us.</p>
			<p><strong class="bold">Jetpack Paging</strong> is a library that helps us load<a id="_idIndexMarker901"/> and display pages of data from a large set of data, either through network requests or from our local data storage, thereby allowing us to save network bandwidth and optimize the usage of system resources.</p>
			<p>In this chapter, for simplicity, we will use the Paging library to display an infinite list of repositories obtained from a network source (that is, the GitHub Search API), without involving the local cache.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jetpack Paging library is now at its third implementation iteration, which is often referred<a id="_idIndexMarker902"/> to as Paging 3 or Paging v3. In this<a id="_idIndexMarker903"/> chapter, we will be using this latest version, so even though we will simply call it Jetpack Paging, we are<a id="_idIndexMarker904"/> in fact referring to Jetpack Paging 3.</p>
			<p>The Jetpack Paging library abstracts most of the complexity associated with requesting the correct page at the correct time, depending on the scroll position of the user. Practically, it brings a lot of benefits to the table, such as the following:</p>
			<ul>
				<li>Avoidance of data request duplication—your app will request data only when needed; for example, when the user reaches the end of the list and more items must be rendered.</li>
				<li>Paged data is cached in memory out of the box. During the lifetime of the app process, once a page was loaded, your app will never request it again. If you cache the paginated data in a local database, then your application will not need to request a specific page for cases such as after an app restart.</li>
				<li>Paginated data is exposed as a data stream of the type that fits your need: Kotlin Flow, LiveData, or RxJava. As you might have guessed, we will use Flow.</li>
				<li>Out-of-the-box support for View System or Compose-based UI components that request data automatically when the user scrolls toward the end of the list. With such support, we don't have to know when to request new pages with data as the UI layer will trigger that for us out of the box.</li>
				<li>Retry and refresh capabilities triggered directly by the UI components.</li>
			</ul>
			<p>Before moving to the actual integration<a id="_idIndexMarker905"/> of the Paging library, let's spend a bit of time looking <a id="_idIndexMarker906"/>over the main components part of the Paging API. To ensure paging in your application with the Jetpack Paging API, you must use the following:</p>
			<ul>
				<li>A <code>PagingSource</code> component—Defines the source of data for the paginated content. This object decides which page to request and loads it from your remote or local data source. If you're looking to have both a local and remote data source for your paginated content, you could use the built-in <code>RemoteMediator</code> API of the Paging library. Check out the <em class="italic">Further reading</em> section for more information on this.</li>
				<li>A <code>Pager</code> component—Based on the defined <code>PagingSource</code> component, you can construct a <code>Pager</code> object that will expose a stream of <code>PagingData</code> objects. You can configure the <code>Pager</code> object by passing a <code>PagingConfig</code> object to its constructor and specifying the page size of your data, for example.</li>
			</ul>
			<p>The <code>PagingData</code> class is a wrapper over your paginated data containing a set of items part of the corresponding page. The <code>PagingData</code> object is responsible for triggering a query for a new page with items that is then forwarded to the <code>PagingSource</code> component.</p>
			<ul>
				<li>A dedicated UI component<a id="_idIndexMarker907"/> that supports pagination—To consume<a id="_idIndexMarker908"/> the stream of paginated content, your UI must make use of dedicated UI components that can handle paginated data. If your UI is based on the traditional View System, you could use the <code>PagingDataAdapter</code> component. Since our UI layer is based on Compose, <code>LazyColumn</code> has us covered as it knows how to consume paginated data (more on that in the next section).</li>
			</ul>
			<p>To get a visual understanding of how all these components should fit, let's take the following example of a possible implementation of the Paging library inside our Repositories App:</p>
			<div><div><img src="img/B17788_11_05.jpg" alt="Figure 11.5 – Observing how Paging library APIs can be used in the Repositories App&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Observing how Paging library APIs can be used in the Repositories App</p>
			<p>At the UI level, our composable collects a flow that contains a stream of <code>PagingData&lt;Repository&gt;</code> objects. The <code>PagingData</code> object contains a list of <code>Repository</code> objects, and behind the scenes, it's responsible for forwarding requests for new pages to <code>PagingSource</code>, which in turn asks for new items from our REST API.</p>
			<p>Inside <code>ViewModel</code>, we will have a <code>Pager</code> object that will use an instance of <code>PagingSource</code>. We will define a <code>PagingSource</code> object so that it knows which page to ask for and where to ask for it—that is, the GitHub Search API.</p>
			<p>Now that we have covered the theoretical aspects of our pagination integration with Jetpack Paging, let's see which practical tasks we will be working on in this section. We will be doing the following:</p>
			<ul>
				<li>Implementing pagination with Jetpack Paging</li>
				<li>Implementing<a id="_idIndexMarker909"/> loading and error states plus retry<a id="_idIndexMarker910"/> functionality</li>
			</ul>
			<p>Let's proceed with the first task: integrating pagination in our Repositories App.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor323"/>Implementing pagination with Jetpack Paging</h2>
			<p>In this section, we will integrate paging<a id="_idIndexMarker911"/> in our Repositories App and create an infinite<a id="_idIndexMarker912"/> list of repositories with the help of Jetpack Paging. To achieve that, we will implement and add all the components described in the previous section.</p>
			<p>Let's get cracking! Proceed as follows:</p>
			<ol>
				<li value="1">First, inside the app-level <code>build.gradle</code> file, in the <code>dependencies</code> block, add the Compose Gradle dependency for Jetpack Paging, as follows:<pre>dependencies {
    […]
<strong class="bold">    implementation "androidx.paging:</strong>
<strong class="bold">        paging-compose:1.0.0-alpha14"</strong>
}</pre></li>
			</ol>
			<p>After updating the <code>build.gradle</code> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Next up, let's refactor our Retrofit <code>RepositoriesApiService</code> interface by removing the hardcoded page index of <code>1</code> within the <code>@GET()</code> request annotation, and by adding a query <code>page</code> parameter of type <code>Int</code> representing the page index we're looking to acquire. The code is illustrated in the following snippet:<pre>interface RepositoriesApiService {
    @GET("<strong class="bold">repositories?q=mobile&amp;sort=stars&amp;per_page=20</strong>")
    suspend fun getRepositories(<strong class="bold">@Query("page") page:Int</strong>): 
        RepositoriesResponse
}</pre></li>
			</ol>
			<p>Before these changes, we were always obtaining the first page of repository results. Now, we have updated<a id="_idIndexMarker913"/> our network request to harvest the power <a id="_idIndexMarker914"/>of paginated REST APIs—that is, the capability to ask for a different page index based on the scrolling position of the user. </p>
			<p>To achieve this, we used the Retrofit <code>@Query()</code> annotation, which basically will insert the value of the <code>page</code> parameter we have defined in the <code>getRepositories()</code> method into the <code>GET</code> request. As the GitHub Search API expects a <code>"page"</code> query key in the URL request, we have passed the <code>"page"</code> key to the <code>@Query()</code> annotation.</p>
			<ol>
				<li value="3">It's now time to build a <code>PagingSource</code> component that will request new pages through our <code>RepositoriesApiService</code> dependency and will keep track of which page to ask for, while also keeping an in-memory cache of the previously retrieved pages.</li>
			</ol>
			<p>Inside the root package of the app, create a new class named <code>RepositoriesPagingSource</code> and paste the following code below it:</p>
			<pre>class RepositoriesPagingSource(
    private val restInterface: RepositoriesApiService
    = DependencyContainer.repositoriesRetrofitClient,
) : PagingSource&lt;Int, Repository&gt;() {
    override suspend fun load(params: LoadParams&lt;Int&gt;)
            : LoadResult&lt;Int, Repository&gt; {
    }
    override fun getRefreshKey(
        state: PagingState&lt;Int, Repository&gt;,
    ): Int? {
        return null
    }
}</pre>
			<p>Let's break down<a id="_idIndexMarker915"/> the code we have just added. This component<a id="_idIndexMarker916"/> is doing the following:</p>
			<ul>
				<li>It is in charge of requesting new pages, so it has a dependency on <code>RepositoriesApiService</code> as the <code>restInterface</code> constructor field.</li>
				<li>It is a <code>PagingSource</code> component, so it inherits from the <code>PagingSource</code> class while also defining the following:</li>
			</ul>
			<ul>
				<li>A key as the type of the page index—in our case, the GitHub Search API requires an integer representing the index of the page, so we set the key as <code>Int</code>.</li>
				<li>Type of the loaded data—in our case, <code>Repository</code> objects.<ul><li>Implementing the following two mandatory functions:</li></ul></li>
				<li>The <code>load()</code> suspending function, which is called automatically by the Paging library and should fetch more items asynchronously. This method takes in a <code>LoadParams</code> object that keeps track of information such as what is the key (index) of the page that must be requested, or the initial load size of items. Also, this method returns a <code>LoadResult</code> object indicating if a specific query result was successful or has failed.</li>
				<li>The <code>getRefreshKey()</code> function, which is called to obtain and return the most recent page key in case of a refresh event so that the user is returned to the latest known page (and not the first one). A refresh event can come from a variety of sources, such as a manual UI refresh triggered by the user, a database cache invalidation event, system events, and so on.</li>
			</ul>
			<p>For simplicity, and also because we will not implement refresh capabilities, we will skip implementing the <code>getRefreshKey()</code> method, so we just returned <code>null</code> inside the body of this method. However, if you're looking to also support such behavior, check out the <em class="italic">Further reading</em> section where additional resources are listed to help you provide an implementation for this method.</p>
			<ol>
				<li value="4">Now that we have covered the purpose of the two mandatory methods, let's implement the one we're really interested in—the <code>load()</code> function.</li>
			</ol>
			<p>This method should return a <code>LoadResult</code> object, so first, add a <code>try</code>-<code>catch</code> block, and inside the <code>catch</code> block, return an <code>Error()</code> instance of <code>LoadResult</code> by passing the <code>Exception</code> object that was caught, as illustrated in the following code snippet:</p>
			<pre>class RepositoriesPagingSource(…) : […] {
    override suspend fun load(params: LoadParams&lt;Int&gt;)
    : LoadResult&lt;Int, Repository&gt; {
<strong class="bold">        try {</strong>
<strong class="bold">        } catch (e: Exception) {</strong>
<strong class="bold">            return LoadResult.Error(e)</strong>
<strong class="bold">        }</strong>
    }
    override fun getRefreshKey(…): Int? { … }
}</pre>
			<p>With this approach, if the request for a new page fails, we let the Paging library know<a id="_idIndexMarker917"/> that an error event occurred<a id="_idIndexMarker918"/> by returning the <code>LoadResult.Error</code> object.</p>
			<ol>
				<li value="5">Next up, inside the <code>try</code> block, we must first obtain and store the next page we're interested in. Store the index of the next page inside the <code>nextPage</code> variable, as follows:<pre>class RepositoriesPagingSource(…) : […] {
    override suspend fun load(params: LoadParams&lt;Int&gt;)
    : LoadResult&lt;Int, Repository&gt; {
        try {
<strong class="bold">            val nextPage = params.key ?: 1</strong>
        } catch (e: Exception) {
            return LoadResult.Error(e) 
        }
    }
    override fun getRefreshKey(…): Int? { … }
}</pre></li>
			</ol>
			<p>We obtained the index for the next page by tapping into the <code>params</code> parameter and getting its <code>key</code> field—this field will always give us the index of the next page that must be loaded. If this is the first time a page is requested, the <code>key</code> field will be <code>null</code>, so we default to the value of <code>1</code> in that case.</p>
			<ol>
				<li value="6">Since we now know the index<a id="_idIndexMarker919"/> of the next page of repositories<a id="_idIndexMarker920"/> that we need, let's query our REST API for that specific page by calling the <code>getRepositories()</code> method of <code>restInterface</code> and by passing in the newly defined <code>nextPage</code> parameter, as follows:<pre>class RepositoriesPagingSource(…) : […] {
    override suspend fun load(params: LoadParams&lt;Int&gt;)
            : LoadResult&lt;Int, Repository&gt; {
        try {
            val nextPage = params.key ?: 1
            <strong class="bold">val repos = restInterface</strong>
<strong class="bold">                .getRepositories(nextPage).repos</strong>
        } catch (e: Exception) {
            return LoadResult.Error(e) 
        }
    }
    override fun getRefreshKey(…): Int? { … }
}</pre></li>
			</ol>
			<p>In this step, we also store a list of <code>Repository</code> objects from within the response inside the <code>reposResponse</code> variable.</p>
			<ol>
				<li value="7">Next up, we must return a <code>LoadResult</code> object, as the request to our REST API is successful at this point. Let's instantiate and return a <code>LoadResult.Page</code> object, as follows:<pre>class RepositoriesPagingSource(…) : […] {
    override suspend fun load(params: LoadParams&lt;Int&gt;)
            : […] {
        try {
            val nextPage = params.key ?: 1
            val repos = restInterface
                .getRepositories(nextPage).repos
            <strong class="bold">return LoadResult.Page(</strong>
<strong class="bold">                data = repos,</strong>
<strong class="bold">                prevKey = if (nextPage == 1) null</strong>
<strong class="bold">                          else nextPage - 1,</strong>
<strong class="bold">                nextKey = nextPage + 1)</strong>
        } catch (e: Exception) {
            return LoadResult.Error(e)
        }
    }
    override fun getRefreshKey(…): Int? { … }
}</pre></li>
			</ol>
			<p>We had to pass the following to the <code>LoadResult.Page()</code> constructor:</p>
			<ul>
				<li>A list of <code>Repository</code> objects from the newly requested page to the <code>data</code> parameter.</li>
				<li>The previous key of the newly<a id="_idIndexMarker921"/> requested page to the <code>prevKey</code> parameter. This key is important<a id="_idIndexMarker922"/> if, for some reason, the previous pages are invalidated and must be reloaded when the user starts scrolling up. Most of the time, we would deduct <code>1</code> from the <code>nextPage</code> value, yet we also made sure that if we had just requested the first page (the value of <code>nextPage</code> would be <code>1</code>), we would pass <code>null</code> to the <code>prevKey</code> parameter.</li>
				<li>The next key after <code>nextPage</code> to the <code>nextKey</code> parameter. This is a simple one as we have just added <code>1</code> to the value of <code>nextPage</code>.</li>
			</ul>
			<p>Now that we finished the <code>PagingSource</code> implementation, it's time to build the <code>Pager</code> component<a id="_idIndexMarker923"/> and get a stream of paginated<a id="_idIndexMarker924"/> data.</p>
			<ol>
				<li value="8">Inside <code>RepositoriesViewModel</code>, replace the <code>RepositoriesApiService</code> dependency with the newly created <code>RepositoriesPagingSource</code> class, as follows:<pre>class RepositoriesViewModel(
    <strong class="bold">private val reposPagingSource:</strong>
<strong class="bold">    RepositoriesPagingSource = RepositoriesPagingSource()</strong>
) : ViewModel() <strong class="bold">{</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>At the same time, we make sure to remove any existing implementation inside the <code>RepositoriesViewModel</code>, leaving it blank for the upcoming step.</p>
			<ol>
				<li value="9">Still inside the <code>RepositoriesViewModel</code>, define a <code>repositories</code> variable that will hold our flow of paginated data, like this:<pre>import kotlinx.coroutines.flow.Flow
class RepositoriesViewModel(
    private val reposPagingSource:
    RepositoriesPagingSource = RepositoriesPagingSource()
) : ViewModel() {
    <strong class="bold">val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt;</strong>
}</pre></li>
			</ol>
			<p>The paginated content with <code>Repository</code> items is held within a <code>PagingData</code> container, making our stream of data to be of type <code>Flow&lt;PagingData&lt;Repository&gt;&gt;</code>.</p>
			<p>Now, we must instantiate our <code>repositories</code> variable. However, creating a flow is not trivial, especially when the data (the list of repositories) must grow as the user scrolls. The Paging<a id="_idIndexMarker925"/> library has us covered, as it will hide<a id="_idIndexMarker926"/> this complexity from us and will provide us with a flow that emits data as we would expect it to: when the user scrolls to the end of the list, new requests are made to the backend, and new <code>Repository</code> objects are appended to the list.</p>
			<ol>
				<li value="10">As the first step to obtaining our flow of paginated data, we must create an instance of the <code>Pager</code> class based on the previously created <code>PagingSource</code> object, like so:<pre>class RepositoriesViewModel(
    private val reposPagingSource:
    RepositoriesPagingSource = RepositoriesPagingSource()
) : ViewModel() {
    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; =
        <strong class="bold">Pager(</strong>
<strong class="bold">            config = PagingConfig(pageSize = 20),</strong>
<strong class="bold">            pagingSourceFactory = {</strong>
<strong class="bold">                reposPagingSource</strong>
<strong class="bold">            })</strong>
}</pre></li>
			</ol>
			<p>To create an instance of a <code>Pager</code>, we called the <code>Pager()</code> constructor and passed the following:</p>
			<ul>
				<li>A <code>PagingConfig</code> object with a <code>pageSize</code> value of <code>20</code> (to match this value<a id="_idIndexMarker927"/> with the number of repositories<a id="_idIndexMarker928"/> we're requesting from the backend) to the <code>config</code> parameter.</li>
				<li>The <code>reposPagingSource</code> instance of type <code>RepositoriesPagingSource</code> to the <code>pagingSourceFactory</code> parameter. By doing so, the Paging library will know which <code>PagingSource</code> object to query for new pages.</li>
			</ul>
			<ol>
				<li value="11">Finally, to obtain a flow with data from the newly created <code>Pager</code> instance, we must simply access the <code>flow</code> field exposed by the resulted <code>Pager</code> instance, as follows:<pre>class RepositoriesViewModel(...) : ViewModel() {
    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; =
        Pager(
            config = PagingConfig(pageSize = 20),
            pagingSourceFactory = {
                reposPagingSource
          <strong class="bold">  }).flow.cachedIn(viewModelScope)</strong>
}</pre></li>
			</ol>
			<p>On the resulting flow, we also called the <code>cachedIn()</code> extension function that makes sure that the stream of data is kept alive as long as the passed <code>CoroutineScope</code> object is alive and then returns back the same flow it's called upon. Since we wanted the paginated content to be cached as long as the <code>ViewModel</code> is kept in memory, we passed the <code>viewModelScope</code> scope to this extension function. This makes sure that the flow is also preserved upon events where the <code>ViewModel</code> survives—for example, configuration change.</p>
			<ol>
				<li value="12">Now, we must obtain the flow<a id="_idIndexMarker929"/> in our Compose-based UI, so inside the <code>RepositoriesAppTheme()</code> composable<a id="_idIndexMarker930"/> call from within <code>MainActivity</code>, replace the <code>repos</code> variable with the <code>reposFlow</code> variable that holds a reference to the <code>repositories</code> flow variable of the <code>ViewModel</code>, as follows:<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                val viewModel: RepositoriesViewModel = 
                    viewModel()
                <strong class="bold">val reposFlow = viewModel.repositories</strong>
                RepositoriesScreen<strong class="bold">()</strong>
            }
        }
    }
}</pre></li>
				<li>Next up, we must use a special collection function (similar to the <code>collect()</code> function used in the previous section) that can consume and remember the paginated data from within <code>reposFlow</code> in the context of Compose.</li>
			</ol>
			<p>Declare a new variable called <code>lazyRepoItems</code> and instantiate it with the result returned from the <code>collectAsLazyPagingItems()</code> call on <code>reposFlow</code>, as follows:</p>
			<pre>class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            RepositoriesAppTheme {
                val viewModel: […] = viewModel()
                val reposFlow = viewModel.repositories
                <strong class="bold">val lazyRepoItems</strong>
<strong class="bold">                        : LazyPagingItems&lt;Repository&gt; =</strong>
<strong class="bold">                    reposFlow.collectAsLazyPagingItems()</strong>
                RepositoriesScreen(<strong class="bold">lazyRepoItems</strong>)
            }
        }
    }
}</pre>
			<p>The <code>collectAsLazyPagingItems()</code> function returned a <code>LazyPagingItems</code> object filled with <code>Repository</code> objects. The <code>LazyPagingItems</code> object is responsible<a id="_idIndexMarker931"/> for accessing <code>Repository</code> objects<a id="_idIndexMarker932"/> from the flow so that they can be consumed by our <code>LazyColumn</code> component later on—that's why, in the end, we passed <code>lazyRepoItems</code> to the <code>RepositoriesScreen()</code> composable.</p>
			<ol>
				<li value="14">Moving to the last<a id="_idIndexMarker933"/> piece of the puzzle, the <code>RepositoriesScreen()</code> composable, make sure that it accepts the <code>LazyPagingItems</code> object returned<a id="_idIndexMarker934"/> by our flow by adding the <code>repos</code> parameter, as follows:<pre>@Composable
fun RepositoriesScreen(
<strong class="bold">    repos: LazyPagingItems&lt;Repository&gt;</strong>
) {
    LazyColumn (…) <strong class="bold">{</strong>
    <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>Also, while you're at this step, remove all the code inside the DSL <code>content</code> block exposed by <code>LazyColumn</code> as we will re-add it in a different structure in the next step.</p>
			<ol>
				<li value="15">Finally, still inside <code>RepositoriesScreen()</code>, pass the <code>repos</code> input parameter to another <code>itemsIndexed()</code> DSL function that accepts <code>LazyPagingItems</code>, as follows:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        <strong class="bold">itemsIndexed(repos) { index, repo -&gt;</strong>
<strong class="bold">            if (repo != null) {</strong>
<strong class="bold">                RepositoryItem(index, repo)</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>The <code>LazyColumn</code> API knows how to consume paginated data and how to report back to our instances of <code>Pager</code> and <code>PagingSource</code> when a new page should be loaded, and that's why we made use of an overloaded variant of the <code>itemsIndexed()</code> DSL function that accepts <code>LazyPagingItems</code> as content.</p>
			<p>Also, because the returned <code>repo</code> value can be <code>null</code>, we added a null check before passing it to our <code>RepositoryItem()</code> composable.</p>
			<ol>
				<li value="16">Finally, build<a id="_idIndexMarker935"/> and run the application. Try to scroll to the bottom<a id="_idIndexMarker936"/> of the repositories list. This should trigger a request to get new items, and therefore you should be able to scroll and browse through an <em class="italic">endless</em> list of repositories.<p class="callout-heading">Note</p><p class="callout">If you make too many requests to the GitHub Search API, you might be temporarily limited, and the application will stop loading new items and throw an error. To make our application express such an event, we will learn how to display error states, up next.</p></li>
			</ol>
			<p>Next up, let's improve the UI and UX of our application by adding loading and error states in the context of an infinite list.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor324"/>Implementing loading and error states plus retry functionality</h2>
			<p>While our application<a id="_idIndexMarker937"/> now features<a id="_idIndexMarker938"/> an infinite list<a id="_idIndexMarker939"/> that the user<a id="_idIndexMarker940"/> can scroll<a id="_idIndexMarker941"/> through, it doesn't express<a id="_idIndexMarker942"/> any sort of loading or error state. The good news is that the Paging library tells us exactly when loading states or error states must be shown.</p>
			<p>However, before jumping into the actual implementation, we should first cover the possible loading states and error states that emerge from interacting with an app that features pagination. Luckily, all these cases are already covered by the Paging API.</p>
			<p>While the <code>LazyPagingItems</code> API provides<a id="_idIndexMarker943"/> us with<a id="_idIndexMarker944"/> several <code>LoadState</code> objects, the most<a id="_idIndexMarker945"/> common ones—and the ones<a id="_idIndexMarker946"/> we will need in this section—are the <code>refresh</code> and <code>append</code> types, as<a id="_idIndexMarker947"/> explained in more<a id="_idIndexMarker948"/> detail here:</p>
			<ul>
				<li>The <code>LoadState.refresh</code> instance of <code>LoadState</code> represents initial states that occur after the first request of paginated items or after a refresh event. The two values that we're interested in for this object are these:<ul><li><code>LoadState.Loading</code> — This state means that the app is expressing the initial loading status. When this status arrives for the first time after an app launch, no content would be painted on the screen at that point.</li><li><code>LoadState.Error</code> — This state means that the app is expressing the initial error status. Just as with the previous state, if this status arrives for the first time after an app launch, no content is present.</li></ul></li>
				<li>The <code>LoadState.append</code> instance of <code>LoadState</code> represents states that occur at the end of a subsequent request of paginated items. The two values we're interested in for this object are similar to type <code>refresh</code> but have different significance, as outlined here:<ul><li><code>LoadState.Loading</code> — This state means that the app is in a loading status at the end of a subsequent request for a page with repositories; in other words, the app has requested another page with repositories and it's waiting for the results to arrive. At this point, there should be content rendered from the previous pages.</li><li><code>LoadState.Error</code> — This state means that the app reached an error status after a subsequent request for a page with repositories. In other words, the app has requested another page with repositories but the request has failed. Just as with the previous state, there should be content rendered from the previous pages.</li></ul></li>
			</ul>
			<p>Let's listen<a id="_idIndexMarker949"/> for these states<a id="_idIndexMarker950"/> in our app<a id="_idIndexMarker951"/> and start<a id="_idIndexMarker952"/> with type <code>LoadState.refresh</code>, as follows:</p>
			<ol>
				<li value="1">Inside the <code>RepositoriesScreen()</code> composable, below<a id="_idIndexMarker953"/> the <code>itemsIndexed()</code> call, store the <code>refresh</code> load state<a id="_idIndexMarker954"/> instance inside the <code>refreshLoadstate</code> variable, as follows:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        itemsIndexed(repos) { index, repo -&gt;
            if (repo != null) {
                RepositoryItem(index, repo)
            }
        }
<strong class="bold">        val refreshLoadState = repos.loadState.refresh</strong>
    }
}</pre></li>
			</ol>
			<p>Every time this refreshes, <code>LoadState</code> will change; the values within <code>refreshLoadState</code> will be the latest ones and will correspond to the page where they occurred.</p>
			<ol>
				<li value="2">Next up, create a <code>when</code> expression and verify<a id="_idIndexMarker955"/> whether <code>refreshLoadState</code> is of type <code>LoadState.Loading</code>, and if it is, inside<a id="_idIndexMarker956"/> a new <code>item()</code> call, pass a <code>LoadingItem()</code> composable<a id="_idIndexMarker957"/> that we will define in a bit. The code<a id="_idIndexMarker958"/> is illustrated<a id="_idIndexMarker959"/> in the following<a id="_idIndexMarker960"/> snippet:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        itemsIndexed(repos) { index, repo -&gt;
            if (repo != null) {
                RepositoryItem(index, repo)
            }
        }
        val refreshLoadState = repos.loadState.refresh
    <strong class="bold">    when {</strong>
<strong class="bold">            refreshLoadState is LoadState.Loading -&gt; {</strong>
<strong class="bold">                item {</strong>
<strong class="bold">                    LoadingItem(</strong>
<strong class="bold">                        Modifier.fillParentMaxSize())</strong>
                <strong class="bold">}</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>Since we are adding another <code>item()</code> call below the <code>itemsIndexed()</code> DSL call, we are actually adding another composable below the list of composables from the <code>itemsIndexed()</code> call. However, since <code>refreshLoadState</code> can be of type <code>LoadState.Loading</code> on the first<a id="_idIndexMarker961"/> request for a page<a id="_idIndexMarker962"/> of items, this means<a id="_idIndexMarker963"/> that the screen<a id="_idIndexMarker964"/> is empty at this time, so we also passed a <code>fillParentMaxSize</code> modifier to the <code>LoadingItem()</code> composable, thus making sure that this composable<a id="_idIndexMarker965"/> will take up the entire size<a id="_idIndexMarker966"/> of the screen.</p>
			<ol>
				<li value="3">Next up, at the bottom of the <code>RepositoriesScreen.kt</code> file, let's quickly define a <code>LoadingItem()</code> function that will feature a <code>CirculatorProgressIndicator()</code> composable, as follows:<pre>@Composable
fun LoadingItem(
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.padding(24.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment =
            Alignment.CenterHorizontally
    ) { CircularProgressIndicator() }
}</pre></li>
				<li>Now, run the app, and notice how the progress indicator animation is running before the first page of repositories is loaded and how it is occupying the entire screen, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17788_11_06.jpg" alt="Figure 11.6 – Adding a loading animation for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Adding a loading animation for the first request of paginated content</p>
			<ol>
				<li value="5">Now, let's cover the case<a id="_idIndexMarker967"/> where <code>refreshLoadState</code> is of type <code>Loadstate.Error</code>. Back<a id="_idIndexMarker968"/> inside the <code>LazyColumn</code> component<a id="_idIndexMarker969"/> of the <code>RepositoriesScreen()</code> composable, below the first <code>when</code> branch, add another<a id="_idIndexMarker970"/> check for the state<a id="_idIndexMarker971"/> to be <code>LoadState.Loading</code>—and if that's the<a id="_idIndexMarker972"/> case, add an <code>ErrorItem()</code> composable that we will define in a bit. The code that you must add is illustrated in the following snippet:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        itemsIndexed(repos) { index, repo -&gt; […] }
        val refreshLoadState = repos.loadState.refresh
        when {
            refreshLoadState is LoadState.Loading -&gt; {
                item { LoadingItem(…) }
            }
            <strong class="bold">refreshLoadState is LoadState.Error -&gt; {</strong>
<strong class="bold">                val error = refreshLoadState.error</strong>
<strong class="bold">                item {</strong>
<strong class="bold">                    ErrorItem(</strong>
<strong class="bold">                        message = error.localizedMessage</strong>
<strong class="bold">                            ?: "",</strong>
<strong class="bold">                        modifier =</strong>
<strong class="bold">                           Modifier.fillParentMaxSize()</strong>
<strong class="bold">                    )</strong>
<strong class="bold">                }</strong>
<strong class="bold">            }</strong>
        }
    }
}</pre></li>
			</ol>
			<p>The <code>ErrorItem()</code> composable<a id="_idIndexMarker973"/> requires an error message<a id="_idIndexMarker974"/> to display, so we<a id="_idIndexMarker975"/> stored the <code>Throwable</code> object from <code>LoadState</code> in the <code>error</code> variable<a id="_idIndexMarker976"/> and passed its <code>localizedMessage</code> value<a id="_idIndexMarker977"/> to the <code>message</code> parameter<a id="_idIndexMarker978"/> of the composable.</p>
			<p>Similar to the <code>LoadState.Loading</code> case from before, we are adding another <code>item()</code> call below the <code>itemsIndexed()</code> DSL call, so we are actually adding another composable below the list of composables from the <code>itemsIndexed()</code> call. Also, since <code>refreshLoadState</code> can be of type <code>LoadState.Error</code> on the request for the first page of items, this means that the screen is empty at this time, so we also passed a <code>fillParentMaxSize</code> modifier to the <code>ErrorItem()</code> composable, thus making sure that this composable is taking up the entire size of the screen.</p>
			<ol>
				<li value="6">Next up, at<a id="_idIndexMarker979"/> the bottom<a id="_idIndexMarker980"/> of the <code>RepositoriesScreen.kt</code> file, let's quickly<a id="_idIndexMarker981"/> define an <code>ErrorItem()</code> function<a id="_idIndexMarker982"/> that will feature<a id="_idIndexMarker983"/> a <code>Text()</code> composable displaying<a id="_idIndexMarker984"/> a red error message, as follows:<pre>@Composable
fun ErrorItem(
    message: String,
    modifier: Modifier = Modifier) {
    Row(
        modifier = modifier.padding(16.dp),
        horizontalArrangement = 
            Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = message,
            maxLines = 2,
            modifier = Modifier.weight(1f),
            style = MaterialTheme.typography.h6,
            color = Color.Red)
    }
}</pre></li>
				<li>To mimic an error<a id="_idIndexMarker985"/> state, run the<a id="_idIndexMarker986"/> app on your emulator<a id="_idIndexMarker987"/> or physical device<a id="_idIndexMarker988"/> without an internet<a id="_idIndexMarker989"/> connection, and you should<a id="_idIndexMarker990"/> see a similar error occupying the entire screen, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17788_11_07.jpg" alt="Figure 11.7 – Adding an error message for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Adding an error message for the first request of paginated content</p>
			<p>Note that<a id="_idIndexMarker991"/> the error message<a id="_idIndexMarker992"/> could be different depending<a id="_idIndexMarker993"/> on the circumstances<a id="_idIndexMarker994"/> of the error scenario<a id="_idIndexMarker995"/> that you have<a id="_idIndexMarker996"/> created.</p>
			<p>Before moving on to the append type of <code>LoadState</code>, let's briefly cover the retry functionality that is provided out of the box by the Paging library. In other words, we want to give the user the option to retry obtaining the data in case something went wrong, such as with our forced-error case of disconnecting the test device from the internet.</p>
			<p>Let's do that next.</p>
			<ol>
				<li value="8">Refactor the <code>ErrorItem()</code> composable to accept an <code>onClick()</code> function parameter that will be triggered by the <code>onClick</code> event caused by the press of a new retry <code>Button()</code> composable, as follows:<pre>@Composable
fun ErrorItem(
    message: String,
    modifier: Modifier = Modifier,
    <strong class="bold">onClick: () -&gt; Unit</strong>) {
    Row(...) {
        Text(...)
<strong class="bold">        Button(</strong>
<strong class="bold">            onClick = onClick,</strong>
<strong class="bold">            modifier = Modifier.padding(8.dp)</strong>
<strong class="bold">        ) { Text(text = "Try again") }</strong>
    }
}</pre></li>
			</ol>
			<p>Also, inside<a id="_idIndexMarker997"/> the <code>Row()</code> composable<a id="_idIndexMarker998"/> that was displaying<a id="_idIndexMarker999"/> the error<a id="_idIndexMarker1000"/> message, we have<a id="_idIndexMarker1001"/> now added a <code>Button()</code> composable that when<a id="_idIndexMarker1002"/> pressed, forwards the event to its caller.</p>
			<ol>
				<li value="9">Then, back inside the <code>LazyColumn</code> component of <code>RepositoriesScreen()</code>, find the case where <code>LoadState</code> is of type <code>LoadState.Error</code> and implement the <code>onClick</code> parameter of the <code>ErrorItem()</code> composable that will now trigger a reload. The code is illustrated in the following snippet:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        itemsIndexed(repos) { index, repo -&gt; […] }
        val refreshLoadState = repos.loadState.refresh
        when {
            refreshLoadState is LoadState.Loading -&gt; {
                …
            }
            refreshLoadState is LoadState.Error -&gt; {
                val error = refreshLoadState.error
                item {
                    ErrorItem(
                        message = error.localizedMessage
                            ?: "",
                        modifier =
                           Modifier.fillParentMaxSize(),
<strong class="bold">                        onClick = { repos.retry() })</strong>
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>To<a id="_idIndexMarker1003"/> trigger<a id="_idIndexMarker1004"/> a reload, we<a id="_idIndexMarker1005"/> called the <code>retry()</code> function <a id="_idIndexMarker1006"/>provided<a id="_idIndexMarker1007"/> by our <code>LazyPagingItems</code> instance. Behind<a id="_idIndexMarker1008"/> the scenes, when the <code>retry()</code> function is called, the Paging library notifies <code>PagingSource</code> to request the problematic page again—in this case, for us, the first page with repositories.</p>
			<ol>
				<li value="10">Run the app on your emulator or physical device without an internet connection. You should now see the error state occupying the entire screen containing the error message, but also a retry button. The following screenshot provides a depiction of this:</li>
			</ol>
			<div><div><img src="img/B17788_11_08.jpg" alt="Figure 11.8 – Adding error message and retry button for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Adding error message and retry button for the first request of paginated content</p>
			<p>Don't press the retry button just yet.</p>
			<ol>
				<li value="11">Reconnect<a id="_idIndexMarker1009"/> your device<a id="_idIndexMarker1010"/> to the internet<a id="_idIndexMarker1011"/> and then press<a id="_idIndexMarker1012"/> the retry<a id="_idIndexMarker1013"/> button. As an effect of this action, the content<a id="_idIndexMarker1014"/> should now load successfully.</li>
			</ol>
			<p>Now that we have covered the possible <code>LoadState</code> values for the <code>refresh</code> state, it's time to also cover the values for the <code>append</code> state. As we previously stated, type <code>LoadState.append</code> represents states that occur at the end of a subsequent request of paginated items. </p>
			<p>The possible states we're interested in for this scenario are the <code>LoadState.Loading</code> state—meaning the user has scrolled toward the end of the list and the app is waiting for another page with repositories—and the <code>LoadState.Error</code> state—meaning that the user has scrolled toward the end of the list but the request to get a new page with repositories has failed.</p>
			<ol>
				<li value="12">Inside the block of code exposed by the <code>itemsIndexed()</code> call from within the <code>RepositoriesScreen()</code> composable, just as we did with the <code>refresh</code> state, store the <code>append</code> state inside a new <code>appendLoadState</code> variable, and then add two corresponding branches<a id="_idIndexMarker1015"/> inside the <code>when</code> expression treating<a id="_idIndexMarker1016"/> the <code>LoadState.Loading</code> and<a id="_idIndexMarker1017"/> the <code>LoadState.Error</code> cases. The code<a id="_idIndexMarker1018"/> is illustrated<a id="_idIndexMarker1019"/> in the following<a id="_idIndexMarker1020"/> snippet:<pre>@Composable
fun RepositoriesScreen(
    repos: LazyPagingItems&lt;Repository&gt;
) {
    LazyColumn(…) {
        itemsIndexed(repos) { […] }
        val refreshLoadState = repos.loadState.refresh
<strong class="bold">        val appendLoadState = repos.loadState.append</strong>
        when {
            refreshLoadState is LoadState.Loading -&gt; {
                item {
                    LoadingItem(...)
                }
            }
            refreshLoadState is LoadState.Error -&gt; {
                val error = refreshLoadState.error
                item {
                    ErrorItem(
                        message = error.localizedMessage
                            ?: "",
                        modifier = ...,
                        onClick = { repos.retry() })
                }
            }
            <strong class="bold">appendLoadState is LoadState.Loading -&gt; {</strong>
                <strong class="bold">item {</strong>
<strong class="bold">                    LoadingItem(</strong>
<strong class="bold">                        Modifier.fillMaxWidth())</strong>
<strong class="bold">                }</strong>
<strong class="bold">            }</strong>
            <strong class="bold">appendLoadState is LoadState.Error -&gt; {</strong>
<strong class="bold">                val error = appendLoadState.error</strong>
<strong class="bold">                item {</strong>
<strong class="bold">                    ErrorItem(</strong>
<strong class="bold">                        message = error.localizedMessage</strong>
<strong class="bold">                            ?: "",</strong>
<strong class="bold">                        onClick = { repos.retry() })</strong>
<strong class="bold">                }</strong>
<strong class="bold">            }</strong>
        }
    }
}</pre></li>
			</ol>
			<p>The way we treated<a id="_idIndexMarker1021"/> the possible values<a id="_idIndexMarker1022"/> of <code>appendLoadState</code> is very<a id="_idIndexMarker1023"/> similar to how<a id="_idIndexMarker1024"/> we treated<a id="_idIndexMarker1025"/> the possible<a id="_idIndexMarker1026"/> values of <code>refreshLoadState</code>. However, the notable difference is that <code>appendLoadState</code> state values occur when the app has already loaded some pages and the user has scrolled toward the end of our list, meaning that our app is either waiting for a new page with repositories or failed to load it.</p>
			<p>That's why, in the <code>LoadState.Loading</code> case, we have passed the <code>Modifier.fillMaxWidth()</code> modifier to the <code>LoadingItem()</code> composable, therefore making sure that the loading indicator item appears at the bottom of the list as a list element. In other words, the loading element<a id="_idIndexMarker1027"/> will take only the available width<a id="_idIndexMarker1028"/> and it will not cover<a id="_idIndexMarker1029"/> the entire screen like<a id="_idIndexMarker1030"/> we did<a id="_idIndexMarker1031"/> when <code>refreshLoadState</code> was<a id="_idIndexMarker1032"/> of type <code>LoadState.Loading</code>.</p>
			<p>Similarly, for the <code>LoadState.Error</code> case, we passed the <code>Modifier.fillMaxWidth()</code> modifier to the <code>ErrorItem()</code> composable, therefore making sure that the error element appears as a list element and doesn't cover the entire screen like we did when <code>refreshLoadState</code> was of type <code>LoadState.Error</code>.</p>
			<p>Let's see these two cases in practice, and let's start with the case when our <code>appendLoadState</code> instance has a value of <code>LoadState.Loading</code>.</p>
			<ol>
				<li value="13">First, run the app while your test device is connected to the internet. If you scroll down to the bottom of the list with repositories, you should see the loading indicator animation displayed until a new page with repositories is loaded, as illustrated in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B17788_11_09.jpg" alt="Figure 11.9 – Adding a loading animation for a subsequent request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Adding a loading animation for a subsequent request of paginated content</p>
			<p>Unlike the<a id="_idIndexMarker1033"/> loading indicator<a id="_idIndexMarker1034"/> that is shown<a id="_idIndexMarker1035"/> initially, this indicator appears<a id="_idIndexMarker1036"/> as an item within<a id="_idIndexMarker1037"/> the list, thereby indicating<a id="_idIndexMarker1038"/> that the app is waiting for a new page with repositories.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If your network speed is very fast, you might miss the loading spinner as you are scrolling through new pages. To simulate a slower connection, you can change the network speed of your Android emulator by going into <strong class="bold">AVD Manager</strong>, pressing the <strong class="bold">Edit</strong> button of your emulator, and then selecting <strong class="bold">Show Advanced Settings</strong>. Inside this menu, you can slow down the internet speed of your emulator so that you can see the loading spinner.</p>
			<p>Now, let's test the case when our <code>appendLoadState</code> instance is of type <code>LoadState.Error</code>.</p>
			<ol>
				<li value="14">First, run the app while your test device is connected to the internet.</li>
				<li>Then, disconnect your test device from the internet and scroll down to the bottom of the list with repositories. Initially, you<a id="_idIndexMarker1039"/> might see the loading indicator, yet after a short period <a id="_idIndexMarker1040"/>of time, you should see the error<a id="_idIndexMarker1041"/> element appearing<a id="_idIndexMarker1042"/> at the bottom of the list, as illustrated<a id="_idIndexMarker1043"/> in the following<a id="_idIndexMarker1044"/> screenshot:</li>
			</ol>
			<div><div><img src="img/B17788_11_10.jpg" alt="Figure 11.10 – Adding error element for a subsequent request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Adding error element for a subsequent request of paginated content</p>
			<p>Unlike the error message that is shown initially, this error element appears as an item in the list, thereby indicating that the app has failed to obtain the next page with repositories.</p>
			<ol>
				<li value="16">Optionally, you can reconnect your device to the internet and press the retry button—the new page with repositories should now load, so you can continue browsing and scrolling for more items.</li>
			</ol>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor325"/>Summary</h1>
			<p>In this chapter, we first understood what pagination is and how pagination can be used to expose large datasets of items to users in a more efficient manner.</p>
			<p>Then, we got to meet the Repositories App, a simple Android project where a fixed amount of GitHub repositories was displayed. At that point, we took the decision that users should be able to browse through a huge number of repositories that the GitHub Search API is exposing, so the only solution for that was to integrate paging within our app.</p>
			<p>However, we then realized that we needed to first understand the concept of data streams in the context of pagination, so we learned a few things about Kotlin Flow and how it can be a simple solution to consume paginated content.</p>
			<p>Then, we explored how the Jetpack Paging library is an elegant solution to adding pagination to our apps, culminating with the practical task of integrating paging in our Repositories App with the help of this library. Finally, we transformed our Repositories App into a modern application that creates the illusion of an infinite list of repositories, with initial and intermediary loading or error states, as well as retry functionality.</p>
			<p>In the next chapter, we will tackle yet another Jetpack subject—Lifecycle components!</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor326"/>Further reading</h1>
			<p>In this chapter, we briefly covered how you can integrate Jetpack Paging into an Android application. However, in the context of pagination and Jetpack Paging, there are a couple of more advanced topics that you might end up wondering about, as outlined here:</p>
			<ul>
				<li><code>RemoteMediator</code> API of the Paging library. You can learn more about it from its official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator">https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator</a>.</li>
				<li><code>PagingSource</code> component. Learn more about this from the official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys">https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys</a>.</li>
			</ul>
			<p>As you know by now, testing is very important. In the context of paging, testing can get a little trickier. If you're interested in learning how to test your paging app, check out the official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/test">https://developer.android.com/topic/libraries/architecture/paging/test</a>.</p>
		</div>
	</body></html>