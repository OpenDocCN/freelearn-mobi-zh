<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor317"/>Chapter 11</em>: Creating Infinite Lists with Jetpack Paging and Kotlin Flow</h1>
			<p>In the previous chapters, we built the great Restaurants App that displayed content from our own backend. However, the number of restaurants displayed in the Restaurants App was fixed, and the user was only able to browse through the few restaurants that we added to our Firebase database.</p>
			<p>In this chapter, we will understand how pagination can help us display large datasets of items without putting pressure on our backend and without huge network bandwidth consumption. We will create the impression of an infinite list of items inside a new app that we will be working on called the Repositories App, and we will achieve<a id="_idIndexMarker855"/> that with the help of yet<a id="_idIndexMarker856"/> another Jetpack library called <strong class="bold">Paging</strong>.</p>
			<p>In the first section, <em class="italic">Why do we need pagination?</em>, we will explore what data pagination is and how it can help us break large datasets into pages of data, thereby optimizing the communication between our app and the backend server. Up next, in the <em class="italic">Importing and exploring the Repositories App</em> section, we will explore a project in which we will integrate pagination: the Repositories App that displays information about GitHub repositories.</p>
			<p>Then, in the <em class="italic">Using Kotlin Flow to handle streams of data</em> section, we will cover how paginated content can be expressed as a data stream and how Kotlin Flow is a great solution to handle such content. In the last section, <em class="italic">Exploring pagination with Jetpack Paging</em>, we will first explore the Jetpack Paging library as a solution to working with paginated content in our Android app, and then, with the help of this new library, we will integrate paging in our Repositories App to create the illusion of an infinite list of repositories.</p>
			<p>To summarize, in this chapter, we will be covering the following sections:</p>
			<ul>
				<li>Why do we need pagination?</li>
				<li>Importing and exploring the Repositories App</li>
				<li>Using Kotlin Flow to handle streams of data</li>
				<li>Exploring pagination with Jetpack Paging</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>Building Compose-based Android projects for this chapter usually requires your day-to-day tools. However, to follow along smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>Kotlin 1.6.10 or newer plugin installed in Android Studio</li>
				<li>The existing Repositories App from the GitHub repository of the book</li>
			</ul>
			<p>The starting point for this chapter is represented by the Repositories App that you can find by navigating to the <strong class="source-inline">Chapter_11</strong> directory of the GitHub repository of the book, and then by importing the <strong class="source-inline">repositories_app_starting_point_ch11</strong> directory from within Android Studio. Don't worry, as we will do this together later in this chapter.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_11</strong> directory and then import the <strong class="source-inline">repositories_app_solution_ch11</strong> directory from within Android Studio.</p>
			<p>You can find the <strong class="source-inline">Chapter_11</strong> directory by following this link:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_11</a></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor319"/>Why do we need pagination?</h1>
			<p>Let's say we have an Android application<a id="_idIndexMarker857"/> that allows you to explore GitHub repositories by displaying<a id="_idIndexMarker858"/> a list of projects. It does<a id="_idIndexMarker859"/> that by querying the GitHub <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) with Retrofit and obtaining a fixed number of repositories inside the app. While the REST API serves the application with detailed information for each repository, the app only uses and displays the title and description of the repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don't confuse the Repository classes in our project architecture that abstract data logic with the GitHub repositories that are displayed in our Repositories App.</p>
			<p>Now, let's imagine<a id="_idIndexMarker860"/> that this application retrieves and displays 20 repository elements. Because of this, the user will be able to scroll the content until the 20th element, and therefore will be able to visualize no more than 20 elements.</p>
			<p>But what if we wanted to allow the user to explore more repositories inside our list? In the end, the purpose of the app is to browse a larger number of repositories and not just 20.</p>
			<p>We could update the network call and request a larger list of elements from one single shot. In other words, we could refactor our app to obtain and display a list of 10,000 repositories on one occasion—that is, when the app is launched.</p>
			<p>However, with such an approach, we can think of three main issues, as outlined here:</p>
			<ul>
				<li><strong class="bold">The user interface (UI) of the app could become unresponsive</strong>—If our app tried to render all 10,000 elements, our UI would most likely freeze and become sluggish. However, this issue can be avoided by reusing or rendering only items that are visible on the screen. In fact, until now, we used the <strong class="source-inline">LazyColumn</strong> composable to render UI elements in a lazy manner (when needed), so we can conclude that this issue can be easily fixed.</li>
				<li><strong class="bold">The app would put a lot of pressure on the backend</strong>—Imagine what would happen if every Android application client requested 10,000 database records from the backend server—these services would have to consume quite some resources to query and return so many elements.</li>
				<li>Such a <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request and response would cause a high network<a id="_idIndexMarker861"/> bandwidth consumption caused by the huge <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) payload that would have to be transferred. All 10,000 elements<a id="_idIndexMarker862"/> could contain a lot of fields and nested information—it's clear that having such a payload sent around between our apps and the server would be highly inefficient.</li>
			</ul>
			<p>While we can easily address the first issue, we can conclude that the second and third issues are very concerning. Many real-world applications<a id="_idIndexMarker863"/> and systems face these problems, and in order to alleviate them, the concept of pagination was adopted for most client-server communication-based relationships where large datasets had to be displayed to the end user.</p>
			<p><strong class="bold">Pagination</strong> is a server-friendly communication approach that breaks a huge result into multiple smaller chunks. In other words, if your backend supports pagination, your application can request<a id="_idIndexMarker864"/> only a portion of data (often called a <strong class="bold">page</strong>) and receive a partial response, thereby allowing the transfer to be faster and more efficient on both sides.</p>
			<p>When the application needs more results, it just requests another page, and another page, and so on. This approach is beneficial both for the app and backend service since only small portions of data are served and interpreted at a certain moment in time.</p>
			<p>With pagination, if the user decides to visualize only a small portion of items and then switch to another app, your app would have requested only this small portion of data. Without pagination, in the same case, your backend would have served your app with the entire collection of items, while some of your users wouldn't have had a chance to see all of them. This would be a waste of resources from the perspective of your app, but especially from the perspective of your backend service. Also, only a small portion out of the huge payload sent over the internet was needed.</p>
			<p>To implement such a pagination behavior on the UI, there are two well-known UI approaches for mobile apps, as follows:</p>
			<ul>
				<li>A fixed number of items are displayed on a screen that resembles a web page. On this page, there is a fixed amount of scrolling space because if the user wants to see new items, a button must be pressed to switch pages (often representing the number of a specific page), and then a new set of data is loaded and displayed, replacing the existing content.</li>
			</ul>
			<p>From a mobile <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) perspective, this is a poor design choice because, as opposed<a id="_idIndexMarker865"/> to monitor screens used for web pages, scrolling over contents is more natural on smaller-sized devices such as phones.</p>
			<ul>
				<li>The list of items displayed grows as the user scrolls, thereby creating the impression that the list is infinite—such an approach<a id="_idIndexMarker866"/> is often referred to as infinite scrolling. While there is no such thing as an infinite list, this approach mimics one. It starts with a few requests for the initial page/s, and as the user scrolls to see more elements, it requests more pages with more content on the fly. This approach relies heavily on scrolling and usually creates a better UX.</li>
			</ul>
			<p>In this chapter, we will go for the second<a id="_idIndexMarker867"/> option—in other words, we will implement paging in an attempt to mimic the infinite list effect. Let's also try to visualize how the app could request more items as the user scrolls in the following simplified example, where <strong class="bold">Page 1</strong> contains only six elements:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B17788_11_01.jpg" alt="Figure 11.1 – Observing how infinite lists can be achieved with pagination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Observing how infinite lists can be achieved with pagination</p>
			<p>For the app to request the second page with items, the users must scroll further down, thereby informing the app about their intention of wanting to see more elements.</p>
			<p>When the app catches on to this intention (because the user reached the end of the list), it asks for the second page with items from the backend, making the list of repositories grow and allowing<a id="_idIndexMarker868"/> the user to browse through the new content. This process repeats on and on, as the user keeps on reaching the end of the list.</p>
			<p>Before implementing this pagination approach, let's first get to know our starting point—the GitHub Repositories App!</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor320"/>Importing and exploring the Repositories App</h1>
			<p>The Repositories App project<a id="_idIndexMarker869"/> is a simple application that displays a list of repositories obtained<a id="_idIndexMarker870"/> from the GitHub Search API. This project is a simplified version of a Compose-based application that incorporates only a few concepts from the previous chapters as it tries to be a good candidate for implementing pagination with the Jetpack Paging library rather than being a fully-fledged sample app that applies all the concepts taught in the book.</p>
			<p>Nevertheless, we will see how<a id="_idIndexMarker871"/> the Repositories App follows a <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) presentation pattern, uses Retrofit to obtain data, a <strong class="source-inline">ViewModel</strong> class to hold state and present data, coroutines for the <strong class="bold">asynchronous</strong> (<strong class="bold">async</strong>) operation of obtaining data<a id="_idIndexMarker872"/> from the server, and Compose for the UI layer.</p>
			<p>Let's start off by importing this project into Android Studio, as follows:</p>
			<ol>
				<li>Navigate to the GitHub repository page of the book, located at <a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin</a>.</li>
				<li>Download the repository files. You can do that by pressing the <strong class="bold">Code</strong> button and then by selecting <strong class="bold">Download zip</strong>.</li>
				<li>Unzip the downloaded files and remember the location where you did this.</li>
				<li>Open Android Studio, press on the <strong class="bold">File</strong> tab option, and then select <strong class="bold">Open</strong>.</li>
				<li>Search for the directory where you unzipped the project files. Once you have found it, navigate to the <strong class="source-inline">Chapter_11</strong> directory, select the <strong class="source-inline">repositories_app_starting_point_ch11</strong> directory, and press <strong class="bold">Open</strong>.</li>
				<li>Run the application on your test device.</li>
			</ol>
			<p>You should notice that our Repositories App displays a list of repositories, and the index of each repository item from the list is displayed on the left side, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B17788_11_02.jpg" alt="Figure 11.2 – Observing the Repositories App without pagination&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Observing the Repositories App without pagination</p>
			<p>If you scroll further down, you will notice<a id="_idIndexMarker873"/> that only 20 elements can be viewed. This means that our app<a id="_idIndexMarker874"/> doesn't support paging and the user can only browse through 20 repositories.</p>
			<p>If we have a look inside the <strong class="source-inline">RepositoriesApiService.kt</strong> file, we will notice that our app instructs the REST API through the <strong class="source-inline">@GET()</strong> endpoint <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) to obtain the first page<a id="_idIndexMarker875"/> of repositories while fetching only 20 items per page, as illustrated in the following code snippet:</p>
			<p class="source-code">interface RepositoriesApiService {</p>
			<p class="source-code">   @GET("repositories?q=mobile&amp;sort=stars&amp;page=1&amp;per_page=20")</p>
			<p class="source-code">   suspend fun getRepositories(): RepositoriesResponse</p>
			<p class="source-code">}</p>
			<p>If you have a look at the parameters hardcoded within the request, you will notice that our app always requests the first page of repositories. Also, because it can specify the page number, this clearly means that the backend we're accessing supports pagination, but because we always ask for page <strong class="source-inline">1</strong>, our app doesn't take advantage of it.</p>
			<p>More specifically, when the app<a id="_idIndexMarker876"/> performs this request, it will always retrieve 20 records from the backend <a id="_idIndexMarker877"/>from the page with index <strong class="source-inline">1</strong>. Later in this chapter, we will learn how to make multiple network calls requesting different page numbers, therefore adopting pagination.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're looking to build an app that supports pagination, you must first make sure that your backend supports pagination, just as the GitHub Search API does. Remember that the whole purpose of pagination is to ease the workload of the backend API and to minimize the network bandwidth consumption associated with retrieving a huge JSON payload, so if your backend doesn't support pagination, you can't implement pagination in your app.</p>
			<p>Let's have a brief look over the response we receive from the GitHub API by navigating to the <strong class="source-inline">Repository.kt</strong> file. Basically, we get a list of <strong class="source-inline">Repository</strong> objects, and we parse the <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, and <strong class="source-inline">description</strong> values of the repository, as illustrated in the following code snippet:</p>
			<p class="source-code">data class RepositoriesResponse(</p>
			<p class="source-code">    @SerializedName("items") val repos: List&lt;Repository&gt;</p>
			<p class="source-code">)</p>
			<p class="source-code">data class Repository(</p>
			<p class="source-code">    @SerializedName("id")</p>
			<p class="source-code">    val id: String,</p>
			<p class="source-code">    @SerializedName("full_name")</p>
			<p class="source-code">    val name: String,</p>
			<p class="source-code">    @SerializedName("description")</p>
			<p class="source-code">    val description: String)</p>
			<p>As mentioned before, our app makes use of the GitHub Search API, and this can be better observed inside the <strong class="source-inline">DependencyContainer.kt</strong> class where the Retrofit <strong class="source-inline">RepositoriesApiService</strong> dependency is manually<a id="_idIndexMarker878"/> constructed, and the base URL of this API is passed. You can view<a id="_idIndexMarker879"/> the code for this process in the following snippet:</p>
			<p class="source-code">object DependencyContainer {</p>
			<p class="source-code">    val repositoriesRetrofitClient: RepositoriesApiService =         </p>
			<p class="source-code">        Retrofit.Builder()</p>
			<p class="source-code">            .addConverterFactory(GsonConverterFactory.create())</p>
			<p class="source-code">            .baseUrl("https://api.github.com/search/")</p>
			<p class="source-code">            .build().create(RepositoriesApiService::class.java)</p>
			<p class="source-code">}</p>
			<p>If you're looking to find out more about the API we're using in this chapter, head over to the official documentation<a id="_idIndexMarker880"/> of the GitHub Search API, at <a href="https://docs.github.com/en/rest/search#search-repositories">https://docs.github.com/en/rest/search#search-repositories</a>.</p>
			<p>Now, going back to our Repositories App, if we navigate to the <strong class="source-inline">RepositoriesViewModel.kt</strong> file, we will see that our <strong class="source-inline">ViewModel</strong> class uses the <strong class="source-inline">RepositoriesApiService</strong> dependency to obtain a list of repositories by launching a coroutine and setting the result to a Compose <strong class="source-inline">State</strong> object holding a list of <strong class="source-inline">Repository</strong> objects. The code is illustrated in the following snippet:</p>
			<p class="source-code">class RepositoriesViewModel(</p>
			<p class="source-code">    private val restInterface: RepositoriesApiService</p>
			<p class="source-code">    = DependencyContainer.repositoriesRetrofitClient</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    val repositories = mutableStateOf(emptyList&lt;Repository&gt;())</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            repositories.value =</p>
			<p class="source-code">                restInterface.getRepositories().repos</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The approach of having a Jetpack ViewModel launch a coroutine to obtain data with the help of Retrofit is very similar to what we've done in the Restaurants App.</p>
			<p>The UI level is also similar<a id="_idIndexMarker881"/> to the Restaurants App. If we navigate to the <strong class="source-inline">MainActivity.kt</strong> file, we can see that our <strong class="source-inline">Activity</strong> class creates a <strong class="source-inline">ViewModel</strong> instance, retrieves a Compose <strong class="source-inline">State</strong> object, obtains its value of type <strong class="source-inline">List&lt;Repository&gt;</strong>, and passes it to a composable function<a id="_idIndexMarker882"/> to consume it, as illustrated in the following code snippet:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        setContent {</p>
			<p class="source-code">            RepositoriesAppTheme {</p>
			<p class="source-code">                val viewModel: RepositoriesViewModel = </p>
			<p class="source-code">                    viewModel()</p>
			<p class="source-code">                val repos = viewModel.repositories.value</p>
			<p class="source-code">                RepositoriesScreen(repos)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The composable function that consumes the list of <strong class="source-inline">Repository</strong> objects resides inside the <strong class="source-inline">RepositoriesScreen.kt</strong> file, as illustrated in the following code snippet:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RepositoriesScreen(repos: List&lt;Repository&gt;) {</p>
			<p class="source-code">    LazyColumn(</p>
			<p class="source-code">        contentPadding = PaddingValues(</p>
			<p class="source-code">            vertical = 8.dp,</p>
			<p class="source-code">            horizontal = 8.dp)</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">        itemsIndexed(repos) { index, repo -&gt;</p>
			<p class="source-code">            RepositoryItem(index, repo) </p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Just as in the Restaurants App, our screen-level composable uses the <strong class="source-inline">LazyColumn</strong> composable<a id="_idIndexMarker883"/> to optimize the way the UI renders<a id="_idIndexMarker884"/> elements in the list.</p>
			<p><strong class="source-inline">LazyColumn</strong> usage is important for our use case of trying to implement pagination because we don't want our UI to render thousands of UI elements. Luckily, as we know already, <strong class="source-inline">LazyColumn</strong> has us covered because it only composes and lays out visible elements on the screen.</p>
			<p>Now, you might have noticed that the <strong class="source-inline">RepositoriesScreen</strong> composable uses the <strong class="source-inline">itemsIndexed()</strong> <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) function instead of the <strong class="source-inline">items()</strong> function that we used<a id="_idIndexMarker885"/> in the Restaurants App. This is because, since our app will support pagination, we want to paint the index of the element displayed on the screen to better understand where we are at right now. To get the index of the composable item visible on the screen, the <strong class="source-inline">itemsIndexed()</strong> function provides us with this information out of the box.</p>
			<p>Finally, let's have a brief look over the structure of the <strong class="source-inline">RepositoryItem</strong> composable that displays the contents of a <strong class="source-inline">Repository</strong> object, while also rendering the index of the repository, as follows:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun RepositoryItem(index: Int, item: Repository) {</p>
			<p class="source-code">    Card(</p>
			<p class="source-code">        elevation = 4.dp,</p>
			<p class="source-code">        modifier = Modifier.padding(8.dp).height(120.dp)</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">        Row(</p>
			<p class="source-code">            verticalAlignment = Alignment.CenterVertically,</p>
			<p class="source-code">            modifier = Modifier.padding(8.dp)</p>
			<p class="source-code">        ) {</p>
			<p class="source-code">            Text(</p>
			<p class="source-code">                text = index.toString(),</p>
			<p class="source-code">                style = MaterialTheme.typography.h6,</p>
			<p class="source-code">                modifier = Modifier</p>
			<p class="source-code">                    .weight(0.2f)</p>
			<p class="source-code">                    .padding(8.dp))</p>
			<p class="source-code">            Column(modifier = Modifier.weight(0.8f)) {</p>
			<p class="source-code">                Text(</p>
			<p class="source-code">                    text = item.name,</p>
			<p class="source-code">                    style = MaterialTheme.typography.h6)</p>
			<p class="source-code">                Text(</p>
			<p class="source-code">                    text = item.description,</p>
			<p class="source-code">                    style = MaterialTheme.typography.body2,</p>
			<p class="source-code">                    overflow = TextOverflow.Ellipsis,</p>
			<p class="source-code">                    maxLines = 3)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now that we have briefly covered the current state of the Repositories App, we can conclude that it could really use pagination<a id="_idIndexMarker886"/> to show more repositories, especially when the GitHub Search API<a id="_idIndexMarker887"/> supports that. It's time to cover another important aspect that pagination forces us to be aware of, and that's the concept of streams of data.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor321"/>Using Kotlin Flow to handle streams of data</h1>
			<p>If we want our app to support pagination<a id="_idIndexMarker888"/> in the form of an infinite list, it's clear that our existing approach<a id="_idIndexMarker889"/> of having a single one-shot request to the backend that results in one UI update will not suffice.</p>
			<p>Let's first have a look in the following code snippet at how our <strong class="source-inline">RepositoriesViewModel</strong> class requests data:</p>
			<p class="source-code">class RepositoriesViewModel(</p>
			<p class="source-code">    private val restInterface: RepositoriesApiService =  [...]</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    val repositories = mutableStateOf(emptyList&lt;Repository&gt;())</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            <strong class="bold">repositories.value =</strong></p>
			<p class="source-code"><strong class="bold">                restInterface.getRepositories().repos</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When the <strong class="source-inline">ViewModel</strong> is initialized, it executes the <strong class="source-inline">getRepositories()</strong> suspending function inside a coroutine. The suspending function returns a list of <strong class="source-inline">Repository</strong> objects that is passed to the <strong class="source-inline">repositories</strong> variable. This means that our <strong class="source-inline">ViewModel</strong> performs a one-shot request for data<a id="_idIndexMarker890"/> in the form of a one-time call to the suspending<a id="_idIndexMarker891"/> function—no other request is done over time to get new repositories as the user scrolls through the list. That's why our app receives a single event with data (an initial list of objects) from the backend as a single result.</p>
			<p>We can imagine that calling a similar <strong class="source-inline">getRepositories()</strong> suspending function with the one in our app would just as well return a one-time response as its return type would be <strong class="source-inline">List&lt;Repository&gt;</strong>, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B17788_11_03.jpg" alt="Figure 11.3 – Observing one-shot data result with suspending function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Observing one-shot data result with suspending function</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While our <strong class="source-inline">ViewModel</strong> contains a <strong class="source-inline">repositories</strong> variable whose type is <strong class="source-inline">MutableState</strong>, meaning that it can change its value over time, we aren't going to use Compose <strong class="source-inline">State</strong> objects to observe changes coming from the data layer as this would break the responsibilities of layers. Right now, in our code, we are calling a suspending function that returns only one result or one set of data asynchronously. This result is passed to the <strong class="source-inline">repositories</strong> variable, so even though our UI state can change over time, it only receives one update.</p>
			<p>To support an infinite list, we must somehow design our app to receive multiple results over time, just as with a stream of data. In other words, our app must request new <strong class="source-inline">Repository</strong> objects as the user scrolls, thereby receiving multiple events with data, and not just one. With every new data event coming in, our app should get a new list of <strong class="source-inline">Repository</strong> objects that now contains the newly received repositories as well.</p>
			<p>To make our <strong class="source-inline">ViewModel</strong> receive multiple events of data in the form of a stream of data, we can use Flow. Kotlin <strong class="bold">Flow</strong> is a data type built on top of coroutines that exposes a stream of multiple, asynchronously computed values.</p>
			<p>As opposed to suspending<a id="_idIndexMarker892"/> functions, which emit a single result, Flow<a id="_idIndexMarker893"/> allows us to emit multiple values sequentially over time. However, just as a suspending function emits a result in an asynchronous manner that you can later obtain from within a coroutine, Flow also emits results asynchronously, so you must observe its results from within a launched coroutine.</p>
			<p>You could use Flow to listen for events coming from various sources; for example, you could use Flow to get location updates every time the location of the user changes. Or, you could use Flow to get sequential updates from your Room database—instead of manually querying the database every time you insert or update items, you can tell Room to return a flow that will emit updates with its most up-to-date content whenever you perform insertions, updates, and so on.</p>
			<p>Getting back to our example with repositories, let's imagine that our <strong class="source-inline">getRepositories()</strong> function is no longer a suspending function, but instead returns a flow whose contained data is of type <strong class="source-inline">List&lt;Repository&gt;</strong>, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B17788_11_04.jpg" alt="Figure 11.4 – Observing multiple results over time with Kotlin Flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – Observing multiple results over time with Kotlin Flow</p>
			<p>Just as the Compose <strong class="source-inline">State</strong> object holds data of a certain type (for example, <strong class="source-inline">State&lt;Int&gt;</strong> emits values of type <strong class="source-inline">Int</strong>), Flow also holds data of a certain type; in our previous example, that type was the data we're interested in emitting—that is, <strong class="source-inline">List&lt;Repository&gt;</strong>.</p>
			<p>But how can we observe the emitted values of a flow?</p>
			<p>Let's take the previous<a id="_idIndexMarker894"/> example where the <strong class="source-inline">getRepositories()</strong> method returned a <strong class="source-inline">Flow&lt;List&lt;Repository&gt;&gt;</strong> instance, and let's imagine<a id="_idIndexMarker895"/> that we're trying to observe its values in a UI component, as follows:</p>
			<p class="source-code">class SomeViewModel(…) : ViewModel() {</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            getRepositories().collect { repos -&gt;</p>
			<p class="source-code">                // Update UI</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    […]</p>
			<p class="source-code">}</p>
			<p>Since a flow emits values asynchronously, we obtained the <strong class="source-inline">Flow&lt;List&lt;Repository&gt;&gt;</strong> instance inside a launched coroutine and then called the <strong class="source-inline">.collect()</strong> method, which in turn provided us with a block of code where we can consume the <strong class="source-inline">List&lt;Repository&gt;</strong> values.</p>
			<p>As opposed to obtaining such a list from a suspending function call, it's important to remember that the values emitted by the flow change (or, at least, should change) over time. In other words, for every callback that provides us with a value stored in the <strong class="source-inline">repos</strong> variable, the content of its value of type <strong class="source-inline">List&lt;Repository&gt;</strong> could be different, allowing us to update the UI on every new emission.</p>
			<p>In this section, we have explored what a flow is and how we can consume it. However, Kotlin Flow is a very complex subject; for example, we aren't going to cover the manner in which you can create a flow, or how you can modify the produced stream. If you're looking to find out more about Flow, check the official<a id="_idIndexMarker896"/> Android documentation at <a href="https://developer.android.com/kotlin/flow">https://developer.android.com/kotlin/flow</a>.</p>
			<p>Let's now explore<a id="_idIndexMarker897"/> the last missing piece<a id="_idIndexMarker898"/> of the puzzle—the Paging library.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor322"/>Exploring pagination with Jetpack Paging</h1>
			<p>To implement an infinite<a id="_idIndexMarker899"/> list of repositories in our Repositories App, we must find<a id="_idIndexMarker900"/> a way to request more repositories as the user scrolls through the existing list and reaches its bottom, thereby adding new elements on the fly. Instead of manually deciding when the user is approaching the bottom of the current list of repositories and then triggering a network request to get new items, we can use the Jetpack Paging library, which hides all this complexity from us.</p>
			<p><strong class="bold">Jetpack Paging</strong> is a library that helps us load<a id="_idIndexMarker901"/> and display pages of data from a large set of data, either through network requests or from our local data storage, thereby allowing us to save network bandwidth and optimize the usage of system resources.</p>
			<p>In this chapter, for simplicity, we will use the Paging library to display an infinite list of repositories obtained from a network source (that is, the GitHub Search API), without involving the local cache.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jetpack Paging library is now at its third implementation iteration, which is often referred<a id="_idIndexMarker902"/> to as Paging 3 or Paging v3. In this<a id="_idIndexMarker903"/> chapter, we will be using this latest version, so even though we will simply call it Jetpack Paging, we are<a id="_idIndexMarker904"/> in fact referring to Jetpack Paging 3.</p>
			<p>The Jetpack Paging library abstracts most of the complexity associated with requesting the correct page at the correct time, depending on the scroll position of the user. Practically, it brings a lot of benefits to the table, such as the following:</p>
			<ul>
				<li>Avoidance of data request duplication—your app will request data only when needed; for example, when the user reaches the end of the list and more items must be rendered.</li>
				<li>Paged data is cached in memory out of the box. During the lifetime of the app process, once a page was loaded, your app will never request it again. If you cache the paginated data in a local database, then your application will not need to request a specific page for cases such as after an app restart.</li>
				<li>Paginated data is exposed as a data stream of the type that fits your need: Kotlin Flow, LiveData, or RxJava. As you might have guessed, we will use Flow.</li>
				<li>Out-of-the-box support for View System or Compose-based UI components that request data automatically when the user scrolls toward the end of the list. With such support, we don't have to know when to request new pages with data as the UI layer will trigger that for us out of the box.</li>
				<li>Retry and refresh capabilities triggered directly by the UI components.</li>
			</ul>
			<p>Before moving to the actual integration<a id="_idIndexMarker905"/> of the Paging library, let's spend a bit of time looking <a id="_idIndexMarker906"/>over the main components part of the Paging API. To ensure paging in your application with the Jetpack Paging API, you must use the following:</p>
			<ul>
				<li>A <strong class="source-inline">PagingSource</strong> component—Defines the source of data for the paginated content. This object decides which page to request and loads it from your remote or local data source. If you're looking to have both a local and remote data source for your paginated content, you could use the built-in <strong class="source-inline">RemoteMediator</strong> API of the Paging library. Check out the <em class="italic">Further reading</em> section for more information on this.</li>
				<li>A <strong class="source-inline">Pager</strong> component—Based on the defined <strong class="source-inline">PagingSource</strong> component, you can construct a <strong class="source-inline">Pager</strong> object that will expose a stream of <strong class="source-inline">PagingData</strong> objects. You can configure the <strong class="source-inline">Pager</strong> object by passing a <strong class="source-inline">PagingConfig</strong> object to its constructor and specifying the page size of your data, for example.</li>
			</ul>
			<p>The <strong class="source-inline">PagingData</strong> class is a wrapper over your paginated data containing a set of items part of the corresponding page. The <strong class="source-inline">PagingData</strong> object is responsible for triggering a query for a new page with items that is then forwarded to the <strong class="source-inline">PagingSource</strong> component.</p>
			<ul>
				<li>A dedicated UI component<a id="_idIndexMarker907"/> that supports pagination—To consume<a id="_idIndexMarker908"/> the stream of paginated content, your UI must make use of dedicated UI components that can handle paginated data. If your UI is based on the traditional View System, you could use the <strong class="source-inline">PagingDataAdapter</strong> component. Since our UI layer is based on Compose, <strong class="source-inline">LazyColumn</strong> has us covered as it knows how to consume paginated data (more on that in the next section).</li>
			</ul>
			<p>To get a visual understanding of how all these components should fit, let's take the following example of a possible implementation of the Paging library inside our Repositories App:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B17788_11_05.jpg" alt="Figure 11.5 – Observing how Paging library APIs can be used in the Repositories App&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Observing how Paging library APIs can be used in the Repositories App</p>
			<p>At the UI level, our composable collects a flow that contains a stream of <strong class="source-inline">PagingData&lt;Repository&gt;</strong> objects. The <strong class="source-inline">PagingData</strong> object contains a list of <strong class="source-inline">Repository</strong> objects, and behind the scenes, it's responsible for forwarding requests for new pages to <strong class="source-inline">PagingSource</strong>, which in turn asks for new items from our REST API.</p>
			<p>Inside <strong class="source-inline">ViewModel</strong>, we will have a <strong class="source-inline">Pager</strong> object that will use an instance of <strong class="source-inline">PagingSource</strong>. We will define a <strong class="source-inline">PagingSource</strong> object so that it knows which page to ask for and where to ask for it—that is, the GitHub Search API.</p>
			<p>Now that we have covered the theoretical aspects of our pagination integration with Jetpack Paging, let's see which practical tasks we will be working on in this section. We will be doing the following:</p>
			<ul>
				<li>Implementing pagination with Jetpack Paging</li>
				<li>Implementing<a id="_idIndexMarker909"/> loading and error states plus retry<a id="_idIndexMarker910"/> functionality</li>
			</ul>
			<p>Let's proceed with the first task: integrating pagination in our Repositories App.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor323"/>Implementing pagination with Jetpack Paging</h2>
			<p>In this section, we will integrate paging<a id="_idIndexMarker911"/> in our Repositories App and create an infinite<a id="_idIndexMarker912"/> list of repositories with the help of Jetpack Paging. To achieve that, we will implement and add all the components described in the previous section.</p>
			<p>Let's get cracking! Proceed as follows:</p>
			<ol>
				<li value="1">First, inside the app-level <strong class="source-inline">build.gradle</strong> file, in the <strong class="source-inline">dependencies</strong> block, add the Compose Gradle dependency for Jetpack Paging, as follows:<p class="source-code">dependencies {</p><p class="source-code">    […]</p><p class="source-code"><strong class="bold">    implementation "androidx.paging:</strong></p><p class="source-code"><strong class="bold">        paging-compose:1.0.0-alpha14"</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>After updating the <strong class="source-inline">build.gradle</strong> file, make sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="2">Next up, let's refactor our Retrofit <strong class="source-inline">RepositoriesApiService</strong> interface by removing the hardcoded page index of <strong class="source-inline">1</strong> within the <strong class="source-inline">@GET()</strong> request annotation, and by adding a query <strong class="source-inline">page</strong> parameter of type <strong class="source-inline">Int</strong> representing the page index we're looking to acquire. The code is illustrated in the following snippet:<p class="source-code">interface RepositoriesApiService {</p><p class="source-code">    @GET("<strong class="bold">repositories?q=mobile&amp;sort=stars&amp;per_page=20</strong>")</p><p class="source-code">    suspend fun getRepositories(<strong class="bold">@Query("page") page:Int</strong>): </p><p class="source-code">        RepositoriesResponse</p><p class="source-code">}</p></li>
			</ol>
			<p>Before these changes, we were always obtaining the first page of repository results. Now, we have updated<a id="_idIndexMarker913"/> our network request to harvest the power <a id="_idIndexMarker914"/>of paginated REST APIs—that is, the capability to ask for a different page index based on the scrolling position of the user. </p>
			<p>To achieve this, we used the Retrofit <strong class="source-inline">@Query()</strong> annotation, which basically will insert the value of the <strong class="source-inline">page</strong> parameter we have defined in the <strong class="source-inline">getRepositories()</strong> method into the <strong class="source-inline">GET</strong> request. As the GitHub Search API expects a <strong class="source-inline">"page"</strong> query key in the URL request, we have passed the <strong class="source-inline">"page"</strong> key to the <strong class="source-inline">@Query()</strong> annotation.</p>
			<ol>
				<li value="3">It's now time to build a <strong class="source-inline">PagingSource</strong> component that will request new pages through our <strong class="source-inline">RepositoriesApiService</strong> dependency and will keep track of which page to ask for, while also keeping an in-memory cache of the previously retrieved pages.</li>
			</ol>
			<p>Inside the root package of the app, create a new class named <strong class="source-inline">RepositoriesPagingSource</strong> and paste the following code below it:</p>
			<p class="source-code">class RepositoriesPagingSource(</p>
			<p class="source-code">    private val restInterface: RepositoriesApiService</p>
			<p class="source-code">    = DependencyContainer.repositoriesRetrofitClient,</p>
			<p class="source-code">) : PagingSource&lt;Int, Repository&gt;() {</p>
			<p class="source-code">    override suspend fun load(params: LoadParams&lt;Int&gt;)</p>
			<p class="source-code">            : LoadResult&lt;Int, Repository&gt; {</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun getRefreshKey(</p>
			<p class="source-code">        state: PagingState&lt;Int, Repository&gt;,</p>
			<p class="source-code">    ): Int? {</p>
			<p class="source-code">        return null</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's break down<a id="_idIndexMarker915"/> the code we have just added. This component<a id="_idIndexMarker916"/> is doing the following:</p>
			<ul>
				<li>It is in charge of requesting new pages, so it has a dependency on <strong class="source-inline">RepositoriesApiService</strong> as the <strong class="source-inline">restInterface</strong> constructor field.</li>
				<li>It is a <strong class="source-inline">PagingSource</strong> component, so it inherits from the <strong class="source-inline">PagingSource</strong> class while also defining the following:</li>
			</ul>
			<ul>
				<li>A key as the type of the page index—in our case, the GitHub Search API requires an integer representing the index of the page, so we set the key as <strong class="source-inline">Int</strong>.</li>
				<li>Type of the loaded data—in our case, <strong class="source-inline">Repository</strong> objects.<ul><li>Implementing the following two mandatory functions:</li></ul></li>
				<li>The <strong class="source-inline">load()</strong> suspending function, which is called automatically by the Paging library and should fetch more items asynchronously. This method takes in a <strong class="source-inline">LoadParams</strong> object that keeps track of information such as what is the key (index) of the page that must be requested, or the initial load size of items. Also, this method returns a <strong class="source-inline">LoadResult</strong> object indicating if a specific query result was successful or has failed.</li>
				<li>The <strong class="source-inline">getRefreshKey()</strong> function, which is called to obtain and return the most recent page key in case of a refresh event so that the user is returned to the latest known page (and not the first one). A refresh event can come from a variety of sources, such as a manual UI refresh triggered by the user, a database cache invalidation event, system events, and so on.</li>
			</ul>
			<p>For simplicity, and also because we will not implement refresh capabilities, we will skip implementing the <strong class="source-inline">getRefreshKey()</strong> method, so we just returned <strong class="source-inline">null</strong> inside the body of this method. However, if you're looking to also support such behavior, check out the <em class="italic">Further reading</em> section where additional resources are listed to help you provide an implementation for this method.</p>
			<ol>
				<li value="4">Now that we have covered the purpose of the two mandatory methods, let's implement the one we're really interested in—the <strong class="source-inline">load()</strong> function.</li>
			</ol>
			<p>This method should return a <strong class="source-inline">LoadResult</strong> object, so first, add a <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> block, and inside the <strong class="source-inline">catch</strong> block, return an <strong class="source-inline">Error()</strong> instance of <strong class="source-inline">LoadResult</strong> by passing the <strong class="source-inline">Exception</strong> object that was caught, as illustrated in the following code snippet:</p>
			<p class="source-code">class RepositoriesPagingSource(…) : […] {</p>
			<p class="source-code">    override suspend fun load(params: LoadParams&lt;Int&gt;)</p>
			<p class="source-code">    : LoadResult&lt;Int, Repository&gt; {</p>
			<p class="source-code"><strong class="bold">        try {</strong></p>
			<p class="source-code"><strong class="bold">        } catch (e: Exception) {</strong></p>
			<p class="source-code"><strong class="bold">            return LoadResult.Error(e)</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun getRefreshKey(…): Int? { … }</p>
			<p class="source-code">}</p>
			<p>With this approach, if the request for a new page fails, we let the Paging library know<a id="_idIndexMarker917"/> that an error event occurred<a id="_idIndexMarker918"/> by returning the <strong class="source-inline">LoadResult.Error</strong> object.</p>
			<ol>
				<li value="5">Next up, inside the <strong class="source-inline">try</strong> block, we must first obtain and store the next page we're interested in. Store the index of the next page inside the <strong class="source-inline">nextPage</strong> variable, as follows:<p class="source-code">class RepositoriesPagingSource(…) : […] {</p><p class="source-code">    override suspend fun load(params: LoadParams&lt;Int&gt;)</p><p class="source-code">    : LoadResult&lt;Int, Repository&gt; {</p><p class="source-code">        try {</p><p class="source-code"><strong class="bold">            val nextPage = params.key ?: 1</strong></p><p class="source-code">        } catch (e: Exception) {</p><p class="source-code">            return LoadResult.Error(e) </p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override fun getRefreshKey(…): Int? { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>We obtained the index for the next page by tapping into the <strong class="source-inline">params</strong> parameter and getting its <strong class="source-inline">key</strong> field—this field will always give us the index of the next page that must be loaded. If this is the first time a page is requested, the <strong class="source-inline">key</strong> field will be <strong class="source-inline">null</strong>, so we default to the value of <strong class="source-inline">1</strong> in that case.</p>
			<ol>
				<li value="6">Since we now know the index<a id="_idIndexMarker919"/> of the next page of repositories<a id="_idIndexMarker920"/> that we need, let's query our REST API for that specific page by calling the <strong class="source-inline">getRepositories()</strong> method of <strong class="source-inline">restInterface</strong> and by passing in the newly defined <strong class="source-inline">nextPage</strong> parameter, as follows:<p class="source-code">class RepositoriesPagingSource(…) : […] {</p><p class="source-code">    override suspend fun load(params: LoadParams&lt;Int&gt;)</p><p class="source-code">            : LoadResult&lt;Int, Repository&gt; {</p><p class="source-code">        try {</p><p class="source-code">            val nextPage = params.key ?: 1</p><p class="source-code">            <strong class="bold">val repos = restInterface</strong></p><p class="source-code"><strong class="bold">                .getRepositories(nextPage).repos</strong></p><p class="source-code">        } catch (e: Exception) {</p><p class="source-code">            return LoadResult.Error(e) </p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override fun getRefreshKey(…): Int? { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this step, we also store a list of <strong class="source-inline">Repository</strong> objects from within the response inside the <strong class="source-inline">reposResponse</strong> variable.</p>
			<ol>
				<li value="7">Next up, we must return a <strong class="source-inline">LoadResult</strong> object, as the request to our REST API is successful at this point. Let's instantiate and return a <strong class="source-inline">LoadResult.Page</strong> object, as follows:<p class="source-code">class RepositoriesPagingSource(…) : […] {</p><p class="source-code">    override suspend fun load(params: LoadParams&lt;Int&gt;)</p><p class="source-code">            : […] {</p><p class="source-code">        try {</p><p class="source-code">            val nextPage = params.key ?: 1</p><p class="source-code">            val repos = restInterface</p><p class="source-code">                .getRepositories(nextPage).repos</p><p class="source-code">            <strong class="bold">return LoadResult.Page(</strong></p><p class="source-code"><strong class="bold">                data = repos,</strong></p><p class="source-code"><strong class="bold">                prevKey = if (nextPage == 1) null</strong></p><p class="source-code"><strong class="bold">                          else nextPage - 1,</strong></p><p class="source-code"><strong class="bold">                nextKey = nextPage + 1)</strong></p><p class="source-code">        } catch (e: Exception) {</p><p class="source-code">            return LoadResult.Error(e)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    override fun getRefreshKey(…): Int? { … }</p><p class="source-code">}</p></li>
			</ol>
			<p>We had to pass the following to the <strong class="source-inline">LoadResult.Page()</strong> constructor:</p>
			<ul>
				<li>A list of <strong class="source-inline">Repository</strong> objects from the newly requested page to the <strong class="source-inline">data</strong> parameter.</li>
				<li>The previous key of the newly<a id="_idIndexMarker921"/> requested page to the <strong class="source-inline">prevKey</strong> parameter. This key is important<a id="_idIndexMarker922"/> if, for some reason, the previous pages are invalidated and must be reloaded when the user starts scrolling up. Most of the time, we would deduct <strong class="source-inline">1</strong> from the <strong class="source-inline">nextPage</strong> value, yet we also made sure that if we had just requested the first page (the value of <strong class="source-inline">nextPage</strong> would be <strong class="source-inline">1</strong>), we would pass <strong class="source-inline">null</strong> to the <strong class="source-inline">prevKey</strong> parameter.</li>
				<li>The next key after <strong class="source-inline">nextPage</strong> to the <strong class="source-inline">nextKey</strong> parameter. This is a simple one as we have just added <strong class="source-inline">1</strong> to the value of <strong class="source-inline">nextPage</strong>.</li>
			</ul>
			<p>Now that we finished the <strong class="source-inline">PagingSource</strong> implementation, it's time to build the <strong class="source-inline">Pager</strong> component<a id="_idIndexMarker923"/> and get a stream of paginated<a id="_idIndexMarker924"/> data.</p>
			<ol>
				<li value="8">Inside <strong class="source-inline">RepositoriesViewModel</strong>, replace the <strong class="source-inline">RepositoriesApiService</strong> dependency with the newly created <strong class="source-inline">RepositoriesPagingSource</strong> class, as follows:<p class="source-code">class RepositoriesViewModel(</p><p class="source-code">    <strong class="bold">private val reposPagingSource:</strong></p><p class="source-code"><strong class="bold">    RepositoriesPagingSource = RepositoriesPagingSource()</strong></p><p class="source-code">) : ViewModel() <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
			</ol>
			<p>At the same time, we make sure to remove any existing implementation inside the <strong class="source-inline">RepositoriesViewModel</strong>, leaving it blank for the upcoming step.</p>
			<ol>
				<li value="9">Still inside the <strong class="source-inline">RepositoriesViewModel</strong>, define a <strong class="source-inline">repositories</strong> variable that will hold our flow of paginated data, like this:<p class="source-code">import kotlinx.coroutines.flow.Flow</p><p class="source-code">class RepositoriesViewModel(</p><p class="source-code">    private val reposPagingSource:</p><p class="source-code">    RepositoriesPagingSource = RepositoriesPagingSource()</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    <strong class="bold">val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The paginated content with <strong class="source-inline">Repository</strong> items is held within a <strong class="source-inline">PagingData</strong> container, making our stream of data to be of type <strong class="source-inline">Flow&lt;PagingData&lt;Repository&gt;&gt;</strong>.</p>
			<p>Now, we must instantiate our <strong class="source-inline">repositories</strong> variable. However, creating a flow is not trivial, especially when the data (the list of repositories) must grow as the user scrolls. The Paging<a id="_idIndexMarker925"/> library has us covered, as it will hide<a id="_idIndexMarker926"/> this complexity from us and will provide us with a flow that emits data as we would expect it to: when the user scrolls to the end of the list, new requests are made to the backend, and new <strong class="source-inline">Repository</strong> objects are appended to the list.</p>
			<ol>
				<li value="10">As the first step to obtaining our flow of paginated data, we must create an instance of the <strong class="source-inline">Pager</strong> class based on the previously created <strong class="source-inline">PagingSource</strong> object, like so:<p class="source-code">class RepositoriesViewModel(</p><p class="source-code">    private val reposPagingSource:</p><p class="source-code">    RepositoriesPagingSource = RepositoriesPagingSource()</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; =</p><p class="source-code">        <strong class="bold">Pager(</strong></p><p class="source-code"><strong class="bold">            config = PagingConfig(pageSize = 20),</strong></p><p class="source-code"><strong class="bold">            pagingSourceFactory = {</strong></p><p class="source-code"><strong class="bold">                reposPagingSource</strong></p><p class="source-code"><strong class="bold">            })</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>To create an instance of a <strong class="source-inline">Pager</strong>, we called the <strong class="source-inline">Pager()</strong> constructor and passed the following:</p>
			<ul>
				<li>A <strong class="source-inline">PagingConfig</strong> object with a <strong class="source-inline">pageSize</strong> value of <strong class="source-inline">20</strong> (to match this value<a id="_idIndexMarker927"/> with the number of repositories<a id="_idIndexMarker928"/> we're requesting from the backend) to the <strong class="source-inline">config</strong> parameter.</li>
				<li>The <strong class="source-inline">reposPagingSource</strong> instance of type <strong class="source-inline">RepositoriesPagingSource</strong> to the <strong class="source-inline">pagingSourceFactory</strong> parameter. By doing so, the Paging library will know which <strong class="source-inline">PagingSource</strong> object to query for new pages.</li>
			</ul>
			<ol>
				<li value="11">Finally, to obtain a flow with data from the newly created <strong class="source-inline">Pager</strong> instance, we must simply access the <strong class="source-inline">flow</strong> field exposed by the resulted <strong class="source-inline">Pager</strong> instance, as follows:<p class="source-code">class RepositoriesViewModel(...) : ViewModel() {</p><p class="source-code">    val repositories: Flow&lt;PagingData&lt;Repository&gt;&gt; =</p><p class="source-code">        Pager(</p><p class="source-code">            config = PagingConfig(pageSize = 20),</p><p class="source-code">            pagingSourceFactory = {</p><p class="source-code">                reposPagingSource</p><p class="source-code">          <strong class="bold">  }).flow.cachedIn(viewModelScope)</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>On the resulting flow, we also called the <strong class="source-inline">cachedIn()</strong> extension function that makes sure that the stream of data is kept alive as long as the passed <strong class="source-inline">CoroutineScope</strong> object is alive and then returns back the same flow it's called upon. Since we wanted the paginated content to be cached as long as the <strong class="source-inline">ViewModel</strong> is kept in memory, we passed the <strong class="source-inline">viewModelScope</strong> scope to this extension function. This makes sure that the flow is also preserved upon events where the <strong class="source-inline">ViewModel</strong> survives—for example, configuration change.</p>
			<ol>
				<li value="12">Now, we must obtain the flow<a id="_idIndexMarker929"/> in our Compose-based UI, so inside the <strong class="source-inline">RepositoriesAppTheme()</strong> composable<a id="_idIndexMarker930"/> call from within <strong class="source-inline">MainActivity</strong>, replace the <strong class="source-inline">repos</strong> variable with the <strong class="source-inline">reposFlow</strong> variable that holds a reference to the <strong class="source-inline">repositories</strong> flow variable of the <strong class="source-inline">ViewModel</strong>, as follows:<p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            RepositoriesAppTheme {</p><p class="source-code">                val viewModel: RepositoriesViewModel = </p><p class="source-code">                    viewModel()</p><p class="source-code">                <strong class="bold">val reposFlow = viewModel.repositories</strong></p><p class="source-code">                RepositoriesScreen<strong class="bold">()</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next up, we must use a special collection function (similar to the <strong class="source-inline">collect()</strong> function used in the previous section) that can consume and remember the paginated data from within <strong class="source-inline">reposFlow</strong> in the context of Compose.</li>
			</ol>
			<p>Declare a new variable called <strong class="source-inline">lazyRepoItems</strong> and instantiate it with the result returned from the <strong class="source-inline">collectAsLazyPagingItems()</strong> call on <strong class="source-inline">reposFlow</strong>, as follows:</p>
			<p class="source-code">class MainActivity : ComponentActivity() {</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        setContent {</p>
			<p class="source-code">            RepositoriesAppTheme {</p>
			<p class="source-code">                val viewModel: […] = viewModel()</p>
			<p class="source-code">                val reposFlow = viewModel.repositories</p>
			<p class="source-code">                <strong class="bold">val lazyRepoItems</strong></p>
			<p class="source-code"><strong class="bold">                        : LazyPagingItems&lt;Repository&gt; =</strong></p>
			<p class="source-code"><strong class="bold">                    reposFlow.collectAsLazyPagingItems()</strong></p>
			<p class="source-code">                RepositoriesScreen(<strong class="bold">lazyRepoItems</strong>)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">collectAsLazyPagingItems()</strong> function returned a <strong class="source-inline">LazyPagingItems</strong> object filled with <strong class="source-inline">Repository</strong> objects. The <strong class="source-inline">LazyPagingItems</strong> object is responsible<a id="_idIndexMarker931"/> for accessing <strong class="source-inline">Repository</strong> objects<a id="_idIndexMarker932"/> from the flow so that they can be consumed by our <strong class="source-inline">LazyColumn</strong> component later on—that's why, in the end, we passed <strong class="source-inline">lazyRepoItems</strong> to the <strong class="source-inline">RepositoriesScreen()</strong> composable.</p>
			<ol>
				<li value="14">Moving to the last<a id="_idIndexMarker933"/> piece of the puzzle, the <strong class="source-inline">RepositoriesScreen()</strong> composable, make sure that it accepts the <strong class="source-inline">LazyPagingItems</strong> object returned<a id="_idIndexMarker934"/> by our flow by adding the <strong class="source-inline">repos</strong> parameter, as follows:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code"><strong class="bold">    repos: LazyPagingItems&lt;Repository&gt;</strong></p><p class="source-code">) {</p><p class="source-code">    LazyColumn (…) <strong class="bold">{</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Also, while you're at this step, remove all the code inside the DSL <strong class="source-inline">content</strong> block exposed by <strong class="source-inline">LazyColumn</strong> as we will re-add it in a different structure in the next step.</p>
			<ol>
				<li value="15">Finally, still inside <strong class="source-inline">RepositoriesScreen()</strong>, pass the <strong class="source-inline">repos</strong> input parameter to another <strong class="source-inline">itemsIndexed()</strong> DSL function that accepts <strong class="source-inline">LazyPagingItems</strong>, as follows:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        <strong class="bold">itemsIndexed(repos) { index, repo -&gt;</strong></p><p class="source-code"><strong class="bold">            if (repo != null) {</strong></p><p class="source-code"><strong class="bold">                RepositoryItem(index, repo)</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">LazyColumn</strong> API knows how to consume paginated data and how to report back to our instances of <strong class="source-inline">Pager</strong> and <strong class="source-inline">PagingSource</strong> when a new page should be loaded, and that's why we made use of an overloaded variant of the <strong class="source-inline">itemsIndexed()</strong> DSL function that accepts <strong class="source-inline">LazyPagingItems</strong> as content.</p>
			<p>Also, because the returned <strong class="source-inline">repo</strong> value can be <strong class="source-inline">null</strong>, we added a null check before passing it to our <strong class="source-inline">RepositoryItem()</strong> composable.</p>
			<ol>
				<li value="16">Finally, build<a id="_idIndexMarker935"/> and run the application. Try to scroll to the bottom<a id="_idIndexMarker936"/> of the repositories list. This should trigger a request to get new items, and therefore you should be able to scroll and browse through an <em class="italic">endless</em> list of repositories.<p class="callout-heading">Note</p><p class="callout">If you make too many requests to the GitHub Search API, you might be temporarily limited, and the application will stop loading new items and throw an error. To make our application express such an event, we will learn how to display error states, up next.</p></li>
			</ol>
			<p>Next up, let's improve the UI and UX of our application by adding loading and error states in the context of an infinite list.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor324"/>Implementing loading and error states plus retry functionality</h2>
			<p>While our application<a id="_idIndexMarker937"/> now features<a id="_idIndexMarker938"/> an infinite list<a id="_idIndexMarker939"/> that the user<a id="_idIndexMarker940"/> can scroll<a id="_idIndexMarker941"/> through, it doesn't express<a id="_idIndexMarker942"/> any sort of loading or error state. The good news is that the Paging library tells us exactly when loading states or error states must be shown.</p>
			<p>However, before jumping into the actual implementation, we should first cover the possible loading states and error states that emerge from interacting with an app that features pagination. Luckily, all these cases are already covered by the Paging API.</p>
			<p>While the <strong class="source-inline">LazyPagingItems</strong> API provides<a id="_idIndexMarker943"/> us with<a id="_idIndexMarker944"/> several <strong class="source-inline">LoadState</strong> objects, the most<a id="_idIndexMarker945"/> common ones—and the ones<a id="_idIndexMarker946"/> we will need in this section—are the <strong class="source-inline">refresh</strong> and <strong class="source-inline">append</strong> types, as<a id="_idIndexMarker947"/> explained in more<a id="_idIndexMarker948"/> detail here:</p>
			<ul>
				<li>The <strong class="source-inline">LoadState.refresh</strong> instance of <strong class="source-inline">LoadState</strong> represents initial states that occur after the first request of paginated items or after a refresh event. The two values that we're interested in for this object are these:<ul><li><strong class="source-inline">LoadState.Loading</strong> — This state means that the app is expressing the initial loading status. When this status arrives for the first time after an app launch, no content would be painted on the screen at that point.</li><li><strong class="source-inline">LoadState.Error</strong> — This state means that the app is expressing the initial error status. Just as with the previous state, if this status arrives for the first time after an app launch, no content is present.</li></ul></li>
				<li>The <strong class="source-inline">LoadState.append</strong> instance of <strong class="source-inline">LoadState</strong> represents states that occur at the end of a subsequent request of paginated items. The two values we're interested in for this object are similar to type <strong class="source-inline">refresh</strong> but have different significance, as outlined here:<ul><li><strong class="source-inline">LoadState.Loading</strong> — This state means that the app is in a loading status at the end of a subsequent request for a page with repositories; in other words, the app has requested another page with repositories and it's waiting for the results to arrive. At this point, there should be content rendered from the previous pages.</li><li><strong class="source-inline">LoadState.Error</strong> — This state means that the app reached an error status after a subsequent request for a page with repositories. In other words, the app has requested another page with repositories but the request has failed. Just as with the previous state, there should be content rendered from the previous pages.</li></ul></li>
			</ul>
			<p>Let's listen<a id="_idIndexMarker949"/> for these states<a id="_idIndexMarker950"/> in our app<a id="_idIndexMarker951"/> and start<a id="_idIndexMarker952"/> with type <strong class="source-inline">LoadState.refresh</strong>, as follows:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">RepositoriesScreen()</strong> composable, below<a id="_idIndexMarker953"/> the <strong class="source-inline">itemsIndexed()</strong> call, store the <strong class="source-inline">refresh</strong> load state<a id="_idIndexMarker954"/> instance inside the <strong class="source-inline">refreshLoadstate</strong> variable, as follows:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        itemsIndexed(repos) { index, repo -&gt;</p><p class="source-code">            if (repo != null) {</p><p class="source-code">                RepositoryItem(index, repo)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code"><strong class="bold">        val refreshLoadState = repos.loadState.refresh</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Every time this refreshes, <strong class="source-inline">LoadState</strong> will change; the values within <strong class="source-inline">refreshLoadState</strong> will be the latest ones and will correspond to the page where they occurred.</p>
			<ol>
				<li value="2">Next up, create a <strong class="source-inline">when</strong> expression and verify<a id="_idIndexMarker955"/> whether <strong class="source-inline">refreshLoadState</strong> is of type <strong class="source-inline">LoadState.Loading</strong>, and if it is, inside<a id="_idIndexMarker956"/> a new <strong class="source-inline">item()</strong> call, pass a <strong class="source-inline">LoadingItem()</strong> composable<a id="_idIndexMarker957"/> that we will define in a bit. The code<a id="_idIndexMarker958"/> is illustrated<a id="_idIndexMarker959"/> in the following<a id="_idIndexMarker960"/> snippet:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        itemsIndexed(repos) { index, repo -&gt;</p><p class="source-code">            if (repo != null) {</p><p class="source-code">                RepositoryItem(index, repo)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        val refreshLoadState = repos.loadState.refresh</p><p class="source-code">    <strong class="bold">    when {</strong></p><p class="source-code"><strong class="bold">            refreshLoadState is LoadState.Loading -&gt; {</strong></p><p class="source-code"><strong class="bold">                item {</strong></p><p class="source-code"><strong class="bold">                    LoadingItem(</strong></p><p class="source-code"><strong class="bold">                        Modifier.fillParentMaxSize())</strong></p><p class="source-code">                <strong class="bold">}</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Since we are adding another <strong class="source-inline">item()</strong> call below the <strong class="source-inline">itemsIndexed()</strong> DSL call, we are actually adding another composable below the list of composables from the <strong class="source-inline">itemsIndexed()</strong> call. However, since <strong class="source-inline">refreshLoadState</strong> can be of type <strong class="source-inline">LoadState.Loading</strong> on the first<a id="_idIndexMarker961"/> request for a page<a id="_idIndexMarker962"/> of items, this means<a id="_idIndexMarker963"/> that the screen<a id="_idIndexMarker964"/> is empty at this time, so we also passed a <strong class="source-inline">fillParentMaxSize</strong> modifier to the <strong class="source-inline">LoadingItem()</strong> composable, thus making sure that this composable<a id="_idIndexMarker965"/> will take up the entire size<a id="_idIndexMarker966"/> of the screen.</p>
			<ol>
				<li value="3">Next up, at the bottom of the <strong class="source-inline">RepositoriesScreen.kt</strong> file, let's quickly define a <strong class="source-inline">LoadingItem()</strong> function that will feature a <strong class="source-inline">CirculatorProgressIndicator()</strong> composable, as follows:<p class="source-code">@Composable</p><p class="source-code">fun LoadingItem(</p><p class="source-code">    modifier: Modifier = Modifier</p><p class="source-code">) {</p><p class="source-code">    Column(</p><p class="source-code">        modifier = modifier.padding(24.dp),</p><p class="source-code">        verticalArrangement = Arrangement.Center,</p><p class="source-code">        horizontalAlignment =</p><p class="source-code">            Alignment.CenterHorizontally</p><p class="source-code">    ) { CircularProgressIndicator() }</p><p class="source-code">}</p></li>
				<li>Now, run the app, and notice how the progress indicator animation is running before the first page of repositories is loaded and how it is occupying the entire screen, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B17788_11_06.jpg" alt="Figure 11.6 – Adding a loading animation for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Adding a loading animation for the first request of paginated content</p>
			<ol>
				<li value="5">Now, let's cover the case<a id="_idIndexMarker967"/> where <strong class="source-inline">refreshLoadState</strong> is of type <strong class="source-inline">Loadstate.Error</strong>. Back<a id="_idIndexMarker968"/> inside the <strong class="source-inline">LazyColumn</strong> component<a id="_idIndexMarker969"/> of the <strong class="source-inline">RepositoriesScreen()</strong> composable, below the first <strong class="source-inline">when</strong> branch, add another<a id="_idIndexMarker970"/> check for the state<a id="_idIndexMarker971"/> to be <strong class="source-inline">LoadState.Loading</strong>—and if that's the<a id="_idIndexMarker972"/> case, add an <strong class="source-inline">ErrorItem()</strong> composable that we will define in a bit. The code that you must add is illustrated in the following snippet:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        itemsIndexed(repos) { index, repo -&gt; […] }</p><p class="source-code">        val refreshLoadState = repos.loadState.refresh</p><p class="source-code">        when {</p><p class="source-code">            refreshLoadState is LoadState.Loading -&gt; {</p><p class="source-code">                item { LoadingItem(…) }</p><p class="source-code">            }</p><p class="source-code">            <strong class="bold">refreshLoadState is LoadState.Error -&gt; {</strong></p><p class="source-code"><strong class="bold">                val error = refreshLoadState.error</strong></p><p class="source-code"><strong class="bold">                item {</strong></p><p class="source-code"><strong class="bold">                    ErrorItem(</strong></p><p class="source-code"><strong class="bold">                        message = error.localizedMessage</strong></p><p class="source-code"><strong class="bold">                            ?: "",</strong></p><p class="source-code"><strong class="bold">                        modifier =</strong></p><p class="source-code"><strong class="bold">                           Modifier.fillParentMaxSize()</strong></p><p class="source-code"><strong class="bold">                    )</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">ErrorItem()</strong> composable<a id="_idIndexMarker973"/> requires an error message<a id="_idIndexMarker974"/> to display, so we<a id="_idIndexMarker975"/> stored the <strong class="source-inline">Throwable</strong> object from <strong class="source-inline">LoadState</strong> in the <strong class="source-inline">error</strong> variable<a id="_idIndexMarker976"/> and passed its <strong class="source-inline">localizedMessage</strong> value<a id="_idIndexMarker977"/> to the <strong class="source-inline">message</strong> parameter<a id="_idIndexMarker978"/> of the composable.</p>
			<p>Similar to the <strong class="source-inline">LoadState.Loading</strong> case from before, we are adding another <strong class="source-inline">item()</strong> call below the <strong class="source-inline">itemsIndexed()</strong> DSL call, so we are actually adding another composable below the list of composables from the <strong class="source-inline">itemsIndexed()</strong> call. Also, since <strong class="source-inline">refreshLoadState</strong> can be of type <strong class="source-inline">LoadState.Error</strong> on the request for the first page of items, this means that the screen is empty at this time, so we also passed a <strong class="source-inline">fillParentMaxSize</strong> modifier to the <strong class="source-inline">ErrorItem()</strong> composable, thus making sure that this composable is taking up the entire size of the screen.</p>
			<ol>
				<li value="6">Next up, at<a id="_idIndexMarker979"/> the bottom<a id="_idIndexMarker980"/> of the <strong class="source-inline">RepositoriesScreen.kt</strong> file, let's quickly<a id="_idIndexMarker981"/> define an <strong class="source-inline">ErrorItem()</strong> function<a id="_idIndexMarker982"/> that will feature<a id="_idIndexMarker983"/> a <strong class="source-inline">Text()</strong> composable displaying<a id="_idIndexMarker984"/> a red error message, as follows:<p class="source-code">@Composable</p><p class="source-code">fun ErrorItem(</p><p class="source-code">    message: String,</p><p class="source-code">    modifier: Modifier = Modifier) {</p><p class="source-code">    Row(</p><p class="source-code">        modifier = modifier.padding(16.dp),</p><p class="source-code">        horizontalArrangement = </p><p class="source-code">            Arrangement.SpaceBetween,</p><p class="source-code">        verticalAlignment = Alignment.CenterVertically</p><p class="source-code">    ) {</p><p class="source-code">        Text(</p><p class="source-code">            text = message,</p><p class="source-code">            maxLines = 2,</p><p class="source-code">            modifier = Modifier.weight(1f),</p><p class="source-code">            style = MaterialTheme.typography.h6,</p><p class="source-code">            color = Color.Red)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To mimic an error<a id="_idIndexMarker985"/> state, run the<a id="_idIndexMarker986"/> app on your emulator<a id="_idIndexMarker987"/> or physical device<a id="_idIndexMarker988"/> without an internet<a id="_idIndexMarker989"/> connection, and you should<a id="_idIndexMarker990"/> see a similar error occupying the entire screen, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B17788_11_07.jpg" alt="Figure 11.7 – Adding an error message for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Adding an error message for the first request of paginated content</p>
			<p>Note that<a id="_idIndexMarker991"/> the error message<a id="_idIndexMarker992"/> could be different depending<a id="_idIndexMarker993"/> on the circumstances<a id="_idIndexMarker994"/> of the error scenario<a id="_idIndexMarker995"/> that you have<a id="_idIndexMarker996"/> created.</p>
			<p>Before moving on to the append type of <strong class="source-inline">LoadState</strong>, let's briefly cover the retry functionality that is provided out of the box by the Paging library. In other words, we want to give the user the option to retry obtaining the data in case something went wrong, such as with our forced-error case of disconnecting the test device from the internet.</p>
			<p>Let's do that next.</p>
			<ol>
				<li value="8">Refactor the <strong class="source-inline">ErrorItem()</strong> composable to accept an <strong class="source-inline">onClick()</strong> function parameter that will be triggered by the <strong class="source-inline">onClick</strong> event caused by the press of a new retry <strong class="source-inline">Button()</strong> composable, as follows:<p class="source-code">@Composable</p><p class="source-code">fun ErrorItem(</p><p class="source-code">    message: String,</p><p class="source-code">    modifier: Modifier = Modifier,</p><p class="source-code">    <strong class="bold">onClick: () -&gt; Unit</strong>) {</p><p class="source-code">    Row(...) {</p><p class="source-code">        Text(...)</p><p class="source-code"><strong class="bold">        Button(</strong></p><p class="source-code"><strong class="bold">            onClick = onClick,</strong></p><p class="source-code"><strong class="bold">            modifier = Modifier.padding(8.dp)</strong></p><p class="source-code"><strong class="bold">        ) { Text(text = "Try again") }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Also, inside<a id="_idIndexMarker997"/> the <strong class="source-inline">Row()</strong> composable<a id="_idIndexMarker998"/> that was displaying<a id="_idIndexMarker999"/> the error<a id="_idIndexMarker1000"/> message, we have<a id="_idIndexMarker1001"/> now added a <strong class="source-inline">Button()</strong> composable that when<a id="_idIndexMarker1002"/> pressed, forwards the event to its caller.</p>
			<ol>
				<li value="9">Then, back inside the <strong class="source-inline">LazyColumn</strong> component of <strong class="source-inline">RepositoriesScreen()</strong>, find the case where <strong class="source-inline">LoadState</strong> is of type <strong class="source-inline">LoadState.Error</strong> and implement the <strong class="source-inline">onClick</strong> parameter of the <strong class="source-inline">ErrorItem()</strong> composable that will now trigger a reload. The code is illustrated in the following snippet:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        itemsIndexed(repos) { index, repo -&gt; […] }</p><p class="source-code">        val refreshLoadState = repos.loadState.refresh</p><p class="source-code">        when {</p><p class="source-code">            refreshLoadState is LoadState.Loading -&gt; {</p><p class="source-code">                …</p><p class="source-code">            }</p><p class="source-code">            refreshLoadState is LoadState.Error -&gt; {</p><p class="source-code">                val error = refreshLoadState.error</p><p class="source-code">                item {</p><p class="source-code">                    ErrorItem(</p><p class="source-code">                        message = error.localizedMessage</p><p class="source-code">                            ?: "",</p><p class="source-code">                        modifier =</p><p class="source-code">                           Modifier.fillParentMaxSize(),</p><p class="source-code"><strong class="bold">                        onClick = { repos.retry() })</strong></p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>To<a id="_idIndexMarker1003"/> trigger<a id="_idIndexMarker1004"/> a reload, we<a id="_idIndexMarker1005"/> called the <strong class="source-inline">retry()</strong> function <a id="_idIndexMarker1006"/>provided<a id="_idIndexMarker1007"/> by our <strong class="source-inline">LazyPagingItems</strong> instance. Behind<a id="_idIndexMarker1008"/> the scenes, when the <strong class="source-inline">retry()</strong> function is called, the Paging library notifies <strong class="source-inline">PagingSource</strong> to request the problematic page again—in this case, for us, the first page with repositories.</p>
			<ol>
				<li value="10">Run the app on your emulator or physical device without an internet connection. You should now see the error state occupying the entire screen containing the error message, but also a retry button. The following screenshot provides a depiction of this:</li>
			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B17788_11_08.jpg" alt="Figure 11.8 – Adding error message and retry button for the first request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8 – Adding error message and retry button for the first request of paginated content</p>
			<p>Don't press the retry button just yet.</p>
			<ol>
				<li value="11">Reconnect<a id="_idIndexMarker1009"/> your device<a id="_idIndexMarker1010"/> to the internet<a id="_idIndexMarker1011"/> and then press<a id="_idIndexMarker1012"/> the retry<a id="_idIndexMarker1013"/> button. As an effect of this action, the content<a id="_idIndexMarker1014"/> should now load successfully.</li>
			</ol>
			<p>Now that we have covered the possible <strong class="source-inline">LoadState</strong> values for the <strong class="source-inline">refresh</strong> state, it's time to also cover the values for the <strong class="source-inline">append</strong> state. As we previously stated, type <strong class="source-inline">LoadState.append</strong> represents states that occur at the end of a subsequent request of paginated items. </p>
			<p>The possible states we're interested in for this scenario are the <strong class="source-inline">LoadState.Loading</strong> state—meaning the user has scrolled toward the end of the list and the app is waiting for another page with repositories—and the <strong class="source-inline">LoadState.Error</strong> state—meaning that the user has scrolled toward the end of the list but the request to get a new page with repositories has failed.</p>
			<ol>
				<li value="12">Inside the block of code exposed by the <strong class="source-inline">itemsIndexed()</strong> call from within the <strong class="source-inline">RepositoriesScreen()</strong> composable, just as we did with the <strong class="source-inline">refresh</strong> state, store the <strong class="source-inline">append</strong> state inside a new <strong class="source-inline">appendLoadState</strong> variable, and then add two corresponding branches<a id="_idIndexMarker1015"/> inside the <strong class="source-inline">when</strong> expression treating<a id="_idIndexMarker1016"/> the <strong class="source-inline">LoadState.Loading</strong> and<a id="_idIndexMarker1017"/> the <strong class="source-inline">LoadState.Error</strong> cases. The code<a id="_idIndexMarker1018"/> is illustrated<a id="_idIndexMarker1019"/> in the following<a id="_idIndexMarker1020"/> snippet:<p class="source-code">@Composable</p><p class="source-code">fun RepositoriesScreen(</p><p class="source-code">    repos: LazyPagingItems&lt;Repository&gt;</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        itemsIndexed(repos) { […] }</p><p class="source-code">        val refreshLoadState = repos.loadState.refresh</p><p class="source-code"><strong class="bold">        val appendLoadState = repos.loadState.append</strong></p><p class="source-code">        when {</p><p class="source-code">            refreshLoadState is LoadState.Loading -&gt; {</p><p class="source-code">                item {</p><p class="source-code">                    LoadingItem(...)</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">            refreshLoadState is LoadState.Error -&gt; {</p><p class="source-code">                val error = refreshLoadState.error</p><p class="source-code">                item {</p><p class="source-code">                    ErrorItem(</p><p class="source-code">                        message = error.localizedMessage</p><p class="source-code">                            ?: "",</p><p class="source-code">                        modifier = ...,</p><p class="source-code">                        onClick = { repos.retry() })</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">            <strong class="bold">appendLoadState is LoadState.Loading -&gt; {</strong></p><p class="source-code">                <strong class="bold">item {</strong></p><p class="source-code"><strong class="bold">                    LoadingItem(</strong></p><p class="source-code"><strong class="bold">                        Modifier.fillMaxWidth())</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code">            <strong class="bold">appendLoadState is LoadState.Error -&gt; {</strong></p><p class="source-code"><strong class="bold">                val error = appendLoadState.error</strong></p><p class="source-code"><strong class="bold">                item {</strong></p><p class="source-code"><strong class="bold">                    ErrorItem(</strong></p><p class="source-code"><strong class="bold">                        message = error.localizedMessage</strong></p><p class="source-code"><strong class="bold">                            ?: "",</strong></p><p class="source-code"><strong class="bold">                        onClick = { repos.retry() })</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The way we treated<a id="_idIndexMarker1021"/> the possible values<a id="_idIndexMarker1022"/> of <strong class="source-inline">appendLoadState</strong> is very<a id="_idIndexMarker1023"/> similar to how<a id="_idIndexMarker1024"/> we treated<a id="_idIndexMarker1025"/> the possible<a id="_idIndexMarker1026"/> values of <strong class="source-inline">refreshLoadState</strong>. However, the notable difference is that <strong class="source-inline">appendLoadState</strong> state values occur when the app has already loaded some pages and the user has scrolled toward the end of our list, meaning that our app is either waiting for a new page with repositories or failed to load it.</p>
			<p>That's why, in the <strong class="source-inline">LoadState.Loading</strong> case, we have passed the <strong class="source-inline">Modifier.fillMaxWidth()</strong> modifier to the <strong class="source-inline">LoadingItem()</strong> composable, therefore making sure that the loading indicator item appears at the bottom of the list as a list element. In other words, the loading element<a id="_idIndexMarker1027"/> will take only the available width<a id="_idIndexMarker1028"/> and it will not cover<a id="_idIndexMarker1029"/> the entire screen like<a id="_idIndexMarker1030"/> we did<a id="_idIndexMarker1031"/> when <strong class="source-inline">refreshLoadState</strong> was<a id="_idIndexMarker1032"/> of type <strong class="source-inline">LoadState.Loading</strong>.</p>
			<p>Similarly, for the <strong class="source-inline">LoadState.Error</strong> case, we passed the <strong class="source-inline">Modifier.fillMaxWidth()</strong> modifier to the <strong class="source-inline">ErrorItem()</strong> composable, therefore making sure that the error element appears as a list element and doesn't cover the entire screen like we did when <strong class="source-inline">refreshLoadState</strong> was of type <strong class="source-inline">LoadState.Error</strong>.</p>
			<p>Let's see these two cases in practice, and let's start with the case when our <strong class="source-inline">appendLoadState</strong> instance has a value of <strong class="source-inline">LoadState.Loading</strong>.</p>
			<ol>
				<li value="13">First, run the app while your test device is connected to the internet. If you scroll down to the bottom of the list with repositories, you should see the loading indicator animation displayed until a new page with repositories is loaded, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B17788_11_09.jpg" alt="Figure 11.9 – Adding a loading animation for a subsequent request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9 – Adding a loading animation for a subsequent request of paginated content</p>
			<p>Unlike the<a id="_idIndexMarker1033"/> loading indicator<a id="_idIndexMarker1034"/> that is shown<a id="_idIndexMarker1035"/> initially, this indicator appears<a id="_idIndexMarker1036"/> as an item within<a id="_idIndexMarker1037"/> the list, thereby indicating<a id="_idIndexMarker1038"/> that the app is waiting for a new page with repositories.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If your network speed is very fast, you might miss the loading spinner as you are scrolling through new pages. To simulate a slower connection, you can change the network speed of your Android emulator by going into <strong class="bold">AVD Manager</strong>, pressing the <strong class="bold">Edit</strong> button of your emulator, and then selecting <strong class="bold">Show Advanced Settings</strong>. Inside this menu, you can slow down the internet speed of your emulator so that you can see the loading spinner.</p>
			<p>Now, let's test the case when our <strong class="source-inline">appendLoadState</strong> instance is of type <strong class="source-inline">LoadState.Error</strong>.</p>
			<ol>
				<li value="14">First, run the app while your test device is connected to the internet.</li>
				<li>Then, disconnect your test device from the internet and scroll down to the bottom of the list with repositories. Initially, you<a id="_idIndexMarker1039"/> might see the loading indicator, yet after a short period <a id="_idIndexMarker1040"/>of time, you should see the error<a id="_idIndexMarker1041"/> element appearing<a id="_idIndexMarker1042"/> at the bottom of the list, as illustrated<a id="_idIndexMarker1043"/> in the following<a id="_idIndexMarker1044"/> screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B17788_11_10.jpg" alt="Figure 11.10 – Adding error element for a subsequent request of paginated content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10 – Adding error element for a subsequent request of paginated content</p>
			<p>Unlike the error message that is shown initially, this error element appears as an item in the list, thereby indicating that the app has failed to obtain the next page with repositories.</p>
			<ol>
				<li value="16">Optionally, you can reconnect your device to the internet and press the retry button—the new page with repositories should now load, so you can continue browsing and scrolling for more items.</li>
			</ol>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor325"/>Summary</h1>
			<p>In this chapter, we first understood what pagination is and how pagination can be used to expose large datasets of items to users in a more efficient manner.</p>
			<p>Then, we got to meet the Repositories App, a simple Android project where a fixed amount of GitHub repositories was displayed. At that point, we took the decision that users should be able to browse through a huge number of repositories that the GitHub Search API is exposing, so the only solution for that was to integrate paging within our app.</p>
			<p>However, we then realized that we needed to first understand the concept of data streams in the context of pagination, so we learned a few things about Kotlin Flow and how it can be a simple solution to consume paginated content.</p>
			<p>Then, we explored how the Jetpack Paging library is an elegant solution to adding pagination to our apps, culminating with the practical task of integrating paging in our Repositories App with the help of this library. Finally, we transformed our Repositories App into a modern application that creates the illusion of an infinite list of repositories, with initial and intermediary loading or error states, as well as retry functionality.</p>
			<p>In the next chapter, we will tackle yet another Jetpack subject—Lifecycle components!</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor326"/>Further reading</h1>
			<p>In this chapter, we briefly covered how you can integrate Jetpack Paging into an Android application. However, in the context of pagination and Jetpack Paging, there are a couple of more advanced topics that you might end up wondering about, as outlined here:</p>
			<ul>
				<li><strong class="bold">Having both a local and remote source for paginated content</strong>—For such a case, you will need a component that manages communication between the two data sources. For this task, you could use the built-in <strong class="source-inline">RemoteMediator</strong> API of the Paging library. You can learn more about it from its official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator">https://developer.android.com/topic/libraries/architecture/paging/v3-network-db#implement-remotemediator</a>.</li>
				<li><strong class="bold">Adding support for content refresh or invalidation</strong>—If you're looking to support pull-to-refresh functionality, or you're interested in making sure that the user is returned to the appropriate page upon various system events that could restart the paginated content, you need to obtain the refresh keys of the <strong class="source-inline">PagingSource</strong> component. Learn more about this from the official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys">https://developer.android.com/topic/libraries/architecture/paging/v3-migration#refresh-keys</a>.</li>
			</ul>
			<p>As you know by now, testing is very important. In the context of paging, testing can get a little trickier. If you're interested in learning how to test your paging app, check out the official documentation at <a href="https://developer.android.com/topic/libraries/architecture/paging/test">https://developer.android.com/topic/libraries/architecture/paging/test</a>.</p>
		</div>
	</body></html>