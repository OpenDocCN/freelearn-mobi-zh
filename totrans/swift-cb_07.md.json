["```swift\nimport UIKit\n\nstruct Color {\n    let red: Float\n    let green: Float\n    let blue: Float\n    let alpha: Float = 1.0\n\n    var displayColor: UIColor {\n        return UIColor(red: CGFloat(red),\n                       green: CGFloat(green),\n                       blue: CGFloat(blue),\n                       alpha: CGFloat(alpha))\n    }\n}\n```", "```swift\nstruct Bar {\n    var value: Float\n    var color: Color\n}\n\nclass BarView: UIView {\n\n    init(frame: CGRect, color: UIColor) {\n        super.init(frame: frame)\n        backgroundColor = color\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        backgroundColor = .red\n    }\n}\n```", "```swift\nclass BarChart: UIView {\n\n    private var barViews: [BarView] = []\n    private var maxValue: Float = 0.0\n\n    var interBarMargin: CGFloat = 5.0\n\n    var bars: [Bar] = [] {\n        didSet {\n            self.barViews.forEach { $0.removeFromSuperview() }\n\n            var barViews = [BarView]()\n\n            let barCount = CGFloat(bars.count)\n\n            // Calculate the max value before calculating size\n            for bar in bars {\n                maxValue = max(maxValue, bar.value)\n            }\n\n            var xOrigin: CGFloat = interBarMargin\n\n            let margins = interBarMargin * (barCount+1)\n            let width = (frame.width - margins) / barCount\n\n            for bar in bars {\n\n                let height = barHeight(forValue: bar.value)\n                let rect = CGRect(x: xOrigin, \n                                  y: bounds.height - height, \n                                  width: width, \n                                  height: height)\n                let view = BarView(frame: rect, \n                                   color: bar.color.displayColor)\n                barViews.append(view)\n                addSubview(view)\n\n                xOrigin = view.frame.maxX + interBarMargin\n            }\n            self.barViews = barViews\n        }\n    }\n\n    private func barHeight(forValue value: Float) -> CGFloat {\n        return (frame.size.height / CGFloat(maxValue)) * \n          CGFloat(value)\n    }\n}\n```", "```swift\nlet barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: \n  300))\nbarView.backgroundColor = .white\nlet bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))\nlet bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))\nlet bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))\nbarView.bars = [bar1, bar2, bar3]\n```", "```swift\nimport PlaygroundSupport\n```", "```swift\nPlaygroundPage.current.liveView = barView\n```", "```swift\nimport PlaygroundSupport\nimport Cocoa\n\nstruct Color {\n    let red: CGFloat\n    let green: CGFloat\n    let blue: CGFloat\n    let alpha: CGFloat = 1.0\n\n    var displayColor: NSColor {\n        return NSColor(calibratedRed: red, \n                       green: green, \n                       blue: blue, \n                       alpha: alpha)\n    }\n}\n```", "```swift\nstruct Bar {\n    var value: Float\n    var color: Color\n}\n\nclass BarView: NSView {\n\n    let color: NSColor\n\n    init(frame: NSRect, color: NSColor) {\n        self.color = color\n        super.init(frame: frame)\n    }\n\n    required init?(coder: NSCoder) {\n        self.color = .red\n        super.init(coder: coder)\n    }\n\n    override func draw(_ dirtyRect: NSRect) {\n        super.draw(dirtyRect)\n        color.set()\n        NSBezierPath.fill(dirtyRect)\n    }\n}\n```", "```swift\nclass BarChart: NSView {\n\n    let color: NSColor\n\n    init(frame: NSRect, color: NSColor) {\n        self.color = color\n        super.init(frame: frame)\n    }\n\n    required init?(coder: NSCoder) {\n        self.color = .white\n        super.init(coder: coder)\n    }\n\n    var bars: [Bar] = [] {\n        didSet {\n            self.barViews.forEach { $0.removeFromSuperview() }\n\n            var barViews = [BarView]()\n\n            let barCount = CGFloat(bars.count)\n\n            // Calculate the max value before calculating size\n            for bar in bars {\n                maxValue = max(maxValue, bar.value)\n            }\n\n            var xOrigin: CGFloat = interBarMargin\n\n            let margins = interBarMargin * (barCount+1)\n            let width = (frame.width - margins) / barCount\n\n            for bar in bars {\n\n                let height = barHeight(forValue: bar.value)\n                let rect = NSRect(x: xOrigin, \n                                  y: 0, \n                                  width: width, \n                                  height: height)\n                let view = BarView(frame: rect, \n                                   color: bar.color.displayColor)\n                barViews.append(view)\n                addSubview(view)\n\n                xOrigin = rect.maxX + interBarMargin\n            }\n            self.barViews = barViews\n        }\n    }\n    var interBarMargin: CGFloat = 5.0\n\n    private var barViews: [NSView] = []\n    private var maxValue: Float = 0.0\n\n    override func draw(_ dirtyRect: NSRect) {\n        super.draw(dirtyRect)\n        color.set()\n        NSBezierPath.fill(dirtyRect)\n    }\n\n    private func barHeight(forValue value: Float) -> CGFloat {\n        return (frame.size.height / CGFloat(maxValue)) * \n          CGFloat(value)\n    }\n}\n```", "```swift\nlet frame = CGRect(x: 0, y: 0, width: 300, height: 300)\nlet barView = BarChart(frame: frame,\n                       color: .white)\nPlaygroundPage.current.liveView = barView\nlet bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))\nlet bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))\nlet bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))\nbarView.bars = [bar1, bar2, bar3]\n\nPlaygroundPage.current.liveView = barView\n```", "```swift\nclass BarView: UIView {\n\n    init(frame: CGRect, color: UIColor) {\n        super.init(frame: frame)\n        backgroundColor = color\n        setupTexture()\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        backgroundColor = UIColor.red\n        setupTexture()\n    }\n\n    private func setupTexture() {\n        guard let textureImage = UIImage(named: \"texture\") else {\n          return }\n        let textureColor = UIColor(patternImage: textureImage)\n        let frame = CGRect(origin: .zero, size: bounds.size)\n        let textureView = UIView(frame: frame)\n        textureView.backgroundColor = textureColor\n        addSubview(textureView)\n    }\n}\n```", "```swift\nlet textureImage = UIImage(named: \"texture\")\n```", "```swift\nimport UIKit\n\npublic struct Color {\n    let red: Float\n    let green: Float\n    let blue: Float\n    let alpha: Float\n\n    public init(red:Float, green:Float, blue:Float, alpha:Float = 1) {\n        self.red = red\n        self.green = green\n        self.blue = blue\n        self.alpha = alpha\n    }\n\n    var displayColor: UIColor {\n        return UIColor(red: CGFloat(red),\n                       green: CGFloat(green),\n                       blue: CGFloat(blue),\n                       alpha: CGFloat(alpha))\n    }\n}\n```", "```swift\nimport UIKit\n\npublic struct Bar {\n    var value: Float\n    var color: Color\n\n    public init(value: Float, color: Color) {\n        self.value = value\n        self.color = color\n    }\n}\n\n```", "```swift\nclass BarView: UIView {\n\n    init(frame: CGRect, color: UIColor) {\n        super.init(frame: frame)\n        backgroundColor = color\n        setupTexture()\n    }\n\n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        backgroundColor = UIColor.red\n        setupTexture()\n    }\n\n    private func setupTexture() {\n        guard let textureImage = UIImage(named: \"texture\") else { \n          return }\n        let textureColor = UIColor(patternImage: textureImage)\n        let textureView = UIView(frame: bounds)\n        textureView.backgroundColor = textureColor\n        addSubview(textureView)\n    }\n}\n```", "```swift\npublic class BarChart: UIView {\n\n    private var barViews: [BarView] = []\n    private var maxValue: Float = 0.0\n\n    var interBarMargin: CGFloat = 5.0\n\n    public var bars: [Bar] = [] {\n        didSet {\n            self.barViews.forEach { $0.removeFromSuperview() }\n\n            var barViews = [BarView]()\n\n            let barCount = CGFloat(bars.count)\n\n            // Calculate the max value before calculating size\n            for bar in bars {\n                maxValue = max(maxValue, bar.value)\n            }\n\n            var xOrigin: CGFloat = interBarMargin\n\n            let margins = interBarMargin * (barCount+1)\n            let width = (frame.width - margins) / barCount\n\n            for bar in bars {\n\n                let height = barHeight(forValue: bar.value)\n                let rect = CGRect(x: xOrigin, \n                                  y: bounds.height - height, \n                                  width: width, \n                                  height: height)\n                let view = BarView(frame: rect, \n                                   color: bar.color.displayColor)\n                barViews.append(view)\n                addSubview(view)\n\n                xOrigin = view.frame.maxX + interBarMargin\n            }\n            self.barViews = barViews\n        }\n    }\n\n    private func barHeight(forValue value: Float) -> CGFloat {\n        return (frame.size.height / CGFloat(maxValue))*\n          CGFloat(value)\n    }\n}\n```", "```swift\nimport PlaygroundSupport\nimport UIKit\n\nlet barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: \n  300))\nbarView.backgroundColor = .white\nlet bar1 = Bar(value: 20, color: Color(red: 1, green: 0, blue: 0))\nlet bar2 = Bar(value: 40, color: Color(red: 0, green: 1, blue: 0))\nlet bar3 = Bar(value: 25, color: Color(red: 0, green: 0, blue: 1))\nbarView.bars = [bar1, bar2, bar3]\nPlaygroundPage.current.liveView = barView\n```", "```swift\nimport PlaygroundSupport\nimport UIKit\n\nlet frame = CGRect(x: 0, y: 0, width: 300, height: 300)\nlet barView = BarChart(frame: frame)\nbarView.backgroundColor = .white\n\nlet green =  Color(red: 0, green: 1, blue: 0)\n\nlet jan2020 = Bar(value: 9388.88, color: green)\nlet feb2020 = Bar(value: 8639.59, color: green)\nlet mar2020 = Bar(value: 6483.74, color: green)\nlet apr2020 = Bar(value: 8773.11, color: green)\nlet may2020 = Bar(value: 9437.05, color: green)\nlet jun2020 = Bar(value: 9164.54, color: green)\n\nbarView.bars = [jan2020,\n                feb2020,\n                mar2020,\n                apr2020,\n                may2020,\n                jun2020]\n\nPlaygroundPage.current.liveView = barView\n```", "```swift\nimport PlaygroundSupport\nimport UIKit\n\nlet frame = CGRect(x: 0, y: 0, width: 300, height: 300)\nlet barView = BarChart(frame: frame)\nbarView.backgroundColor = .white\n\nlet blue = Color(red: 0, green: 0, blue: 1)\n\nlet jan2020 = Bar(value: 181.73, color: blue)\nlet feb2020 = Bar(value: 223.5, color: blue)\nlet mar2020 = Bar(value: 133.76, color: blue)\nlet apr2020 = Bar(value: 209.42, color: blue)\nlet may2020 = Bar(value: 245.76, color: blue)\nlet jun2020 = Bar(value: 225.71, color: blue)\n\nbarView.bars = [jan2020,\n                feb2020,\n                mar2020,\n                apr2020,\n                may2020,\n                jun2020]\n\nPlaygroundPage.current.liveView = barView\n```", "```swift\nimport PlaygroundSupport\nimport UIKit\n\nlet frame = CGRect(x: 0, y: 0, width: 300, height: 300)\nlet barView = BarChart(frame: frame)\nbarView.backgroundColor = .white\n\nlet red = Color(red: 1, green: 0, blue: 0)\n\nlet jan2020 = Bar(value: 67.58, color: red)\nlet feb2020 = Bar(value: 58.09, color: red)\nlet mar2020 = Bar(value: 39.13, color: red)\nlet apr2020 = Bar(value: 46.19, color: red)\nlet may2020 = Bar(value: 44.23, color: red)\nlet jun2020 = Bar(value: 41.21, color: red)\n\nbarView.bars = [jan2020,\n                feb2020,\n                mar2020,\n                apr2020,\n                may2020,\n                jun2020]\n\nPlaygroundPage.current.liveView = barView\n```", "```swift\n/*:\n # Crypto Currencies\n ## Bitcoin\n */\n\nimport PlaygroundSupport\nimport UIKit\n\n/*:\n ### Usage\n * Create Bar Chart\n * Create Bars and add to chart\n * Make Bar Chart the LiveView\n */\nlet barView = BarChart(frame: CGRect(x: 0, y: 0, width: 300, height: \n  300))\nbarView.backgroundColor = .white\nlet green =  Color(red: 0, green: 1, blue: 0, alpha: 1.0)\n\n/*:\n * Note: \n Bitcoin Price (in USD)\n - Jan 2017 -  $970.17\n - Feb 2017 -  $960.05\n - Mar 2017 - $1203.02\n - Apr 2017 - $1076.90\n - May 2017 - $1390.24\n - Jun 2017 - $2414.11\n\nTaken from [Statista](https://www.statista.com/statistics/326707/bitcoin-price-index)\n */\nlet jan2017 = Bar(value: 970.17, color: green)\nlet feb2017 = Bar(value: 960.05, color: green)\nlet mar2017 = Bar(value: 1203.02, color: green)\nlet apr2017 = Bar(value: 1076.90, color: green)\nlet may2017 = Bar(value: 1390.24, color: green)\nlet jun2017 = Bar(value: 2414.11, color: green)\n\nbarView.bars = [jan2017, feb2017, mar2017, apr2017, may2017, jun2017]\nPlaygroundPage.current.liveView = barView\n```", "```swift\n//: [Next page](@next)\n//: [Previous page](@previous)\n```", "```swift\nlet name = value\n```", "```swift\nlet isSwitchedOn = true\nif isSwitchedOn {\n print(\"Switched On\")\n}\n```", "```swift\nimport UIKit\nimport PlaygroundSupport\n\nPlaygroundPage.current.needsIndefiniteExecution = true\n```", "```swift\nstruct RootResponse: Codable {\n    let response: [Response]?\n}\n\nstruct Response: Codable {\n    let id: String?\n    let quote: String\n}\n```", "```swift\nfunc fetchQuotes(completionHandler: @escaping ([Response]?) -> Void) \n  -> URLSessionDataTask? {\n\n    var session = URLSession.shared\n\n let urlString = \"https://api.bobross.dev/api/10\"\n\n    guard let url = URL(string: urlString) else {\n        return nil\n    }\n    var request = URLRequest(url: url)\n    let task = session.dataTask(with: request) { (data, response, \n      error) in\n\n        // First unwrap the optional data\n        guard let data = data else {\n            completionHandler(nil)\n            return\n        }\n\n        do {\n            let decoder = JSONDecoder()\n            let responseObject = try \n              decoder.decode(RootResponse.self, from: data)\n\n            completionHandler(responseObject.response)\n        } catch {\n            completionHandler(nil)\n        }\n    }\n    task.resume()\n\n    return task\n}\n```", "```swift\nfetchQuotes { (response) in\n    guard let quotes = response as? [Response] else { return }\n\n    for item in quotes {\n        print(item.quote ?? \"\")\n    }\n}\n```", "```swift\npublic struct RootResponse: Codable {\n    public let response: [Response]?\n}\n\npublic struct Response: Codable {\n    public let id: String?\n    public let quote: String\n}\n```", "```swift\nclass TableViewController: UITableViewController { }\n```", "```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Fetch Quotes code to go here\n\n}\n```", "```swift\nvar quotes = [String]()\nvar session = URLSession.shared\n```", "```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n fetchQuotes { (response) in\n\n guard let quotes = response as? [Response] else { return }\n for item in quotes {\n self.quotes.append(item.quote)\n }\n DispatchQueue.main.async {\n self.tableView.reloadData()\n }\n }\n\n}\n```", "```swift\noverride func numberOfSections(in tableView: UITableView) -> Int {\n    return 1\n}\n\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n    return quotes.count\n}\n```", "```swift\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\n    let quote = quotes[indexPath.row]\n    var cell = UITableViewCell()\n    if let _ = tableView.dequeueReusableCell(withIdentifier: \n      \"table.view.cell\") {\n        cell = UITableViewCell(style: .default, reuseIdentifier:\n          \"table.view.cell\")\n    }\n\n    cell.textLabel?.text = quote\n    return cell\n\n}\n```", "```swift\nPlaygroundPage.current.liveView = TableViewController()\n```", "```swift\nPlaygroundPage.current.needsIndefiniteExecution = true\n```"]