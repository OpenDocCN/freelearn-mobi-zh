<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Composing User Interfaces</h1>
                </header>
            
            <article>
                
<p>Mobile apps seem like simple systems, but they are often actually quite deep and complex systems, with many different parts that help them keep the appearance of being simple. The user interfaces of applications are the same; they may appear simple, but they are often complex arrangements of screens and dialogs designed to hide the complexities of the application from the user and provide a smoother experience. The easiest way to think about this is that traditional desktop applications and websites tend to be <em>wide</em>, while mobile applications tend to be <em>deep</em>.</p>
<p>This comment applies (on the surface at least) to the navigation of applications. Desktop applications tend to have a central <em>control</em> area where most of the work is done. Think of a document editor--the application centers around the document being written, and you never really <em>leave</em> that area. Instead of navigating away, dialogs pop up to fulfill a single task, which alters the document before they disappear. There are many variations on this theme, but desktop applications tend to follow the same pattern.</p>
<p>Mobile applications, on the other hand, tend to start at an <em>overview</em> screen of some sort, or launch directly into an <em>action</em> screen. The user then navigates <em>downward</em> into a task or item before either returning to the overview screen, or completing their task and being presented with a <em>result</em> of some sort (for example, booking a flight). <span>Achieving a goal by navigating away from the overview screen, rather than simply opening a dialog on top of the content, requires a different approach to your application's design</span>. As there is no central screen always available to the user, you often need to remind them of where they are, and what they are doing. This sort of repetition will be unthinkable on a desktop application where the information is always available in another window or panel of the application; however, on the limited space offered by a mobile phone, this becomes an essential tool to keep the user on track, and help them complete the task they are trying to fulfill.</p>
<p>This change in how the user navigates, requires that screens often present the same data, or have elements that are repeated all over the application. These elements are best encapsulated so that they can be easily reused throughout the application. Android offers the perfect way to encapsulate these groups of widgets in a way that can be more aware than a simple layout component--fragments. A <strong>Fragment</strong> is like a <em>miniature</em> <kbd>Activity</kbd>; each Fragment has a full life cycle, just like <kbd>Activity</kbd>, except that they are always contained within an <kbd>Activity</kbd> (refer to <a href="8b58d03e-232e-49ec-8aba-344b3ed81d2d.xhtml" target="_blank">Appendix A</a> for details of the <kbd>Activity</kbd> life cycle). Using fragments allows your application to more easily adapt to various screen sizes. We'll be taking a closer look at fragments later in this chapter.</p>
<p><span>In this chapter, we'll look at various ways to break up a user interface, building modules that can be layered and reused to form complex behaviors without requiring complex code and wiring. We'll be looking at the following:</span></p>
<ul>
<li>How to build custom groups of widgets that can be directly included in layouts</li>
<li>How to build Fragments that expose common functionality with a complete life cycle of their own</li>
<li>How to use ViewPager to display pages or tabs of widgets</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing a modular layout</h1>
                </header>
            
            <article>
                
<p>So far, you've built a single <kbd>Activity</kbd> class with a layout composed out of two layout files containing widgets. This is a pretty normal state of affairs, but it's not the best situation. Like in most user interfaces, the claim capturing screen can be divided into a range of very logical areas:</p>
<div class="CDPAlignCenter CDPAlign"><img height="218" width="303" src="assets/5f60df92-53cd-4554-9ba7-4e31ce4b843a.jpg"/></div>
<p>In an Android user interface, you always have the individual widgets (such as <kbd>Button</kbd>, <kbd>TextView</kbd>, <kbd>ImageView</kbd>, and friends) at the bottom level, and <kbd>Activity</kbd> at the top level, but when you look at that screen mockup, you can instantly see that the screen can be divided into other layers in between <kbd>Activity</kbd> and widget. You can, of course, take each of the <kbd>CardView</kbd> layouts from this screen and place them in their own layout XML files, and then import them:</p>
<pre class="mce-root">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;!-- card_claim_capture_info.xml --&gt;<br/>&lt;android.support.v7.widget.CardView<br/>   <br/>   <br/>   android:layout_width="match_parent"<br/>   android:layout_height="wrap_content"&gt;<br/><br/>  &lt;android.support.constraint.ConstraintLayout<br/>       android:layout_width="match_parent"<br/>       android:layout_height="match_parent"<br/>       android:layout_margin="@dimen/grid_spacer1"&gt;<br/>       &lt;android.support.design.widget.TextInputLayout<br/>           android:id="@+id/description_layout"<br/>           android:layout_width="0dp"<br/>           android:layout_height="wrap_content"<br/>           android:layout_marginEnd="8dp"<br/>           app:layout_constraintEnd_toStartOf="@+id/amount_layout"<br/>           app:layout_constraintStart_toStartOf="parent"<br/>           app:layout_constraintTop_toTopOf="parent"&gt;</pre>
<p>You can use the <kbd>&lt;include&gt;</kbd> element to include one layout file into another, like this:</p>
<pre>&lt;!-- content_capture_claim.xml --&gt;<br/>&lt;include layout="@layout/card_claim_capture_info"/&gt;</pre>
<p>This nicely separates out the layout for this part of the screen, allowing you to reuse it in layouts for larger physical screens or even in other <kbd>Activity</kbd> classes in the application. The problem is that every screen that wants to use this layout will need to also duplicate all the logic associated with it. While the logical decoupling of the logic and the layout is mostly a good thing (especially when you can overlay the logic on multiple different layouts), their coupling is normally quite tight.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the DatePickerLayout</h1>
                </header>
            
            <article>
                
<p>Each of these areas can easily be encapsulated in a Java class and reused elsewhere in your application. In <a href="75335d7f-3cda-4985-b992-965f46adc335.xhtml" target="_blank">Chapter 3</a>, <em>Taking Actions</em>, <span>you wrote the</span> <kbd>DatePickerWrapper</kbd> class, which can turn any <kbd>TextView</kbd> widget into a date selection widget. However, <kbd>DatePickerWrapper</kbd> doesn't create the <kbd>TextView</kbd> <span>label</span> or change the styling of the widgets to look like <kbd>TextInputLayout</kbd>. This means that you need to copy that styling into each layout where you want a date-picker, which can quickly lead to inconsistencies in your user interface. While it's good to have the events and state decoupled from the display logic, it would also be nice to have them grouped together in a single structure that can be reused without every layout having to specify the date picker widgets by hand, and then bind them to the <kbd>DatePickerWrapper</kbd> in its code.</p>
<p>While it's not obvious at first, the Android layout XML files can reference any <kbd>View</kbd> class and not just those defined in the core and support packages, and it can do so without any special tricks. All you need to do is reference the <kbd>View</kbd> class by its fully-qualified name, much like you've already done for several widgets:</p>
<ul>
<li style="font-weight: 400"><kbd>android.support.constraint.ConstraintLayout</kbd></li>
<li style="font-weight: 400"><kbd>android.support.v7.widget.CardView</kbd></li>
<li style="font-weight: 400"><kbd>android.support.design.widget.TextInputLayout</kbd></li>
</ul>
<p>All the preceding are classes that you can look up in Android Studio, and even read their code if you like. Let's get started by writing a <kbd>DatePickerLayout</kbd> to couple the layout XML with the <kbd>DatePickerWrapper</kbd>, and make the date picker reusable from any layout XML file in your application:</p>
<ol>
<li>In the Android panel of Android Studio, right-click on the <span class="packt_screen">layout</span> directory under <span class="packt_screen">res</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="109" width="185" src="assets/ee95da20-5eb2-40a0-a6b4-b86b058794d8.png"/></div>
<ol start="2">
<li style="font-weight: 400">Select <span class="packt_screen">New</span> | <span class="packt_screen">Layout resource file</span>.</li>
<li style="font-weight: 400">Name the new layout file as <kbd>widget_date_picker</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Root element</span> field to <kbd>merge</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="115" width="596" src="assets/0fb35182-414c-430f-8a77-159e36ca6774.png"/></div>
<div class="packt_infobox">
<p><kbd>merge</kbd> is a special root element for layout files. Normally, the root element of a layout file is a <kbd>View</kbd> class that results in the file having a root widget when it's inflated. The <kbd>merge</kbd> element doesn't create a root widget; instead, it's effectively skipped when the file is loaded, and its children are inflated directly. This makes it ideal for creating layout widgets, or reusable bits of layout, while also keeping the layout hierarchy flat and helping improve your application's performance.</p>
</div>
<ol start="5">
<li style="font-weight: 400">Change the editor mode to <span class="packt_screen">Text</span> instead of <span class="packt_screen">Design</span>.</li>
<li style="font-weight: 400">Remove the <kbd>layout_width</kbd> and <kbd>layout_height</kbd> attributes from the <kbd>merge</kbd> element.</li>
<li style="font-weight: 400">Write the following two <kbd>TextView</kbd> widgets into the merge element:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;merge &gt;<br/>   &lt;TextView<br/>       android:layout_width="match_parent"<br/>       android:layout_height="wrap_content"<br/>       android:text="@string/label_date"<br/>       android:textAppearance="@style/TextAppearance.AppCompat.Caption"<br/>       android:textColor="@color/colorAccent" /&gt;<br/>   &lt;TextView<br/>       style="@style/Widget.AppCompat.EditText"<br/>       android:layout_width="match_parent"<br/>       android:layout_height="wrap_content"<br/>       android:layout_marginTop="@dimen/grid_spacer1" /&gt;<br/>&lt;/merge&gt;</pre>
<div class="packt_tip">
<p>In the preceding file, there are no <kbd>id</kbd> attributes set; this is because any layout the new widget is used in will be polluted with those <kbd>id</kbd> attributes, and <kbd>findViewById</kbd> can easily start returning unexpected results. When encapsulating parts of your layout, always consider what <kbd>id</kbd> values will appear in the layout, and where they might be used in code. <kbd>findViewById</kbd> simply finds the <em>first</em> matching <kbd>View</kbd> object in the layout and returns it, and doesn't consider where that <kbd>View</kbd> might have come from (that is: an <kbd>&lt;include&gt;</kbd>, or special <kbd>View</kbd> class).</p>
</div>
<ol start="8">
<li style="font-weight: 400">In the <span class="packt_screen">Android</span> panel of Android Studio, right-click on your <kbd>base</kbd> package (that is, <kbd>com.packtpub.claim</kbd>):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="193" width="358" src="assets/1b9d0772-6c90-47e1-9fa4-79f2067ac612.png"/></div>
<ol start="9">
<li style="font-weight: 400">Select <span class="packt_screen">New</span> and <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>widget.DatePickerLayout</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Superclass</span> to <kbd>android.widget.LinearLayout</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new package and class.</li>
<li style="font-weight: 400">Declare fields in the <span><kbd>DatePickerLayout</kbd></span> for to reference a <kbd>TextView</kbd> label, and the <kbd>DatePickerWrapper</kbd> :</li>
</ol>
<pre style="padding-left: 60px">private TextView label;<br/>private DatePickerWrapper wrapper;</pre>
<ol start="14">
<li>Any class accessible from a layout XML requires several constructor overloads, so it's best to create a single <kbd>initialize</kbd> method that can be reused for all of them:</li>
</ol>
<pre style="padding-left: 60px">void initialize(final Context context) {<br/>   setOrientation(VERTICAL);<br/>}</pre>
<ol start="15">
<li>Still within the <kbd>initialize</kbd> method, use <kbd>LayoutInflator</kbd> to load the layout XML file you wrote, adding its contents as elements to the <kbd>DatePickerLayout</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">LayoutInflater.from(context).inflate(<br/>  R.layout.widget_date_picker, this, true);</pre>
<div class="packt_infobox">The parameters for the inflate method are the layout resource, the <kbd>ViewGroup</kbd> (in this case, <kbd>DatePickerLayout</kbd>) that will contain the layout, and whether or not to actually attach the elements of the layout resource to the <kbd>ViewGroup</kbd>. As you are using a merge element in the layout resource, the third parameter must be <kbd>true</kbd>, because otherwise the contents of the layout will be lost.</div>
<ol start="16">
<li>Use <kbd>getChildAt</kbd> to retrieve the new <kbd>TextView</kbd> elements that have been loaded by the <kbd>LayoutInflator</kbd>, and assign the fields of the <kbd>DatePickerLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px">label = (TextView) getChildAt(0);<br/>wrapper = new DatePickerWrapper((TextView) getChildAt(1));</pre>
<ol start="17">
<li>Overload the constructors and invoke the <kbd>initialize</kbd> method in each of them:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public DatePickerLayout(Context context) {<br/>  super(context);<br/>  initialize(context);<br/>}<br/><br/>public DatePickerLayout(Context context, AttributeSet attrs) {<br/>  super(context, attrs);<br/>  initialize(context);<br/>}<br/><br/>public DatePickerLayout(<br/>    Context context, AttributeSet attrs, int defStyleAttr) {<br/>  super(context, attrs, defStyleAttr);<br/>  initialize(context);<br/>}</pre>
<ol start="18">
<li>Create getters and setters to make the <kbd>DatePickerLayout</kbd> usable from the <kbd>Activity</kbd> classes:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public void setDate(final Date date) {<br/>   wrapper.setDate(date);<br/>}<br/><br/>public Date getDate() {<br/>   return wrapper.getDate();<br/>}<br/><br/>public void setLabel(final CharSequence text) {<br/>   label.setText(text);<br/>}<br/><br/>public void setLabel(final int resid) {<br/>   label.setText(resid);<br/>}<br/><br/>public CharSequence getLabel() {<br/>   return label.getText();<br/>}</pre>
<ol start="19">
<li>As the <kbd>DatePickerLayout</kbd> contains some of the user-interface state (the currently selected date), it's expected to keep track of this through <span>possible</span> <kbd>Activity</kbd> <span>restarts, if required</span> <span>(an <kbd>Activity</kbd> is recreated every time the user changes between portrait and landscape, as these are considered <em>configuration</em> changes)</span>. This will involve saving its state to a <kbd>Parcel</kbd>, and restoring it from a <kbd>Parcel</kbd> when requested to (a <kbd>Parcel</kbd> is a bit like a <kbd>byte[]</kbd> of <kbd>Serialized</kbd> objects, except that all the marshaling work needs to be implemented). You'll need an inner class that can hold the state of the <kbd>DatePickerLayout</kbd> (and it's parent class--<kbd>LinearLayout</kbd>). For convenience, the <kbd>View</kbd> class provides a <kbd>BaseSavedState</kbd> abstract class to take care of some of the implementation for you, so extend <kbd>BaseSavedState</kbd> in a static inner class named <kbd>SavedState</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">private static class SavedState extends BaseSavedState {<br/>   final long timestamp;<br/>   final CharSequence label;<br/><br/>   public SavedState(<br/>           final Parcelable superState,<br/>           final long timestamp,<br/>           final CharSequence label) {<br/><br/>       super(superState);<br/>       this.timestamp = timestamp;<br/>       this.label = label;<br/>   }<br/>}</pre>
<div class="packt_infobox">Objects crossing between <kbd>Activity</kbd> <span>instances need to be</span> <kbd>Parcelable</kbd><span>, because Android may need to store the objects temporarily through the</span> <kbd>Activity</kbd> <span>life cycle. Being able to store just the important bits of data and state, instead of the entire widget tree, is very useful for conserving memory when the user has a lot of applications running. <kbd>BaseSavedState</kbd> implements <kbd>Parcelable</kbd> and will allow the <kbd>DatePickerLayout</kbd> to remember its state when the <kbd>Activity</kbd> is destroyed and recreated by the system.</span></div>
<ol start="20">
<li><kbd>SavedState</kbd> will also need a constructor to load its fields from a <kbd>Parcel</kbd> object; a <kbd>CharSequence</kbd> cannot be read directly from a <kbd>Parcel</kbd>, but fortunately, <kbd>TextUtils</kbd> has a nice helper for reading <kbd>CharSequence</kbd> objects from <kbd>Parcel</kbd> objects for you:</li>
</ol>
<pre style="padding-left: 60px">SavedState(final Parcel in) {<br/>  super(in);<br/>  this.timestamp = in.readLong();<br/>  this.label = TextUtils.CHAR_SEQUENCE_CREATOR<br/>      .createFromParcel(in);<br/>}</pre>
<ol start="21">
<li>Then, <kbd>SavedState</kbd> needs the <kbd>writeToParcel</kbd> method implemented in order to actually write those fields to a <kbd>Parcel</kbd>; part of this is delegated to the <kbd>BaseSavedState</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void writeToParcel(final Parcel out, final int flags) {<br/>   super.writeToParcel(out, flags);<br/>   out.writeLong(timestamp);<br/>   TextUtils.writeToParcel(label, out, flags);<br/>}</pre>
<ol start="22">
<li>Every <kbd>Parcelable</kbd> implementation requires a special <kbd>public static final</kbd> field called <kbd>CREATOR</kbd>, which will be used by the <kbd>Parcel</kbd> system to create instances and arrays of the <kbd>Parcelable</kbd> objects. This also applies for every subclass, so write the following static final into the <kbd>SavedState</kbd> class:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =<br/>      new Parcelable.Creator&lt;SavedState&gt;() {<br/>  @Override<br/>  public SavedState createFromParcel(final Parcel source) {<br/>    return new SavedState(source);<br/>  }<br/><br/>  @Override<br/>  public SavedState[] newArray(int size) {<br/>    return new SavedState[size];<br/>  }<br/>};</pre>
<div class="packt_tip">When implementing a vanilla <kbd>Parcelable</kbd> class, Android Studio has a nice generator that can be triggered from the class declaration hints (look for "<span class="packt_screen">Add Parcelable Implementation</span>") that will write a simple <kbd>writeToParcel</kbd> method, <kbd>Parcel</kbd> handling constructor, and the <kbd>CREATOR</kbd> field. Check whether it's working though; it skips any field it doesn't know how to handle.</div>
<ol start="23">
<li>In the <kbd>DatePickerLayout</kbd> class, you need to override the <kbd>onSaveInstanceState</kbd> method and create the <kbd>SavedState</kbd> object that will be recorded:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected Parcelable onSaveInstanceState() {<br/>  return new SavedState(<br/>      super.onSaveInstanceState(),<br/>      getDate().getTime(), getLabel());<br/>}</pre>
<ol start="24">
<li>You'll also need to restore the state from a <kbd>SavedState</kbd> object, which requires overriding <kbd>onRestoreInstanceState</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>protected void onRestoreInstanceState(final Parcelable state) {<br/>   final SavedState savedState = (SavedState) state;<br/>   super.onRestoreInstanceState(savedState.getSuperState());<br/>   setDate(new Date(savedState.timestamp));<br/>   setLabel(savedState.label);<br/>}</pre>
<ol start="25">
<li style="font-weight: 400">Open the <kbd>content_capture_claim.xml</kbd> layout file in Android Studio.</li>
<li style="font-weight: 400">Change to the <span class="packt_screen">Text</span> editor, if required.</li>
<li style="font-weight: 400">Find the two <kbd>TextView</kbd> elements that describe the date-picker, and replace them with the following snippet:</li>
</ol>
<pre style="padding-left: 60px">&lt;com.packtpub.claim.widget.DatePickerLayout<br/>   android:id="@+id/date"<br/>   android:layout_width="0dp"<br/>   android:layout_height="wrap_content"<br/>   android:layout_marginTop="8dp"<br/>   app:layout_constraintEnd_toEndOf="parent"<br/>   app:layout_constraintStart_toStartOf="parent"<br/>   app:layout_constraintTop_toBottomOf="@+id/description_layout" /&gt;</pre>
<ol start="28">
<li style="font-weight: 400">Open the <kbd>CaptureClaimActivity</kbd> class in Android Studio.</li>
<li style="font-weight: 400">Replace the references to <kbd>DatePickerWrapper</kbd> with <kbd>DatePickerLayout</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>private DatePickerLayout selectedDate;</strong><br/><br/>@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>  // …<br/>  <span>selectedDate = new DatePickerWrapper(    // remove this line<br/>      (TextView) findViewById(R.id.date)); // remove this line</span><br/>  <strong>selectedDate = (DatePickerLayout) findViewById(R.id.date);</strong><br/>  // …<br/>}</pre>
<p>This new <kbd>DatePickerLayout</kbd> class allows you to reuse the same label and editor in any layout XML file in your application, while also coupling the required events in a single class. Any time you have a layout with <kbd>TextViewLayout</kbd> widgets, the new <kbd>DatePickerLayout</kbd> will fit right into the style and allow for safe date selection. It's also very important to implement the <kbd>onSaveInstanceState</kbd>/<kbd>onRestoreInstanceState</kbd> method on <kbd>View</kbd> subclasses if you intend to carry any state. These classes are marshaled, and new instances of the <kbd>View</kbd> are created every time a configuration state changes, which includes actions such as the user rotating the device (refer to <a href="192d8c3c-7167-43cf-ae76-9c841f4ec1d2.xhtml" target="_blank">Appendix A</a> for more information on <kbd>Activity</kbd> life cycle).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the data model</h1>
                </header>
            
            <article>
                
<p>At this point in the application, it's time to build a simple data model that the user interface will back onto. Each claim will be represented by a <kbd>ClaimItem</kbd> object, and will contain any number of <kbd>Attachment</kbd> objects, each of which will reference the <kbd>File</kbd> that was attached, and have a marker to help decide how the attachment should be previewed. All these classes will need to be <kbd>Parcelable</kbd>, because they need to be saved in the <kbd>CaptureClaimActivity</kbd>. The <kbd>CaptureClaimActivity</kbd> will also use them as input and output parameters, and any time an object needs to be passed as a parameter to or from an <kbd>Activity</kbd>, it needs to be <kbd>Parcelable</kbd>.</p>
<p>You'll also be creating a <kbd>Category</kbd> enum that links the Android IDs to an internal model that can be stored without having to worry about the Android IDs changing their values as the application evolves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Attachment class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Attachment</kbd> class represents files that have been attached to a <kbd>ClaimItem</kbd> by the user. These should always be files accessible by the application, and later on, we'll take steps to ensure this by copying all the attachments into a private space before attaching them to a claim item. For now, follow these steps to create the <kbd>Attachment</kbd> class:</p>
<ol>
<li style="font-weight: 400">In the <span class="packt_screen">Android</span> panel, right-click on your default package (that is, <kbd>com.packtpub.claim</kbd>) and select <span class="packt_screen">New|</span> <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class as <kbd>model.Attachment</kbd>, and in the <span class="packt_screen">Interface(s)</span> box, add <kbd>Parcelable</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="130" width="519" src="assets/47ff5cc6-2cfe-4906-bb56-d25f03734c85.png"/></div>
<ol start="3">
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new package and class.</li>
<li style="font-weight: 400">Attachments have different types, which can affect how they are previewed; for now, you'll just have images and unknown types. Inside the new <kbd>Attachment</kbd> class, create an <kbd>enum</kbd> to represent these types:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public enum Type {<br/>  IMAGE,<br/>  UNKNOWN;<br/><br/>  public static Type safe(final Type type) {<br/>    // Use a ternary to replace null with UNKNOWN<br/>    return type != null ? type : UNKNOWN;<br/>  }<br/>}</pre>
<ol start="5">
<li>In the <kbd>Attachment</kbd> class, declare its fields, a constructor, and getters and setters:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">File file;<br/>Type type;<br/><br/>public Attachment(final File file, final Type type) {<br/> this.file = file;<br/> this.type = Type.safe(type);<br/>}<br/><br/>public File getFile() { return file; }<br/>public void setFile(final File file) {<br/>  this.file = file;<br/>}<br/><br/>public Type getType() { return type; }<br/>public void setType(final Type type) {<br/>  this.type = Type.safe(type);<br/>}</pre>
<ol start="6">
<li>Now, create the <kbd>Parcelable</kbd> implementation for the <kbd>Attachment</kbd> class. This is best done by hand in this case, as neither <kbd>File</kbd> nor the <kbd>Type</kbd> <kbd>enum</kbd> will be understood by Android Studio's <kbd>Parcelable</kbd> generator:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">protected Attachment(final Parcel in) {<br/>  file = new File(in.readString());<br/>  type = Type.values()[in.readInt()];<br/>}<br/><br/>@Override<br/>public void writeToParcel(final Parcel dest, final int flags) {<br/>  dest.writeString(file.getAbsolutePath());<br/>  dest.writeInt(type.ordinal());<br/>}<br/><br/>@Override<br/>public int describeContents() { return 0; }</pre>
<ol start="7">
<li>Finally, at the top of the <kbd>Attachment</kbd> class, add its <kbd>Parcelable.Creator</kbd> instance:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public static final Creator&lt;Attachment&gt; CREATOR = new Creator&lt;Attachment&gt;() {<br/>  @Override<br/>  public Attachment createFromParcel(final Parcel in) {<br/>    return new Attachment(in);<br/>  }<br/><br/>  @Override<br/>  public Attachment[] newArray(final int size) {<br/>    return new Attachment[size];<br/>  }<br/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Category enum</h1>
                </header>
            
            <article>
                
<p>The next part of the model is the <kbd>Category</kbd> enumeration. This will serve a double purpose--when you change the list of available resources in your application, their IDs can all change. This makes these IDs unsuited to long-term identification of items; however, they are very useful as identifiers while the application is running:</p>
<ul>
<li style="font-weight: 400">They are unique within the application</li>
<li style="font-weight: 400">They are integer types, which are very fast for comparisons</li>
<li style="font-weight: 400">They can be used to directly identify user-interface components</li>
</ul>
<p>The <kbd>Category</kbd> enum will serve as a way to bind between a long-term stable identifier (the enum name), and the potentially unstable (but often much faster) Android resource ID. Follow these quick steps to create the <kbd>Category</kbd> enum:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>model</kbd> package, and select <span class="packt_screen">New</span> | <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the class <kbd>Category</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Kind</span> field to <span class="packt_screen">Enum</span>.</li>
</ol>
<ol start="4">
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new enum file.</li>
<li style="font-weight: 400">Declare the enum constants, and map them to their appropriate Android resource IDs:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">ACCOMMODATION(R.id.accommodation),<br/>FOOD(R.id.food),<br/>TRANSPORT(R.id.transport),<br/>ENTERTAINMENT(R.id.entertainment),<br/>BUSINESS(R.id.business),<br/>OTHER(R.id.other);</pre>
<ol start="6">
<li>Declare the ID integer, private constructor, and getter method for the ID. Note the use of the <kbd>@IdRes</kbd> annotation, which indicates what should be used for these specific integers; attempting to pass anything other than an ID resource in here will result in a lint error in Android Studio:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">@IdRes<br/>private final int idResource;<br/><br/>Category(@IdRes final int idResource) {<br/>  this.idResource = idResource;<br/>}<br/><br/>@IdRes<br/>public int getIdResource() {<br/>  return idResource;<br/>}</pre>
<div class="packt_tip">There are annotations similar to <kbd>@IdRes</kbd> for all of the different resource types available on Android. They are located in the <kbd>android.support.annotation</kbd> package. Use them wherever you expect an integer value to reference an Android resource of some type.</div>
<ol start="7">
<li style="font-weight: 400">Finally, create a method to look up a <kbd>Category</kbd> enum constant from its Android ID resource:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public static Category forIdResource(@IdRes final int id) {<br/>  for (final Category c : values()) {<br/>    if (c.idResource == id) {<br/>      return c;<br/>    }<br/>  }<br/><br/>  throw new IllegalArgumentException("No category for ID: " + id);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the ClaimItem class</h1>
                </header>
            
            <article>
                
<p>The <strong>ClaimItem</strong> is the heart of this application's object model. Each claim the user collects is represented in memory as a single <kbd>ClaimItem</kbd> instance. Here are the steps required to build the <kbd>ClaimItem</kbd> class:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>model</kbd> package, and select <span class="packt_screen">New</span> | <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the class <kbd>ClaimItem</kbd>, and in the <span class="packt_screen">Interface(s)</span> box, add <kbd>Parcelable</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new class file.</li>
<li style="font-weight: 400">Declare the fields of the <kbd>ClaimItem</kbd> type, and a <kbd>public</kbd> default constructor:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">String description;<br/>double amount;<br/>Date timestamp;<br/>Category category;<br/>List&lt;Attachment&gt; attachments = new ArrayList&lt;&gt;();<br/><br/>public ClaimItem() {}</pre>
<ol start="5">
<li>Use Android Studio to generate getter and setter methods for all the fields, except the attachments field:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public String getDescription() { return description; }<br/>public void setDescription(final String description) {<br/>  this.description = description;<br/>}<br/>public double getAmount() { return amount; }<br/>public void setAmount(final double amount) {<br/>  this.amount = amount;<br/>}<br/>public Date getTimestamp() { return timestamp; }<br/>public void setTimestamp(final Date timestamp) {<br/>  this.timestamp = timestamp;<br/>}<br/>public Category getCategory() { return category; }<br/>public void setCategory(final Category category) {<br/>  this.category = category;<br/>}</pre>
<ol start="6">
<li>Create methods to add, remove, and list the <kbd>Attachment</kbd> objects for the <kbd>ClaimItem</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public void addAttachment(final Attachment attachment) {<br/>  if ((attachment != null) &amp;&amp; !attachments.contains(attachment)) {<br/>   attachments.add(attachment);<br/>  }<br/>}<br/><br/>public void removeAttachment(final Attachment attachment) {<br/>  attachments.remove(attachment);<br/>}<br/><br/>public List&lt;Attachment&gt; getAttachments() {<br/>  return Collections.unmodifiableList(attachments);<br/>}</pre>
<ol start="7">
<li>Implement the <kbd>Parcelable</kbd> methods for the <kbd>ClaimItem</kbd> class; again, this is more complex than the Android Studio generator can typically handle:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">protected ClaimItem(final Parcel in) {<br/>  description = in.readString();<br/>  amount = in.readDouble();<br/><br/>  final long time = in.readLong();<br/>  timestamp = time != -1 ? new Date(time) : null;<br/><br/>  final int categoryOrd = in.readInt();<br/>  category = categoryOrd != -1<br/>      ? Category.values()[categoryOrd]<br/>      : null;<br/><br/>  in.readTypedList(attachments, Attachment.CREATOR);<br/>}<br/><br/>@Override<br/>public void writeToParcel(final Parcel dest, final int flags) {<br/>  dest.writeString(description);<br/>  dest.writeDouble(amount);<br/>  dest.writeLong(timestamp != null ? timestamp.getTime() : -1);<br/>  dest.writeInt(category != null ? category.ordinal() : -1);<br/>  dest.writeTypedList(attachments);<br/>}<br/><br/>@Override<br/>public int describeContents() { return 0; }<br/><br/>public static final Creator&lt;ClaimItem&gt; CREATOR = new Creator&lt;ClaimItem&gt;() {<br/>  @Override<br/>  public ClaimItem createFromParcel(Parcel in) {<br/>  return new ClaimItem(in);<br/>  }<br/><br/>  @Override<br/>  public ClaimItem[] newArray(int size) {<br/>  return new ClaimItem[size];<br/>  }<br/>};</pre>
<p>Excellent! With the formality of an object model out of the way, you can continue building the user interface. The next stage will involve building <kbd>Fragment</kbd> classes that will help modularize the capturing of the <kbd>ClaimItem</kbd> data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wrapping up the category picker</h1>
                </header>
            
            <article>
                
<p>The category picker you created for the <kbd>CaptureClaimActivity</kbd> is just a group of widgets in a card right now, and while it's one of the simplest cards to use on the screen, it's also one of the largest by the amount of code written for it. The best way to encapsulate this part of the screen is to move the layout that appears inside the <kbd>CardView</kbd> into a <kbd>Fragment</kbd> class.</p>
<p>However, why a <kbd>Fragment</kbd> class, and why not write another <kbd>Layout</kbd> class? <kbd>Fragment</kbd> classes are self-contained systems, and have their own life cycle within the context of their parent <kbd>Activity</kbd>. This means they can contain significantly more application logic, and can be reused more easily in other parts of the application. It's also because in this case, we rely on the IDs of the radio buttons to know what has been checked by the user, which means that we can very easily start polluting layouts with IDs specific to this specific widget. Fragment classes don't stop this from happening, but it's expected behavior. You don't expect ID pollution from <kbd>View</kbd> classes, but from a <kbd>Fragment</kbd>, it's okay. Follow these simple steps to encapsulate the category picker in a new <kbd>Fragment</kbd> class:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>ui</kbd> package in your project and select <span class="packt_screen">New|</span> <span class="packt_screen">Fragment |</span> <span class="packt_screen">Fragment (Blank)</span>.</li>
<li style="font-weight: 400">Name the new <kbd>Fragment</kbd> class <kbd>CategoryPickerFragment</kbd>.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Turn off <span class="packt_screen">Include fragment factory methods?</span> and <span class="packt_screen">Include interface callbacks</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/56299f89-cc3c-4035-a157-319351dc8804.png"/></div>
<ol start="4">
<li style="font-weight: 400">Click on <span class="packt_screen">Finish</span> to create your new <kbd>Fragment</kbd> and its layout file.</li>
<li style="font-weight: 400">Open the new <kbd>fragment_category_picker.xml</kbd> file, and change the editor view to <span class="packt_screen">Text</span> mode.</li>
<li style="font-weight: 400">Change the root node of the layout from <kbd>FrameLayout</kbd> to <kbd>LinearLayout</kbd>, and make it a <kbd>vertical</kbd> orientation:</li>
</ol>
<pre>&lt;LinearLayout<br/>   <br/>   <br/>   android:layout_width="match_parent"<br/>   android:layout_height="match_parent"<br/>   android:orientation="vertical"<br/>   tools:context="com.packtpub.claim.ui.CategoryPickerFragment"&gt;</pre>
<ol start="7">
<li style="font-weight: 400">Remove any contents of the <kbd>LinearLayout</kbd> placed there by the Android Studio template.</li>
<li style="font-weight: 400">Open the <kbd>content_capture_claim.xml</kbd> layout file, and change the editor view to <span class="packt_screen">Text</span> mode.</li>
<li style="font-weight: 400">Cut the contents of the <kbd>LinearLayout</kbd> containing the existing category picker, the entire <kbd>RadioGroup</kbd> and <kbd>TextView</kbd> used as their label.</li>
<li style="font-weight: 400">Paste this as the content of the <kbd>LinearLayout</kbd> in the <kbd>fragment_category_picker.xml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout <br/>  android:layout_width="match_parent"<br/>  android:layout_height="match_parent"<br/>  android:orientation="vertical"&gt;<br/><br/>  &lt;RadioGroup<br/>      android:id="@+id/categories"<br/>      android:layout_width="match_parent"<br/>      android:layout_height="wrap_content"<br/>      android:orientation="horizontal"&gt;<br/><br/>      &lt;RadioButton<br/>          android:id="@+id/accommodation"<br/>          android:layout_width="wrap_content"<br/>          android:layout_height="wrap_content"<br/>          android:layout_marginEnd="@dimen/grid_spacer1"<br/>          android:layout_marginRight="@dimen/grid_spacer1"<br/>          android:button="@drawable/ic_category_hotel"<br/>          android:contentDescription="@string/description_accommodation" /&gt;<br/><br/>      &lt;!-- ... --&gt;<br/>  &lt;/RadioGroup&gt;<br/><br/>  &lt;TextView<br/>      android:id="@+id/selected_category"<br/>      android:layout_width="match_parent"<br/>      android:layout_height="wrap_content"<br/>      android:textAppearance="@style/TextAppearance.AppCompat.Medium" /&gt;<br/>&lt;/LinearLayout&gt;</pre>
<ol start="11">
<li>In the <kbd>content_capture_claim.xml</kbd> layout file, you can now remove the <kbd>LinearLayout</kbd> for the category picker and replace it with a reference to the <kbd>Fragment</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.CardView<br/>  android:layout_width="match_parent"<br/>  android:layout_height="wrap_content"<br/>  android:layout_marginTop="@dimen/grid_spacer1"&gt;<br/><br/>  &lt;fragment<br/>      class="com.packtpub.claim.ui.CategoryPickerFragment"<br/>      android:id="@+id/categories"<br/>      android:layout_width="match_parent"<br/>      android:layout_height="match_parent"<br/>      android:layout_margin="@dimen/grid_spacer1"/&gt;<br/><br/>&lt;/android.support.v7.widget.CardView&gt;</pre>
<ol start="12">
<li>Now, open the <kbd>CategoryPickerFragment</kbd> class in Android Studio, and at the top of the class, declare the fields for the <kbd>RadioGroup</kbd> and <kbd>TextView</kbd> that you'll use to track and update the user's selection:</li>
</ol>
<pre style="padding-left: 60px">private RadioGroup categories;<br/>private TextView categoryLabel;</pre>
<ol start="13">
<li>Now in the <kbd>onCreateView</kbd>, you'll need to change how the <kbd>View</kbd> is inflated, because you need to capture the fields and set up the event listeners. Note the use of the <kbd>IconPickerWrapper</kbd> as the event listener:</li>
</ol>
<pre style="padding-left: 60px">public View onCreateView(<br/>      final LayoutInflater inflater,<br/>      final @Nullable ViewGroup container,<br/>      final @Nullable Bundle savedInstanceState) {<br/><br/>  final View picker = inflater.inflate(<br/>      R.layout.fragment_category_picker,<br/>      container,<br/>      false<br/>  );<br/><br/>  categories = (RadioGroup) picker.findViewById(R.id.categories);<br/>  categoryLabel = (TextView) picker.findViewById(<br/>      R.id.selected_category);<br/>  categories.setOnCheckedChangeListener(<br/>      new IconPickerWrapper(categoryLabel));<br/>  categories.check(R.id.other);<br/>  return picker;<br/>}</pre>
<ol start="14">
<li>Now, create a simple getter and setter method to retrieve and alter state using the <kbd>Category</kbd> enum:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public Category getSelectedCategory() {<br/>  return Category.forIdResource(<br/>      categories.getCheckedRadioButtonId());<br/>}<br/><br/>public void setSelectedCategory(final Category category){<br/>  categories.check(category.getIdResource());<br/>}</pre>
<ol start="15">
<li style="font-weight: 400">Open the <kbd>CaptureClaimActivity</kbd> in Android Studio.</li>
</ol>
<ol start="16">
<li style="font-weight: 400">Change the categories field to use <kbd>CategoryPickerFragment</kbd>, instead of a <kbd>RadioGroup</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private CategoryPickerFragment categories;</pre>
<ol start="17">
<li>In the <kbd>onCreate</kbd> method, remove the code that initialized the category picker:</li>
</ol>
<pre style="padding-left: 60px">categories = (RadioGroup) findViewById(R.id.categories);<br/>categories.setOnCheckedChangeListener(<br/>    new IconPickerWrapper(<br/>        (TextView) findViewById(R.id.selected_category)<br/>    )<br/>);<br/>categories.check(R.id.other);</pre>
<ol start="18">
<li>Use <kbd>FragmentManager</kbd> to retrieve the new <kbd>CategoryPickerFragment</kbd> from the layout:</li>
</ol>
<pre style="padding-left: 60px">final FragmentManager fragmentManager = getSupportFragmentManager();<br/>categories = (CategoryPickerFragment)<br/>    fragmentManager.findFragmentById(R.id.categories);</pre>
<p>Note that you're using the <kbd>getSupportFragmentManager</kbd> method, and not <kbd>getFragmentManager</kbd>. This is because <kbd>CategoryPickerFragment</kbd> is built on top of the support APIs and is backwards compatible all the way to API level 4 (Android 1.6). Android Studio typically prefers the support APIs when generating code as it offers a very simple and stable target, since your application links against a static target, and you are in control of which version to link against and when to upgrade. You can reuse <kbd>CategoryPickerFragment</kbd> anywhere in the application, just as you would a custom <kbd>View</kbd> implementation.</p>
<div class="packt_tip">Linking against the platform APIs (instead of the equivalent support) reduces backward compatibility and requires more testing since your application may behave slightly differently on different versions of the platform. However, platform versions may be slightly faster, and will result in smaller applications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Attachment Pager</h1>
                </header>
            
            <article>
                
<p>Having modularized the category picker, it's time to turn your attention to the attachments. When you implemented the file selection, you left a <kbd>Toast</kbd> in place to show where the code would normally attach the selected file to the <kbd>ClaimItem</kbd> being captured. This next stage will be to create a <kbd>Fragment</kbd> that will encapsulate the previewing of the <kbd>Attachment</kbd> objects. You'll also move much of the attachment logic into this <kbd>Fragment</kbd>. Although the code to connect to other applications and request permissions is commonly placed in an <kbd>Activity</kbd> class, <kbd>Fragment</kbd> classes are also capable of performing the same actions, and the attachment pager is a perfect opportunity to show this off.</p>
<p>This <kbd>Fragment</kbd> will show a pattern where the <kbd>Fragment</kbd> interacts with the <kbd>Activity</kbd> that it belongs to without directly sending events upward. The instinct of most developers when encountering a <kbd>Fragment</kbd> for the first time is to use the pattern in the template where the <kbd>Fragment</kbd> can send events upward to its <kbd>Activity</kbd>, as shown:</p>
<div class="CDPAlignCenter CDPAlign"><img height="232" width="285" src="assets/159c0075-e9be-4b03-8dfc-1cbdca5ac4ed.jpg"/></div>
<p>However, this is often not desirable. It's generally a much better idea to push changes through the data model, and have it deliver the events to areas that are interested in the changes. This is part of a unidirectional event flow, and serves to keep the application much easier to maintain and debug, because the data model always represents the <em>authority</em> for all information and state within the application, as illustrated here:</p>
<div class="CDPAlignCenter CDPAlign">&gt;<img height="202" width="294" src="assets/f6a7e4d3-8802-46f7-ba1e-eee6ba32b4e4.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Attachment preview widget</h1>
                </header>
            
            <article>
                
<p>The first part of the attachments will be a <kbd>View</kbd> implementation, to allow attachments to be previewed within the pager. This class will need an area where the attachment can be previewed if it's an image, or a placeholder icon can be displayed if it's a file the application cannot read. Follow these steps to create the new widget and it's layout XML file:</p>
<ol>
<li style="font-weight: 400">Right-click on the <span class="packt_screen">layout</span> directory under <span class="packt_screen">res</span>, and select <span class="packt_screen">New |</span> <span class="packt_screen">Layout resource file</span>.</li>
<li style="font-weight: 400">Name the new file <kbd>widget_attachment_preview</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Root</span> element field to <kbd>merge</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new layout file.</li>
</ol>
<ol start="5">
<li style="font-weight: 400">Within the <kbd>merge</kbd> element, create an <kbd>ImageView</kbd> that can carry the preview of the attachment file. The <kbd>ImageView</kbd> will need a margin to automatically scale the image to its size on the screen (while maintaining the image's proportions):</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;merge <br/>  android:layout_width="match_parent"<br/>  android:layout_height="match_parent"&gt;<br/>  &lt;ImageView<br/>      android:scaleType="fitCenter"<br/>      android:layout_margin="@dimen/grid_spacer1"<br/>      android:layout_width="match_parent"<br/>      android:layout_height="match_parent"/&gt;<br/>&lt;/merge&gt;</pre>
<ol start="6">
<li style="font-weight: 400">Right-click on the <span class="packt_screen">drawable</span> resource directory, and select <span class="packt_screen">New</span>, <span class="packt_screen">Vector Asset</span>.</li>
<li style="font-weight: 400">Using the <span class="packt_screen">Icon</span> button, search for the <kbd>insert drive file</kbd> icon and select it.</li>
<li style="font-weight: 400">Name the new resource <kbd>ic_unknown_file_type</kbd>.</li>
<li style="font-weight: 400">Click on <span class="packt_screen">Next</span> and then on <span class="packt_screen">Finish</span> to create the new resource.</li>
<li style="font-weight: 400">Open the <kbd>ic_unknown_file_type.xml</kbd> file in Android Studio.</li>
<li style="font-weight: 400">Change the <kbd>fillColor</kbd> attribute of the path to <kbd>#FFBAB5AB</kbd>, and save and close the file.</li>
<li style="font-weight: 400">Right-click on the <kbd>widget</kbd> package in your project, and select <span class="packt_screen">New |</span> <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>AttachmentPreview</kbd>.</li>
<li style="font-weight: 400">Change the <span class="packt_screen">Superclass</span> field to <kbd>android.support.v7.widget.CardView</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new class.</li>
<li style="font-weight: 400">Create fields to reference the <kbd>Attachment</kbd> object and the <kbd>ImageView</kbd> that will render its preview onto the screen:</li>
</ol>
<pre style="padding-left: 60px">private Attachment attachment;<br/>private ImageView preview;</pre>
<ol start="17">
<li>Create the standard <kbd>View</kbd> subclass constructors and an <kbd>initialize</kbd> method that inflates the layout XML and captures the <kbd>ImageView</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public AttachmentPreview(Context context) {<br/>  super(context);<br/>  initialize(context);<br/>}<br/><br/>public AttachmentPreview(Context context, AttributeSet attrs) {<br/>  super(context, attrs);<br/>  initialize(context);<br/>}<br/><br/>public AttachmentPreview(<br/>    Context context,<br/>    AttributeSet attrs,<br/>    int defStyleAttr) {<br/>  super(context, attrs, defStyleAttr);<br/>  initialize(context);<br/>}<br/><br/>void initialize(final Context context) {<br/>  LayoutInflater.from(context).inflate(<br/>      R.layout.widget_attachment_preview, this, true);<br/>  preview = (ImageView) getChildAt(0);<br/>}</pre>
<ol start="18">
<li>Create a simple getter for the <kbd>Attachment</kbd> field:</li>
</ol>
<pre style="padding-left: 60px">public Attachment getAttachment() { return attachment; }</pre>
<ol start="19">
<li>Create a setter to update the <kbd>Attachment</kbd> field, and also start the update of the preview on-screen. You'll also create an inner class using the <kbd>ActionCommand</kbd> class you wrote in <a href="75335d7f-3cda-4985-b992-965f46adc335.xhtml" target="_blank">Chapter 3</a>, <em>Taking Actions</em>, which will attempt to load the actual images on a background thread before updating the widget on the screen:</li>
</ol>
<pre style="padding-left: 60px">public void setAttachment(final Attachment attachment) {<br/>  this.attachment = attachment;<br/>  preview.setImageDrawable(null);<br/><br/>  if (attachment != null) {<br/>    new UpdatePreviewCommand().exec(attachment);<br/>  }<br/>}<br/><br/>private class UpdatePreviewCommand<br/>    extends ActionCommand&lt;Attachment, Drawable&gt; {<br/><br/>  @Override<br/>  public Drawable onBackground(<br/>      final Attachment attachment)<br/>      throws Exception {<br/><br/>    switch (attachment.getType()) {<br/>      case IMAGE:<br/>        return new BitmapDrawable(<br/>            getResources(),<br/>            attachment.getFile().getAbsolutePath()<br/>        );<br/>    }<br/><br/>    return getResources().getDrawable(<br/>        R.drawable.ic_unknown_file_type);<br/>  }<br/><br/>  @Override<br/>  public void onForeground(final Drawable value) {<br/>    preview.setImageDrawable(value);<br/>  }<br/>}</pre>
<p>The preceding code is a great example of using an <kbd>ActionCommand</kbd> object to improve the user experience. When the <kbd>Attachment</kbd> is actually specified on the <kbd>AttachmentPreview</kbd> widget, the onscreen preview is instantly queued, and the loading of the actual preview (which may take a second or two on a slower device) takes place in the background. This frees the main thread to continue processing events from the user, or start the loading of other previews that may be required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Attachment Pager Adapter</h1>
                </header>
            
            <article>
                
<p>The <kbd>ViewPager</kbd> class is a special type of Android widget called an adapter view (although some, such as <kbd>ViewPager</kbd>, don't actually inherit from <kbd>AdapterView</kbd>, it shares much of the concepts). An <kbd>AdapterView</kbd> is used when it potentially needs to display more data than will fit on the screen at once, but maintain excellent performance. They do this by maintaining a small selection of widgets that will be displayed on the screen, and an <kbd>Adapter</kbd> that will populate the widgets with the data to display. Examples of <kbd>Adapter</kbd> widgets are as follows:</p>
<ul>
<li style="font-weight: 400"><kbd>ListView</kbd>: A simple vertical scrolling list of similar items, such as phone contacts</li>
<li style="font-weight: 400"><kbd>GridView</kbd>: A vertical scrolling grid of similar items, such as photos</li>
<li style="font-weight: 400"><kbd>StackView</kbd>: A three-dimensional stack of items great for presenting media</li>
<li style="font-weight: 400"><kbd>RecyclerView</kbd>: A powerful all-purpose pooling view, originally added to replace <kbd>ListView</kbd></li>
</ul>
<p>If you wanted to display a scrolling list of images, for example, you would use a <kbd>RecyclerView</kbd> and provide it with an <kbd>Adapter</kbd> that could load previews of image files into <kbd>ImageView</kbd> widgets (much the same way as the <kbd>AttachmentPreview</kbd> class does):</p>
<div class="CDPAlignCenter CDPAlign"><img height="211" width="350" src="assets/26b634a8-dfa9-4b58-95ff-c18b6b7b25d0.jpg"/></div>
<div>
<p><kbd>ViewPager</kbd> is a little different from the <kbd>AdapterView</kbd> classes described here; all of them only maintain as many widgets as what can fit on the screen at once. The normal <kbd>AdapterView</kbd> classes and <kbd>RecyclerView</kbd> all <em>recycle</em> their pool of widgets. When one widget is scrolled off the screen, it's resized, populated with new data, and scrolled into view looking like a new widget. <kbd>ViewPager</kbd> doesn't stop you from doing this, but it doesn't do it for you. This is because <kbd>ViewPager</kbd> often contains large and complex tab layouts, which would be too expensive to try and recycle (or simply don't repeat at all, in which case, recycling is useless).</p>
<p>For this application, the user is unlikely to have many attachments, so you can get away with simply creating an <kbd>AttachmentPreview</kbd> instance for each of the attachments when they are displayed, which keeps the steps for implementing the <kbd>Adapter</kbd> much simpler and to the point:</p>
</div>
<ol>
<li style="font-weight: 400">Right-click on your default package (that is, <kbd>com.packtpub.claim</kbd>) and select <span class="packt_screen">New |</span> <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>ui.attachments.AttachmentPreviewAdapter</kbd>.</li>
<li style="font-weight: 400">Make its <span class="packt_screen">Superclass</span> <kbd>android.support.v4.view.PagerAdapter</kbd>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new class.</li>
</ol>
<ol start="5">
<li style="font-weight: 400">This class will need a <kbd>List</kbd> of the <kbd>Attachment</kbd> objects it's expected to translate into widgets for previewing, and it'll need a setter to change what will be displayed:</li>
</ol>
<pre style="padding-left: 60px">private List&lt;Attachment&gt; attachments = Collections.emptyList();<br/><br/>public int getCount() {<br/>  return attachments.size();<br/>}<br/><br/>public void setAttachments(final List&lt;Attachment&gt; attachments) {<br/>  this.attachments = attachments != null<br/>          ? attachments<br/>          : Collections.&lt;Attachment&gt;emptyList();<br/>  notifyDataSetChanged();<br/>}</pre>
<div class="packt_infobox">After changing the <kbd>List</kbd> of attachments, <kbd>AttachmentPreviewAdapter</kbd> is wrapping; it invokes <kbd>notifyDataSetChanged()</kbd>, which informs the <kbd>ViewPager</kbd> it's attached to things that have changed, and some rerendering may be required. This sort of functionality can be found in all the <kbd>Adapter</kbd> classes, and allows for the reactive behavior that users expect from their apps. When a new email arrives, it can just appear on the list they're looking at. As a developer, this system is nice because the events can bubble up from the data model rather than being tied to the user interface.</div>
<ol start="6">
<li style="font-weight: 400">The <kbd>ViewPager</kbd> maintains separate lists of the widgets used to display data on the screen and the object model being displayed. The <kbd>ViewPager</kbd> creates the widgets by invoking <kbd>instantiateItem</kbd> on the <kbd>PagerAdapter</kbd> object, which is expected to add the widget to the <kbd>ViewPager</kbd> and return the data model object that it's displaying:</li>
</ol>
<pre style="padding-left: 60px">public Object instantiateItem(final ViewGroup container, final int position) {<br/>  final AttachmentPreview preview =<br/>      new AttachmentPreview(container.getContext());<br/>  preview.setAttachment(attachments.get(position));<br/>  container.addView(preview);<br/>  return attachments.get(position);<br/>}</pre>
<ol start="7">
<li style="font-weight: 400">The <kbd>ViewPager</kbd> may also ask <kbd>PagerAdapter</kbd> to remove the widgets that are not visible to the user. This is typically when a view is not visible, and cannot be directly scrolled into view by the user (that is, it's not directly to the left or right of the current view). The position argument passed to <kbd>destroyItem</kbd> is the position in the data model, not the index of the widget within the <kbd>ViewPager</kbd>, so you need a way to figure out which widget in the <kbd>ViewPager</kbd> actually needs to be removed. Here, we do it by simply iterating over all the child widgets in the <kbd>ViewPager</kbd> since there will never be many of them:</li>
</ol>
<pre style="padding-left: 60px">public void destroyItem(<br/>    final ViewGroup container,<br/>    final int position,<br/>    final Object object) {<br/>  for (int i = 0; i &lt; container.getChildCount(); i++) {<br/>    final AttachmentPreview preview =<br/>        ((AttachmentPreview) container.getChildAt(i));<br/>    if (preview.getAttachment() == object) {<br/>      container.removeViewAt(i);<br/>      break;<br/>    }<br/>  }<br/>}</pre>
<ol start="8">
<li>Finally, the <kbd>ViewPager</kbd> needs a way to know which widget child of its is associated with which part of the data model; this is really easy for you in this class, because the <kbd>AttachmentPreview</kbd> class directly references the <kbd>Attachment</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">public boolean isViewFromObject(final View view, final Object o) {<br/>  return (view instanceof AttachmentPreview)<br/>      &amp;&amp; (((AttachmentPreview) view).getAttachment() == o);<br/>}</pre>
<p>This implementation of <kbd>PagerAdapter</kbd> is very naive and simple, but shows more of how the <kbd>Adapter</kbd> views work. They track their onscreen views completely independently of the dataset, and the order in which the child widgets appear on the screen doesn't have any direct relationship to the order in which the data model is presented.</p>
<p>The next step is to create another <kbd>ActionCommand</kbd> class that will create the <kbd>Attachment</kbd> objects when the user selects an external file to attach to the claims.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Create Attachment Command</h1>
                </header>
            
            <article>
                
<p>When the user selects a file to attach to the claim, you'll need to ensure that your application can always access the file. This means copying the file into your application's private space, which can take a second or two. You also need to know what type of file it is, otherwise your application won't know if it can render a preview of the attachment. For both of these, you'll need an <kbd>ActionCommand</kbd> implementation that does the work:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>model</kbd> package, and select <span class="packt_screen">New |</span> <span class="packt_screen">Java Class</span>.</li>
<li style="font-weight: 400">Name the new class <kbd>commands.CreateAttachmentCommand</kbd>.</li>
<li style="font-weight: 400">Make the class <span class="packt_screen">Abstract</span>.</li>
<li style="font-weight: 400">Click <span class="packt_screen">OK</span> to create the new package and class.</li>
<li style="font-weight: 400">Change the class declaration to extend <kbd>ActionCommand&lt;Uri, Attachment&gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public abstract class CreateAttachmentCommand<br/>    extends ActionCommand&lt;Uri, Attachment&gt; {</pre>
<ol start="6">
<li>Declare a directory to write the local files to, and a <kbd>ContentResolver</kbd> that can be used to read the files that the user selects:</li>
</ol>
<pre style="padding-left: 60px">private final File dir;<br/>private final ContentResolver resolver;<br/><br/>public CreateAttachmentCommand(<br/>      final File dir,<br/>      final ContentResolver resolver) {<br/><br/>  this.dir = dir;<br/>  this.resolver = resolver;<br/>}</pre>
<div class="packt_infobox">A <kbd>ContentResolver</kbd> allows applications to read each other's data, if they choose to expose it. In this case, you'll be using <kbd>content://</kbd> URIs that are commonly used in Android when data needs to be exposed safely between applications. A <kbd>ContentResolver</kbd> counterpart is a <kbd>ContentProvider</kbd> that exposes the data for other applications to access.</div>
<ol start="7">
<li>Create a simple utility method to copy the file from a <kbd>Uri</kbd> into a new, randomly named file. The file is randomly named so that no two files are likely to collide in name:</li>
</ol>
<pre style="padding-left: 60px">File makeFile(final Uri value) throws IOException {<br/>  final File outputFile =<br/>      new File(dir, UUID.randomUUID().toString());<br/>  final InputStream input = resolver.openInputStream(value);<br/>  final FileOutputStream output = new FileOutputStream(outputFile);<br/>  try {<br/>      final byte[] buffer = new byte[10 * 1024];<br/>      int bytesRead = 0;<br/>      while ((bytesRead = input.read(buffer)) != -1) {<br/>          output.write(buffer, 0, bytesRead);<br/>      }<br/>      output.flush();<br/>  } finally {<br/>      output.close();<br/>      input.close();<br/>  }<br/>  return outputFile;<br/>}</pre>
<ol start="8">
<li>Override the <kbd>onBackground</kbd> method to copy the file using the preceding utility method:</li>
</ol>
<pre style="padding-left: 60px">public Attachment onBackground(final Uri value) throws Exception {<br/>   final File file = makeFile(value);</pre>
<ol start="9">
<li>Finally, check the type of the file your command just created, and if it looks like an image, ensure that you can read it before returning. This avoids the application having to do the same check every time it wants to preview the attachment. We check whether the image is readable by attempting to read it using the <kbd>BitmapFactory</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">  final String type = resolver.getType(value);<br/>  if (type != null<br/>      &amp;&amp; type.startsWith("image/")<br/>      &amp;&amp; BitmapFactory.decodeFile(file.getAbsolutePath()) != null)<br/>  {<br/>    return new Attachment(file, Attachment.Type.IMAGE);<br/>  } else {<br/>    return new Attachment(file, Attachment.Type.UNKNOWN);<br/>  }<br/>}</pre>
<p>This simple command class doesn't have any foreground work, and has been left abstract. Instead, it assumes that the work of handling the <kbd>Attachment</kbd> will be done elsewhere. The next part is the <kbd>AttachmentPagerFragment</kbd> class that will handle the <kbd>Attachment</kbd> objects created here by attaching them to the <kbd>ClaimItem</kbd>, and notifying the <kbd>AttachmentPreviewAdapter</kbd> that there is a new attachment to render.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Attachment Pager Fragment</h1>
                </header>
            
            <article>
                
<p>Now that you've assembled all of the parts required for the attachments to be created and previewed, you need to actually populate the area where they will be previewed. The <kbd>AttachmentPagerFragment</kbd> class will not only serve to encapsulate the <kbd>ViewPager</kbd> used to preview the attachments, but will also encapsulate the logic required to add new attachments to the user's claim. This will be done by moving the <kbd>onRequestPermissionsResult</kbd> and <kbd>onActivityResult</kbd> from the <kbd>CaptureClaimActivity</kbd> to the new <kbd>AttachmentPagerFragment</kbd> class. This process will require moving some of the code out of <kbd>CaptureClaimActivity</kbd> and into the <kbd>Fragment</kbd> class, so you'll be in for some cutting and pasting. Let's get started:</p>
<ol>
<li style="font-weight: 400">Create a new <span class="packt_screen">layout</span> resource named <kbd>fragment_attachment_pager</kbd>.</li>
<li style="font-weight: 400">Open the <kbd>content_capture_claim.xml</kbd> layout file.</li>
<li style="font-weight: 400">Cut and paste the <kbd>ViewPager</kbd> from the bottom of <kbd>content_capture_claim.xml</kbd> into the <kbd>fragment_attachment_pager</kbd> layout file, overwriting all the content of the file. You'll need to define the XML namespaces (the <kbd>xmlns</kbd> attributes) on the <kbd>ViewPager</kbd> element, so that the <kbd>fragment_attachment_pager.xml</kbd> file reads like this:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.v4.view.ViewPager<br/>  <br/>  <br/>  android:id="@+id/attachments"<br/>  android:layout_width="wrap_content"<br/>  android:layout_height="wrap_content"<br/>  android:layout_weight="1"<br/>  android:clipChildren="false"<br/>  android:clipToPadding="false"<br/>  tools:context=".ui.attachments.AttachmentPagerFragment"/&gt;</pre>
<ol start="4">
<li style="font-weight: 400">Create a <span class="packt_screen">New</span>, <span class="packt_screen">Java Class</span> in the <kbd>ui.attachments</kbd> package.</li>
<li style="font-weight: 400">Name the class <kbd>AttachmentPagerFragment</kbd>.</li>
<li style="font-weight: 400">Make its <span class="packt_screen">Superclass</span> <kbd>android.support.v4.app.Fragment</kbd>.</li>
<li style="font-weight: 400">Open the <kbd>CaptureClaimActivity</kbd> class.</li>
<li>Cut the <kbd>REQUEST_ATTACH_FILE</kbd> and <kbd>REQUEST_ATTACH_PERMISSION</kbd> constants from the <kbd>CaptureClaimActivity</kbd> and paste them in <kbd>AttachmentPagerFragment</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private static final int REQUEST_ATTACH_FILE = 1;<br/>private static final int REQUEST_ATTACH_PERMISSION = 1001;</pre>
<ol start="9">
<li>Create an instance of <kbd>AttachmentPagerAdapter</kbd> to help with rendering the attachment previews. As the <kbd>AttachmentPagerAdapter</kbd> can handle its list of <kbd>Attachment</kbd> object changing completely, you'll only ever need one in each <kbd>AttachmentPagerFragment</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private final AttachmentPreviewAdapter adapter = new AttachmentPreviewAdapter();</pre>
<ol start="10">
<li>Create fields for the <kbd>ActionCommand</kbd> you'll use to attach the files, and another to hold a reference to the <kbd>ViewPager</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">private ActionCommand&lt;Uri, Attachment&gt; attachFileCommand;<br/>private ViewPager pager;</pre>
<ol start="11">
<li>Your <kbd>AttachmentPagerFragment</kbd> needs a reference to the <kbd>ClaimItem</kbd> it is previewing <kbd>Attachment</kbd> for. This will also allow it to add new <kbd>Attachment</kbd> objects to the claim without invoking its <kbd>Activity</kbd> to do so. The <kbd>Fragment</kbd> will also expose a method that can be called to notify it that the list of attachments on the <kbd>ClaimItem</kbd> has changed. This can be invoked by the <kbd>ClaimItem</kbd> itself later on, or through an event-bus:</li>
</ol>
<pre style="padding-left: 60px">private ClaimItem claimItem;<br/><br/>public void setClaimItem(final ClaimItem claimItem) {<br/>  this.claimItem = claimItem;<br/>  onAttachmentsChanged();<br/>}<br/><br/>public void onAttachmentsChanged() {<br/>  adapter.setAttachments(<br/>      claimItem != null<br/>          ? claimItem.getAttachments()<br/>          : null<br/>  );<br/>  pager.setCurrentItem(adapter.getCount() - 1);<br/>}</pre>
<ol start="12">
<li>Override the <kbd>Fragment</kbd> <kbd>onCreate</kbd> method. This looks just like the <kbd>onCreate</kbd> method of an <kbd>Activity</kbd>, and is called after your <kbd>Fragment</kbd> has been attached to its context (in this case, to its <kbd>Activity</kbd> object). <kbd>AttachmentPagerFragment</kbd> will use <kbd>onCreate</kbd> to instantiate the <kbd>attachFileCommand</kbd> for later use, and it'll do so using an anonymous inner class, inheriting from the <kbd>CreateAttachmentCommand</kbd> class that you just wrote:</li>
</ol>
<pre style="padding-left: 60px">public void onCreate(final @Nullable Bundle savedInstanceState) {<br/>   super.onCreate(savedInstanceState);<br/>   final File attachmentsDir =<br/>      getContext().getDir("attachments", Context.MODE_PRIVATE);<br/>   attachFileCommand = new CreateAttachmentCommand(<br/>       attachmentsDir,<br/>       getContext().getContentResolver()) {<br/>       @Override<br/>       public void onForeground(final Attachment value) {<br/>           if (claimItem != null) {<br/>               claimItem.addAttachment(value);<br/>               onAttachmentsChanged();<br/>           }<br/>       }<br/>   };<br/>}</pre>
<div class="packt_tip">In any task that takes place in the background and then jumps back to the foreground, it's a good idea to check your context before running any code. In the preceding snippet, this takes the form of the <kbd>claimItem != null</kbd> check. If the command was started, and the user left the <kbd>Activity</kbd> (or similar), the foreground code could trigger errors by trying to alter variables that are invalid or <kbd>null</kbd>.</div>
<ol start="13">
<li>When the <kbd>Fragment</kbd> is released completely (with no chance of a later restart), its <kbd>onDestroy</kbd> method is called. Use this method to release the <kbd>claimItem</kbd>, stopping any background tasks from modifying it when they get back to the foreground:</li>
</ol>
<pre style="padding-left: 60px">public void onDestroy() {<br/>   super.onDestroy();<br/>   claimItem = null;<br/>}</pre>
<ol start="14">
<li>Just like the <kbd>CategoryPickerFragment</kbd> you wrote earlier, <kbd>AttachmentPagerFragment</kbd> needs a <kbd>View</kbd> that will display when it's inflated into a layout XML. In this case, you also need to adjust the <kbd>ViewPager</kbd> slightly, as the page margin is not exposed as an XML attribute:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public View onCreateView(<br/>       final LayoutInflater inflater,<br/>       final @Nullable ViewGroup container,<br/>       final @Nullable Bundle savedInstanceState) {<br/><br/>  pager = (ViewPager) inflater.inflate(<br/>      R.layout.fragment_attachment_pager, container, false);<br/>  pager.setPageMargin(<br/>      getResources().getDimensionPixelSize(R.dimen.grid_spacer1));<br/>  pager.setAdapter(adapter);<br/><br/>  return pager;<br/>}</pre>
<ol start="15">
<li>Now, cut and paste the <kbd>onAttachClick</kbd> method from <kbd>CaptureClaimActivity</kbd> into <kbd>AttachmentPagerFragment</kbd>. This will immediately cause errors, because <kbd>onAttachClick</kbd> uses the fact that an <kbd>Activity</kbd> is also a <kbd>Context</kbd>; so, <kbd>ContextCompat.checkSelfPermission</kbd> can use the <kbd>CaptureClaimAcitvity</kbd> as the <kbd>Context</kbd> to check. <kbd>Fragment</kbd> doesn't inherit from <kbd>Context</kbd>, but it does expose the <kbd>getContext()</kbd> and <kbd>getActivity()</kbd> methods to retrieve the environment that it's attached to:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public void onAttachClick() {<br/>  final int permissionStatus = ContextCompat.checkSelfPermission(<br/>      getContext(),<br/>      Manifest.permission.READ_EXTERNAL_STORAGE);<br/><br/>  if (permissionStatus != PackageManager.PERMISSION_GRANTED) {<br/>    ActivityCompat.requestPermissions(<br/>        getActivity(),<br/>        new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},<br/>        REQUEST_ATTACH_PERMISSION);<br/>    return;<br/>  }<br/><br/>  final Intent attach = new Intent(Intent.ACTION_GET_CONTENT)<br/>      .addCategory(Intent.CATEGORY_OPENABLE)<br/>      .setType("*/*");<br/><br/>  startActivityForResult(attach, REQUEST_ATTACH_FILE);<br/>}</pre>
<ol start="16">
<li style="font-weight: 400">Now cut and paste the <kbd>onRequestPermissionsResult</kbd>, <kbd>onAttachFileResult</kbd>, and <kbd>onActivityResult</kbd> methods over as well. These should copy over without any errors.</li>
<li style="font-weight: 400">In the <kbd>onAttachFileResult</kbd> method, you can now remove the <kbd>Toast</kbd> you put in as a placeholder. Instead, invoke the <kbd>attachFileCommand</kbd> with the selected file; this will automatically result in the previews also being updated:</li>
</ol>
<pre style="padding-left: 60px"><span>Toast.makeText(this, data.getDataString(), Toast.LENGTH_SHORT).show();</span><br/>attachFileCommand.exec(data.getData());</pre>
<ol start="18">
<li>In the <kbd>content_capture_claim.xml</kbd> layout file, include the new <kbd>AttachmentPagerFragment</kbd> where the <kbd>ViewPager</kbd> used to be:</li>
</ol>
<pre style="padding-left: 60px">&lt;fragment<br/>   android:id="@+id/attachments"<br/>   class="com.packtpub.claim.ui.attachments.AttachmentPagerFragment"<br/>   android:layout_width="match_parent"<br/>   android:layout_height="0dp"<br/>   android:layout_marginTop="@dimen/grid_spacer1"<br/>   android:layout_weight="1" /&gt;</pre>
<ol start="19">
<li>In the <kbd>CaptureClaimActivity</kbd>, create a new field for the <kbd>AttachmentPagerFragment</kbd>, and in <kbd>onCreate</kbd>, capture the field from the <kbd>FragmentManager</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>private AttachmentPagerFragment attachments;</strong><br/>// ...<br/>protected void onCreate(Bundle savedInstanceState) {<br/>   // ...<br/>   final FragmentManager fragmentManager =<br/>       getSupportFragmentManager();<br/>   categories = (CategoryPickerFragment)<br/>       fragmentManager.findFragmentById(R.id.categories);<br/><strong>   attachments = (AttachmentPagerFragment)<br/>       fragmentManager.findFragmentById(R.id.attachments);</strong></pre>
<ol start="20">
<li>Finally, change the <kbd>onClick</kbd> method in <kbd>CaptureClaimActivity</kbd> to invoke <kbd>onAttachClick</kbd> on the <kbd>AttachmentPagerFragment</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onClick(View v) {<br/>  switch (v.getId()) {<br/>    case R.id.attach:<br/>      <strong>attachments.onAttachClick();</strong><br/>      break;<br/>  }<br/>}</pre>
<p>The <kbd>AttachmentPagerFragment</kbd> is a multipurpose <kbd>Fragment</kbd>. Although it has all the logic required to attach files to a <kbd>ClaimItem</kbd>, it doesn't attempt to hook them up to any event listeners itself. As a result, you can easily use it as a read-only preview of attachments if (for example) the current user was reviewing someone else's travel expenses (in which case, they shouldn't be editing the data).</p>
<p>It's always a good idea to consider how a <kbd>Fragment</kbd> might be reused in different situations, and to rather push data and events down into them rather than having them making call upward to their <kbd>Activity</kbd> to know what should be done (which forces every <kbd>Activity</kbd> wanting to use the <kbd>Fragment</kbd> to provide that information).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Capturing the ClaimItem data</h1>
                </header>
            
            <article>
                
<p>While you've linked the new <kbd>Fragment</kbd> classes to the <kbd>CaptureClaimAcitvity</kbd>, things aren't quite finished yet. The <kbd>CaptureClaimActivity</kbd> doesn't actually have a <kbd>ClaimItem</kbd> to capture and modify. For this, you'll not only need to hold a reference to a <kbd>ClaimItem</kbd> in the <kbd>CaptureClaimActivity</kbd>, you'll need to ensure that it is saved and restored through life cycle changes for the <kbd>Activity</kbd> as well. Fortunately, your model is all <kbd>Parcelable</kbd>, which keeps this easy. It's time to capture a <kbd>ClaimItem</kbd>:</p>
<ol>
<li style="font-weight: 400">Open the <kbd>CaptureClaimActivity</kbd> class.</li>
<li style="font-weight: 400">First, you'll need a way that a <kbd>ClaimItem</kbd> can be passed into the <kbd>CaptureClaimActivity</kbd> for editing. To keep this simple and flexible, you'll allow them to be passed as an "extra" field on the <kbd>Intent</kbd>. When you use <span><kbd>extras</kbd> in an <kbd>Intent</kbd></span>, it's a good idea to expose the name as a public constant so that they can be accessed by outside classes when creating the <kbd>Intent</kbd> objects:</li>
</ol>
<pre style="padding-left: 60px">public static final String EXTRA_CLAIM_ITEM = "com.packtpub.claim.extras.CLAIM_ITEM";</pre>
<ol start="3">
<li>You'll also need to save and restore the <kbd>ClaimItem</kbd> while it's being edited, and for this, you'll also need a key for the <kbd>Bundle</kbd>:</li>
</ol>
<pre style="padding-left: 60px">private static final String KEY_CLAIM_ITEM = "com.packtpub.claim.ClaimItem";</pre>
<ol start="4">
<li>Then, create a <kbd>private</kbd> field to reference the <kbd>ClaimItem</kbd> being edited, and you'll also need to reference all the inputs and <kbd>Fragment</kbd> objects on the screen; <kbd>CaptureClaimActivity</kbd> should have <kbd>private</kbd> fields looking like this:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>private EditText description;</strong><br/><strong>private EditText amount;</strong><br/><br/>private DatePickerLayout selectedDate;<br/>private CategoryPickerFragment categories;<br/>private AttachmentPagerFragment attachments;<br/><br/><strong>private ClaimItem claimItem;</strong></pre>
<ol start="5">
<li>In the <kbd>onCreate</kbd> method, ensure that you capture all the preceding fields after the call to <kbd>setContentView</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>description = (EditText) findViewById(R.id.description);</strong><br/><strong>amount = (EditText) findViewById(R.id.amount);</strong><br/><strong>selectedDate = (DatePickerLayout) findViewById(R.id.date);</strong><br/><br/>final FragmentManager fragmentManager = getSupportFragmentManager();<br/>attachments = (AttachmentPagerFragment) fragmentManager.findFragmentById(R.id.attachments);<br/>categories = (CategoryPickerFragment) fragmentManager.findFragmentById(R.id.categories);</pre>
<ol start="6">
<li>Then, you'll need to check whether a <kbd>ClaimItem</kbd> has been passed in, either in the <kbd>savedInstanceState</kbd> <kbd>Bundle</kbd> (which will be populated if the <kbd>Activity</kbd> is being restarted due to a configuration change), or is being passed as an extra parameter on the <kbd>Intent</kbd> (a bit like a constructor argument):</li>
</ol>
<pre style="padding-left: 60px">if (savedInstanceState != null) {<br/>   claimItem = savedInstanceState.getParcelable(KEY_CLAIM_ITEM);<br/>} else if (getIntent().hasExtra(EXTRA_CLAIM_ITEM)) {<br/>   claimItem = getIntent().getParcelableExtra(EXTRA_CLAIM_ITEM);<br/>}</pre>
<ol start="7">
<li>If a <kbd>ClaimItem</kbd> wasn't passed in through either of these mechanisms, you'll want to create a new, empty <kbd>ClaimItem</kbd> to be edited by the user. On the other hand, if one was passed in, you'll need to populate the user interface with its data:</li>
</ol>
<pre style="padding-left: 60px">if (claimItem == null) {<br/>  claimItem = new ClaimItem();<br/>} else {<br/>  description.setText(claimItem.getDescription());<br/>  amount.setText(String.format("%f", claimItem.getAmount()));<br/>  selectedDate.setDate(claimItem.getTimestamp());<br/>}<br/><br/>attachments.setClaimItem(claimItem);</pre>
<ol start="8">
<li style="font-weight: 400">Now, write a <kbd>utility</kbd> method to copy the data from the user interface widgets back into the <kbd>ClaimItem</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">void captureClaimItem() {<br/>  claimItem.setDescription(description.getText().toString());<br/>  if (!TextUtils.isEmpty(amount.getText())) {<br/>    claimItem.setAmount(<br/>        Double.parseDouble(amount.getText().toString()));<br/>  }<br/>  claimItem.setTimestamp(selectedDate.getDate());<br/>  claimItem.setCategory(categories.getSelectedCategory());<br/>}</pre>
<ol start="9">
<li>When the <kbd>Activity</kbd> is shutdown in ways that can result in it being restarted at a later time (and as a new instance), the <kbd>onSaveInstanceState</kbd> method is invoked with a <kbd>Bundle</kbd> where your <kbd>Activity</kbd> can save any state it needs to restore later (in this case, it'll be the <kbd>ClaimItem</kbd> being edited). This will happen if your <kbd>Activity</kbd> is in the background and the OS needs to reclaim memory, or if the <kbd>Activity</kbd> restarts due to a configuration change (such as the user changing between the portrait and landscape modes). This is where you set up the contents of the <kbd>Bundle</kbd> that gets passed into <kbd>onCreate</kbd>:</li>
</ol>
<pre style="padding-left: 60px">protected void onSaveInstanceState(final Bundle outState) {<br/>  super.onSaveInstanceState(outState);<br/>  captureClaimItem(); // make sure the ClaimItem is up-to-date<br/>  outState.putParcelable(KEY_CLAIM_ITEM, claimItem);<br/>}</pre>
<ol start="10">
<li>We also want to ensure that when the <kbd>CaptureClaimActivity</kbd> is closed, it returns the edited <kbd>ClaimItem</kbd> to the <kbd>Activity</kbd> that started it. This can be done by overloading the <kbd>finish()</kbd> method, which is invoked to close an <kbd>Activity</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public void finish() {<br/>  captureClaimItem();<br/>  setResult(<br/>      RESULT_OK,<br/>      new Intent().putExtra(EXTRA_CLAIM_ITEM, claimItem)<br/>  );<br/>  super.finish();<br/>}</pre>
<div class="packt_tip"><kbd>CaptureClaimActivity</kbd> will always return a <kbd>ClaimItem</kbd> object; there is no notion of saving the <kbd>ClaimItem</kbd> or canceling its creation (although a calling <kbd>Activity</kbd> may choose to ignore the <kbd>ClaimItem</kbd> if it's empty). The idea is to assume that the user knows what they are doing, and rather offer them a way to undo their changes once they've been made. This is much less disruptive to the user than always asking them "are you sure" questions.</div>
<ol start="11">
<li>Finally, it's important that we give the user a visual method to exit the screen without using the Android back button. We'll do this by putting a <em>back</em> navigation arrow on the <kbd>Toolbar</kbd>. First, write a handler that listens for the <em>home</em> button being selected:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">@Override<br/>public boolean onOptionsItemSelected(final MenuItem item) {<br/>  switch (item.getItemId()) {<br/>    case android.R.id.home:<br/>      finish();<br/>      break;<br/>    default:<br/>      return false;<br/>  }<br/><br/>  return true;<br/>}</pre>
<ol start="12">
<li style="font-weight: 400">Now, right-click on the <span class="packt_screen">drawable</span> resource directory and choose <span class="packt_screen">New|</span> <span class="packt_screen">Vector Asset</span>.</li>
<li style="font-weight: 400">Using the <span class="packt_screen">Icon</span> selector, search for <kbd>arrow back</kbd>.</li>
</ol>
<ol start="14">
<li style="font-weight: 400">Name the new Icon <kbd>ic_arrow_back_white_24dp</kbd>.</li>
<li style="font-weight: 400">Click on <span class="packt_screen">Next</span> and then on <span class="packt_screen">Finish</span> to complete the wizard and create the new asset.</li>
<li style="font-weight: 400">Open the <kbd>ic_arrow_back_white_24dp.xml</kbd> resource file.</li>
<li style="font-weight: 400">Change the path <kbd>android:fillColor</kbd> attribute to white:</li>
</ol>
<pre style="padding-left: 60px">&lt;path<br/>   android:fillColor="#FFFFFFFF"</pre>
<ol start="18">
<li style="font-weight: 400">Open the <kbd>activity_capture_claim.xml</kbd> layout resource in <span class="packt_screen">Design</span> mode.</li>
<li style="font-weight: 400">Select the toolbar in the <span class="packt_screen">Component Tree</span> panel:
<div class="CDPAlignCenter CDPAlign"><img src="assets/caab850f-21b9-4f23-ad79-e530047331a2.png"/></div>
</li>
<li style="font-weight: 400">In the <span class="packt_screen">Attributes</span> panel, toggle to the <span class="packt_screen">View all attributes</span> view.</li>
<li style="font-weight: 400">Search for <span class="packt_screen">navigationIcon</span>, and use the resource selector to pick the <kbd>ic_arrow_back_white_24dp</kbd> icon resource.</li>
</ol>
<p>If you run the application now, you'll see that you can capture attachments for a claim, and when the device is rotated, or you navigate away using the home button, any data you've changed will remain the same when you return to the application. It's always important to consider what state you will need to maintain when navigating away from an <kbd>Activity</kbd>, as the <kbd>Activity</kbd> itself may need to be reclaimed.</p>
<p>It's also a good idea to separate the state of an <kbd>Activity</kbd> from the state of the application. While an <kbd>Activity</kbd> is busy editing a record, that record's data should remain encapsulated within the <kbd>Activity</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Try it yourself</h1>
                </header>
            
            <article>
                
<p>You've isolated the category picker and the attachment logic into <kbd>Fragment</kbd> classes in this chapter; now try writing a Fragment to encapsulate the contents of the first <kbd>CardView</kbd> on the screen. Remember to rather push the <kbd>ClaimItem</kbd> down into the <kbd>Fragment</kbd> instead of having the <kbd>Fragment</kbd> push the change events up to the <kbd>Activity</kbd>. Name the new <kbd>Fragment</kbd> class <kbd>CaptureClaimDetailsFragment</kbd> and name its layout resource <kbd>fragment_capture_claim_details.xml</kbd>.</p>
<p>You can also try pushing the logic to change the <kbd>Category</kbd> of the <kbd>ClaimItem</kbd> down into the <kbd>CategoryPickerFragment</kbd> in a way <span>similar</span> to how the <kbd>AttachmentPagerFragment</kbd> automatically adds new <kbd>Attachments</kbd> to the <kbd>ClaimItem</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">When developing a layout subclass, which of the following options is the best?
<ul>
<li class="mce-root">Programmatically instantiating its child widgets</li>
<li class="mce-root">Only having ID attributes in nested child widgets</li>
<li class="mce-root">Avoiding assigning ID attributes to child widgets</li>
</ul>
</li>
<li class="mce-root">Which of these applies to the <kbd>Bundle</kbd> passed at an <kbd>Activity</kbd> in <kbd>onCreate</kbd>?
<ul>
<li class="mce-root">It is populated in the <kbd>onSaveInstanceState</kbd> method</li>
<li class="mce-root">It is populated automatically by the platform</li>
<li class="mce-root">It is never null</li>
</ul>
</li>
<li class="mce-root">When the data for an <kbd>Adapter</kbd> changes, which of the mentioned happens?
<ul>
<li class="mce-root">It will be detected by the <kbd>View</kbd> automatically</li>
<li class="mce-root">It should be replaced by a new <kbd>Adapter</kbd> to reflect the changes</li>
<li class="mce-root">It should notify any attached listeners</li>
</ul>
</li>
<li>Fragments and <kbd>View</kbd> classes should meet which of the following condition?
<ul>
<li style="font-weight: 400">They should have their data and state pushed into them from the <kbd>Activity</kbd></li>
<li style="font-weight: 400">They should expose listener interfaces that their <kbd>Activity</kbd> implements to receive events</li>
<li style="font-weight: 400">They should directly call event methods on their <kbd>Activity</kbd> by casting it to the correct class</li>
</ul>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned some of the practical techniques for breaking your user interface and application into modular components that can be reused. It's always a good idea to start with the finished user interface and break it up, preferably from the mockup stage. It's also good to identify where some parts of the system can serve multiple roles, for example, being both a read-only display and an editor. It's also a good idea to wrap components within other components, even if it's just conceptually. Keeping certain types of event handlers as their own modules makes them reusable over screens that don't share exactly the same widgets, but need to reuse the same logic.</p>
<p>When building user interfaces, it's a good idea to use an <kbd>Activity</kbd> to just wrap a collection of <kbd>Fragment</kbd> rather than nesting the screen logic in the <kbd>Activity</kbd>. This will allow the <kbd>Fragment</kbd> to take on specific responsibilities (such as attachments), making them more reusable elsewhere in your application. It also allows you far more flexibility when providing different layouts for different screen sizes. Devices with large screens might actually have more <kbd>Fragment</kbd> on the screen than smaller devices.</p>
<p>As a general best practice, always try and contain data and state by pushing it downward (as you do when you pass parameters to a method). This avoids <kbd>View</kbd> classes and <kbd>Fragment</kbd> from needing to be placed within specific parts of your application, just like a method doesn't need to know where it is being invoked from to do its job. This approach makes it much easier to move parts of the application around later on.</p>
<p>In the next chapter, we'll look at an Android system that makes this sort of modularization easier, and even more flexible. The data binding system is an incredibly powerful system that takes care of keeping user interfaces populated with data, and allows much of the presentation work to be bound directly to the layout XML files.</p>


            </article>

            
        </section>
    </body></html>