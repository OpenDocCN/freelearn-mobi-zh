- en: Chapter 8. Font Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Font rendering with the FreeType project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering different languages with Harfbuzz
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering text on Head Up Display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Font rendering is an essential part of computer application programs; it helps
    users to interact with the system and understand information in a readable form.
    OpenGL ES does not provide a built-in support for font rendering; instead, the
    font engine needs to be programed by a developer. There are many font-rendering
    techniques; this chapter will cover the most popular technique for font rendering,
    which is rendered using the **FreeType** project in conjunction with the **Harfbuzz**
    library. The former is used to rasterize symbolic characters or glyphs using font
    files; this library supports different types of font file formats, such as TTF,
    BDF, OTF, Windows FNT, and so on. The latter library is used for multilingual
    support. Using this library, almost all world-famous language scripts can be rendered.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will provide you with a detailed description on how to build the
    font engine; we will implement simple text rendering with the help of FreeType.
    We will use the capabilities of the Harfbuzz library to print multilingual text
    rendering, such as Arabic, Thai, Tamil, Punjabi, and so on. Last but not least,
    you will learn the technique to render text in the screen coordinate system on
    the **Head Up Display** (**HUD**) or overlays.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Font rendering with the FreeType project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will render a simple Latin text in the 3D space. For this,
    we can create a texture bitmap for each character and render it in a quad geometry
    (rectangle) shape. However, creating each character bitmap could be expensive
    in terms of memory management and performance because it is required to load several
    bitmaps in the texture memory. Instead, the better solution is to create a big
    texture embedded with all characters in it and use their texture coordinates to
    map them on the geometry quad.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the process to render fonts using the FreeType library is as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the FreeType library. This initializes the necessary FreeType data
    structure.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the font face. This loads the font file and generates the font style (font
    face) information.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the font size. With the specified size of the font, create an empty
    texture big enough to contain all glyphs. In order to make the texture backward
    compatible with OpenGL ES 2.0, choose its texture size to be a power of two.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the font face data contents. This uses the font face and metric information
    to create glyph images on an empty texture, which is called texture atlas. Glyphs
    will be drawn in the form of row and columns, as shown in the next image.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the glyph. This stores the texture coordinates of each glyph image from
    the texture atlas in a data structure and maps it to its respective charcode.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the text. The glyph map contains all character codes, picks the desired
    character, and maps the respective texture coordinate from the texture atlas to
    the quad geometry of each character. For example, the following image shows the
    printing of the Hello World from the texture atlas:![Font rendering with the FreeType
    project](img/5527OT_08_01.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Classes and data structure**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a brief description of all the classes and related data structures
    used in font rendering:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`FontGenerator`: This class loads the font file with the help of the FreeType
    library. It stores important information from the font file in the related data
    structure. It uses the FreeType library data structure to build the bitmap texture;
    the bitmap information for each character/glyph is stored locally in a quick accessible
    map:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`library`: This is the handle of the FreeType library instance.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fontface`: Each font may contain one or more font faces or typeface; it has
    a specific weight, style, condensation, width, slant, italicization, ornamentation,
    and designer or foundry.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glyphs`: This is the STL map of glyph and character code.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atlasTex`: This contains the handle of the atlas texture object.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Glyph`: This data structure stores information related to a glyph present
    in the font file:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Metric`: Glyph metric is used to position the glyph when rendered in the 2D/3D
    space.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`texCoordX`, `texCoordY`, `atlasX`, and `atlasY`: These store texture coordinates
    of glyphs present in the texture atlas.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`advanceHorizontal` and `advanceVertical`: The advance information is helpful
    in placing next adjacent character with respect to current glyph.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Font`: This class is derived from `FontGenerator` and provides an interface
    to load the font file and a helper function to render text.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FontSample`: This class acts as a consumer of the font renderer; it renders
    sample text for demonstration purposes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the class diagram of the design; the `Font` class
    is derived from `FontGenerator` and `Model`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Font rendering with the FreeType project](img/5527OT_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FreeType project is an open source library used for font rasterization;
    it reads font files and is able to generate bitmaps from the vector/curve information
    stored in such files. This library is written in ANSI-C, which makes it portable
    across platforms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library is freely available under the download section at [http://www.freetype.org](http://www.freetype.org).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The **FreeType License** (**FTL**) is the most commonly used one. This is a
    BSD-style license with a credit clause and is compatible with the GNU Public License
    (GPL) version 3 and not with the GPL version 2\. In our GLPI framework, we will
    use the 2.5.4 version, which is placed under the `GLPIFramework/Font/FreeType`
    folder.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Build process**: The following points provide a detailed description of the
    build process for the FreeType library and other source files required to implement
    this recipe:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Android platform**: We need the makefile to build the FreeType project library.
    Add the `Android.mk` makefile under `GLPIFramework/Font/FreeType`; edit this makefile,
    as shown in the following code. This will be compiled as a shared library, which
    is named as GLPift2\. Optionally, you can also add the source code directly in
    the main project makefile instead of compiling a shared library:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `Android.mk` makefile present in the project directory under the `JNI`
    folder (`<Source code path>/SimpleFont/Android/JNI`) and include the path of the
    FreeType library `Android.mk` file that we have created in the preceding code:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our `GLPift2.so` shared library in order to link at runtime:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**iOS platform**: On the iOS platform, we need to add the same FreeType project
    source files (mentioned under the `LOCAL_SRC_FILES` makefile variable) to your
    project using the **Build Phase** | **Compile Sources** project properties; click
    on add to select source files.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a path to include header files for the free type project using **Build
    Settings** | **Search Paths** | **Header Search Paths**. For the present case,
    it should be:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following preprocessor macro under **Apple LLVM <compiler version>**
    | **Preprocessing** | **Preprocessor Macros**:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add the `FontGenerator.h/cpp`, `Font.h/cpp` project source files and `FontSample.h/cpp`
    using **File** | **Add Files to <Project Name>**.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to understand the procedure of implementing this
    recipe:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `FontGenerator` class and add the following code body to it; the
    important data structure is already covered in the previous section under classes
    and data structures:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure that the `<ft2build.h>` header file is included in the source.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the FreeType library in the constructor with the `FT_Init_FreeType`
    function; this constructor will be called from the Font class when its object
    is created from the `Renderer::createModels` function. This function creates a
    new instance of the FreeType library and sets the handle to the library:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `loadFont` function is responsible for loading the font file using FreeType''s
    `FT_New_Face` function. This function creates a new face with the available typeface
    and style information in the font file. For example, Arial Bold and Arial Italic
    correspond to two different faces. This function calls the `getCorrectResolution`
    function, which is described in the next step:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before creating the texture atlas, it''s important to check whether the texture
    size is supported by a device using the `getCorrectResolution` function. The maximum
    texture size can be queried using the `GL_MAX_TEXTURE_SIZE` symbolic flag. If
    the texture exceeds the maximum supported limit, this function falls back to the
    next immediate smaller available power of two sizes:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The texture altas we generated for this recipe is made of power 2.0 in order
    to make it compatible with OpenGL ES 2.0 version.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the font information from the FreeType library in the `readFont` function.
    This function sets the font size using `FT_Set_Pixel_Sizes` in pixels:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `fontFace` contains information about the total number of characters in
    the font file. Using this information and the provided font size, the total size
    of the texture atlas is calculated in the power of two dimensions. A two channel
    texture memory is allocated and stored in the `textureData` variable for luminance
    and alpha:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each glyph in the font face is recognized with a unique index; the face object
    contains one or more tables called character maps (charmaps), which are used to
    map glyph indices to character codes. For example, `A` has a character code of
    65 in ASCII encoding.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop through all the available glyph in the font and load the information for
    a current glyph image using `FT_Load_Glyph`. This function stores the glyph image
    in a special object called glyph slot. The `FT_Load_Glyph` accepts three parameters,
    handles the font face object, glyphs indexes, and loads flags:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A glyph slot is a container that stores only one type of image at a time. This
    can be bitmap, outline, and so on. The glyph slot object can be accessed using
    **fontFace** | **glyph**. The bitmap information is generated out of the glyph
    slot using the `FT_Render_Glyph` API; it accepts two arguments, the first argument
    is the glyph slot and the second argument is the render mode flag, which specifies
    how to render the glyph image.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The glyph information is loaded into the glyph data structure and stored as
    a value in the STL map glyphs with the character code as a key:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Load the glyph bitmap in the texture atlas using the `generateTexFromGlyph`
    function. This function writes the raster information from the glyph slot to the
    texture data. After all the characters are rastered, load the texture atlas in
    the OpenGL ES texture object with the help of `glTexImage2D` and delete the local
    texture atlas:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `generateTexFromGlyph` function is responsible for loading the current
    specified glyph in to the glyph slot to load it into a particular position in
    the texture atlas specified by `atlasX`, `atlasY`, and `texSize`. The last parameter
    for this function is used to draw a border around the character, which can be
    very helpful in debugging the positioning of a character in texture rendering.
    For example, see the preceding **Hello World** sample text image; it contains
    a border around each character:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `Font` class derived from `Model` and `FontGenerator`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a vertex shader file called `fontVertex.glsl` and add the following
    code; this shader file receives the vertex and texture coordinate information
    from the OpenGL ES program. The received texture coordinates are further sent
    to the fragment shader for the purpose of texture sampling purpose:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `fontfrag.glsl` fragment shader; it contains a sampler2D variable
    for the texture input and a uniform `TexColor` for the text color:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Load and compile the shader in the `initModel` function and query the vertex
    shader attributes:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `drawGlyph` function is responsible for rendering the glyph. The glyph
    is rendered on a logical square by mapping texture coordinates stored in the glyph
    data structure. Initialize the texture sample with texture unit `0`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The message string is printed with the help of the `printText` function. This
    function loops through the message string and calls the `drawGlyph` function to
    render each character in it. After rendering each character, the next glyph is
    advanced by the horizontal offset `advanceHorizontal` information stored in the
    glyph data structure for the corresponding character code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The present case of `drawGlyph()` can be optimized by bunching multiple draw
    calls into a single one. Multiple glyphs can be defined and drawn in one go if
    all glyph quads are computed and specified along with their texture coordinates
    in vertex attribute buffers. We will leave this optimization as an exercise to
    our readers.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `FontSample` class derived from `Model` and override the `Render()`
    method in order to render the sample text, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `Renderer::createModel` function, load the font file with the desired
    font size and add the `FontSample` model. Make sure that the font file is added
    to the project:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initialization of FreeType is necessary in order to use it properly and
    without any unexpected surprises during use; this initialization is done in the
    constructor of the `Font` class using the `FT_Init_FreeType` API. This ensures
    that all the modules in the library are ready for use. On successful initialization,
    this API returns `0`; otherwise, it returns an error and sets the handle with
    a `NULL` value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The constructor also calls the `loadFont` function; this function loads the
    font file using the `FT_New_Face` API and creates the face object. One font file
    may contain one or more than one font faces; the face contains the font style
    information. It describes a given typeface and style. For example, *Times New
    Roman Regular* and *Times New Roman Italic* correspond to two different faces.
    The `loadFont` function calls `getCorrectResolution` to make sure that the hardware
    device supports the requested texture size of the texture atlas allocation. The
    maximum texture size limit can be queried using `GL_MAX_TEXTURE_SIZE`; if the
    texture size is bigger than the supported limit, it falls back to the next smallest
    available size and returns the new updated resolution and margin size in the `calculatedResolution`
    and `calculatedSize`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readFont` function sets the font size information using the `FT_Set_Pixel_Size`
    API. This function takes three arguments, namely, font face, pixel width, and
    pixel height. The total number of glyphs in the font file, pixel resolution, and
    the margin size are used to calculate the size of texture atlas, which is allocated
    in the power of two and stored in the `textureData`. The allocated texture is
    stored as two channel information: one for the color information and another for
    the alpha component.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Each glyph present in the library is traversed and loaded using the `FT_Load_Glyph`
    API. This loads the current glyph in the glyph slot that can be retrieved with
    `fontFace` | `glyph` and passed to `FT_Render_Glyph` and rasters the bitmap bits.
    These bits are written in the `textureData` using the `generateTexFromGlyph` function.
    The glyph writing in the texture is done from the left to right direction. When
    the number of the glyph reaches the maximum number of glyphs per row, the write
    pointer is set to the next row. After all the glyphs are written in the `textureData`
    texture atlas, create an OpenGL ES texture object and set it with this information:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_08_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: The `Font` class provides the interface to the external world for texture rendering
    purposes. This class first initializes the shaders in the `initModel` function,
    similar to other GLPI framework models. The `printText` function can be used to
    render the text information; this function accepts a text message string as the
    first argument and colors information in the RGBA format as next four parameters.
    The printing function should disable the culling and depth testing. The former
    testing is disabled because we want to view the font on the back faces as well;
    otherwise, it will surprise the user when texture goes suddenly missing. The latter
    case is helpful to keep the text rendered at the top always; we don't want this
    if it gets occluded by some other objects. The alpha blending must be turned on
    with the `glBlendFunc` (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) blending function.
    Traversing through each character prints the string; the corresponding glyph is
    obtained from the glyphs map for the current character code and passed on to the
    `drawGlyph` function. The `drawGlyph` function makes use of the glyph structure
    and generates the necessary information to draw the bitmap image in the 2D or
    3D space. Each glyph is rendered to a square and mapped with texture coordinates
    from the texture atlas; glyphs need to be placed according to font metrics or
    the glyph metric in the 2D/3D space.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The glyph metric contains the distance information associated with a particular
    glyph to help it in positioning while creating a text layout.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_08_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `printText` function renders a simple text where the transformation can
    be applied to the string to achieve various effects. We have seen that each string
    is rendered as a single glyph at a time. Therefore, it''s possible to perform
    transforming animations on a single glyph. The following image is an example of
    the glyph animation, where glyphs are arranged in a circular fashion and rotates
    along the *y* axis:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_08_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'In the current recipe, the `animateText` function can be used to render glyphs
    in an animated fashion. The function definition is explained later on; it accepts
    two more parameters: radius and rotation in addition to the `printText` parameter.
    This function renders glyphs that are arranged in a circular fashion and rotate
    along the *y* axis.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the number of characters in the string and the given radius, a locus
    is calculated, and each character is placed in such a way that it always faces
    the camera. This way, the letter always faces the camera, irrespective of its
    position and angle along the *y* axis:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rendering different languages with Harfbuzz*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering different languages with Harfbuzz
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FreeType library performs the rasterization operation in which each character
    is associated with a glyph index; this glyph index maps to the bitmap image. This
    information is more or less sufficient for simple scripts like English, which
    does not change its shape with the context. For example, based on the context,
    Arabic language has four different types of shape forms, where a character may
    change its shape depending on the own location or surrounding characters. With
    Unicode, there was a need for different languages to allow them to create complex
    transformations of glyphs, such as substitution, positioning, bi-directional text,
    context-sensitive shaping, and ligatures. Therefore, we need some special library
    that understands the context of the language and does the job of shaping for us;
    this is where Harfbuzz comes into the picture.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Harfbuzz is a text shaping engine that manages complex text; it performs the
    shaping job on the given Unicode text using the language script and layout direction
    specified by the user. This library does not provide text layout or rendering.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the characteristics of complex text:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**Bi-directionality**: Text written/displayed from left to right and vice versa
    direction. Arabic and Hebrew scripts use the right to left direction. However,
    most other languages, including Latin, are written from left to right. The following
    image shows the mix of English numerals and Arabic text in the bidirectional order.![Rendering
    different languages with Harfbuzz](img/5527OT_08_06.jpg)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shaping**: The character shape depends on the context. For example, the shape
    of the Arabic character changes when it connects to the adjacent characters. The
    following example shows contextual shaping in Arabic.![Rendering different languages
    with Harfbuzz](img/5527OT_08_07.jpg)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ligatures**: A ligature is a special character that combines two or more
    characters into a single character. Here is an example of the Arabic ligature.![Rendering
    different languages with Harfbuzz](img/5527OT_08_08.jpg)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positioning**: Glyphs are adjusted with respect to a given character vertically
    or horizontally; the following image demonstrates the concept of positioning in
    Thai.![Rendering different languages with Harfbuzz](img/5527OT_08_09.jpg)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reordering**: The position of a character depends on the context. In the
    following example, the last character of the Hindi text (Devanagri script) is
    placed in front of the second last character in the final output.![Rendering different
    languages with Harfbuzz](img/5527OT_08_10.jpg)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Split characters**: In this case, the same character appears in more than
    one position.![Rendering different languages with Harfbuzz](img/5527OT_08_11.jpg)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Image courtesy: [http://scripts.sil.org](http://scripts.sil.org)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This recipe will demonstrate text rendering in different types of languages,
    such as Arabic, Thai, Punjabi, Tamil, and English altogether.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes and data structure**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will introduce a new class, which is responsible for shaping the
    text as per the specified language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**FontShaping**: This class is derived from `FontGenerator`. It inherits all
    the vital information from the FreeType library that is necessary for rasterization.
    This class uses the `Harfbuzz-ng` library for text shaping:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering different languages with Harfbuzz](img/5527OT_08_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Harfbuzz-ng` library is an open source library written in ANSI-C. This
    library is freely available under the MIT license.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The library can be downloaded at [http://freedesktop.org/wiki/Software/HarfBuzz/](http://freedesktop.org/wiki/Software/HarfBuzz/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Build process**: The following steps provide a detailed description of the
    installation process for the `Harfbuzz-ng` library and other source files required
    to implement this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Android**: On the Android platform, we need the makefile to build the `Harfbuzz-ng`
    library. Add the `Android.mk` makefile under `GLPIFramework/Font/harfbuzz-ng`.
    Edit this makefile, as given in the following code. This will be compiled as a
    shared library and named as `GLPiharfbuzz`:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our `GLPiharfbuzz.so` shared library in order to link at runtime:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open the `Android.mk` makefile in the present project directory under the (`<Source
    code path>/Localization/Android/JNI`) JNI folder and include the path of the `Android.mk`
    makefile that we have created in the `harfbuzz` library. Additionally, add the
    following source files in order to build this recipe:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**iOS**: On the iOS platform, we need to add the same FreeType project source
    files (mentioned under the `LOCAL_SRC_FILES` makefile variable) to your projects
    using the **Build Phase** | **Compile Sources** project properties. Click on add
    to select source files.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide a path to include the header files for the Harfbuzz project using **Build
    Settings** | **Search Paths** | **Header Search Paths**. For the present case,
    it should be:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, add `FontGenerator.h/cpp`, `FontShaping.h/cpp`, `Font.h/cpp`, and
    `FontSample.h/cpp` using **File** | **Add Files to <Project Name>**.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reuse the first implemented recipe, *Font rendering with FreeType project*,
    and proceed to the following procedure to program this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `FontShaping` class derived from `FontGenerator` and add the following
    code. This class contains two major functions: `setDirectionAndScript` and `produceShape`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `produceShape` function is responsible for text shaping using the `Harfbuzz-ng`
    library. It accepts a string that needs to be shaped as an input parameter and
    returns the code points after processing the shape. These code points are nothing
    but glyph indexes:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Harfbuzz requires scripting and layout direction hints in order to perform
    the text shaping. Therefore, the end user must provide the script type and the
    direction of the text layout:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `FontGenerator::readFont` function, replace the following code. This
    will be useful to map the Harfbuzz-generated code points after text shaping:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace the preceding code with this code:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With respect to the preceding code changes done in the `FontGenerator::readFont`
    function, replace the following code in the `Font::printText` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace the preceding code with this code:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `Renderer::createModels` function, add the necessary font files as per
    the supported languages:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![How to do it...](img/5527OT_08_13.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working logic to render fonts in the current recipe is the same as the previous
    recipe. Therefore, it's strongly advisable to understand the first recipe before
    reading this section, which will only cover the text shaping working concept.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This recipe has introduced a new class called `FontShaping`, which is derived
    from `FontGenerator`. From now on, the `Font` class will be inheriting from `FontShaping,`
    instead of `FontGenerator`. The `FontShaping` class is the core engine for text
    shaping. Internally, this class makes use of the `Harfbuzz-ng` library.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We send UTF-8 encoding as an input parameter for multilingual text rendering
    in the `Font::printText` function. This function calls the `FontShaping::produceShaping`,
    which accepts one more argument in addition to the UTF-8 text, which is a vector
    list of code points that are returned from this function to the caller function.
    Code points are basically indexes of glyphs in the font file. In the multilingual
    text rendering, we have used the index of glyphs instead of character code in
    the glyphs map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The `Harfbuzz-ng` library uses its own temporary buffer (of the `hb_buffer_t`
    type) to calculate the shaping information; this temporary buffer is allocated
    using the `hb_buffer_create` API. The created buffer is used to set the text layout
    direction (`hb_buffer_set_direction`) and language script (`hb_buffer_set_script`)
    in the `setDirectionAndScript` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Use the `hb_buffer_add_utf8` API and provide the UTF8 encoded text to the `Harfbuzz`
    library. In addition, the font face information is required from FreeType in order
    to create its own font (`hb_font_t`). This font is created using the `hb_ft_font_create`
    API. The `hb_shape` API does the shaping job for the input string. It accepts
    the `hb_font_t` and `hb_buffer_t` object as an argument.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: After the shaping process is completed in the library, the number of glyphs
    may change. The `hb_buffer_get_length` API provides the new glyph count. The shaping
    information can be retrieved with the `hb_buffer_get_glyph_infos` API, which returns
    the `hb_glyph_info_t` object that contains all the glyph code points. These code
    points are collected in a vector list and sent back to the `printText` function.
    Make sure that the temporary buffer must be released from the memory at the end
    of the process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: In the `Font::printText`, the `codePoint` or glyph indexes are retrieved from
    the vector list and render the same way (we have described in the first recipe).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Font rendering with the FreeType project*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering text on Head Up Display
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text rendering on the screen coordinate system is a very common use case of
    printing text. The HUD, also known as overlays, allows you to render the text
    on top of a normal scene. The depth of the scene object does not change the size
    of the text. Examples of HUD are menu items, status bar, game scoreboards, and
    so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, HUD is an orthographic view where the dimensions of left, right,
    top, and bottom are set equal to the viewport of the scene. In this recipe, we
    will print the vertex position of a rotating 3D cube in the screen coordinates.
    All vertices in the cube (near or far) have text in equal size. It is not affected
    by the distance of vertices from the camera position:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering text on Head Up Display](img/5527OT_08_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: In the current recipe, we will reuse the *Drawing APIs in OpenGL ES 3.0* recipe
    from [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES
    3.0 Essentials*. This will render a rotating cube in the 3D space. We will use
    the HUD mechanism to display the positions of each vertex in the screen coordinates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reuse the last recipe, *Rendering different languages with Harfbuzz*, and add
    the following files from another recipe *Drawing APIs in OpenGL ES 3.0* in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Cube.h` and `Cube.cpp` GL ES program files
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CubeVertex.glsl` and `CubeFragment.glsl` GLSL shader files
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following instructions will provide a step-by-step procedure to implement
    HUD:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `Cube.h`/`cpp` and define a new method called `GetScreenCoordinates`.
    This will produce the screen coordinates from the logical coordinates of the cube
    vertices and collect them in a `screenCoordinateVector` vector list. There is
    no change required for imported shaders:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Call the `GetScreenCoordinates` in the `Cube::Render` function after rendering
    the primitives. For this recipe, we change the rendering primitive from `GL_TRIANGLES
    to GL_LINE_LOOP`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `FontSample.h`/`cpp`, create a function called `HeadUpDisplay`; this function
    will be responsible for setting the correct projection system and its dimensions
    for the head up display. The projection system for HUD must be orthographic and
    the dimension must be set to the viewport dimension:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `FontSample::Render()`, call the `HeadUpDisplay` function before rendering
    any drawing primitive. This will enable the HUD viewing. Get the vector list from
    the `Cube` class and render the vertex position with the `Font::printText` function:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The projection system for head up display must always be in the orthographic
    view. The `FontSample::HeadUpDisplay` function sets the projection matrix to an
    orthographic view with the help of the `Transform::TransformOrtho` API. It accepts
    eight parameters, in which the left-right and top-bottom must be specified with
    the correct dimension matched to the viewport size. Set the `Model` and `View`
    as the identity matrix:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `HeadUpDisplay` function must be called before rendering primitives. For
    this recipe, we have collected screen coordinates of each vertex from the Cube
    class and displayed them using the `Font::printText` function with their respective
    screen coordinates position. The screen space coordinates of a vertex can be calculated
    in the logical coordinate system using the `Transform::TransformProject` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/5527OT_08_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Rendering* *different languages with Harfbuzz*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Understanding projection system in GLPI* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Drawing APIs in OpenGL ES 3.0* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章. OpenGL ES 3.0 基础")中的*OpenGL ES 3.0 绘图 API*配方，*OpenGL
    ES 3.0 基础*
