<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/><st c="0">1</st></h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><st c="2">What’s New in iOS 18</st></h1>
			<p><st c="22">Apple introduced iOS 18 in WWDC 2024 as part of its annual developer’s conference, alongside macOS, tvOS, iPadOS, watchOS, </st><st c="146">and visionOS.</st></p>
			<p><st c="159">Utilizing our app’s latest features and capabilities in each major OS release gives us a competitive advantage. </st><st c="272">Here are the reasons why Apple chose to improve particular domains in the SDK – market research or technology trends are good enough reasons to adopt </st><st c="422">new technologies.</st></p>
			<p><st c="439">However, to understand iOS 18 improvements, we first must understand the background for this version – that’s one of this </st><st c="562">chapter’s goals.</st></p>
			<p><st c="578">In this chapter, we will cover the </st><st c="614">following topics:</st></p>
			<ul>
				<li><st c="631">Understanding iOS </st><st c="650">18 background</st></li>
				<li><st c="663">Exploring </st><st c="674">Swift Testing</st></li>
				<li><st c="687">Learning about the new Swift </st><st c="717">Data improvements</st></li>
				<li><st c="734">Trying the new </st><st c="750">zoom transition</st></li>
				<li><st c="765">Adding a floating tab bar to our </st><st c="799">iPad apps</st></li>
				<li><st c="808">Having more control over scroll views </st><st c="847">in SwiftUI</st></li>
				<li><st c="857">Changing the text </st><st c="876">rendering behavior</st></li>
				<li><st c="894">Positioning sub-views from </st><st c="922">another view</st></li>
				<li><st c="934">Entering the </st><st c="948">AI revolution</st></li>
			</ul>
			<p><st c="961">If that sounds like an exciting chapter, you are not wrong. </st><st c="1022">Let’s start by understanding the background of </st><st c="1069">iOS 18.</st></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><st c="1076">Technical requirements</st></h1>
			<p><st c="1099">For this chapter, it’s essential to download Xcode version 16.0 or higher from the </st><st c="1183">App Store.</st></p>
			<p><st c="1193">Ensure that you’re operating on the most recent version of macOS (Ventura or newer). </st><st c="1279">Just search for Xcode in the App Store, choose the latest version, and proceed with the download. </st><st c="1377">Open Xcode and complete any further setup instructions that appear. </st><st c="1445">After Xcode is completely up and running, you </st><st c="1491">can begin.</st></p>
			<p><st c="1501">This chapter includes many code examples, and can be found in the following </st><st c="1578">GitHub repository:</st></p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%201"><st c="1596">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%201</st></a></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><st c="1682">Understanding iOS 18 background</st></h1>
			<p><st c="1714">Releasing a major iOS version is always a big deal, even if it’s the 18</st><st c="1786">th</st><st c="1789"> already. </st><st c="1799">Let’s try to analyze the iOS SDK before </st><st c="1839">iOS 18:</st></p>
			<ul>
				<li><strong class="bold"><st c="1846">SwiftUI</st></strong><st c="1854"> is becoming more mature</st><a id="_idIndexMarker000"/><st c="1878"> and capable. </st><st c="1892">However, some features, such as complex animations or transitions, gesture handling, navigation, and drawing, remain challenging to implement </st><st c="2034">using SwiftUI.</st></li>
				<li> <strong class="bold"><st c="2048">Core Data</st></strong><st c="2058"> is the go-to framework for most iOS developers</st><a id="_idIndexMarker001"/><st c="2105"> as a solution for storing </st><st c="2132">data persistently.</st></li>
				<li><st c="2150">While </st><strong class="bold"><st c="2157">XCTest</st></strong><st c="2163"> is considered a robust</st><a id="_idIndexMarker002"/><st c="2186"> and convenient testing framework, it lacks features that are commonly available on other platforms, such as parameterized testing and better </st><st c="2328">testing organization.</st></li>
				<li><strong class="bold"><st c="2349">WidgetKit</st></strong><st c="2359">’s popularity proves that the ability</st><a id="_idIndexMarker003"/><st c="2397"> to show information at a glance is crucial in </st><st c="2444">today’s world.</st></li>
			</ul>
			<p><st c="2458">No one can argue that this list is important. </st><st c="2505">However, one critical topic that Apple didn’t focus on until WWDC 2024 is </st><st c="2579">artificial intelligence.</st></p>
			<p><st c="2603">The rise of OpenAI’s ChatGPT, followed by thousands of machine learning and AI tools, put Apple in a weird situation. </st><st c="2722">This is not the first time Apple has left behind some temporary trend, but this time it was different. </st><st c="2825">AI’s potential influence on humanity indicates that this is not a regular trend or technology evolution; it is practically a revolution that will change </st><st c="2978">the world.</st></p>
			<p><st c="2988">The question is, where is Apple with its set of platforms and technologies? </st><st c="3065">Does it have an answer to the </st><st c="3095">AI revolution?</st></p>
			<p><st c="3109">Before diving into that question, let’s first review the new features and frameworks introduced in iOS 18 and explore how the latest version tackles some of the key challenges we face in iOS development. </st><st c="3314">Don’t worry, though – we’ll cover the AI revolution in the final section and throughout the book. </st><st c="3412">Now, let’s discuss a new framework – </st><st c="3449">Swift Testing.</st></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><st c="3463">Introducing Swift Testing</st></h1>
			<p><st c="3489">Swift Testing is a new framework</st><a id="_idIndexMarker004"/><st c="3522"> with a new and refreshing approach to testing. </st><st c="3570">Swift Testing contains modern features such as macros, which work with structs instead of classes and can tag tests and </st><st c="3690">test suites.</st></p>
			<p><st c="3702">Swift Testing is supposed to replace XCTest, which was introduced in 2013 as part of Xcode 5. </st><st c="3797">XCTest belongs to older times when Objective-C was the dominant language. </st><st c="3871">However, Swift took over, and Apple understood that iOS developers needed a modern </st><st c="3954">testing framework.</st></p>
			<p><st c="3972">Here’s a simple </st><st c="3989">test function:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="4003">@Test("Test view model increment function", .enabled(if: AppSettings.CanDecrement), .tags(.critical))</st></strong><st c="4105">
func testViewModelIncrement() async throws {
//         preparation
        let viewmodel = CounterViewModel()
        viewmodel.count = 5
//        execution
        viewmodel.increment(by: 1)
//        verification
</st><strong class="bold"><st c="4277">        #expect(viewmodel.count == 6)</st></strong><st c="4306">
    }.</st></pre>			<p><st c="4309">We can see how simple it is to write a test function in Swift Testing. </st><st c="4381">Notice the preceding Swift macro, which configures and tags the function as critical in addition to providing the </st><st c="4495">test description.</st></p>
			<p><st c="4512">If your app doesn’t have a test function, Swift Testing</st><a id="_idIndexMarker005"/><st c="4568"> is a great way to start (to read more about Swift Testing, go to </st><a href="B21795_14.xhtml#_idTextAnchor430"><em class="italic"><st c="4634">Chapter 14</st></em></a><st c="4644">).</st></p>
			<p><st c="4647">Now, let’s discuss another new framework that handles our </st><st c="4706">persistent store.</st></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/><st c="4723">Introducing Swift Data Improvements</st></h1>
			<p><st c="4759">Swift Data was introduced</st><a id="_idIndexMarker006"/><st c="4785"> in WWDC 2023 as part of iOS 17, and its goal was to replace the old but popular Core </st><st c="4871">Data framework.</st></p>
			<p><st c="4886">Swift Data provides a modern API based on Swift, which can help reduce friction when working with persistent stores. </st><st c="5004">One of the trends we see in Apple development tools is moving away from GUI to code-based tools. </st><st c="5101">A good example is SwiftUI – even though it is possible to drag and drop components to build a user interface, the primary way to do this is in code. </st><st c="5250">The same goes for App Intents and Swift Package Managers. </st><st c="5308">The data layer goes through the same concept – in Swift Data, we don’t have any data model editor, so we build our data model using </st><st c="5440">only code.</st></p>
			<p><st c="5450">For example, here’s how to create a data model for a </st><code><st c="5504">Book</st></code><st c="5508"> entity:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="5516">@Model</st></strong><st c="5523">
class Book {
    var author: String
    var title: String
    var publishedDate: Date
}</st></pre>			<p><st c="5599">At first glance, it seems like a regular </st><code><st c="5641">Book</st></code><st c="5645"> class – and it is! </st><st c="5665">This time, we added the </st><code><st c="5689">@Model</st></code><st c="5695"> macro, which does all </st><st c="5718">that magic.</st></p>
			<p><st c="5729">When Swift Data was introduced, it already had many features, such as relationships and deletion rules. </st><st c="5834">Despite that, many developers felt that the framework wasn’t mature enough to replace </st><st c="5920">Core Data.</st></p>
			<p><st c="5930">In iOS 18, Apple added</st><a id="_idIndexMarker007"/><st c="5953"> some features to Swift Data that, if it is not already there, will bring it closer to where it </st><st c="6049">should be.</st></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><st c="6059">Unique value</st></h2>
			<p><st c="6072">The first and maybe most important</st><a id="_idIndexMarker008"/><st c="6107"> new feature</st><a id="_idIndexMarker009"/><st c="6119"> in iOS 18 is the ability to construct a </st><strong class="bold"><st c="6160">unique value</st></strong><st c="6172"> for the model based on </st><st c="6196">its attributes:</st></p>
			<pre class="source-code">
<code><st c="6273">Book</st></code><st c="6277"> class’s unique identifier is based on combining the </st><code><st c="6330">name</st></code><st c="6334"> and </st><code><st c="6339">publicationName</st></code><st c="6354"> attributes.</st></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><st c="6366">History API</st></h2>
			<p><st c="6378">Another new and exciting feature</st><a id="_idIndexMarker010"/><st c="6411"> is the History API. </st><st c="6432">Using the History API, we can fetch</st><a id="_idIndexMarker011"/><st c="6467"> transactions and changes that have been made to our Swift Datastore over a particular time range. </st><st c="6566">This capability allows us to update our app when we work with extensions such as widgets or sync changes to </st><st c="6674">the server.</st></p>
			<p><st c="6685">Reading the transaction history is not the only “pro” feature added to Swift Data. </st><st c="6769">Let’s talk about Core Data for </st><st c="6800">a second.</st></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><st c="6809">Custom data stores in Swift Data</st></h2>
			<p><st c="6842">Core Data fundamentals</st><a id="_idIndexMarker012"/><st c="6865"> included the ability to work with</st><a id="_idIndexMarker013"/><st c="6899"> any data store type we wanted – XML, SQLite, CSV files, or even a remote server. </st><st c="6981">Although almost all apps that implement Core Data work with SQLite as their data store, it was built to be agnostic to whatever </st><st c="7109">happens underneath.</st></p>
			<p><st c="7128">Starting with iOS 18, Apple also brings custom data stores to </st><st c="7191">Swift Data.</st></p>
			<p><st c="7202">For example, let’s say that we want to base our data store on a CSV file. </st><st c="7277">We start by creating a new data store configuration</st><a id="_idIndexMarker014"/><st c="7328"> specifically for CSV </st><st c="7350">data</st><a id="_idIndexMarker015"/><st c="7354"> stores:</st></p>
			<pre class="source-code"><st c="7362">
final class CSVStoreConfiguration: DataStoreConfiguration {
    typealias Store = CSVDataStore
    var name: String
    var schema: Schema?
    </st><st c="7491">var fileURL: URL
    init(name: String, schema: Schema? </st><st c="7543">= nil, fileURL: URL)
   {
        self.name = name
        self.schema = schema
        self.fileURL = fileURL
    }
    static func == (lhs: CSVStoreConfiguration, rhs:
      CSVStoreConfiguration) -&gt; Bool {
        return lhs.name == rhs.name
    }
    func hash(into hasher: inout Hasher) {
        hasher.combine(name)
    }
}</st></pre>			<p><st c="7804">The </st><code><st c="7809">CSVStoreConfiguration</st></code><st c="7830"> class is a new data store configuration that accepts the name and the schema (similar to how Swift Data configuration setup works today), and we added an additional parameter, which is </st><code><st c="8016">fileURL</st></code><st c="8023"> – the location of our </st><st c="8046">CSV file.</st></p>
			<p><st c="8055">In the </st><code><st c="8063">init()</st></code><st c="8069"> function, we can also check whether the CSV file exists or whether we need to create a </st><st c="8157">new one.</st></p>
			<p><st c="8165">Notice that there’s a </st><code><st c="8188">typealias</st></code><st c="8197"> named </st><code><st c="8204">Store</st></code><st c="8209">, which represents</st><a id="_idIndexMarker016"/><st c="8227"> a new type</st><a id="_idIndexMarker017"/><st c="8238"> called </st><code><st c="8246">CSVDataStore</st></code><st c="8258">. This is the actual store class where everything happens. </st><st c="8317">Let’s create </st><st c="8330">it now:</st></p>
			<pre class="source-code"><st c="8337">
final class </st><strong class="bold"><st c="8350">CSVDataStore</st></strong><st c="8362">: DataStore {
    typealias Configuration = </st><strong class="bold"><st c="8403">CSVStoreConfiguration</st></strong><st c="8424">
    typealias Snapshot = DefaultSnapshot
    var configuration: </st><strong class="bold"><st c="8481">CSVStoreConfiguration</st></strong><st c="8502">
    var name: String
    var schema: Schema
    var identifier: String
    required init(_ configuration: CSVStoreConfiguration,
      migrationPlan: (any SchemaMigrationPlan.Type)?)
      throws {
        self.configuration = configuration
        self.name = configuration.name
        self.schema = configuration.schema!
        </st><st c="8775">self.identifier =
          configuration.fileURL.lastPathComponent
    }
}</st></pre>			<p><st c="8836">Our </st><code><st c="8841">CSVDataStore</st></code><st c="8853"> class conforms to the </st><code><st c="8876">DataStore</st></code><st c="8885"> protocol and has similar properties, such as </st><code><st c="8931">name</st></code> <st c="8935">and </st><code><st c="8940">schema</st></code><st c="8946">.</st></p>
			<p><st c="8947">The </st><code><st c="8952">CSVDataStore</st></code><st c="8964"> class must handle a persistent store’s basic operations, such as inserting new items and deleting or updating </st><st c="9075">existing ones.</st></p>
			<p><st c="9089">Notice that the </st><code><st c="9106">init()</st></code><st c="9112"> function includes a migration type, so we can even handle migrations when our </st><st c="9191">schema changes.</st></p>
			<p><st c="9206">To handle all of these</st><a id="_idIndexMarker018"/><st c="9229"> operations, we need to implement two important</st><a id="_idIndexMarker019"/><st c="9276"> methods that are part of the </st><code><st c="9306">DataStore</st></code><st c="9315"> protocol – </st><code><st c="9327">fetch()</st></code> <st c="9334">and </st><code><st c="9339">save()</st></code><st c="9345">:</st></p>
			<pre class="source-code"><st c="9347">
func fetch&lt;T&gt;(_ request: DataStoreFetchRequest&lt;T&gt;)
  throws -&gt; DataStoreFetchResult&lt;T, DefaultSnapshot&gt;
    where T : PersistentModel {
        let predicate = request.descriptor.predicate
        return DataStoreFetchResult(descriptor:
          request.descriptor, fetchedSnapshots: [],
          relatedSnapshots: [:])
          .  </st><st c="9630">// perform fetch operations
    }
    func save(_ request:
      DataStoreSaveChangesRequest&lt;DefaultSnapshot&gt;)
      throws -&gt; DataStoreSaveChangesResult&lt;DefaultSnapshot&gt;
      {
        var remappedIdentifiers = [PersistentIdentifier:
          PersistentIdentifier]()
        for snapshot in request.inserted {
            // insert new items
        }
        for snapshot in request.updated {
            // update existing items
        }
        for snapshot in request.deleted {
            // delete items
        }
        return
          DataStoreSaveChangesResult&lt;DefaultSnapshot&gt;(for:
          self.identifier,
          remappedIdentifiers: remappedIdentifiers)
       }</st></pre>			<p><st c="10142">These two functions perform all the magic underneath. </st><st c="10197">In this code example, I left the function implementation empty – it is up to you to fill it in according to the specific data store implementation. </st><st c="10345">Once we modify our CSV file, we can return the results to </st><st c="10403">the app.</st></p>
			<p><st c="10411">The </st><code><st c="10416">History</st></code><st c="10423"> API, the </st><code><st c="10433">DataStore</st></code><st c="10442"> protocol, and the ability</st><a id="_idIndexMarker020"/><st c="10468"> to provide uniqueness</st><a id="_idIndexMarker021"/><st c="10490"> to entities make Swift Data much more mature and capable. </st><st c="10549">To get started with Swift Data, read </st><a href="B21795_02.xhtml#_idTextAnchor043"><em class="italic"><st c="10586">Chapter 2</st></em></a><st c="10595">.</st></p>
			<p><st c="10596">Next, let’s talk about an exciting improvement in </st><st c="10647">SwiftUI transition.</st></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/><st c="10666">Introducing zoom transition</st></h1>
			<p><st c="10694">This is a small improvement, but it may</st><a id="_idIndexMarker022"/><st c="10734"> indicate an interesting direction Apple is taking with SwiftUI. </st><st c="10799">In general, UIKit’s transitioning capabilities are very robust and provide us with the flexibility to create any transition we want. </st><st c="10932">Even before that, from the beginning, UIKit had some nice built-in transitions we could use to make our navigation </st><st c="11047">more appealing.</st></p>
			<p><st c="11062">In iOS 18, Apple added a new transition that allows us to navigate to a new view using a </st><st c="11152">zoom animation.</st></p>
			<p><st c="11167">Let’s create an album grid that, when tapping on the album, transitions to a full album screen with a </st><st c="11270">zoom animation:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="11285">    @Namespace() var namespace</st></strong><st c="11312">
    var body: some View {
        NavigationStack {
            ScrollView {
                LazyVGrid(columns: [
                  GridItem(.adaptive(minimum: 150)) ]) {
                    ForEach(Album.albums) { album in
                        NavigationLink {
                            Image(album.imageName)
                                .resizable()          </st><a id="_idTextAnchor024"/><a id="_idTextAnchor025"/><strong class="bold"><st c="11512">.navigationTransition(.zoom(sourceID: album.id, in:</st></strong>
<strong class="bold"><st c="11563">  namespace))</st></strong><st c="11575">
                        } label: {
                            Image(album.imageName)
                                .resizable()
                                .scaledToFit()
                                .frame(minWidth: 0,
                                  maxWidth: .infinity)
                                .frame(height: 150)
                                .cornerRadius(8.0)
                        }
  </st><a id="_idTextAnchor026"/><a id="_idTextAnchor027"/><strong class="bold"><st c="11720">.matchedTransitionSource(id:</st></strong>
<strong class="bold"><st c="11748">                          album.id, in: namespace)</st></strong><st c="11773">
                    }
                }
            }
        }
        .padding()
    }</st></pre>			<p><st c="11794">This example shows a simple grid view</st><a id="_idIndexMarker023"/><st c="11832"> of albums, a NavigationStack, and a NavigationLink. </st><st c="11885">The idea of performing the zoom transition is to match the source (the image we tapped on) to the destination (the image we </st><st c="12009">zoomed into).</st></p>
			<p><st c="12022">We do that by adding two </st><st c="12048">view modifiers:</st></p>
			<ul>
				<li><code><st c="12063">navigationTransition</st></code><st c="12084">: We add this modifier to the source view. </st><st c="12128">The source view, in our case, is the album view in the grid. </st><st c="12189">We select the type of animation (currently, it’s a zoom animation) and the </st><st c="12264">source ID.</st></li>
				<li><code><st c="12274">matchedTransitionSource</st></code><st c="12298">: We add this modifier to the destination view. </st><st c="12347">In our example, the destination view is the full-screen view of the album. </st><st c="12422">Again, we provide the ID of the album we want to present so SwiftUI can perform the zoom animation between </st><st c="12529">these views.</st></li>
			</ul>
			<p><st c="12541">Creating the match between the views allows SwiftUI to perform a nice zoom animation, similar to what we see in the Photos app. </st><st c="12670">Look at </st><em class="italic"><st c="12678">Figure 1</st></em><em class="italic"><st c="12686">.1</st></em><st c="12688">:</st></p>
			<div><div><img src="img/B21795_01_01.jpg" alt="Figure 1.1: Zoom transition between photos grid and a full-screen view"/><st c="12690"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12691">Figure 1.1: Zoom transition between photos grid and a full-screen view</st></p>
			<p><em class="italic"><st c="12761">Figure 1</st></em><em class="italic"><st c="12770">.1</st></em><st c="12772"> shows how the zoom animation looks in a couple of frames based on the p</st><a id="_idTextAnchor028"/><a id="_idTextAnchor029"/><st c="12844">receding </st><st c="12854">code example.</st></p>
			<p><st c="12867">Zoom transitions serve</st><a id="_idIndexMarker024"/><st c="12890"> more than aesthetic purposes. </st><st c="12921">They inform the user about the changes occurring on the screen, helping them </st><st c="12998">stay oriented.</st></p>
			<p><st c="13012">To read more about navigation in iOS, read </st><a href="B21795_04.xhtml#_idTextAnchor148"><em class="italic"><st c="13056">Chapter 4</st></em></a><st c="13065">.</st></p>
			<p><st c="13066">Speaking of navigation, iPadOS navigation gained a unique and valuable capability – the </st><st c="13155">floating bar.</st></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/><st c="13168">Adding a floating tab bar</st></h1>
			<p><st c="13194">iPad is not the focus</st><a id="_idIndexMarker025"/><st c="13216"> of this book. </st><st c="13231">This is not because iPadOS is unimportant but because most, if not all, of the topics we discuss here are also suitable </st><st c="13351">for iPadOS.</st></p>
			<p><st c="13362">However, there are special features that are relevant to iPadOS that are worth mentioning. </st><st c="13454">One of them is the float </st><st c="13479">tab bar.</st></p>
			<p><st c="13487">The tab bar has existed in iOS since its very beginning. </st><st c="13545">It allows users to navigate between different sections of an app. </st><st c="13611">In both iOS and iPadOS, the tab is located at the bottom of the screen. </st><st c="13683">While it looks perfectly fine on small devices, a tab bar on big screens seems stretched and doesn’t use the </st><st c="13792">large space.</st></p>
			<p><st c="13804">One solution for handling navigation in a iPadOS is to implement a sidebar – a view on the side that displays the different sections of </st><st c="13941">the app.</st></p>
			<p><st c="13949">In iPadOS 18, the position</st><a id="_idIndexMarker026"/><st c="13976"> of the sidebar changed, and it is now located at the top of the screen, floating over the app content. </st><st c="14080">Not only that; the user can also transition between a tab bar and a sidebar. </st><st c="14157">Let’s see how to do that </st><st c="14182">in code:</st></p>
			<pre class="source-code"><st c="14190">
struct ContentView: View {
    var body: some View {
        TabView {
            Tab("Home", systemImage: "house.fill") {  }
            Tab("Profile", systemImage:
              "person.crop.circle") { }
            Tab("Settings", systemImage: "gear") { }
        }
        .tint(.red)
</st><strong class="bold"><st c="14402">        .tabViewStyle(.sidebarAdaptable)</st></strong><st c="14434">
    }
}</st></pre>			<p><st c="14438">This code example looks straightforward but includes a view modifier called </st><code><st c="14515">tabViewStyle</st></code><st c="14527">. Currently, it has only one option to choose from – </st><code><st c="14580">sidebarAdaptable</st></code><st c="14596">. When we add this view modifier, a button is added to the tab bar that allows the user to change the layout. </st><st c="14706">Let’s see how it looks (</st><em class="italic"><st c="14730">Figure 1</st></em><em class="italic"><st c="14739">.2</st></em><st c="14741">):</st></p>
			<div><div><img src="img/B21795_01_02.jpg" alt="Figure 1.2: The Tab bar adapts a sidebar layout"/><st c="14744"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="14831">Figure 1.2: The Tab bar adapts a sidebar layout</st></p>
			<p><em class="italic"><st c="14878">Figure 1</st></em><em class="italic"><st c="14887">.2</st></em><st c="14889"> shows the two layouts</st><a id="_idIndexMarker027"/><st c="14911"> for our tab bar. </st><st c="14929">The new sidebar improves the user experience and makes navigating and focusing on content easier. </st><st c="15027">It also resembles Apple’s apps, such as the TV app, which aligns with what users can expect from </st><st c="15124">our app.</st></p>
			<p><st c="15132">Another important aspect of SwiftUI that required improvement is scroll views. </st><st c="15212">Let’s go over major changes in </st><st c="15243">that area.</st></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor031"/><st c="15253">Having more control over scroll views</st></h1>
			<p><st c="15291">Controlling and observing scroll view behavior</st><a id="_idIndexMarker028"/><st c="15338"> was part of the reason why UIKit developers ha</st><a id="_idTextAnchor032"/><a id="_idTextAnchor033"/><a id="_idTextAnchor034"/><st c="15385">dn’t moved to </st><st c="15400">SwiftUI yet.</st></p>
			<p><st c="15412">Scroll views are crucial in mobile apps, not just because of the small screen, which often requires the user to scroll for more content, but also because they help reuse visible content to minimize memory usage or adjust our UI based on </st><st c="15650">scroll position.</st></p>
			<p><st c="15666">However, why is handling scroll views in SwiftUI </st><a id="_idIndexMarker029"/><st c="15716">more complex than in UIKit? </st><st c="15744">We can think of </st><st c="15760">two reasons:</st></p>
			<ol>
				<li><strong class="bold"><st c="15772">SwiftUI is relatively new</st></strong><st c="15798">: SwiftUI is still considered to be a new framework. </st><st c="15852">Think how much time it took for UIKit to become a mature framework. </st><st c="15920">Obviously, we can achieve this in several years and 17 years </st><st c="15981">of development.</st></li>
				<li><code><st c="16336">@State</st></code><st c="16342"> variable or a </st><st c="16357">view modifier.</st></li>
			</ol>
			<p><st c="16371">These reasons lead to many workarounds that developers use to achieve the desired user experience. </st><st c="16471">Fortunately, iOS 18 gives us two view modifiers that make SwiftUI scroll views more appealing than ever. </st><st c="16576">We’ll start </st><st c="16588">with </st><code><st c="16593">onScrollGeometryChange</st></code><st c="16615">.</st></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor035"/><st c="16616">Observing the scroll view position</st></h2>
			<p><st c="16651">Up until now, SwiftUI hasn’t provided</st><a id="_idIndexMarker030"/><st c="16689"> any direct API to observe the scroll view position. </st><st c="16742">Many developers had to find a workaround or use UIKit as a solution. </st><st c="16811">Now, we have an </st><code><st c="16827">onScrollGeometryChange</st></code><st c="16849"> view modifier that allows us to observe any change in the </st><st c="16908">scroll position.</st></p>
			<p><st c="16924">Let’s say we have a </st><code><st c="16945">VStack</st></code><st c="16951"> view within a scroll view, and we wish to show a </st><strong class="bold"><st c="17001">Scroll to the top</st></strong><st c="17018"> button whenever the user scrolls down to allow them to return to the top of </st><st c="17095">the list.</st></p>
			<p><st c="17104">Let’s look at the </st><st c="17123">following code:</st></p>
			<pre class="source-code"><st c="17138">
        ScrollViewReader { proxy in
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    ForEach(albums) { album in
                        ExtractedView(album: album)
                            .id(album.id)
                    }
                }
            }
            .overlay(alignment: .bottom) {
                if showScrollToTop {
                    Button("Scroll to top") {
                            proxy.scrollTo(albums[0].id,
                             anchor: .top)
                    }
                    .buttonStyle(.borderedProminent)
                }
            }
</st><strong class="bold"><st c="17458">            .onScrollGeometryChange(for: Bool.self) {</st></strong>
<strong class="bold"><st c="17499">            geometry in</st></strong>
<strong class="bold"><st c="17511">                geometry.contentOffset.y &lt;</st></strong>
<strong class="bold"><st c="17538">                geometry.contentInsets.bottom + 300</st></strong>
<strong class="bold"><st c="17574">            } action: { oldValue, newValue in</st></strong>
<strong class="bold"><st c="17608">                withAnimation {</st></strong>
<strong class="bold"><st c="17624">                    showScrollToTop = !newValue</st></strong>
<strong class="bold"><st c="17652">                }</st></strong>
<strong class="bold"><st c="17654">            }</st></strong><st c="17656">
        }</st></pre>			<p><st c="17658">In this code example, we can see a </st><code><st c="17693">VStack</st></code><st c="17699"> view inside a scroll view. </st><st c="17727">The </st><code><st c="17731">VStack</st></code><st c="17737"> view contains a list of albums. </st><st c="17770">Notice that we have an </st><code><st c="17793">onScrollGeometryChange</st></code><st c="17815"> view modifier for the scroll view itself. </st><st c="17858">The view modifier has a closure that runs each time the scroll position changes with a </st><code><st c="17945">geometry</st></code><st c="17953"> parameter. </st><st c="17965">Within the closure, we inspect the scroll view content offset, and if it reaches a specific threshold, we show/hide the </st><strong class="bold"><st c="18085">Scroll to top</st></strong><st c="18098"> button using a specific </st><st c="18123">state variable.</st></p>
			<p><st c="18138">The </st><code><st c="18143">ScrollViewReader</st></code><st c="18159"> view, which wraps</st><a id="_idIndexMarker031"/><st c="18177"> the scroll view, provides a proxy to the scroll view so we can scroll to the top when the user presses </st><st c="18281">the button.</st></p>
			<p><st c="18292">We can use the </st><code><st c="18308">onScrollGeometryChange</st></code><st c="18330"> method for more use cases than just toggling a button. </st><st c="18386">For example, we can use it to perform a network request in an infinity list where we need to load more content from the server when the user reaches the bottom. </st><st c="18547">Additional examples would be having a sticky header or a progress indicator, or even just sending analytics. </st><st c="18656">These use cases were complex to implement before iOS 18 and are now </st><st c="18724">extremely simple.</st></p>
			<p><st c="18741">The improvement in the second scroll view seems to belong to the same family. </st><st c="18820">Let’s review </st><st c="18833">it now.</st></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/><st c="18840">Observing items’ visibility</st></h2>
			<p><st c="18868">Checking whether a view is visible</st><a id="_idIndexMarker032"/><st c="18903"> inside a scroll view is not easy. </st><st c="18938">Up until now, we had to calculate the view frame versus the scroll view content offset, not to mention observe that during a scroll view. </st><st c="19076">Lucky for us, we now have a new modifier </st><st c="19117">called </st><code><st c="19124">onScrollVisibilityChange</st></code><st c="19148">.</st></p>
			<p><st c="19149">Suppose we want to change a view while it enters our scroll view. </st><st c="19216">For example, we might want to report analytics or print to </st><st c="19275">the console.</st></p>
			<p><st c="19287">Let’s look at the </st><st c="19306">following example:</st></p>
			<pre class="source-code"><st c="19324">
ForEach(albums) { album in
    ExtractedView(album: album)
           .id(album.id)
           .</st><strong class="bold"><st c="19395">onScrollVisibilityChange(threshold: 0.9) {</st></strong>
<strong class="bold"><st c="19438">             visible in</st></strong>
<strong class="bold"><st c="19449">                if visible {</st></strong>
<strong class="bold"><st c="19462">                   print("\(album.title) appears")</st></strong>
<strong class="bold"><st c="19494">                }</st></strong>
<strong class="bold"><st c="19496">           }</st></strong><st c="19498">
}</st></pre>			<p><st c="19500">This code example shows the same album row we created in the previous example (in the </st><em class="italic"><st c="19586">Observing the scroll view position</st></em><st c="19620"> section). </st><st c="19631">This time, we added a new view modifier to the view itself – </st><code><st c="19692">onScrollVisibilityChange</st></code><st c="19716">. This view modifier has two parameters – </st><code><st c="19758">threshold</st></code><st c="19767"> and </st><code><st c="19772">closure</st></code><st c="19779"> with a </st><code><st c="19787">Bool</st></code><st c="19791"> parameter (named </st><code><st c="19809">visible</st></code><st c="19816"> in our case). </st><st c="19831">Let’s review </st><st c="19844">them now:</st></p>
			<ul>
				<li><code><st c="19853">threshold</st></code><st c="19863">: The </st><code><st c="19870">threshold</st></code><st c="19879"> parameter defines how much the change must occur for the closure to run. </st><st c="19953">For example, a threshold of 0.2 means that we need 20% of the view to be visible or hidden before it runs the closure and reports </st><st c="20083">the change.</st></li>
				<li><code><st c="20094">closure</st></code><st c="20102">: The closure with the </st><code><st c="20126">Bool</st></code><st c="20130"> parameter runs each time the view reaches the threshold. </st><st c="20188">The </st><code><st c="20192">Bool</st></code><st c="20196"> parameter contains the change – </st><code><st c="20229">true</st></code><st c="20233"> for visible and </st><code><st c="20250">false</st></code> <st c="20255">for hidden.</st></li>
			</ul>
			<p><st c="20267">In our code example, we set the threshold to </st><code><st c="20313">0.9</st></code><st c="20316">. This means that we need to view it to reveal 90% of its size before the closure runs. </st><st c="20404">Inside the closure, we check whether the view is visible before we report it to </st><st c="20484">the console.</st></p>
			<p><st c="20496">We can use this view modifier for many purposes. </st><st c="20546">For example, we can perform a specific animation when the view enters, load additional information, or adjust the screen interface if needed. </st><st c="20688">Something that was complex to do before is now simple to accomplish</st><a id="_idIndexMarker033"/><st c="20755"> using one </st><st c="20766">view modifier.</st></p>
			<p><st c="20780">Scroll view is not the only topic we have more control of. </st><st c="20840">Let’s talk </st><st c="20851">about texts.</st></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor037"/><st c="20863">Changing the text rendering behavior</st></h1>
			<p><st c="20900">Handling texts on screen</st><a id="_idIndexMarker034"/><st c="20925"> was also a very mature area where UIKit provided great frameworks such as TextKit. </st><st c="21009">We could manipulate texts and create almost any effect that </st><st c="21069">we wanted.</st></p>
			<p><st c="21079">In iOS 18, Apple introduced TextRenderer, a protocol that can help us change the default behavior of our texts </st><st c="21191">in SwiftUI.</st></p>
			<p><st c="21202">Let’s say that we want a title with a different opacity for each line and even rotate the lines a bit. </st><st c="21306">This creates a nice effect for the titles in our app. </st><st c="21360">So, let’s see how to do that </st><st c="21389">in SwiftUI:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="21400">struct CustomTextRenderer: TextRenderer {</st></strong>
<strong class="bold"><st c="21442">    func draw(layout: Text.Layout, in ctx: inout</st></strong>
<strong class="bold"><st c="21487">     GraphicsContext) {</st></strong>
<strong class="bold"><st c="21506">        for (index, line) in layout.enumerated() {</st></strong>
<strong class="bold"><st c="21549">            ctx.opacity = Double(index + 1) * 0.1</st></strong>
<strong class="bold"><st c="21587">            ctx.rotate(by: Angle(degrees: Double(index) *</st></strong>
<strong class="bold"><st c="21633">              1))</st></strong>
<strong class="bold"><st c="21637">            ctx.draw(line)</st></strong>
<strong class="bold"><st c="21652">        }</st></strong>
<strong class="bold"><st c="21654">    }</st></strong>
<strong class="bold"><st c="21656">}</st></strong><st c="21657">
struct ContentView: View {
    var body: some View {
        Text("Great new features come to texts in SwiftUI")
            .font(.system(size: 60))
</st><strong class="bold"><st c="21784">            .textRenderer(CustomTextRenderer())</st></strong><st c="21819">
    }
}</st></pre>			<p><st c="21823">This code example has a new structure called </st><code><st c="21869">CustomTextRender</st></code><st c="21885">, which conforms to the </st><code><st c="21909">TextRenderer</st></code><st c="21921"> protocol. </st><st c="21932">We have one important function to implement – the </st><code><st c="21982">draw()</st></code><st c="21988"> function. </st><st c="21999">In this function, we receive an important parameter – </st><code><st c="22053">ctx</st></code><st c="22056"> – the graphic context. </st><st c="22080">The </st><code><st c="22084">TextRenderer</st></code><st c="22096"> protocol also provides us access to the different lines and slices we have in our text. </st><st c="22185">In our example, we can iterate the different lines using the </st><code><st c="22246">layout</st></code><st c="22252"> parameter, change their opacity, and even </st><st c="22295">rotate them.</st></p>
			<p><st c="22307">Once we have the </st><code><st c="22325">CustomTextRender</st></code><st c="22341"> structure, we can</st><a id="_idIndexMarker035"/><st c="22359"> add it to our </st><code><st c="22374">Text</st></code><st c="22378"> component using the </st><code><st c="22399">textRenderer</st></code> <st c="22411">view modifier.</st></p>
			<p><st c="22426">Let’s see how it looks (</st><em class="italic"><st c="22451">Figure 1</st></em><em class="italic"><st c="22460">.3</st></em><st c="22462">):</st></p>
			<div><div><img src="img/B21795_01_03.jpg" alt="Figure 1.3: The Text component with custom text rendering"/><st c="22465"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22467">Figure 1.3: The Text component with custom text rendering</st></p>
			<p><em class="italic"><st c="22524">Figure 1</st></em><em class="italic"><st c="22533">.3</st></em><st c="22535"> shows our text with a different opacity and rotation for each line. </st><st c="22604">Adding effects to text can give a dynamic visualization</st><a id="_idIndexMarker036"/><st c="22659"> for titles and paragraphs and add more life to </st><st c="22707">our apps.</st></p>
			<p><st c="22716">Next, let’s see how SwiftUI has become more mature and capable than ever with positioning sub -iews from </st><st c="22822">other views.</st></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor038"/><st c="22834">Positioning sub-views from another view</st></h1>
			<p><st c="22874">What does it mean to position</st><a id="_idIndexMarker037"/><st c="22904"> sub-views from another view? </st><st c="22934">While this description sounds weird and unclear, it is a nice addition to SwiftUI that can help us provide more dynamic and </st><st c="23058">reusable content.</st></p>
			<p><st c="23075">To understand what it means, let’s take the following code as </st><st c="23138">an example:</st></p>
			<pre class="source-code"><st c="23149">
struct NewsView: View {
    var body: some View {
        Text("Major Breakthrough in Renewable Energy: New Solar Panel Technology Promises 30% Efficiency Increase")
        Text("lobal Markets React to Sudden Interest Rate Hike: Stocks Tumble Across the Board")
        Text("Historic Peace Agreement Reached: Leaders Sign Pact to End Decades-Long Conflict")
        Text("Innovative AI Tool Revolutionizes Healthcare: Doctors Embrace Machine Learning for Diagnosis")
        Text("Natural Disaster Strikes: Massive Earthquake Hits Coastal City, Rescue Efforts Underway")
    }
}</st></pre>			<p><st c="23682">This code example shows a view called </st><code><st c="23721">NewsView</st></code><st c="23729"> with a list of </st><code><st c="23745">Text </st></code><st c="23750">components, each containing a news headline. </st><st c="23795">If we look closely, we can see that there’s no layout – no VStack, group, or List. </st><st c="23878">We are not used to this in SwiftUI, and that’s okay because that view is </st><st c="23951">for display.</st></p>
			<p><st c="23963">The </st><code><st c="23968">NewsView</st></code><st c="23976"> job is to be a container</st><a id="_idIndexMarker038"/><st c="24001"> for components. </st><st c="24018">Let’s see how we can use </st><st c="24043">this container:</st></p>
			<pre class="source-code"><st c="24058">
struct ContentView: View {
    var body: some View {
        ScrollView {
            VStack {
                Text("Latest headlines")
                    .font(.titl</st><a id="_idTextAnchor039"/><a id="_idTextAnchor040"/><st c="24166">e)
</st><strong class="bold"><st c="24170">                Group(subviews: NewsView()) { collection in</st></strong><st c="24213">
                    if let firstHeadline = collection.first
                    {
                        firstHeadline
                            .font(.title2)
                        Spacer()
                    }
                    ForEach(collection.dropFirst()) {
                      newsItem in
                        newsItem
                            .font(.headline)
                        Spacer()
                    }
                }
            }
            .padding()
        }
    }
}</st></pre>			<p><st c="24399">In this example, we added a SwiftUI group, but this time, from the </st><code><st c="24467">NewsView</st></code><st c="24475"> view:</st></p>
			<pre class="source-code"><st c="24481">
Group(subviews: NewsView()) { collection in</st></pre>			<p><st c="24525">This line creates a group that iterates over the specific view’s sub-views and allows us to position and modify </st><st c="24638">them ourselves.</st></p>
			<p><st c="24653">In our example, we change the font of the first sub-view and present all the views with a spacer </st><st c="24751">between them.</st></p>
			<p><st c="24764">The ability to reposition views</st><a id="_idIndexMarker039"/><st c="24796"> within other views unlocks new possibilities. </st><st c="24843">For instance, we can reuse the same views but with different layouts, sequences, or styles. </st><st c="24935">Treating our views as containers for smaller components makes our code </st><st c="25006">more reusable.</st></p>
			<p><st c="25020">Now, let’s move to our chapter’s last section – the </st><st c="25073">AI revolution.</st></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor041"/><st c="25087">Entering the AI revolution</st></h1>
			<p><st c="25114">AI and machine learning </st><a id="_idIndexMarker040"/><st c="25139">are not new areas for Apple and the iOS platform. </st><st c="25189">Apple uses AI to adjust photos taken, suggest apps to users according to their usage, optimize battery charging, and </st><st c="25306">many more.</st></p>
			<p><st c="25316">For developers, Apple provides the CoreML framework and tools such as Create ML to help users train and create their own machine </st><st c="25446">learning models.</st></p>
			<p><st c="25462">However, the rising popularity of services such as ChatGPT and Gemini proved that CoreML is insufficient, and that Apple needs to integrate AI deeper into </st><st c="25618">the system.</st></p>
			<p><st c="25629">So, what did Apple prepare for us, the developers, regarding AI in </st><st c="25697">iOS 18?</st></p>
			<p><st c="25704">Apple integrated AI into iOS 18 by letting iOS understand what’s happening in the system and helping the user perform common tasks using natural language understanding, similar </st><st c="25882">to ChatGPT.</st></p>
			<p><st c="25893">For example, let’s say we’re working on a word-processing app and created an App Intent that allows the user to add an image to </st><st c="26022">a document.</st></p>
			<p><st c="26033">Until iOS 18, we would have had to define a specific phrase for the user to use with Siri. </st><st c="26125">However, in iOS 18, the user can say something such as “Add this image to the page I’m working on,” and Siri uses a set of machine-learning models to convert this phrase to our app intent model. </st><st c="26320">Not only that, but Siri can also understand the current context on screen and even search our app by indexing our app content in </st><st c="26449">the spotlight.</st></p>
			<p><st c="26463">Integrating our app into Siri requires</st><a id="_idIndexMarker041"/><st c="26502"> little effort. </st><st c="26518">We mainly need to focus on structuring our main actions and entities. </st><st c="26588">Apple Intelligence does all </st><st c="26616">the rest.</st></p>
			<p><st c="26625">To read more about using App Intents with Siri, go to </st><a href="B21795_13.xhtml#_idTextAnchor401"><em class="italic"><st c="26680">Chapter 13</st></em></a><st c="26690">.</st></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor042"/><st c="26691">Summary</st></h1>
			<p><st c="26699">There’s no other way of looking at iOS 18 than as an exciting one. </st><st c="26767">The addition of Apple Intelligence is only part of the story – Apple took care of many system and SDK aspects such as testing, persistent data, UI, </st><st c="26915">and more.</st></p>
			<p><st c="26924">In this chapter, we explored the basics of the new Swift Testing framework, learned about Swift Data improvements, and discussed enhancements in SwiftUI such as zoom transition, floating tab bar, scroll views, and text rendering. </st><st c="27155">We even scratched the surface of Apple Intelligence and tried to understand how it is integrated with App Intents. </st><st c="27270">By now, you should be familiar with the most exciting and new topics in </st><st c="27342">iOS 18.</st></p>
			<p><st c="27349">A few code examples are just not enough. </st><st c="27391">We are developers, and we need more! </st><st c="27428">So, let’s jump straight into SwiftData and explore Apple’s new persistent data framework in the </st><st c="27524">next chapter.</st></p>
		</div>
	<div></body></html>