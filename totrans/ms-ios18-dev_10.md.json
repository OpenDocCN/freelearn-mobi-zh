["```swift\n #define SQUARE(x) ((x) * (x))\nint num = 5;\nint result = SQUARE(num);\n```", "```swift\n<st c=\"3898\">@AddDebugerLogger</st> class MyClass {\n}\n```", "```swift\n class MyClass {\n    func printLog(issue: String) {\n        #if DEBUG\n        print(\"In class named MyClass - \\(issue)\")\n        #endif\n    }\n}\n```", "```swift\n     https://github.com/apple/swift-syntax\n    ```", "```swift\n import SwiftSyntax\nimport SwiftSyntaxParser <st c=\"10949\">let</st> <st c=\"10952\">sourceCode</st> = \"\"\"\nfunc hello() {\n    print(\"Hello World\")\n}\n\"\"\"\n```", "```swift\n do { <st c=\"11467\">let syntax = try SyntaxParser.parse(source: sourceCode)</st> } catch {\n    print(\"Error parsing code: \\(error)\")\n}\n```", "```swift\n if let <st c=\"14575\">funcDecl</st> = syntax.statements.first?.item.as(<st c=\"14619\">FunctionDeclSyntax</st>.self) {\n       // We'll fill that part soon\n }\n```", "```swift\n if let <st c=\"15603\">funcCallExpression</st> = funcDecl.body?.statements.first?.item.as(<st c=\"15665\">FunctionCallExprSyntax</st>.self) {\n   // Checking the print function\n  }\n```", "```swift\n let functionName = funcCallExpression.<st c=\"16197\">calledExpression</st>.firstToken?.text\n            if functionName == \"print\" {\n                let value = funcCallExpression.<st c=\"16292\">argumentList</st>.first?.expression.as(StringLiteralExprSyntax.self)?\n                    .segments\n                    .first?.firstToken?.text\n            }\n```", "```swift\n let initString: String = \"<st c=\"18052\">init(title: String) {</st>\n<st c=\"18150\">SwiftSyntax</st> types:\n\n```", "```swift\n\n\t\t\t<st c=\"18273\">In the preceding code,</st> `<st c=\"18297\">InitializerDeclSyntax</st>` <st c=\"18318\">is a constructor declaration, and</st> `<st c=\"18353\">ExprSyntax</st>` <st c=\"18363\">is a base type</st> <st c=\"18379\">for expressions.</st>\n\t\t\t<st c=\"18395\">In the context of Swift Macros, in most cases, using</st> `<st c=\"18449\">String</st>` <st c=\"18455\">literals will be enough.</st> <st c=\"18481\">That’s because the</st> `<st c=\"18500\">SwiftSyntax</st>` <st c=\"18511\">types support</st> `<st c=\"18526\">String</st>` <st c=\"18532\">literals.</st> <st c=\"18543\">However, using the built-in</st> <st c=\"18570\">expressions will ensure the generated code will be valid in future</st> <st c=\"18638\">Swift updates.</st>\n\t\t\t<st c=\"18652\">Speaking of Swift Macros, let’s create our first Swift macro now that we know what</st> `<st c=\"18736\">SwiftSyntax</st>` <st c=\"18747\">is and how</st> <st c=\"18759\">it works.</st>\n\t\t\t<st c=\"18768\">Creating our first Swift macro</st>\n\t\t\t<st c=\"18799\">As I</st> <st c=\"18805\">mentioned earlier (in the</st> *<st c=\"18831\">What is a Swift macro?</st>* <st c=\"18853\">section), the Swift Macros feature is part of the</st> `<st c=\"18904\">SwiftSyntax</st>` <st c=\"18915\">library.</st> <st c=\"18925\">Macros don’t run as part of our app but as a plugin in</st> <st c=\"18980\">the IDE.</st>\n\t\t\t<st c=\"18988\">Macros can be created by adding a new Swift package with a</st> <st c=\"19048\">macro template.</st>\n\t\t\t<st c=\"19063\">It is obvious why Apple selected the Swift package feature to create macros – a Swift package is a great way to encapsulate code, including tests</st> <st c=\"19210\">and documentation.</st>\n\t\t\t<st c=\"19228\">Let’s add our first Swift macro by creating a new</st> <st c=\"19279\">Swift package.</st>\n\t\t\t<st c=\"19293\">Adding a new Swift macro</st>\n\t\t\t<st c=\"19318\">To create a new</st> <st c=\"19335\">Swift macro, we should open Xcode and follow</st> <st c=\"19380\">these steps:</st>\n\n\t\t\t\t1.  <st c=\"19392\">Select</st> **<st c=\"19400\">File</st>** <st c=\"19404\">|</st> **<st c=\"19407\">New</st>** <st c=\"19410\">|</st> **<st c=\"19413\">Package…</st>**<st c=\"19421\">.</st>\n\t\t\t\t2.  <st c=\"19422\">Then, select</st> **<st c=\"19436\">Swift Macro</st>** <st c=\"19447\">followed by tapping on</st> **<st c=\"19471\">Next</st>** <st c=\"19475\">(see</st> *<st c=\"19481\">Figure 10</st>**<st c=\"19490\">.5</st>*<st c=\"19492\">):</st>\n\n\t\t\t![Figure 10.5: Selecting Swift Macro in the choose template window](img/B21795_figure_10.05.jpg)\n\n\t\t\t<st c=\"19632\">Figure 10.5: Selecting Swift Macro in the choose template window</st>\n\n\t\t\t\t1.  <st c=\"19696\">In the</st> <st c=\"19704\">opening screen, we will give a name for our struct and press the</st> `<st c=\"19936\">StructInit</st>` <st c=\"19946\">(see</st> *<st c=\"19952\">Figure 10</st>**<st c=\"19961\">.6</st>*<st c=\"19963\">):</st>\n\n\t\t\t![Figure 10.6: Adding a StructInit macro](img/B21795_figure_10.06.jpg)\n\n\t\t\t<st c=\"20054\">Figure 10.6: Adding a StructInit macro</st>\n\n\t\t\t\t1.  <st c=\"20092\">After saving, Xcode</st> <st c=\"20113\">opens a window with our new package containing an</st> <st c=\"20163\">example macro.</st>\n\n\t\t\t<st c=\"20177\">Let’s see how a Swift Macros package is</st> <st c=\"20218\">built next!</st>\n\t\t\t<st c=\"20229\">Examining our Swift Macros package structure</st>\n\t\t\t<st c=\"20274\">Now that we</st> <st c=\"20286\">have a Swift Macros package, we can reveal its file’s structure (</st>*<st c=\"20352\">Figure 10</st>**<st c=\"20362\">.7</st>*<st c=\"20364\">):</st>\n\t\t\t![Figure 10.7: The Swift Macros package file’s structure](img/B21795_figure_10.07.jpg)\n\n\t\t\t<st c=\"20612\">Figure 10.7: The Swift Macros package file’s structure</st>\n\t\t\t<st c=\"20666\">Looking at the Swift Macros package (</st>*<st c=\"20704\">Figure 10</st>**<st c=\"20714\">.7</st>*<st c=\"20716\">), we can see that</st> `<st c=\"20736\">SwiftSyntax</st>` <st c=\"20747\">is defined as a dependency of the package for us, with the latest stable version already linked to</st> <st c=\"20847\">our package.</st>\n\t\t\t<st c=\"20859\">The macro itself is built upon three different</st> <st c=\"20907\">source files:</st>\n\n\t\t\t\t*   `<st c=\"20920\">StructInit</st>`<st c=\"20931\">: That’s our macro definition file.</st> <st c=\"20968\">Here, we define the macro name</st> <st c=\"20999\">and type.</st>\n\t\t\t\t*   `<st c=\"21008\">StructInitClient</st>`<st c=\"21025\">: That’s our Swift Macros package executable product.</st> <st c=\"21080\">This is where we add an executable code that uses</st> <st c=\"21130\">our macro.</st>\n\t\t\t\t*   `<st c=\"21140\">StructInitMacros</st>`<st c=\"21157\">: That’s our macro implementation and where all the</st> <st c=\"21210\">magic happens.</st>\n\n\t\t\t<st c=\"21224\">In addition, we also have a</st> `<st c=\"21253\">Test</st>` <st c=\"21257\">target where we can test our</st> <st c=\"21287\">macro code.</st>\n\t\t\t<st c=\"21298\">Our first step toward the</st> `<st c=\"21325\">StructInit</st>` <st c=\"21335\">macro is by declaring its name</st> <st c=\"21367\">and type.</st>\n\t\t\t<st c=\"21376\">Declaring our macro</st>\n\t\t\t<st c=\"21396\">If we</st> <st c=\"21402\">open the</st> `<st c=\"21412\">StructInit</st>` <st c=\"21422\">file, we can see it has a concise yet</st> <st c=\"21461\">important declaration:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"21631\">This short declaration has</st> <st c=\"21659\">many components:</st>\n\n\t\t\t\t*   `<st c=\"21675\">@freestanding(expression)</st>`<st c=\"21701\">: That’s the macro role.</st> <st c=\"21727\">We’ll go over roles in the</st> *<st c=\"21754\">Giving our macro a</st>* *<st c=\"21773\">role</st>* <st c=\"21777\">section.</st>\n\t\t\t\t*   `<st c=\"21786\">public macro stringify<T></st>`<st c=\"21812\">: The</st> <st c=\"21819\">macro name.</st>\n\t\t\t\t*   `<st c=\"21830\">(_ value: T) -> (T, String)</st>`<st c=\"21858\">: The macro parameters</st> <st c=\"21882\">and output.</st>\n\t\t\t\t*   `<st c=\"21893\">#externalMacro</st>`<st c=\"21908\">: This means that the macro will be used as a plug in</st> <st c=\"21963\">the compiler.</st>\n\t\t\t\t*   `<st c=\"21976\">module: \"StructInitMacros\"</st>`<st c=\"22003\">: The name of the plugin that will</st> <st c=\"22039\">be used.</st>\n\t\t\t\t*   `<st c=\"22047\">type: \"StringifyMacro\"</st>`<st c=\"22070\">: That’s the macro type, as defined in the</st> `<st c=\"22114\">Package.swift</st>` <st c=\"22127\">file.</st>\n\n\t\t\t<st c=\"22133\">The first component is the macro role, so let’s discuss what</st> <st c=\"22195\">roles are.</st>\n\t\t\t<st c=\"22205\">Giving our macro a role</st>\n\t\t\t**<st c=\"22229\">Macro roles</st>** <st c=\"22241\">define</st> <st c=\"22249\">the fundamental behavior of our macros.</st> <st c=\"22289\">There are two primary</st> <st c=\"22311\">role categories:</st>\n\n\t\t\t\t*   `<st c=\"22473\">#</st>` <st c=\"22474\">sign.</st>\n\n    <st c=\"22479\">Here’s an example of a</st> <st c=\"22503\">freestanding macro:</st>\n\n    ```", "```swift\n\n    <st c=\"22549\">The</st> `<st c=\"22554\">#URL</st>` <st c=\"22558\">macro checks whether the provided value is a valid URL.</st> <st c=\"22615\">If not, it raises an error on compile time.</st> <st c=\"22659\">Otherwise, it returns a</st> <st c=\"22683\">non-optional value.</st>\n\n    <st c=\"22702\">We can see</st> <st c=\"22713\">that the</st> `<st c=\"22723\">#URL</st>` <st c=\"22727\">macro can be anywhere in our code.</st> <st c=\"22763\">That’s why it is</st> <st c=\"22780\">called</st> *<st c=\"22787\">freestanding</st>*<st c=\"22799\">.</st>\n\n    \t\t\t\t*   `<st c=\"22974\">@</st>` <st c=\"22975\">sign.</st>\n\n    <st c=\"22980\">Here’s an example of an</st> <st c=\"23005\">attached macro:</st>\n\n    ```", "```swift\n\n    <st c=\"23142\">In the preceding code, the</st> `<st c=\"23170\">@StructInit</st>` <st c=\"23181\">macro is “attached” to the</st> `<st c=\"23209\">Book</st>` <st c=\"23213\">struct and inserts an</st> `<st c=\"23236\">init</st>` <st c=\"23240\">function based on the</st> <st c=\"23263\">struct properties.</st>\n\n\t\t\t<st c=\"23281\">The two categories of macro types, namely freestanding and attached, represent distinct sets of roles.</st> <st c=\"23385\">Here is the list of</st> <st c=\"23405\">all roles:</st>\n\n\t\t\t\t*   `<st c=\"23415\">#freestanding(expression)</st>`<st c=\"23441\">: This</st> <st c=\"23448\">just returns a new expression based on an</st> <st c=\"23491\">existing one</st>\n\t\t\t\t*   `<st c=\"23503\">#freestanding(declaration)</st>`<st c=\"23530\">: This creates a</st> <st c=\"23548\">new declaration</st>\n\t\t\t\t*   `<st c=\"23563\">@attached(peer)</st>`<st c=\"23579\">: This adds new declaration next to the</st> <st c=\"23620\">attached one</st>\n\t\t\t\t*   `<st c=\"23632\">@attached(accessor)</st>`<st c=\"23652\">: This adds accessors to</st> <st c=\"23678\">a property</st>\n\t\t\t\t*   `<st c=\"23688\">@attached(memberAttribute)</st>`<st c=\"23715\">: This adds attributes to the declarations in the type it’s</st> <st c=\"23776\">attached to</st>\n\t\t\t\t*   `<st c=\"23787\">@attached(member)</st>`<st c=\"23805\">: This adds new declarations inside the type it’s</st> <st c=\"23856\">attached to</st>\n\t\t\t\t*   `<st c=\"23867\">@attached(conformance)</st>`<st c=\"23890\">: This</st> <st c=\"23898\">adds conformance to the type it’s</st> <st c=\"23932\">attached to</st>\n\n\t\t\t<st c=\"23943\">The role we define when we declare the macro tells the created plugin</st> *<st c=\"24014\">how to</st>* <st c=\"24020\">change an</st> <st c=\"24031\">existing code.</st>\n\t\t\t<st c=\"24045\">The role is the first part of declaring a macro.</st> <st c=\"24095\">Let’s continue with the rest of</st> <st c=\"24127\">the declaration.</st>\n\t\t\t<st c=\"24143\">Defining the StructInit macro</st>\n\t\t\t<st c=\"24173\">Our</st> `<st c=\"24178\">StructInit</st>` <st c=\"24188\">macro goal is to</st> <st c=\"24205\">create the init method for a struct.</st> <st c=\"24243\">Our macro doesn’t exist independently; its purpose is to insert new declarations into an existing struct.</st> <st c=\"24349\">Therefore, we will choose the</st> `<st c=\"24379\">@attached(member)</st>` <st c=\"24396\">macro from the roles list in the</st> *<st c=\"24430\">Giving our macro a</st>* *<st c=\"24449\">role</st>* <st c=\"24453\">section:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"24480\">However, mentioning the role type is not enough.</st> <st c=\"24530\">We also need to specify what declaration types we expect our macro to generate.</st> <st c=\"24610\">In this case, we expect the macro to generate an</st> `<st c=\"24659\">init</st>` <st c=\"24663\">function.</st> <st c=\"24674\">Let’s add that to the</st> <st c=\"24696\">role declaration:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"24751\">Adding role types helps the compiler cover different cases where the macro generates something else that was not declared.</st> <st c=\"24875\">It also behaves as a documentation for</st> <st c=\"24914\">our macro.</st>\n\t\t\t<st c=\"24924\">Here is another example of</st> `<st c=\"24952\">names</st>` <st c=\"24957\">argument usage:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"25015\">In this case, the</st> `<st c=\"25034\">names</st>` <st c=\"25039\">argument declares a usage of the</st> `<st c=\"25073\">RawValue</st>` <st c=\"25081\">declaration.</st>\n\t\t\t<st c=\"25094\">We can also add</st> `<st c=\"25111\">arbitrary</st>` <st c=\"25120\">for</st> <st c=\"25125\">general purposes:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"25178\">Using</st> `<st c=\"25185\">arbitrary</st>` <st c=\"25194\">counts for all types</st> <st c=\"25216\">of declarations.</st>\n\t\t\t<st c=\"25232\">Moving forward, we will reconfigure the predefined macro with the</st> <st c=\"25299\">following declaration:</st>\n\n```", "```swift\n import SwiftCompilerPlugin\nimport SwiftSyntax\nimport SwiftSyntaxBuilder\nimport SwiftSyntaxMacros\n```", "```swift\n<st c=\"26662\">public</st> struct StructInit: <st c=\"26688\">MemberMacro</st> {\n   public static func expansion() {\n      //Implementation details are detailed in the next section\n   }\n}\n```", "```swift\n public static func expansion(\n        of node: AttributeSyntax,\n        providingMembersOf declaration: some\n          DeclGroupSyntax,\n        in context: some MacroExpansionContext\n    ) throws -> [SwiftSyntax.DeclSyntax]\n```", "```swift\n let members = declaration.memberBlock.members <st c=\"29595\">// 1</st> let variableDecl = members.compactMap {\n  $0.decl.as(VariableDeclSyntax.self) } <st c=\"29678\">// 2</st> let variablesName = variableDecl.compactMap {\n  $0.bindings.first?.pattern } <st c=\"29758\">// 3</st> let variablesType = variableDecl.compactMap {\n  $0.bindings.first?.typeAnnotation?.type } <st c=\"29851\">// 4</st>\n```", "```swift\n var code = \"<st c=\"30433\">init(</st>\"\nfor (name, type) in zip(variablesName, variablesType) {\n    code += <st c=\"30506\">\"\\(name): \\(type),</st> \"\n}\ncode = String(code.dropLast(2))\ncode += \"<st c=\"30570\">)</st>\"\n```", "```swift\n let initializer = try <st c=\"30988\">InitializerDeclSyntax</st>(SyntaxNodeString\n  (stringLiteral: code)) {\n      for name in variablesName {\n          ExprSyntax(\"self.\\(name) = \\(name)\")\n      }\n}\n```", "```swift\n return [DeclSyntax(initializer)]\n```", "```swift\n let members = structDecl.memberBlock.members\n        let variableDecl = members.compactMap {\n          $0.decl.as(VariableDeclSyntax.self) }\n        let variablesName = variableDecl.compactMap {\n          $0.bindings.first?.pattern }\n        let variablesType = variableDecl.compactMap {\n          $0.bindings.first?.typeAnnotation?.type }\n        var code = \"<st c=\"31700\">init(</st>\"\n        for (name, type) in zip(variablesName,\n          variablesType) {\n            code += <st c=\"31773\">\"\\(name): \\(type),</st> \"\n        }\n        code = String(code.dropLast(2))\n        code += \"<st c=\"31837\">)</st>\"\n        let initializer = try InitializerDeclSyntax(SyntaxNodeString\n          (stringLiteral: code)) {\n            for name in variablesName {\n                ExprSyntax(\"<st c=\"31967\">self.\\(name) = \\(name)</st>\")\n            }\n        }\n        return [DeclSyntax(initializer)]\n```", "```swift\n struct Book {\n    var id: Int\n    var title: String\n}\n```", "```swift\n init(id: Int, title: String) {\n    self.id = id\n    self.title = title\n}\n```", "```swift\n @main\nstruct struct_initial_macroPlugin: CompilerPlugin {\n    let providingMacros: [Macro.Type] = [\n        StructInit.self,\n    ]\n}\n```", "```swift\n .executable(\n    name: \"StructInitClient\",\n    targets: [\"StructInitClient\"]\n),\n```", "```swift\n import StructInit\nimport Foundation <st c=\"34334\">@StructInit</st> struct Book {\n    var id: Int\n    var title: String\n    var subtitle: String\n    var description: String\n    var author: String\n}\n```", "```swift\n guard let structDecl = declaration.as(StructDeclSyntax.self)\n    else {\n      throw StructInitError.onlyStructs\n    }\n```", "```swift\n enum StructInitError: CustomStringConvertible, Error {\n    case onlyStructs\n    var description: String {\n        switch self {\n        case . onlyStructs: return \"@StructInit can only be applied to a structure\"\n        }\n    }\n}\n```", "```swift\n enum CustomDiagnostic: String, DiagnosticMessage {\n    case notAStruct\n    var <st c=\"36919\">severity</st>: DiagnosticSeverity { return .error}\n    var <st c=\"36970\">message</st>: String {\n        switch self {\n        case .notAStruct:\n            return \"@StructInit can only be applied to a structure\"\n        }\n    }\n    var <st c=\"37085\">diagnosticID</st>: MessageID {\n        return MessageID(domain: \"StructInitMacro\",\n                         id: rawValue)\n    }\n} <st c=\"37174\">let diagnostic = Diagnostic(node: node,</st>\n<st c=\"37383\">SwiftSyntax</st> library.\n\t\t\t<st c=\"37403\">If you wondered why we need the</st> `<st c=\"37436\">context</st>` <st c=\"37443\">parameter in the</st> `<st c=\"37461\">expansion</st>` <st c=\"37470\">function, now you’ll have</st> <st c=\"37497\">the answer:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"37537\">Remember we said that context links us to the compiler environment?</st> <st c=\"37606\">So, we use it to invoke a</st> <st c=\"37632\">diagnostic message.</st>\n\t\t\t<st c=\"37651\">Let’s see the</st> `<st c=\"37666\">guard</st>` <st c=\"37671\">declaration now that we have a</st> `<st c=\"37703\">diagnostic</st>` <st c=\"37713\">structure:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"37934\">We can see that</st> `<st c=\"37951\">SwiftSyntax</st>` <st c=\"37962\">is like peeling an onion – we uncover new features every time we dig deeper, and</st> `<st c=\"38044\">Diagnostic</st>` <st c=\"38054\">is one of</st> <st c=\"38065\">these features.</st>\n\t\t\t<st c=\"38080\">Now, we have a significant error handling – descriptive and precise.</st> <st c=\"38150\">But what about checking our macro in various</st> <st c=\"38195\">use cases?</st>\n\t\t\t<st c=\"38205\">To see our macro at work, we used</st> `<st c=\"38240\">StructInitClient</st>`<st c=\"38256\">. However, relying on the client to verify that</st> <st c=\"38303\">our macro works as expected is not sustainable</st> <st c=\"38351\">over time.</st>\n\t\t\t<st c=\"38361\">So, another great feature we get from having a macro written in a Swift package is</st> <st c=\"38445\">unit tests.</st>\n\t\t\t<st c=\"38456\">Let’s see how we test</st> <st c=\"38479\">a macro.</st>\n\t\t\t<st c=\"38487\">Adding tests</st>\n\t\t\t<st c=\"38500\">The principle of testing a macro</st> <st c=\"38533\">is to test a code block</st> *<st c=\"38558\">before and after</st>* <st c=\"38574\">the</st> <st c=\"38579\">macro expansion.</st>\n\t\t\t<st c=\"38595\">As part of our Swift Macros package, we have a test target (</st>*<st c=\"38656\">Figure 10</st>**<st c=\"38666\">.10</st>*<st c=\"38669\">):</st>\n\t\t\t![Figure 10.10: A testing target for StructInitMacro](img/B21795_figure_10.10.jpg)\n\n\t\t\t<st c=\"38877\">Figure 10.10: A testing target for StructInitMacro</st>\n\t\t\t<st c=\"38927\">Each Swift package comes with a testing target, and in this case, we already have one test with the</st> `<st c=\"39028\">stringify</st>` <st c=\"39037\">macro that comes when we create a new Swift</st> <st c=\"39082\">Macros package.</st>\n\t\t\t<st c=\"39097\">Let’s clear the test file and start our</st> <st c=\"39138\">own test.</st>\n\t\t\t<st c=\"39147\">To test a macro, we need to create the</st> `<st c=\"39187\">XCTestCase</st>` <st c=\"39197\">subclass and create a new method called</st> `<st c=\"39238\">testMacro</st>`<st c=\"39247\">. Remember that test functions in</st> `<st c=\"39281\">XCTest</st>` <st c=\"39287\">always start with the phrase “test” followed by the</st> <st c=\"39340\">test name.</st>\n\t\t\t<st c=\"39350\">To test a macro expansion, we will use a particular</st> `<st c=\"39403\">SwiftSyntax</st>` <st c=\"39414\">function called</st> `<st c=\"39431\">assertMacroExpansion</st>`<st c=\"39451\">. The most important function parameters are</st> <st c=\"39496\">as follows:</st>\n\n\t\t\t\t*   `<st c=\"39507\">_originalSource</st>`<st c=\"39523\">: The original code before the expansion, including the macro</st> <st c=\"39586\">attribute itself</st>\n\t\t\t\t*   `<st c=\"39602\">expandedSource</st>`<st c=\"39617\">: The code</st> *<st c=\"39629\">after</st>* <st c=\"39634\">the expansion</st>\n\t\t\t\t*   `<st c=\"39648\">macros</st>`<st c=\"39655\">: The list of macro types</st> <st c=\"39682\">being tested</st>\n\n\t\t\t<st c=\"39694\">Let’s see a basic</st> <st c=\"39712\">test case for testing our</st> `<st c=\"39739\">StructInit</st>` <st c=\"39749\">macro:</st>\n\n```", "```swift\n\n\t\t\t<st c=\"40226\">We can see</st> <st c=\"40238\">that</st> `<st c=\"40243\">assertMacroExpansion</st>` <st c=\"40263\">received the three parameters I</st> <st c=\"40296\">mentioned earlier.</st>\n\t\t\t<st c=\"40314\">We compare the</st> `<st c=\"40330\">Book</st>` <st c=\"40334\">struct expansion with the</st> `<st c=\"40361\">Book</st>` <st c=\"40365\">struct desired structure, including the</st> `<st c=\"40406\">init</st>` <st c=\"40410\">function.</st>\n\t\t\t`<st c=\"40420\">assertMacroExpansion</st>` <st c=\"40441\">compares the expanded code of the macro to the</st> `<st c=\"40489\">expandedSource</st>` <st c=\"40503\">parameter, and if there are any differences, it fails</st> <st c=\"40558\">the test.</st>\n\t\t\t<st c=\"40567\">Testing is a crucial part of Swift packages in general.</st> <st c=\"40624\">Swift packages are meant to be reusable and rely on testing to ensure</st> <st c=\"40694\">their stability.</st>\n\t\t\t<st c=\"40710\">Things get even more important when creating Swift macros since they run as a compiler plugin, which makes it harder to debug.</st> <st c=\"40838\">So, we shouldn’t give up tests, especially not</st> <st c=\"40885\">in macros.</st>\n\t\t\t<st c=\"40895\">Practice exercises</st>\n\t\t\t<st c=\"40914\">Swift Macros is a complex topic, and it is a challenge to understand how to create a Swift macro without trying it yourself.</st> <st c=\"41040\">Here are two exercises that can help you</st> <st c=\"41081\">get started:</st>\n\n\t\t\t\t*   <st c=\"41093\">Create an attached Swift macro that adds a function called</st> `<st c=\"41153\">printVariables</st>`<st c=\"41167\">. The function prints the list of the class properties and</st> <st c=\"41226\">their values.</st>\n\t\t\t\t*   <st c=\"41239\">Create a freestanding macro called</st> `<st c=\"41275\">#colorhex</st>` <st c=\"41284\">that receives a hex color value and generates an RGB color expression.</st> <st c=\"41356\">For example,</st> `<st c=\"41369\">#colorhex(\"#FFFFFF\")</st>` <st c=\"41389\">will generate</st> `<st c=\"41404\">Color(red: 0.0, green: 0.0,</st>` `<st c=\"41432\">blue: 0.0)</st>`<st c=\"41442\">.</st>\n\n\t\t\t<st c=\"41443\">In addition, here are some links that can help you get more insights about</st> <st c=\"41519\">Swift Macros:</st>\n\n\t\t\t\t*   **<st c=\"41532\">Swift Macros documentation from the Swift.org</st>** **<st c=\"41579\">projects</st>**<st c=\"41587\">:</st> [<st c=\"41589\">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/</st>]( https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/ )\n\t\t\t\t*   **<st c=\"41676\">A GitHub repository about great Swift macros we can use and learn</st>** **<st c=\"41743\">from</st>**<st c=\"41747\">:</st> [<st c=\"41750\">https://github.com/krzysztofzablocki/Swift-Macros</st>](https://github.com/krzysztofzablocki/Swift-Macros)\n\n\t\t\t<st c=\"41799\">Summary</st>\n\t\t\t<st c=\"41807\">This chapter covered a new and exciting feature of Xcode 15 and iOS 17 –</st> <st c=\"41881\">Swift Macros.</st>\n\t\t\t<st c=\"41894\">We explored the</st> `<st c=\"41911\">SwiftSyntax</st>` <st c=\"41922\">library and learned how to set up, parse, and generate Swift code.</st> <st c=\"41990\">We also created our first Swift macro, handled errors, and even wrote</st> <st c=\"42060\">one test.</st>\n\t\t\t<st c=\"42069\">Swift Macros is a comprehensive, complex, yet effective feature, and by now, you are ready to implement it in your</st> <st c=\"42185\">own projects!</st>\n\t\t\t<st c=\"42198\">In the next chapter, we’ll discuss another exciting framework –</st> <st c=\"42263\">Combine.</st>\n\n```", "```swift\n\n```"]