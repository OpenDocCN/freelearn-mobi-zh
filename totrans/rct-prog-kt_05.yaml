- en: Asynchronous Data Operators and Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the previous chapters, we got a strong grip on the producer (Observable
    and Flowable) and consumer (Observer and Subscriber). While learning them, we
    used the `map` method a lot. As already mentioned, the `map` method is actually
    an Rx-Operator. There are also a number of operators in RxKotlin. I can guess
    you have an itching question in your mind from the very first time we used the
    `map` operator. Why do we call it an operator when it looks like a method? Well,
    in this chapter, we will first try to answer this question by defining RxKotlin
    operators. We will then take a deeper look at the various operators available
    and their implementations. With the help of operators, we will transform, accumulate,
    map, group, and filter our data efficiently and with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we started with programming for the first time, we learned about operators.
    We learned that operators are those special characters/sequence of characters
    that perform some specific tasks on the operands and return the final results.
    In the reactive world, the definition remains merely the same; they take one or
    more Observable/Flowable as operands, transform them, and return the resultant
    Observable/Flowable.
  prefs: []
  type: TYPE_NORMAL
- en: Operators work such as a consumer to the preceding Observable/Flowable, listen
    to their emissions, transform them, and emit them to the downstream consumer.
    For instance, think of the `map` operator, it listens to the upstream producer,
    performs some operations on their emissions, and then emits those modified items
    to the downstream.
  prefs: []
  type: TYPE_NORMAL
- en: Operators help us leverage and express business logic and behaviors. There are
    a lot of operators available with RxKotlin. Throughout this book, we will be covering
    various types of operators comprehensively so that you know when to use which
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, to implement business logic and behavior in your applications, you
    should use operators instead of writing blocking code or mixing imperative programming
    with reactive programming. By keeping algorithms and processes purely reactive,
    you can easily leverage lower memory usage, flexible concurrency, and disposability,
    which are reduced or not achieved if you mix reactive programming with imperative
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the five types of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Filtering`/`suppressing` operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now, let's take a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: The filtering/suppressing operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of a situation when you want to receive some emissions from the producer
    but want to discard the rest. There may be some logic to determine the qualifying
    emissions, or you may even wish to discard in bulk. The `filtering`/`suppressing`
    operators are there to help you in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief list of `filtering`/`suppressing` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debounce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct` and `distinctUntilChanged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementAt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first` and `last`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreElements`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip`, `skipLast`, `skipUntil`, and `skipWhile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take`, `takeLast`, `takeUntil`, and `takeWhile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now take a closer look at all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The debounce operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of a situation where you're receiving emissions rapidly, and are willing
    to take the last one after taking some time to be sure about it.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an application UI/UX, we often come to such a situation. For
    example, you have created a text input and are willing to perform some operation
    when the user types something, but you don't want to perform this operation on
    each keystroke. You would like to wait a little bit for the user to stop typing
    (so you've got a good query matching what the user actually wants) and then send
    it to the downstream operator. The `debounce` operator serves that exact purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will not use any UI/UX code of any platform
    here (we will definitely try that in the later chapters while learning to implement
    RxKotlin in Android). Rather, we will try to simulate this using the `Observable.create`
    method (if you have any doubt about the `Observable.create` method, then rush
    to [Chapter 3](135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml), *Observables, Observers,
    and Subjects* before this). Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we tried to keep the `main` function clean by exporting the
    Observable creation to another function (`createObservable()`) to help you understand
    better. On comment `(1)`, we called the `createObservable()` function to create
    an `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `createObservable()` function, we tried to simulate user typing behavior
    by emitting a series of incremental `Strings` with intervals, until it reached
    the final version (`Reactive Programming in Kotlin`). We provided bigger intervals
    after completing each word depicting an ideal user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(2)`, we used the `debounce()` operator with `200` and `TimeUnit.MILLISECONDS`
    as parameters that'll make the downstream wait for `200` milliseconds after each
    emission and take the emissions only if no other emissions occurred in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4540fae7-df2a-4d25-880f-dd62549e8fee.png)'
  prefs: []
  type: TYPE_IMG
- en: Observer receives only three emits, after which the Observable took at least
    `200` milliseconds before emitting the next one.
  prefs: []
  type: TYPE_NORMAL
- en: The distinct operators – distinct, distinctUntilChanged
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This operator is quite simple; it helps you filter duplicate emissions from
    the upstream. Take a look at the following example for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On comment `(1)`, we created a list of `Int` containing many duplicate values.
    On comment `(2)`, we created an `Observable` instance from that `list` with the
    help of the `toObservable()` method. On comment `(3)`, we used the `distinct`
    operator to filter out all duplicate emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54af4bd8-4f6c-4d89-bbc6-e62afe8a6bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: What the `distinct` operator does is remember all the emissions that took place
    and filters any such emissions in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `distinctUntilChange` operator is slightly different. Instead of discarding
    all duplicate emissions, it discards only consecutive duplicate emissions, keeping
    the rest at its place. Please, refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5101ede1-6cf2-418b-a576-acdf7d35f4d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a cautious look at the output; item `3` is printed twice, second time after
    `9`. The `distinct` operator remembers each item until it receives `onComplete`,
    but the `distinctUntilChanged` operator remembers them only until it receives
    a new item.
  prefs: []
  type: TYPE_NORMAL
- en: The elementAt operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With imperative programming, we have the ability to access the *n^(th)* element
    of any array/list, which is quite a common requirement. The `elementAt` operator
    is really helpful in this regard; it pulls the *n^(th)* element from the producer
    and emits it as its own sole emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output before we continue to inspect the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/813c056d-4e54-40ba-ab4b-970e676d76d4.png)'
  prefs: []
  type: TYPE_IMG
- en: On comment `(1)`, we requested the `5`^(th) element from `Observable`, and it
    emitted the same (count starts with zero). However, on comment `(2)`, we requested
    the `50`^(th) element, which doesn't even exist in `Observable`, so it didn't
    emit anything.
  prefs: []
  type: TYPE_NORMAL
- en: This operator achieves this behavior with the help of the `Maybe` monad, which
    will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering emissions - filter operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filter` operator is arguably the most used `filtering`/`suppressing` operator.
    It lets you implement custom logic to filter emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is the simplest implementation of the `filter` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On comment `(1)`, we created an `Observable` instance with the help of the `Observable.range()`
    operator. We filtered out odd numbers from the emissions with the help of the
    `filter` operator on comment `(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a6182ea-29ff-4038-a5bf-9696973fdffb.png)'
  prefs: []
  type: TYPE_IMG
- en: The first and last operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These operators help you listen only for the first or last emission and discard
    the remaining ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4325037-3079-4fcd-85eb-ce66fe9d71b8.png)'
  prefs: []
  type: TYPE_IMG
- en: On comment `(1)`, we used the `first` operator, with the `defaultValue` parameter
    set to `2` so that it will emit the `defaultValue` parameter if it can't access
    the first element. On comment `(2)`, we used the `last` operator. On comment `(3)`,
    we used the `first` operator again, this time, with an empty `Observable`; so,
    instead of emitting the first element, it emits `defaultValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The ignoreElements operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may require to listen only on the `onComplete` of a producer.
    The `ignoreElements` operator helps you to do that. Please refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5f5e614c-bc9e-40a9-b8cf-57cf4ebbddb7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ignoreElements` operator returns a Completable monad, which only has the
    `onComplete` event.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into the `skip` and `take` operators in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* while discussing conditional operators.
  prefs: []
  type: TYPE_NORMAL
- en: The transforming operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the `transforming` operators help you transform items
    emitted by a producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief list of `transforming` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap`, `concatMap`, and `flatMapIterable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switchMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switchIfEmpty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startWith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultIfEmpty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` operator performs a given task (lambda) on each of the emitted items
    and emits them to the downstream. We have already seen a little use of the `map`
    operator. For a given `Observable<T>` or `Flowable<T>`, the `map` operator will
    transform an emitted item of type `T` into an emission of type `R` by applying
    the provided lambda of `Function<T,R>` to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, let''s take a look at another example with the `map` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On comment `(1)`, we used the `map` operator, which will transform the emitted
    item of type `Int` to an emission of type `String`. Although we have a clear idea
    of what the output will be, let''s validate that by taking a look at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1899088-5c70-474a-bf0b-8e42a69158bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Casting emissions (cast operator)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of a situation where you want to cast emissions from the Observable to
    another data type. Passing a lambda just to cast the emissions doesn''t seem like
    a good idea. The `cast` operator is here to help in this scenario. Let''s take
    a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we have defined two classes: `MyItem` and `MyItemInherit`
    on comment `(5)` and `(6)` respectively. We will be using these two classes to
    demonstrate the uses of the `cast` operator. So, on comment `(1)`, we created
    a list of `MyItemInherit`; for this program, our approach is to try the same thing,
    first with the `map` operator, and then we will do the same with the `cast` operator.
    On comment `(2)`, we created an observable with a list, and then, on comment `(3)`,
    we used the `map` operator and passed a lambda, where we type-casted the emission
    to `MyItemInherit`.'
  prefs: []
  type: TYPE_NORMAL
- en: We did the same on comment `(4)`, but, this time with the `cast` operator. Just
    look at the simplicity of the code now, it looks a lot cleaner and simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where the `map` operator takes each emission and transforms them, the `flatMap`
    operator creates a new producer, applying the function you passed to each emission
    of the source producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db9dbc0d-026c-46da-8357-da73b0ec601f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output is similar to the previous one, but the logic is different. Instead
    of just returning the `String`, we are returning `Observable` with the desired
    `String`. Although, for this example, you seem to have no benefit using it, think
    of a situation when you need to derive multiple items from a single emission.
    Consider the following example where we will create multiple items from each emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the output, and then we will try to understand the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68b366a5-c649-4eae-962b-b43c9892f597.png)'
  prefs: []
  type: TYPE_IMG
- en: In this program, we've created a new instance of `Observable` inside the `flatMap`
    operator, which will emit three strings. On comment `(1)`, we created the `Observable`
    instance with the `Observable.create` operator. We will emit three strings from
    the `Observable.create` operator, and, on comment `(2)`, we will send an `onComplete`
    notification after emitting three items from `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: However, take a look at the output; it emitted all the items before sending
    the `onComplete` notification. The reason is that all `Obervables` are combined
    together and then subscribed to the downstream. The `flatMap` operator internally
    uses the `merge` operator to combine multiple `Observables`.
  prefs: []
  type: TYPE_NORMAL
- en: The `concatMap` performs the same operation using the `concat` operator instead
    of the `merge` operator to combine two `Observable`/`Flowables`.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about these operators (`merge`, `concat`, and other combining
    operators) in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will again take a look at `flatMap`, along with `concatMap`, `switchMap`,
    and `flatMapIterable` in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* after gaining some knowledge on merging and concatenating
    producers.
  prefs: []
  type: TYPE_NORMAL
- en: The defaultIfEmpty operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with filtering operators and/or working on complex requirements,
    it may occur that we encounter an empty producer (see the following code block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, on comment `(1)`, we will create `Observable` of range `0` to `10`; however,
    on comment `(2)`, we will filter it for emission value `>15`. So, basically, we
    will end up with an empty Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defaultIfEmpty` operator helps us deal with such situations. The preceding
    example, with `defaultIfEmpty` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the same program, but, just on comment `(3)`, we added the `defaultIfEmpty`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88efc565-61bf-4801-86d2-3e99901cdfb5.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows that, although `Observable` doesn't contain any number above
    `10`, `defaultIfEmpty` adds `15` to the `Observable` as it's empty after filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The switchIfEmpty operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This operator is similar to the `defaultIfEmpty` operator; the only difference
    is that, for the `defaultIfEmpty` operator, it adds an emission to empty producers,
    but for the `switchIfEmpty` operator, it starts emitting from the specified alternative
    producer if the source producer is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `defaultIfEmpty` operator, where you needed to pass an item, here,
    you have to pass an alternate producer to the `switchIfEmpty` operator. If the
    source producer is empty, it will start taking emissions from the alternate producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same example as the previous one; just on comment `(3)`, we used
    `switchIfEmpty` instead of `defaultIfEmpty` with an alternate Observable. The
    following output shows that the emissions were taken from the alternate Observable
    passed with the `switchIfEmpty` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5cc506f-14a2-45ab-be68-da67ce63e703.png)'
  prefs: []
  type: TYPE_IMG
- en: The startWith operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `startWith` operator is simple; it enables you to add an item to the producer
    at the top of all preexisting items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2033e7a6-e4d1-40f2-b14e-010d254c4ad2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `startWith` operator on comment `(2)` and `(4)` worked just
    like a prefix on the existing list of emissions.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting emissions (sorted operator)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some scenarios where you would like to sort the emissions. The `sorted`
    operator helps you do that. It will internally collect and reemit all the emissions
    from the source producer after sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this example and try to understand this operator better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the output first, and then we will explore the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/644eaf81-347e-4470-9016-9a2d4985cd29.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's explore the program. As we already know, the `sorted` operator helps
    sorting emissions; to sort, we need to compare, thus, the `sorted` operator requires
    a `Comparable` instance to compare emitted items and sort them respectively. This
    operator has two overloads, one with no parameter—it assumes that the producer
    (here `Observable`) type will implement `Comparable` and calls `compareTo` function,
    failing which will generate error; the other overload is with a method (lambda)
    for comparing. On comment `(1)` and `(2)`, we implemented the `sorted` operator
    with a default `sort` function, that is, it will call the `compareTo` function
    from the item instance and will throw error if the datatype doesn't implement
    `Comparable`.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(3)`, we used our own custom `sortFunction` to sort the integers
    in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(4)`, we used an Observable of type `MyItem1`, which obviously is
    a custom class and doesn't implement `Comparable`, so we passed the `sortFunction`
    lambda here as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Caution**: As we already mentioned, the `sorted` operator collects all emissions
    and then sorts them before reemitting them in a sorted order; thus, using this
    operator can cause significant performance implications. Moreover, while using
    with large producers, it can cause `OutOfMemory Error` as well. So, use the sorted
    operator cautiously, or try to avoid it unless extensively required.'
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating data – scan operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `scan` operator is a rolling aggregator; it emits incremental accumulation
    by adding previous emissions to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example before delving deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8acca42d-df8c-4385-884b-078fa75f3df2.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in this program, we used the `scan` operator to implement three types of
    operations, which we will discuss in detail, but, first, let's try to understand
    the `scan` operator itself. It takes a lambda with two arguments. The first parameter
    is the result of a rolling aggregation of all previous emissions; the second one
    is the current emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph will allow you to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bce443b-389b-4fe1-8dd2-9537b09bebf4.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the graph, the `scan` operator will accumulate all the previous
    emissions with the current emission based on the provided accumulation function.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding program, on comment `(1)`, we did the same thing with the
    `scan` operator as it is described in the graph. We used it to get the sum of
    all `integers` emitted up until then. On comment `(2)`, we used it with `Observable`
    of type `String` and got concatenated strings.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(3)`, we used the `scan` operator to concatenate the `integers`
    by multiplying the previous accumulation by `10` and adding the present emission
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that we can use the `scan` operator for almost any operation,
    not just for summing, as long as it returns items of the same datatype.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `scan` operator has similarities with the `reduce` operator, which
    we will cover soon in this chapter; however, be cautious not to get confused.
    The `scan` operator is a rolling aggregator, which transforms all the emissions
    it receives into accumulation; whereas, the `reduce` operator reduces emissions
    to just one by accumulating all the emissions once it receives the `onComplete`
    notification.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications, you may face such a situation where you may need
    to accumulate and consolidate emissions. Note that nearly all the operators under
    this criteria will only work on a finite producer (Observable/Flowable) that calls
    `onComplete()` because typically, we can consolidate only finite datasets. We
    will explore this behavior as we cover these operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short list of reducing operators, which we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting emissions (count operator)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `count` operator subscribes to a producer, counts the emissions, and emits
    a `Single`, containing the count of emissions by the producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa05b80c-734a-40a9-bd4d-9e303e3868c0.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the output, this operator counts the emissions from the producer,
    and emits the count once it receives the `onComplete` notification.
  prefs: []
  type: TYPE_NORMAL
- en: Accumulating emissions – reduce operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reduce is a perfect accumulation operator. It accumulates all the emissions
    by the producer and emits them once it receives the `onComplete` notification
    from the producer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2248a518-06cd-4d24-a21b-f31636c3605d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `reduce` operator works similar to the `scan` operator, the only difference
    is that instead of accumulating and emitting them on each emission, it accumulates
    all the emissions and emits them on receiving the `onComplete` notification.
  prefs: []
  type: TYPE_NORMAL
- en: The `all` and `any` operators help validate emissions by the producer; we will
    look into them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The collection operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it is not good practice, keeping some rare situations in mind, RxKotlin
    provides you with operators that can listen to all the emissions and accumulate
    them to a collection object.
  prefs: []
  type: TYPE_NORMAL
- en: The `collection` operators are basically a subset of the reducing operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list consists of the most important `collection` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toList` and `toSortedList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toMultiMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be covering `collection` operators in detail later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The error handling operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already learned about the `onError` event in the Subscriber/Observer. However,
    the problem with the `onError` event is that the error is emitted to the downstream
    consumer chain, and the subscription is terminated instantly. For example, take
    a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfe8c4e0-644e-485b-9935-2595bb337a87.png)'
  prefs: []
  type: TYPE_IMG
- en: The program throws an exception in the `map` operator when the string **Errr**
    is emitted from the Observable. The exception was caught by the `onError` handler,
    but the Subscription doesn't get any further emissions.
  prefs: []
  type: TYPE_NORMAL
- en: This may not be the desired behavior every time. Although we cannot pretend
    the error never happened and continue (we should not do this either), there should
    be a way to at least resubscribe or switch to an alternate source producer.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling operators help you achieve the same.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the error handling operators.
  prefs: []
  type: TYPE_NORMAL
- en: '`onErrorResumeNext( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onErrorReturn( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onExceptionResumeNext( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryWhen( )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover error handling operators in detail in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml),
    *More on Operators and Error Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: The utility operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These operators help us to perform various utility operations, such as performing
    some action on emissions, remembering timestamps of each items emitted, caching,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of utility operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doOnNext`, `doOnComplete`, and `doOnError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnSubscribe`, `doOnDispose`, and `doOnSuccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover utility operators in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about operators and the types of operators available,
    and we learned in detail about operators, especially the ones useful for transforming,
    filtering, and accumulating emissions by the source producer. We also learned
    about the necessity of the error handling operators, which we will cover in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and the next chapter, that is, [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* are highly related; while discussing topics in
    this chapter, we got a glance about the contents of the next chapter. In the next
    chapter as well, we will refer to and use the contents learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While in this chapter we focused on the basics of operators, operator types,
    and operators specifically useful for filtering, transforming, and accumulating
    emissions (aka data), in the next chapter, we will cover the operators useful
    to combine Observable/Flowables and error handling and for conditional purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Turn the page right now to get started.
  prefs: []
  type: TYPE_NORMAL
