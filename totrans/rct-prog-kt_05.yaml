- en: Asynchronous Data Operators and Transformations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步数据操作符和转换
- en: Through the previous chapters, we got a strong grip on the producer (Observable
    and Flowable) and consumer (Observer and Subscriber). While learning them, we
    used the `map` method a lot. As already mentioned, the `map` method is actually
    an Rx-Operator. There are also a number of operators in RxKotlin. I can guess
    you have an itching question in your mind from the very first time we used the
    `map` operator. Why do we call it an operator when it looks like a method? Well,
    in this chapter, we will first try to answer this question by defining RxKotlin
    operators. We will then take a deeper look at the various operators available
    and their implementations. With the help of operators, we will transform, accumulate,
    map, group, and filter our data efficiently and with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的章节，我们强烈掌握了生产者（Observable和Flowable）和消费者（Observer和Subscriber）。在学习它们的过程中，我们大量使用了`map`方法。如前所述，`map`方法实际上是一个Rx-Operator。RxKotlin中也有许多操作符。我可以猜到你从第一次使用`map`操作符时就有了一个迫切的问题。为什么它看起来像方法，我们却称之为操作符？好吧，在本章中，我们首先将尝试通过定义RxKotlin操作符来回答这个问题。然后我们将更深入地了解各种操作符及其实现。借助操作符，我们将高效且轻松地转换、累积、映射、分组和过滤我们的数据。
- en: Operator
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: When we started with programming for the first time, we learned about operators.
    We learned that operators are those special characters/sequence of characters
    that perform some specific tasks on the operands and return the final results.
    In the reactive world, the definition remains merely the same; they take one or
    more Observable/Flowable as operands, transform them, and return the resultant
    Observable/Flowable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次开始编程时，我们学习了操作符。我们了解到操作符是那些在操作数上执行特定任务并返回最终结果的特殊字符/字符序列。在响应式世界中，定义保持基本相同；它们接受一个或多个Observable/Flowable作为操作数，转换它们，并返回结果Observable/Flowable。
- en: Operators work such as a consumer to the preceding Observable/Flowable, listen
    to their emissions, transform them, and emit them to the downstream consumer.
    For instance, think of the `map` operator, it listens to the upstream producer,
    performs some operations on their emissions, and then emits those modified items
    to the downstream.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符就像消费者一样作用于前面的Observable/Flowable，监听它们的发射，转换它们，并将它们发射到下游消费者。例如，考虑`map`操作符，它监听上游生产者，对其发射执行一些操作，然后将修改后的项目发射到下游。
- en: Operators help us leverage and express business logic and behaviors. There are
    a lot of operators available with RxKotlin. Throughout this book, we will be covering
    various types of operators comprehensively so that you know when to use which
    operator.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符帮助我们利用和表达业务逻辑和行为。RxKotlin中有许多操作符可用。在本书中，我们将全面介绍各种类型的操作符，以便你知道何时使用哪个操作符。
- en: Remember, to implement business logic and behavior in your applications, you
    should use operators instead of writing blocking code or mixing imperative programming
    with reactive programming. By keeping algorithms and processes purely reactive,
    you can easily leverage lower memory usage, flexible concurrency, and disposability,
    which are reduced or not achieved if you mix reactive programming with imperative
    programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了在应用程序中实现业务逻辑和行为，你应该使用操作符而不是编写阻塞代码或混合命令式编程与响应式编程。通过保持算法和过程纯粹响应式，你可以轻松利用较低的内存使用、灵活的并发性和可处置性，这些在混合响应式编程与命令式编程时可能会减少或无法实现。
- en: 'These are the five types of operators:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是五种类型的操作符：
- en: '`Filtering`/`suppressing` operators'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`过滤`/`抑制`操作符'
- en: Transforming operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换操作符
- en: Reducing operators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少操作符
- en: Collection operators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合操作符
- en: Error handling operators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理操作符
- en: Utility operators
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具操作符
- en: So, now, let's take a closer look at them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，让我们更仔细地看看它们。
- en: The filtering/suppressing operators
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤/抑制操作符
- en: Think of a situation when you want to receive some emissions from the producer
    but want to discard the rest. There may be some logic to determine the qualifying
    emissions, or you may even wish to discard in bulk. The `filtering`/`suppressing`
    operators are there to help you in these situations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当你想接收生产者的一些发射，但想丢弃其余的。可能有一些逻辑来决定合格的发射，或者你可能甚至希望批量丢弃。`过滤`/`抑制`操作符就是为了在这些情况下帮助你。
- en: 'Here is a brief list of `filtering`/`suppressing` operators:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简短的`过滤`/`抑制`操作符列表：
- en: '`debounce`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounce`'
- en: '`distinct` and `distinctUntilChanged`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`和`distinctUntilChanged`'
- en: '`elementAt`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementAt`'
- en: '`Filter`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filter`'
- en: '`first` and `last`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`和`last`'
- en: '`ignoreElements`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreElements`'
- en: '`skip`, `skipLast`, `skipUntil`, and `skipWhile`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip`, `skipLast`, `skipUntil`, 和 `skipWhile`'
- en: '`take`, `takeLast`, `takeUntil`, and `takeWhile`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`, `takeLast`, `takeUntil`, 和 `takeWhile`'
- en: Let's now take a closer look at all of them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更仔细地看看所有这些操作符。
- en: The debounce operator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`debounce`操作符'
- en: Think of a situation where you're receiving emissions rapidly, and are willing
    to take the last one after taking some time to be sure about it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在快速接收发射，并且愿意在等待一段时间以确保之后采取最后一个发射。
- en: When developing an application UI/UX, we often come to such a situation. For
    example, you have created a text input and are willing to perform some operation
    when the user types something, but you don't want to perform this operation on
    each keystroke. You would like to wait a little bit for the user to stop typing
    (so you've got a good query matching what the user actually wants) and then send
    it to the downstream operator. The `debounce` operator serves that exact purpose.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序的UI/UX时，我们经常会遇到这样的情况。例如，你已经创建了一个文本输入框，并希望在用户输入某些内容时执行某些操作，但你不想在每次按键时都执行这个操作。你希望等待用户停止输入（这样你就能得到一个与用户实际想要匹配的好查询），然后将它发送到下游操作员。`debounce`操作符正是为此目的而设计的。
- en: 'For the sake of simplicity, we will not use any UI/UX code of any platform
    here (we will definitely try that in the later chapters while learning to implement
    RxKotlin in Android). Rather, we will try to simulate this using the `Observable.create`
    method (if you have any doubt about the `Observable.create` method, then rush
    to [Chapter 3](135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml), *Observables, Observers,
    and Subjects* before this). Please refer to the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在这里不会使用任何平台上的UI/UX代码（我们将在学习如何在Android中实现RxKotlin的后续章节中尝试）。相反，我们将尝试使用`Observable.create`方法来模拟这种情况（如果您对`Observable.create`方法有任何疑问，请在阅读本节之前快速翻到[第3章](135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml)，*Observables,
    Observers, and Subjects*）。请参考以下代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this program, we tried to keep the `main` function clean by exporting the
    Observable creation to another function (`createObservable()`) to help you understand
    better. On comment `(1)`, we called the `createObservable()` function to create
    an `Observable` instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们试图通过将Observable的创建导出到另一个函数（`createObservable()`）来保持`main`函数的简洁，以帮助您更好地理解。在注释`(1)`中，我们调用了`createObservable()`函数来创建一个`Observable`实例。
- en: Inside the `createObservable()` function, we tried to simulate user typing behavior
    by emitting a series of incremental `Strings` with intervals, until it reached
    the final version (`Reactive Programming in Kotlin`). We provided bigger intervals
    after completing each word depicting an ideal user behavior.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createObservable()`函数内部，我们试图通过以间隔发射一系列递增的`Strings`来模拟用户的输入行为，直到达到最终版本（`Kotlin中的响应式编程`）。我们在完成每个单词后提供了更大的间隔，以描绘理想用户的行为。
- en: On comment `(2)`, we used the `debounce()` operator with `200` and `TimeUnit.MILLISECONDS`
    as parameters that'll make the downstream wait for `200` milliseconds after each
    emission and take the emissions only if no other emissions occurred in between.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(2)`中，我们使用了`debounce()`操作符，参数为`200`和`TimeUnit.MILLISECONDS`，这将使下游在每次发射后等待`200`毫秒，并且只有在之间没有其他发射发生时才接收发射。
- en: 'The output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4540fae7-df2a-4d25-880f-dd62549e8fee.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4540fae7-df2a-4d25-880f-dd62549e8fee.png)'
- en: Observer receives only three emits, after which the Observable took at least
    `200` milliseconds before emitting the next one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者只接收了三个发射，之后Observable至少等待了`200`毫秒才发射下一个。
- en: The distinct operators – distinct, distinctUntilChanged
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独特的操作符 - `distinct`, `distinctUntilChanged`
- en: 'This operator is quite simple; it helps you filter duplicate emissions from
    the upstream. Take a look at the following example for better understanding:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符非常简单；它帮助您从上游过滤掉重复的发射。请看以下示例以更好地理解：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On comment `(1)`, we created a list of `Int` containing many duplicate values.
    On comment `(2)`, we created an `Observable` instance from that `list` with the
    help of the `toObservable()` method. On comment `(3)`, we used the `distinct`
    operator to filter out all duplicate emissions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(1)`中，我们创建了一个包含许多重复值的`Int`列表。在注释`(2)`中，我们使用`toObservable()`方法从这个列表创建了一个`Observable`实例。在注释`(3)`中，我们使用了`distinct`操作符来过滤掉所有重复的发射。
- en: 'Here is the output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '![](img/54af4bd8-4f6c-4d89-bbc6-e62afe8a6bbd.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54af4bd8-4f6c-4d89-bbc6-e62afe8a6bbd.png)'
- en: What the `distinct` operator does is remember all the emissions that took place
    and filters any such emissions in future.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct`操作符的作用是记住所有已经发生的发射，并过滤掉未来的任何此类发射。'
- en: 'The `distinctUntilChange` operator is slightly different. Instead of discarding
    all duplicate emissions, it discards only consecutive duplicate emissions, keeping
    the rest at its place. Please, refer to the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinctUntilChange` 操作符略有不同。它不会丢弃所有重复的输出，只会丢弃连续重复的输出，其余的保持原位。请参考以下代码：'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/5101ede1-6cf2-418b-a576-acdf7d35f4d6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5101ede1-6cf2-418b-a576-acdf7d35f4d6.png)'
- en: Take a cautious look at the output; item `3` is printed twice, second time after
    `9`. The `distinct` operator remembers each item until it receives `onComplete`,
    but the `distinctUntilChanged` operator remembers them only until it receives
    a new item.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察输出；项目 `3` 被打印了两次，第二次在 `9` 之后。`distinct` 操作符会记住每个项目直到它收到 `onComplete`，但 `distinctUntilChanged`
    操作符只会记住它们直到收到新的项目。
- en: The elementAt operator
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`elementAt` 操作符'
- en: With imperative programming, we have the ability to access the *n^(th)* element
    of any array/list, which is quite a common requirement. The `elementAt` operator
    is really helpful in this regard; it pulls the *n^(th)* element from the producer
    and emits it as its own sole emission.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式编程，我们能够访问任何数组/列表的 *n^(th)* 元素，这是一个相当常见的需求。`elementAt` 操作符在这方面非常有用；它从生产者那里拉取
    *n^(th)* 元素，并将其作为它自己的唯一输出。
- en: 'Take a look at the following piece of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码片段：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Take a look at the following output before we continue to inspect the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续检查代码之前，先看看以下输出：
- en: '![](img/813c056d-4e54-40ba-ab4b-970e676d76d4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/813c056d-4e54-40ba-ab4b-970e676d76d4.png)'
- en: On comment `(1)`, we requested the `5`^(th) element from `Observable`, and it
    emitted the same (count starts with zero). However, on comment `(2)`, we requested
    the `50`^(th) element, which doesn't even exist in `Observable`, so it didn't
    emit anything.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们从 `Observable` 中请求了第 `5`^(th) 个元素，并输出了相同的（计数从零开始）。然而，在注释 `(2)`
    中，我们请求了第 `50`^(th) 个元素，这在 `Observable` 中甚至不存在，所以它没有输出任何内容。
- en: This operator achieves this behavior with the help of the `Maybe` monad, which
    will be covered later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符通过使用稍后将要介绍的 `Maybe` monad 来实现这种行为。
- en: Filtering emissions - filter operator
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤输出 - 过滤操作符
- en: The `filter` operator is arguably the most used `filtering`/`suppressing` operator.
    It lets you implement custom logic to filter emissions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 操作符可以说是最常用的 `filtering`/`suppressing` 操作符。它允许你实现自定义逻辑来过滤输出。'
- en: 'The following code snippet is the simplest implementation of the `filter` operator:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是 `filter` 操作符的最简单实现：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On comment `(1)`, we created an `Observable` instance with the help of the `Observable.range()`
    operator. We filtered out odd numbers from the emissions with the help of the
    `filter` operator on comment `(2)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们使用 `Observable.range()` 操作符创建了一个 `Observable` 实例。我们使用注释 `(2)`
    中的 `filter` 操作符过滤掉了输出中的奇数。
- en: 'The following is the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/4a6182ea-29ff-4038-a5bf-9696973fdffb.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a6182ea-29ff-4038-a5bf-9696973fdffb.png)'
- en: The first and last operator
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个和最后一个操作符
- en: These operators help you listen only for the first or last emission and discard
    the remaining ones.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符可以帮助你只监听第一个或最后一个输出，并丢弃其余的。
- en: 'Check out the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f4325037-3079-4fcd-85eb-ce66fe9d71b8.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4325037-3079-4fcd-85eb-ce66fe9d71b8.png)'
- en: On comment `(1)`, we used the `first` operator, with the `defaultValue` parameter
    set to `2` so that it will emit the `defaultValue` parameter if it can't access
    the first element. On comment `(2)`, we used the `last` operator. On comment `(3)`,
    we used the `first` operator again, this time, with an empty `Observable`; so,
    instead of emitting the first element, it emits `defaultValue`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们使用了 `first` 操作符，并将 `defaultValue` 参数设置为 `2`，这样如果无法访问第一个元素，它将输出
    `defaultValue` 参数。在注释 `(2)` 中，我们使用了 `last` 操作符。在注释 `(3)` 中，我们再次使用了 `first` 操作符，这次使用了一个空的
    `Observable`；因此，它不会输出第一个元素，而是输出 `defaultValue`。
- en: The ignoreElements operator
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略元素操作符
- en: 'Sometimes, you may require to listen only on the `onComplete` of a producer.
    The `ignoreElements` operator helps you to do that. Please refer to the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能只需要监听生产者的 `onComplete`。`ignoreElements` 操作符可以帮助你做到这一点。请参考以下代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/5f5e614c-bc9e-40a9-b8cf-57cf4ebbddb7.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5e614c-bc9e-40a9-b8cf-57cf4ebbddb7.png)'
- en: The `ignoreElements` operator returns a Completable monad, which only has the
    `onComplete` event.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignoreElements` 操作符返回一个只有 `onComplete` 事件的 Completable monad。'
- en: We will look into the `skip` and `take` operators in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* while discussing conditional operators.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml)“更多关于操作符和错误处理”中探讨`skip`和`take`操作符，同时讨论条件操作符。
- en: The transforming operators
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换操作符
- en: As the name suggests, the `transforming` operators help you transform items
    emitted by a producer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`transforming`操作符可以帮助你转换由生产者发出的项目。
- en: 'Here is a brief list of `transforming` operators:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`transforming`操作符的简要列表：
- en: '`map`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`'
- en: '`flatMap`, `concatMap`, and `flatMapIterable`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`, `concatMap`, 和 `flatMapIterable`'
- en: '`switchMap`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchMap`'
- en: '`switchIfEmpty`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchIfEmpty`'
- en: '`scan`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan`'
- en: '`groupBy`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy`'
- en: '`startWith`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWith`'
- en: '`defaultIfEmpty`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty`'
- en: '`sorted`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted`'
- en: '`buffer`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`'
- en: '`window`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window`'
- en: '`cast`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast`'
- en: '`delay`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`'
- en: '`repeat`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`'
- en: The map operator
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平铺操作符
- en: The `map` operator performs a given task (lambda) on each of the emitted items
    and emits them to the downstream. We have already seen a little use of the `map`
    operator. For a given `Observable<T>` or `Flowable<T>`, the `map` operator will
    transform an emitted item of type `T` into an emission of type `R` by applying
    the provided lambda of `Function<T,R>` to it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作符对每个输出的项目执行一个给定的任务（lambda）并将它们输出到下游。我们已经看到了`map`操作符的一些用法。对于给定的`Observable<T>`或`Flowable<T>`，`map`操作符将通过应用提供的`Function<T,R>`
    lambda将类型为`T`的输出项转换为类型为`R`的输出。'
- en: 'So, now, let''s take a look at another example with the `map` operator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，让我们通过`map`操作符来看另一个例子：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On comment `(1)`, we used the `map` operator, which will transform the emitted
    item of type `Int` to an emission of type `String`. Although we have a clear idea
    of what the output will be, let''s validate that by taking a look at the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释（1）中，我们使用了`map`操作符，它将输出的类型为`Int`的项目转换为类型为`String`的输出。尽管我们清楚地知道输出会是什么样子，但让我们通过查看以下截图来验证这一点：
- en: '![](img/b1899088-5c70-474a-bf0b-8e42a69158bb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1899088-5c70-474a-bf0b-8e42a69158bb.png)'
- en: Casting emissions (cast operator)
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换输出（`cast`操作符）
- en: 'Think of a situation where you want to cast emissions from the Observable to
    another data type. Passing a lambda just to cast the emissions doesn''t seem like
    a good idea. The `cast` operator is here to help in this scenario. Let''s take
    a look:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个你想将Observable的输出转换为其他数据类型的情况。仅仅为了转换输出而传递一个lambda似乎不是一个好主意。`cast`操作符就是为了在这种情况下提供帮助。让我们看看：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this program, we have defined two classes: `MyItem` and `MyItemInherit`
    on comment `(5)` and `(6)` respectively. We will be using these two classes to
    demonstrate the uses of the `cast` operator. So, on comment `(1)`, we created
    a list of `MyItemInherit`; for this program, our approach is to try the same thing,
    first with the `map` operator, and then we will do the same with the `cast` operator.
    On comment `(2)`, we created an observable with a list, and then, on comment `(3)`,
    we used the `map` operator and passed a lambda, where we type-casted the emission
    to `MyItemInherit`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们在注释（5）和（6）分别定义了两个类：`MyItem`和`MyItemInherit`。我们将使用这两个类来展示`cast`操作符的用法。因此，在注释（1）中，我们创建了一个`MyItemInherit`列表；对于这个程序，我们的方法首先使用`map`操作符尝试相同的事情，然后我们将使用`cast`操作符做同样的事情。在注释（2）中，我们使用列表创建了一个可观察对象，然后在注释（3）中，我们使用了`map`操作符并传递了一个lambda，其中我们将输出类型转换为`MyItemInherit`。
- en: We did the same on comment `(4)`, but, this time with the `cast` operator. Just
    look at the simplicity of the code now, it looks a lot cleaner and simpler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在注释（4）中做了同样的事情，但这次使用的是`cast`操作符。现在看看代码的简洁性，它看起来干净得多，简单得多。
- en: The flatMap operator
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平铺操作符
- en: Where the `map` operator takes each emission and transforms them, the `flatMap`
    operator creates a new producer, applying the function you passed to each emission
    of the source producer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当`map`操作符对每个输出项执行给定任务（lambda）并将它们输出到下游时，`flatMap`操作符会创建一个新的生产者，将你传递给每个源生产者输出的函数应用于每个输出。
- en: 'So, let''s look at this example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这个例子：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/db9dbc0d-026c-46da-8357-da73b0ec601f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db9dbc0d-026c-46da-8357-da73b0ec601f.png)'
- en: 'The output is similar to the previous one, but the logic is different. Instead
    of just returning the `String`, we are returning `Observable` with the desired
    `String`. Although, for this example, you seem to have no benefit using it, think
    of a situation when you need to derive multiple items from a single emission.
    Consider the following example where we will create multiple items from each emission:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个类似，但逻辑不同。我们不仅返回`String`，还返回具有所需`String`的`Observable`。尽管在这个例子中，你可能觉得使用它没有好处，但考虑一下你需要从单个发射中推导出多个项目的情况。考虑以下示例，我们将从每个发射中创建多个项目：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s take a look at the output, and then we will try to understand the program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出，然后我们尝试理解程序：
- en: '![](img/68b366a5-c649-4eae-962b-b43c9892f597.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68b366a5-c649-4eae-962b-b43c9892f597.png)'
- en: In this program, we've created a new instance of `Observable` inside the `flatMap`
    operator, which will emit three strings. On comment `(1)`, we created the `Observable`
    instance with the `Observable.create` operator. We will emit three strings from
    the `Observable.create` operator, and, on comment `(2)`, we will send an `onComplete`
    notification after emitting three items from `Observable`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们在`flatMap`运算符内部创建了一个新的`Observable`实例，它将发射三个字符串。在注释（1）中，我们使用`Observable.create`运算符创建了`Observable`实例。我们将从`Observable.create`运算符发射三个字符串，并在注释（2）中，在从`Observable`发射三个项目后发送一个`onComplete`通知。
- en: However, take a look at the output; it emitted all the items before sending
    the `onComplete` notification. The reason is that all `Obervables` are combined
    together and then subscribed to the downstream. The `flatMap` operator internally
    uses the `merge` operator to combine multiple `Observables`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看看输出；它在发送`onComplete`通知之前发射了所有项目。原因是所有`Observable`都被组合在一起，然后订阅到下游。`flatMap`运算符内部使用`merge`运算符来组合多个`Observable`。
- en: The `concatMap` performs the same operation using the `concat` operator instead
    of the `merge` operator to combine two `Observable`/`Flowables`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatMap`使用`concat`运算符而不是`merge`运算符来执行相同的操作，以组合两个`Observable`/`Flowables`。'
- en: We will learn more about these operators (`merge`, `concat`, and other combining
    operators) in the next chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中了解更多关于这些运算符（`merge`、`concat`和其他组合运算符）的信息。
- en: We will again take a look at `flatMap`, along with `concatMap`, `switchMap`,
    and `flatMapIterable` in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* after gaining some knowledge on merging and concatenating
    producers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次查看`flatMap`，以及`concatMap`、`switchMap`和`flatMapIterable`，在[第6章](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml)，*更多关于运算符和错误处理*之后，我们将对合并和连接生产者有一些了解。
- en: The defaultIfEmpty operator
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defaultIfEmpty运算符
- en: 'While working with filtering operators and/or working on complex requirements,
    it may occur that we encounter an empty producer (see the following code block):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用过滤运算符和/或处理复杂需求时，可能会遇到空的生产者（见以下代码块）：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, on comment `(1)`, we will create `Observable` of range `0` to `10`; however,
    on comment `(2)`, we will filter it for emission value `>15`. So, basically, we
    will end up with an empty Observable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在注释（1）中，我们将创建范围从`0`到`10`的`Observable`；然而，在注释（2）中，我们将过滤它以发射值`>15`。所以，基本上，我们将得到一个空的`Observable`。
- en: 'The `defaultIfEmpty` operator helps us deal with such situations. The preceding
    example, with `defaultIfEmpty` looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty`运算符帮助我们处理这种情况。带有`defaultIfEmpty`的前一个例子看起来像这样：'
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the same program, but, just on comment `(3)`, we added the `defaultIfEmpty`
    operator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的程序，但在注释（3）中，我们添加了`defaultIfEmpty`运算符。
- en: 'The output looks like the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下截图：
- en: '![](img/88efc565-61bf-4801-86d2-3e99901cdfb5.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88efc565-61bf-4801-86d2-3e99901cdfb5.png)'
- en: The output shows that, although `Observable` doesn't contain any number above
    `10`, `defaultIfEmpty` adds `15` to the `Observable` as it's empty after filtering.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，尽管`Observable`不包含任何大于`10`的数字，但`defaultIfEmpty`在过滤后为空时向`Observable`添加了`15`。
- en: The switchIfEmpty operator
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: switchIfEmpty运算符
- en: This operator is similar to the `defaultIfEmpty` operator; the only difference
    is that, for the `defaultIfEmpty` operator, it adds an emission to empty producers,
    but for the `switchIfEmpty` operator, it starts emitting from the specified alternative
    producer if the source producer is empty.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符类似于`defaultIfEmpty`运算符；唯一的区别是，对于`defaultIfEmpty`运算符，它向空的生产者添加一个发射项，但对于`switchIfEmpty`运算符，如果源生产者是空的，它将从指定的替代生产者开始发射。
- en: Unlike the `defaultIfEmpty` operator, where you needed to pass an item, here,
    you have to pass an alternate producer to the `switchIfEmpty` operator. If the
    source producer is empty, it will start taking emissions from the alternate producer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要传递一个项目的`defaultIfEmpty`操作符不同，在这里，你必须将一个替代生产者传递给`switchIfEmpty`操作符。如果源生产者为空，它将从替代生产者开始取排放。
- en: 'Here is an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the same example as the previous one; just on comment `(3)`, we used
    `switchIfEmpty` instead of `defaultIfEmpty` with an alternate Observable. The
    following output shows that the emissions were taken from the alternate Observable
    passed with the `switchIfEmpty` operator:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个例子相同；只是在注释（3）中，我们使用了`switchIfEmpty`而不是`defaultIfEmpty`与一个替代的`Observable`。下面的输出显示，排放是从使用`switchIfEmpty`操作符传递的替代`Observable`中取出的：
- en: '![](img/e5cc506f-14a2-45ab-be68-da67ce63e703.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5cc506f-14a2-45ab-be68-da67ce63e703.png)'
- en: The startWith operator
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`startWith`操作符'
- en: The `startWith` operator is simple; it enables you to add an item to the producer
    at the top of all preexisting items.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWith`操作符很简单；它允许你将一个项目添加到生产者的顶部，所有现有的项目之上。'
- en: 'Let''s take a look at how it works:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/2033e7a6-e4d1-40f2-b14e-010d254c4ad2.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2033e7a6-e4d1-40f2-b14e-010d254c4ad2.png)'
- en: As we can see, the `startWith` operator on comment `(2)` and `(4)` worked just
    like a prefix on the existing list of emissions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，注释（2）和（4）中的`startWith`操作符就像现有排放列表的前缀一样工作。
- en: Sorting emissions (sorted operator)
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排放排序（sorted操作符）
- en: There are some scenarios where you would like to sort the emissions. The `sorted`
    operator helps you do that. It will internally collect and reemit all the emissions
    from the source producer after sorting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景下，你可能想要对排放进行排序。`sorted`操作符可以帮助你做到这一点。它将在排序后内部收集并重新排放来自源生产者的所有排放。
- en: 'Let''s take a look at this example and try to understand this operator better:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子，并尝试更好地理解这个操作符：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Take a look at the output first, and then we will explore the program:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看输出，然后我们将探索程序：
- en: '![](img/644eaf81-347e-4470-9016-9a2d4985cd29.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/644eaf81-347e-4470-9016-9a2d4985cd29.png)'
- en: Now, let's explore the program. As we already know, the `sorted` operator helps
    sorting emissions; to sort, we need to compare, thus, the `sorted` operator requires
    a `Comparable` instance to compare emitted items and sort them respectively. This
    operator has two overloads, one with no parameter—it assumes that the producer
    (here `Observable`) type will implement `Comparable` and calls `compareTo` function,
    failing which will generate error; the other overload is with a method (lambda)
    for comparing. On comment `(1)` and `(2)`, we implemented the `sorted` operator
    with a default `sort` function, that is, it will call the `compareTo` function
    from the item instance and will throw error if the datatype doesn't implement
    `Comparable`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索这个程序。正如我们已经知道的，`sorted`操作符有助于排序排放；为了排序，我们需要比较，因此，`sorted`操作符需要一个`Comparable`实例来比较排放项并分别排序。这个操作符有两个重载版本，一个没有参数——它假设生产者（这里为`Observable`）类型将实现`Comparable`并调用`compareTo`函数，如果没有实现将生成错误；另一个重载版本是带有比较方法的（lambda）。在注释（1）和（2）中，我们使用默认的`sort`函数实现了`sorted`操作符，即它会调用项目实例的`compareTo`函数，如果数据类型没有实现`Comparable`将抛出错误。
- en: On comment `(3)`, we used our own custom `sortFunction` to sort the integers
    in descending order.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释（3）中，我们使用我们自己的自定义`sortFunction`以降序对整数进行排序。
- en: On comment `(4)`, we used an Observable of type `MyItem1`, which obviously is
    a custom class and doesn't implement `Comparable`, so we passed the `sortFunction`
    lambda here as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释（4）中，我们使用了一个类型为`MyItem1`的`Observable`，这显然是一个自定义类，没有实现`Comparable`，因此我们在这里也传递了`sortFunction`
    lambda。
- en: '**Caution**: As we already mentioned, the `sorted` operator collects all emissions
    and then sorts them before reemitting them in a sorted order; thus, using this
    operator can cause significant performance implications. Moreover, while using
    with large producers, it can cause `OutOfMemory Error` as well. So, use the sorted
    operator cautiously, or try to avoid it unless extensively required.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：正如我们已经提到的，`sorted`操作符收集所有排放并排序后再以排序顺序重新排放；因此，使用此操作符可能会引起重大的性能影响。此外，在使用大型生产者时，它还可能导致`OutOfMemory
    Error`。所以，谨慎使用排序操作符，或者除非有广泛的需求，否则尽量避免使用。'
- en: Accumulating data – scan operator
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累积数据 – scan操作符
- en: The `scan` operator is a rolling aggregator; it emits incremental accumulation
    by adding previous emissions to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan`操作符是一个滚动聚合器；它通过将先前排放添加到其中来发出增量累积。'
- en: 'Let''s take a look at the following example before delving deeper:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，让我们先看看以下例子：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8acca42d-df8c-4385-884b-078fa75f3df2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8acca42d-df8c-4385-884b-078fa75f3df2.png)'
- en: So, in this program, we used the `scan` operator to implement three types of
    operations, which we will discuss in detail, but, first, let's try to understand
    the `scan` operator itself. It takes a lambda with two arguments. The first parameter
    is the result of a rolling aggregation of all previous emissions; the second one
    is the current emission.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们使用了`scan`操作符来实现三种类型的操作，我们将在详细讨论之前，首先尝试理解`scan`操作符本身。它接受一个带有两个参数的lambda表达式。第一个参数是所有先前排放的滚动聚合结果；第二个是当前排放。
- en: 'The following graph will allow you to understand it better:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助您更好地理解：
- en: '![](img/5bce443b-389b-4fe1-8dd2-9537b09bebf4.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bce443b-389b-4fe1-8dd2-9537b09bebf4.png)'
- en: As we can see in the graph, the `scan` operator will accumulate all the previous
    emissions with the current emission based on the provided accumulation function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如图表所示，`scan`操作符将根据提供的累积函数将所有先前排放与当前排放累积起来。
- en: So, in the preceding program, on comment `(1)`, we did the same thing with the
    `scan` operator as it is described in the graph. We used it to get the sum of
    all `integers` emitted up until then. On comment `(2)`, we used it with `Observable`
    of type `String` and got concatenated strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在先前的程序中，在注释`(1)`处，我们使用了`scan`操作符，正如图表中描述的那样。我们使用它来获取到目前为止发出的所有`整数`的总和。在注释`(2)`处，我们使用它与`Observable`类型的`String`一起，得到了连接的字符串。
- en: On comment `(3)`, we used the `scan` operator to concatenate the `integers`
    by multiplying the previous accumulation by `10` and adding the present emission
    to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(3)`处，我们使用了`scan`操作符通过将前一次累积乘以`10`并加上当前排放来连接`整数`。
- en: One thing to note is that we can use the `scan` operator for almost any operation,
    not just for summing, as long as it returns items of the same datatype.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，只要返回相同的数据类型项，我们就可以使用`scan`操作符进行几乎任何操作，而不仅仅是求和。
- en: Note that the `scan` operator has similarities with the `reduce` operator, which
    we will cover soon in this chapter; however, be cautious not to get confused.
    The `scan` operator is a rolling aggregator, which transforms all the emissions
    it receives into accumulation; whereas, the `reduce` operator reduces emissions
    to just one by accumulating all the emissions once it receives the `onComplete`
    notification.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`scan`操作符与即将在本章中介绍的`reduce`操作符有相似之处；然而，请谨慎不要混淆。`scan`操作符是一个滚动聚合器，它将接收到的所有排放转换为累积；而`reduce`操作符在接收到`onComplete`通知后，通过累积所有排放将排放减少到只有一个。
- en: Reducing operators
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少操作符
- en: While developing applications, you may face such a situation where you may need
    to accumulate and consolidate emissions. Note that nearly all the operators under
    this criteria will only work on a finite producer (Observable/Flowable) that calls
    `onComplete()` because typically, we can consolidate only finite datasets. We
    will explore this behavior as we cover these operators.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您可能会遇到需要累积和合并排放的情况。请注意，几乎符合这一标准的所有操作符都只会在调用`onComplete()`的有限生产者（Observable/Flowable）上工作，因为通常我们只能合并有限的数据集。我们将随着对这些操作符的介绍来探索这一行为。
- en: 'Here is a short list of reducing operators, which we will cover in this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的减少操作符列表，我们将在本章中介绍：
- en: '`count`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`'
- en: '`reduce`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`'
- en: '`all`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`'
- en: '`any`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`'
- en: '`contains`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`'
- en: Counting emissions (count operator)
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算排放（计数操作符）
- en: The `count` operator subscribes to a producer, counts the emissions, and emits
    a `Single`, containing the count of emissions by the producer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`操作符订阅一个生产者，计算排放量，并在生产者发出排放量的计数后发出一个`Single`。'
- en: 'Here is an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![](img/aa05b80c-734a-40a9-bd4d-9e303e3868c0.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa05b80c-734a-40a9-bd4d-9e303e3868c0.png)'
- en: As we can see from the output, this operator counts the emissions from the producer,
    and emits the count once it receives the `onComplete` notification.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，这个操作符计算生产者的排放量，并在接收到`onComplete`通知后发出计数。
- en: Accumulating emissions – reduce operator
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累积排放 - 减法操作符
- en: Reduce is a perfect accumulation operator. It accumulates all the emissions
    by the producer and emits them once it receives the `onComplete` notification
    from the producer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 减少（reduce）是一个完美的累积操作符。它累积生产者的所有排放，并在接收到生产者的`onComplete`通知后发出它们。
- en: 'Here is an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/2248a518-06cd-4d24-a21b-f31636c3605d.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2248a518-06cd-4d24-a21b-f31636c3605d.png)'
- en: The `reduce` operator works similar to the `scan` operator, the only difference
    is that instead of accumulating and emitting them on each emission, it accumulates
    all the emissions and emits them on receiving the `onComplete` notification.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`操作符的工作方式与`scan`操作符类似，唯一的区别是它不是在每次发射时累积并发射，而是在接收到`onComplete`通知时累积所有发射并发射。'
- en: The `all` and `any` operators help validate emissions by the producer; we will
    look into them in the next chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`和`any`操作符帮助验证生产者的发射；我们将在下一章中探讨它们。'
- en: The collection operators
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`collection`操作符'
- en: Though it is not good practice, keeping some rare situations in mind, RxKotlin
    provides you with operators that can listen to all the emissions and accumulate
    them to a collection object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个好的实践，但考虑到一些罕见的情况，RxKotlin为你提供了可以监听所有发射并将它们累积到集合对象的操作符。
- en: The `collection` operators are basically a subset of the reducing operators.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection`操作符基本上是减少操作符的一个子集。'
- en: 'The following list consists of the most important `collection` operators:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含最重要的`collection`操作符：
- en: '`toList` and `toSortedList`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toList`和`toSortedList`'
- en: '`toMap`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toMap`'
- en: '`toMultiMap`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toMultiMap`'
- en: '`collect`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect`'
- en: We will be covering `collection` operators in detail later in this book.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分详细讲解`collection`操作符。
- en: The error handling operators
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理操作符
- en: 'We already learned about the `onError` event in the Subscriber/Observer. However,
    the problem with the `onError` event is that the error is emitted to the downstream
    consumer chain, and the subscription is terminated instantly. For example, take
    a look at the following program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了Subscriber/Observer中的`onError`事件。然而，`onError`事件的问题在于错误被发射到下游消费者链，并且订阅立即终止。例如，看看以下程序：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the program is shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出显示在以下屏幕截图：
- en: '![](img/bfe8c4e0-644e-485b-9935-2595bb337a87.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfe8c4e0-644e-485b-9935-2595bb337a87.png)'
- en: The program throws an exception in the `map` operator when the string **Errr**
    is emitted from the Observable. The exception was caught by the `onError` handler,
    but the Subscription doesn't get any further emissions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当Observable发出字符串**Errr**时，程序在`map`操作符中抛出异常。异常被`onError`处理器捕获，但订阅没有获得任何进一步的发射。
- en: This may not be the desired behavior every time. Although we cannot pretend
    the error never happened and continue (we should not do this either), there should
    be a way to at least resubscribe or switch to an alternate source producer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是每次都期望的行为。虽然我们不能假装错误从未发生并继续（我们也不应该这样做），但应该至少有重新订阅或切换到备用源生产者的方法。
- en: Error handling operators help you achieve the same.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理操作符可以帮助你实现同样的效果。
- en: The following are the error handling operators.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些错误处理操作符。
- en: '`onErrorResumeNext( )`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorResumeNext( )`'
- en: '`onErrorReturn( )`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorReturn( )`'
- en: '`onExceptionResumeNext( )`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onExceptionResumeNext( )`'
- en: '`retry( )`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry( )`'
- en: '`retryWhen( )`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryWhen( )`'
- en: We will cover error handling operators in detail in [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml),
    *More on Operators and Error Handling*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml)详细讲解错误处理操作符，*更多关于操作符和错误处理*。
- en: The utility operators
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具操作符
- en: These operators help us to perform various utility operations, such as performing
    some action on emissions, remembering timestamps of each items emitted, caching,
    and much more.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符帮助我们执行各种工具操作，例如对发射执行某些操作，记住每个发射项的时间戳，缓存等等。
- en: 'The following is the list of utility operators:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了工具操作符：
- en: '`doOnNext`, `doOnComplete`, and `doOnError`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext`、`doOnComplete`和`doOnError`'
- en: '`doOnSubscribe`, `doOnDispose`, and `doOnSuccess`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe`、`doOnDispose`和`doOnSuccess`'
- en: '`serialize`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize`'
- en: '`cache`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`'
- en: We will cover utility operators in detail in the next chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中详细讲解工具操作符。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about operators and the types of operators available,
    and we learned in detail about operators, especially the ones useful for transforming,
    filtering, and accumulating emissions by the source producer. We also learned
    about the necessity of the error handling operators, which we will cover in the
    next chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了操作符和可用的操作符类型，我们详细学习了操作符，特别是那些用于转换、过滤和累积源生产者发射的操作符。我们还学习了错误处理操作符的必要性，我们将在下一章中介绍。
- en: This chapter and the next chapter, that is, [Chapter 6](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml), *More
    on Operators and Error Handling* are highly related; while discussing topics in
    this chapter, we got a glance about the contents of the next chapter. In the next
    chapter as well, we will refer to and use the contents learned in this chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章，即[第6章](dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml)“更多关于操作符和错误处理”，密切相关；在讨论本章主题时，我们对下一章的内容有了大致的了解。在下一章中，我们也将参考并使用本章学到的内容。
- en: While in this chapter we focused on the basics of operators, operator types,
    and operators specifically useful for filtering, transforming, and accumulating
    emissions (aka data), in the next chapter, we will cover the operators useful
    to combine Observable/Flowables and error handling and for conditional purposes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于操作符、操作符类型以及特别适用于过滤、转换和累积排放（即数据）的操作符（也称为数据）的基础知识，而在下一章中，我们将介绍用于组合可观察的/流动的、错误处理以及条件目的的操作符。
- en: Turn the page right now to get started.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 立即翻到下一页开始吧。
