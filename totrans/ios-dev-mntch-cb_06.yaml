- en: Chapter 6. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 网络服务
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Consuming web services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费网络服务
- en: Invoking web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用网络服务
- en: Consuming WCF services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费WCF服务
- en: Reading JSON data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取JSON数据
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Providing online information to the user is a crucial part of mobile development.
    In this chapter, we will discuss developing applications that communicate with
    web services to provide information. We will see how to consume and invoke web
    services, based on SOAP. We will also discuss how to use WCF web services and
    how to parse the popular JSON data format from a web server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户提供在线信息是移动开发的关键部分。在本章中，我们将讨论开发与网络服务通信以提供信息的应用程序。我们将看到如何基于SOAP消费和调用网络服务，还将讨论如何使用WCF网络服务以及如何从网络服务器解析流行的JSON数据格式。
- en: All examples in this chapter use the xsp lightweight web server that ships with
    the Mono Framework, so there is no need to have a live web service up and running
    online to make use of the provided code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都使用与Mono框架一起提供的xsp轻量级网络服务器，因此无需在线上运行一个实时网络服务来使用提供的代码。
- en: Consuming web services
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费网络服务
- en: In this recipe, we will learn how to use a SOAP web service in a MonoTouch project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何在MonoTouch项目中使用SOAP网络服务。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `WebServiceApp`. This chapter's
    code contains a web service project, named `MTWebService`. This is the web service
    that will be used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`WebServiceApp`。本章的代码包含一个名为`MTWebService`的网络服务项目。这就是将要使用的网络服务。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To use the `MTWebService` web service, we need a web server. Mono Framework
    provides the xsp lightweight web server for testing purposes.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`MTWebService`网络服务，我们需要一个网络服务器。Mono框架提供了用于测试目的的xsp轻量级网络服务器。
- en: 'Open a terminal and type the following command to get to the web service''s
    directory, replacing`<code_directory>` with the path the downloaded code is in:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端，并输入以下命令以进入网络服务的目录，将`<code_directory>`替换为下载的代码所在的路径：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the xsp web server by typing `xsp4` in the prompt. You will see an output
    similar to the following:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在提示符中输入`xsp4`来运行xsp网络服务器。你将看到类似以下输出的内容：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we need to add a web reference to the web service in the project. Right-click
    on the project in the **Solution** pad and select **Add | Add Web Reference**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在项目中添加对网络服务的引用。在**解决方案**面板中右键单击项目，然后选择**添加 | 添加Web引用**。
- en: In the dialog that will be shown, add the information provided in the following
    screenshot:![How to do it...](img/1468EXP_06_01.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将显示的对话框中，添加以下截图提供的信息：![如何操作...](img/1468EXP_06_01.jpg)
- en: 'After adding the web reference to the **MTTestWebService** web service, add
    a button and a label on the view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and enter the following code in it:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将引用添加到**MTTestWebService**网络服务后，在`MainController`的视图中添加一个按钮和一个标签。覆盖`MainController`类的`ViewDidLoad`方法，并在其中输入以下代码：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, provide a `using` directive for our web service''s namespace:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为我们的网络服务命名空间提供一个`using`指令：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compile and run the application on the simulator.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the button to invoke the web service, and notice the output message in the
    label.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮以调用网络服务，并注意标签中的输出消息。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'MonoTouch can consume web services just like a .NET desktop application. The
    `xsp` lightweight web server is installed by default when installing the Mono
    Framework, which is a requirement for the MonoTouch installation. When running
    the `xsp4` command in the terminal without any parameters, it sets its base directory
    to the current directory by default and starts listening on the `8080` port. If
    the web server is started, the web service description can be viewed by entering
    `http://localhost:8080/MTTestWebService.asmx` in a browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch可以像.NET桌面应用程序一样消费网络服务。`xsp`轻量级网络服务器在安装Mono框架时默认安装，这是MonoTouch安装的要求。在终端中运行不带任何参数的`xsp4`命令时，它默认将其基本目录设置为当前目录，并开始监听`8080`端口。如果网络服务器已启动，可以通过在浏览器中输入`http://localhost:8080/MTTestWebService.asmx`来查看网络服务描述：
- en: '![How it works...](img/1468EXP_06_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1468EXP_06_02.jpg)'
- en: The link that needs to be entered in the **Web Service Url** field of the web
    reference dialog can be found by clicking on the **Service Description** link
    in the service description page, and then by clicking on the **Download** link
    above the web service's WSDL description.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在网络服务引用对话框的 **Web 服务 URL** 字段中输入的链接，可以通过点击服务描述页面上的 **服务描述** 链接，然后点击位于网络服务
    WSDL 描述上方的 **下载** 链接来找到。
- en: 'We then set the **Framework** value to **.NET 2.0 Web Services**, and provide
    a **Reference** name, which will reflect the namespace of the web reference. To
    make use of the web service within our code, we instantiate it, and then just
    call the method we are interested in:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 **框架** 值设置为 **.NET 2.0 Web 服务**，并提供一个 **引用** 名称，该名称将反映网络引用的命名空间。为了在我们的代码中使用网络服务，我们实例化它，然后只需调用我们感兴趣的方法：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Apart from using a local hosted web service, there are also numerous sample
    web services on the Internet. A simple search will yield many results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用本地托管网络服务外，互联网上还有许多示例网络服务。简单的搜索会产生许多结果。
- en: XSP shutdown
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XSP 关闭
- en: To shutdown the `xsp` web server, just press the *return* key in the terminal
    where it was executed from.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭 `xsp` 网络服务器，只需在执行它的终端中按 *回车键*。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中：
- en: '*Invoking web services*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用网络服务*'
- en: '*Consuming WCF services*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费 WCF 服务*'
- en: Invoking web services
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用网络服务
- en: In this recipe, we will discuss how to properly use web services with MonoTouch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何正确使用 MonoTouch 中的网络服务。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `WebServiceApp2`. Start the
    `xsp` web server, and add a web reference in the project to the `TTestWebService`
    web service, as described in the previous task.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `WebServiceApp2`。启动 `xsp` 网络服务器，并在项目中添加对 `TTestWebService`
    网络服务的引用，具体操作如前一个任务所述。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Add a label and a button on the view of `MainController`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的视图中添加一个标签和一个按钮。
- en: 'In the `MainController` class in MonoDevelop, override the `ViewDidLoad` method,
    and enter the following code in it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中的 `MainController` 类中，覆盖 `ViewDidLoad` 方法，并在其中输入以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add the following method:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下方法：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compile and run the application on the simulator.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the button and see the result from the web service being displayed on
    the label.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，查看网络服务的结果在标签上显示。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you may already have noticed, the application from the previous task froze
    while it was communicating with the web service, until it received the result.
    In this task, we use the asynchronous invocation so that the user interface will
    not freeze while the application is contacting the web service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，在前一个任务中，当应用程序与网络服务通信时，它冻结了，直到收到结果。在这个任务中，我们使用异步调用，这样在应用程序联系网络服务时用户界面就不会冻结。
- en: 'We want to be notified when our application receives a response from the web
    service, but we also need its result. Prior to calling the web method that we
    are interested in, we subscribe to the web service object''s `MultiplyNumbersCompleted`
    event, as the highlighted code shows in the `ViewDidLoad` override. This event
    is part of the class that was created by MonoDevelop when we added the web reference,
    and every web method has a corresponding event. We then call the web method asynchronously
    by accessing the `MultiplyNumbersAsync` method. This call returns instantly. The
    next call is interesting:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在应用程序从网络服务收到响应时得到通知，但我们还需要它的结果。在调用我们感兴趣的 web 方法之前，我们订阅了网络服务对象的 `MultiplyNumbersCompleted`
    事件，如 `ViewDidLoad` 覆盖中突出显示的代码所示。这个事件是 MonoDevelop 在我们添加网络引用时创建的类的一部分，每个 web 方法都有一个对应的事件。然后我们通过访问
    `MultiplyNumbersAsync` 方法异步调用 web 方法。这个调用立即返回。下一个调用很有趣：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Through the `UIApplication.SharedApplication` static property, we have access
    to some application-wide components, such as the status bar that is displayed
    on the screen. It is recommended to provide some sort of information to the user
    when a process is pending. The status bar contains an activity indicator, which
    is what is displayed when the device connects to the Internet in native iOS applications.
    Hence, the user is accustomed to this control and knows that when it is displayed,
    the device connects to receive data. By setting the `NetworkActivityIndicatorVisible`
    property to `true`, the network indicator is activated and displayed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `UIApplication.SharedApplication` 静态属性，我们可以访问一些应用程序范围内的组件，例如屏幕上显示的状态栏。当有进程挂起时，建议向用户提供某种信息。状态栏包含一个活动指示器，这是在原生
    iOS 应用程序中设备连接到互联网时显示的内容。因此，用户习惯于这个控件，并知道当它显示时，设备正在连接以接收数据。通过将 `NetworkActivityIndicatorVisible`
    属性设置为 `true`，网络指示器被激活并显示。
- en: When a call to a web method is completed, the appropriate event is triggered.
    Inside the `MultiplyNumbers_CompletedHandler` method, we first make sure to hide
    the network indicator to inform the user that the application is no longer connected.
    We can access the result of the web method through the `MultiplyNumbersCompletedEventArgs.
    Result` property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当对 Web 方法的调用完成时，将触发相应的事件。在 `MultiplyNumbers_CompletedHandler` 方法内部，我们首先确保隐藏网络指示器，以通知用户应用程序不再连接。我们可以通过
    `MultiplyNumbersCompletedEventArgs.Result` 属性访问 Web 方法的返回结果。
- en: In this example, we want to display the result in the label directly, from within
    our handler. Because the web method was asynchronously called, the handler will
    most likely be executed on a different thread than the main thread. So, we wrap
    the assignment of the result to the label to an anonymous method and execute it
    on the main thread, as shown in the highlighted code of the handler implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们希望在处理程序内部直接在标签中显示结果。因为 Web 方法是异步调用的，处理程序很可能会在主线程之外的其他线程上执行。因此，我们将结果赋值给标签的操作包装在一个匿名方法中，并在主线程上执行，如处理程序实现中突出显示的代码所示。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The web service object contains a more common set of asynchronous invocation
    that we can use. It follows the `BeginInvoke EndInvoke` pattern, with the methods
    renamed according to the web method of the service. In this case, these methods
    are named `BeginMultiplyNumbers` and `EndMultiplyNumbers`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务对象包含了一组更常见的异步调用，我们可以使用。它遵循 `BeginInvoke EndInvoke` 模式，方法名称根据服务的 Web 方法进行重命名。在这种情况下，这些方法被命名为
    `BeginMultiplyNumbers` 和 `EndMultiplyNumbers`。
- en: Error handling
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'The `MultiplyNumbersCompletedEventArgs` class also contains an `Error` property.
    It returns a value of the type `System.Exception`, and if something went wrong,
    for example, due to lack of network connection, it will contain the appropriate
    information. If no error occurred, the `Error` property will return `null`. It
    is advisable to always check this property first, before proceeding to retrieving
    the result of the web method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiplyNumbersCompletedEventArgs` 类还包含一个 `Error` 属性。它返回 `System.Exception`
    类型的值，如果发生错误，例如由于网络连接问题，它将包含适当的信息。如果没有发生错误，`Error` 属性将返回 `null`。在检索 Web 方法的返回结果之前，建议始终检查此属性：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Consuming WCF services*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费 WCF 服务*'
- en: Consuming WCF services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 WCF 服务
- en: In this recipe, we will learn how to consume WCF services with MonoTouch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 MonoTouch 消费 WCF 服务。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this project, we will need a running WCF service. A WCF service can be
    found in the code download of this chapter. To start the service, open a terminal
    and go to the project''s directory. Start the service by running the `start_wcfservice.sh`
    shell script:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此项目，我们需要一个正在运行的 WCF 服务。本章的代码下载中可以找到 WCF 服务。要启动服务，打开终端并转到项目的目录。通过运行 `start_wcfservice.sh`
    脚本来启动服务：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the service is started, create a new project in MonoDevelop, and name
    it `WcfServiceApp`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务启动后，在 MonoDevelop 中创建一个新的项目，并将其命名为 `WcfServiceApp`。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add the references to the `System.Runtime.Serialization` and `System.ServiceModel`
    to the project and their corresponding `using` directives in the `MainController.cs`
    file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `System.Runtime.Serialization` 和 `System.ServiceModel` 的引用添加到项目中，并在 `MainController.cs`
    文件中添加它们对应的 `using` 指令。
- en: 'MonoTouch does not yet provide full support for WCF services. To generate a
    proxy for the client, we will need to use the `slsvcutil` tool on a Windows machine.
    Run the following command in the terminal under Windows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MonoTouch尚未提供对WCF服务的全面支持。为了生成客户端代理，我们将在Windows机器上使用`slsvcutil`工具。在Windows的终端中运行以下命令：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will produce a C# source fi le named `service.cs` . Add this fi
    le to the MonoDevelop project.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将生成一个名为`service.cs`的C#源文件。将此文件添加到MonoDevelop项目中。
- en: 'Add a label and a button on the view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and enter the following code in it:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`视图上添加一个标签和一个按钮。重写`MainController`类的`ViewDidLoad`方法，并在其中输入以下代码：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, add the following event handler:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下事件处理器：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run the application on the simulator.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the button and watch the data returned from the service populate in the
    label.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮，并观察从服务返回的数据填充到标签中。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: MonoTouch relies on Mono Framework's support on WCF services, which is not complete.
    However, the fact alone that WCF services can be used in iOS applications makes
    MonoTouch more appealing to .NET developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch依赖于Mono Framework对WCF服务的支持，但这并不完整。然而，仅WCF服务可以在iOS应用程序中使用这一事实就使MonoTouch对.NET开发者更具吸引力。
- en: For instance, there is no tool to create the client proxy on a Mac, so we will
    have to have access to a Windows machine to do this, with the **Silverlight Service
    Model Proxy Generation Tool (slsvcutil.exe)** . The source file this tool generates
    allows us to consume the WCF service in our project. It basically does what MonoDevelop
    does automatically when we add a web reference to an ASMX web service, like in
    the two previous tasks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，没有工具可以在Mac上创建客户端代理，因此我们必须能够访问Windows机器来执行此操作，使用**Silverlight服务模型代理生成工具（slsvcutil.exe）**。该工具生成的源文件允许我们在项目中消耗WCF服务。它基本上做了MonoDevelop在我们添加Web引用到ASMX
    Web服务时自动执行的事情，就像在前两个任务中一样。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to use the **Silverlight version 3.0** `slsvcutil` to create
    the client proxy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是使用**Silverlight版本3.0**的`slsvcutil`来创建客户端代理。
- en: 'Apart from Mono Framework''s support, there is another limitation: dynamic
    code generation is not allowed on iOS. This makes any code that relies on the
    `System.Reflection.Emit` namespace unusable. In fact, the `System.Reflection.Emit`
    namespace is not available at all in MonoTouch.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mono Framework的支持外，还有一个限制：iOS不允许动态代码生成。这使得任何依赖于`System.Reflection.Emit`命名空间的代码都无法使用。实际上，`System.Reflection.Emit`命名空间在MonoTouch中根本不可用。
- en: After copying the produced file on the Mac, we add it to the project and we
    are ready to use the WCF service. The previous highlighted code shows how to instantiate
    the service object. Note that the default constructor of the service object cannot
    be used, since MonoTouch does not support the `System.Configuration` namespace.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上复制生成的文件后，我们将其添加到项目中，我们就可以使用WCF服务了。之前高亮显示的代码显示了如何实例化服务对象。请注意，服务对象的默认构造函数不能使用，因为MonoTouch不支持`System.Configuration`命名空间。
- en: 'The actual communication occurs by calling the method''s asynchronous implementation,
    after setting a handler to its corresponding completion event. Note that in this
    case, there is no alternative of using synchronous invocations, or `BeginInvoke
    EndInvoke` pattern:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际通信是通过调用方法异步实现来完成的，在设置其对应完成事件的处理器之后。请注意，在这种情况下，没有使用同步调用或`BeginInvoke EndInvoke`模式的替代方案：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result returned from the service can be retrieved through the specified
    `EventArgs` derivative''s `Result` property:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务返回的结果可以通过指定的`EventArgs`派生类的`Result`属性检索：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When debugging a project that consumes WCF services, remember to set the address
    of the machine the service is running on, instead of `localhost` or `127.0.0.1`.
    That is because when we run the application on the device, the application will
    fail to connect to the service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试消耗WCF服务的项目时，请记住设置服务运行在的机器的地址，而不是`localhost`或`127.0.0.1`。这是因为当我们将应用程序运行在设备上时，应用程序将无法连接到服务。
- en: More information on MonoDevelop's WCF support
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于MonoDevelop的WCF支持的更多信息
- en: There is an option of adding a WCF web reference through MonoDevelop in the
    **Add Web References** window shown in the *Consuming Web Services* recipe. However,
    it is not yet complete.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*消耗Web服务*配方中显示的**添加Web引用**窗口中，可以通过MonoDevelop添加WCF Web引用。然而，它尚未完成。
- en: WCF service creation
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WCF服务创建
- en: The object returned from the `WcfService` service and the actual service itself
    were created completely on a Mac with MonoDevelop. Since there is no WCF project
    template, the **Empty Project** template was used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `WcfService` 服务返回的对象以及实际的服务本身都是在 Mac 上使用 MonoDevelop 完全创建的。由于没有 WCF 项目模板，使用了
    **空项目** 模板。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Consuming web services*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费 Web 服务*'
- en: Reading JSON data
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 JSON 数据
- en: In this recipe, we will learn how to read **JavaScript Object Notation (JSON
    )** data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何读取 **JavaScript 对象表示法 (JSON )** 数据。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `JsonDataApp`. Add a button
    and a label on the view of the `MainController`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `JsonDataApp`。在 `MainController` 的视图中添加一个按钮和一个标签。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Add a reference to the project to the `System.Json` assembly.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目添加到 `System.Json` 程序集的引用中。
- en: 'Add the following `using` directives in the `MainController.cs` file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController.cs` 文件中添加以下 `using` 指令：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Enter the following method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Attach a handler to the button''s `TouchUpInside` event, and enter the following
    code in it:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理程序附加到按钮的 `TouchUpInside` 事件，并在其中输入以下代码：
- en: '[PRE17]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, run the `xsp` server in the project's directory. The file "mtjson.txt"
    contains data in JSON format.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在项目目录中运行 `xsp` 服务器。文件 "mtjson.txt" 包含了 JSON 格式的数据。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'JSON is a specific text format that is human-readable and easy to implement.
    Many popular websites use this format to distribute data. Its main advantage is
    that it is language-independent. The structure of JSON is based on name/value
    pairs and arrays. The JSON data object used in this task is fairly simple:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种特定的文本格式，它易于阅读和实现。许多流行的网站使用此格式来分发数据。其主要优势是它不受语言限制。JSON 的结构基于名称/值对和数组。在本任务中使用的
    JSON 数据对象相当简单：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To read the data from the web server, we simply create an `HttpWebRequest` object,
    setting its `Method` property to `HTTP GET:`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要从网络服务器读取数据，我们只需创建一个 `HttpWebRequest` 对象，将其 `Method` 属性设置为 `HTTP GET:`。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We then need to get the response from the server. We do this by retrieving the
    request's response object and read the data from its underlying stream with a
    `StreamReader:`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要从服务器获取响应。我们通过检索请求的响应对象，并使用 `StreamReader` 从其底层流中读取数据来完成此操作：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `responseString` variable now contains the raw JSON data shown previously.
    For parsing JSON data, MonoTouch provides the `JsonValue` class. To create a `JsonValue`
    object, we use its `Parse` static method, passing it as the string containing
    the JSON data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `responseString` 变量包含了之前显示的原始 JSON 数据。为了解析 JSON 数据，MonoTouch 提供了 `JsonValue`
    类。要创建一个 `JsonValue` 对象，我们使用它的 `Parse` 静态方法，并将包含 JSON 数据的字符串传递给它：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To access the data that the `JsonValue` object has parsed, we use indexers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `JsonValue` 对象解析的数据，我们使用索引器：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If a name that does not exist in the JSON object is passed, an exception will
    occur. If the names of the JSON object are not known, we can use integers to retrieve
    the data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了一个在 JSON 对象中不存在的名称，将会抛出异常。如果不知道 JSON 对象的名称，我们可以使用整数来检索数据：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `JsonValue` class inherits from the `IEnumerable` interface.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonValue` 类继承自 `IEnumerable` 接口。'
- en: Serialization
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化
- en: 'The `System.Json` namespace provides objects for simple parsing of JSON data.
    It does not provide JSON serialization functionality. We can, however, create
    a `JsonObject` from a set of `KeyValuePair<string, JsonValue>` objects. To create
    the previous JSON object, we would write something like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Json` 命名空间提供了用于简单解析 JSON 数据的对象。它不提供 JSON 序列化功能。然而，我们可以从一组 `KeyValuePair<string,
    JsonValue>` 对象创建一个 `JsonObject`。要创建之前的 JSON 对象，我们将编写如下内容：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Consuming web services*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费 Web 服务*'
