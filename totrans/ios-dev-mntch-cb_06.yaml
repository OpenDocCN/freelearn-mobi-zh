- en: Chapter 6. Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WCF services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing online information to the user is a crucial part of mobile development.
    In this chapter, we will discuss developing applications that communicate with
    web services to provide information. We will see how to consume and invoke web
    services, based on SOAP. We will also discuss how to use WCF web services and
    how to parse the popular JSON data format from a web server.
  prefs: []
  type: TYPE_NORMAL
- en: All examples in this chapter use the xsp lightweight web server that ships with
    the Mono Framework, so there is no need to have a live web service up and running
    online to make use of the provided code.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a SOAP web service in a MonoTouch project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `WebServiceApp`. This chapter's
    code contains a web service project, named `MTWebService`. This is the web service
    that will be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the `MTWebService` web service, we need a web server. Mono Framework
    provides the xsp lightweight web server for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a terminal and type the following command to get to the web service''s
    directory, replacing`<code_directory>` with the path the downloaded code is in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the xsp web server by typing `xsp4` in the prompt. You will see an output
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to add a web reference to the web service in the project. Right-click
    on the project in the **Solution** pad and select **Add | Add Web Reference**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog that will be shown, add the information provided in the following
    screenshot:![How to do it...](img/1468EXP_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After adding the web reference to the **MTTestWebService** web service, add
    a button and a label on the view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and enter the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, provide a `using` directive for our web service''s namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the button to invoke the web service, and notice the output message in the
    label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MonoTouch can consume web services just like a .NET desktop application. The
    `xsp` lightweight web server is installed by default when installing the Mono
    Framework, which is a requirement for the MonoTouch installation. When running
    the `xsp4` command in the terminal without any parameters, it sets its base directory
    to the current directory by default and starts listening on the `8080` port. If
    the web server is started, the web service description can be viewed by entering
    `http://localhost:8080/MTTestWebService.asmx` in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The link that needs to be entered in the **Web Service Url** field of the web
    reference dialog can be found by clicking on the **Service Description** link
    in the service description page, and then by clicking on the **Download** link
    above the web service's WSDL description.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set the **Framework** value to **.NET 2.0 Web Services**, and provide
    a **Reference** name, which will reflect the namespace of the web reference. To
    make use of the web service within our code, we instantiate it, and then just
    call the method we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from using a local hosted web service, there are also numerous sample
    web services on the Internet. A simple search will yield many results.
  prefs: []
  type: TYPE_NORMAL
- en: XSP shutdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To shutdown the `xsp` web server, just press the *return* key in the terminal
    where it was executed from.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Invoking web services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Consuming WCF services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to properly use web services with MonoTouch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `WebServiceApp2`. Start the
    `xsp` web server, and add a web reference in the project to the `TTestWebService`
    web service, as described in the previous task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a label and a button on the view of `MainController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainController` class in MonoDevelop, override the `ViewDidLoad` method,
    and enter the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the button and see the result from the web service being displayed on
    the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may already have noticed, the application from the previous task froze
    while it was communicating with the web service, until it received the result.
    In this task, we use the asynchronous invocation so that the user interface will
    not freeze while the application is contacting the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be notified when our application receives a response from the web
    service, but we also need its result. Prior to calling the web method that we
    are interested in, we subscribe to the web service object''s `MultiplyNumbersCompleted`
    event, as the highlighted code shows in the `ViewDidLoad` override. This event
    is part of the class that was created by MonoDevelop when we added the web reference,
    and every web method has a corresponding event. We then call the web method asynchronously
    by accessing the `MultiplyNumbersAsync` method. This call returns instantly. The
    next call is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Through the `UIApplication.SharedApplication` static property, we have access
    to some application-wide components, such as the status bar that is displayed
    on the screen. It is recommended to provide some sort of information to the user
    when a process is pending. The status bar contains an activity indicator, which
    is what is displayed when the device connects to the Internet in native iOS applications.
    Hence, the user is accustomed to this control and knows that when it is displayed,
    the device connects to receive data. By setting the `NetworkActivityIndicatorVisible`
    property to `true`, the network indicator is activated and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: When a call to a web method is completed, the appropriate event is triggered.
    Inside the `MultiplyNumbers_CompletedHandler` method, we first make sure to hide
    the network indicator to inform the user that the application is no longer connected.
    We can access the result of the web method through the `MultiplyNumbersCompletedEventArgs.
    Result` property.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we want to display the result in the label directly, from within
    our handler. Because the web method was asynchronously called, the handler will
    most likely be executed on a different thread than the main thread. So, we wrap
    the assignment of the result to the label to an anonymous method and execute it
    on the main thread, as shown in the highlighted code of the handler implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The web service object contains a more common set of asynchronous invocation
    that we can use. It follows the `BeginInvoke EndInvoke` pattern, with the methods
    renamed according to the web method of the service. In this case, these methods
    are named `BeginMultiplyNumbers` and `EndMultiplyNumbers`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `MultiplyNumbersCompletedEventArgs` class also contains an `Error` property.
    It returns a value of the type `System.Exception`, and if something went wrong,
    for example, due to lack of network connection, it will contain the appropriate
    information. If no error occurred, the `Error` property will return `null`. It
    is advisable to always check this property first, before proceeding to retrieving
    the result of the web method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consuming WCF services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WCF services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to consume WCF services with MonoTouch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this project, we will need a running WCF service. A WCF service can be
    found in the code download of this chapter. To start the service, open a terminal
    and go to the project''s directory. Start the service by running the `start_wcfservice.sh`
    shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the service is started, create a new project in MonoDevelop, and name
    it `WcfServiceApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the references to the `System.Runtime.Serialization` and `System.ServiceModel`
    to the project and their corresponding `using` directives in the `MainController.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MonoTouch does not yet provide full support for WCF services. To generate a
    proxy for the client, we will need to use the `slsvcutil` tool on a Windows machine.
    Run the following command in the terminal under Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will produce a C# source fi le named `service.cs` . Add this fi
    le to the MonoDevelop project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a label and a button on the view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and enter the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the button and watch the data returned from the service populate in the
    label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MonoTouch relies on Mono Framework's support on WCF services, which is not complete.
    However, the fact alone that WCF services can be used in iOS applications makes
    MonoTouch more appealing to .NET developers.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, there is no tool to create the client proxy on a Mac, so we will
    have to have access to a Windows machine to do this, with the **Silverlight Service
    Model Proxy Generation Tool (slsvcutil.exe)** . The source file this tool generates
    allows us to consume the WCF service in our project. It basically does what MonoDevelop
    does automatically when we add a web reference to an ASMX web service, like in
    the two previous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to use the **Silverlight version 3.0** `slsvcutil` to create
    the client proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from Mono Framework''s support, there is another limitation: dynamic
    code generation is not allowed on iOS. This makes any code that relies on the
    `System.Reflection.Emit` namespace unusable. In fact, the `System.Reflection.Emit`
    namespace is not available at all in MonoTouch.'
  prefs: []
  type: TYPE_NORMAL
- en: After copying the produced file on the Mac, we add it to the project and we
    are ready to use the WCF service. The previous highlighted code shows how to instantiate
    the service object. Note that the default constructor of the service object cannot
    be used, since MonoTouch does not support the `System.Configuration` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual communication occurs by calling the method''s asynchronous implementation,
    after setting a handler to its corresponding completion event. Note that in this
    case, there is no alternative of using synchronous invocations, or `BeginInvoke
    EndInvoke` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result returned from the service can be retrieved through the specified
    `EventArgs` derivative''s `Result` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When debugging a project that consumes WCF services, remember to set the address
    of the machine the service is running on, instead of `localhost` or `127.0.0.1`.
    That is because when we run the application on the device, the application will
    fail to connect to the service.
  prefs: []
  type: TYPE_NORMAL
- en: More information on MonoDevelop's WCF support
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is an option of adding a WCF web reference through MonoDevelop in the
    **Add Web References** window shown in the *Consuming Web Services* recipe. However,
    it is not yet complete.
  prefs: []
  type: TYPE_NORMAL
- en: WCF service creation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The object returned from the `WcfService` service and the actual service itself
    were created completely on a Mac with MonoDevelop. Since there is no WCF project
    template, the **Empty Project** template was used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consuming web services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to read **JavaScript Object Notation (JSON
    )** data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `JsonDataApp`. Add a button
    and a label on the view of the `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a reference to the project to the `System.Json` assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives in the `MainController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach a handler to the button''s `TouchUpInside` event, and enter the following
    code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the `xsp` server in the project's directory. The file "mtjson.txt"
    contains data in JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON is a specific text format that is human-readable and easy to implement.
    Many popular websites use this format to distribute data. Its main advantage is
    that it is language-independent. The structure of JSON is based on name/value
    pairs and arrays. The JSON data object used in this task is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To read the data from the web server, we simply create an `HttpWebRequest` object,
    setting its `Method` property to `HTTP GET:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We then need to get the response from the server. We do this by retrieving the
    request's response object and read the data from its underlying stream with a
    `StreamReader:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `responseString` variable now contains the raw JSON data shown previously.
    For parsing JSON data, MonoTouch provides the `JsonValue` class. To create a `JsonValue`
    object, we use its `Parse` static method, passing it as the string containing
    the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the data that the `JsonValue` object has parsed, we use indexers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a name that does not exist in the JSON object is passed, an exception will
    occur. If the names of the JSON object are not known, we can use integers to retrieve
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `JsonValue` class inherits from the `IEnumerable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `System.Json` namespace provides objects for simple parsing of JSON data.
    It does not provide JSON serialization functionality. We can, however, create
    a `JsonObject` from a set of `KeyValuePair<string, JsonValue>` objects. To create
    the previous JSON object, we would write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Consuming web services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
