["```swift\nlet app = Application()\napp.start(port: 8080)\n\n```", "```swift\napp.get(\"welcome\") { request in\n    return \"Hello, World\"\n}\n\n```", "```swift\napp.get(\"version\") { request in\n    return Json([\"version\": \"0.1\"])\n}\n\n```", "```swift\napp.post(\"hello\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        return \"Please include a name\"\n    }\n\n    return \"Hello, \\(name)!\"\n}\n\n```", "```swift\n.Package(url: \"https://github.com/qutheory/vapor.git\",\n  majorVersion: xx, minor: x),\n.Package(url: \"https://github.com/qutheory/vapor-zewo-mustache.git\",\n  majorVersion: xx, minor: xx)\n```", "```swift\nimport Vapor\n\nfinal class Todo {\n    var id: Int\n    var name: String\n    var description: String\n    var notes: String\n    var completed: Bool\n    var synced: Bool\n\n    init(id: Int, name: String, description: String, notes: String,\n      completed: Bool, synced: Bool) {\n        self.id = id\n        self.name = name\n        self.description = description\n        self.notes = notes\n        self.completed = completed\n        self.synced = synced\n    }\n}\n\n```", "```swift\nextension Todo: JSONRepresentable {\n    func makeJson() -> JSON {\n\n        return JSON([\n            \"id\":id,\n          \"name\": \"\\(name)\",\n   \"description\": \"\\(description)\",\n         \"notes\": \"\\(notes)\",\n     \"completed\": completed,\n        \"synced\": synced\n        ])\n    }\n}\n\n```", "```swift\nimport Vapor\n\nfinal class TodoStore {\n\n    static let sharedInstance = TodoStore()\n    private var list: [Todo] = Array<Todo>()\n    private init() {\n    }\n}\n\n```", "```swift\nextension TodoStore: JSONRepresentable {\n    func makeJson() -> JSON {\n        return JSON([\n            \"list\": \"\\(list)\"\n        ])\n    }\n}\n```", "```swift\nfunc addtem(item: Todo) {\n    self.list.append(item)\n}\n\nfunc listItems() -> [Todo] {\n    return self.list\n}\n\n```", "```swift\nfunc find(id: Int) -> Todo? {\n    return self.list.index { $0.id == id }.map { self.list[$0] }\n}\n\n```", "```swift\nfunc delete(id: Int) -> String {\n    if self.find(id: id) != nil {\n        self.list = self.list.filter { $0.id != id }\n        return \"Item is deleted\"\n    }\n    return \"Item not found\"\n}\n\nfunc deleteAll() -> String {\n    if self.list.count > 0 {\n        self.list.removeAll()\n        return \"All items were deleted\"\n    }\n    return \"List was empty\"\n\n}\n\nfunc update(item: Todo) -> String {\n    if let index = (self.list.index { $0.id == item.id }) {\n        self.list[index] = item\n        return \"item is up to date\"\n    }\n    return \"item not found\"\n}\n\n```", "```swift\nfunc addOrUpdateItem(item: Todo) {\n    if self.find(item.id) != nil {\n        update(item)\n    } else {\n        self.list.append(item)\n    }\n}\n\n```", "```swift\nlet app = Application()\n\n```", "```swift\n/// Post a todo item\napp.post(\"postTodo\") { request in\n    guard let id = request.headers.headers[\"id\"]?.values,\n        name = request.headers.headers[\"name\"]?.values,\n        description = request.headers.headers[\"description\"]?.values,\n        notes = request.headers.headers[\"notes\"]?.values,\n        completed = request.headers.headers[\"completed\"]?.values,\n        synced = request.headers.headers[\"synced\"]?.values\n    else {\n        return JSON([\"message\": \"Please include mandatory parameters\"])\n    }\n\n    let todoItem = Todo(id: Int(id[0])!,\n                      name: name[0],\n               description: description[0],\n                     notes: notes[0],\n                 completed: completed[0].toBool()!,\n                    synced: synced[0].toBool()!)\n\n    let todos = TodoStore.sharedInstance\n    todos.addOrUpdateItem(item: todoItem)\n\n    let json:[JSONRepresentable] = todos.listItems().map { $0 }\n    return JSON(json)\n}\n\n```", "```swift\nextension String {\n    func toBool() -> Bool? {\n        switch self {\n        case \"True\", \"true\", \"yes\", \"1\":\n            return true\n        case \"False\", \"false\", \"no\", \"0\":\n            return false\n        default:\n            return nil\n        }\n    }\n}\n\n```", "```swift\ncurl -X \"POST\" \"http://localhost:8080/postTodo/\" \\\n   -H \"Cookie: test=123\" \\\n   -H \"id: 3\" \\\n   -H \"notes: do not forget to buy potato chips\" \\\n   -H \"Content-Type: application/json\" \\\n   -H \"description: Our first todo item\" \\\n   -H \"completed: false\" \\\n   -H \"name: todo 1\" \\\n   -d \"{}\"\n\n```", "```swift\n/// List todo items\napp.get(\"todos\") { request in\n\n    let todos = TodoStore.sharedInstance\n    let json:[JSONRepresentable] = todos.listItems().map { $0 }\n    return JSON(json)\n}\n\n```", "```swift\ncurl -X \"GET\" \"http://localhost:8080/todos\" \\\n   -H \"Cookie: test=123\"\n\n```", "```swift\n/// Get a specific todo item\napp.get(\"todo\") { request in\n\n    guard let id = request.headers.headers[\"id\"]?.values else {\n        return JSON([\"message\": \"Please provide the id of todo item\"])\n    }\n\n    let todos = TodoStore.sharedInstance.listItems()\n    var json = [JSONRepresentable]()\n\n    let item = todos.filter { $0.id == Int(id[0])! }\n    if item.count > 0 {\n        json.append(item[0])\n    }\n\n    return JSON(json)\n}\n\n```", "```swift\ncurl -X \"GET\" \"http://localhost:8080/todo/\" \\\n   -H \"id: 1\" \\\n   -H \"Cookie: test=123\"\n\n```", "```swift\n/// Delete a specific todo item\napp.delete(\"deleteTodo\") { request in\n    guard let id = request.headers.headers[\"id\"]?.values else {\n        return JSON([\"message\": \"Please provide the id of todo item\"])\n    }\n\n    let todos = TodoStore.sharedInstance\n    todos.delete(id: Int(id[0])!)\n\n    return JSON([\"message\": \"Item is deleted\"])\n}\n\n/// Delete all items\napp.delete(\"deleteAll\") { request in\n    TodoStore.sharedInstance.deleteAll()\n\n    return JSON([\"message\": \"All items are deleted\"])\n}\n\n```", "```swift\ncurl -X \"DELETE\" \"http://localhost:8080/deleteTodo/\" \\\n   -H \"id: 1\" \\\n   -H \"Cookie: test=123\"\n\n```", "```swift\ncurl -X \"DELETE\" \"http://localhost:8080/deleteAll\" \\\n   -H \"Cookie: test=123\"\n\n```", "```swift\n/// Update a specific todo item\napp.post(\"updateTodo\") { request in\n    guard let id = request.headers.headers[\"id\"]?.values,\n        name = request.headers.headers[\"name\"]?.values,\n        description = request.headers.headers[\"description\"]?.values,\n        notes = request.headers.headers[\"notes\"]?.values,\n        completed = request.headers.headers[\"completed\"]?.values,\n        synced = request.headers.headers[\"synced\"]?.values\n    else {\n        return JSON([\"message\": \"Please include mandatory parameters\"])\n    }\n\n    let todoItem = Todo(id: Int(id[0])!,\n                      name: name[0],\n               description: description[0],\n                     notes: notes[0],\n                 completed: completed[0].toBool()!,\n                    synced: synced[0].toBool()!)\n\n    let todos = TodoStore.sharedInstance\n    todos.update(item: todoItem)\n    return JSON([\"message\": \"Item is updated\"])\n}\n\n```", "```swift\ncurl -X \"POST\" \"http://localhost:8080/updateTodo\" \\\n   -H \"Cookie: test=123\" \\\n   -H \"id: 3\" \\\n   -H \"notes: new note\" \\\n   -H \"name: updated name\" \\\n   -H \"description: updated description\" \\\n   -H \"completed : yes\"\n\n```", "```swift\nsudo gem install cocoapods\n\n```", "```swift\nmkdir Frontend\n\n```", "```swift\ncd Frontend/TodoApp\npod init\n\n```", "```swift\nplatform :ios, '8.0'\nuse_frameworks!\n\ntarget 'TodoApp' do\n\nend\n\n```", "```swift\nplatform :ios, '8.0'\nuse_frameworks!\n\ntarget 'TodoApp' do\n    pod 'Alamofire'\n    pod 'Argo'\n    pod 'Curry'\n    pod 'ReactiveCocoa'\n    pod 'Delta', :git => \"https://github.com/thoughtbot/Delta.git\"\nend\n\n```", "```swift\nPod install\n\n```", "```swift\nimport Argo\nimport Curry\n\nenum TodoFilter: Int {\n    case all\n    case active\n    case completed\n    case notSyncedWithBackend\n    case selected\n}\n\nstruct Todo {\n    let id: Int\n    let name: String\n    let description: String\n    let notes: String?\n    let completed: Bool\n    let synced: Bool\n    let selected: Bool?\n}\n\nextension Todo: Decodable {\n    static func decode(json: JSON) -> Decoded<Todo> {\n        return curry(Todo.init)\n        <^> json <| \"id\"\n        <*> json <| \"name\"\n        <*> json <| \"description\"\n        <*> json <|? \"notes\"\n        <*> json <| \"completed\"\n        <*> json <| \"synced\"\n        <*> json <|? \"selected\"\n    }\n}\n\nextension Todo: Equatable {}\n\nfunc == (lhs: Todo, rhs: Todo) -> Bool {\n    return lhs.id == rhs.id\n}\n\n```", "```swift\npublic func curry<A, B, C, D, E, F>(function: (A, B, C, D, E) -> F) -> A\n  -> B -> C -> D -> E -> F {\n    return { (`a`: A) -> B -> C -> D -> E -> F in { (`b`: B) -> C -> D -> E\n      -> F in { (`c`: C) -> D -> E -> F in { (`d`: D) -> E -> F in { (`e`:\n      E) -> F in function(`a`, `b`, `c`, `d`, `e`) } } } } }\n}\n\n```", "```swift\npublic func <^> <T, U>(@noescape f: T -> U, x: Decoded<T>) -> Decoded<U> {\n    return x.map(f)\n}\nfunc map<U>(@noescape f: T -> U) -> Decoded<U> {\n    switch self {\n        case let .Success(value): return .Success(f(value))\n        case let .Failure(error): return .Failure(error)\n    }\n}\n\n```", "```swift\npublic func <*> <T, U>(f: Decoded<T -> U>, x: Decoded<T>) -> Decoded<U> {\n    return x.apply(f)\n}\nfunc apply<U>(f: Decoded<T -> U>) -> Decoded<U> {\n    switch f {\n        case let .Success(function): return self.map(function)\n        case let .Failure(error): return .Failure(error)\n    }\n}\n\n```", "```swift\npublic func <| <A where A: Decodable, A == A.DecodedType>(json: JSON, keys:\n  [String]) -> Decoded<A> {\n    return flatReduce(keys, initial: json, combine: decodedJSON)\n      >>- A.decode\n}\n\n```", "```swift\npublic func <|? <A where A: Decodable, A == A.DecodedType>(json: JSON, key:\n  String) -> Decoded<A?> {\n    return .optional(json <| [key])\n}\n\n```", "```swift\npublic func <|| <A where A: Decodable, A == A.DecodedType>(json: JSON,\n  keys: [String]) -> Decoded<[A]> {\n    return flatReduce(keys, initial: json, combine: decodedJSON) >>-\n      Array<A>.decode\n}\n\n```", "```swift\nlet json: AnyObject? = try?NSJSONSerialization.JSONObjectWithData(data,\n  options: [])\n\nif let j: AnyObject = json {\n    let todo: Todo? = decode(j)\n}\n\n```", "```swift\nimport ReactiveCocoa\n\nstruct TodosViewModel {\n    let todos: [Todo]\n\n    func todoForIndexPath(indexPath: NSIndexPath) -> Todo {\n        return todos[indexPath.row]\n    }\n}\n\n```", "```swift\nstruct TodoViewModel {\n    let todo: Todo?\n}\n\n```", "```swift\nprotocol RequestProtocol {\n    subscript(key: String) -> (String?, String?) { get }\n}\n\nextension RequestProtocol {\n    func getPropertyNames()-> [String] {\n        return Mirror(reflecting: self).children.filter {\n$0.label !=\n          nil }.map\n        { $0.label! }}\n}\n\n```", "```swift\nstruct TodoRequest: RequestProtocol {\n\n    let id: Int\n    let name: String\n    let description: String\n    let notes: String\n    let completed: Bool\n    let synced: Bool\n\n    subscript(key: String) -> (String?, String?) {\n        get {\n            switch key {\n            case \"id\": return (String(id), \"id\")\n            case \"name\": return (name, \"name\")\n            case \"description\": return (description, \"description\")\n            case \"notes\": return (notes, \"notes\")\n            case \"completed\": return (String(completed), \"completed\")\n            case \"synced\": return (String(synced), \"synced\")\n            default: return (\"Cookie\",\"test=123\")\n            }\n        }\n    }\n}\n\n```", "```swift\nimport Alamofire\nfunc sendRequest(method: Alamofire.Method, request: RequestProtocol) {\n\n    // Add Headers\n    let headers = configureHeaders(request)\n\n    // Fetch Request\n    Alamofire.request(method, \"http://localhost:8080/todo/\",\n      headers: headers, encoding: .JSON)\n    .validate()\n    .responseJSON { response in\n        if (response.result.error == nil) {\n            debugPrint(\"HTTP Response Body: \\(response.data)\")\n        }\n        else {\n            debugPrint(\"HTTP Request failed: \\(response.result.error)\")\n        }\n    }\n}\n\nfunc configureHeaders(request: RequestProtocol) -> [String: String] {\n    let listOfProperties = request.getPropertyNames()\n    var configuredRequestHeaders = Dictionary<String, String>()\n    for property in listOfProperties {\n        let (propertyValue, propertyName) = request[property]\n        if propertyName != nil {\n            configuredRequestHeaders[propertyName!] = propertyValue\n        }\n    }\n    return configuredRequestHeaders\n}\n\n```", "```swift\nlet newRequest = TodoRequest(id: 1,\n                             name: \"First request\",\n                             description:\"description\",\n                             notes: \"notes\",\n                             completed: \"no\")\n    sendRequest(Alamofire.Method.POST, request: newRequest)\n\n```", "```swift\nfunc sendRequest(method: Alamofire.Method,\n                 request: RequestProtocol,\n                 completion:(responseData: AnyObject?, error: NSError?) -> Void) {\n\n    // Add Headers \n    let headers = configureHeaders(request) \n\n    // Fetch Request\n    Alamofire.request(method, \"http://localhost:8080/todo/\", \n      headers: headers, encoding: .JSON)\n        .validate() \n        .responseJSON { response in \n        if (response.result.error == nil) { \n            debugPrint(\"HTTP Response Body: \\(response.data)\") \n            completion(responseData: response.result.value, error: nil) \n        } \n        else { \n            debugPrint(\"HTTP Request failed: \\(response.result.error)\") \n            completion(responseData: nil, error: response.result.error) \n        } \n    } \n}\n\n```", "```swift\nlet newRequest = TodoRequest(id: 1,\n                             name: \"First request\",\n                             description:\"description\",\n                             notes: \"notes\", \n                             completed: \"no\")\nsendRequest(Alamofire.Method.POST, request: newRequest) {\n    (response, error) in\n    if error == nil {\n        let todos: [Todo]? = decode(response!)\n        print(\"request was successful: \\(todos)\")\n    } else {\n        print(\"Error\")\n    }\n}\n\n```", "```swift\nimport Alamofire\n\nenum Urls {\n    case postTodo\n    case getTodos\n    case getTodo\n    case deleteTodo\n    case deleteAll\n    case update\n}\n\nextension Urls {\n    func httpMethodUrl() -> (Alamofire.Method, String) {\n        let baseUrl = \"http://localhost:8080/\"\n        switch self {\n        case .postTodo:\n            return (.POST, \"\\(baseUrl)postTodo\")\n        case .getTodos:\n            return (.GET, \"\\(baseUrl)todos\")\n        case .getTodo:\n            return (.GET, \"\\(baseUrl)todo\")\n        case .deleteTodo:\n            return (.DELETE, \"\\(baseUrl)deleteTodo\")\n        case .deleteAll:\n            return (.DELETE, \"\\(baseUrl)deleteAll\")\n        case .update:\n            return (.POST, \"\\(baseUrl)updateTodo\")\n        }\n    }\n}\n\n```", "```swift\nimport Alamofire\n\nfunc sendRequest(url: Urls,\n             request: RequestProtocol,\n          completion: (responseData: AnyObject?,\n               error: NSError?) -> Void) {\n    // Add headers\n    let headers = configureHeaders(request)\n    // Get request method and full url\n    let (method, url) = url.httpMethodUrl()\n\n    // Fetch request\n    Alamofire.request(method, url, headers: headers, encoding: .JSON)\n    .validate()\n    .responseJSON { response in\n        if (response.result.error == nil) {\n            debugPrint(\"HTTP Response Body: \\(response.data)\")\n            completion(responseData: response.result.value, error: nil)\n        } else {\n            debugPrint(\"HTTP Request failed: \\(response.result.error)\")\n            completion(responseData: nil, error: response.result.error)\n        }\n    }\n}\n\n```", "```swift\nlet newRequest = TodoRequest(id: 1,\n                           name: \"First request\",\n                    description: \"description\",\n                          notes: \"notes\",\n                      completed: false)\n\nsendRequest(Urls.postTodo, request: newRequest) { (response, error) in\n    if error == nil {\n        let todos: [Todo]? = decode(response!)\n        print(\"request was successful: \\(todos)\")\n    } else {\n        print(\"Error\")\n    }\n}\n\n```", "```swift\nstruct RequestModel: RequestProtocol {\n\n    subscript(key: String) -> (String?, String?) {\n        get {\n            switch key {\n                default: return (\"Cookie\",\"test=123\")\n            }\n        }\n    }\n}\n\n```", "```swift\nsendRequest(Urls.getTodos, request: RequestModel()) { (response, error) in\n    if error == nil {\n        let todos: [Todo]? = decode(response!)\n        print(\"request was successful: \\(todos)\")\n    } else {\n        print(\"Error: \\(error?.localizedDescription)\")\n    }\n}\n\n```", "```swift\nimport Alamofire\nimport Argo\n\nfunc addTodo(completion:(responseData:[Todo]?, error: NSError?) -> Void) {\n    let newRequest = TodoRequest(id: 1,\n                               name: \"Saturday Grocery\",\n                        description: \"Bananas, Pineapple, Beer,\n                          Orange juice, ...\",\n                              notes: \"Cehck expiry date of orange juice\",\n                          completed: false,\n                             synced: true)\n\n    sendRequest(Urls.postTodo, request: newRequest) {\n        (response, error) in\n        if error == nil {\n            let todos: [Todo]? = decode(response!)\n            completion(responseData: todos, error: nil)\n            print(\"request was successfull: \\(todos)\")\n        } else {\n            completion(responseData: nil, error: error)\n            print(\"Error: \\(error?.localizedDescription)\")\n        }\n    }\n}\n\nfunc listTodos(completion:(responseData:[Todo]?, error: NSError?) -> Void) {\n    sendRequest(Urls.getTodos, request: RequestModel()) {\n        (response, error) in\n        if error == nil {\n            let todos: [Todo]? = decode(response!)\n            completion(responseData: todos, error: nil)\n            print(\"request was successfull: \\(todos)\")\n        } else {\n            completion(responseData: nil, error: error)\n            print(\"Error: \\(error?.localizedDescription)\")\n        }\n    }\n}\n\n```", "```swift\nfunc addOrUpdateTodo(todo: [Todo]?, completion:(responseData:[Todo]?, error: NSError?) -> Void) {\n    if let todoItem = todo?.first {\n        let newRequest = TodoRequest(id: todoItem.id,\n                                   name: todoItem.name,\n                            description: todoItem.description,\n                                  notes: todoItem.notes!,\n                              completed: todoItem.completed,\n                                 synced: true)\n\n        sendRequest(Urls.postTodo, request: newRequest) {\n            (response, error) in\n            if error == nil {\n                let todos: [Todo]? = decode(response!)\n                let newTodo = todoSyncedLens.set(true, todoItem)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n                completion(responseData: todos, error: nil)\n                print(\"request was successfull: \\(todos)\")\n            } else {\n                completion(responseData: nil, error: error)\n                print(\"Error: \\(error?.localizedDescription)\")\n            }\n        }\n    }\n}\n\nfunc updateTodo(todo: [Todo]?, completion:(responseData:[Todo]?,\n  error: NSError?) -> Void) {\n    if let todoItem = todo?.first {\n        let newRequest = TodoRequest(id: todoItem.id,\n                                   name: todoItem.name,\n                            description: todoItem.description,\n                                  notes: todoItem.notes!,\n                              completed: todoItem.completed,\n                                 synced: true)\n\n        sendRequest(Urls.update, request: newRequest) {\n            (response, error) in\n            if error == nil {\n                let todos: [Todo]? = decode(response!)\n                let newTodo = todoSyncedLens.set(true, todoItem)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n                completion(responseData: todos, error: nil)\n                print(\"request was successfull: \\(todos)\")\n            } else {   \n                completion(responseData: nil, error: error)\n                print(\"Error: \\(error?.localizedDescription)\")\n            }\n        }\n    }\n}\n\n```", "```swift\nstruct Lens<Whole, Part> {\n    let get: Whole -> Part\n    let set: (Part, Whole) -> Whole\n}\n\nlet todoNameLens: Lens<Todo, String> = Lens(\n    get: { $0.name},\n    set: {\n        Todo(id: $1.id,\n           name: $0,\n    description: $1.description,\n          notes: $1.notes,\n      completed: $1.completed,\n         synced: $1.synced,\n       selected: $1.selected)\n})\n\nlet todoDescriptionLens: Lens<Todo, String> = Lens(\n    get: { $0.description},\n    set: {\n        Todo(id: $1.id,\n           name: $1.name,\n    description: $0,\n          notes: $1.notes,\n      completed: $1.completed,\n         synced: $1.synced,\n       selected: $1.selected)\n})\n\nlet todoNotesLens: Lens<Todo, String> = Lens(\n    get: { $0.notes!},\n    set: {\n        Todo(id: $1.id,\n           name: $1.name,\n    description: $1.description,\n          notes: $0,\n      completed: $1.completed,\n         synced: $1.synced,\n       selected: $1.selected)\n})\n\nlet todoCompletedLens: Lens<Todo, Bool> = Lens(\n    get: { $0.completed},\n    set: {\n        Todo(id: $1.id,\n           name: $1.name,\n    description: $1.description,\n          notes: $1.notes,\n      completed: $0,\n         synced: $1.synced,\n       selected: $1.selected)\n})\n\nlet todoSyncedLens: Lens<Todo, Bool> = Lens(\n    get: { $0.synced},\n    set: {\n        Todo(id: $1.id,\n           name: $1.name,\n    description: $1.description,\n          notes: $1.notes,\n      completed: $1.completed,\n         synced: $0,\n       selected: $1.selected)\n})\n\n```", "```swift\nimport ReactiveCocoa\nimport Delta\n\nextension MutableProperty: Delta.ObservablePropertyType {\n    public typealias ValueType = Value\n}\n\n```", "```swift\nimport ReactiveCocoa\n\nprivate let initialTodos: [Todo] = []\n\nstruct State {\n    let todos = MutableProperty(initialTodos)\n    let filter = MutableProperty(TodoFilter.all)\n    let notSynced = MutableProperty(TodoFilter.notSyncedWithBackend)\n    let selectedTodoItem = MutableProperty(TodoFilter.selected)\n}\n\n```", "```swift\nimport ReactiveCocoa\nimport Delta\n\nstruct Store: StoreType {\n    var state: MutableProperty<State>\n\n    init(state: State) {\n        self.state = MutableProperty(state)\n    }\n}\n\nvar store = Store(state: State())\n\n```", "```swift\nimport ReactiveCocoa\nimport Result\n\n// MARK: Properties\nextension Store {\n    var todos: MutableProperty<[Todo]> {\n        return state.value.todos\n    }\n\n    var activeFilter: MutableProperty<TodoFilter> {\n        return state.value.filter\n    }\n\n    var selectedTodoItem: MutableProperty<TodoFilter> {\n        return state.value.selectedTodoItem\n    }\n\n}\n\n// MARK: SignalProducers\nextension Store {\n    var activeTodos: SignalProducer<[Todo], NoError> {\n        return activeFilter.producer.flatMap(.Latest) {\n            filter -> SignalProducer<[Todo], NoError> in\n                switch filter {\n                case .all: return self.todos.producer\n                case .active: return self.incompleteTodos\n                case .completed: return self.completedTodos\n                case .notSyncedWithBackend: return\n                  self.notSyncedWithBackend\n                case .selected: return self.selectedTodo\n            }\n        }\n    }\n\n    var completedTodos: SignalProducer<[Todo], NoError> {\n        return todos.producer.map {\n            todos in\n            return todos.filter { $0.completed }\n        }\n    }\n\n    var incompleteTodos: SignalProducer<[Todo], NoError> {\n        return todos.producer.map {\n            todos in\n            return todos.filter { !$0.completed }\n        }\n    }\n\n    var incompleteTodosCount: SignalProducer<Int, NoError> {\n        return incompleteTodos.map { $0.count }\n    }\n\n    var allTodosCount: SignalProducer<Int, NoError> {\n        return todos.producer.map { $0.count }\n    }\n\n    var todoStats: SignalProducer<(Int, Int), NoError> {\n        return allTodosCount.zipWith(incompleteTodosCount)\n    }\n\n    var notSyncedWithBackend: SignalProducer<[Todo], NoError> {\n        return todos.producer.map {\n            todos in\n            return todos.filter { !$0.synced }\n        }\n    }\n\n    var selectedTodo: SignalProducer<[Todo], NoError> {\n        return todos.producer.map {\n            todos in\n            return todos.filter {\n                todo in\n                if let selected = todo.selected {\n                    return selected\n                } else {\n                    return false\n                }\n            }\n        }\n    }\n\n    func producerForTodo(todo: Todo) -> SignalProducer<Todo, NoError> {\n        return store.todos.producer.map {\n            todos in\n            return todos.filter { $0 == todo }.first\n        }.ignoreNil()\n    }\n}\n\n```", "```swift\nimport Delta\n\nstruct UpdateTodoAction: ActionType {\n    let todo: Todo\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value.map {\n            todo in\n            guard todo == self.todo else { return todo }\n\n            return Todo(id: todo.id,\n                      name: self.todo.name,\n               description: self.todo.description,\n                     notes: self.todo.notes,\n                 completed: self.todo.completed,\n                    synced: !todo.synced,\n                  selected: todo.selected)\n        }\n\n        return state\n    }\n}\n\n```", "```swift\nstore.dispatch(UpdateTodoAction(todo: newTodo))\n\n```", "```swift\nimport Delta\n\nstruct ClearCompletedTodosAction: DynamicActionType {\n    func call() {\n        let todos = store.completedTodos.first()?.value ?? []\n\n        todos.forEach { todo in\n            store.dispatch(DeleteTodoAction(todo: todo))\n        }\n    }\n}\n\nstruct CreateTodoAction: ActionType {\n    let id: Int\n    let name: String\n    let description: String\n    let notes: String\n\n    var todo: Todo {\n        return Todo(id: id,\n                  name: name,\n           description: description,\n                 notes: notes,\n             completed: false,\n                synced: false,\n              selected: false)\n    }\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value + [todo]\n\n        return state\n    }\n}\n\nstruct DeleteTodoAction: ActionType {\n    let todo: Todo\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value.filter { $0 != self.todo }\n\n        return state\n    }\n}\n\nstruct DetailsTodoAction: ActionType {\n    let todo: Todo\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value.map { todo in\n            guard todo == self.todo else {\n\n                return Todo(id: todo.id,\n                          name: todo.name,\n                   description: todo.description,\n                         notes: todo.notes,\n                     completed: todo.completed,\n                        synced: todo.synced,\n                      selected: false)\n            }\n\n            return Todo(id: self.todo.id,\n                      name: self.todo.name,\n               description: self.todo.description,\n                     notes: self.todo.notes,\n                 completed: self.todo.completed,\n                    synced: self.todo.synced,\n                  selected: true)\n        }\n\n        return state\n    }\n}\n\nstruct LoadTodosAction: ActionType {\n    let todos: [Todo]\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value + todos\n        return state\n    }\n}\n\nstruct SetFilterAction: ActionType {\n    let filter: TodoFilter\n\n    func reduce(state: State) -> State {\n        state.filter.value = filter\n        return state\n    }\n}\n\nstruct ToggleCompletedAction: ActionType {\n    let todo: Todo\n\n    func reduce(state: State) -> State {\n        state.todos.value = state.todos.value.map {\n            todo in\n            guard todo == self.todo else { return todo }\n\n            return Todo(id: todo.id,\n                      name: todo.name,\n               description: todo.description,\n                     notes: todo.notes,\n                 completed: !todo.completed,\n                    synced: !todo.synced,\n                  selected: todo.selected)\n        }\n\n        return state\n    }\n}\n\n```", "```swift\nclass TodoTableViewCell: UITableViewCell {\n\n    var todo: Todo? {\n        didSet {\n            updateUI()\n        }\n    }\n\n    var attributedText: NSAttributedString {\n        guard let todo = todo else { return NSAttributedString() }\n\n        let attributes: [String : AnyObject]\n        if todo.completed {\n            attributes = [NSStrikethroughStyleAttributeName:\n              NSUnderlineStyle.StyleSingle.rawValue]\n        } else {\n            attributes = [:]\n        }\n\n        return NSAttributedString(string: todo.name,\n          attributes: attributes)\n    }\n\n    override func setSelected(selected: Bool, animated: Bool) {\n        super.setSelected(selected, animated: animated)\n    }\n\n    func configure(todo: Todo) {\n        store.producerForTodo(todo).startWithNext { nextTodo in\n            self.todo = nextTodo\n        }\n    }\n\n    func updateUI() {\n        guard let todo = todo else { return }\n\n        textLabel?.attributedText = attributedText\n        accessoryType = todo.completed ? .Checkmark : .None\n    }\n\n}\n\n```", "```swift\nimport UIKit\n\nclass MasterViewController: UITableViewController {\n\n    @IBOutlet weak var filterSegmentedControl: UISegmentedControl!\n\n    var viewModel = TodosViewModel(todos: []) {\n        didSet {\n            tableView.reloadData()\n        }\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        listTodos() {\n            (response, error) in\n            if error == nil {\n                store.dispatch(LoadTodosAction(todos: response!))\n            } else {\n                print(\"Error: \\(error?.localizedDescription)\")\n            }\n        }\n\n        filterSegmentedControl.addTarget(self, action:\n          #selector(ViewController.filterValueChanged),\n          forControlEvents: .ValueChanged)\n\n        store.activeFilter.producer.startWithNext {\n            filter in\n            self.filterSegmentedControl.selectedSegmentIndex =\n              filter.rawValue\n        }\n\n        store.activeTodos.startWithNext {\n            todos in\n            self.viewModel = TodosViewModel(todos: todos)\n        }\n\n        store.notSyncedWithBackend.startWithNext {\n            todos in\n            addOrUpdateTodo(todos) { (response, error) in\n                if error == nil {\n                    print(\"Success\")\n                } else {\n                    print(\"Error: \\(error?.localizedDescription)\")\n                }\n            }\n        }\n    }\n}\n\n```", "```swift\n// MARK: Actions\nextension MasterViewController {\n    @IBAction func addTapped(sender: UIBarButtonItem) {\n        let alertController = UIAlertController(\n          title: \"Create\",\n        message: \"Create a new todo item\",\n preferredStyle: .Alert)\n\n    alertController.addTextFieldWithConfigurationHandler() {\n        textField in\n        textField.placeholder = \"Id\"\n    }\n\n    alertController.addTextFieldWithConfigurationHandler() {\n        textField in\n        textField.placeholder = \"Name\"\n    }\n\n    alertController.addTextFieldWithConfigurationHandler() {\n        textField in\n        textField.placeholder = \"Description\"\n    }\n\n    alertController.addTextFieldWithConfigurationHandler() {\n        textField in\n        textField.placeholder = \"Notes\"\n    }\n\n    alertController.addAction(UIAlertAction(title: \"Cancel\",\n      style: .Cancel) { _ in })\n\n    alertController.addAction(UIAlertAction(title: \"Create\",\n      style: .Default) { _ in\n        guard let id = alertController.textFields?[0].text,\n        name = alertController.textFields?[1].text,\n        description = alertController.textFields?[2].text,\n        notes = alertController.textFields?[3].text\n        else { return }\n\n        store.dispatch(CreateTodoAction(\n          id: Int(id)!,\n        name: name,\n description: description,\n       notes: notes))\n        })\n        presentViewController(alertController, animated: false,\n          completion: nil)\n    }\n\n    func filterValueChanged() {\n        guard let newFilter = TodoFilter(rawValue:\n          filterSegmentedControl.selectedSegmentIndex)\n        else { return }\n\n        store.dispatch(SetFilterAction(filter: newFilter))\n    }\n}\n\n```", "```swift\n// MARK: UITableViewController\nextension MasterViewController {\n    override func tableView(tableView: UITableView,\n      numberOfRowsInSection section: Int) -> Int {\n        return viewModel.todos.count\n    }\n\n    override func tableView(tableView: UITableView, cellForRowAtIndexPath\n      indexPath: NSIndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCellWithIdentifier(\"todoCell\",\n          forIndexPath: indexPath) as! TodoTableViewCell\n        let todo = viewModel.todoForIndexPath(indexPath)\n\n        cell.configure(todo)\n\n        return cell\n    }\n\n    override func tableView(tableView: UITableView, didSelectRowAtIndexPath\n      indexPath: NSIndexPath) {\n        let todo = viewModel.todoForIndexPath(indexPath)\n        store.dispatch(ToggleCompletedAction(todo: todo))\n        tableView.deselectRowAtIndexPath(indexPath, animated: true)\n    }\n\n    override func tableView(tableView: UITableView, commitEditingStyle\n      editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath\n      indexPath: NSIndexPath) {\n\n    }\n\n    override func tableView(tableView: UITableView,\n      editActionsForRowAtIndexPath indexPath: NSIndexPath)\n      -> [UITableViewRowAction]? {\n        let delete = UITableViewRowAction(style: .Normal, title: \"Delete\")\n          { action, index in\n            let todo = self.viewModel.todoForIndexPath(indexPath)\n            store.dispatch(DeleteTodoAction(todo: todo))\n        }\n        delete.backgroundColor = UIColor.redColor()\n\n        let details = UITableViewRowAction(style: .Normal,\n          title: \"Details\") { action, index in\n            let todo = self.viewModel.todoForIndexPath(indexPath)\n            store.dispatch(DetailsTodoAction(todo: todo))\n\n            self.performSegueWithIdentifier(\"segueShowDetails\",\n              sender: self)\n        }\n        details.backgroundColor = UIColor.orangeColor()\n\n        return [details, delete]\n    }\n\n    override func tableView(tableView: UITableView, canEditRowAtIndexPath\n      indexPath: NSIndexPath) -> Bool {\n        // the cells you would like the actions to appear need to\n          be editable\n        return true\n    }\n}\n\n```", "```swift\nimport UIKit\nimport ReactiveCocoa\n\nclass DetailsViewController: UIViewController {\n\n    @IBOutlet weak var txtFieldName: UITextField!\n    @IBOutlet weak var txtFieldDescription: UITextField!\n    @IBOutlet weak var txtFieldNotes: UITextField!\n    @IBOutlet weak var switchCompleted: UISwitch!\n\n    var viewModel = TodoViewModel(todo: nil)\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        store.selectedTodo.startWithNext { todos in\n            let model = todos.first!\n            self.txtFieldName.text = model.name\n            self.txtFieldDescription.text = model.description\n            self.txtFieldNotes.text = model.notes\n            self.switchCompleted.on = model.completed\n            self.viewModel = TodoViewModel(todo: model)\n        }\n        setupUpdateSignals()\n    }\n\n    func setupUpdateSignals() {\n        txtFieldName.rac_textSignal().subscribeNext {\n            (next: AnyObject!) -> () in\n            if let newName = next as? String {\n                let newTodo = todoNameLens.set(newName,\n                  self.viewModel.todo!)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n            }\n        }\n\n        txtFieldDescription.rac_textSignal().subscribeNext {\n            (next: AnyObject!) -> () in\n            if let newDescription = next as? String {\n                let newTodo = todoDescriptionLens.set(newDescription,\n                  self.viewModel.todo!)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n            }\n        }\n\n        txtFieldNotes.rac_textSignal().subscribeNext {\n            (next: AnyObject!) -> () in\n            if let newNotes = next as? String {\n                let newTodo = todoNotesLens.set(newNotes,\n                  self.viewModel.todo!)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n\n            }\n        }\n\n        switchCompleted.rac_newOnChannel().subscribeNext {\n            (next: AnyObject!) -> () in\n            if let newCompleted = next as? Bool {\n                let newTodo = todoCompletedLens.set(newCompleted,\n                  self.viewModel.todo!)\n                store.dispatch(UpdateTodoAction(todo: newTodo))\n\n            }\n        }\n    }\n}\n\n```"]