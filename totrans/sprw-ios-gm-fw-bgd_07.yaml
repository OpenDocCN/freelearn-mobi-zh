- en: Chapter 7. User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about adding the first gameplay elements
    into our game. Our pirate ship can now shoot cannonballs, and if the cannonballs
    hit the enemy enough number of times, the enemy ship will be destroyed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to add user interface elements. Specifically,
    we will improve our game in the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Display and update the health of each ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display text on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start by adding a visual representation for hit points on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the hit points of each ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, each ship has 100 hit points, and each cannonball does 25 points
    of damage to those hit points. We do have some visual feedback when a cannonball
    hits a ship, but we don't know how many hit points a ship has once hit a few times.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – placing a health bar on top of each ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display the hit points for each ship, we just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our game's project file if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance variable called `_quadHitpoints`, which is a pointer to `SPQuad`,
    as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Switch to the `Ship.m` file. Just after where we create the cannonball images
    in the initializer, we add a quad which should be the border for our hit point
    representation, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the background for the hit points box, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the background for the hit points box to have a one point margin, which
    means its position needs to be one point to the left and one point up from the
    local coordinate system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create `SPQuad` from the `_quadHitpoints` instance variable, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in the following code, we set the hit points to the same coordinates
    as the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add all of the hit point quads to the display tree, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `setHitpoints` method, add the following line of code just after
    the statement where we set the instance variable to the value of the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As seen in the following screenshot, both ships now have the amount of their
    hit points represented as red and green bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – placing a health bar on top of each ship](img/1509OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened our Xcode template from where we had left off in the previous
    chapter. First of all, we need an instance variable that should represent our
    hit points. If we think about how other games display the current hit points,
    in strategy games mostly, the hit points are represented as little green and red
    bars above each unit. In fighting games, the hit points are displayed at the top
    left- and right-hand sides for each player. As we might have more than one enemy
    on the screen, the best representation will be to have red and green bars above
    each of the ship. The green portion of the bar would be the amount of hit points
    the ship currently has and the red portion is the amount that is currently missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 2, we switched to the `Ship.h` file as we wanted to define an instance
    variable. To represent the hit points, we chose `SPQuad` and called our variable
    `_quadHitpoints`. To actually implement the hit point mechanics, we switched to
    the `Ship.m` file. Our hit points bar actually consists of three different boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: A border around the hit points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background for the hit points (a red bar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual hit point bar (a green bar which is represented by our `_quadHitpoints`
    instance variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 5, we defined a black rectangle that will act as the border for our
    hit point bar. The width of the rectangle should be the width of the ship. We
    got the width from the `clipNorth` movie clip. Actually, we can also get the ship's
    width from any other movie clips. We set the height of the black rectangle to
    five points. We don't want the hit points bar to be too thick, but it has to be
    easily visible and recognizable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we set the background of the hit points. We defined a `SPQuad`
    instance, which we call `quadMaxHitpoints`. It should be one point smaller than
    the black rectangle on each side. We used the width from the `hitpointsBorder`
    instance and had set the height to three points.
  prefs: []
  type: TYPE_NORMAL
- en: We set the left and the top of the `quadMaxHitpoints` instance to one point
    each so that it will actually look as if the hit point bar has a border.
  prefs: []
  type: TYPE_NORMAL
- en: We then initialized the `quadHitpoints` instance variable in step 8\. It's a
    `SPQuad` class as well and has the same dimensions as our background hit point
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: With the `quadMaxHitpoints` instance, we want `_quadHitpoints` to be displayed
    inside the border. So, we set the position of`_quadHitpoints` one point to the
    left and top relative to the ship itself. In this case, we can adjust the position
    from the `quadMaxHitpoints` quad.
  prefs: []
  type: TYPE_NORMAL
- en: For the red and green rectangles, we refrained from using bright colors, as
    this might strain the eyes and distract us from the action. Also, as we are going
    for a darker tone in general, having bright colors would not fit in this context.
    Keep in mind when coloring and designing the user interface that the elements
    should be tested on the actual device. The brightness is usually not at its maximum,
    especially if the device is running on battery. In some cases, graphics are even
    given additional contrast or are brightened so that they don't look too dark on
    mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: In step 10, we added all of the quads to the display tree; all of the quads
    are children of the `Ship` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this point, our code snippet will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we were to use the hit points' creation code more than once, it is considered
    a best practice to put this piece of code into a separate method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we updated the hit points setter. The `_quadHitpoints` instance
    will be scaled horizontally. As both `_hitpoints` and `self.maxHitpoints` are
    integer values, we needed to cast it to a float value. If we don't do this, the
    hit points bar would either be red or green with nothing in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setHitpoints` method will look like the following piece of code after
    step 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We ran the example in the last step and saw that the enemy ship as well as our
    ship have hit point bars on top of them. When the ships moved, the hit point bars
    also moved with them, and when we hit the enemy ship, the hit points bar updated
    itself accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have hit point bars on the screen, let's add some things that the
    user can actually interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and resuming the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we are going to add is the ability to pause and resume the game
    at will. This is actually quite important, especially for mobile action games.
    If a call comes on the mobile device (iPhone) and we don't have a pause functionality,
    the player might get frustrated by not being able to pause the game and lose their
    progress or winning streak.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into implementing these buttons, let's download the necessary
    graphics for this chapter which are available at [https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.7/Graphics_07.zip).
    Copy the contents of the extracted file into the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think of what we need to do when pausing the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Display a button to pause the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a button to resume the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop all current tweens when the player clicks on the pause button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resume all current tweens when the player clicks on the resume button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this is a bigger task, we are splitting it into two parts; first, we are
    going to display the buttons, and then we will implement the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the pause and resume buttons on the screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we are going to add all of the buttons we need and will display
    them at the correct position on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting buttons on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add our first buttons, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Battlefield.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add one instance variable for each button. We will use the `SPButton` type,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct the instances for our two instance variables, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the position of both the pause and resume buttons to the top-right corner
    of the screen using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hide the resume button using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For later usage, create methods to tap the pause and resume buttons, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bind the newly created methods to the pause and resume buttons, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add both buttons to the display tree as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result. We now have a pause button on the screen,
    as shown in the following screenshot:![Time for action – putting buttons on the
    screen](img/1509OS_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened the `Battlefield.h` file. We added two instance variables
    to this class, one for the pause button and one for the resume button. We used
    the `SPButton` class, which is pretty much an image, and optionally displayed
    some text on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we switched to the `Battlefield.m` file. In step 4, we initialized both
    buttons. We need to take a closer look at the following two points:'
  prefs: []
  type: TYPE_NORMAL
- en: We already know that we can get an array of textures if we use the `texturesStartingWith`
    method. If we want only a single texture, we need to use `textureByName`, and
    we also have to specify the correct name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPButton` provides several factory methods. The one we are using is the `buttonWithUpState`
    method in which we have to pass an `SPTexture` instance. The up state is the texture
    that is visible all the time. If we were to specify a down state, the down state
    would be visible once the button is tapped. Another factory method lets us specify
    either the down state or even some text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next step, we positioned the buttons at the top-right of the screen.
    We left a bit of space (four points) so that the button is not too close to the
    edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we hid the resume button so that we only see the pause button the
    first time the scene is being shown.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we added some dummy methods to pause and resume the game.
    We left these empty for now, but we'll fill them in a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we linked these methods to the buttons so that they will be called when
    we touch these buttons.
  prefs: []
  type: TYPE_NORMAL
- en: To actually show the buttons on the screen, we need to add them to the display
    tree, which we did in step 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what exactly changed in the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we ran the example, we saw the pause button in the top-right corner
    of the screen. When we tap the button, nothing happens except for the button scaling
    down a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the logic to pause and resume the game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have displayed the buttons on the screen, let's allow the player
    to pause and resume the game. We are going to utilize our own juggler and, save
    if the game is paused into a variable and if the game is not paused, we advance
    our juggler as well as the child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – allowing the player to pause and resume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow the player to pause and resume the game, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance variable called `_juggler` that is a pointer to `SPJuggler`,
    as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a property called `paused`, which is of the type `BOOL`, as shown in
    the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a method called `advanceTime`, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Ship.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the initializer, set the `paused` property to `NO` using its instance
    variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the `_juggler` instance variable inside the initializer with the
    following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update all references from `Sparrow.juggler` to `_juggler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `advanceTime` method with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Battlefield.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance variable for `juggler` here as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance variable for the background using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a property called `paused` which is a `BOOL` type. As we are going to add
    custom getters and setters for this property, we also need an instance variable
    called `_paused` as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the initializer, update the reference from the local background variable
    to the `_background` instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Battlefield` initializer, initialize the `_juggler` instance. This
    has to be done before we add `shipTween` to `juggler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update all references from `Sparrow.juggler` to `_juggler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a custom setter for the `paused` property with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a custom getter for the `paused` property that returns the `_paused` instance
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `onButtonPause` and `onButtonResume` methods by setting the `paused`
    property to its correct values (`YES` in the `onButtonPause` method, `NO` in the
    `onButtonResume` method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the parameter type in `onEnterFrame` from being a pointer to `SPEvent`
    to being a pointer to `SPEnterFrameEvent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to the `onEnterFrame` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now tap the pause and resume buttons. In the following screenshot, you
    can see that when the game is paused, all animations stop until we press the resume
    button:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – allowing the player to pause and resume](img/1509OS_07_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Ship.h` file, we updated the interface by performing the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Added a new `juggler` instance variable, which is a pointer to `SPJuggler` (step
    2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `paused` property with the type `BOOL` (step 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declared a method called `advanceTime` (step 4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparrow does not provide the pause and resume methods for its jugglers. We dealt
    with this by introducing our own jugglers and setting a flag if the game is paused,
    and we advanced all of our jugglers only if the game was not paused.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we switched to the `Ship.m` file and we defined the `paused` property
    inside the initializer to `NO`, because by default, the ships should not be paused.
    This step is not necessary as Objective-C initializes this instance as `NO`; it's
    just a reminder to see which instance variables we have if we were to decide to
    change a value later on, and we know where to look.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we initialized the `_juggler` instance variable. It does not
    matter where exactly we defined the juggler instance variable inside the initializer
    as we don't add any tweens to jugglers in the initializer method. Next, we searched
    and replaced all references from `Sparrow.juggler` to `_juggler`. The easiest
    way is to use *command* + *F*, select **Replace** from the drop-down list, put
    `Sparrow.juggler` in the first input box, `_juggler` in the second input, and
    select **All** to replace all the references.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we implemented the `advanceTime` method, where we call the `advanceTime`
    method from `_juggler` and pass in `double` as the `seconds` parameter. This is
    only called if the `paused` property is set to `NO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we switched to the `Battlefield.h` file. Here, we needed to perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance variable for a juggler, similar to how we did for the `Ship`
    class (step 11).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now need an instance variable that references the background image instance
    (step 12).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a `paused` property. As we are going to implement custom getters and
    setters, we also need an instance variable corresponding to that property (step
    13).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we switched to the `Battlefield.m` file. In the next step, we updated
    all references from the local background variable to the instance variable `_background`.
  prefs: []
  type: TYPE_NORMAL
- en: In step 16, we initialized our `_juggler` instance variable. Here, it does matter
    where we initialize this instance; it should be right before the line `[Sparrow.juggler
    addObject:shipTween];`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we updated the references to use `_juggler` instead of `Sparrow.juggler`
    inside the battlefield scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we defined the setter for the `paused` property. Let''s take a closer
    look at what exactly happened:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the `_paused` instance variable to the value of the parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `_paused` is set to `YES`, `_buttonPause` is not visible and `_buttonResume`
    is visible. If `_paused` is set to `NO`, it's the other way round.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each sprite has a `touchable` property. If this is set to `NO`, touch handlers
    won't fire. We set this to `NO` so the game can be paused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We paused all ships on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In step 19, we defined the getter for the `paused` property. It just returned
    the `_paused` instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then implemented the `onButtonPause` and `onButtonResume` methods, where
    we set the `paused` property to `YES` and `NO`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In step 21, we needed to update the parameter type in our `onEnterFrame` method.
    It needs to be a pointer to `SPEnterFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we added some lines of code to the `onEnterFrame` method. Now that the
    event is a pointer to `SPEnterFrame`, we can actually get the time that has been
    passed by getting the `passedTime` property from the event parameter. We then
    called the `advanceTime` method from all the ships on the screen, and if the scene
    is paused, we call the `advanceTime` method from `_juggler`.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we can now pause and resume the game at will.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some suggestions of what we could improve:'
  prefs: []
  type: TYPE_NORMAL
- en: As there isn't much happening in the `onButtonPause` and `onButtonResume` methods,
    we could either try to use blocks or merge both methods into one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could extend the `Scene` class to use a `juggler` instance variable, so we
    don't need to redefine a custom juggler wherever we need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, we have custom user interface elements for each scene. However, if
    this were to change, we should think about abstracting the user interface logic
    into a separate class and maybe bind it to the `Scene` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aborting the current game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we don't have the ability to switch to the pirate cove scene. However,
    we should introduce the option to abort the current fight.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – conceding the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To abort the current game, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the initializer, we should add the abort button right after the resume
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Position the abort button in the bottom-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `SceneDirector` class, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a listener to the abort button using a block, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the button to the display tree, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now see the abort button as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – conceding the game](img/1509OS_07_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened the `Battlefield.m` file. For this example, we only need
    to take a look at the initializer method. We initialized the abort button similar
    to how we did for the pause and resume buttons before, the only difference is
    that we are using a different texture.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we positioned the abort button at the bottom-right corner.
    Just like how we left a bit of space with the pause and resume buttons, we did
    the same here.
  prefs: []
  type: TYPE_NORMAL
- en: We then imported the `SceneDirector.h` file in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: In step 5, we added an event listener to the abort button. Inside the event
    listener, we switched to the pirate cove scene. Although we do have a reference
    to the scene director using the `director` property, it is of the type `id`. So,
    we needed to recast it to a pointer to the `SceneDirector` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we added the abort button to the display tree.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we saw the abort button, and when we tapped it, we
    jumped to the pirate cove scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dialogs to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added the abort button on the screen, we might run into a
    few problems, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We might tap on the abort button by accident
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have any way to get from the pirate cove scene back to the battlefield
    scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, to counteract this, at least on the surface, let's add a dialog which should
    be shown when we tap the abort button.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a dialog class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add dialogs, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new group inside the **Classes** folder called **UI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the **UI** group, add a new Objective-C class called `Dialog`, which
    derives from `SPSprite`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the dialog initializer with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Dialog.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right before the abort button event, initialize the dialog, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The dialog should be hidden by default, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the abort button event to show the dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we tap the abort button, we now see a dialog popping up:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – creating a dialog class](img/1509OS_07_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we structured the `Dialog` class. To keep it separate from the game logic
    code, we created it within a new group. The `Dialog` class itself should inherit
    from `SPSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 3, we defined the initializer for the `Dialog` class, where we performed
    the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We added a background image for the dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the **Yes** and **No** buttons. We called the factory methods for `SPButton`,
    where we put some text on the buttons, which in our case is **Yes** and **No**,
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We positioned these elements at the bottom of the dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `Battlefield.m` file, we imported the `Dialog.h` file to be able
    to use the `Dialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the initializer of the battlefield scene, we needed to initialize the
    dialog, which we did right before the abort button event.
  prefs: []
  type: TYPE_NORMAL
- en: We set the dialog to be invisible by default and updated the abort button event
    to show the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we saw the dialog when we tapped the abort button.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the abort button on the bottom-right of the screen is not ideal from
    a usability point of view. If we accidently tapped the button, a dialog is now
    being shown instead of just aborting the current battle. Still, it doesn''t seem
    to be ideal. The following are some suggestions on how to improve the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the abort button (`buttonAbort`) next to the pause button. All user
    interface elements would be in the same area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine the pause button and the abort button into a game menu button. Clicking
    on the button will pause the game and will open a menu. An abort button can be
    found there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom events to the dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that a dialog is on the screen, we would like to attach listeners to the
    dialog buttons themselves. While we can go for simply attaching touch events,
    Sparrow provides a way to define custom events.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding our own buttons to our dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add custom events for our dialogs, we just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Dialog.h` file, we need to define the event names before the interface
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to `Dialog.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register the following listeners to our buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `onButtonYes` and `onButtonNo` methods, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to `Battlefield.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local dialog variable inside the initializer needs to be refactored into
    an instance variable called `_dialogAbort`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `#import "Dialog.h"` statement from `Battlefield.m` to `Battlefield.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add event listeners for both dialog buttons in `Battlefield.m`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the corresponding methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the abort button event to also pause the game when the dialog is being
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result. When we tap the abort button, we can now
    tap the buttons of the dialog:![Time for action – adding our own buttons to our
    dialog](img/1509OS_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we defined the event names for our buttons. In the `Dialog.m`
    file, we needed to add listeners for our dialog. We used `SP_EVENT_TYPE_TRIGGERED`,
    so if any kind of event is triggered on either of the buttons, the selector will
    be called.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, we implemented the necessary methods. We created an event with our
    custom event type and dispatched this event afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we refactored the local dialog variable in the battlefield
    initializer. It now needs to be an instance variable called `_dialogAbort` and
    it is still a pointer to `Dialog`. We updated all references and the initialization
    part of the instance variable. Consequently, we imported a statement to the header
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We then called the `addEventListener` method on our dialog using our custom
    events.
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we implemented the methods that should be fired when the button is
    tapped. If we select **Yes**, we need to show the pirate cove scene, and if we
    select **No**, we need the dialog to disappear. We also resume the game in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: As we resume the game if we tap **Yes**, we also need to update the abort button
    event to actually pause the game once the dialog is being shown.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example and tapped the abort button, our dialog pops up and
    the game pauses. If we tap **No**, the dialog closes and the game resumes. If
    we tap **Yes**, we shift to the pirate cove scene.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text on the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to display text on the screen. We can either use one of the
    iOS fonts (so-called system fonts) or we could try to create a more customized
    font that fits our needs better.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying our first text field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already drew some text on the screen utilizing the capabilities of `SPButton`
    when we added the dialog buttons. However, we are now going to draw some text
    on the screen for the dialog message.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a text field to the dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To draw text on the screen, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following line of code, add a property called `content`, which
    is a pointer to `SPTextField`, inside the `Dialog.h` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Dialog` initializer, create the following content instance and position
    it between the title box and the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `content` property to the display tree, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a custom message for the abort dialog, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we see the text message inside the dialog.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – adding a text field to the dialog](img/1509OS_07_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we needed a property for the message we are going to display.
    A `SPTextField` class works like this: we define a rectangle and some text, and
    the text will automatically be aligned inside the bounds of the rectangle. By
    default, the text is centered horizontally and vertically. If we want to change
    this, we need to change the `hAlign` and `vAlign` properties to our desired values.
    In addition to all of the properties it inherits from being a display object (such
    as color or scale), a text field also has the `fontName` property to use different
    fonts and the `fontSize` property for the size of the text.'
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we created the `_content` instance, where the text field should be
    a bit smaller than the dialog itself. We gave the text field a default text and
    then updated its position to be more or less in the center of the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: After we added the text field to the display tree in step 3, we updated the
    default message, a custom one, inside the `Battlefield` initializer.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, we saw our custom message in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining system fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System fonts are the fonts iOS has built-in, out of the box. The selection ranges
    from Arial and Helvetica to Verdana, including the light, bold, and italic variants.
    For a complete list of all available system fonts, visit [http://iosfonts.com/](http://iosfonts.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Explaining bitmap fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bitmap font is very similar to a texture atlas; every character is an image.
    All of these smaller images are put into a big one. Although system fonts can
    display Unicode characters with ease, if we need umlauts or similar characters,
    we would need to add them ourselves. As a result, this would directly increase
    the size of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample bitmap font would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining bitmap fonts](img/1509OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A portion of the data might look something like the following portion of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Similar to a texture atlas, the actual data is represented in XML.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple tools to create bitmap fonts, with each of them having their
    own advantages and disadvantages. Littera is a free online tool available at [http://kvazars.com/littera/](http://kvazars.com/littera/)
    (requires Adobe Flash Player); other popular commercial solutions are **Glyph
    Designer** by 71squared and **bmGlyph** by Stéphane Queraud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our very own bitmap font
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we will use bmGlyph, as it allows us to create multiple scaled
    bitmap fonts similar to the mechanic `TexturePacker` provides. The bmGlyph solution
    is available on the Mac App Store at [https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12](https://itunes.apple.com/us/app/bmglyph/id490499048?mt=12)
    for $9.99 or your regional equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use bmGlyph, the complete bitmap font is also included
    in the graphics package.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using bmGlyph to create a bitmap font
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our first bitmap font, we just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **bmGlyph**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Arial Rounded MT Bold** as the font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Font size** to **72** points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **Color Tools** section and check **Shadow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Shadow** pane, set the **x** property to **2**, the **y** property
    to **-2**, and the **radius** to **8**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Fill Mode** section, select a brown-yellowish color and select the
    **Glossy** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Publish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Default** target, enter `PirateFont` as the **File Name** and font
    name (**Force Font Name**). In the **Suffix** input box, add `@4x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **50** button inside the **Duplicate with scale** box and add the
    suffix `@2x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **25** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Sparrow** in the **Format** drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that **PirateFont** is displayed in all of the targets as the **File
    Name** and in **Force Font Name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit **Publish** and then the **Close** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After these steps, we should see the following screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – using bmGlyph to create a bitmap font](img/1509OS_07_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we opened **bmGlyph**, we set the base font, size, color, and the shadow
    of the bitmap font. To export the bitmap font, we clicked on the **Publish** button,
    which we did in step 7\. For each separate image, we need to define a new target
    with a scale. In our case, this is `100%`, `50%`, and `25%` with the suffixes
    `@4x` and `@2x`, respectively. For the `25%` target, we don't need a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: To export a Sparrow-compatible bitmap font, we needed to select the **Sparrow**
    format. We needed to make sure that `PirateFont` is written in both **File Name**
    and **Force Font Name**. If we don't do the latter, the font won't become available
    as `PirateFont`, but will replace **Arial Rounded MT Bold**.
  prefs: []
  type: TYPE_NORMAL
- en: When we hit the **Publish** button, our font files became available in the location
    where we wanted to save them.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a text field with bitmap fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have displayed a system in our dialog, let's display text using
    our fresh bitmap font as the dialog's title.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using our bitmap font for a text field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to display bitmap fonts in `SPTextField`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add another property called `title` inside the `Dialog.h` file,
    which is also a pointer to `SPTextField`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We register our bitmap font, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create and position the `_title` instance with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to add the `_title` instance to the display tree, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Battlefield.m` file, we replace the default title with a custom
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our dialog now has a message and a title:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – using our bitmap font for a text field](img/1509OS_07_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying bitmap fonts is very similar to displaying system fonts on the screen.
    Before we can use any bitmap font, we need to register it first. When we want
    to display a text field with this font, we need to update the `fontName` property
    to reflect the name of the bitmap font.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider is that Sparrow displays all text in black by default.
    We need to change this in order to see the color effect of our bitmap font.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember that the complete source code for this chapter can also be found on
    GitHub: [https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733](https://github.com/freezedev/pirategame/tree/f742f6026e9ad129546d17e5d9e9728c27ff0733).'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. In order for custom jugglers to show their tweens, which method needs to
    be called?
  prefs: []
  type: TYPE_NORMAL
- en: '`advanceTime`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`update`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`addJuggler`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Are bitmap fonts similar to texture atlases?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. What kind of fonts can be used with `SPTextField`?
  prefs: []
  type: TYPE_NORMAL
- en: System fonts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitmap fonts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about adding user interface elements to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered health bars, buttons, and drawing text on the screen,
    and we got a deeper knowledge of jugglers and how to update elements through custom
    getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic user interface, let's add some artificial intelligence—which
    is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
