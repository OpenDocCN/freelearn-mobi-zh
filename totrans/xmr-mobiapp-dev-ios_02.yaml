- en: Chapter 2. The User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user interface is the primary method of communication between a device and
    the user. The design and appearance is what differentiates a good app from an
    amazing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering some of the essential features of the
    user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MonoTouch.Dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating external views into your user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the User Interface with Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the exception of `MonoTouch.Dialog`, the user interface for any iOS application
    is created using Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: When considering how to create a user interface and the positioning of any of
    the available widgets, you need to think along the lines of fuzzy felt placed
    on a canvas. You are able to place any iOS widget anywhere on the felt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple user interface, create a new iOS application. Click on **File**
    then **New**. You will be presented with a window as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Single View Application**, enter a filename in the **Name** field,
    and click on **OK** once it is done. Xamarin.iOS will create a directory containing
    all of the folders and files required to get you started. Unchecking the **Create
    directory for solution** box will still create the application, but the files
    will not be held in a directory structure, but instead wherever the **Location**
    path points to. The application can still be edited and worked on, but there is
    a good chance that files will be lost or overwritten (for example, if you work
    on multiple projects, each project will create an `AppDelegate.cs` file. When
    one is created, the new version will overwrite the old one.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application structure is set up, you will be presented with a new
    text editing window shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the solution explorer, there are three files that need attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '**testappViewController.cs**: This is the file for creating the C# code for
    your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**testappViewController.designer.cs**: This is a designer file created by Xamarin.iOS
    and is based on the user interface created with Xcode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**testappViewController_iPad.xib** and **testappViewController_iPhone.xib**:
    Any file with a `.xib` extension is an Xcode designer file![Note](img/00001.gif)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To start Xcode, simply double-click on the `.xib` file. To edit the `.xib` file,
    you must double-click on either the **testappViewController_iPad.xib** or **testappViewController_iPhone.xib**
    file depending on the view controller user interface you wish to edit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Xcode is quite a simple designer, but in that simplicity is a very powerful
    piece of software. On startup, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Xcode designer is a very complex piece of software. However, because there
    are books written on how to use it to its maximum potential, and due to space
    constraints, I will limit the discussion here to the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: To add a widget, simply select and drop it into the main view. You can drop
    any widget more or less anywhere. However, your application won't know anything
    about it at all as it needs to be connected. Connecting a widget is simple. The
    preceding screenshot shows a button called Connector. Click on this icon and another
    frame will appear to the left of the properties frame. To connect a widget, click
    on *Ctrl* and drag it to the Connector frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From this point, you have to decide the type of the button: **Outlet**, **Action**,
    or **Outlet Collection**. Each is very different and their names are sometimes
    confusing.'
  prefs: []
  type: TYPE_NORMAL
- en: An **Outlet** button would be normally considered for displaying information
    and not accepting events. However, actions, say, click events, are handled in
    **Outlet**. If you connect a button as **Outlet**, it is considered an interface.
    It is open to all modifiers and events available for that object. **Outlet Collection**
    is a collection of outlets. **Action** is just that—it is a specific action (or
    event) linked to that object.
  prefs: []
  type: TYPE_NORMAL
- en: There is a major difference, though, between them. If you have a button connected
    as **Outlet**, events have to be specifically added. If you don't do anything
    with the button at all, the application will run on your device, but the button
    will do nothing. If you have the button connected as **Action**, the code for
    the action must be written before the application is run. Failure to do so will
    result in the application crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Events will be dealt with in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Screen origins and sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All screens and views start with **0,0** at top left. To obtain the screen
    size (remember, this is going to be different for different versions of iPhones
    and iPads), consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: MonoTouch.Dialog (MT.D)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS screens usually contain a lot of data in a list form (think of how Facebook
    or Twitter looks). On iOS, these are constructed using `UITableView`. This is
    a very flexible piece of the UI, but can be tricky to code for. To alleviate the
    problems with `UITableView`, Xamarin created the `MonoTouch.Dialog` class. The
    benefit of `MT.D` is that Xcode is not required for designing the interface so
    it can just as simply be created under Windows as well as Mac.
  prefs: []
  type: TYPE_NORMAL
- en: '`MonoTouch.Dialog` views are very simple to create and work on a three-tier
    system for design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elements**: These contain the likes of `on`/`off` Boolean switches, strings,
    images, and anything else you would normally see in a user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sections**: These hold any number of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roots**: These hold the sections. An `MT.D` class must have at least one
    root element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many different types of elements. In the following example, a simple
    user interface is constructed (this code is autogenerated from Xamarin Studio
    when you ask it to create an `MT.D` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When compiled, the code produces the following (the first view is the initial
    display; the second view is displayed when the **Hello** entry is clicked on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![MonoTouch.Dialog (MT.D)](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Image A
  prefs: []
  type: TYPE_NORMAL
- en: 'We would get the following image after clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MonoTouch.Dialog (MT.D)](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Image B
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard does not have to be a standard QWERTY keyboard. It can be one specific
    for e-mail addresses, phone numbers, or just numbers. This is defined using `UIKeyboardType`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the keyboard type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding line of code is attached to an MT.D class view, tapping
    the element will bring up a standard alphanumeric keyboard. For standard entry,
    this is fine; in this example, though, a different type of keyboard is required.
    To set this, either of the following can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an issue, though, with these keyboards and that is dismissing them.
    For the likes of a standard alphanumeric keyboard, a return key can be added to
    the keyboard itself using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The likes of the numeric keyboards do not have a return key, even if `ReturnKeyType`
    is added. There are three ways to sort this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldReturn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResignFirstResponder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a toolbar to the keyboard with a done button that dismisses the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ShouldReturn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simple method to use but relies on a return key being on the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using ResignFirstResponder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless it is defined in the designer or in code, the `FirstResponder` method
    is whatever control is clicked on first. When something else is clicked (say another
    `EntryElement` but this also applies to any other control), that needs to become
    the `FirstResponder` control. By issuing a `ResignFirstResponder` method, the
    keyboard for that control is closed. Clicking onto a new control should issue
    a `BecomeFirstResponder` control and its keyboard appears (assuming that a keyboard
    is associated with the control).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toolbar to the keyboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Toolbars are not actually part of the keyboard but can be attached to the keyboard
    to provide additional or missing functionality to the keyboard. Adding the keyboard
    is different for an `MT.D` class than for a standard `UITextField` or `UITextView`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: '**For an MT.D**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, a subclass of the `EntryElement` class will be needed to implement the
    `InputAccessoryView` method. While the cell being used can be found by looking
    at the `TableView` from the Root constructor, the `InputAccessoryView` from this
    is a read-only parameter so it cannot be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the subclass would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `EntryElement` class in the main code would need to be altered to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, I have not included the password parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**For a standard UITextField**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, the toolbar (as described in the preceding section) is created but without
    the action sheet, and then added to the `UITextField` method using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Image B (section *MonoTouch.Dialog (MT.D)*) shows the `UIAlertView` control.
    This is a customizable alert box that is usually used for information (for example,
    errors, during a slow process to stop the user from getting worried, or if a user
    choice is required).
  prefs: []
  type: TYPE_NORMAL
- en: The real beauty of `MT.D` is that it removes the tedium associated with the
    `UITableView` control. It gives the developer the majority of the facilities required
    from the `UITableView` control without having to mess about. Also, if you need
    something special (such as a standard interface button), these can be achieved
    simply by creating a subclass of an element type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic element types supported in an `MT.D` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Uses | Caveats to use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ActivityElement` | Used to show that something is happening (it''s a spinner)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `BadgeElement` | Image with text next to it |   |'
  prefs: []
  type: TYPE_TB
- en: '| `BaseBooleanImageElement` |   | Base type for the Booleans, cannot be used
    directly (abstract class) |'
  prefs: []
  type: TYPE_TB
- en: '| `BooleanElement` | Simple `on`/`off` switch |   |'
  prefs: []
  type: TYPE_TB
- en: '| `BooleanImageElement` | Simple `on`/`off` switch that allows for two different
    images to be displayed |   |'
  prefs: []
  type: TYPE_TB
- en: '| `BoolElement` |   | Cannot be used directly (abstract class) |'
  prefs: []
  type: TYPE_TB
- en: '| `CheckboxElement` | Tick next to a string when selected |   |'
  prefs: []
  type: TYPE_TB
- en: '| `DateElement` | Displays a date picker | This is a two-part element. Part
    one looks like a standard `StringElement` element but with a **>** symbol next
    to the value on the right. When clicked, a `UIDatePicker` element is displayed.
    The selected value is returned in the value element. |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeElement` | Displays a date/time picker | Essentially is the same
    as `DateElement`, except that it includes the time. The time can be set in the
    12 or 24 hour clock |'
  prefs: []
  type: TYPE_TB
- en: '| `Element` |   | Base element |'
  prefs: []
  type: TYPE_TB
- en: '| `EntryElement` | Allows for data entry | The optional fourth parameter in
    the constructor allows for the entry to be used for passwords (set as `true` for
    password). The constructor takes three strings: caption, placeholder, and value.
    Placeholder and value can be string or `Empty`, but caption must have a value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FloatElement` | Slider bar | Values are float |'
  prefs: []
  type: TYPE_TB
- en: '| `HtmlElement` | Caption that leads to an HTML view | This is a crossover
    element in that the originator is just an `Element`, but gives a `UIWebView` element
    when clicked. |'
  prefs: []
  type: TYPE_TB
- en: '| `ImageElement` | Produces an image |   |'
  prefs: []
  type: TYPE_TB
- en: '| `ImageStringElement` | Produces an image with a string next to it |   |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonElement` | Allows for the loading of content from a local or remote
    URL |   |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadMoreElement` | Allows users to add more items to the list on screen
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MessageElement` | Consider this as the sort of message you find on Twitter
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `MultilineElement` | Allows multiple lines of text to be displayed | Cannot
    be styled |'
  prefs: []
  type: TYPE_TB
- en: '| `OwnerDrawnElement` | Not used directly | Must be subclassed. The `Height`
    and `Draw` methods must be overridden |'
  prefs: []
  type: TYPE_TB
- en: '| `RadioElement` | A radio element that allows for a single option to be chosen
    from multiple choices. | Requires a radio group to be specified in the element
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RootElement` | Base element for the root |   |'
  prefs: []
  type: TYPE_TB
- en: '| `StringElement` | A simple caption on the left with a value on the right
    | This element can also be used as a button by providing an anonymous delegate
    as the second parameter (as in the example above) |'
  prefs: []
  type: TYPE_TB
- en: '| `StyledMultilineElement` | Essentially the same as `MultilineElement` except
    can by styled |   |'
  prefs: []
  type: TYPE_TB
- en: '| `StyledStringElement` | Allow for strings to be shown using the built-in
    styles (such as colors, fonts, and sizes) and custom formats. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `TimeElement` | Displays a time picker | Same as `DateElement`, but for time.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UIViewElement` | `UIView` that can be displayed | Design `UIView` using
    Xcode. |'
  prefs: []
  type: TYPE_TB
- en: Creating your own Pickers on MT.D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've decided to demonstrate this using `UIPickerView` with `UIToolBar` added
    to the top and incorporate it within `UIActionSheet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with, we need two things: an event to latch onto and the model
    (containing the information that `UIPickerView` requires). It''s then a case of
    wiring the two together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Actually, this can return anything, not just a string. But for my purposes,
    I'll keep it as a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Not rocket science—the only important part is that the `Selected()` method from
    the parent class is being overridden to send back the value from the row selected;
    everything else overrides the default class settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To wire this into the main `MT.D` class, `EntryElement` is used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `UIActionSheet` element is also needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create `UIPickerView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create `UIToolbar` and `UIBarButtonItem`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `EntryElement` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is just a case of using the `EntryStarted` event to call the picker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When this is all coded in, the result is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating your own Pickers on MT.D](img/00019.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Subclassing an element is equally simple. The subclass `EntryElement` allows
    only a specific number of characters to be entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are still free to use `UITableView` and `UITableViewCell` of course.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UITableView and UITableViewCell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITableView` method is the workhorse of the iPhone. Most, if not all, list
    data of whatever description is displayed using the `TableView` and `TableViewCell`
    methods. If you are a user of Facebook, Twitter, the standard iPhone text message
    application, or any form of configuration on the iPhone, you will have used these
    two components—this gives you an idea of how much they are used.
  prefs: []
  type: TYPE_NORMAL
- en: The topic is a massive one to cover and will be dealt with further in [Chapter
    4](../Text/part0026.html#page "Chapter 4. Controllers"), *Controllers*.
  prefs: []
  type: TYPE_NORMAL
- en: Colors, buttons, and labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UILabel` is the simplest method of putting text onto a screen. It has a very
    limited range of actions associated with its use (for example, you cannot use
    it as something that is clickable). The color and text of the label can be set,
    as can the formatting. For example, consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UILabel` method has five constructors, of which two are of great use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UILabel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second constructor can be replicated using the `Frame` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: UILabel lbl = new UILabel();
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the main issues with using `UILabel` is ensuring that the bounding frame
    is large enough. There is a way to get around this:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the label much larger than required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length of the string and, using the `Frame` property, alter the
    size of the label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduce the font size of the string to ensure it fits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these approaches have their benefits and disadvantages. The first is
    that text will always fit but only if the font size is the system default. The
    second is that you will always have the correct size-bounding box, but that you
    will have to calculate the size, and that will take time.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring you have the correct size bounding boxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This assumes that a label has already been created using Xcode. The label in
    this case has a width of 96 (enough to write “More text to”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: UIColor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iOS comes with a number of preset colors (such as red, green, blue, black, and
    white). It is also possible to create your own using `UIColor.FromRGB[A]` as well
    as `FromHSB[A]` (where `HSB` is hue, saturation, and brightness and `[A]` is the
    alpha channel). Think of the latter as being the colors' opacity. The color can
    also be set from a pattern (this is useful, as it creates a color based on an
    image that can then be used as a brush to paint the image), `CoreImage` and `CoreGraphicsColor`
    (`CI` and `CGColor`), and `FromWhiteAlpha` (a gray-scale color based on the current
    color space).
  prefs: []
  type: TYPE_NORMAL
- en: Using `CIColor` and `CGColor` requires a lot more legwork but does allow for
    greater flexibility in the colors.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest to use, though, is `FromRGB`. This allows the values to be entered
    as byte, int, and float. The caveat here, though, is that the float values go
    from `0` to `1` rather than `0` to `255`, so the value for `82, 184, 33` would
    be `0.32`, `0.72`, `0.13` (that is, 82/255, 184/255, and 33/255).
  prefs: []
  type: TYPE_NORMAL
- en: UIButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A button is not just a button; it can have a whole range of interesting effects
    applied to it (such as the addition of graphics, a gradient color, text, and graphics).
    Let's assume a button (`btn`) has been created in Xcode and we wish to apply a
    gradient color to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`CAGradientLayer` come from the `CoreAnimation` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an image is also quite trivial, though the important point here is to
    remember that, when placing anything on a button, you have to treat that button
    as a new view with the origin set at the top left of the button. Remember also
    that a button can have a foreground and background image.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a background image will cover the entire button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter here (`UIControlState`) is the state the button (or control)
    is in. `Normal` is when it has not been selected. When the button is depressed,
    the state becomes `Highlighted` and when released, it is `Normal` again. This
    means you can have different images depending on the state of the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The foreground image will typically not cover the entire button, but will be
    of a particular size. For example, say the button is 92 x 92\. To fill most of
    the button, a gap of 4 on each side would be good; this makes the dimension 84
    x 84 (left and right gaps, as well as for both the height and width). To create
    this image for the button is a two-step process: create the image and add the
    image. This time, though, `ImageView` is initially used and then fed into the
    `SetImage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: An alternative is to add `ImageView` as a subview to the button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `UIButton` can also just have a color assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The button also comes with a default piece of text on it called `Title`. As
    with any text element, this can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A more interesting effect is to have both text and graphics on a button. The
    simplest way to consider the placement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Let `a` and `b` be the position of the top left and right of the image (in our
    previous example, that would be `4`, `4`). For ease, the same gap is on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Let `c` be the offset from the top (`a` + “image height” + “some gap”).
  prefs: []
  type: TYPE_NORMAL
- en: The trick here, though, is to ensure there is enough of a gap at the bottom
    so it doesn't look messy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the image is a two- or three-step process.
  prefs: []
  type: TYPE_NORMAL
- en: If `Title` is set, clear it (this can be one in or out of the designer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the image (see previous example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and add a `UILabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: UIControlStates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are (as previously mentioned) a number of `UIControlStates`: `Application`,
    `Disabled`, `Highlighted`, `Normal`, `Reserved`, and `Selected`. For most day-to-day
    considerations, `Disabled`, `Highlighted`, and `Normal` are the ones used most
    commonly.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Enabled` property is `false`, the button is `Disabled`. The only problem
    is that this is the only way to tell if a button is disabled using the system
    defaults. It is probably a better idea to set the background color as well as
    the text when disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'A button does not have to be a rounded rectangle. There are four predefined
    buttons (`ContactsAdd`, `DetailDisclosure` [the **>** arrow], `InfoDark`, and
    `InfoLight` [the info icon with either a dark or light background]). There is
    also a custom `UIButtonType` type. This by default gives no border to the button,
    but allows for interesting buttons where a `.png` file could be the button shape.
    So if you want an octagonal button, you would have a `.png` file of an octagon
    and then write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from this whistle-stop tour, iOS gives you a massively rich and
    varied number of different objects usable within the UI. In later chapters, we
    will see how these can be extended and how to get the most from them.
  prefs: []
  type: TYPE_NORMAL
