- en: Chapter 2. The User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user interface is the primary method of communication between a device and
    the user. The design and appearance is what differentiates a good app from an
    amazing one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering some of the essential features of the
    user interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MonoTouch.Dialog
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating external views into your user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the User Interface with Xcode
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the exception of `MonoTouch.Dialog`, the user interface for any iOS application
    is created using Xcode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: When considering how to create a user interface and the positioning of any of
    the available widgets, you need to think along the lines of fuzzy felt placed
    on a canvas. You are able to place any iOS widget anywhere on the felt.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple user interface, create a new iOS application. Click on **File**
    then **New**. You will be presented with a window as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00013.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Click on **Single View Application**, enter a filename in the **Name** field,
    and click on **OK** once it is done. Xamarin.iOS will create a directory containing
    all of the folders and files required to get you started. Unchecking the **Create
    directory for solution** box will still create the application, but the files
    will not be held in a directory structure, but instead wherever the **Location**
    path points to. The application can still be edited and worked on, but there is
    a good chance that files will be lost or overwritten (for example, if you work
    on multiple projects, each project will create an `AppDelegate.cs` file. When
    one is created, the new version will overwrite the old one.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application structure is set up, you will be presented with a new
    text editing window shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00014.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the solution explorer, there are three files that need attention:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**testappViewController.cs**: This is the file for creating the C# code for
    your application'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**testappViewController.designer.cs**: This is a designer file created by Xamarin.iOS
    and is based on the user interface created with Xcode'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**testappViewController_iPad.xib** and **testappViewController_iPhone.xib**:
    Any file with a `.xib` extension is an Xcode designer file![Note](img/00001.gif)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To start Xcode, simply double-click on the `.xib` file. To edit the `.xib` file,
    you must double-click on either the **testappViewController_iPad.xib** or **testappViewController_iPhone.xib**
    file depending on the view controller user interface you wish to edit.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Xcode is quite a simple designer, but in that simplicity is a very powerful
    piece of software. On startup, you will see the following screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00015.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: The Xcode designer is a very complex piece of software. However, because there
    are books written on how to use it to its maximum potential, and due to space
    constraints, I will limit the discussion here to the minimum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To add a widget, simply select and drop it into the main view. You can drop
    any widget more or less anywhere. However, your application won't know anything
    about it at all as it needs to be connected. Connecting a widget is simple. The
    preceding screenshot shows a button called Connector. Click on this icon and another
    frame will appear to the left of the properties frame. To connect a widget, click
    on *Ctrl* and drag it to the Connector frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User Interface with Xcode](img/00016.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'From this point, you have to decide the type of the button: **Outlet**, **Action**,
    or **Outlet Collection**. Each is very different and their names are sometimes
    confusing.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: An **Outlet** button would be normally considered for displaying information
    and not accepting events. However, actions, say, click events, are handled in
    **Outlet**. If you connect a button as **Outlet**, it is considered an interface.
    It is open to all modifiers and events available for that object. **Outlet Collection**
    is a collection of outlets. **Action** is just that—it is a specific action (or
    event) linked to that object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: There is a major difference, though, between them. If you have a button connected
    as **Outlet**, events have to be specifically added. If you don't do anything
    with the button at all, the application will run on your device, but the button
    will do nothing. If you have the button connected as **Action**, the code for
    the action must be written before the application is run. Failure to do so will
    result in the application crashing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Events will be dealt with in a later chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Screen origins and sizes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All screens and views start with **0,0** at top left. To obtain the screen
    size (remember, this is going to be different for different versions of iPhones
    and iPads), consider the following lines of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: MonoTouch.Dialog (MT.D)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS screens usually contain a lot of data in a list form (think of how Facebook
    or Twitter looks). On iOS, these are constructed using `UITableView`. This is
    a very flexible piece of the UI, but can be tricky to code for. To alleviate the
    problems with `UITableView`, Xamarin created the `MonoTouch.Dialog` class. The
    benefit of `MT.D` is that Xcode is not required for designing the interface so
    it can just as simply be created under Windows as well as Mac.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`MonoTouch.Dialog` views are very simple to create and work on a three-tier
    system for design:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Elements**: These contain the likes of `on`/`off` Boolean switches, strings,
    images, and anything else you would normally see in a user interface.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sections**: These hold any number of elements.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roots**: These hold the sections. An `MT.D` class must have at least one
    root element.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many different types of elements. In the following example, a simple
    user interface is constructed (this code is autogenerated from Xamarin Studio
    when you ask it to create an `MT.D` class):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When compiled, the code produces the following (the first view is the initial
    display; the second view is displayed when the **Hello** entry is clicked on):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![MonoTouch.Dialog (MT.D)](img/00017.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Image A
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We would get the following image after clicking:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![MonoTouch.Dialog (MT.D)](img/00018.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Image B
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard does not have to be a standard QWERTY keyboard. It can be one specific
    for e-mail addresses, phone numbers, or just numbers. This is defined using `UIKeyboardType`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Changing the keyboard type
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following line of code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the preceding line of code is attached to an MT.D class view, tapping
    the element will bring up a standard alphanumeric keyboard. For standard entry,
    this is fine; in this example, though, a different type of keyboard is required.
    To set this, either of the following can be used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is an issue, though, with these keyboards and that is dismissing them.
    For the likes of a standard alphanumeric keyboard, a return key can be added to
    the keyboard itself using:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The likes of the numeric keyboards do not have a return key, even if `ReturnKeyType`
    is added. There are three ways to sort this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldReturn`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResignFirstResponder`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a toolbar to the keyboard with a done button that dismisses the keyboard
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ShouldReturn
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simple method to use but relies on a return key being on the keyboard:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using ResignFirstResponder
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless it is defined in the designer or in code, the `FirstResponder` method
    is whatever control is clicked on first. When something else is clicked (say another
    `EntryElement` but this also applies to any other control), that needs to become
    the `FirstResponder` control. By issuing a `ResignFirstResponder` method, the
    keyboard for that control is closed. Clicking onto a new control should issue
    a `BecomeFirstResponder` control and its keyboard appears (assuming that a keyboard
    is associated with the control).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toolbar to the keyboard
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Toolbars are not actually part of the keyboard but can be attached to the keyboard
    to provide additional or missing functionality to the keyboard. Adding the keyboard
    is different for an `MT.D` class than for a standard `UITextField` or `UITextView`
    control.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**For an MT.D**'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, a subclass of the `EntryElement` class will be needed to implement the
    `InputAccessoryView` method. While the cell being used can be found by looking
    at the `TableView` from the Root constructor, the `InputAccessoryView` from this
    is a read-only parameter so it cannot be set.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the subclass would be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `EntryElement` class in the main code would need to be altered to read.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Note](img/00001.gif)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, I have not included the password parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: '**For a standard UITextField**'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, the toolbar (as described in the preceding section) is created but without
    the action sheet, and then added to the `UITextField` method using:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Image B (section *MonoTouch.Dialog (MT.D)*) shows the `UIAlertView` control.
    This is a customizable alert box that is usually used for information (for example,
    errors, during a slow process to stop the user from getting worried, or if a user
    choice is required).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The real beauty of `MT.D` is that it removes the tedium associated with the
    `UITableView` control. It gives the developer the majority of the facilities required
    from the `UITableView` control without having to mess about. Also, if you need
    something special (such as a standard interface button), these can be achieved
    simply by creating a subclass of an element type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic element types supported in an `MT.D` class are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Uses | Caveats to use |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `ActivityElement` | Used to show that something is happening (it''s a spinner)
    |   |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `BadgeElement` | Image with text next to it |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `BaseBooleanImageElement` |   | Base type for the Booleans, cannot be used
    directly (abstract class) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `BooleanElement` | Simple `on`/`off` switch |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `BooleanImageElement` | Simple `on`/`off` switch that allows for two different
    images to be displayed |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `BoolElement` |   | Cannot be used directly (abstract class) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `CheckboxElement` | Tick next to a string when selected |   |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `DateElement` | Displays a date picker | This is a two-part element. Part
    one looks like a standard `StringElement` element but with a **>** symbol next
    to the value on the right. When clicked, a `UIDatePicker` element is displayed.
    The selected value is returned in the value element. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeElement` | Displays a date/time picker | Essentially is the same
    as `DateElement`, except that it includes the time. The time can be set in the
    12 or 24 hour clock |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `Element` |   | Base element |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `EntryElement` | Allows for data entry | The optional fourth parameter in
    the constructor allows for the entry to be used for passwords (set as `true` for
    password). The constructor takes three strings: caption, placeholder, and value.
    Placeholder and value can be string or `Empty`, but caption must have a value.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `FloatElement` | Slider bar | Values are float |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `HtmlElement` | Caption that leads to an HTML view | This is a crossover
    element in that the originator is just an `Element`, but gives a `UIWebView` element
    when clicked. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `ImageElement` | Produces an image |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `ImageStringElement` | Produces an image with a string next to it |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `JsonElement` | Allows for the loading of content from a local or remote
    URL |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `LoadMoreElement` | Allows users to add more items to the list on screen
    |   |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `MessageElement` | Consider this as the sort of message you find on Twitter
    |   |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `MultilineElement` | Allows multiple lines of text to be displayed | Cannot
    be styled |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `OwnerDrawnElement` | Not used directly | Must be subclassed. The `Height`
    and `Draw` methods must be overridden |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `RadioElement` | A radio element that allows for a single option to be chosen
    from multiple choices. | Requires a radio group to be specified in the element
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `RootElement` | Base element for the root |   |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `StringElement` | A simple caption on the left with a value on the right
    | This element can also be used as a button by providing an anonymous delegate
    as the second parameter (as in the example above) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `StyledMultilineElement` | Essentially the same as `MultilineElement` except
    can by styled |   |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `StyledStringElement` | Allow for strings to be shown using the built-in
    styles (such as colors, fonts, and sizes) and custom formats. |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `TimeElement` | Displays a time picker | Same as `DateElement`, but for time.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `UIViewElement` | `UIView` that can be displayed | Design `UIView` using
    Xcode. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: Creating your own Pickers on MT.D
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've decided to demonstrate this using `UIPickerView` with `UIToolBar` added
    to the top and incorporate it within `UIActionSheet`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off with, we need two things: an event to latch onto and the model
    (containing the information that `UIPickerView` requires). It''s then a case of
    wiring the two together.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'First the event:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Actually, this can return anything, not just a string. But for my purposes,
    I'll keep it as a string.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is the model:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not rocket science—the only important part is that the `Selected()` method from
    the parent class is being overridden to send back the value from the row selected;
    everything else overrides the default class settings.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To wire this into the main `MT.D` class, `EntryElement` is used:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A `UIActionSheet` element is also needed:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then create `UIPickerView`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, create `UIToolbar` and `UIBarButtonItem`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `EntryElement` object:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now it is just a case of using the `EntryStarted` event to call the picker:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When this is all coded in, the result is as follows:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating your own Pickers on MT.D](img/00019.jpeg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Subclassing an element is equally simple. The subclass `EntryElement` allows
    only a specific number of characters to be entered:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You are still free to use `UITableView` and `UITableViewCell` of course.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UITableView and UITableViewCell
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UITableView` method is the workhorse of the iPhone. Most, if not all, list
    data of whatever description is displayed using the `TableView` and `TableViewCell`
    methods. If you are a user of Facebook, Twitter, the standard iPhone text message
    application, or any form of configuration on the iPhone, you will have used these
    two components—this gives you an idea of how much they are used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The topic is a massive one to cover and will be dealt with further in [Chapter
    4](../Text/part0026.html#page "Chapter 4. Controllers"), *Controllers*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Colors, buttons, and labels
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UILabel` is the simplest method of putting text onto a screen. It has a very
    limited range of actions associated with its use (for example, you cannot use
    it as something that is clickable). The color and text of the label can be set,
    as can the formatting. For example, consider the following lines of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `UILabel` method has five constructors, of which two are of great use:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`UILabel()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second constructor can be replicated using the `Frame` property as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: UILabel lbl = new UILabel();
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One of the main issues with using `UILabel` is ensuring that the bounding frame
    is large enough. There is a way to get around this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Make the label much larger than required.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length of the string and, using the `Frame` property, alter the
    size of the label.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduce the font size of the string to ensure it fits.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these approaches have their benefits and disadvantages. The first is
    that text will always fit but only if the font size is the system default. The
    second is that you will always have the correct size-bounding box, but that you
    will have to calculate the size, and that will take time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring you have the correct size bounding boxes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This assumes that a label has already been created using Xcode. The label in
    this case has a width of 96 (enough to write “More text to”):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: UIColor
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: iOS comes with a number of preset colors (such as red, green, blue, black, and
    white). It is also possible to create your own using `UIColor.FromRGB[A]` as well
    as `FromHSB[A]` (where `HSB` is hue, saturation, and brightness and `[A]` is the
    alpha channel). Think of the latter as being the colors' opacity. The color can
    also be set from a pattern (this is useful, as it creates a color based on an
    image that can then be used as a brush to paint the image), `CoreImage` and `CoreGraphicsColor`
    (`CI` and `CGColor`), and `FromWhiteAlpha` (a gray-scale color based on the current
    color space).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Using `CIColor` and `CGColor` requires a lot more legwork but does allow for
    greater flexibility in the colors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The simplest to use, though, is `FromRGB`. This allows the values to be entered
    as byte, int, and float. The caveat here, though, is that the float values go
    from `0` to `1` rather than `0` to `255`, so the value for `82, 184, 33` would
    be `0.32`, `0.72`, `0.13` (that is, 82/255, 184/255, and 33/255).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: UIButton
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A button is not just a button; it can have a whole range of interesting effects
    applied to it (such as the addition of graphics, a gradient color, text, and graphics).
    Let's assume a button (`btn`) has been created in Xcode and we wish to apply a
    gradient color to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`CAGradientLayer` come from the `CoreAnimation` namespace.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Adding an image is also quite trivial, though the important point here is to
    remember that, when placing anything on a button, you have to treat that button
    as a new view with the origin set at the top left of the button. Remember also
    that a button can have a foreground and background image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a background image will cover the entire button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second parameter here (`UIControlState`) is the state the button (or control)
    is in. `Normal` is when it has not been selected. When the button is depressed,
    the state becomes `Highlighted` and when released, it is `Normal` again. This
    means you can have different images depending on the state of the button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The foreground image will typically not cover the entire button, but will be
    of a particular size. For example, say the button is 92 x 92\. To fill most of
    the button, a gap of 4 on each side would be good; this makes the dimension 84
    x 84 (left and right gaps, as well as for both the height and width). To create
    this image for the button is a two-step process: create the image and add the
    image. This time, though, `ImageView` is initially used and then fed into the
    `SetImage` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: An alternative is to add `ImageView` as a subview to the button.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `UIButton` can also just have a color assigned to it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The button also comes with a default piece of text on it called `Title`. As
    with any text element, this can be set:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A more interesting effect is to have both text and graphics on a button. The
    simplest way to consider the placement is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Let `a` and `b` be the position of the top left and right of the image (in our
    previous example, that would be `4`, `4`). For ease, the same gap is on the right.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Let `c` be the offset from the top (`a` + “image height” + “some gap”).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The trick here, though, is to ensure there is enough of a gap at the bottom
    so it doesn't look messy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Adding the image is a two- or three-step process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: If `Title` is set, clear it (this can be one in or out of the designer).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the image (see previous example).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and add a `UILabel`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: UIControlStates
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are (as previously mentioned) a number of `UIControlStates`: `Application`,
    `Disabled`, `Highlighted`, `Normal`, `Reserved`, and `Selected`. For most day-to-day
    considerations, `Disabled`, `Highlighted`, and `Normal` are the ones used most
    commonly.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If the `Enabled` property is `false`, the button is `Disabled`. The only problem
    is that this is the only way to tell if a button is disabled using the system
    defaults. It is probably a better idea to set the background color as well as
    the text when disabled.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'A button does not have to be a rounded rectangle. There are four predefined
    buttons (`ContactsAdd`, `DetailDisclosure` [the **>** arrow], `InfoDark`, and
    `InfoLight` [the info icon with either a dark or light background]). There is
    also a custom `UIButtonType` type. This by default gives no border to the button,
    but allows for interesting buttons where a `.png` file could be the button shape.
    So if you want an octagonal button, you would have a `.png` file of an octagon
    and then write the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from this whistle-stop tour, iOS gives you a massively rich and
    varied number of different objects usable within the UI. In later chapters, we
    will see how these can be extended and how to get the most from them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这次匆匆一瞥中可以看到，iOS 为您提供了大量丰富且多样化的对象，这些对象可以在 UI 中使用。在后续章节中，我们将看到这些对象如何被扩展，以及如何最大限度地利用它们。
