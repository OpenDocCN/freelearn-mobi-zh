- en: Chapter 2. Performing Work with Looper, Handler, and HandlerThread
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用Looper、Handler和HandlerThread执行工作
- en: In the previous chapter, you were introduced to the most basic concurrent issues
    that a developer might face while developing a responsive and concurrent Android
    application. As the most interactable items run on the main thread, it is crucial
    to coordinate the backgrounds code to handle the work without any UI stuttering
    that compromises the user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你被介绍到开发响应式和并发Android应用程序时开发者可能遇到的最基本的并发问题。由于最可交互的项目运行在主线程上，协调后台代码以处理工作而不产生任何影响用户体验的UI卡顿至关重要。
- en: In this chapter, we will meet some of most fundamental constructs used on Android
    systems to perform tasks and schedule on a main thread or an ordinary background
    thread created by the developer to perform and schedule tasks long-running operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将遇到在Android系统中执行任务和调度主线程或开发者创建的普通后台线程以执行和调度长时间运行操作的一些最基本构造。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding Looper
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Looper
- en: Understanding Handler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Handler
- en: Sending work to Looper
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工作发送到Looper
- en: Scheduling work with post
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用post调度工作
- en: Using Handler to defer work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handler延迟工作
- en: Leaking implicit references
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄露隐式引用
- en: Leaking explicit references
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄露显式引用
- en: Updating the UI with Handler
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handler更新UI
- en: Canceling pending messages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消挂起的消息
- en: Multithreading with Handler and HandlerThread
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Handler和HandlerThread进行多线程处理
- en: Applications of Handler and HandlerThread
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Handler和HandlerThread的应用
- en: Understanding Looper
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Looper
- en: Before we can understand `Looper`, we need to understand where it gets its name
    from.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解`Looper`之前，我们需要了解其名称的来源。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A loop is a group of instructions that are repeated continually until a termination
    condition is met.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一组不断重复执行的指令，直到满足终止条件。
- en: Following this definition, Android's `Looper` executes on a thread that has
    a `MessageQueue`, executes a continuous loop waiting for work, and blocks when
    there is no work pending. When work is submitted to its queue, it dispatches it
    to the target `Handler` defined explicitly on the `Message` object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，Android的`Looper`在一个具有`MessageQueue`的线程上执行，执行连续循环等待工作，并在没有挂起工作的情况下阻塞。当工作提交到其队列时，它将派发到在`Message`对象上显式定义的目标`Handler`。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A message is a notification object containing a description and arbitrary data
    object that can be sent to a Handler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是一个包含描述和任意数据对象的通告对象，可以发送到Handler。
- en: The Looper on Android is an implementation of a common UI programming concept
    known as an event loop. Later, at the end of this processing sequence, the `Handler`
    will process the `Message` and execute your domain logic in order to solve an
    application user problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的Looper是实现了一个常见的UI编程概念，称为事件循环。稍后，在处理序列的末尾，`Handler`将处理`Message`并执行你的领域逻辑，以解决应用程序用户问题。
- en: 'The `Looper` sequence on Android follows these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的`Looper`序列遵循以下步骤：
- en: Wait until a Message is retrieved from its MessageQueue
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待从其消息队列中检索到消息
- en: If logging is enabled, print dispatch information
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果启用了日志记录，请打印派发信息
- en: Dispatch the message to the target Handler
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息发送到目标处理器
- en: Recycle the Message
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回收消息
- en: Go to step 1
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到步骤1
- en: As mentioned on the previous chapter, the main thread implicitly creates its
    own `Looper` to sequentially process all that is needed to keep the application
    running and to manage the interaction between the application components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，主线程隐式创建自己的`Looper`，以顺序处理保持应用程序运行所需的所有内容，并管理应用程序组件之间的交互。
- en: 'To access the main thread''s Looper you want access to the main thread''s `Looper`
    instance, use the static method `getMainLooper()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问主线程的Looper，你需要访问主线程的`Looper`实例，使用静态方法`getMainLooper()`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set up our own `Looper` thread, we need to invoke two static methods of
    `Looper`—`prepare` and `loop`—from within the thread, and they will handle the
    continuous loop. Here is a simple example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们自己的`Looper`线程，我们需要在线程内部调用`Looper`的两个静态方法——`prepare`和`loop`——它们将处理连续循环。以下是一个简单的示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the snippet, when the `SimpleLopper` object is created and started by invoking
    the `start()` method, a new thread is created in the current application process,
    and `run()` is automatically called inside the new thread. When the `run()` method
    is called, we attach a `Looper` to the current thread when we invoke the static
    `Looper.prepare()` method. Following that, we start processing messages when `loop()`
    is called. The `prepare()` method is responsible for initializing the `MessageQueue`
    and attaching the queue as a `ThreadLocal` parameter to the current thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，当通过调用 `start()` 方法创建并启动 `SimpleLopper` 对象时，在当前应用程序进程中创建了一个新线程，并且 `run()`
    方法在新线程中自动被调用。当调用 `run()` 方法时，我们在调用静态 `Looper.prepare()` 方法时将一个 `Looper` 绑定到当前线程。随后，当调用
    `loop()` 时，我们开始处理消息。`prepare()` 方法负责初始化 `MessageQueue` 并将其作为 `ThreadLocal` 参数绑定到当前线程。
- en: When `loop()` is invoked, the `run()` method will block until the looper is
    interrupted to process new messages be added to the queue.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `loop()` 时，`run()` 方法将阻塞，直到循环器被中断以处理添加到队列中的新消息。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Looper.prepare()` must only be called once from within the same thread; otherwise,
    a `RuntimeException` will to be thrown that says only one looper may be created
    per thread.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Looper.prepare()` 必须在同一线程中只调用一次；否则，将抛出一个 `RuntimeException`，表示每个线程只能创建一个循环器。'
- en: When we want to stop the continuous `Looper` execution, we can either invoke
    its member function `quit()` to stop it without processing the remaining messages
    in its queue or `quitSafely()` to process the remaining work on the queue and
    stop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要停止连续的 `Looper` 执行时，我们可以通过调用其成员函数 `quit()` 来停止它，而无需处理队列中剩余的消息，或者调用 `quitSafely()`
    来处理队列中剩余的工作然后停止。
- en: Understanding Handler
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Handler
- en: Together with `Looper`, the `Handler` class is fundamental to the infrastructure
    of Android apps. It underpins everything that the main thread does—including the
    invocation of the `Activity` lifecycle methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Looper` 一起，`Handler` 类是 Android 应用程序基础设施的基本组成部分。它支撑着主线程所做的所有事情——包括调用 `Activity`
    生命周期方法。
- en: 'While `Looper` takes care of dispatching work on its message-loop thread, `Handler`
    serves two purposes: providing an interface to submit messages to its `Looper`
    queue, and implementing the callback for processing those messages when they are
    dispatched by the `Looper`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Looper` 在其消息循环线程上处理工作的时候，`Handler` 扮演两个角色：提供一个接口将消息提交到其 `Looper` 队列，并在消息被
    `Looper` 分发时实现处理这些消息的回调。
- en: It is also import to know that each `Handler` is bound to a single `Looper`
    and, by extension, to one thread and its looper `MessageQueue`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，每个 `Handler` 都绑定到一个单一的 `Looper`，进而绑定到一个线程及其 `Looper` 的 `MessageQueue`。
- en: 'To bind to the `Looper` of the current thread, we need to instantiate it over
    the default `Handler()` constructor after we initialize the `Looper` by calling
    the `prepare` method. Since we create our handler inside our `SimpleLooper` thread
    over the default constructor `Handler()`, `myHandler` will be attached to the
    current thread''s `Looper` instead of the main thread''s `Looper`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绑定到当前线程的 `Looper`，我们需要在通过调用 `prepare` 方法初始化 `Looper` 之后，使用默认的 `Handler()`
    构造函数来实例化它。由于我们在 `SimpleLooper` 线程中通过默认构造函数 `Handler()` 创建我们的处理器，因此 `myHandler`
    将绑定到当前线程的 `Looper` 而不是主线程的 `Looper`：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Apart from providing an interface to submit work to `Looper` threads, `Handler`
    also defines the code that process the messages submitted. In the following code,
    the `MyHandler` class overrides the superclass'' (`Handler`) `handleMessage` member
    method to define our message-handling code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一个接口将工作提交给 `Looper` 线程外，`Handler` 还定义了处理提交的消息的代码。在下面的代码中，`MyHandler` 类重写了超类（`Handler`）的
    `handleMessage` 成员方法来定义我们的消息处理代码：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once started, the `Looper` thread will wait inside `Looper.loop()` for messages
    to be added to its queue.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，`Looper` 线程将在 `Looper.loop()` 内部等待，直到有消息添加到其队列中。
- en: When another thread adds a `Message` to the queue using the `submit` method,
    the waiting thread will then dispatch the message to our target `MyHandler` by
    invoking the handler's `handleMessage()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一个线程使用 `submit` 方法将 `Message` 添加到队列中时，等待的线程将调用处理器的 `handleMessage()` 方法，将消息分发到我们的目标
    `MyHandler`。
- en: 'With the `Handler` object reference in hand, we are able to able to send messages
    to the `Handler` from any thread, and as a consequence, it is always dispatched
    to the `Looper` thread and handled by the correct `Handler`, as shown in the following
    diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有`Handler`对象引用后，我们能够从任何线程向`Handler`发送消息，因此，消息总是被调度到`Looper`线程并由正确的`Handler`处理，如下面的图示所示：
- en: '![Understanding Handler](img/Image_B05062_02_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![理解Handler](img/Image_B05062_02_01.jpg)'
- en: 'Figure 2.1: Posting work to other Threads'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：将工作发布到其他线程
- en: 'We already saw that we can create our own `Looper` threads, but as detailed
    and mentioned before, the main thread is in also a `Looper` thread. To make it
    more clear, we are going to create a `StackTraceHandler` that prints the stack
    trace of the current thread:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以创建自己的`Looper`线程，但如前所述，主线程也是一个`Looper`线程。为了更清楚地说明，我们将创建一个打印当前线程堆栈跟踪的`StackTraceHandler`：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the activity's `onCreate()` function runs on the main thread, we will
    create an instance of our handler that implicitly calls the handler's super constructor,
    which binds the handler to the current thread's `Looper`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动的`onCreate()`函数在主线程上运行，我们将创建我们处理器的实例，它隐式地调用处理器的超构造函数，该构造函数将处理器绑定到当前线程的`Looper`。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the current thread does not have a Looper and we try to create a handler
    over the super constructor, a runtime exception with the message **Can't create
    handler inside thread that has not called Looper.prepare()** is thrown.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前线程没有`Looper`，并且我们尝试在超构造函数中创建处理器，则会抛出一个带有消息**Can't create handler inside
    thread that has not called Looper.prepare()**的运行时异常。
- en: 'With the `Handler` instance created, we retrieve a message from its recycled
    messages pool by calling the handler''s `obtainMessage`, and we post an empty
    message to the main thread''s `Looper`. The messages obtained by `obtainMessage`
    are cached and will also set the handler as the destination''s `Handler` object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`Handler`实例后，我们通过调用处理器的`obtainMessage`方法从其回收的消息池中检索消息，并将一个空消息发布到主线程的`Looper`。通过`obtainMessage`获取的消息将被缓存，并将处理器设置为目标的`Handler`对象：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As mentioned before, when our `handleMessage()` gets dispatched it prints active
    stack frames at the time of the `handleMessage()` execution, as we can see in
    the following stack trace:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当我们的`handleMessage()`被调度时，它打印出`handleMessage()`执行时的活动堆栈帧，正如我们可以在下面的堆栈跟踪中看到的那样：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's right, `handleMesage()` is running in the `dispatchMessage()` call invoked
    by the main `Looper`, and it is dispatched to the main thread's line of execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，`handleMesage()`是在由主`Looper`调用的`dispatchMessage()`调用中运行的，并且它被调度到主线程的执行行。
- en: Sending work to a Looper
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Looper发送工作
- en: Previously, the `StackTraceHandler` was implicitly bound to the current main
    thread's `Looper`, so to make it flexible, let's take the next step and make it
    attachable to any `Looper`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，`StackTraceHandler`隐式地绑定到当前主线程的`Looper`，因此为了使其更灵活，让我们再迈出一步，使其可以附加到任何`Looper`。
- en: 'In the following code, we are going to override the default `Handler` constructor
    and define a constructor that accepts the `Looper` that is going to the queue,
    and we will then process and dispatch the message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将重写默认的`Handler`构造函数并定义一个接受将要进入队列的`Looper`的构造函数，然后我们将处理和调度消息：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our new constructor basically attaches the Handler to the `Looper` passed as
    an argument, making the `StackTraceHandler` attachable to any `Looper` instead
    of the current thread's `Looper`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新构造函数基本上是将处理器（Handler）附加到作为参数传递的`Looper`，使得`StackTraceHandler`可以附加到任何`Looper`，而不是当前线程的`Looper`。
- en: 'Our `SimpleLooper` was also extended to provide a `getter` method to retrieve
    the `Looper` object associated with its thread:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SimpleLooper`也被扩展以提供`getter`方法来检索与其线程关联的`Looper`对象：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, from the main thread, we start the `SimpleLooper` and its own thread,
    and when it starts up, we get the `Looper` instance to bind our `Handler` to the
    `SimpleLooper` thread and `Looper`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从主线程开始，我们启动`SimpleLooper`及其自己的线程，当它启动时，我们获取`Looper`实例以将我们的`Handler`绑定到`SimpleLooper`线程和`Looper`：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we are going to send the message, as we did in the previous example, from
    the activity''s `onCreate()` callback, which runs in the main thread:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将像上一个示例中那样，从活动的`onCreate()`回调中发送消息，该回调在主线程中运行：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see in the following stack trace, the thread stack frame at the bottom
    points to `SimpleLooper.run()`, and at the top of the stack trace, we have our
    `Handler` callback, `StackTraceHandler.handleMessage`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下堆栈跟踪所示，堆栈底部的线程堆栈帧指向 `SimpleLooper.run()`，而在堆栈顶部，我们有我们的 `Handler` 回调，`StackTraceHandler.handleMessage`：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The interesting thing to realize here is that we can send messages from the
    main thread to the background thread managed by `SimpleLooper` (or even from the
    background thread to the main thread) and, in doing so, hand over work from background
    threads to the main thread—for example, to have it update the user interface with
    the results of background processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们可以从主线程向由 `SimpleLooper` 管理的后台线程（甚至从后台线程向主线程）发送消息，并且在这个过程中，将后台线程的工作交给主线程——例如，用后台处理的结果更新用户界面。
- en: Scheduling work with post
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `post` 安排工作
- en: As we discussed in the previous paragraph, we can submit work to the main or
    background thread by passing a reference to a `Looper` instance into the `Handler`
    constructor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段所述，我们可以通过将 `Looper` 实例的引用传递给 `Handler` 构造函数来将工作提交给主线程或后台线程。
- en: Exactly what we mean by work can be described by the subclasses of `java.lang.Runnable`
    or instances of `android.os.Message`. We can post runnables to a `Handler` instance
    or send messages to it, and it will add them to the `MessageQueue` belonging to
    the associated `Looper` instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“工作”可以通过 `java.lang.Runnable` 的子类或 `android.os.Message` 的实例来描述。我们可以将 `Runnable`
    发布到 `Handler` 实例或向其发送消息，它将它们添加到相关 `Looper` 实例的 `MessageQueue` 中。
- en: 'We can post work to a `Handler` quite easily, for example, by creating an anonymous
    inner runnable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将工作发布到 `Handler`，例如，通过创建一个匿名内部 `Runnable`：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Looper` instance to which the `Handler` is bound works its way through
    the queue, executing each `Runnable` as soon as possible. Posting with the `post`
    method simply adds a new `Runnable` at the end of the queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定 `Handler` 的 `Looper` 实例会遍历队列，尽可能快地执行每个 `Runnable`。使用 `post` 方法简单地在队列末尾添加一个新的
    `Runnable`。
- en: 'If we want our runnable to take priority over anything currently in the queue,
    we can post it to the front of the queue, ahead of existing work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的 `Runnable` 在队列中的任何现有工作之上具有优先级，我们可以将其发布到队列的前面，在现有工作之前：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In a single-threaded app, it might seem as if there isn't a whole lot to be
    gained from posting work to the main thread like this, but breaking things down
    into small tasks that can be interleaved and potentially reordered is very useful
    for maintaining responsiveness.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程应用程序中，可能看起来通过将工作发布到主线程并没有获得太多好处，但将事情分解成可以交错和可能重新排序的小任务对于保持响应性非常有用。
- en: 'Moreover, with the encapsulation of work into more fine-grained units of work,
    we encourage the reuse of components, improve the testability of the code, and
    increase the aptitude for work composition:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过将工作封装成更细粒度的工作单元，我们鼓励组件的重用，提高代码的可测试性，并增加工作组合的能力：
- en: '![Scheduling work with post](img/Image_B05062_02_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用 `post` 安排工作](img/Image_B05062_02_02.jpg)'
- en: 'Figure 2.2: Runnable composition'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：`Runnable` 组合
- en: Using Handler to defer work
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Handler` 延迟工作
- en: When we use the normal `post` work function, the work is processed as soon as
    all the previous units of work are processed on the `Looper`—but what happens
    if we want to schedule some work in 10 seconds' time?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用正常的 `post` 工作函数时，工作会在所有之前的单元工作在 `Looper` 上处理完毕后立即处理——但如果我们想在10秒后安排一些工作，会发生什么呢？
- en: 'Using `Thread.sleep` to block the main thread for 10 seconds would mean that
    we are holding up the main thread from doing other work, and we are guaranteed
    to get an ANR dialog. The alternative is to use the handler functions that supply
    us with deferring functionality:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Thread.sleep` 来阻塞主线程10秒意味着我们阻止主线程执行其他工作，并且我们保证会得到一个ANR对话框。另一种选择是使用提供延迟功能的处理程序函数：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can still post additional work for execution in the meantime, and our delayed
    `Runnable` instance will execute after the specified delay. Note that we're using
    the `TimeUnit` class from the `java.lang.concurrent` package to convert seconds
    to milliseconds.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以在同时发布其他工作以供执行，并且我们的延迟 `Runnable` 实例将在指定的延迟后执行。注意，我们正在使用 `java.lang.concurrent`
    包中的 `TimeUnit` 类将秒转换为毫秒。
- en: 'A further scheduling option for posted work is `postAtTime`, which schedules
    `Runnable` to execute at a particular time relative to the system uptime (how
    long it has been since the system booted):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发布工作的一个进一步调度选项是`postAtTime`，它将`Runnable`调度到相对于系统运行时间的特定时间（自系统启动以来经过的时间）执行：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since `postAtTime()` is implemented in terms of an offset from the `SystemClock`
    uptime, the scheduling could suffer from some delay issues, especially if the
    device has recently fallen in some deep-sleep states. Taking this into account,
    and when timing accuracy is required, it is usually better to use `handler.postDelayed`
    to defer work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`postAtTime()`是通过从`SystemClock`的运行时间偏移量实现的，因此调度可能会受到一些延迟问题的影响，尤其是在设备最近进入某些深度睡眠状态时。考虑到这一点，并且当需要时间精度时，通常最好使用`handler.postDelayed`来延迟工作。
- en: Leaking implicit references
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏露隐式引用
- en: Deferring work with `Handler` and anonymous or nonstatic nested classes requires
    care in order to avoid potential resource leakage. In these cases, the object
    submitted to the handler usually creates a reference to the class where it was
    defined or created. Since the Looper message queue will keep the `Runnable` object
    alive until the scheduled time, an indirect reference to the original Android
    component could prevent an entire component and its objects from being garbage-collected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Handler`和匿名或非静态嵌套类延迟工作需要小心，以避免潜在的资源泄漏。在这些情况下，提交给处理器的对象通常创建了对它定义或创建的类的引用。由于Looper消息队列将保持`Runnable`对象在计划时间内的活动状态，对原始Android组件的间接引用可能会阻止整个组件及其对象被垃圾回收。
- en: 'Let''s look at this issue with the following examples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来分析这个问题：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both objects, the `MyRunnable` object created over his default constructor and
    the anonymous `Runnable` class created on the second `handler.postDelayed`, hold
    a reference to the `Activity` object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象，即通过默认构造函数创建的`MyRunnable`对象和在第二个`handler.postDelayed`中创建的匿名`Runnable`类，都持有`Activity`对象的引用。
- en: By declaring an anonymous inner `Runnable` inside an activity, we have made
    an implicit reference to that containing `Activity` instance. We've then posted
    the `Runnable` to a handler and told it to execute in 10 minutes' time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在活动内部声明一个匿名内部`Runnable`，我们已经对该包含`Activity`实例创建了隐式引用。然后我们向处理器发送了`Runnable`，并告诉它在10分钟后执行。
- en: If the activity finishes before the 10 minutes are up, it cannot yet be garbage-collected
    because the implicit reference in our runnable means that the activity is still
    reachable by live objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果活动在10分钟内完成，它还不能被垃圾回收，因为我们的`Runnable`中的隐式引用意味着活动仍然可以通过活动对象访问。
- en: So, although it makes for a concise example, it is not a good idea in practice
    to post non-static Runnables onto the main thread's `Handler` queue (especially
    with `postDelayed` or `postAtTime`) unless we're very careful to clean up after
    ourselves all the references to the inactive Activities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管这只是一个简洁的例子，但在实践中将非静态的Runnables发布到主线程的`Handler`队列（尤其是使用`postDelayed`或`postAtTime`）并不是一个好主意，除非我们非常小心地清理所有不活跃活动的引用。
- en: If the `MyActivity` object is not garbage-collected in 10 minutes, a memory
    leak with all the activity views and resources will increase your memory consumption
    until you reach the maximum heap space per application available. Worse, if you
    create several instances of this activity when the user navigates through the
    application, the application will run out of memory in a snap.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MyActivity`对象在10分钟内没有被垃圾回收，所有活动视图和资源将导致内存消耗增加，直到达到每个应用程序可用的最大堆空间。更糟糕的是，如果用户在应用程序中导航时创建了多个此活动实例，应用程序将瞬间耗尽内存。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The heap size limit available per application varies from device to device.
    When an application reaches this limit, the system will throw an `OutOfMemoryError`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序可用的堆大小限制因设备而异。当应用程序达到这个限制时，系统将抛出`OutOfMemoryError`异常。
- en: 'One way to minimize this problem is to use static nested classes or top-level
    classes in their own files (direct member of a package) to remove the reference
    to the original `Activity` object when we create a deferred `Runnable` work task.
    This means that references must be explicit, which makes them easier to spot and
    nullify:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 减少这种问题的一种方法是在创建延迟的`Runnable`工作任务时，使用静态嵌套类或顶级类（它们自己的文件中的直接成员）来移除对原始`Activity`对象的引用。这意味着引用必须是显式的，这使得它们更容易被发现和置空：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Leaking explicit references
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏露显式引用
- en: 'If we are to interact with the user interface, we''ll at least need a reference
    to an object in the `View` hierarchy, which we might pass into our static or top-level
    runnable''s constructor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要与用户界面交互，我们至少需要一个指向`View`层次结构中对象的引用，我们可能将其传递到我们的静态或顶级可运行对象的构造函数中：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, by keeping a strong reference to the `View`, we are again subject to
    potential memory leaks if our `Runnable` outlives the `View`; for example, if
    some other part of our code removes this `View` from the display before our `Runnable`
    executes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们保持了对`View`的强引用，如果我们的`Runnable`比`View`存活时间更长，我们再次面临潜在的内存泄漏问题；例如，如果我们的`Runnable`执行之前，代码的某个其他部分已经将这个`View`从显示中移除。
- en: 'One solution to this is to use a weak reference and check for `null` before
    using the referenced `View`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用弱引用并在使用引用的`View`之前检查`null`：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you haven't used `WeakReference` before, what it gives us is a way to refer
    to an object only for as long as some other live object has a stronger reference
    to it (for example, a normal property reference).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过`WeakReference`，它为我们提供了一种方式，即只有当其他活动对象对它的引用更强（例如，一个普通的属性引用）时，我们才能引用一个对象（例如，一个普通的属性引用）。
- en: When all strong references are garbage-collected, our `WeakReference` will also
    lose its reference to the `View`, `get()` will return `null`, and the `View` will
    be garbage-collected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有强引用都被垃圾回收时，我们的`WeakReference`也会失去对`View`的引用，`get()`将返回`null`，`View`将被垃圾回收。
- en: This fixes the resource leakage problem, but we must always check for `null`
    before using the returned object in order to avoid potential `NullPointerException`
    instances.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了资源泄漏问题，但我们必须在使用返回的对象之前始终检查`null`，以避免潜在的`NullPointerException`实例。
- en: 'If we''re sending messages to our `Handler` and expecting it to update the
    user interface, it will also need a reference to the view hierarchy. A nice way
    to manage this is to attach and detach the `Handler` from `onResume` and `onPause`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`Handler`发送消息并期望它更新用户界面，它也需要一个指向视图层次结构的引用。一种很好的管理方式是在`onResume`和`onPause`中附加和分离`Handler`：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Updating the UI with Handler
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Handler更新UI
- en: 'Since we instantiated our handler in the main thread, all work submitted to
    it executes on the main thread. This means that we must not submit long-running
    operations to this particular handler, but we can safely interact with the user
    interface:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在主线程中实例化了我们的handler，因此提交给它的所有工作都在主线程上执行。这意味着我们不应该向这个特定的handler提交长时间运行的操作，但我们可以安全地与用户界面交互：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This applies regardless of which thread posts the `Runnable`, which makes `Handler`
    an ideal way to send the results of work performed by other threads to the main
    thread:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于无论哪个线程提交`Runnable`，这使得`Handler`成为将其他线程执行的工作结果发送到主线程的理想方式：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you start your own threads for background work, make sure to set the priority
    to `Thread.MIN_PRIORITY` to avoid starving the main thread of CPU time. The system
    CPU scheduler will give more CPU cycle times to threads with higher priority.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为后台工作启动自己的线程，请确保将其优先级设置为`Thread.MIN_PRIORITY`，以避免耗尽主线程的CPU时间。系统CPU调度器会给优先级更高的线程更多的CPU周期时间。
- en: '`Handler` is so fundamental that its API is integrated right into the `View`
    class''s member functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler`如此基本，以至于其API已经集成到`View`类的成员函数中：'
- en: '`View.post(Runnable)`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.post(Runnable)`。'
- en: '`View.postDelayed(action,delayMillis)`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.postDelayed(action,delayMillis)`。'
- en: 'So, we can rewrite the previous example as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将之前的示例重写如下：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When writing code in an `Activity` class, there is an alternative way to submit
    a `Runnable` on the main thread using the `runOnUiThread(Runnable)` method of
    `Activity`, as explained in the previous chapter. If the current thread is the
    UI thread, then the action is executed immediately. If the current thread is not
    the UI thread, the action is posted to the event queue of the main UI thread.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Activity`类中编写代码时，可以使用`Activity`的`runOnUiThread(Runnable)`方法提交主线程上的`Runnable`，正如前一章所解释的。如果当前线程是UI线程，则操作会立即执行。如果当前线程不是UI线程，则操作会被发送到主UI线程的事件队列。
- en: Canceling a pending Runnable
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消挂起的Runnable
- en: 'During your application execution, you could have a situation where you want
    to cancel a posted `Runnable`, for instance, when you submit a deferred task on
    your activity''s `onCreate()` and you want to cancel it when you are executing
    `onDestroy()` because the activity is going to be destroyed. The `Handler` function
    `removeCallbacks()` can cancel a pending operation by removing a posted `Runnable`
    task from the queue of work:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序执行过程中，你可能会有想要取消已发布`Runnable`的情况，例如，当你在一个活动的`onCreate()`中提交一个延迟任务，并且当你执行`onDestroy()`时想要取消它，因为活动将被销毁。`Handler`函数`removeCallbacks()`可以通过从工作队列中移除已发布的`Runnable`任务来取消挂起的操作：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that in order to be able to specify what to remove, we must keep a reference
    to the `Runnable` instance, and that cancelation applies only to pending tasks—it
    does not attempt to stop a `Runnable` that is already mid-execution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了能够指定要移除的内容，我们必须保留对`Runnable`实例的引用，并且取消操作仅适用于挂起的任务——它不会尝试停止正在执行中的`Runnable`。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Keep in mind that if you post the same object more than one time, `removeCallbacks()`
    will remove all the non-running entries that reference that object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您多次发布同一个对象，`removeCallbacks()`将移除所有引用该对象的非运行条目。
- en: Scheduling work with send
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用发送进行工作调度
- en: When we post a `Runnable`, we can—as seen in the previous examples—define the
    work at the local or member scope with an anonymous `Runnable`. As such, the `Handler`
    does not know in advance what kind of work it might be asked to perform.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发布一个`Runnable`时，我们可以像前例中看到的那样，在局部或成员范围内使用匿名`Runnable`定义工作。因此，`Handler`事先不知道可能被要求执行哪种类型的工作。
- en: If we often need to perform the same work from different scopes, we could define
    a static or top-level `Runnable` class that we can instantiate from anywhere in
    our application's lifecycle.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常需要从不同的范围执行相同的工作，我们可以定义一个静态或顶级`Runnable`类，我们可以在应用程序的生命周期中的任何地方实例化它。
- en: Alternatively, we can turn the approach on its head by sending messages to a
    `Handler` and defining the `Handler` to react appropriately to different messages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过向`Handler`发送消息并定义`Handler`以适当地对不同消息做出反应来颠倒这种做法。
- en: 'Taking a simple example, let''s say we want our `Handler` to display `hello`
    or `goodbye`, depending on the type of message it receives. To do that, we''ll
    extend `Handler` and override its `handleMessage()` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，假设我们想让我们的`Handler`根据接收到的消息类型显示`hello`或`goodbye`。为了做到这一点，我们将扩展`Handler`并重写其`handleMessage()`方法：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we've implemented the `handleMessage()` method to expect messages with
    two different `what` values and react accordingly. Apart from the `what` property,
    which is used to identify what the message is about, the message object provides
    three extra integer fields, `arg`, `arg2`, and `obj`, which can be used to identify
    and specify your message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现了`handleMessage()`方法，以期望具有两个不同`what`值的消息，并相应地做出反应。除了用于标识消息内容的`what`属性外，消息对象还提供了三个额外的整数字段`arg`、`arg2`和`obj`，可以用来标识和指定你的消息。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If you look carefully at the `Speak` handler class example explained earlier,
    you'll notice that we defined it as a static class. Subclasses of `Handler` should
    always be declared as top-level or static inner classes to avoid inadvertent memory
    leaks!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看前面解释的`Speak`处理器类示例，你会注意到我们将其定义为静态类。`Handler`的子类应始终声明为顶级或静态内部类，以避免意外的内存泄漏！
- en: 'To bind an instance of our `Handler` to the main thread, we simply instantiate
    it from any method that runs on the main thread, such as the `Activity onCreate()`
    callback:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`Handler`实例绑定到主线程，我们只需从任何在主线程上运行的方法中实例化它，例如`Activity onCreate()`回调：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remember that we can send messages to this `Handler` from any thread, and they
    will be processed by the main thread. We send messages to our `Handler`, as shown
    here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以从任何线程向这个`Handler`发送消息，它们将由主线程处理。我们向我们的`Handler`发送消息，如下所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we post a message over the previous method, the `Handler` will create a
    message for us, fill in the message's `what` property with the integer passed
    in, and post the message to the handler's `Looper` queue. This construct could
    be extremely useful when we need to send basic commands to a handler, although
    when we need more complex messages, we need to use other message properties, such
    as `arg1`, `arg2`, and `obj`, to carry more information about our request.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过之前的方法发布消息时，`Handler`会为我们创建一个消息，将消息的`what`属性填充为传入的整数，并将消息发布到处理器的`Looper`队列。当我们需要向处理器发送基本命令时，这种结构可能非常有用，尽管当我们需要更复杂的消息时，我们需要使用其他消息属性，如`arg1`、`arg2`和`obj`，来携带更多关于我们请求的信息。
- en: 'As messages may carry an object payload as the context for the execution of
    a message, let''s extend our example to allow our `Handler` to say any word that
    the message sender wants:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息可能携带一个对象有效负载作为消息执行的上下文，让我们扩展我们的示例，允许我们的`Handler`说出消息发送者想要说的任何词：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within our `handleMessage` method, we can access the payload of the message
    directly by accessing the public `obj` property. The `Message` payload can be
    set easily via alternative static `obtain` methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`handleMessage`方法中，我们可以通过访问公共的`obj`属性直接访问消息的有效负载。`Message`有效负载可以通过替代的静态`obtain`方法轻松设置：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous example, we basically create a message that the `what` property
    is `SAY_WORD` and the `obj` property is `Welcome!`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们基本上创建了一条消息，其中`what`属性是`SAY_WORD`，而`obj`属性是`Welcome!`。
- en: While it should be quite clear what this code is doing, you might be wondering
    why we didn't create a new instance of `Message` by invoking its constructor and
    instead invoked its static method, `obtain`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码的功能应该相当清晰，但你可能想知道为什么我们没有通过调用其构造函数来创建一个新的`Message`实例，而是调用了它的静态方法`obtain`。
- en: The reason is efficiency. Messages are used only briefly—we instantiate, dispatch,
    handle, and then discard them. So, if we create new instances each time, we are
    creating work for the garbage collector.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是效率。消息仅被短暂使用——我们实例化、分发、处理，然后丢弃它们。因此，如果我们每次都创建新的实例，我们就是在为垃圾回收器创造工作。
- en: Garbage collection is expensive, and the Android platform goes out of its way
    to minimize object allocation whenever it can. While we can instantiate a new
    `Message` object if we wish, the recommended approach is to obtain one that reuses
    `Message` instances from a pool and cuts down on garbage collection overhead.
    By reducing the memory footprint, fewer objects are recycled, leading to faster
    and less frequent garbage collection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是昂贵的，Android平台会尽力在可能的情况下最小化对象分配。虽然我们可以根据需要实例化一个新的`Message`对象，但推荐的方法是获取一个从池中重用`Message`实例的实例，从而减少垃圾回收的开销。通过减少内存占用，可以回收
    fewer 对象，从而实现更快和更频繁的垃圾回收。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In cases where you can build your messages over low-cost integer arguments,
    you should use them instead of complex arguments such as `obj` or `data`, which
    always create extra work for the GC.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用低成本整数参数构建消息的情况下，你应该使用它们，而不是像`obj`或`data`这样的复杂参数，这些参数总是为GC创造额外的工作。
- en: 'Just as we can schedule runnables with variants of the `post` method, we can
    schedule messages with variants of `send`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以使用`post`方法的变体来安排可运行对象一样，我们也可以使用`send`方法的变体来安排消息：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are also empty-message variants for convenience, when we don''t have
    a payload:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，也存在空消息变体，当我们没有有效负载时：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cancelling pending messages
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消挂起的消息
- en: 'Canceling sent messages is also possible and actually easier than canceling
    posted runnables because we don''t have to keep a reference to the messages that
    we might want to cancel—instead, we can just cancel messages by their `what` values
    or by the `what` value and object reference:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 取消已发送的消息也是可能的，实际上比取消已发布的可运行对象更容易，因为我们不需要保留我们可能想要取消的消息的引用——相反，我们可以通过它们的`what`值或`what`值和对象引用来取消消息：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that just as with posted runnables, message cancellation only removes pending
    operations from the queue—it does not attempt to stop an operation already being
    executed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像已发布的可运行对象一样，消息取消仅从队列中移除挂起的操作——它不会尝试停止正在执行的操作。
- en: 'Besides the canceling functionality, the handler also provides functions to
    verify whether there are any pending messages in the queue. With the handler object
    in hand, we can query the handler by the message''s `what` value, `hasMessages(what)`,
    and by the `hasMethods(what,object)` message object value. Let''s put some examples
    together with our previous examples:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了取消功能之外，handler还提供了验证队列中是否有挂起消息的功能。有了handler对象，我们可以通过消息的`what`值（`hasMessages(what)`）和`hasMethods(what,object)`消息对象值来查询handler。让我们结合之前的例子来放一些例子：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first example will verify whether there is any message whose `what` code
    is `SAY_BYE`, and the second will verify whether there is any message whose `what`
    code is `SAY_WORD` and whose object points to the same reference as `myWord`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将验证是否存在任何`what`代码为`SAY_BYE`的消息，第二个例子将验证是否存在任何`what`代码为`SAY_WORD`且对象指向与`myWord`相同引用的消息。
- en: 'It is really important to remember that the `removeMessages` and `hasMessages`
    methods with an object argument will search the queue, comparing the object by
    the `==` reference comparison and not a comparison of object values such as `(equals())`.
    Here is a simple example to explain the situation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 真的非常重要，要记住，带有对象参数的`removeMessages`和`hasMessages`方法将会在队列中搜索，通过`==`引用比较而不是对象值比较（如`(equals())`）来比较对象。这里有一个简单的例子来解释这种情况：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As explained before, the second `remove` invocation will not remove the message
    added previously, because the `stringRef1` reference is different from the new
    reference passed in, despite the string content being the same.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第二次`remove`调用不会移除之前添加的消息，因为`stringRef1`引用与传入的新引用不同，尽管字符串内容相同。
- en: 'Here is the output from the looper dump, with the message that was not canceled
    successfully:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是looper转储的输出，其中包含未成功取消的消息：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Composition versus inheritance
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合与继承
- en: 'So far, we''ve subclassed `Handler` to override its `handleMessage` method,
    but that isn''t our only option. We can favor composition over inheritance by
    passing an instance of `Handler.Callback` during handler construction:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过重写`Handler`的`handleMessage`方法来子类化`Handler`，但这并不是我们的唯一选择。我们可以在构造`Handler`时通过传递`Handler.Callback`的实例来优先考虑组合而不是继承：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s suppose we want to extend our speaker without changing the original
    `Handler`, and we want to add new actions over a `Handler.Callback` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要扩展我们的演讲者而不改变原始的`Handler`，并且我们想在`Handler.Callback`类上添加新的操作：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice that the signature of `handleMessage` is slightly different here—we
    must return a `boolean` value indicating whether or not the `Message` was handled.
    To create a `Handler` that uses our extension, we simply pass the `Handler.Callback`
    implementation during handler construction:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的`handleMessage`签名略有不同——我们必须返回一个`boolean`值，表示是否处理了`Message`。要创建使用我们扩展的`Handler`，我们只需在构造`Handler`时传递`Handler.Callback`实现：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we return `false` from the `handleMessage` method of our callback, the Handler
    will invoke its own `handleMessage` method, so we could choose to use a combination
    of inheritance and composition to implement the default behavior in a `Handler`
    subclass and then mix in special behavior by passing in an instance of `Handler.Callback`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从回调的`handleMessage`方法返回`false`，Handler将调用它自己的`handleMessage`方法，因此我们可以选择使用继承和组合的组合来实现`Handler`子类中的默认行为，并通过传递`Handler.Callback`的实例来混合特殊行为。
- en: 'In the aforementioned code, we use the composition to process the `SAY_HELLO`
    message and the inheritance to process the `SAY_YES` message:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用组合来处理`SAY_HELLO`消息，使用继承来处理`SAY_YES`消息：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Inheritance** should only be used when the relationship between a subclass
    and the superclass is permanent and strong and can''t be decoupled. On the other
    hand, **composition** offers more flexibility for enhancements and testing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**应该只在子类与超类之间的关系是永久且强烈，并且不能解耦时使用。另一方面，**组合**提供了更多增强和测试的灵活性。'
- en: Multithreading with Handler and ThreadHandler
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Handler和ThreadHandler进行多线程
- en: In a typical Android asynchronous application, the UI thread hands over long
    computing operations to a background thread, which in turn executes the task and
    posts back the results to the main thread.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Android异步应用程序中，UI线程将长时间计算操作交给后台线程，该线程随后执行任务并将结果回传到主线程。
- en: So far, we have just used the `Handler` to send messages to the main thread,
    so the next natural step is to design a multithreaded scenario where the `interthread`
    communication is managed by the `Handler` construct.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是使用`Handler`向主线程发送消息，所以下一步自然的步骤是设计一个多线程场景，其中`interthread`通信由`Handler`结构管理。
- en: Let's extend our previous examples and create a weather forecast retriever.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们之前的示例，创建一个天气预报检索器。
- en: 'Imagine this scenario: when we click on a UI button, the main thread will ask
    for our background thread to retrieve the weather forecast and, when the weather
    forecast response is received, the background thread will ask the main thread
    to present the weather forecast received.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这个场景：当我们点击UI按钮时，主线程将请求我们的后台线程检索天气预报，当收到天气预报响应时，后台线程将请求主线程展示收到的天气预报。
- en: We will start by creating the `WeatherRetriever` that is responsible for receiving
    the weather forecast requests and then retrieve the forecast sentence and post
    back the result to the `mainHandler` object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`WeatherRetriever`，它负责接收天气预测请求，然后检索预测句子并将结果回传给`mainHandler`对象。
- en: During the scenario assembly, the `WeatherRetriever` handler is attached to
    a background `Looper` over the first constructor argument in order to execute
    in a separate line of execution away from the main thread. The second constructor
    argument is used to set the handler to post the results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景组装过程中，`WeatherRetriever`处理器通过第一个构造函数参数附加到后台`Looper`上，以便在主线程之外单独的执行线上执行。第二个构造函数参数用于设置处理器以发布结果。
- en: On the `handleMessage` method, the handler is able to process the current day's
    forecast message requests (`GET_TODAY_FORECAST`) or the next day's requests (`GET_TOMORROW_FORECAST`),
    eventually calling the long-computing `getForecast()` operation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleMessage`方法中，处理器能够处理当前日的预测消息请求（`GET_TODAY_FORECAST`）或下一日的请求（`GET_TOMORROW_FORECAST`），最终调用长时间计算的`getForecast()`操作。
- en: 'The long-computing `getForecast()` could block the thread execution for a long
    time, but this is not a problem anymore, since we are going to run it in a background
    thread with lower priority, which does not block the UI from being rendered in
    time, and hence prevents an ANR error from occurring and makes the application
    more responsive to user interactions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间计算的`getForecast()`可能会长时间阻塞线程执行，但这个问题现在不再是问题，因为我们将在一个优先级较低的背景线程中运行它，这样就不会阻塞UI及时渲染，从而防止ANR错误的发生，并使应用程序对用户交互更加响应：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Secondly, we will build the `WeatherPresenter`, which will handle the forecast
    results coming from the background operation, presenting it to the user on the
    main thread:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将构建`WeatherPresenter`，它将处理来自后台操作的结果，在主线程上向用户展示：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We described one way of setting up a `Looper` thread with the `SimpleLooper`
    class, detailed earlier in this chapter, but there''s an easier way, using a class
    provided by the SDK for exactly this purpose: `android.os.HandlerThread`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面详细描述了使用`SimpleLooper`类设置`Looper`线程的一种方法，但还有一种更简单的方法，使用SDK提供的专门为此目的而设计的类：`android.os.HandlerThread`。
- en: 'When we create a `HandlerThread`, we specify two things: a name for the thread,
    which can be helpful when debugging, and its priority, which must be selected
    from the set of static values in the `android.os.Process` class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个`HandlerThread`时，我们指定两件事：线程的名称，这在调试时可能很有帮助，以及其优先级，这必须从`android.os.Process`类的静态值集中选择：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Thread priorities in Android are mapped into Linux nice levels, which govern
    how often a thread gets to run. A niceness of `−20` is the highest priority, and
    `19` is the lowest priority. The default nice level is `0`. In addition to prioritization,
    Android limits CPU resources using Linux cgroups. Threads that are of background
    priority are moved into the `bg_non_interactive` cgroup, which is limited to 5
    percent of available CPU if threads in other groups are busy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的线程优先级映射到Linux的nice级别，这决定了线程运行频率。`-20`的niceness是最高优先级，而`19`是最低优先级。默认的niceness级别是`0`。除了优先级之外，Android还使用Linux
    cgroups限制CPU资源。具有后台优先级的线程会被移动到`bg_non_interactive` cgroup中，如果其他组的线程忙碌，则该cgroup仅限于可用CPU的5%。
- en: Adding `THREAD_PRIORITY_MORE_FAVORABLE` to `THREAD_PRIORITY_BACKGROUND` when
    configuring your `HandlerThread` moves the thread into the default cgroup, but
    always consider whether it is really necessary—it often isn't!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置`HandlerThread`时添加`THREAD_PRIORITY_MORE_FAVORABLE`到`THREAD_PRIORITY_BACKGROUND`会将线程移动到默认的cgroup，但始终考虑这是否真的必要——通常并不是！
- en: 'In the the next table, the mapping from Android thread priority to Linux nice
    levels is detailed; however, the use of nice levels lower than **-2** in regular
    applications is not recommended:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个表中，详细说明了从Android线程优先级到Linux nice级别的映射；然而，在常规应用程序中不建议使用低于**-2**的nice级别：
- en: '| Java priority | Thread priority | Nice level |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Java优先级 | 线程优先级 | Nice级别 |'
- en: '| --- | --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | THREAD_PRIORITY_URGENT_AUDIO | -19 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|   | THREAD_PRIORITY_URGENT_AUDIO | -19 |'
- en: '|   | THREAD_PRIORITY_AUDIO | -16 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|   | THREAD_PRIORITY_AUDIO | -16 |'
- en: '| MAX_PRIORITY | THREAD_PRIORITY_URGENT_DISPLAY | -8 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| MAX_PRIORITY | THREAD_PRIORITY_URGENT_DISPLAY | -8 |'
- en: '|   | THREAD_PRIORITY_DISPLAY | -4 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|   | THREAD_PRIORITY_DISPLAY | -4 |'
- en: '|   | THREAD_PRIORITY_FOREGROUND | -2 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|   | THREAD_PRIORITY_FOREGROUND | -2 |'
- en: '| NORM_PRIORITY | THREAD_PRIORITY_DEFAULT | 0 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| NORM_PRIORITY | THREAD_PRIORITY_DEFAULT | 0 |'
- en: '|   | THREAD_PRIORITY_BACKGROUND | 10 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   | THREAD_PRIORITY_BACKGROUND | 10 |'
- en: '| MIN_PRIORITY | THREAD_PRIORITY_LOWEST | 19 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| MIN_PRIORITY | THREAD_PRIORITY_LOWEST | 19 |'
- en: '`HandlerThread` extends `java.lang.Thread`, and we must start it with `start()`before
    it actually begins processing its queue:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerThread`扩展了`java.lang.Thread`，我们必须在它实际开始处理其队列之前使用`start()`启动它：'
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, from an `Activity` callback, we are going to detail how to lift up our
    scenario, building all the instances and objects required to submit and process
    requests:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从一个`Activity`回调中，我们将详细说明如何提升我们的场景，构建提交和处理请求所需的所有实例和对象：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we saw previously, the retriever handler is using the `HandlerThread's Looper`
    instead of the main thread's `Looper`, so it processes the forecast requests on
    a background thread, allowing us to run long-computing operations on the `WeatherRetriever`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，检索器处理程序正在使用`HandlerThread`的`Looper`而不是主线程的`Looper`，因此它在后台线程上处理预测请求，允许我们在`WeatherRetriever`上运行长时间计算操作。
- en: 'With a `WeatherRetriever` object (`retHandler`) reference in our hands, we
    are able to enqueue a new forecast request to the background thread by sending
    a message with the `WeatherRetriever` handler. In the next example, we listen
    for taps on the UI''s `today` button in order to initiate a forecast request:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手中持有`WeatherRetriever`对象（`retHandler`）引用，能够通过发送带有`WeatherRetriever`处理器的消息将新的预测请求入队到后台线程。在下一个示例中，我们监听UI的`today`按钮的点击以启动预测请求：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the forecast is processed by the background thread on the `WeatherRetriever`
    callback, a message is dispatched to the main `Looper` through the `WeatherPresenter`
    reference, and `readTodayWeather(String)` is invoked on the main thread in order
    to present the forecast to the user.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`WeatherRetriever`回调的背景线程处理预测时，会通过`WeatherPresenter`引用将消息发送到主`Looper`，并在主线程上调用`readTodayWeather(String)`以向用户展示预测。
- en: 'As you can see in the following trace output, the forecast retriever runs on
    the low-priority background thread with TID `120`, and the forecast result is
    presented on the main UI thread, which has a TID of `1`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下跟踪输出所示，预测检索器在低优先级的背景线程上运行，TID为`120`，而预测结果则在TID为`1`的主UI线程上展示：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we create a `HandlerThread` to do background work for a specific `Activity`,
    we will want to tie the `HandlerThread` instance's life cycle closely to that
    of the activity's to prevent resource leaks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个`HandlerThread`为特定的`Activity`执行后台工作，我们希望将`HandlerThread`实例的生命周期紧密绑定到活动上，以防止资源泄漏。
- en: 'A `HandlerThread` can be shut down by invoking `quit()`, which will stop the
    `HandlerThread` from processing any more work from its queue. A `quitSafely` method
    was added at API level 18, which causes the `HandlerThread` to process all remaining
    tasks before shutting down. Once a `HandlerThread` has been told to shut down,
    it will not accept any further tasks:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`quit()`来关闭`HandlerThread`，这将停止`HandlerThread`处理其队列中的任何更多工作。API级别18添加了`quitSafely`方法，它会导致`HandlerThread`在关闭前处理所有剩余的任务。一旦`HandlerThread`被告知关闭，它将不接受任何进一步的任务：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Looper message dispatching debugging
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Looper消息分发调试
- en: 'When you want to follow the dispatching and processing of your messages, it
    could be handy to print a message in the Android logs when any of your messages
    get routed by the `Looper` and when the handler finishes the processing. The `Looper`
    object supplies us with a method to set a printer facility for the message-dispatching
    debugging, so, from our `HandlerThread`, we are able to set it and enable the
    extra logging required to follow our requests:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想跟踪消息的分发和处理时，当你的任何消息被 `Looper` 路由，以及处理器完成处理时，在 Android 日志中打印一条消息可能很有用。`Looper`
    对象为我们提供了一个设置消息分发调试打印工具的方法，因此，从我们的 `HandlerThread` 中，我们能够设置它并启用跟踪我们的请求所需的额外日志：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is an example of debugging messages printed when our forecast request
    gets processed by the `Looper`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了当我们的预测请求被 `Looper` 处理时打印的调试信息：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The format for the dispatching debug message is `(<Target_Handler>) {Callback_Obj}
    : <what>`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '分发调试信息的格式为 `(<目标_Handler>) {回调对象} : <内容>`。'
- en: In our simple example, we print the messages for the process's standard output
    stream (`java.io.OutputStream`), but in more advanced cases, we can print to any
    kind of `OutputStream` subclass (file, network, and so on).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，我们打印了进程的标准输出流（`java.io.OutputStream`）的消息，但在更复杂的情况下，我们可以打印到任何类型的 `OutputStream`
    子类（文件、网络等）。
- en: Sending messages versus posting runnables
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息与发布可运行对象
- en: It is worth spending a few moments to consider the difference between posting
    runnables and sending messages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花几分钟时间考虑发布可运行对象和发送消息之间的区别。
- en: The runtime difference mostly comes down to efficiency. Creating new instances
    of `Runnable` each time we want our handler to do something adds garbage-collection
    overhead, while sending messages reuses `Message` instances, which are sourced
    from an application-wide pool.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时差异主要在于效率。每次我们想让我们的处理器做些什么时，都创建新的 `Runnable` 实例会增加垃圾收集开销，而发送消息则重用 `Message`
    实例，这些实例来自应用程序范围内的池。
- en: For prototyping and small one-offs, posting runnables is quick and easy, while
    the advantages of sending messages tend to grow with the size of the application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原型设计和小型一次性任务，发布可运行对象既快又简单，而发送消息的优点往往随着应用程序规模的增加而增加。
- en: It should be said that message-sending is more *the Android way* and is used
    throughout the platform to keep garbage to a minimum and apps running smoothly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 应该说，消息发送更符合 Android 的方式，并且在整个平台上用于将垃圾收集量降到最低，使应用程序运行顺畅。
- en: Applications of Handler and HandlerThread
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Handler 和 HandlerThread 的应用
- en: The `Handler` class is incredibly versatile, which makes its range of applications
    very broad.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler` 类非常灵活，这使得其应用范围非常广泛。'
- en: So far, we've looked at `Handler` and `HandlerThread` in the context of the
    `Activity` lifecycle, which constrains the sort of applications where this construct
    might be used—ideally, we do not want to perform long-running operations (more
    than a second or so) at all in this context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在 `Activity` 生命周期的背景下探讨了 `Handler` 和 `HandlerThread`，这限制了此结构可能被使用的应用类型——理想情况下，我们在这个上下文中根本不想执行长时间运行的操作（超过一秒钟）。
- en: With that constraint in mind, good candidate uses include performing calculations,
    string processing, reading and writing small files on the file system, and reading
    or writing to local databases using a background `HandlerThread`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个限制，合适的用途包括执行计算、字符串处理、在文件系统中读取和写入小文件，以及使用后台 `HandlerThread` 读取或写入本地数据库。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to use `Handler` to queue work for the main
    thread and how to use `Looper` to build up a queueing infrastructure for our own
    `Thread`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 `Handler` 为主线程排队工作，以及如何使用 `Looper` 为我们的 `Thread` 构建排队基础设施。
- en: 'We saw the different ways in which we can define work with `Handler`: arbitrary
    work defined at the call site with `Runnable` or predefined work implemented in
    the `Handler` itself and triggered by message-sending.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了使用 `Handler` 定义工作的不同方式：在调用点使用 `Runnable` 定义的任意工作，或者在 `Handler` 本身中实现并触发消息发送的预定义工作。
- en: In the meantime, we learned how to defer work properly without leaking memory
    on the way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们学习了如何正确地推迟工作，而不会在过程中泄漏内存。
- en: We learned how to use `Handler` in a multithreaded application to pass work
    and results back and forth between cooperating threads, performing blocking operations
    on an ordinary background thread and communicating the results back to the main
    thread to update the user interface.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在多线程应用程序中使用`Handler`，以便在协作线程之间传递工作和结果，在普通后台线程上执行阻塞操作，并将结果返回到主线程以更新用户界面。
- en: In the next chapter, we'll start to build responsive applications by applying
    the `AsyncTask` instance to execute work in the background using pools of threads
    and returning progress updates and results to the main thread.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过应用`AsyncTask`实例来构建响应式应用程序，通过使用线程池在后台执行工作，并将进度更新和结果返回到主线程。
