<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designed for Concurrency</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll discuss the most common concurrency design patterns, implemented with coroutines, and how coroutines can synchronize their execution.</p>
<p class="calibre2">Concurrent design patterns help us to manage many tasks at once. Yeah, I know, that's what we did in the last chapter. That's because some of those design patterns are already built into the language. </p>
<p class="calibre2">In this chapter, we'll <span class="calibre7">briefly cover design patterns</span> and other concurrent design patterns that you'll need to implement by yourself, with little effort.</p>
<p class="calibre2">We will be covering the following topics in this chapter:</p>
<ul class="calibre11">
<li class="calibre12">Active Object</li>
<li class="calibre12">Deferred value</li>
<li class="calibre12">Barrier</li>
<li class="calibre12">Scheduler</li>
<li class="calibre12">Pipelines</li>
<li class="calibre12">Fan out</li>
<li class="calibre12">Fan in</li>
<li class="calibre12">Buffered channels</li>
<li class="calibre12">Unbiased select</li>
<li class="calibre12">Mutex</li>
<li class="calibre12">Select on close</li>
<li class="calibre12">Sidekick channel</li>
<li class="calibre12">Deferred channel</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Active Object</h1>
                
            
            <article>
                
<p class="calibre2">This design pattern allows a method to be executed in a safe way on another thread. Guess what else is being executed on another thread?</p>
<p class="calibre2">You're totally right: <kbd class="calibre13">actor()</kbd>.</p>
<p class="calibre2">So, it's one of those design patterns that is already built into the language. Or, to be precise, into one of the accommodating libraries.</p>
<p class="calibre2">We've already seen how to send data to <kbd class="calibre13">actor()</kbd>. But how do we receive data from it? </p>
<p class="calibre2">One way is to supply it with a channel for output:</p>
<pre class="calibre18"><span>fun </span><span>activeActor</span>(out: SendChannel&lt;String&gt;) = <span>actor</span>&lt;Int&gt; <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in this</span>) {<br class="title-page-name"/>        out.send(i.toString().<span>reversed</span>())<br class="title-page-name"/>    }<br class="title-page-name"/>    out.close()<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Remember to close the output channel when you're done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing</h1>
                
            
            <article>
                
<p class="calibre2">To test the <strong class="calibre5">Active Object</strong> pattern, we'll launch two jobs. One will send data to our actor:</p>
<pre class="calibre18"><span>val </span>channel = <span>Channel</span>&lt;String&gt;()<br class="title-page-name"/><span>val </span>actor = <span>activeActor</span>(channel)<br class="title-page-name"/><br class="title-page-name"/><span>val </span>j1 = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>42</span>..<span>53</span>) {<br class="title-page-name"/>        actor.send(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    actor.close()<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">And another will wait for output on the outbound channel:</p>
<pre class="calibre18"><span>val </span>j2 = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span>channel) {<br class="title-page-name"/>        <span>println</span>(i)<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>j1.join()<br class="title-page-name"/>j2.join()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deferred value</h1>
                
            
            <article>
                
<p class="calibre2">We've already met deferred values in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <span class="calibre7"><em class="calibre14">Threads and Coroutines</em>,</span> in the <em class="calibre14">Returning results</em> section. <kbd class="calibre13">Deferred</kbd> is the result of the <kbd class="calibre13">async()</kbd> function, for example. You may also know them as <em class="calibre14">Futures</em> from Java or Scala, or as <em class="calibre14">Promises</em> from JavaScript.</p>
<p class="calibre2">Interestingly enough, Deferred is a <strong class="calibre5">Proxy</strong> design pattern that we've met in previous chapters.</p>
<p class="calibre2">Much as the Kotlin <kbd class="calibre13">Sequence</kbd> is very similar to the Java8 <kbd class="calibre13">Stream</kbd>, Kotlin Deferred is very similar to Java Future. You'll rarely need to create your own Deferred. Usually, you would work with the one returned from <kbd class="calibre13">async().</kbd></p>
<p class="calibre2">In cases where you do need to return a placeholder for a value that would be evaluated in the future, you can do it:</p>
<pre class="calibre18"><span>val </span>deferred = <span class="underline"><strong class="calibre1">CompletableDeferred&lt;String&gt;()</strong></span><br class="title-page-name"/><br class="title-page-name"/><span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(<span>100</span>)<br class="title-page-name"/>    <span>if </span>(Random().nextBoolean()) {<br class="title-page-name"/>        deferred.<span class="underline"><strong class="calibre1">complete</strong></span>(<span>"OK"</span>)<br class="title-page-name"/>    }<br class="title-page-name"/>    <span>else </span>{<br class="title-page-name"/>        deferred.<span class="underline"><strong class="calibre1">completeExceptionally</strong></span>(RuntimeException())<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>println</span>(deferred.await())</pre>
<p class="calibre2">This code will print <kbd class="calibre13">OK</kbd> half of the time, and throw <kbd class="calibre13">RuntimeException</kbd> the other half of the time.</p>
<p class="calibre2">Make sure that you always complete your deferred. It is usually a good idea to wrap any code containing deferred into a <kbd class="calibre13">try...catch</kbd> block.</p>
<p class="calibre2">It is also possible to cancel a deferred if you're no longer interested in its results. Simply call <kbd class="calibre13">cancel()</kbd> on it:</p>
<pre class="calibre18">deferred.cancel()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Barrier</h1>
                
            
            <article>
                
<p class="calibre2">The Barrier design pattern provides us with the means to wait for multiple concurrent tasks before proceeding further. A common use case is composing objects from different sources.</p>
<p class="calibre2">Take, for example, the following class:</p>
<pre class="calibre18"><span>data class </span>FavoriteCharacter(<span>val </span><span>name</span>: String<span>, val </span><span>catchphrase</span>: String<span>, val </span><span>repeats</span>: Int)</pre>
<p class="calibre2">Assume that we're fetching name, <kbd class="calibre13">catchphrase</kbd>, and number. This <kbd class="calibre13">catchphrase</kbd> is being repeated from three different sources. </p>
<p class="calibre2">The most basic way would be to use <kbd class="calibre13">CountDownLatch</kbd>, as we did in some of the previous examples:</p>
<pre class="calibre18"><span>val </span>latch = CountDownLatch(<span>3</span>)<br class="title-page-name"/><br class="title-page-name"/><span>var </span>name: String? = <span>null<br class="title-page-name"/></span><span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got name"</span>)<br class="title-page-name"/>    name = <span>"Inigo Montoya"<br class="title-page-name"/></span><span>    </span>latch.countDown()<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>var </span>catchphrase = <span>""<br class="title-page-name"/></span><span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got catchphrase"</span>)<br class="title-page-name"/>    catchphrase = <span>"Hello. My name is Inigo Montoya. You killed my father. Prepare to die."<br class="title-page-name"/></span><span>    </span>latch.countDown()<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>var </span>repeats = <span>0<br class="title-page-name"/></span><span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got repeats"</span>)<br class="title-page-name"/>    repeats = <span>6<br class="title-page-name"/></span><span>    </span>latch.countDown()<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>latch.await()<br class="title-page-name"/><br class="title-page-name"/><span>println</span>(<span>"</span><span>${</span>name<span>}</span><span> says: </span><span>${</span>catchphrase.<span>repeat</span>(repeats)<span>}</span><span>"</span>)</pre>
<p class="calibre2">You'll notice that the order of the async tasks completing is changing:</p>
<pre class="calibre18">Got name<br class="title-page-name"/>Got catchphrase<br class="title-page-name"/>Got repeats</pre>
<p class="calibre2">But in the end, we always print the same result:</p>
<pre class="calibre18"><strong class="calibre1">Inigo Montoya says: Hello. My name is Inigo Montoya. ...</strong></pre>
<p class="calibre2">But this solution brings a lot of problems. We need to work with mutable variables and either set defaults for them or use nulls. </p>
<p class="calibre2">Also, this would work as long as we use closures. What if our functions were longer than a few lines? </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">CountDownLatch</h1>
                
            
            <article>
                
<p class="calibre2">We could pass them the latch, of course. The latch, which we've already seen a couple of times, allows one thread to wait until the other threads have completed working:</p>
<pre class="calibre18"><span>private fun </span><span>getName</span>(latch: CountDownLatch) = <span>launch </span><span>{<br class="title-page-name"/></span><span>    ...<br class="title-page-name"/></span><span>    latch.countDown()<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">But it's not a clear separation of concerns. Do we really want to specify how this function should be synchronized? </p>
<p class="calibre2">Let's have a second take:</p>
<pre class="calibre18"><span>private fun </span><span>getName</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got name"</span>)<br class="title-page-name"/>    <span>"Inigo Montoya"<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>private fun </span><span>getCatchphrase</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got catchphrase"</span>)<br class="title-page-name"/>    <span>"Hello. My name is Inigo Montoya. You killed my father. Prepare to die."<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>private fun </span><span>getRepeats</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(Random().nextInt(<span>100</span>))<br class="title-page-name"/>    <span>println</span>(<span>"Got repeats"</span>)<br class="title-page-name"/>    <span>6<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">Just a reminder, <kbd class="calibre13">fun getRepeats() = async { ... }</kbd> has nothing magical in it. Its longer equivalent is:</p>
<pre class="calibre18">private fun getCatchphrase(): Deferred&lt;String&gt; {<br class="title-page-name"/>    return async {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can call our code to get the same results as before:</p>
<pre class="calibre18"><span>val </span>name = <span>getName</span>()<br class="title-page-name"/><span>val </span>catchphrase = <span>getCatchphrase</span>()<br class="title-page-name"/><span>val </span>repeats = <span>getRepeats</span>()<br class="title-page-name"/><br class="title-page-name"/><span>println</span>(<span>"</span><span>${</span>name.<strong class="calibre1"><span class="underline">await()</span></strong><span>}</span><span> says: </span><span>${</span>catchphrase.<span class="underline"><strong class="calibre1">await()</strong></span>.<span>repeat</span>(repeats.<span class="underline"><strong class="calibre1">await()</strong></span>)<span>}</span><span>"</span>)</pre>
<p class="calibre2">But we can improve it further by using our old friend, data class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data class as Barrier</h1>
                
            
            <article>
                
<p class="calibre2">Now our data class is the Barrier:</p>
<pre class="calibre18"><span>val </span>character = FavoriteCharacter(<span>getName</span>().await()<span>, </span><span>getCatchphrase</span>().await()<span>, </span><span>getRepeats</span>().await())<br class="title-page-name"/><br class="title-page-name"/>// Will happen only when everything is ready<br class="title-page-name"/><span>with</span>(character) <span>{<br class="title-page-name"/></span><span>    </span><span>println</span>(<span>"</span><span>$</span><span>name</span><span> says: </span><span>${</span><span>catchphrase</span>.<span>repeat</span>(<span>repeats</span>)<span>}</span><span>"</span>)    <br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">The additional benefit of data classes as Barriers is the ability to destructure them easily:</p>
<pre class="calibre18"><span>val </span>(name<span>, </span>catchphrase<span>, </span>repeats) = character<br class="title-page-name"/><span>println</span>(<span>"</span><span>$</span>name<span> says: </span><span>${</span>catchphrase.<span>repeat</span>(repeats)<span>}</span><span>"</span>)</pre>
<p class="calibre2">This works well if the type of data we receive from different asynchronous tasks is widely different. In this example, we receive both <kbd class="calibre13">String</kbd> and <kbd class="calibre13">Int</kbd>. </p>
<p class="calibre2">In some cases, we receive the same types of data from different sources. </p>
<p class="calibre2">For example, let's ask Michael (our canary product owner), Jake (our barista), and me who our favorite movie character is:</p>
<pre class="calibre18"><span>object </span>Michael {<br class="title-page-name"/>    <span>fun </span><span>getFavoriteCharacter</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>        </span><span>// Doesn't like to think much<br class="title-page-name"/></span><span>        </span><span>delay</span>(Random().nextInt(<span>10</span>))<br class="title-page-name"/>        FavoriteCharacter(<span>"Terminator"</span><span>, </span><span>"Hasta la vista, baby"</span><span>, </span><span>1</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span>}<br class="title-page-name"/><br class="title-page-name"/><span>object </span>Jake {<br class="title-page-name"/>    <span>fun </span><span>getFavoriteCharacter</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>        </span><span>// Rather thoughtful barista<br class="title-page-name"/></span><span>        </span><span>delay</span>(Random().nextInt(<span>100</span>) + <span>10</span>)<br class="title-page-name"/>        FavoriteCharacter(<span>"Don Vito Corleone"</span><span>, </span><span>"I'm going to make him an offer he can't refuse"</span><span>, </span><span>1</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span>}<br class="title-page-name"/><br class="title-page-name"/><span>object </span>Me {<br class="title-page-name"/>    <span>fun </span><span>getFavoriteCharacter</span>() = <span>async </span><span>{<br class="title-page-name"/></span><span>        </span><span>// I already prepared the answer!<br class="title-page-name"/></span><span>        </span>FavoriteCharacter(<span>"Inigo Montoya"</span><span>, </span><span>"Hello, my name is..."</span><span>, </span><span>6</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span>}</pre>
<p class="calibre2">In that case, we can use a list to gather the results:</p>
<pre class="calibre18"><span>val </span>favoriteCharacters = <span>listOf</span>(Me.getFavoriteCharacter().await()<span>,<br class="title-page-name"/></span><span>        </span>Michael.getFavoriteCharacter().await()<span>,<br class="title-page-name"/></span><span>        </span>Jake.getFavoriteCharacter().await())<br class="title-page-name"/><br class="title-page-name"/><span>println</span>(favoriteCharacters)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scheduler</h1>
                
            
            <article>
                
<p class="calibre2">This is another concept we discussed briefly in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14"><span class="calibre7">Threads and Coroutines</span></em>, in the <em class="calibre14">Starting a coroutine</em> section.<span class="calibre7"> </span></p>
<p class="calibre2">Remember how our <kbd class="calibre13">launch()</kbd> or <kbd class="calibre13">async()</kbd> could receive <kbd class="calibre13">CommonPool</kbd>?</p>
<p class="calibre2">Here's an example to remind you that you could specify it explicitly:</p>
<pre class="calibre18">// Same as launch {}<br class="title-page-name"/>launch(<span class="underline"><strong class="calibre1">CommonPool</strong></span>) {<br class="title-page-name"/>...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Same as async {}<br class="title-page-name"/>val result = async(<span class="underline"><strong class="calibre1">CommonPool</strong></span>) {<br class="title-page-name"/>...<br class="title-page-name"/>}</pre>
<p class="calibre2">This <kbd class="calibre13">CommonPool</kbd> is a Scheduler design pattern in a bad disguise. Many async tasks may be mapped to the same Scheduler.</p>
<p class="calibre2">Run the following code:</p>
<pre class="calibre18"><span>val </span>r1 = <span>async</span>(CommonPool) <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>1000</span>) {<br class="title-page-name"/>        <span>println</span>(Thread.currentThread().<span>name</span>)<br class="title-page-name"/>        <span>yield</span>()<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>r1.await()</pre>
<p class="calibre2">What is interesting is the fact that the same coroutine is picked up by different threads:</p>
<pre class="calibre18"><strong class="calibre1">ForkJoinPool.commonPool-worker-2</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-3</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-3</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-1</strong></pre>
<p class="calibre2">You can also specify the context as <kbd class="calibre13">Unconfined</kbd>:</p>
<pre class="calibre18"><span>val </span>r1 = <span>async</span>(Unconfined) <span>{<br class="title-page-name"/></span><span>    ...</span><br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">This will run the coroutine on the main thread. It prints:</p>
<pre class="calibre18"><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">You can also inherit context from your parent coroutine:</p>
<pre class="calibre18"><span>val </span>r1 = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>1000</span>) {<br class="title-page-name"/>        <span>val </span>parentThread = Thread.currentThread().<span>name<br class="title-page-name"/></span><span>        </span><span>launch</span>(<span>coroutineContext</span>) <span>{<br class="title-page-name"/></span><span>            </span><span>println</span>(Thread.currentThread().<span>name </span>== parentThread)<br class="title-page-name"/>        <span>}<br class="title-page-name"/></span><span>        </span><span>yield</span>()<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Note though, that running in the same context doesn't mean that we run on the same thread.</p>
<p class="calibre2">You may ask yourself: what's the difference between inheriting the context and using <kbd class="calibre13">Unconfined</kbd>? We'll discuss this in detail in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding contexts</h1>
                
            
            <article>
                
<p class="calibre2">To understand different contexts, let's look at the following code:</p>
<pre class="calibre18"><span>val </span>r1 = <span>async</span>(<strong class="calibre1">Unconfined</strong>) <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>1000</span>) {<br class="title-page-name"/>        <span>println</span>(Thread.currentThread().<span>name</span>)<br class="title-page-name"/>        <strong class="calibre1">delay(1)</strong><br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>r1.await()</pre>
<p class="calibre2">Instead of <kbd class="calibre13">yield()</kbd>, we're using the <kbd class="calibre13">delay()</kbd> function, which also suspends the current coroutine. </p>
<p class="calibre2">But the output compared to <kbd class="calibre13">yield()</kbd> is different:</p>
<pre class="calibre18"><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">kotlinx.coroutines.DefaultExecutor</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">After calling <kbd class="calibre13">delay()</kbd> for the first time, the coroutine has switched context, and as a result, threads.</p>
<p class="calibre2">For that reason, using <kbd class="calibre13">Unconfined</kbd> is not recommended for CPU-intensive tasks or tasks that need to run on a particular thread, such as UI rendering.</p>
<p class="calibre2">You can also create your own thread pool for coroutines to run on:</p>
<pre class="calibre18"><span class="underline"><strong class="calibre1">val pool = newFixedThreadPoolContext(2, "My Own Pool")</strong></span><br class="title-page-name"/><span>val </span>r1 = <span>async</span>(pool) <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>1000</span>) {<br class="title-page-name"/>        <span>println</span>(Thread.currentThread().<span>name</span>)<br class="title-page-name"/>        <span>yield</span>()<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>r1.await()<br class="title-page-name"/><span class="underline"><strong class="calibre1">pool.close()</strong></span></pre>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-1</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">If you create your own thread pool, make sure that you either release it with <kbd class="calibre13">close()</kbd> or reuse it, since creating a new thread pool and holding to it is expensive in terms of resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipelines</h1>
                
            
            <article>
                
<p class="calibre2">In our <kbd class="calibre13">StoryLand</kbd>, the same lazy architect, me, is struggling with a problem. Back in <a href="part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 4</a>, <span class="calibre7"><em class="calibre14">Getting Familiar with Behavioral Patterns</em>, we</span> wrote an HTML page parser. But it depends on whether somebody already fetched the pages to parse for us. It is also not very flexible.</p>
<p class="calibre2">What we would like is for one coroutine to produce an infinite stream of news, and for others to parse that stream in steps.</p>
<p class="calibre2">To start working with DOM, we'll need a library, such as <kbd class="calibre13">kotlinx.dom</kbd><em class="calibre14">. </em>If you're using <strong class="calibre5">Gradle</strong>, make sure you add the following lines to your <kbd class="calibre13">build.gradle</kbd>:</p>
<pre class="calibre18">repositories {<br class="title-page-name"/>    ...<br class="title-page-name"/>    <span class="underline"><strong class="calibre1">jcenter()</strong></span><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>dependencies {<br class="title-page-name"/>    ...<span><br class="title-page-name"/></span><span>    </span><span class="underline"><strong class="calibre1">compile </strong></span><span><span class="underline"><strong class="calibre1">"org.jetbrains.kotlinx:kotlinx.dom:0.0.10"</strong></span><br class="title-page-name"/></span>}</pre>
<p class="calibre2">Now, to the task at hand. </p>
<p class="calibre2">First, we would like to fetch news pages once in a while. For that, we'll have a producer:</p>
<pre class="calibre18"><span>fun </span><span>producePages</span>() = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>fun </span><span>getPages</span>(): List&lt;String&gt; {<br class="title-page-name"/>        <span>// This should actually fetch something<br class="title-page-name"/></span><span>        </span><span>return </span><span>listOf</span>(<span>"&lt;html&gt;&lt;body&gt;&lt;H1&gt;Cool stuff&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;"</span><span>,<br class="title-page-name"/></span><span>                </span><span>"&lt;html&gt;&lt;body&gt;&lt;H1&gt;Event more stuff&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;"</span>).<span>shuffled</span>()<br class="title-page-name"/>    }<br class="title-page-name"/>    <span>while </span>(<span class="underline"><strong class="calibre1">this.isActive</strong></span>) {<br class="title-page-name"/>        <span>val </span>pages = getPages()<br class="title-page-name"/>        <span>for </span>(p <span>in </span>pages) {<br class="title-page-name"/>            send(p)<br class="title-page-name"/>        }<br class="title-page-name"/>        <span>delay</span>(TimeUnit.<span>SECONDS</span>.toMillis(<span>5</span>))<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span></pre>
<p class="calibre2">We use <kbd class="calibre13">shuffled()</kbd> here so the order of the list elements won't be the same all the time.</p>
<p class="calibre2">The <kbd class="calibre13">isActive</kbd> flag will be true as long as the coroutine is running and hasn't been canceled. It is good practice to check this property in loops that may run for a long time, so they could be stopped between iterations.</p>
<p class="calibre2">Each time we receive new titles, we send them downstream.</p>
<p class="calibre2">Since tech news isn't updated very often. We can check for updates only once in a while, using <kbd class="calibre13">delay()</kbd>. In the actual code, the delay would probably be minutes, if not hours.</p>
<p class="calibre2">The next step is creating <strong class="calibre5">Document Object Model</strong> (<strong class="calibre5">DOM</strong>) out of those raw strings containing HTML. For that we'll have a second producer, this one receiving a channel that connects it to the first one:</p>
<pre class="calibre18"><span>fun </span><span>produceDom</span>(<span class="underline"><strong class="calibre1">pages: ReceiveChannel&lt;String&gt;</strong></span>) = <span>produce </span><span>{<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    </span><span>fun </span><span>parseDom</span>(page: String): Document {<br class="title-page-name"/>         return kotlinx.dom.parseXml(<em class="calibre25">page.toSource()</em>)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    <span class="underline"><strong class="calibre1">for (p in pages)</strong></span> {<br class="title-page-name"/>        send(parseDom(p))<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">We can use the <kbd class="calibre13">for</kbd> loop to iterate over the channel as long as more data is coming. This is a very elegant way of consuming data from a channel. </p>
<p class="calibre2">In this producer, we finally make use of the DOM parser we imported a while ago. We also introduced an extension function on <kbd class="calibre13">String</kbd> for our convenience:</p>
<pre class="calibre18"><span>private fun </span>String.<span>toSource</span>(): InputSource {<br class="title-page-name"/>    <span>return </span>InputSource(StringReader(<span>this</span>))<br class="title-page-name"/>}</pre>
<p class="calibre2">That's because <kbd class="calibre13">parseXml()</kbd> expects <kbd class="calibre13">InputSource</kbd> as its input. Basically, this is an <strong class="calibre5">Adapter</strong> design pattern in action:</p>
<pre class="calibre18"><span>fun </span><span>produceTitles</span>(parsedPages: ReceiveChannel&lt;Document&gt;) = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>fun </span><span>getTitles</span>(dom: Document): List&lt;String&gt; {<br class="title-page-name"/>        <span>val </span>h1 = dom.getElementsByTagName(<span>"H1"</span>)<br class="title-page-name"/>        <span>return </span>h1.<span>asElementList</span>().<span>map </span><span>{<br class="title-page-name"/></span><span>            it</span>.<span>textContent<br class="title-page-name"/></span><span>        </span><span>}<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><br class="title-page-name"/>    <span>for </span>(page <span>in </span>parsedPages) {<br class="title-page-name"/>        <span>for </span>(t <span>in </span>getTitles(page)) {<br class="title-page-name"/>            send(t)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">We're looking for the headers, hence <kbd class="calibre13">getElementsByTagName("H1")</kbd>. For each header found, and there may be more than one, we get its text with <kbd class="calibre13">textContent</kbd>.</p>
<p class="calibre2">Finally, we're sending each header from each page to the next in line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Establishing a pipeline</h1>
                
            
            <article>
                
<p class="calibre2">Now, to establish our pipeline:</p>
<pre class="calibre18"><span>val </span>pagesProducer = <span>producePages</span>()<br class="title-page-name"/><br class="title-page-name"/><span>val </span>domProducer = <span>produceDom</span>(pagesProducer)<br class="title-page-name"/><br class="title-page-name"/><span>val </span>titleProducer = <span>produceTitles</span>(domProducer)<br class="title-page-name"/><br class="title-page-name"/><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span>titleProducer.<span>consumeEach </span><span>{<br class="title-page-name"/></span><span>        </span><span>println</span>(<span>it</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">We have the following:</p>
<pre class="calibre18">pagesProducer |&gt; domProducer |&gt; titleProducer |&gt; output</pre>
<p class="calibre2">A pipeline is a great way to break a long process into smaller steps. Note that each producing coroutine is a pure function, so it's also easy to test and reason about.</p>
<p class="calibre2">The entire pipeline could be stopped by calling <kbd class="calibre13">cancel()</kbd> on the first coroutine in line.</p>
<p class="calibre2">We can achieve an even nicer API by using the extension functions:</p>
<pre class="calibre18"><span>private fun </span>ReceiveChannel&lt;Document&gt;.<span>titles</span>(): ReceiveChannel&lt;String&gt; {<br class="title-page-name"/>    <span class="underline"><strong class="calibre1">val channel = </strong></span><span><span class="underline"><strong class="calibre1">this</strong></span><br class="title-page-name"/></span><span>    fun </span><span>getTitles</span>(dom: Document): List&lt;String&gt; {<br class="title-page-name"/>        <span>val </span>h1 = dom.getElementsByTagName(<span>"H1"</span>)<br class="title-page-name"/>        <span>return </span>h1.<span>asElementList</span>().<span>map </span><span>{<br class="title-page-name"/></span><span>            it</span>.<span>textContent<br class="title-page-name"/></span><span>        </span><span>}<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><br class="title-page-name"/>    <span>return </span><span>produce </span><span>{<br class="title-page-name"/></span><span>        </span><span>for </span>(page <span>in </span>channel) {<br class="title-page-name"/>            <span>for </span>(t <span>in </span>getTitles(page)) {<br class="title-page-name"/>                send(t)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span>}<br class="title-page-name"/><br class="title-page-name"/><span>private fun </span>ReceiveChannel&lt;String&gt;.<span>dom</span>(): ReceiveChannel&lt;Document&gt; {<br class="title-page-name"/>    <span>val </span>channel = <span>this<br class="title-page-name"/></span><span>    return </span><span>produce</span><span>() </span><span>{<br class="title-page-name"/></span><span>        </span><span>for </span>(p <span>in </span>channel) {<br class="title-page-name"/>            send(kotlinx.dom.<span>parseXml</span>(p.<span>toSource</span>()))<br class="title-page-name"/>        }<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span>}</pre>
<p class="calibre2">Then we can call our code like this:</p>
<pre class="calibre18"><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span><span>producePages</span>().<span>dom</span>().<span>titles</span>().<span>consumeEach </span><span>{<br class="title-page-name"/></span><span>        </span><span>println</span>(<span>it</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">Kotlin really excels at creating expressive and fluent APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The fan-out design pattern</h1>
                
            
            <article>
                
<p class="calibre2">What if the amount of work at different steps in our pipeline is very different?</p>
<p class="calibre2">For example, it takes a lot more time to fetch the HTML than to parse it. Or what if we don't have a pipeline at all, just a lot of tasks we would like to distribute between coroutines.</p>
<p class="calibre2">That's where the fan-out design pattern kicks in. The number of coroutines may read from the same channel, distributing the work.</p>
<p class="calibre2">We can have one coroutine produce some results:</p>
<pre class="calibre18"><span>private fun </span><span>producePages</span>() = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>10_000</span>) {<br class="title-page-name"/>        <span>for </span>(c <span>in </span><span>'a'</span>..<span>'z'</span>) {<br class="title-page-name"/>            send(i <span>to </span><span>"page</span><span>$</span>c<span>"</span>)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">And have a function that would create a coroutine that reads those results:</p>
<pre class="calibre18"><span><br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>private fun </span><span>consumePages</span>(channel: ReceiveChannel&lt;Pair&lt;Int<span>, </span>String&gt;&gt;) = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(p <span>in </span>channel) {<br class="title-page-name"/>        <span>println</span>(p)<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">This allows us to generate an arbitrary number of consumers:</p>
<pre class="calibre18"><span>val </span>producer = <span>producePages</span>()<br class="title-page-name"/><br class="title-page-name"/><span>val </span>consumers = <span>List</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>    </span><span>consumePages</span>(producer)<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span>consumers.<span>forEach </span><span>{<br class="title-page-name"/></span><span>        it</span>.await()<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">The fan-out design pattern allows us to efficiently distribute the work across a number of coroutines, threads, and CPUs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The fan-in design pattern</h1>
                
            
            <article>
                
<p class="calibre2">It would be great if our coroutines could always make decisions by themselves. But what if they need to return some results from the computation to another coroutine?</p>
<p class="calibre2">The opposite of <strong class="calibre5">fan-out</strong> is the <strong class="calibre5">fan-in</strong> design pattern. Instead of multiple coroutines reading from the same channel, multiple coroutines can write their results to the same channel.</p>
<p class="calibre2">Imagine that you're reading news from two prominent tech resources: <kbd class="calibre13">techBunch</kbd> and <kbd class="calibre13">theFerge</kbd>. </p>
<p class="calibre2">Each resource produces the values at its own pace, and sends them over a channel:</p>
<pre class="calibre18"><span>private fun </span><span>techBunch</span>(collector: Channel&lt;String&gt;) = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>        </span><span>delay</span>(Random().nextInt(<span>1000</span>))<br class="title-page-name"/>        collector.send(<span>"Tech Bunch"</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>private fun </span><span>theFerge</span>(collector: Channel&lt;String&gt;) = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>        </span><span>delay</span>(Random().nextInt(<span>1000</span>))<br class="title-page-name"/>        collector.send(<span>"The Ferge"</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">By providing them with the same channel, we can combine their results:</p>
<pre class="calibre18"><span>val </span>collector = <span>Channel</span>&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/><span>techBunch</span>(collector)<br class="title-page-name"/><span>theFerge</span>(collector)<br class="title-page-name"/><br class="title-page-name"/><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span>collector.<span>consumeEachIndexed </span><span>{<br class="title-page-name"/></span><span>        </span><span>println</span>(<span>"</span><span>${</span><span>it</span>.<span>index</span><span>}</span><span> Got news from </span><span>${</span><span>it</span>.<span>value</span><span>}</span><span>"</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span></pre>
<p class="calibre2">Combining the fan-out and fan-in design patterns is a good base for <strong class="calibre5">Map</strong>/<strong class="calibre5">Reduce</strong> algorithms.</p>
<p class="calibre2">To demonstrate that, we'll generate 10,000,000 random numbers and compute the maximum number among them by dividing this task multiple times.</p>
<p class="calibre2">First, to generate the list of 10,000,000 random integers:</p>
<pre class="calibre18"><span>val </span>numbers = <span>List</span>(<span>10_000_000</span>) <span>{<br class="title-page-name"/></span><span>    </span>Random().nextInt()<br class="title-page-name"/><span>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing workers</h1>
                
            
            <article>
                
<p class="calibre2">Now we'll have two types of workers:</p>
<ul class="calibre11">
<li class="calibre12">The divide worker will receive the list of numbers, determine the biggest number in the list, and send it over to the output channel:</li>
</ul>
<pre class="calibre27"><span>fun </span><span>divide</span>(input: ReceiveChannel&lt;List&lt;Int&gt;&gt;<span>, <br class="title-page-name"/></span><span>           </span>output: SendChannel&lt;Int&gt;) = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>var </span>max = <span>0<br class="title-page-name"/></span><span>    </span><span>for </span>(list <span>in </span>input) {<br class="title-page-name"/>        <span>for </span>(i <span>in </span>list) {<br class="title-page-name"/>            <span>if </span>(i &gt; max) {<br class="title-page-name"/>                max = i<br class="title-page-name"/>                output.send(max)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<ul class="calibre11">
<li class="calibre12">The collector will listen to this channel and each time a new sub-max number arrives, will decide whether it's the all-time biggest:</li>
</ul>
<pre class="calibre27"><span>fun </span><span>collector</span>() = <span>actor</span>&lt;Int&gt; <span>{<br class="title-page-name"/></span><span>    </span><span>var </span>max = <span>0<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in this</span>) {<br class="title-page-name"/>        max = Math.max(max<span>, </span>i)<br class="title-page-name"/>    }<br class="title-page-name"/>    <span>println</span>(max)<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Now we only need to establish those channels:</p>
<pre class="calibre18"><span>val </span>input = <span>Channel</span>&lt;List&lt;Int&gt;&gt;()<br class="title-page-name"/><span>val </span>output = <span>collector</span>()<br class="title-page-name"/><span>val </span>dividers = <span>List</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>    </span><span>divide</span>(input<span>, </span>output)<br class="title-page-name"/><span>}<br class="title-page-name"/></span><br class="title-page-name"/><span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(c <span>in </span>numbers.<span>chunked</span>(<span>1000</span>)) {<br class="title-page-name"/>        input.send(c)<br class="title-page-name"/>    }<br class="title-page-name"/>    input.close()<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span>dividers.<span>forEach </span><span>{<br class="title-page-name"/></span><span>    it</span>.await()<br class="title-page-name"/><span>}<br class="title-page-name"/><br class="title-page-name"/></span>output.close()</pre>
<p class="calibre2">Note that in this case, we don't gain performance benefits, and naive <kbd class="calibre13">numbers.max()</kbd> would produce better results. But the more data you need to collect, the more useful this pattern becomes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Buffered channels</h1>
                
            
            <article>
                
<p class="calibre2">Up until now, all the channels that we used had a capacity of exactly one element.</p>
<p class="calibre2">This means that if you write to this channel but no one reads from it, the sender will be suspended:</p>
<pre class="calibre18"><span>val </span>channel = <span>Channel</span>&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/><span>val </span>j = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>10</span>) {<br class="title-page-name"/>        channel.send(i)<br class="title-page-name"/>        <span>println</span>(<span>"Sent </span><span>$</span>i<span>"</span>)</pre>
<pre class="calibre18">    }<br class="title-page-name"/><span>}<br class="title-page-name"/><br class="title-page-name"/>j.join()</span></pre>
<p class="calibre2">This code doesn't print anything because the coroutine is waiting for someone to read from the channel.</p>
<p class="calibre2">To avoid that, we can create a buffered channel:</p>
<pre class="calibre18"><span>val </span>channel = <span>Channel</span>&lt;Int&gt;<span class="underline"><strong class="calibre1">(5)</strong></span></pre>
<p class="calibre2">Now suspension will occur only when the channel capacity is reached.</p>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">Sent 1</strong><br class="title-page-name"/><strong class="calibre1">Sent 2</strong><br class="title-page-name"/><strong class="calibre1">Sent 3</strong><br class="title-page-name"/><strong class="calibre1">Sent 4</strong><br class="title-page-name"/><strong class="calibre1">Sent 5</strong></pre>
<p class="calibre2">Since <kbd class="calibre13">produce()</kbd> and <kbd class="calibre13">actor()</kbd> are also backed up by a channel, we can make it buffered too:</p>
<pre class="calibre18"><span>val </span>actor = <span>actor</span>&lt;Int&gt;(<span>capacity = </span><span>5</span>) <span>{<br class="title-page-name"/></span><span>    ...<br class="title-page-name"/></span><span>}<br class="title-page-name"/><br class="title-page-name"/>val producer = produce&lt;Int&gt;(capacity = 10) {<br class="title-page-name"/>    ...        <br class="title-page-name"/>}<br class="title-page-name"/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unbiased select</h1>
                
            
            <article>
                
<p class="calibre2">One of the most useful ways to work with channels is the <kbd class="calibre13">select {}</kbd> clause we saw in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <span class="calibre7"><em class="calibre14">Threads and Coroutines</em>, </span>in the <em class="calibre14">Producers</em> section. </p>
<p class="calibre2">But select is inherently biased. If two events happen at the same time, it will select the first clause.</p>
<p class="calibre2">In the following example, we'll have a producer that sends five values with a very short delay:</p>
<pre class="calibre18"><span>fun </span><span>producer</span>(name: String<span>, </span>repeats: Int) = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(repeats) <span>{<br class="title-page-name"/></span><span>        </span><span>delay</span>(<span>1</span>)<br class="title-page-name"/>        send(name)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">We'll create three such producers and see the results:</p>
<pre class="calibre18"><span>val </span>repeats = <span>10_000<br class="title-page-name"/></span><span>val </span>p1 = <span>producer</span>(<span>"A"</span><span>, </span>repeats)<br class="title-page-name"/><span>val </span>p2 = <span>producer</span>(<span>"B"</span><span>, </span>repeats)<br class="title-page-name"/><span>val </span>p3 = <span>producer</span>(<span>"C"</span><span>, </span>repeats)<br class="title-page-name"/><br class="title-page-name"/><span>val </span>results = ConcurrentHashMap&lt;String<span>, </span>Int&gt;()<br class="title-page-name"/><span>repeat</span>(repeats) <span>{<br class="title-page-name"/></span><span>    </span><span>val </span>result = <span class="underline"><strong class="calibre1">select</strong></span>&lt;String&gt; <span>{<br class="title-page-name"/></span><span>        </span>p1.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>        </span>p2.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>        </span>p3.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>    }<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    </span>results.compute(result) <span>{ </span>k<span>, </span>v <span>-&gt;<br class="title-page-name"/></span><span>        </span><span>if </span>(v == <span>null</span>) {<br class="title-page-name"/>            <span>1<br class="title-page-name"/></span><span>        </span>}<br class="title-page-name"/>        <span>else </span>{<br class="title-page-name"/>            <span>v</span> + <span>1<br class="title-page-name"/></span><span>        </span>}<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/><br class="title-page-name"/>println(results)</span></pre>
<p class="calibre2">We run this code five times. Here are some of the results:</p>
<pre class="calibre18"><strong class="calibre1">{A=8235, B=1620, C=145}</strong><br class="title-page-name"/><strong class="calibre1">{A=7850, B=2062, C=88}</strong><br class="title-page-name"/><strong class="calibre1">{A=7878, B=2002, C=120}</strong><br class="title-page-name"/><strong class="calibre1">{A=8260, B=1648, C=92}</strong><br class="title-page-name"/><strong class="calibre1">{A=7927, B=2011, C=62}</strong></pre>
<p class="calibre2">As you can see, <kbd class="calibre13">A</kbd> almost always wins, while <kbd class="calibre13">C</kbd> is always third. The more <kbd class="calibre13">repeats</kbd> you set, the larger the bias gets.</p>
<p class="calibre2">Now let's use <kbd class="calibre13">selectUnbiased</kbd> instead:</p>
<pre class="calibre18"><span>...<br class="title-page-name"/>val </span>result = <span>selectUnbiased</span>&lt;String&gt; <span>{<br class="title-page-name"/></span><span>    </span>p1.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>    </span>p2.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>    </span>p3.<span>onReceive </span><span>{ it }<br class="title-page-name"/></span><span>}<br class="title-page-name"/>...</span></pre>
<p class="calibre2">The results of the first five executions may look like this:</p>
<pre class="calibre18"><strong class="calibre1">{A=3336, B=3327, C=<span class="underline">3337</span>}</strong><br class="title-page-name"/><strong class="calibre1">{A=3330, B=3332, C=<span class="underline">3338</span>}</strong><br class="title-page-name"/><strong class="calibre1">{A=<span class="underline">3334</span>, B=3333, C=3333}</strong><br class="title-page-name"/><strong class="calibre1">{A=3334, B=<span class="underline">3336</span>, C=3330}</strong><br class="title-page-name"/><strong class="calibre1">{A=3332, B=<span class="underline">3335</span>, C=3333}</strong></pre>
<p class="calibre2">Not only are the numbers distributed more evenly now, but all clauses have an equal chance of being selected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mutexes</h1>
                
            
            <article>
                
<p class="calibre2">Also known as mutual exclusions, mutexes provide a means to protect a shared state.</p>
<p class="calibre2">Let's start with same, old, dreaded counter example:</p>
<pre class="calibre18"><span>var </span>counter = <span>0<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>val </span>jobs = <span>List</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>    </span><span>launch </span><span>{<br class="title-page-name"/></span><span>        </span><span>repeat</span>(<span>1000</span>) <span>{<br class="title-page-name"/></span><span>            </span>counter++<br class="title-page-name"/>            <span>yield</span>()<br class="title-page-name"/>        <span>}<br class="title-page-name"/></span><span>    }<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span>jobs.<span>forEach </span><span>{<br class="title-page-name"/></span><span>        it</span>.join()<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>    </span><span>println</span>(counter)<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">As you've probably guessed, this prints anything but the result of <kbd class="calibre13">10*100</kbd>. Totally embarrassing.</p>
<p class="calibre2">To solve that, we introduce a mutex:</p>
<pre class="calibre18"><span>var </span>counter = <span>0<br class="title-page-name"/></span><strong class="calibre1">val mutex = Mutex()</strong><br class="title-page-name"/><br class="title-page-name"/><span>val </span>jobs = <span>List</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>    </span><span>launch </span><span>{<br class="title-page-name"/></span><span>        </span><span>repeat</span>(<span>1000</span>) <span>{<br class="title-page-name"/></span><span>            </span><span class="underline"><strong class="calibre1">mutex.lock()</strong></span><br class="title-page-name"/>            counter++<br class="title-page-name"/>            <span class="underline"><strong class="calibre1">mutex.unlock()</strong></span><br class="title-page-name"/>            <span>yield</span>()<br class="title-page-name"/>        <span>}<br class="title-page-name"/></span><span>    }<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">Now our example always prints the correct number.</p>
<p class="calibre2">This is good for simple cases. But what if the code within the critical section (that is, between <kbd class="calibre13">lock()</kbd> and <kbd class="calibre13">unlock()</kbd>) throws an exception?</p>
<p class="calibre2">Then we'll have to wrap everything in <kbd class="calibre13">try...catch</kbd>, which is not very convenient:</p>
<pre class="calibre18"><span>repeat</span>(<span>1000</span>) <span>{<br class="title-page-name"/></span><span>    </span><span class="underline"><strong class="calibre1">try {</strong></span><br class="title-page-name"/>        mutex.lock()<br class="title-page-name"/>        counter++                     <br class="title-page-name"/>   <strong class="calibre1"> </strong><span class="underline"><strong class="calibre1">}</strong></span><br class="title-page-name"/><strong class="calibre1">    <span class="underline">finally</span> {</strong><br class="title-page-name"/>        mutex.unlock()                    <br class="title-page-name"/>    <span class="underline"><strong class="calibre1">}</strong></span><br class="title-page-name"/>    <br class="title-page-name"/>    <span>yield</span>()<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Exactly for that purpose, Kotlin also introduces <kbd class="calibre13">withLock()</kbd>:</p>
<pre class="calibre18"><span>...<br class="title-page-name"/>repeat</span>(<span>1000</span>) <span>{<br class="title-page-name"/></span><span>    </span><span class="underline"><strong class="calibre1">mutex.withLock </strong></span><span><span class="underline"><strong class="calibre1">{</strong></span><br class="title-page-name"/></span><span>        </span>counter++<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>    </span><span>yield</span>()<br class="title-page-name"/><span>}<br class="title-page-name"/>...</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Selecting on close</h1>
                
            
            <article>
                
<p class="calibre2">Reading from a channel using <kbd class="calibre13">select()</kbd> is nice until it gets closed.</p>
<p class="calibre2">You can see an example of that problem here:</p>
<pre class="calibre18"><span>val </span>p1 = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(<span>10</span>) <span>{<br class="title-page-name"/></span><span>        </span>send(<span>"A"</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>val </span>p2 = <span>produce </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(<span>5</span>) <span>{<br class="title-page-name"/></span><span>        </span>send(<span>"B"</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>runBlocking </span><span>{ <br class="title-page-name"/></span><span>    </span><span>repeat</span>(<span>15</span>) <span>{<br class="title-page-name"/></span><span>        </span><span>val </span>result = selectUnbiased&lt;String&gt; <span>{<br class="title-page-name"/></span><span>            </span>p1.<span>onReceive </span><span>{<br class="title-page-name"/></span><span>                it<br class="title-page-name"/></span><span>            }<br class="title-page-name"/></span><span>            </span>p2.<span>onReceive </span><span>{<br class="title-page-name"/></span><span>                it<br class="title-page-name"/></span><span>            }<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>        </span><span>println</span>(result)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}</span></pre>
<p class="calibre2">Although the numbers add up, we may often receive <kbd class="calibre13">ClosedReceiveChannelException</kbd> running this code. That's because the second producer has fewer items, and as soon as it finishes, it will close its channel.</p>
<p class="calibre2">To avoid that, we can use <kbd class="calibre13">onReceiveOrNull</kbd>, which will return a nullable version at the same time. Once the channel gets closed, we'll receive <kbd class="calibre13">null</kbd> in our <kbd class="calibre13">select</kbd>.</p>
<p class="calibre2">We can handle this null value in any way we want, for example, by making use of the <kbd class="calibre13">elvis</kbd> operator:</p>
<pre class="calibre18"><span>repeat</span>(<span>15</span>) <span>{<br class="title-page-name"/></span><span>    </span><span>val </span>result = <span>selectUnbiased</span>&lt;String&gt; <span>{<br class="title-page-name"/></span><span>        </span>p1.<span>onReceiveOrNull </span><span>{<br class="title-page-name"/>            // Can throw my own exception<br class="title-page-name"/></span><span>            it </span><span class="underline"><strong class="calibre1">?: throw RuntimeException()</strong></span><br class="title-page-name"/>        <span>}<br class="title-page-name"/></span><span>        </span>p2.<span>onReceiveOrNull </span><span>{<br class="title-page-name"/>            // Or supply default value<br class="title-page-name"/></span><span>            it </span><span class="underline"><strong class="calibre1">?: </strong></span><span><span class="underline"><strong class="calibre1">"p2 closed"</strong></span><br class="title-page-name"/></span><span>        </span><span>}<br class="title-page-name"/></span><span>    }<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    </span><span>println</span>(result)<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Using that knowledge, we can drain both channels by skipping the null results:</p>
<pre class="calibre18"><span>var </span>count = <span>0<br class="title-page-name"/></span><span>while </span>(count &lt; <span>15</span>) {<br class="title-page-name"/>    <span>val </span>result = <span>selectUnbiased</span>&lt;<span class="underline"><strong class="calibre1">String?</strong></span>&gt; <span>{<br class="title-page-name"/></span><span>        </span>p1.<span>onReceiveOrNull </span><span>{<br class="title-page-name"/></span><span>            it<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span>        </span>p2.<span>onReceiveOrNull </span><span>{<br class="title-page-name"/></span><span>            it<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span>    }<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>    </span><span>if </span>(result != <span>null</span>) {<br class="title-page-name"/>        <span>println</span>(result)<br class="title-page-name"/>        count++<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sidekick channel</h1>
                
            
            <article>
                
<p class="calibre2">Up until now, we've only discussed the usages of <kbd class="calibre13">select</kbd> as a receiver. But we can also use <kbd class="calibre13">select</kbd> to send items to another channel.</p>
<p class="calibre2">Let's look at the following example:</p>
<pre class="calibre18"><span>val </span>batman = <span>actor</span>&lt;String&gt; <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(c <span>in this</span>) {<br class="title-page-name"/>        <span>println</span>(<span>"Batman is beating some sense into </span><span>$</span>c<span>"</span>)<br class="title-page-name"/>        <span>delay</span>(<span>100</span>)<br class="title-page-name"/>    }<br class="title-page-name"/><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>val </span>robin = <span>actor</span>&lt;String&gt; <span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(c <span>in this</span>) {<br class="title-page-name"/>        <span>println</span>(<span>"Robin is beating some sense into </span><span>$</span>c<span>"</span>)<br class="title-page-name"/>        <span>delay</span>(<span>250</span>)<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">We have a superhero and their sidekick as two actors. Since the superhero is more experienced, it usually takes them less time to beat the villain they're facing. </p>
<p class="calibre2">But in some cases, they still have their hands full, so a sidekick needs to step in.</p>
<p class="calibre2">We'll throw five villains at the pair with a few delays, and see how they fare:</p>
<pre class="calibre18"><span>val </span>j = <span>launch </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(c <span>in </span><span>listOf</span>(<span>"Jocker"</span><span>, </span><span>"Bane"</span><span>, </span><span>"Penguin"</span><span>, </span><span>"Riddler"</span><span>, </span><span>"Killer Croc"</span>)) {<br class="title-page-name"/>        <span>val </span>result = <span>select</span>&lt;Pair&lt;String<span>, </span>String&gt;&gt; <span>{<br class="title-page-name"/></span><span>            </span>batman.<span>onSend</span>(c) <span>{<br class="title-page-name"/></span><span>                </span>Pair(<span>"Batman"</span><span>, </span>c)<br class="title-page-name"/>            <span>}<br class="title-page-name"/></span><span>            </span>robin.<span>onSend</span>(c) <span>{<br class="title-page-name"/></span><span>                </span>Pair(<span>"Robin"</span><span>, </span>c)<br class="title-page-name"/>            <span>}<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span>        </span><span>delay</span>(<span>90</span>)<br class="title-page-name"/>        <span>println</span>(result)<br class="title-page-name"/>    }<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">Batman is beating some sense into Jocker</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Jocker)</strong><br class="title-page-name"/><strong class="calibre1">Robin is beating some sense into Bane</strong><br class="title-page-name"/><strong class="calibre1">(Robin, Bane)</strong><br class="title-page-name"/><strong class="calibre1">Batman is beating some sense into Penguin</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Penguin)</strong><br class="title-page-name"/><strong class="calibre1">Batman is beating some sense into Riddler</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Riddler)</strong><br class="title-page-name"/><strong class="calibre1">Robin is beating some sense into Killer Croc</strong><br class="title-page-name"/><strong class="calibre1">(Robin, Killer Croc)</strong></pre>
<p class="calibre2">Notice that the type parameter for this select refers to what is returned from the block, and not what is being sent to the channels. </p>
<p class="calibre2">That's the reason we use <kbd class="calibre13">Pair&lt;String, String&gt;</kbd> here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deferred channel</h1>
                
            
            <article>
                
<p class="calibre2">The more you work with coroutines, the more you'll get used to await results. At some point, you'll start sending deferred values over channels.</p>
<p class="calibre2">We'll start by creating 10 async tasks. The first will delay for a long time, and others we delay for a short time:</p>
<pre class="calibre18"><span>val </span>elements = <span>10<br class="title-page-name"/></span><span>val </span>deferredChannel = <span>Channel</span>&lt;Deferred&lt;Int&gt;&gt;(elements)<br class="title-page-name"/><br class="title-page-name"/><span>launch</span>(CommonPool) <span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(elements) <span>{ </span>i <span>-&gt;<br class="title-page-name"/></span><span>        </span><span>println</span>(<span>"</span><span>$</span>i<span> sent"</span>)<br class="title-page-name"/>        deferredChannel.send(<span>async </span><span>{<br class="title-page-name"/></span><span>            </span><span>delay</span>(<span>if </span>(i == <span>0</span>) <span>1000 </span><span>else </span><span>10</span>)<br class="title-page-name"/>            i<br class="title-page-name"/>        <span>}</span>)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span></pre>
<p class="calibre2">We'll put all those results into a buffered channel.</p>
<p class="calibre2">Now we can read from this channel, and be using a second <kbd class="calibre13">select</kbd> block, and await the results:</p>
<pre class="calibre18"><span>val </span>time = <span>measureTimeMillis </span><span>{<br class="title-page-name"/></span><span>    </span><span>repeat</span>(elements) <span>{<br class="title-page-name"/></span><span>        </span><span>val </span>result = <span>select</span>&lt;Int&gt; <span>{<br class="title-page-name"/></span><span>            </span>deferredChannel.<span>onReceive </span><span>{<br class="title-page-name"/></span><span>                </span><span class="underline"><strong class="calibre1">select </strong></span><span><span class="underline"><strong class="calibre1">{</strong></span><br class="title-page-name"/></span><span>                    it</span>.<span class="underline"><strong class="calibre1">onAwait</strong></span> <span>{ it }<br class="title-page-name"/></span><span>                }<br class="title-page-name"/></span><span>            }<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span>        </span><span>println</span>(result)<br class="title-page-name"/>    <span>}<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>println</span>(<span>"Took </span><span>${</span>time<span>}</span><span>ms"</span>)</pre>
<p class="calibre2">Note that the resulting time is of the slowest task:</p>
<pre class="calibre18"><strong class="calibre1">Took 1010ms</strong></pre>
<p class="calibre2">You can also use <kbd class="calibre13">onAwait()</kbd> as a stop signal for another channel.</p>
<p class="calibre2">For that, we'll create an async task that will complete in 600 ms:</p>
<pre class="calibre18"><span>val </span>stop = <span>async </span><span>{<br class="title-page-name"/></span><span>    </span><span>delay</span>(<span>600</span>)<br class="title-page-name"/>    <span>true<br class="title-page-name"/></span><span>}<br class="title-page-name"/></span></pre>
<p class="calibre2">And, as in the previous example, we'll send 10 deferred values over the buffered channel:</p>
<pre class="calibre18"><span>val </span>channel = <span>Channel</span>&lt;Deferred&lt;Int&gt;&gt;(<span>10</span>)<br class="title-page-name"/><br class="title-page-name"/><span>repeat</span>(<span>10</span>) <span>{</span>i <span>-&gt;<br class="title-page-name"/></span><span>    </span>channel.send(<span>async </span><span>{<br class="title-page-name"/></span><span>        </span><span>delay</span>(i * <span>100</span>)<br class="title-page-name"/>        i<br class="title-page-name"/>    <span>}</span>)<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">Then we'll wait for either a new value or a notification that the channel should be closed:</p>
<pre class="calibre18"><span>runBlocking </span><span>{<br class="title-page-name"/></span><span>    </span><span>for </span>(i <span>in </span><span>1</span>..<span>10</span>) {<br class="title-page-name"/>        <span>select</span>&lt;Unit&gt; <span>{<br class="title-page-name"/></span><span>            </span>stop.<span>onAwait </span><span>{<br class="title-page-name"/></span><span>                </span>channel.close()<br class="title-page-name"/>            <span>}<br class="title-page-name"/></span><span>            </span>channel.<span>onReceive </span><span>{<br class="title-page-name"/></span><span>                </span><span>println</span>(<span>it</span>.await())<br class="title-page-name"/>            <span>}<br class="title-page-name"/></span><span>        }<br class="title-page-name"/></span><span>    </span>}<br class="title-page-name"/><span>}</span></pre>
<p class="calibre2">This prints only six values out of ten, as expected, stopping after 600 ms have passed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we covered various design patterns related to concurrency in Kotlin. Most of them are based on coroutines, channels, deferred values, or a combination. </p>
<p class="calibre2"><strong class="calibre5">Pipeline</strong>, <strong class="calibre5">fan-in</strong>, and <strong class="calibre5">fan-out</strong> help distribute work and collect the results. <strong class="calibre5">Deferred values</strong> are used as placeholders for something that would resolve at a later time. <strong class="calibre5">Schedulers</strong> help us manage resources, mainly threads that back up the coroutines. <strong class="calibre5">Mutexes</strong> and <strong class="calibre5">Barriers</strong> help control that concurrency.</p>
<p class="calibre2">Now you should understand the <kbd class="calibre13">select</kbd> block and how it can be combined with channels and deferred values efficiently.</p>
<p class="calibre2">In the next chapter, we'll discuss Kotlin's idioms, best practices, and some of the anti-patterns that emerged with the language.</p>


            </article>

            
        </section>
    </body></html>