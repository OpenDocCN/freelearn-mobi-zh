<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Designed for Concurrency</h1>
                
            
            
                
<p class="calibre2">In this chapter, we'll discuss the most common concurrency design patterns, implemented with coroutines, and how coroutines can synchronize their execution.</p>
<p class="calibre2">Concurrent design patterns help us to manage many tasks at once. Yeah, I know, that's what we did in the last chapter. That's because some of those design patterns are already built into the language. </p>
<p class="calibre2">In this chapter, we'll briefly cover design patterns and other concurrent design patterns that you'll need to implement by yourself, with little effort.</p>
<p class="calibre2">We will be covering the following topics in this chapter:</p>
<ul class="calibre11">
<li class="calibre12">Active Object</li>
<li class="calibre12">Deferred value</li>
<li class="calibre12">Barrier</li>
<li class="calibre12">Scheduler</li>
<li class="calibre12">Pipelines</li>
<li class="calibre12">Fan out</li>
<li class="calibre12">Fan in</li>
<li class="calibre12">Buffered channels</li>
<li class="calibre12">Unbiased select</li>
<li class="calibre12">Mutex</li>
<li class="calibre12">Select on close</li>
<li class="calibre12">Sidekick channel</li>
<li class="calibre12">Deferred channel</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Active Object</h1>
                
            
            
                
<p class="calibre2">This design pattern allows a method to be executed in a safe way on another thread. Guess what else is being executed on another thread?</p>
<p class="calibre2">You're totally right: <kbd class="calibre13">actor()</kbd>.</p>
<p class="calibre2">So, it's one of those design patterns that is already built into the language. Or, to be precise, into one of the accommodating libraries.</p>
<p class="calibre2">We've already seen how to send data to <kbd class="calibre13">actor()</kbd>. But how do we receive data from it? </p>
<p class="calibre2">One way is to supply it with a channel for output:</p>
<pre class="calibre18">fun activeActor(out: SendChannel&lt;String&gt;) = actor&lt;Int&gt; {<br class="title-page-name"/>    for (i in this) {<br class="title-page-name"/>        out.send(i.toString().reversed())<br class="title-page-name"/>    }<br class="title-page-name"/>    out.close()<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember to close the output channel when you're done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Testing</h1>
                
            
            
                
<p class="calibre2">To test the <strong class="calibre5">Active Object</strong> pattern, we'll launch two jobs. One will send data to our actor:</p>
<pre class="calibre18">val channel = Channel&lt;String&gt;()<br class="title-page-name"/>val actor = activeActor(channel)<br class="title-page-name"/><br class="title-page-name"/>val j1 = launch {<br class="title-page-name"/>    for (i in 42..53) {<br class="title-page-name"/>        actor.send(i)<br class="title-page-name"/>    }<br class="title-page-name"/>    actor.close()<br class="title-page-name"/>}</pre>
<p class="calibre2">And another will wait for output on the outbound channel:</p>
<pre class="calibre18">val j2 = launch {<br class="title-page-name"/>    for (i in channel) {<br class="title-page-name"/>        println(i)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>j1.join()<br class="title-page-name"/>j2.join()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deferred value</h1>
                
            
            
                
<p class="calibre2">We've already met deferred values in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14">Threads and Coroutines</em>, in the <em class="calibre14">Returning results</em> section. <kbd class="calibre13">Deferred</kbd> is the result of the <kbd class="calibre13">async()</kbd> function, for example. You may also know them as <em class="calibre14">Futures</em> from Java or Scala, or as <em class="calibre14">Promises</em> from JavaScript.</p>
<p class="calibre2">Interestingly enough, Deferred is a <strong class="calibre5">Proxy</strong> design pattern that we've met in previous chapters.</p>
<p class="calibre2">Much as the Kotlin <kbd class="calibre13">Sequence</kbd> is very similar to the Java8 <kbd class="calibre13">Stream</kbd>, Kotlin Deferred is very similar to Java Future. You'll rarely need to create your own Deferred. Usually, you would work with the one returned from <kbd class="calibre13">async().</kbd></p>
<p class="calibre2">In cases where you do need to return a placeholder for a value that would be evaluated in the future, you can do it:</p>
<pre class="calibre18">val deferred = <strong class="calibre1">CompletableDeferred&lt;String&gt;()</strong><br class="title-page-name"/><br class="title-page-name"/>launch {<br class="title-page-name"/>    delay(100)<br class="title-page-name"/>    if (Random().nextBoolean()) {<br class="title-page-name"/>        deferred.<strong class="calibre1">complete</strong>("OK")<br class="title-page-name"/>    }<br class="title-page-name"/>    else {<br class="title-page-name"/>        deferred.<strong class="calibre1">completeExceptionally</strong>(RuntimeException())<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(deferred.await())</pre>
<p class="calibre2">This code will print <kbd class="calibre13">OK</kbd> half of the time, and throw <kbd class="calibre13">RuntimeException</kbd> the other half of the time.</p>
<p class="calibre2">Make sure that you always complete your deferred. It is usually a good idea to wrap any code containing deferred into a <kbd class="calibre13">try...catch</kbd> block.</p>
<p class="calibre2">It is also possible to cancel a deferred if you're no longer interested in its results. Simply call <kbd class="calibre13">cancel()</kbd> on it:</p>
<pre class="calibre18">deferred.cancel()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Barrier</h1>
                
            
            
                
<p class="calibre2">The Barrier design pattern provides us with the means to wait for multiple concurrent tasks before proceeding further. A common use case is composing objects from different sources.</p>
<p class="calibre2">Take, for example, the following class:</p>
<pre class="calibre18">data class FavoriteCharacter(val name: String, val catchphrase: String, val repeats: Int)</pre>
<p class="calibre2">Assume that we're fetching name, <kbd class="calibre13">catchphrase</kbd>, and number. This <kbd class="calibre13">catchphrase</kbd> is being repeated from three different sources. </p>
<p class="calibre2">The most basic way would be to use <kbd class="calibre13">CountDownLatch</kbd>, as we did in some of the previous examples:</p>
<pre class="calibre18">val latch = CountDownLatch(3)<br class="title-page-name"/><br class="title-page-name"/>var name: String? = null<br class="title-page-name"/>launch {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got name")<br class="title-page-name"/>    name = "Inigo Montoya"<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>var catchphrase = ""<br class="title-page-name"/>launch {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got catchphrase")<br class="title-page-name"/>    catchphrase = "Hello. My name is Inigo Montoya. You killed my father. Prepare to die."<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>var repeats = 0<br class="title-page-name"/>launch {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got repeats")<br class="title-page-name"/>    repeats = 6<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>latch.await()<br class="title-page-name"/><br class="title-page-name"/>println("${name} says: ${catchphrase.repeat(repeats)}")</pre>
<p class="calibre2">You'll notice that the order of the async tasks completing is changing:</p>
<pre class="calibre18">Got name<br class="title-page-name"/>Got catchphrase<br class="title-page-name"/>Got repeats</pre>
<p class="calibre2">But in the end, we always print the same result:</p>
<pre class="calibre18"><strong class="calibre1">Inigo Montoya says: Hello. My name is Inigo Montoya. ...</strong></pre>
<p class="calibre2">But this solution brings a lot of problems. We need to work with mutable variables and either set defaults for them or use nulls. </p>
<p class="calibre2">Also, this would work as long as we use closures. What if our functions were longer than a few lines? </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">CountDownLatch</h1>
                
            
            
                
<p class="calibre2">We could pass them the latch, of course. The latch, which we've already seen a couple of times, allows one thread to wait until the other threads have completed working:</p>
<pre class="calibre18">private fun getName(latch: CountDownLatch) = launch {<br class="title-page-name"/>    ...<br class="title-page-name"/>    latch.countDown()<br class="title-page-name"/>}</pre>
<p class="calibre2">But it's not a clear separation of concerns. Do we really want to specify how this function should be synchronized? </p>
<p class="calibre2">Let's have a second take:</p>
<pre class="calibre18">private fun getName() = async {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got name")<br class="title-page-name"/>    "Inigo Montoya"<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>private fun getCatchphrase() = async {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got catchphrase")<br class="title-page-name"/>    "Hello. My name is Inigo Montoya. You killed my father. Prepare to die."<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>private fun getRepeats() = async {<br class="title-page-name"/>    delay(Random().nextInt(100))<br class="title-page-name"/>    println("Got repeats")<br class="title-page-name"/>    6<br class="title-page-name"/>}</pre>
<p class="calibre2">Just a reminder, <kbd class="calibre13">fun getRepeats() = async { ... }</kbd> has nothing magical in it. Its longer equivalent is:</p>
<pre class="calibre18">private fun getCatchphrase(): Deferred&lt;String&gt; {<br class="title-page-name"/>    return async {<br class="title-page-name"/>        ...<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can call our code to get the same results as before:</p>
<pre class="calibre18">val name = getName()<br class="title-page-name"/>val catchphrase = getCatchphrase()<br class="title-page-name"/>val repeats = getRepeats()<br class="title-page-name"/><br class="title-page-name"/>println("${name.<strong class="calibre1">await()</strong>} says: ${catchphrase.<strong class="calibre1">await()</strong>.repeat(repeats.<strong class="calibre1">await()</strong>)}")</pre>
<p class="calibre2">But we can improve it further by using our old friend, data class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Data class as Barrier</h1>
                
            
            
                
<p class="calibre2">Now our data class is the Barrier:</p>
<pre class="calibre18">val character = FavoriteCharacter(getName().await(), getCatchphrase().await(), getRepeats().await())<br class="title-page-name"/><br class="title-page-name"/>// Will happen only when everything is ready<br class="title-page-name"/>with(character) {<br class="title-page-name"/>    println("$name says: ${catchphrase.repeat(repeats)}")    <br class="title-page-name"/>}</pre>
<p class="calibre2">The additional benefit of data classes as Barriers is the ability to destructure them easily:</p>
<pre class="calibre18">val (name, catchphrase, repeats) = character<br class="title-page-name"/>println("$name says: ${catchphrase.repeat(repeats)}")</pre>
<p class="calibre2">This works well if the type of data we receive from different asynchronous tasks is widely different. In this example, we receive both <kbd class="calibre13">String</kbd> and <kbd class="calibre13">Int</kbd>. </p>
<p class="calibre2">In some cases, we receive the same types of data from different sources. </p>
<p class="calibre2">For example, let's ask Michael (our canary product owner), Jake (our barista), and me who our favorite movie character is:</p>
<pre class="calibre18">object Michael {<br class="title-page-name"/>    fun getFavoriteCharacter() = async {<br class="title-page-name"/>        // Doesn't like to think much<br class="title-page-name"/>        delay(Random().nextInt(10))<br class="title-page-name"/>        FavoriteCharacter("Terminator", "Hasta la vista, baby", 1)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>object Jake {<br class="title-page-name"/>    fun getFavoriteCharacter() = async {<br class="title-page-name"/>        // Rather thoughtful barista<br class="title-page-name"/>        delay(Random().nextInt(100) + 10)<br class="title-page-name"/>        FavoriteCharacter("Don Vito Corleone", "I'm going to make him an offer he can't refuse", 1)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>object Me {<br class="title-page-name"/>    fun getFavoriteCharacter() = async {<br class="title-page-name"/>        // I already prepared the answer!<br class="title-page-name"/>        FavoriteCharacter("Inigo Montoya", "Hello, my name is...", 6)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">In that case, we can use a list to gather the results:</p>
<pre class="calibre18">val favoriteCharacters = listOf(Me.getFavoriteCharacter().await(),<br class="title-page-name"/>        Michael.getFavoriteCharacter().await(),<br class="title-page-name"/>        Jake.getFavoriteCharacter().await())<br class="title-page-name"/><br class="title-page-name"/>println(favoriteCharacters)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Scheduler</h1>
                
            
            
                
<p class="calibre2">This is another concept we discussed briefly in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14">Threads and Coroutines</em>, in the <em class="calibre14">Starting a coroutine</em> section. </p>
<p class="calibre2">Remember how our <kbd class="calibre13">launch()</kbd> or <kbd class="calibre13">async()</kbd> could receive <kbd class="calibre13">CommonPool</kbd>?</p>
<p class="calibre2">Here's an example to remind you that you could specify it explicitly:</p>
<pre class="calibre18">// Same as launch {}<br class="title-page-name"/>launch(<strong class="calibre1">CommonPool</strong>) {<br class="title-page-name"/>...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>// Same as async {}<br class="title-page-name"/>val result = async(<strong class="calibre1">CommonPool</strong>) {<br class="title-page-name"/>...<br class="title-page-name"/>}</pre>
<p class="calibre2">This <kbd class="calibre13">CommonPool</kbd> is a Scheduler design pattern in a bad disguise. Many async tasks may be mapped to the same Scheduler.</p>
<p class="calibre2">Run the following code:</p>
<pre class="calibre18">val r1 = async(CommonPool) {<br class="title-page-name"/>    for (i in 1..1000) {<br class="title-page-name"/>        println(Thread.currentThread().name)<br class="title-page-name"/>        yield()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>r1.await()</pre>
<p class="calibre2">What is interesting is the fact that the same coroutine is picked up by different threads:</p>
<pre class="calibre18"><strong class="calibre1">ForkJoinPool.commonPool-worker-2</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-3</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-3</strong><br class="title-page-name"/><strong class="calibre1">ForkJoinPool.commonPool-worker-1</strong></pre>
<p class="calibre2">You can also specify the context as <kbd class="calibre13">Unconfined</kbd>:</p>
<pre class="calibre18">val r1 = async(Unconfined) {<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">This will run the coroutine on the main thread. It prints:</p>
<pre class="calibre18"><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">You can also inherit context from your parent coroutine:</p>
<pre class="calibre18">val r1 = async {<br class="title-page-name"/>    for (i in 1..1000) {<br class="title-page-name"/>        val parentThread = Thread.currentThread().name<br class="title-page-name"/>        launch(coroutineContext) {<br class="title-page-name"/>            println(Thread.currentThread().name == parentThread)<br class="title-page-name"/>        }<br class="title-page-name"/>        yield()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note though, that running in the same context doesn't mean that we run on the same thread.</p>
<p class="calibre2">You may ask yourself: what's the difference between inheriting the context and using <kbd class="calibre13">Unconfined</kbd>? We'll discuss this in detail in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Understanding contexts</h1>
                
            
            
                
<p class="calibre2">To understand different contexts, let's look at the following code:</p>
<pre class="calibre18">val r1 = async(<strong class="calibre1">Unconfined</strong>) {<br class="title-page-name"/>    for (i in 1..1000) {<br class="title-page-name"/>        println(Thread.currentThread().name)<br class="title-page-name"/>        <strong class="calibre1">delay(1)</strong><br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>r1.await()</pre>
<p class="calibre2">Instead of <kbd class="calibre13">yield()</kbd>, we're using the <kbd class="calibre13">delay()</kbd> function, which also suspends the current coroutine. </p>
<p class="calibre2">But the output compared to <kbd class="calibre13">yield()</kbd> is different:</p>
<pre class="calibre18"><strong class="calibre1">main</strong><br class="title-page-name"/><strong class="calibre1">kotlinx.coroutines.DefaultExecutor</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">After calling <kbd class="calibre13">delay()</kbd> for the first time, the coroutine has switched context, and as a result, threads.</p>
<p class="calibre2">For that reason, using <kbd class="calibre13">Unconfined</kbd> is not recommended for CPU-intensive tasks or tasks that need to run on a particular thread, such as UI rendering.</p>
<p class="calibre2">You can also create your own thread pool for coroutines to run on:</p>
<pre class="calibre18"><strong class="calibre1">val pool = newFixedThreadPoolContext(2, "My Own Pool")</strong><br class="title-page-name"/>val r1 = async(pool) {<br class="title-page-name"/>    for (i in 1..1000) {<br class="title-page-name"/>        println(Thread.currentThread().name)<br class="title-page-name"/>        yield()<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>r1.await()<br class="title-page-name"/><strong class="calibre1">pool.close()</strong></pre>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-1</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">My Own Pool-2</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">If you create your own thread pool, make sure that you either release it with <kbd class="calibre13">close()</kbd> or reuse it, since creating a new thread pool and holding to it is expensive in terms of resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pipelines</h1>
                
            
            
                
<p class="calibre2">In our <kbd class="calibre13">StoryLand</kbd>, the same lazy architect, me, is struggling with a problem. Back in <a href="part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 4</a>, <em class="calibre14">Getting Familiar with Behavioral Patterns</em>, we wrote an HTML page parser. But it depends on whether somebody already fetched the pages to parse for us. It is also not very flexible.</p>
<p class="calibre2">What we would like is for one coroutine to produce an infinite stream of news, and for others to parse that stream in steps.</p>
<p class="calibre2">To start working with DOM, we'll need a library, such as <kbd class="calibre13">kotlinx.dom</kbd><em class="calibre14">. </em>If you're using <strong class="calibre5">Gradle</strong>, make sure you add the following lines to your <kbd class="calibre13">build.gradle</kbd>:</p>
<pre class="calibre18">repositories {<br class="title-page-name"/>    ...<br class="title-page-name"/>    <strong class="calibre1">jcenter()</strong><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>dependencies {<br class="title-page-name"/>    ...<br class="title-page-name"/>    <strong class="calibre1">compile </strong><strong class="calibre1">"org.jetbrains.kotlinx:kotlinx.dom:0.0.10"</strong><br class="title-page-name"/>}</pre>
<p class="calibre2">Now, to the task at hand. </p>
<p class="calibre2">First, we would like to fetch news pages once in a while. For that, we'll have a producer:</p>
<pre class="calibre18">fun producePages() = produce {<br class="title-page-name"/>    fun getPages(): List&lt;String&gt; {<br class="title-page-name"/>        // This should actually fetch something<br class="title-page-name"/>        return listOf("&lt;html&gt;&lt;body&gt;&lt;H1&gt;Cool stuff&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;",<br class="title-page-name"/>                "&lt;html&gt;&lt;body&gt;&lt;H1&gt;Event more stuff&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;").shuffled()<br class="title-page-name"/>    }<br class="title-page-name"/>    while (<strong class="calibre1">this.isActive</strong>) {<br class="title-page-name"/>        val pages = getPages()<br class="title-page-name"/>        for (p in pages) {<br class="title-page-name"/>            send(p)<br class="title-page-name"/>        }<br class="title-page-name"/>        delay(TimeUnit.SECONDS.toMillis(5))<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">We use <kbd class="calibre13">shuffled()</kbd> here so the order of the list elements won't be the same all the time.</p>
<p class="calibre2">The <kbd class="calibre13">isActive</kbd> flag will be true as long as the coroutine is running and hasn't been canceled. It is good practice to check this property in loops that may run for a long time, so they could be stopped between iterations.</p>
<p class="calibre2">Each time we receive new titles, we send them downstream.</p>
<p class="calibre2">Since tech news isn't updated very often. We can check for updates only once in a while, using <kbd class="calibre13">delay()</kbd>. In the actual code, the delay would probably be minutes, if not hours.</p>
<p class="calibre2">The next step is creating <strong class="calibre5">Document Object Model</strong> (<strong class="calibre5">DOM</strong>) out of those raw strings containing HTML. For that we'll have a second producer, this one receiving a channel that connects it to the first one:</p>
<pre class="calibre18">fun produceDom(<strong class="calibre1">pages: ReceiveChannel&lt;String&gt;</strong>) = produce {<br class="title-page-name"/><br class="title-page-name"/>    fun parseDom(page: String): Document {<br class="title-page-name"/>         return kotlinx.dom.parseXml(<em class="calibre25">page.toSource()</em>)<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    <strong class="calibre1">for (p in pages)</strong> {<br class="title-page-name"/>        send(parseDom(p))<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We can use the <kbd class="calibre13">for</kbd> loop to iterate over the channel as long as more data is coming. This is a very elegant way of consuming data from a channel. </p>
<p class="calibre2">In this producer, we finally make use of the DOM parser we imported a while ago. We also introduced an extension function on <kbd class="calibre13">String</kbd> for our convenience:</p>
<pre class="calibre18">private fun String.toSource(): InputSource {<br class="title-page-name"/>    return InputSource(StringReader(this))<br class="title-page-name"/>}</pre>
<p class="calibre2">That's because <kbd class="calibre13">parseXml()</kbd> expects <kbd class="calibre13">InputSource</kbd> as its input. Basically, this is an <strong class="calibre5">Adapter</strong> design pattern in action:</p>
<pre class="calibre18">fun produceTitles(parsedPages: ReceiveChannel&lt;Document&gt;) = produce {<br class="title-page-name"/>    fun getTitles(dom: Document): List&lt;String&gt; {<br class="title-page-name"/>        val h1 = dom.getElementsByTagName("H1")<br class="title-page-name"/>        return h1.asElementList().map {<br class="title-page-name"/>            it.textContent<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    for (page in parsedPages) {<br class="title-page-name"/>        for (t in getTitles(page)) {<br class="title-page-name"/>            send(t)<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We're looking for the headers, hence <kbd class="calibre13">getElementsByTagName("H1")</kbd>. For each header found, and there may be more than one, we get its text with <kbd class="calibre13">textContent</kbd>.</p>
<p class="calibre2">Finally, we're sending each header from each page to the next in line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Establishing a pipeline</h1>
                
            
            
                
<p class="calibre2">Now, to establish our pipeline:</p>
<pre class="calibre18">val pagesProducer = producePages()<br class="title-page-name"/><br class="title-page-name"/>val domProducer = produceDom(pagesProducer)<br class="title-page-name"/><br class="title-page-name"/>val titleProducer = produceTitles(domProducer)<br class="title-page-name"/><br class="title-page-name"/>runBlocking {<br class="title-page-name"/>    titleProducer.consumeEach {<br class="title-page-name"/>        println(it)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have the following:</p>
<pre class="calibre18">pagesProducer |&gt; domProducer |&gt; titleProducer |&gt; output</pre>
<p class="calibre2">A pipeline is a great way to break a long process into smaller steps. Note that each producing coroutine is a pure function, so it's also easy to test and reason about.</p>
<p class="calibre2">The entire pipeline could be stopped by calling <kbd class="calibre13">cancel()</kbd> on the first coroutine in line.</p>
<p class="calibre2">We can achieve an even nicer API by using the extension functions:</p>
<pre class="calibre18">private fun ReceiveChannel&lt;Document&gt;.titles(): ReceiveChannel&lt;String&gt; {<br class="title-page-name"/>    <strong class="calibre1">val channel = </strong><strong class="calibre1">this</strong><br class="title-page-name"/>    fun getTitles(dom: Document): List&lt;String&gt; {<br class="title-page-name"/>        val h1 = dom.getElementsByTagName("H1")<br class="title-page-name"/>        return h1.asElementList().map {<br class="title-page-name"/>            it.textContent<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    return produce {<br class="title-page-name"/>        for (page in channel) {<br class="title-page-name"/>            for (t in getTitles(page)) {<br class="title-page-name"/>                send(t)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>private fun ReceiveChannel&lt;String&gt;.dom(): ReceiveChannel&lt;Document&gt; {<br class="title-page-name"/>    val channel = this<br class="title-page-name"/>    return produce() {<br class="title-page-name"/>        for (p in channel) {<br class="title-page-name"/>            send(kotlinx.dom.parseXml(p.toSource()))<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Then we can call our code like this:</p>
<pre class="calibre18">runBlocking {<br class="title-page-name"/>    producePages().dom().titles().consumeEach {<br class="title-page-name"/>        println(it)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Kotlin really excels at creating expressive and fluent APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The fan-out design pattern</h1>
                
            
            
                
<p class="calibre2">What if the amount of work at different steps in our pipeline is very different?</p>
<p class="calibre2">For example, it takes a lot more time to fetch the HTML than to parse it. Or what if we don't have a pipeline at all, just a lot of tasks we would like to distribute between coroutines.</p>
<p class="calibre2">That's where the fan-out design pattern kicks in. The number of coroutines may read from the same channel, distributing the work.</p>
<p class="calibre2">We can have one coroutine produce some results:</p>
<pre class="calibre18">private fun producePages() = produce {<br class="title-page-name"/>    for (i in 1..10_000) {<br class="title-page-name"/>        for (c in 'a'..'z') {<br class="title-page-name"/>            send(i to "page$c")<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">And have a function that would create a coroutine that reads those results:</p>
<pre class="calibre18"><br class="title-page-name"/><br class="title-page-name"/>private fun consumePages(channel: ReceiveChannel&lt;Pair&lt;Int, String&gt;&gt;) = async {<br class="title-page-name"/>    for (p in channel) {<br class="title-page-name"/>        println(p)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This allows us to generate an arbitrary number of consumers:</p>
<pre class="calibre18">val producer = producePages()<br class="title-page-name"/><br class="title-page-name"/>val consumers = List(10) {<br class="title-page-name"/>    consumePages(producer)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>runBlocking {<br class="title-page-name"/>    consumers.forEach {<br class="title-page-name"/>        it.await()<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The fan-out design pattern allows us to efficiently distribute the work across a number of coroutines, threads, and CPUs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The fan-in design pattern</h1>
                
            
            
                
<p class="calibre2">It would be great if our coroutines could always make decisions by themselves. But what if they need to return some results from the computation to another coroutine?</p>
<p class="calibre2">The opposite of <strong class="calibre5">fan-out</strong> is the <strong class="calibre5">fan-in</strong> design pattern. Instead of multiple coroutines reading from the same channel, multiple coroutines can write their results to the same channel.</p>
<p class="calibre2">Imagine that you're reading news from two prominent tech resources: <kbd class="calibre13">techBunch</kbd> and <kbd class="calibre13">theFerge</kbd>. </p>
<p class="calibre2">Each resource produces the values at its own pace, and sends them over a channel:</p>
<pre class="calibre18">private fun techBunch(collector: Channel&lt;String&gt;) = launch {<br class="title-page-name"/>    repeat(10) {<br class="title-page-name"/>        delay(Random().nextInt(1000))<br class="title-page-name"/>        collector.send("Tech Bunch")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>private fun theFerge(collector: Channel&lt;String&gt;) = launch {<br class="title-page-name"/>    repeat(10) {<br class="title-page-name"/>        delay(Random().nextInt(1000))<br class="title-page-name"/>        collector.send("The Ferge")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">By providing them with the same channel, we can combine their results:</p>
<pre class="calibre18">val collector = Channel&lt;String&gt;()<br class="title-page-name"/><br class="title-page-name"/>techBunch(collector)<br class="title-page-name"/>theFerge(collector)<br class="title-page-name"/><br class="title-page-name"/>runBlocking {<br class="title-page-name"/>    collector.consumeEachIndexed {<br class="title-page-name"/>        println("${it.index} Got news from ${it.value}")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">Combining the fan-out and fan-in design patterns is a good base for <strong class="calibre5">Map</strong>/<strong class="calibre5">Reduce</strong> algorithms.</p>
<p class="calibre2">To demonstrate that, we'll generate 10,000,000 random numbers and compute the maximum number among them by dividing this task multiple times.</p>
<p class="calibre2">First, to generate the list of 10,000,000 random integers:</p>
<pre class="calibre18">val numbers = List(10_000_000) {<br class="title-page-name"/>    Random().nextInt()<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Managing workers</h1>
                
            
            
                
<p class="calibre2">Now we'll have two types of workers:</p>
<ul class="calibre11">
<li class="calibre12">The divide worker will receive the list of numbers, determine the biggest number in the list, and send it over to the output channel:</li>
</ul>
<pre class="calibre27">fun divide(input: ReceiveChannel&lt;List&lt;Int&gt;&gt;, <br class="title-page-name"/>           output: SendChannel&lt;Int&gt;) = async {<br class="title-page-name"/>    var max = 0<br class="title-page-name"/>    for (list in input) {<br class="title-page-name"/>        for (i in list) {<br class="title-page-name"/>            if (i &gt; max) {<br class="title-page-name"/>                max = i<br class="title-page-name"/>                output.send(max)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<ul class="calibre11">
<li class="calibre12">The collector will listen to this channel and each time a new sub-max number arrives, will decide whether it's the all-time biggest:</li>
</ul>
<pre class="calibre27">fun collector() = actor&lt;Int&gt; {<br class="title-page-name"/>    var max = 0<br class="title-page-name"/>    for (i in this) {<br class="title-page-name"/>        max = Math.max(max, i)<br class="title-page-name"/>    }<br class="title-page-name"/>    println(max)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we only need to establish those channels:</p>
<pre class="calibre18">val input = Channel&lt;List&lt;Int&gt;&gt;()<br class="title-page-name"/>val output = collector()<br class="title-page-name"/>val dividers = List(10) {<br class="title-page-name"/>    divide(input, output)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>launch {<br class="title-page-name"/>    for (c in numbers.chunked(1000)) {<br class="title-page-name"/>        input.send(c)<br class="title-page-name"/>    }<br class="title-page-name"/>    input.close()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>dividers.forEach {<br class="title-page-name"/>    it.await()<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>output.close()</pre>
<p class="calibre2">Note that in this case, we don't gain performance benefits, and naive <kbd class="calibre13">numbers.max()</kbd> would produce better results. But the more data you need to collect, the more useful this pattern becomes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Buffered channels</h1>
                
            
            
                
<p class="calibre2">Up until now, all the channels that we used had a capacity of exactly one element.</p>
<p class="calibre2">This means that if you write to this channel but no one reads from it, the sender will be suspended:</p>
<pre class="calibre18">val channel = Channel&lt;Int&gt;()<br class="title-page-name"/><br class="title-page-name"/>val j = launch {<br class="title-page-name"/>    for (i in 1..10) {<br class="title-page-name"/>        channel.send(i)<br class="title-page-name"/>        println("Sent $i")</pre>
<pre class="calibre18">    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>j.join()</pre>
<p class="calibre2">This code doesn't print anything because the coroutine is waiting for someone to read from the channel.</p>
<p class="calibre2">To avoid that, we can create a buffered channel:</p>
<pre class="calibre18">val channel = Channel&lt;Int&gt;<strong class="calibre1">(5)</strong></pre>
<p class="calibre2">Now suspension will occur only when the channel capacity is reached.</p>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">Sent 1</strong><br class="title-page-name"/><strong class="calibre1">Sent 2</strong><br class="title-page-name"/><strong class="calibre1">Sent 3</strong><br class="title-page-name"/><strong class="calibre1">Sent 4</strong><br class="title-page-name"/><strong class="calibre1">Sent 5</strong></pre>
<p class="calibre2">Since <kbd class="calibre13">produce()</kbd> and <kbd class="calibre13">actor()</kbd> are also backed up by a channel, we can make it buffered too:</p>
<pre class="calibre18">val actor = actor&lt;Int&gt;(capacity = 5) {<br class="title-page-name"/>    ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val producer = produce&lt;Int&gt;(capacity = 10) {<br class="title-page-name"/>    ...        <br class="title-page-name"/>}<br class="title-page-name"/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Unbiased select</h1>
                
            
            
                
<p class="calibre2">One of the most useful ways to work with channels is the <kbd class="calibre13">select {}</kbd> clause we saw in <a href="part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7" class="calibre10">Chapter 8</a>, <em class="calibre14">Threads and Coroutines</em>, in the <em class="calibre14">Producers</em> section. </p>
<p class="calibre2">But select is inherently biased. If two events happen at the same time, it will select the first clause.</p>
<p class="calibre2">In the following example, we'll have a producer that sends five values with a very short delay:</p>
<pre class="calibre18">fun producer(name: String, repeats: Int) = produce {<br class="title-page-name"/>    repeat(repeats) {<br class="title-page-name"/>        delay(1)<br class="title-page-name"/>        send(name)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We'll create three such producers and see the results:</p>
<pre class="calibre18">val repeats = 10_000<br class="title-page-name"/>val p1 = producer("A", repeats)<br class="title-page-name"/>val p2 = producer("B", repeats)<br class="title-page-name"/>val p3 = producer("C", repeats)<br class="title-page-name"/><br class="title-page-name"/>val results = ConcurrentHashMap&lt;String, Int&gt;()<br class="title-page-name"/>repeat(repeats) {<br class="title-page-name"/>    val result = <strong class="calibre1">select</strong>&lt;String&gt; {<br class="title-page-name"/>        p1.onReceive { it }<br class="title-page-name"/>        p2.onReceive { it }<br class="title-page-name"/>        p3.onReceive { it }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    results.compute(result) { k, v -&gt;<br class="title-page-name"/>        if (v == null) {<br class="title-page-name"/>            1<br class="title-page-name"/>        }<br class="title-page-name"/>        else {<br class="title-page-name"/>            v + 1<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println(results)</pre>
<p class="calibre2">We run this code five times. Here are some of the results:</p>
<pre class="calibre18"><strong class="calibre1">{A=8235, B=1620, C=145}</strong><br class="title-page-name"/><strong class="calibre1">{A=7850, B=2062, C=88}</strong><br class="title-page-name"/><strong class="calibre1">{A=7878, B=2002, C=120}</strong><br class="title-page-name"/><strong class="calibre1">{A=8260, B=1648, C=92}</strong><br class="title-page-name"/><strong class="calibre1">{A=7927, B=2011, C=62}</strong></pre>
<p class="calibre2">As you can see, <kbd class="calibre13">A</kbd> almost always wins, while <kbd class="calibre13">C</kbd> is always third. The more <kbd class="calibre13">repeats</kbd> you set, the larger the bias gets.</p>
<p class="calibre2">Now let's use <kbd class="calibre13">selectUnbiased</kbd> instead:</p>
<pre class="calibre18">...<br class="title-page-name"/>val result = selectUnbiased&lt;String&gt; {<br class="title-page-name"/>    p1.onReceive { it }<br class="title-page-name"/>    p2.onReceive { it }<br class="title-page-name"/>    p3.onReceive { it }<br class="title-page-name"/>}<br class="title-page-name"/>...</pre>
<p class="calibre2">The results of the first five executions may look like this:</p>
<pre class="calibre18"><strong class="calibre1">{A=3336, B=3327, C=3337}</strong><br class="title-page-name"/><strong class="calibre1">{A=3330, B=3332, C=3338}</strong><br class="title-page-name"/><strong class="calibre1">{A=3334, B=3333, C=3333}</strong><br class="title-page-name"/><strong class="calibre1">{A=3334, B=3336, C=3330}</strong><br class="title-page-name"/><strong class="calibre1">{A=3332, B=3335, C=3333}</strong></pre>
<p class="calibre2">Not only are the numbers distributed more evenly now, but all clauses have an equal chance of being selected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mutexes</h1>
                
            
            
                
<p class="calibre2">Also known as mutual exclusions, mutexes provide a means to protect a shared state.</p>
<p class="calibre2">Let's start with same, old, dreaded counter example:</p>
<pre class="calibre18">var counter = 0<br class="title-page-name"/><br class="title-page-name"/>val jobs = List(10) {<br class="title-page-name"/>    launch {<br class="title-page-name"/>        repeat(1000) {<br class="title-page-name"/>            counter++<br class="title-page-name"/>            yield()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>runBlocking {<br class="title-page-name"/>    jobs.forEach {<br class="title-page-name"/>        it.join()<br class="title-page-name"/>    }<br class="title-page-name"/>    println(counter)<br class="title-page-name"/>}</pre>
<p class="calibre2">As you've probably guessed, this prints anything but the result of <kbd class="calibre13">10*100</kbd>. Totally embarrassing.</p>
<p class="calibre2">To solve that, we introduce a mutex:</p>
<pre class="calibre18">var counter = 0<br class="title-page-name"/><strong class="calibre1">val mutex = Mutex()</strong><br class="title-page-name"/><br class="title-page-name"/>val jobs = List(10) {<br class="title-page-name"/>    launch {<br class="title-page-name"/>        repeat(1000) {<br class="title-page-name"/>            <strong class="calibre1">mutex.lock()</strong><br class="title-page-name"/>            counter++<br class="title-page-name"/>            <strong class="calibre1">mutex.unlock()</strong><br class="title-page-name"/>            yield()<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now our example always prints the correct number.</p>
<p class="calibre2">This is good for simple cases. But what if the code within the critical section (that is, between <kbd class="calibre13">lock()</kbd> and <kbd class="calibre13">unlock()</kbd>) throws an exception?</p>
<p class="calibre2">Then we'll have to wrap everything in <kbd class="calibre13">try...catch</kbd>, which is not very convenient:</p>
<pre class="calibre18">repeat(1000) {<br class="title-page-name"/>    <strong class="calibre1">try {</strong><br class="title-page-name"/>        mutex.lock()<br class="title-page-name"/>        counter++                     <br class="title-page-name"/>   <strong class="calibre1"> </strong><strong class="calibre1">}</strong><br class="title-page-name"/><strong class="calibre1">    finally {</strong><br class="title-page-name"/>        mutex.unlock()                    <br class="title-page-name"/>    <strong class="calibre1">}</strong><br class="title-page-name"/>    <br class="title-page-name"/>    yield()<br class="title-page-name"/>}</pre>
<p class="calibre2">Exactly for that purpose, Kotlin also introduces <kbd class="calibre13">withLock()</kbd>:</p>
<pre class="calibre18">...<br class="title-page-name"/>repeat(1000) {<br class="title-page-name"/>    <strong class="calibre1">mutex.withLock </strong><strong class="calibre1">{</strong><br class="title-page-name"/>        counter++<br class="title-page-name"/>    }<br class="title-page-name"/>    yield()<br class="title-page-name"/>}<br class="title-page-name"/>...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Selecting on close</h1>
                
            
            
                
<p class="calibre2">Reading from a channel using <kbd class="calibre13">select()</kbd> is nice until it gets closed.</p>
<p class="calibre2">You can see an example of that problem here:</p>
<pre class="calibre18">val p1 = produce {<br class="title-page-name"/>    repeat(10) {<br class="title-page-name"/>        send("A")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val p2 = produce {<br class="title-page-name"/>    repeat(5) {<br class="title-page-name"/>        send("B")<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>runBlocking { <br class="title-page-name"/>    repeat(15) {<br class="title-page-name"/>        val result = selectUnbiased&lt;String&gt; {<br class="title-page-name"/>            p1.onReceive {<br class="title-page-name"/>                it<br class="title-page-name"/>            }<br class="title-page-name"/>            p2.onReceive {<br class="title-page-name"/>                it<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        println(result)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Although the numbers add up, we may often receive <kbd class="calibre13">ClosedReceiveChannelException</kbd> running this code. That's because the second producer has fewer items, and as soon as it finishes, it will close its channel.</p>
<p class="calibre2">To avoid that, we can use <kbd class="calibre13">onReceiveOrNull</kbd>, which will return a nullable version at the same time. Once the channel gets closed, we'll receive <kbd class="calibre13">null</kbd> in our <kbd class="calibre13">select</kbd>.</p>
<p class="calibre2">We can handle this null value in any way we want, for example, by making use of the <kbd class="calibre13">elvis</kbd> operator:</p>
<pre class="calibre18">repeat(15) {<br class="title-page-name"/>    val result = selectUnbiased&lt;String&gt; {<br class="title-page-name"/>        p1.onReceiveOrNull {<br class="title-page-name"/>            // Can throw my own exception<br class="title-page-name"/>            it <strong class="calibre1">?: throw RuntimeException()</strong><br class="title-page-name"/>        }<br class="title-page-name"/>        p2.onReceiveOrNull {<br class="title-page-name"/>            // Or supply default value<br class="title-page-name"/>            it <strong class="calibre1">?: </strong><strong class="calibre1">"p2 closed"</strong><br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    println(result)<br class="title-page-name"/>}</pre>
<p class="calibre2">Using that knowledge, we can drain both channels by skipping the null results:</p>
<pre class="calibre18">var count = 0<br class="title-page-name"/>while (count &lt; 15) {<br class="title-page-name"/>    val result = selectUnbiased&lt;<strong class="calibre1">String?</strong>&gt; {<br class="title-page-name"/>        p1.onReceiveOrNull {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>        p2.onReceiveOrNull {<br class="title-page-name"/>            it<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (result != null) {<br class="title-page-name"/>        println(result)<br class="title-page-name"/>        count++<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sidekick channel</h1>
                
            
            
                
<p class="calibre2">Up until now, we've only discussed the usages of <kbd class="calibre13">select</kbd> as a receiver. But we can also use <kbd class="calibre13">select</kbd> to send items to another channel.</p>
<p class="calibre2">Let's look at the following example:</p>
<pre class="calibre18">val batman = actor&lt;String&gt; {<br class="title-page-name"/>    for (c in this) {<br class="title-page-name"/>        println("Batman is beating some sense into $c")<br class="title-page-name"/>        delay(100)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>val robin = actor&lt;String&gt; {<br class="title-page-name"/>    for (c in this) {<br class="title-page-name"/>        println("Robin is beating some sense into $c")<br class="title-page-name"/>        delay(250)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have a superhero and their sidekick as two actors. Since the superhero is more experienced, it usually takes them less time to beat the villain they're facing. </p>
<p class="calibre2">But in some cases, they still have their hands full, so a sidekick needs to step in.</p>
<p class="calibre2">We'll throw five villains at the pair with a few delays, and see how they fare:</p>
<pre class="calibre18">val j = launch {<br class="title-page-name"/>    for (c in listOf("Jocker", "Bane", "Penguin", "Riddler", "Killer Croc")) {<br class="title-page-name"/>        val result = select&lt;Pair&lt;String, String&gt;&gt; {<br class="title-page-name"/>            batman.onSend(c) {<br class="title-page-name"/>                Pair("Batman", c)<br class="title-page-name"/>            }<br class="title-page-name"/>            robin.onSend(c) {<br class="title-page-name"/>                Pair("Robin", c)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        delay(90)<br class="title-page-name"/>        println(result)<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">It prints:</p>
<pre class="calibre18"><strong class="calibre1">Batman is beating some sense into Jocker</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Jocker)</strong><br class="title-page-name"/><strong class="calibre1">Robin is beating some sense into Bane</strong><br class="title-page-name"/><strong class="calibre1">(Robin, Bane)</strong><br class="title-page-name"/><strong class="calibre1">Batman is beating some sense into Penguin</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Penguin)</strong><br class="title-page-name"/><strong class="calibre1">Batman is beating some sense into Riddler</strong><br class="title-page-name"/><strong class="calibre1">(Batman, Riddler)</strong><br class="title-page-name"/><strong class="calibre1">Robin is beating some sense into Killer Croc</strong><br class="title-page-name"/><strong class="calibre1">(Robin, Killer Croc)</strong></pre>
<p class="calibre2">Notice that the type parameter for this select refers to what is returned from the block, and not what is being sent to the channels. </p>
<p class="calibre2">That's the reason we use <kbd class="calibre13">Pair&lt;String, String&gt;</kbd> here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deferred channel</h1>
                
            
            
                
<p class="calibre2">The more you work with coroutines, the more you'll get used to await results. At some point, you'll start sending deferred values over channels.</p>
<p class="calibre2">We'll start by creating 10 async tasks. The first will delay for a long time, and others we delay for a short time:</p>
<pre class="calibre18">val elements = 10<br class="title-page-name"/>val deferredChannel = Channel&lt;Deferred&lt;Int&gt;&gt;(elements)<br class="title-page-name"/><br class="title-page-name"/>launch(CommonPool) {<br class="title-page-name"/>    repeat(elements) { i -&gt;<br class="title-page-name"/>        println("$i sent")<br class="title-page-name"/>        deferredChannel.send(async {<br class="title-page-name"/>            delay(if (i == 0) 1000 else 10)<br class="title-page-name"/>            i<br class="title-page-name"/>        })<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">We'll put all those results into a buffered channel.</p>
<p class="calibre2">Now we can read from this channel, and be using a second <kbd class="calibre13">select</kbd> block, and await the results:</p>
<pre class="calibre18">val time = measureTimeMillis {<br class="title-page-name"/>    repeat(elements) {<br class="title-page-name"/>        val result = select&lt;Int&gt; {<br class="title-page-name"/>            deferredChannel.onReceive {<br class="title-page-name"/>                <strong class="calibre1">select </strong><strong class="calibre1">{</strong><br class="title-page-name"/>                    it.<strong class="calibre1">onAwait</strong> { it }<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        println(result)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>println("Took ${time}ms")</pre>
<p class="calibre2">Note that the resulting time is of the slowest task:</p>
<pre class="calibre18"><strong class="calibre1">Took 1010ms</strong></pre>
<p class="calibre2">You can also use <kbd class="calibre13">onAwait()</kbd> as a stop signal for another channel.</p>
<p class="calibre2">For that, we'll create an async task that will complete in 600 ms:</p>
<pre class="calibre18">val stop = async {<br class="title-page-name"/>    delay(600)<br class="title-page-name"/>    true<br class="title-page-name"/>}<br class="title-page-name"/></pre>
<p class="calibre2">And, as in the previous example, we'll send 10 deferred values over the buffered channel:</p>
<pre class="calibre18">val channel = Channel&lt;Deferred&lt;Int&gt;&gt;(10)<br class="title-page-name"/><br class="title-page-name"/>repeat(10) {i -&gt;<br class="title-page-name"/>    channel.send(async {<br class="title-page-name"/>        delay(i * 100)<br class="title-page-name"/>        i<br class="title-page-name"/>    })<br class="title-page-name"/>}</pre>
<p class="calibre2">Then we'll wait for either a new value or a notification that the channel should be closed:</p>
<pre class="calibre18">runBlocking {<br class="title-page-name"/>    for (i in 1..10) {<br class="title-page-name"/>        select&lt;Unit&gt; {<br class="title-page-name"/>            stop.onAwait {<br class="title-page-name"/>                channel.close()<br class="title-page-name"/>            }<br class="title-page-name"/>            channel.onReceive {<br class="title-page-name"/>                println(it.await())<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">This prints only six values out of ten, as expected, stopping after 600 ms have passed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we covered various design patterns related to concurrency in Kotlin. Most of them are based on coroutines, channels, deferred values, or a combination. </p>
<p class="calibre2"><strong class="calibre5">Pipeline</strong>, <strong class="calibre5">fan-in</strong>, and <strong class="calibre5">fan-out</strong> help distribute work and collect the results. <strong class="calibre5">Deferred values</strong> are used as placeholders for something that would resolve at a later time. <strong class="calibre5">Schedulers</strong> help us manage resources, mainly threads that back up the coroutines. <strong class="calibre5">Mutexes</strong> and <strong class="calibre5">Barriers</strong> help control that concurrency.</p>
<p class="calibre2">Now you should understand the <kbd class="calibre13">select</kbd> block and how it can be combined with channels and deferred values efficiently.</p>
<p class="calibre2">In the next chapter, we'll discuss Kotlin's idioms, best practices, and some of the anti-patterns that emerged with the language.</p>


            

            
        
    </body></html>