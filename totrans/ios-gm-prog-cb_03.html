<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Animations and Texture</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 2. SpriteKit" href="part0018_split_000.html#page">Chapter 2</a>, <em class="calibre9">SpriteKit</em>, you learned about the basic structure of SpriteKit and its building blocks such as scenes, nodes, sprites, and so on. We got a flying spaceship in the sky by touching the screen, and now in this chapter we will be moving to a fully featured game play for the user.</p><p class="calibre8">You will learn about how the content of sprites are changed using animations, how textures (which store sprite data) are used to render the sprites, how to create a large image for all game assets using the texture atlas, some character (spaceship) animations, and last but the most beautiful will be creating a parallax background for the game full of animations.</p><p class="calibre8">In this chapter, we will be focusing on the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Animating your textures</li><li class="listitem">Creating a texture atlas</li><li class="listitem">Adding animations using a texture atlas</li><li class="listitem">Collision detection</li><li class="listitem">Parallax background</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec19" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">Adding animations into our games using SpriteKit is an easy task, as we did in the previous chapter, where we added some <code class="email">SKAction</code> functions to get the spaceship to move. These were the animations related to their movement, orientations, and somewhat related to their transformations. However, now the animation that we are going to talk about is the content change of a sprite. Animations will be animating multiple images (that is, frames) of the same sprite multiple times per second, giving a feel of being alive for the sprite. This is somewhat similar to the way we capture the videos, it's just a sequence of the snapshots per second. These types of animations need a lot of images to be accomplished thereby increasing the memory size for these textures. The texture is represented by a <code class="email">SKTexture</code> object created and attached with the sprite. Texture object automatically loads the sprite data (called Texture data) whenever it is visible and is used to render the sprite in the respective scene. And when the sprite is removed or not visible in the scene, it deletes the texture data, and as a result automatic memory management is simplified.</p><p class="calibre8">Technically, all of this means that sprites have display frames, which have different textures that change by a fixed delay between each frame. And everything we are going to do in the starter and solution kit will be continued from where we left in the previous chapter.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Animating your textures</h1></div></div></div><p class="calibre8">In this recipe, we<a id="id87" class="calibre1"/> will look at how textures are created and attached to sprites. We will also do some content change (that is, frame changing animations) with the help of textures.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec40" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To get started with textures to be animated, we should know about scenes, nodes, and sprites. As sprites are created with an image and are added on scene, which occupies more memory, textures should be a solution to this problem.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec41" class="calibre1"/>How to do it...</h2></div></div></div><pre></div><p class="calibre13"> </pre></li></ol><div></div><p class="calibre8">Now, as memory <a id="id88" class="calibre1"/>management is more optimized with texture, we can start with the animations to change the frames of a sprite by a fixed time. For that, we will be showing a prop in the environment, which is a coin rotating 360 degrees horizontally.</p><p class="calibre8">The following are the steps involved to make a coin look like it is rotating 360 degrees horizontally:</p><div><ol class="orderedlist"><li class="listitem" value="1">First of all, copy all the images (that is, frames) of the coin as provided in the <code class="email">Project_Resources</code> folder with the kit. There are total six images of coins, each rotated at an angle horizontally.</li><li class="listitem" value="2">Add a method to <code class="email">FSMyScene</code> called <code class="email">addCoin</code> in which we create a sprite for the coin with the initial image to be displayed on the sky background using texture (<code class="email">Coin1.png</code>).<div><pre class="programlisting">  SKTexture* coinInitialTexture = [SKTexture textureWithImageNamed:@"Coin1.png"];
  SKSpriteNode* coinSprite = [SKSpriteNode spriteNodeWithTexture:coinInitialTexture];</pre></div></li><li class="listitem" value="3">To show the coin on the screen, specify its position; as of now, the position is set to the center of the screen, and then add it to the <code class="email">FSMyScene</code>.<div><pre class="programlisting">coinSprite.position = CGPointMake(self.frame.size.width/2,self.frame.size.height/2);
[self addChild:coinSprite];</pre></div></li><li class="listitem" value="4">Similarly, create textures for the remaining frames of the coin to add frame animations.<div><pre class="programlisting">SKTexture* coin2Texture = [SKTexture textureWithImageNamed:@"Coin2.png"];
SKTexture* coin3Texture = [SKTexture textureWithImageNamed:@"Coin3.png"];
SKTexture* coin4Texture = [SKTexture textureWithImageNamed:@"Coin4.png"];
SKTexture* coin5Texture = [SKTexture textureWithImageNamed:@"Coin5.png"];
SKTexture* coin6Texture = [SKTexture textureWithImageNamed:@"Coin6.png"];</pre></div><p class="calibre15">Combining all coin textures creates an array of texture.</p><div><pre class="programlisting">NSArray *coinAnimationTextures = @[coinInitialTexture,coin2Texture,coin3Texture,coin4Texture,coin5Texture,coin6Texture];</pre></div></li><li class="listitem" value="5">Create a <code class="email">SKAction</code> class for <code class="email">coinAnimation</code> using a class method of <code class="email">SKAction</code> and run the action on the coin sprite added on <code class="email">FSMyScene</code>.<div><pre class="programlisting">SKAction *coinAnimation = [SKAction animateWithTextures:coinAnimationTexturestimePerFrame:0.2];
[coinSprite runAction:coinAnimation];</pre></div></li></ol><div></div><p class="calibre8">Adding all <a id="id89" class="calibre1"/>these lines of code makes our <code class="email">addCoin</code> method:</p><div><img src="img/00026.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec42" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">When we create a texture object using <code class="email">SKTexture</code>, as we did in the preceding section, the texture stores the image (that is, frame) data into it which is further forwarded to create a sprite. This helps in memory management, because when the sprites are removed, the data associated with them (that is, texture) is also removed thereby releasing the memory.</p><div><pre class="programlisting">SKTexture* spaceShipTexture = [SKTexture textureWithImageNamed:@"Spaceship.png"];

self.spaceShipSprite = [SKSpriteNode spriteNodeWithTexture:spaceShipTexture];</pre></div><p class="calibre8">Similarly, the <a id="id90" class="calibre1"/>coin is also added using texture in the center of the screen with its initial frame, which looks like this:</p><div><img src="img/00027.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now we will see how animations of frames work using a number of textures. We have just created some textures using some coin images, which are visually designed in increasing order of horizontal rotation angle. So an array in the same order of textures is created.</p><div><pre class="programlisting">NSArray *coinAnimationTextures = @[coinInitialTexture,coin2Texture,coin3Texture,coin4Texture,coin5Texture,coin6Texture];</pre></div><p class="calibre8">Using a class method of <code class="email">SKAction</code>, the coin animation textures array is given as an input with a frame delay of 0.2 seconds.</p><div><pre class="programlisting">  SKAction *coinAnimation = [SKAction animateWithTextures:coinAnimationTexturestimePerFrame:0.2];

  [coinSprite runAction:coinAnimation];</pre></div><p class="calibre8">The preceding function takes the textures and shows them with a delay of 0.2 seconds in the order the textures are given.</p><p class="calibre8">Hence, the overall <code class="email">addCoin</code> method with the animation code written gives a feel that a coin has rotated horizontally <a id="id91" class="calibre1"/>once in the center of the screen, and this is what the scene looks like:</p><div><img src="img/00028.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec21" class="calibre1"/>Creating a texture atlas</h1></div></div></div><p class="calibre8">The texture atlas<a id="id92" class="calibre1"/> is a way of combining all the app assets (that is, images) into one or more larger images to improve the performance of the app so that the app can draw <a id="id93" class="calibre1"/>multiple images in a single draw call of the scene that is rendered. For example, if we have more than one image file to be loaded in the sprite, SpriteKit will perform one drawing call for each sprite. However, if we combine all the required images in one image file, then SpriteKit can render all the sprites in one draw call that uses very less memory to do so. It is recommended to create an atlas of all the required images for any game project.</p><p class="calibre8">Xcode has the capability of building texture atlases for your collection of images to make it a larger image, thereby improving the performance. While creating texture atlases, there should be a balance of too many or very few textures, so that the memory load doesn't increase.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec43" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To create a texture atlas, we should be aware of what sprites and textures are, most importantly <a id="id94" class="calibre1"/>how the sprite is created using textures. We will take the <em class="calibre9">Animating your textures</em> recipe as a reference to start this. In this recipe, we will be learning how to create a texture atlas for a collection of images that are coin images used for animation and the spaceship.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec44" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">The following are the steps to be performed for creating a texture atlas for a collection of images:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a system folder where your project is stored in the starter project of <code class="email">FlyingSpaceship</code>.<div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">It should not be an Xcode group folder; it has to be a system folder.</p></div></li><li class="listitem" value="2">In that folder, add all images of coins and the image of the spaceship added previously in the app bundle.</li><li class="listitem" value="3">Right-click on the <code class="email">Resources</code> folder and click on <strong class="calibre2">Add Files to "FlyingSpaceship"</strong>.<div><img src="img/00029.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">A finder view is opened. From there, select <code class="email">FSGame.atlas</code> and click on the <strong class="calibre2">Add</strong> button. Whenever <a id="id95" class="calibre1"/>we build the project, the compiler looks for folders with a naming convention such as <code class="email">name.atlas</code>. Hence, the folders are identified and all the images in that folder are combined to form one or more large images.<div><img src="img/00030.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">After adding the <code class="email">FSGame.atlas</code> file to the project, the <code class="email">Resources</code> folder looks like this:<div><img src="img/00031.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="6">Now, for enabling the generation of the Texture Atlas, go to the build settings of the project and search for type <code class="email">Spritekit</code>; the search results will look like this:<div><img src="img/00032.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="7">Now <a id="id96" class="calibre1"/>you can see the <strong class="calibre2">Enable Texture Atlas Generation</strong> field in the <strong class="calibre2">SpriteKit Deployment Options</strong> section. Set that bool to <strong class="calibre2">Yes</strong>.<div><img src="img/00033.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre13"> </p></li></ol><div></div><p class="calibre8">As a result, whenever we build the project, the compiler generates a property list to access the images of the texture atlas by its name, which we have given to the folder.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec45" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">After the creation of the texture atlas, the most important part is how we will be able to access images from the texture atlas. It's done by enabling the bool <strong class="calibre2">Enable Texture Atlas Generation</strong>. After this, whenever we build the project, the compiler looks for folders with a naming convention such as <code class="email">name.atlas</code>. Hence, the folders are identified and all the images in that folder are combined to form one or more large images.</p><p class="calibre8">Here, Xcode generates a <code class="email">.plist</code> file after setting the bool. After that, the texture atlas name is used to<a id="id97" class="calibre1"/> get the texture atlas in the code and from there we can get any image, which is put in that folder that is, texture atlas.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch03lvl2sec46" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">Whenever we create a texture atlas, there is always a trade-off between using too many textures or few images. When using few images SpriteKit still needs to make many drawing calls to render each frame. And for many textures, the images in quantity may increase the texture data thereby leading to a load on the memory. So it's up to us how we want to go; we can switch between both the alternatives with relative ease. Hence, different configurations can be tried out to have the best performance.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec22" class="calibre1"/>Adding animations using a texture atlas</h1></div></div></div><p class="calibre8">We have already<a id="id98" class="calibre1"/> learned about animations even before learning how to use textures for loading images from <code class="email">App Bundle</code>. As we<a id="id99" class="calibre1"/> have a texture atlas (that is, a larger combined image), we will be loading the images by that texture atlas. All sprites added in the <code class="email">FSMyScene</code> file are loaded by the images from the <code class="email">App Bundle</code>, so now we will be loading all the images by the texture atlas in the sprite. Lastly, some animations will be applied to them using the texture atlas to load the images.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec47" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before starting with the animations using a texture atlas to load images, we should know the process of creating a texture atlas using a combination of images and doing some animations of changing frame after a fixed delay. So here we will be doing the same animation of coin rotation we did earlier, but now using a texture atlas. This recipe will be called <em class="calibre9">Adding animations using a texture atlas</em>. After that we will animate a bunch of coins from one end to another (right to left) in the <code class="email">FSMyScene</code> in a random fashion giving a feel that coins are just moving in the sky.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec48" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre8">First of all, we will be replacing the creation of textures using the image by the texture atlas images in <code class="email">App Bundle</code>. Perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create an object of <code class="email">SKTextureAtlas</code> by specifying its name that is, <code class="email">FSGame</code> (name of the texture atlas).<div><pre class="programlisting">  SKTextureAtlas *textureAtlas = [SKTextureAtlas atlasNamed:@"FSGame"];</pre></div><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">The images previously added to the project bundle should be removed to avoid redundancy.</p></div><div><pre class="programlisting">  SKTexture* spaceShipTexture = [SKTexture textureWithImageNamed:@"Spaceship.png"];</pre></div></li><li class="listitem" value="2">Now<a id="id100" class="calibre1"/> create the texture using a texture atlas object by passing the spaceship image that has to be set to the sprite.<div><pre class="programlisting">  SKTexture* spaceShipTexture = [textureAtlas textureNamed:@"Spaceship.png"];</pre></div></li><li class="listitem" value="3">In the<a id="id101" class="calibre1"/> <code class="email">addCoin</code> method of FSMyScene, use the preceding process to create the textures using the t<code class="email">extureAtlas</code> object for all coin textures.<div><pre class="programlisting">  SKTextureAtlas *textureAtlas = [SKTextureAtlas atlasNamed:@"FSGame"];

  SKTexture* coinInitialTexture = [textureAtlas textureNamed:@"Coin1.png"];

  SKTexture* coin2Texture = [textureAtlas textureNamed:@"Coin2.png"];
  SKTexture* coin3Texture = [textureAtlas textureNamed:@"Coin3.png"];
  SKTexture* coin4Texture = [textureAtlas textureNamed:@"Coin4.png"];
  SKTexture* coin5Texture = [textureAtlas textureNamed:@"Coin5.png"];
  SKTexture* coin6Texture = [textureAtlas textureNamed:@"Coin6.png"];</pre></div></li><li class="listitem" value="4">Once all the textures are created, use the same code of <code class="email">addCoin</code> to add and animate the coin.</li><li class="listitem" value="5">Let's make the coin animation more live and natural. Feed the action formed for animating the texture with a fixed delay to another <code class="email">SKAction</code> making it repeat forever giving a feel of continuous rotation of coin (never ending).<div><pre class="programlisting">  SKAction *rotateAction = [SKAction animateWithTextures:coinAnimationTextures timePerFrame:0.2];
  
  SKAction *coinRepeatForeverAnimation = [SKAction repeatActionForever:rotateAction];
    
  [coinSprite runAction:coinRepeatForeverAnimation];</pre></div></li><li class="listitem" value="6">After a little tweaking, remove the last texture from the array so that when the <code class="email">repeatForever</code> action is going to run, the first image will appear after the last image, so there is no need for the last texture.<div><pre class="programlisting">  NSArray *coinAnimationTextures = @[coinInitialTexture,coin2Texture,coin3Texture,coin4Texture,coin5Texture,coin6Texture];</pre></div></li></ol><div></div><p class="calibre8">Now our<a id="id102" class="calibre1"/> forever<a id="id103" class="calibre1"/> rotating coin is built and can be used either as a prop or collectables in our game.</p><p class="calibre8">These are the steps to make the coins collectables:</p><div><ol class="orderedlist"><li class="listitem" value="1">For making a coin move from the left end to the right end of the screen, we have to calculate the initial and final positions.<div><pre class="programlisting">  CGFloat coinInitialPositionX = self.frame.size.width + coinSprite.size.width/2;
  CGFloat coinInitialPositionY = arc4random() % 320;
  CGPoint coinInitialPosition = CGPointMake(coinInitialPositionX, oinInitialPositionY);

  CGFloat coinFinalPositionX = -coinSprite.size.width/2;
  CGFloat coinFinalPositionY = coinInitialPositionY;
  CGPoint coinFinalPosition = CGPointMake(coinFinalPositionX, coinFinalPositionY);</pre></div></li><li class="listitem" value="2">After that, set the initial position as the coin sprite position.<div><pre class="programlisting"> coinSprite.position = coinInitialPosition;</pre></div></li><li class="listitem" value="3">The initial position of the coin is set and now we have to animate the coin from the initial position to the final position. This can be done by adding a move <code class="email">SKAction</code> to the coin sprite specifying its final destination.<div><pre class="programlisting">  SKAction *coinMoveAnimation = [SKAction moveTo:coinFinalPosition duration:5.0];
  
  [coinSprite runAction:coinMoveAnimation];</pre></div></li></ol><div></div><p class="calibre8">Finally, our <code class="email">addCoin</code> method has been fully prepared for the game. For moving the coins as collectables, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">For making these coins move as collectables in the scene, a little bit of refactoring is required in the update method. Update the <code class="email">diffTim</code>e and <code class="email">lastUpdatedTime</code> as shown in the following code:<div><pre class="programlisting">   if (self.lastUpdatedTime)
    {
        self.diffTime = currentTime - self.lastUpdatedTime;
    }
    else
    {
        self.diffTime = 0;
    }

    self.lastUpdatedTime = currentTime;</pre></div></li><li class="listitem" value="2">Now<a id="id104" class="calibre1"/> using <code class="email">currentTime</code>, create a timer kind of functionality by declaring a property called <code class="email">lastCoinAdded</code> in the private interface of FSMyScene.<div><pre class="programlisting">@property (nonatomic, assign) NSTimeInterval lastCoinAdded;</pre></div></li><li class="listitem" value="3">So this is <a id="id105" class="calibre1"/>the timer added in the update method and the diff of <code class="email">currentTime</code> and <code class="email">lastCoinAdded</code> is checked by 1. Hence, after every 1.0 second, a coin will be added with animation moving from left to right on the screen.<div><pre class="programlisting">    if( currentTime - self.lastCoinAdded &gt; 1)
    {
        self.lastCoinAdded = currentTime + 1;
        
        [self addCoin];
    }</pre></div></li></ol><div></div><p class="calibre8">Finally, our update method is ready to animate multiple coins after a set delay.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec49" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre8">Before we were creating the sprite using images from <code class="email">App Bundle</code>, but now we will be using texture atlas to get the images and passing to the sprites. The preceding texture atlas named <code class="email">FSGame.atlas</code> holds multiple images of coins and spaceship in it. The internal code loads the frames and stores them in an array.</p><div><ul class="itemizedlist"><li class="listitem">SpriteKit first searches for the image file, if not found it searches inside the texture atlases build into the app bundle. If we want to work explicitly with texture atlases, use the <code class="email">SKTextureAtlas</code> class. It fetches the texture atlas by specifying its name:<div><pre class="programlisting">  SKTextureAtlas *textureAtlas = [SKTextureAtlas atlasNamed:@"FSGame"];</pre></div></li><li class="listitem">Then we can use the atlas object to get the required image for creation of sprites.<div><pre class="programlisting">  SKTexture* spaceShipTexture = [textureAtlas textureNamed:@"Spaceship.png"];</pre></div></li></ul></div><p class="calibre8">Now we will understand how the coins are converted into collectables. For moving the coins, its initial and final positions are to be decided.</p><div><ul class="itemizedlist"><li class="listitem">The initial position in <em class="calibre9">x</em> dimensions, is fixed to the width of the frame plus half of its coin so that it is added outside the screen and <em class="calibre9">y</em> dimensions are randomly chosen from 0 to 320 using the <code class="email">arc4random()</code>function.<div><pre class="programlisting">CGFloat coinInitialPositionX = self.frame.size.width + coinSprite.size.width/2;
  CGFloat coinInitialPositionY = arc4random() % 320;
  CGPoint coinInitialPosition = CGPointMake(coinInitialPositionX, coinInitialPositionY);</pre></div></li><li class="listitem">For<a id="id106" class="calibre1"/> the<a id="id107" class="calibre1"/> final position, the <em class="calibre9">x</em> dimension is set to negative of half of its own width and the <em class="calibre9">y</em> dimension is the same as the initial position <em class="calibre9">x</em>.<div><pre class="programlisting">  CGFloat coinFinalPositionX = -coinSprite.size.width/2;
  CGFloat coinFinalPositionY = coinInitialPositionY;
  CGPoint coinFinalPosition = CGPointMake(coinFinalPositionX, coinFinalPositionY);</pre></div><div><img src="img/00034.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem">Now the collectable is ready to be added to the scene. But for multiple coins to be added moving left to right on the scene, a timer has to be implemented. The timer looks like this:<div><pre class="programlisting">    if( currentTime - self.lastCoinAdded &gt; 1)
    {
        self.lastCoinAdded = currentTime + 1;
        
        [self addCoin];
    }</pre></div></li></ul></div><p class="calibre8">After all these <a id="id108" class="calibre1"/>implementations, multiple coins are seen <a id="id109" class="calibre1"/>moving from left to right as shown in the following screenshot:</p><div><img src="img/00035.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec23" class="calibre1"/>Collision detection</h1></div></div></div><p class="calibre8">We have <a id="id110" class="calibre1"/>our game integrated with collectables. Let's see how the spaceship will collect these collectables that is, coins. In character animation, we will be doing the animations on the spaceship and the coins when they collide with each other.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec50" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before moving on to the complex animations to be applied on the entities of the scene, the understanding of actions (that is, <code class="email">SKAction</code>) and update function of scene (<code class="email">SKScene</code>) has to be there. This is so that during updation we can detect the collision between the coin and the spaceship and do some animations on both of them.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec51" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre8">The following <a id="id111" class="calibre1"/>are the steps involved in detecting the collision and animating both the entities (coin and spaceship):</p><div><ol class="orderedlist"><li class="listitem" value="1">Write an <code class="email">detectSpaceShipCollisionWithCoins</code> method in which we will enumerate the coin objects.<div><pre class="programlisting">- (void)detectSpaceShipCollisionWithCoins
{
    [self enumerateChildNodesWithName:@"Coin"
                           usingBlock: ^(SKNode *node, BOOL *stop)
     {
     }];
}</pre></div></li><li class="listitem" value="2">In that enumeration, determine that the frame of the spaceship and the frame of any coin intersects with the help of <code class="email">CGRectIntersectsRect()</code>.<div><pre class="programlisting">    [self enumerateChildNodesWithName:@"Coin"
      usingBlock: ^(SKNode *node, 
        BOOL *stop)
     {
         if (CGRectIntersectsRect(self.spaceShipSprite.frame, node.frame))
         {

         }
     }];</pre></div></li><li class="listitem" value="3">When a collision is detected, inform the scene that a coin has collided with the spaceship by a function called <code class="email">spaceShipCollidedWithCoin</code>.<div><pre class="programlisting">    [self spaceShipCollidedWithCoin:node];</pre></div></li></ol><div></div><p class="calibre8">After all this, the <code class="email">detectSpaceShipCollisionWithCoins</code> method looks like this:</p><div><img src="img/00036.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre11"> </p><div><ol class="orderedlist"><li class="listitem" value="1">After detecting the collision, the <code class="email">spaceShipCollidedWithCoin</code> function is invoked, which calls two other functions that implement animation methods for the spaceship and coin that have collided. The definition of this method looks like this:<div><pre class="programlisting">- (void)spaceShipCollidedWithCoin:(SKNode*)coinNode
{
    [self runSpaceshipCollectingAnimation];
    
    [self runCollectedAnimationForCoin:coinNode];
}</pre></div></li><li class="listitem" value="2">The<a id="id112" class="calibre1"/> animation written for the spaceship is as if it is taking the coin into itself. There are two actions created for <code class="email">scaleUp</code> and <code class="email">scaleDown</code> with a scale factor 1.4 and 1.0 respectively to be played for 0.2 each.<div><pre class="programlisting">- (void)runSpaceshipCollectingAnimation
{
  SKAction* scaleUp = [SKAction scaleTo:1.4 duration:0.2];

  SKAction* scaleDown = [SKAction scaleTo:1.0 duration:0.2];
}</pre></div></li><li class="listitem" value="3">After that, these two animation arrays are formed to be used for creating a sequence action.<div><pre class="programlisting">NSArray* scaleSequenceAnimations =
  [NSArray arrayWithObjects:scaleUp, scaleDown, nil];

  SKAction* spaceShipCollectingAnimation = [SKAction sequence:scaleSequenceAnimations];</pre></div><p class="calibre15">Lastly the sequence action formed runs on the spaceship.</p><div><pre class="programlisting">  [self.spaceShipSprite runAction:spaceShipCollectingAnimation];</pre></div></li><li class="listitem" value="4">For the coin, the animation should be as if it is disappearing as it is taken by the spaceship. Thus, two core animations <code class="email">fadeOut</code> and <code class="email">scaleDown</code> are created with a 0.2 scale factor having a time interval of 0.4 each, forming an array of animations.<div><pre class="programlisting">- (void)runCollectedAnimationForCoin:(SKNode*)coinNode
{
    SKAction* coinFadeOutAnimation = [SKAction fadeOutWithDuration:0.4];
    
    SKAction* scaleDownAnimation = [SKAction scaleTo:0.2 duration:0.4];
    
    NSArray* coinAnimations = [NSArray arrayWithObjects:coinFadeOutAnimation, scaleDownAnimation, nil]; 
}</pre></div></li><li class="listitem" value="5">Using these animations, a group animation is formed.<div><pre class="programlisting">  SKAction* coinGroupAnimation = [SKAction group:coinAnimations];</pre></div></li><li class="listitem" value="6">As for the <a id="id113" class="calibre1"/>coin, when it collides with the spaceship, it has to be removed from the scene when its animation is over. So create an action using the block to remove the coin after the previously created group animation is completed.<div><pre class="programlisting">  SKAction* coinAnimationFinishedCallBack = [SKAction customActionWithDuration:0.0 actionBlock:^(SKNode *node,CGFloat elapsedTime)
  {
    [node removeFromParent];
  }];</pre></div><pre>removeFromParent</code> function, which is similar to <code class="email">removeFromSuperview</code> in UIKit.</pre></li><li class="listitem" value="7">As the animations are ready, create the sequence action for it using an array.<div><pre class="programlisting">    NSArray* coinAnimationsSequence =
    [NSArray arrayWithObjects:coinGroupAnimation, coinAnimationFinishedCallBack, nil];
    
    SKAction* coinSequenceAnimation =
    [SKAction sequence:coinAnimationsSequence];</pre></div><p class="calibre15">Hence, the coin looks as if it is disappearing when the preceding complex actions run on the coin.</p><div><pre class="programlisting">    [coinNode runAction:coinSequenceAnimation];</pre></div></li><li class="listitem" value="8">As all the code of the animation and collision detection is done, call the <code class="email">detechSpaceShipCollisionWithCoins</code> method, so that in each frame the collision is detected and the coin is collected by the character of the game (that is, the spaceship).<div><pre class="programlisting">    [self detectSpaceShipCollisionWithCoins];</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec52" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre8">The most important <a id="id114" class="calibre1"/>part of this section is the collision detection. It is done with the help of the <code class="email">CGRectIntersectsRect</code> method in which the coins are enumerated and checked whether their frames intersect the spaceship frame. If they do, then two different animations are played on the coin and spaceship.</p><div><pre class="programlisting">    [self enumerateChildNodesWithName:@"Coin"usingBlock: ^(SKNode *node, BOOL *stop)
     {
         if (CGRectIntersectsRect(self.spaceShipSprite.frame, node.frame))
         {

         }
     }];</pre></div><p class="calibre8">When detection happens, the game looks like this:</p><div><img src="img/00037.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now we come to animations. The animation of the spaceship is a simple one. Just to give a feel of collecting the coins, <code class="email">scaleUp</code> and <code class="email">scaleDown</code> animations are used in sequence.</p><div><pre class="programlisting">SKAction* scaleUp = [SKAction scaleTo:1.4 duration:0.2];

    SKAction* scaleDown = [SKAction scaleTo:1.0 duration:0.2];

NSArray* scaleSequenceAnimations = [NSArray arrayWithObjects:scaleUp, scaleDown, nil];
  
  SKAction* spaceShipCollectingAnimation = [SKAction sequence:scaleSequenceAnimations];</pre></div><p class="calibre8">However, for <a id="id115" class="calibre1"/>coins, a complex one with three actions is created, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">FadeOutAction</code> to<a id="id116" class="calibre1"/> fade the coin for 0.4 seconds, which appears to be disappearing.<div><pre class="programlisting">  SKAction* coinFadeOutAnimation = [SKAction fadeOutWithDuration:0.4];</pre></div></li><li class="listitem"><code class="email">ScaleDownAction</code><a id="id117" class="calibre1"/> to scale down the coin to make it shrink into the spaceship in 0.4 seconds.<div><pre class="programlisting">  SKAction* scaleDownAnimation = [SKAction scaleTo:0.2 duration:0.4];</pre></div></li><li class="listitem">A <code class="email">CallBack</code> function<a id="id118" class="calibre1"/> that is used to remove the coin from the scene when the preceding animations are over.<div><pre class="programlisting"> SKAction* coinAnimationFinishedCallBack = [SKAction customActionWithDuration:0.0 actionBlock:^(SKNode *node,CGFloat elapsedTime)
     {
         [node removeFromParent];
     }];</pre></div></li></ul></div><p class="calibre8">After creation of all these actions, a group of <code class="email">fadeOut</code> and <code class="email">scaleDown</code>, a sequence of animation with a sequence of group animation and callback action is created, which is applied on the coin.</p><p class="calibre8">Whenever there is a collision, the spaceship scales up and down with the coin fading out as depicted in the following screenshot:</p><div><img src="img/00038.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec24" class="calibre1"/>Parallax background</h1></div></div></div><p class="calibre8">Now our mini game FlyingSpaceship is about to finish. To give the feel of a game environment we will introduce a parallax scrolling background. A parallax scrolling background<a id="id119" class="calibre1"/> is composed of multiple background layers (that is, nodes); animating them simultaneously gives a feel of dynamic background. To add some cool flyers to the game we will add two layers of background: the <code class="email">SpaceBlueSky</code> and the <code class="email">SpaceWhiteMist</code> in the form of nodes.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec53" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To start with this cool feature, we should be aware of the scrolling background created in the previous chapter and have a basic knowledge of sprites, nodes, and math. We are going to cook the <em class="calibre9">Parallax background</em> recipe in the FlyingSpaceship game.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec54" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre8">To create <a id="id120" class="calibre1"/>multiple scrolling backgrounds with varying speeds of scrolling, we will be creating a class for it to accomplish the parallax background. The steps involved in creating a class for parallax background named as <code class="email">FSParallaxNode</code> are as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new file by right clicking on the <strong class="calibre2">FlyingSpaceship</strong> project.<div><img src="img/00039.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Select <a id="id121" class="calibre1"/><strong class="calibre2">Objective-C Class</strong> in the <strong class="calibre2">Cocoa Touch</strong> section.<div><img src="img/00040.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">Name the class <code class="email">FSParallaxNode</code> and click on <strong class="calibre2">Next</strong>.<div><img src="img/00041.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Now to<a id="id122" class="calibre1"/> create the class, select the <code class="email">FlyingSpaceship</code> folder in which it has to be created and click on <strong class="calibre2">Create</strong>.<div><img src="img/00042.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">Now <a id="id123" class="calibre1"/>we need to add two methods in the header of <code class="email">FSParallaxNode</code>. Firstly, in the <code class="email">init</code> method, we need to specify <code class="email">imageFiles</code>, which are the images to be scrolled, the canvas size, and the velocity with which the images will scroll.<div><pre class="programlisting">- (id)initWithBackgrounds:(NSArray *)imageFiles
           size:(CGSize)size
           speed:(CGFloat)velocity;</pre></div><p class="calibre15">Secondly, an update method called from the update of Scene in which the <code class="email">FSParallaxNode</code> method is added so that the scrolling is made infinite.</p><div><pre class="programlisting">- (void)updateForDeltaTime:(NSTimeInterval)diffTime;</pre></div></li><li class="listitem" value="6">In <code class="email">FSParallaxNode.m</code>, declare some properties in its private interface to store all background nodes, counts of backgrounds, and velocity of that parallax node.<div><pre class="programlisting">@property (nonatomic, strong)  NSMutableArray*  backgrounds;
@property (nonatomic, assign)  NSInteger        noOfBackgrounds;
@property (nonatomic, assign) CGFloat           velocity;</pre></div><p class="calibre15">In definition of the <code class="email">init</code> method, first assign all the parameters passed in the function like <code class="email">velocity</code>. Now we assign <code class="email">noOfBackgrounds</code> using the <code class="email">imageFiles</code> count and make an array of backgrounds with a capacity of <code class="email">noOfBackgrounds</code>.</p><div><pre class="programlisting">- (id)initWithBackgrounds:(NSArray *)imageFiles
               size:(CGSize)size
               speed:(CGFloat)velocity
{
    if (self = [super init])
    {
        self.velocity = velocity;
        self.noOfBackgrounds = [imageFiles count];
        self.backgrounds =
        [NSMutableArray arrayWithCapacity:self.noOfBackgrounds];

        }];
    }
    return self;
}</pre></div></li><li class="listitem" value="7">Using<a id="id124" class="calibre1"/> the <code class="email">imageFiles</code>, enumerate them using the block. In enumeration, add background nodes using the <code class="email">imageFiles</code> class, add them to the backgrounds array and on <code class="email">FSParallaxNode</code>.<div><pre class="programlisting">        [imageFiles enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)
        {
            SKSpriteNode *backgroundNode =
            [SKSpriteNode spriteNodeWithImageNamed:obj];
            
            [self.backgrounds addObject:backgroundNode];
            [self addChild:backgroundNode];
        }];</pre></div></li><li class="listitem" value="8">Also, specify the <code class="email">backgroundNode</code> size, which is passed in the <code class="email">init</code> method, its <code class="email">anchorPoint</code> to <code class="email">CGPointZero</code>, its position according to the <code class="email">idx</code> integer and a name of the node as <code class="email">background</code>.<div><pre class="programlisting">        backgroundNode.size = size;
        backgroundNode.anchorPoint = CGPointZero;
        backgroundNode.position = CGPointMake(size.width * idx, 0.0);
        backgroundNode.name = @"background";</pre></div></li></ol><div></div><p class="calibre8">After all <a id="id125" class="calibre1"/>this, our <code class="email">init</code> method is ready as shown in the following screenshot:</p><div><img src="img/00043.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now let's see how these backgrounds added on <code class="email">FSParallaxNode</code> are to be scrolled; it will be done by an instance update method.</p><div><ol class="orderedlist"><li class="listitem" value="1">Some <code class="email">cleanUp</code> has to be done or in other terms some code movement. Copy the two static methods used in the <code class="email">FSMyScene</code> to <code class="email">FSParallaxNode</code> class used for some math, remove the initialization of the <code class="email">SpaceBackground</code> method and the call of moving background made in the update from <code class="email">FSMyScene</code>. Cut the code of the method for moving the background from the <code class="email">FSMyScene</code> file and paste in the <code class="email">updateForDeltaTime</code> function of <code class="email">FSParallaxNode</code>. Now we will be making some tweaks to the method.</li><li class="listitem" value="2"><code class="email">SKParallax</code> node is the parent for all the other nodes of backgrounds added on it. So using the velocity, send in the <code class="email">init</code> and <code class="email">diffTime</code>, method which will be passed by the <code class="email">FSMyScene</code> update methods, we calculate the position of the parent that is, <code class="email">FSParallax</code> node.<div><pre class="programlisting">- (void)updateForDeltaTime:(NSTimeInterval)diffTime
{
    CGPoint bgVelocity = CGPointMake(self.velocity, 0.0);
    CGPoint amtToMove = CGPointMultiplyScalar(bgVelocity,diffTime);
    self.position = CGPointAdd(self.position, amtToMove);    
}</pre></div></li><li class="listitem" value="3">Now<a id="id126" class="calibre1"/> enumerate the backgrounds that is, all nodes added to the parent. In this enumeration, find the position of an individual background with respect to the parent node. After this, check whether the position of a background is less than the negative of its width (that is, reached the left end), then change the position of that background to its right end.<div><pre class="programlisting">    SKNode *backgroundScreen = self.parent;

    [self.backgrounds enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop)
    {
        SKSpriteNode *bg = (SKSpriteNode *)obj;

        CGPoint bgScreenPos = [self convertPoint:bg.position
                                          toNode:backgroundScreen];

        if (bgScreenPos.x &lt;= -bg.size.width)
        {
            bg.position =
            CGPointMake(bg.position.x + (bg.size.width * self.noOfBackgrounds),
                        bg.position.y);
        }
    }];</pre></div></li><li class="listitem" value="4">Finally, our update method is constructed, which provides a functionality of multiple backgrounds scrolling infinitely.<div><img src="img/00044.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre13"> </p><p class="calibre15">As of <a id="id127" class="calibre1"/>now, the <code class="email">FSParallaxNode</code> class, which provides the functionality of parallax scrolling background is created and it's time to create objects in <code class="email">FSMyScene</code> to make a cool environment.</p></li><li class="listitem" value="5">We will be adding two background layers BlueSky and WhiteMist, so create two objects for each of them.<div><pre class="programlisting">@property (nonatomic, strong) FSParallaxNode*spaceBlueSkyParallaxNode;
@property (nonatomic, strong) FSParallaxNode*spaceWhiteMistParallaxNode;</pre></div><p class="calibre15">Add a method called <code class="email">addParallaxNodes</code> and call it in the first line of the <code class="email">init</code> method of <code class="email">FSMyScene</code>.</p><div><pre class="programlisting">        [self addParallaxNodes];</pre></div></li><li class="listitem" value="6">For two parallax nodes, we have to add the following two constants for their relative speeds.<div><pre class="programlisting">static const float SPACE_BLUE_SKY_BG_VELOCITY = 20.0;
static const float SPACE_WHITE_MIST_BG_VELOCITY = 100.0;</pre></div><p class="calibre15">In <code class="email">addParallaxNodes,</code> make an array of <code class="email">blueSkyParallaxBackgroundImages</code> and create an object of <code class="email">FSParallax</code> by passing the size of the scene and velocity at which it is going to scroll. </p><div><pre class="programlisting">- (void)addParallaxNodes
{
    NSArray *blueSkyParallaxBackgroundNames = @[@"SpaceBackground.png", @"SpaceBackground.png",];
    
    self.spaceBlueSkyParallaxNode = [[FSParallaxNode alloc] initWithBackgrounds:blueSkyParallaxBackgroundNames
                                           size:self.frame.size
          speed:-SPACE_BLUE_SKY_BG_VELOCITY];
    self.spaceBlueSkyParallaxNode.position =
    CGPointMake(0, 0);
    
    [self addChild:self.spaceBlueSkyParallaxNode];
}</pre></div></li><li class="listitem" value="7">Similar<a id="id128" class="calibre1"/> to the blue sky background, we have to implement the mist images as well. To add more reality to the game, we will add the <code class="email">mistParallaxBackgroundImages</code> function.<div><pre class="programlisting">    NSArray *mistParallaxBackgroundNames = @[@"SpaceWhiteMist.png", @"SpaceWhiteMist.png",];
    
    self.spaceWhiteMistParallaxNode = [[FSParallaxNode alloc] initWithBackgrounds:mistParallaxBackgroundNamessize:self.frame.size
    speed:-SPACE_WHITE_MIST_BG_VELOCITY];
    self.spaceWhiteMistParallaxNode.position = CGPointMake(0, 0);
    
    [self addChild:self.spaceWhiteMistParallaxNode];</pre></div></li><li class="listitem" value="8">Once the nodes have been added to the scene, they need to be updated for scrolling purposes. So call the <code class="email">updateForDeltaTime</code> function of <code class="email">FSMyScene</code> for both the nodes.<div><pre class="programlisting">  if (self.spaceBlueSkyParallaxNode)
  {
    [self.spaceBlueSkyParallaxNode updateForDeltaTime:self.diffTime];
  }
  
  if (self.spaceWhiteMistParallaxNode)
  {
    [self.spaceWhiteMistParallaxNode updateForDeltaTime:self.diffTime];
  }</pre></div></li></ol><div></div><p class="calibre8">After all these steps, the dynamic environment with a parallax scrolling background is ready for the game.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec55" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre8">Since we have <a id="id129" class="calibre1"/>done the scrolling of background in the previous chapter, it is time we made a separate class for it called <code class="email">FSParallaxNode</code>. In this class, multiple backgrounds of the same image are placed and scrolled in each update of the scene. It means that the scrolling is done on the basis of the positions of all background nodes added to <code class="email">FSParallaxNode</code>.</p><p class="calibre8">Using this <code class="email">FSParallaxNode</code>, two objects of it are created: <code class="email">BlueSkyBackground</code> and <code class="email">WhiteMistBackground</code>. All are added as normal nodes to the scene in the <code class="email">init</code> method. For them to scroll, the update method calls the <code class="email">updateForDeltaTime</code> function in which the class checks for the position of individual background positions reached at the left end of the screen and changes the position so that it again starts with the right-end side. This whole algorithm makes these individual backgrounds scroll making a full parallax scrolling background. The parallax scrolling background really looks cool as shown in the following screenshot:</p><div><img src="img/00045.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre11"> </p></div></div></body></html>