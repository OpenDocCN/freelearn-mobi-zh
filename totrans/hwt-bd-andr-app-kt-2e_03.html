<html><head></head><body>
		<div><h1 id="_idParaDest-53" class="chapter number"><a id="_idTextAnchor163"/><a id="_idTextAnchor164"/><a id="_idTextAnchor165"/><a id="_idTextAnchor166"/><a id="_idTextAnchor167"/>3</h1>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor168"/>Developing the UI with Fragments</h1>
			<p><a id="_idTextAnchor169"/>This chapter covers fragments and the fragment lifecycle. It demonstrates how to use them to build efficient and dynamic layouts that respond to different screen sizes and configurations and allow you to divide your UI into different sections. By the end of this chapter, you will be able to create static and dynamic fragments, pass data to and from fragments and activities, and use the Jetpack <code>Navigation</code> component to detail how fragments fit together.</p>
			<p><a id="_idTextAnchor170"/>In the previous chapter, we explored the Android activity lifecycle and looked into how it is used in apps to navigate between screens. We also analyzed various types of launch modes, which defined how transitioning between screens happened. In this chapter, you’ll explore fragments. A fragment is a section, portion, or, as the name implies, fragment of an Android activity.</p>
			<p>Throughout the chapter, you’ll learn how to use fragments, see how they can exist in more than one activity, and discover how multiple fragments can be used in one activity. You’ll start by adding simple fragments to an activity and then progress to learning about the difference between static and dynamic fragments.</p>
			<p>Fragments can be used to simplify creating layouts for Android tablets that have larger form factors using dual-pane layouts. For example, if you have an average-sized phone screen and you want to include a list of news stories, you might only have enough space to display the list.</p>
			<p>If you viewed the same list of stories on a tablet, you’d have more space available so you could display the same list and also a story itself to the right of the list. Each of these different areas of the screen can use a fragment. You can then use the same fragment on both the phone and the tablet. You benefit from reusing and simplifying the layouts and don’t have to repeat creating similar functionality.</p>
			<p>Once you’ve explored how fragments are created and used, you’ll then learn how to organize your user journeys with fragments. You’ll apply some established practices for using fragments in this way. Finally, you’ll learn how to simplify fragment use by creating a navigation graph with the Android Jetpack <code>Navigation</code> component, which allows you to specify linking fragments together with destinations.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>The fragment lifecycle</li>
				<li>Static fragments and dual-pane layouts</li>
				<li>Dynamic fragments</li>
				<li>Jetpack Navigation</li>
			</ul>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor171"/><a id="_idTextAnchor172"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/KmdBZ">https://packt.link/KmdBZ</a></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor173"/>The fragment lifecycle</h1>
			<p>A fragment is a <a id="_idIndexMarker185"/>component with its own lifecycle. Understanding the fragment lifecycle is critical as it provides callbacks at certain stages of fragment creation, the running state, and destruction that configure the initialization, display, and cleanup. Fragments run in an activity, and a fragment’s lifecycle is bound to the activity’s lifecycle.</p>
			<p>In many ways, the fragment lifecycle is very similar to the activity lifecycle, and at first glance, it appears that the former replicates the latter. There are as many callbacks that are the same or similar in the fragment lifecycle as there are in the activity lifecycle, such as <code>onCreate(savedInstanceState: Bundle?)</code>.</p>
			<p>The fragment lifecycle is tied to the activity lifecycle, so wherever fragments are used, the fragment callbacks are interleaved with the activity callbacks.</p>
			<p>The same steps are gone through to initialize the fragment and prepare for it to be displayed to the user before being available for the user to interact with. The same teardown steps that an activity goes through happen to the fragment as well when the app is backgrounded, hidden, and exited. Fragments, like activities, have to extend/derive from a parent <code>Fragment</code> class, and you can choose which callbacks to override depending on your use case. The lifecycle is displayed in the following diagram, followed by more detail about each function.</p>
			<div><div><img src="img/B19411_03_01.jpg" alt="Figure 3.1 – Fragment lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Fragment lifecycle</p>
			<p>Let’s now explore <a id="_idIndexMarker186"/>these callbacks, the order they appear in, and what they do.<a id="_idTextAnchor174"/><a id="_idTextAnchor175"/></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor176"/>onAttach</h2>
			<p><code>override fun onAttach(context: Context)</code>: This is the point where your fragment<a id="_idIndexMarker187"/> becomes <a id="_idIndexMarker188"/>linked to the activity it is used in. It allows you to reference the activity, although at this stage neither the fragment nor the activity has been fully create<a id="_idTextAnchor177"/><a id="_idTextAnchor178"/>d.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor179"/>onCreate</h2>
			<p><code>override fun onCreate(savedInstanceState: Bundle?)</code>: This is where you do <a id="_idIndexMarker189"/>any<a id="_idIndexMarker190"/> initialization of your fragment. This is not where you set the layout of your fragment, as at this stage, there is no UI available to display and no <code>setContentView</code> available as there is in an activity. As is the same in the activity’s <code>onCreate()</code> function, you can use the <code>savedInstanceState</code> parameter to restore the state of the fragment when it is being re-crea<a id="_idTextAnchor180"/><a id="_idTextAnchor181"/>ted.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor182"/>onCreateView</h2>
			<p><code>override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?</code>: Now, this<a id="_idIndexMarker191"/> is where<a id="_idIndexMarker192"/> you get to create the layout of your fragment. The most important thing to remember here is that instead of setting the layout (as is the case with an activity), the fragment will actually return the layout <code>View?</code> from this function.</p>
			<p>The views you have in your layout are available to refer to here, but there are a few caveats. You need to create the layout before you can reference the views contained within it, which is why it’s preferred to do view manipulation in <code>onViewCr<a id="_idTextAnchor183"/><a id="_idTextAnchor184"/>eated</code>.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor185"/>onViewCreated</h2>
			<p><code>override fun onViewCreated(view View, savedInstanceState: Bundle?)</code>: This <a id="_idIndexMarker193"/>callback<a id="_idIndexMarker194"/> is the one in between your fragment being fully created and being visible to the user. It’s where you’ll typically set up your views and add any functionality and interactivity to these views. This might be adding an <code>OnClickListener</code> to a button and then calling<a id="_idIndexMarker195"/> a function <a id="_idIndexMarker196"/>when it’<a id="_idTextAnchor186"/><a id="_idTextAnchor187"/>s clicked.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor188"/>onActivityCreated</h2>
			<p><code>override fun onActivityCreated(context: Context)</code>: This is called immediately<a id="_idIndexMarker197"/> after<a id="_idIndexMarker198"/> the activity’s <code>onCreate</code> has been run. Most of the initialization of the view state of the fragment will have been done, and this is the place to do the final setup <a id="_idTextAnchor189"/><a id="_idTextAnchor190"/>if required.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor191"/>onStart</h2>
			<p><code>override fun onStart()</code>: This <a id="_idIndexMarker199"/>is called when the fragment is <a id="_idIndexMarker200"/>about to become visible to the user but is not yet available for the user to <a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>interact with.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor194"/>onResume</h2>
			<p><code>override fun onResume()</code>: At the <a id="_idIndexMarker201"/>end of this call, your <a id="_idIndexMarker202"/>fragment is available for the user to interact with. Normally, there is minimal setup or functionality defined in this callback, as when the app goes into the background and then comes back into the foreground, this callback will always be called.</p>
			<p>Therefore, you don’t want to have to needlessly repeat the setup of the fragment when this could be done with a callback that isn’t run when the fragment <a id="_idTextAnchor195"/><a id="_idTextAnchor196"/>becomes visible.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor197"/>onPause</h2>
			<p><code>override fun onPause()</code>: Like its <a id="_idIndexMarker203"/>counterpart, <code>onPause()</code> in <a id="_idIndexMarker204"/>an activity signals that your app is going into the background or has been partially covered by something else on the screen. Use this to save any changes to the<a id="_idTextAnchor198"/><a id="_idTextAnchor199"/> fragment’s state.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor200"/>onStop</h2>
			<p><code>override fun onStop()</code>: The <a id="_idIndexMarker205"/>fragment is no longer visible<a id="_idIndexMarker206"/> at the end of this call and goes <a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>into the background.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor203"/>onDestroyView</h2>
			<p><code>override fun onDestroyView()</code>: This is usually called for doing a final cleanup before the <a id="_idIndexMarker207"/>fragment <a id="_idIndexMarker208"/>is destroyed. You should use this callback if it is necessary to clean up any resources. If the fragment is pushed to the back stack and retained, then it can also be called without destroying the fragment. On completion of this callback, the fragment’s l<a id="_idTextAnchor204"/><a id="_idTextAnchor205"/>ayout view is removed.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor206"/>onDestroy</h2>
			<p><code>override fun onDestroy()</code>: The <a id="_idIndexMarker209"/>fragment is being <a id="_idIndexMarker210"/>destroyed. This can occur because the app is being killed or because this fragment is being repla<a id="_idTextAnchor207"/><a id="_idTextAnchor208"/>ced by another fragment.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor209"/>onDetach</h2>
			<p><code>override fun onDetach()</code>: This is<a id="_idIndexMarker211"/> called when the<a id="_idIndexMarker212"/> fragment has been detached from its activity.</p>
			<p>There are more fragment callbacks, but these are the ones you will use for the majority of cases. Typically, you’ll only use a subset of these callbacks: <code>onAttach()</code> to associate an activity with the fragment, <code>onCreate</code> to initialize the fragment, <code>onCreateView</code> to set the layout, and then <code>onViewCreated</code>/<code>onActivityCreated</code> to do further initialization, and perhaps <code>onPause()</code> to do some cleanup.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Further details of these callbacks can be found in the official documentation at <a href="">https://developer.android.com/guide/fragments</a>.</p>
			<p>Now that we’ve gone through some of the theory of the fragment lifecycle and how it is affected by the <a id="_idIndexMarker213"/>host <a id="_idIndexMarker214"/>activity’s lifecycle, let’s see those ca<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>llbacks being run in action.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor212"/>Exercise 3.01 – adding a basic fragment and the fragment lifecycle</h2>
			<p>In this exercise, we <a id="_idIndexMarker215"/>will create and add a basic fragment to an app. The aim of this exercise is to gain familiarity with how fragments are added to an activity and the layout they display. To do this, you will create a new blank fragment with a layout in Android Studio. You will then add the fragment to the activity and verify the fragment has been added by the display of the fragment layout. Perform the following steps:</p>
			<ol>
				<li>Create an application in Android Studio with an empty activity called <code>Fragment </code><code>Lifecycle</code> .</li>
				<li>Once the application has been built, create a new fragment by going to <code>Fragment (Blank)</code> option. When you’ve selected this option, you <a id="_idIndexMarker216"/>will be presented with th<a id="_idTextAnchor213"/>e screen shown in <em class="italic">Figure 3</em><em class="italic">.2</em>:</li>
			</ol>
			<div><div><img src="img/B19411_03_02.jpg" alt="Figure 3.2 – Creating a new fragment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Creating a new fragment</p>
			<ol>
				<li value="3">Rename the fragment <code>MainFragment</code> and the layout <code>fragment_main</code>. Then, press <code>Fragment</code> class will be created and opened. There are two functions that have been added: <code>onCreate</code>, which initializes the fragment, and <code>onCreateView</code> (displayed in the following code snippet), which inflates the layout file used for the fragment:<pre class="source code">
    override fun onCreateView(
        inflater: LayoutInflater, container:
            ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout for this fragment
        return inflater.inflate(
            R.layout.fragment_main, container, false)
    }</pre></li>
				<li>When you<a id="_idIndexMarker217"/> open up the <code>fragment_main.xml</code> layout file, you’ll see the following code:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;FrameLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainFragment"&gt;
    &lt;!-- TODO: Update blank fragment layout --&gt;
    &lt;TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="@string/hello_blank_fragment" /&gt;
&lt;/FrameLayout&gt;</pre></li>
			</ol>
			<p>A simple layout has been added with a <code>TextView</code> and some example text using <code>@string/hello_blank_fragment</code>. This string resource has the text <code>hello blank fragment</code>. As <code>layout_width</code> and <code>layout_height</code> are specified as <code>match_parent</code>, <code>TextView</code> will occupy the whole of the screen. The text itself, however, will be added at the top left of the view with the default position.</p>
			<ol>
				<li value="5">Add the <code>android:gravity="center"</code> attribute and value to the <code>TextView</code> so that <a id="_idIndexMarker218"/>the text appears in the center of the screen:<pre class="source code">
    &lt;TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="center"
        android:text="@string/hello_blank_fragment" /&gt;</pre></li>
			</ol>
			<p>If you run up the UI now, you’ll see the <strong class="bold">Hello<a id="_idTextAnchor214"/> World!</strong> display in <em class="italic">Figure 3</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B19411_03_03.jpg" alt="Figure 3.3 – Initial app layout display without a fragment added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Initial app layout display without a fragment added</p>
			<p>Well, you can see<a id="_idIndexMarker219"/> some <code>hello blank fragment</code> text you might have been expecting. The fragment and its layout do not automatically get added to an activity when you create it. This is a manual process.</p>
			<ol>
				<li value="6">Open the <code>activity_main.xml</code> file and replace the contents with the following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=
      "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.fragmentlifecycle
        .MainActivity"&gt;
    &lt;fragment
        android:id="@+id/main_fragment"
        android:name="com.example.fragmentlifecycle
            .MainFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>Just as there are <a id="_idIndexMarker220"/>view declarations you can add to layouts in XML, there is also a <code>fragment</code> element. You’ve added the fragment to <code>ConstraintLayout</code> with constraints of <code>match_parent</code> for <code>layout_width</code> and <code>layout_height</code> so it will occupy the whole of the screen.</p>
			<p>The most important <code>xml</code> attribute to examine here is <code>android:name</code>. It’s here where you specify the fully qualified name of the package and the <code>Fragment</code> class that you are going to add to the layout with <code>com.example.fragmentlifecycle.MainFragment</code>. Now run the app, and you will see <a id="_idTextAnchor215"/>the output shown in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B19411_03_04.jpg" alt="Figure 3.4 – App layout display with a fragment added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – App layout display with a fragment added</p>
			<p>This proves that<a id="_idIndexMarker221"/> your fragment with the text <code>Hello blank fragment</code> has been added to the activity and the layout you defined is being displayed. Next, you’ll examine the callback methods between the activity and the fragment and how this happened.</p>
			<ol>
				<li value="7">Open up the <code>MainFragment</code> class and add a <code>TAG</code> constant to the companion object with the value <code>"MainFragment"</code> to identify the class.<pre class="source code">
private const val TAG = "MainFragment"</pre></li>
			</ol>
			<p>Then, add/update the functions with appropriate log statements.</p>
			<p>You will need to add the imports for the <code>Log</code> statement and <code>context</code> to the imports at the top of the class. The following code snippet is truncated. Follow the link<a id="_idIndexMarker222"/> shown to see the full code block you need to use:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">MainFragment.kt</p>
			<pre class="source code">
import android.content.Context
import android.util.Log
    override fun onAttach(context: Context) {
        super.onAttach(context)
        Log.d(TAG, "onAttach: ")
    }
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        Log.d(TAG,"onCreate: ")
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }
    override fun onCreateView(
        inflater: LayoutInflater, container:
            ViewGroup?, savedInstanceState: Bundle?
    ): View? {
        Log.d(TAG,"onCreateView: ")
        // Inflate the layout for this fragment
        return inflater.inflate(
            R.layout.fragment_main, container, false)
    }</pre>
			<p>You can find the complete code for this step at <a href="https://packt.link/XcOJ4">https://packt.link/XcOJ4</a>.</p>
			<p>You will <a id="_idIndexMarker223"/>need to add <code>Log.d(TAG, "onCreateView")</code> to the <code>onCreateView</code> callback and <code>Log.d(TAG, "onCreate")</code> to the <code>onCreate</code> callback that already exist, and then override the <code>onAttach</code> function, adding <code>Log.d(TAG, "onAttach")</code>, and <code>onViewCreated</code>, adding <code>Log.d(TAG, "onViewCreated")</code>.</p>
			<ol>
				<li value="8">Next, open the <code>MainActivity</code> class and add a companion object with a <code>TAG</code> constant with the value <code>"MainActivity"</code>. Then add the <code>Log</code> import to the top of the class and then the common <code>onStart</code> and <code>onResume</code> callback methods, as shown in the following code snippet.<pre class="source code">
    import android.util.Log
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, "onCreate")
    }
    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart")
    }
    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume")
    }
    companion object {
        private const val TAG = "MainActivity"
    }</pre></li>
			</ol>
			<p>You’ll see that <a id="_idIndexMarker224"/>you also have to add the <code>onCreate</code> log statement, <code>Log.d</code>(<code>TAG,</code> <code>"onCreate"</code>), as this callback was already there when you added the activity to the project.</p>
			<p>You learned in <a href="B19411_02.xhtml#_idTextAnchor103"><em class="italic">Chapter 2</em></a>, <em class="italic">Building User Screen Flows</em>, how to view log statements, and you are going to open the <strong class="bold">Logcat</strong> window in Android Studio to examine the logs and the order they are called in when you run the app.</p>
			<p>In <a href="B19411_02.xhtml#_idTextAnchor103"><em class="italic">Chapter 2</em></a>, <em class="italic">Building User Screen Flows</em>, you viewed logs from a single activity so you could see the order they were called in. Now you’ll examine the order in which the <code>MainActivity</code> and <code>MainFragment</code> callbacks happen.</p>
			<ol>
				<li value="9">Open up the <code>MainActivity</code> and <code>MainFragment</code> start with <code>Main</code>, you can type <code>tag:Main</code> in the search box to filter the logs to only show statements with this text. Run the app,<a id="_idTextAnchor216"/> and you should see the following:</li>
			</ol>
			<div><div><img src="img/B19411_03_05.jpg" alt="Figure 3.5 – Logcat statements shown when starting the app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Logcat statements shown when starting the app</p>
			<p>What’s interesting here is that the first few callbacks are from the fragment. It is linked to the activity it has been placed in with the <code>onAttach</code> callback. The fragment is <a id="_idIndexMarker225"/>initialized, and its view is displayed in <code>onCreate</code> and <code>onCreateView</code>, before another callback, <code>onViewCreated</code>, is called, confirming that the fragment UI is ready to be displayed.</p>
			<p>This is before the activity’s <code>onCreate</code> method is called. This makes sense as the activity creates its UI based on what it contains. As this is a fragment that defines its own layout, the activity needs to know how to measure, lay out, and draw the fragment as it does in the <code>onCreate</code> method.</p>
			<p>Then, the fragment receives confirmation that this has been done with the <code>onActivityCreated</code> callback before both the fragment and activity start to display the UI in <code>onStart</code>, before preparing the user to interact with it after their respective <code>onResume</code> callbacks have finished.</p>
			<p class="callout heading">Note</p>
			<p class="callout">The interaction between the activity and fragment lifecycles detailed previously is for cases when static fragments, which are those defined in the layout of an activity, are created. For dynamic fragments, which can be added when the activity is already running, the interaction can differ.</p>
			<p>So, now that the fragment and the containing activity are shown, what happens when the app is backgrounded or closed? The callbacks are still interleaved when the fragment and activity are paused, stopped, and finished.</p>
			<ol>
				<li value="10">Add the<a id="_idIndexMarker226"/> following callbacks to the <code>MainFragment</code> class:<pre class="source code">
override fun onPause() {
    super.onPause()
    Log.d(TAG, "onPause")
}
override fun onStop() {
    super.onStop()
    Log.d(TAG, "onStop")
}
override fun onDestroyView() {
    super.onDestroyView()
    Log.d(TAG, "onDestroyView")
}
override fun onDestroy() {
    super.onDestroy()
    Log.d(TAG, "onDestroy")
}
override fun onDetach() {
    super.onDetach()
    Log.d(TAG, "onDetach")
}</pre></li>
				<li>Then, add these callbacks to <code>MainActivity</code>:<pre class="source code">
override fun onPause() {
    super.onPause()
    Log.d(TAG, "onPause")
}
override fun onStop() {
    super.onStop()
    Log.d(TAG, "onStop")
}
override fun onDestroy() {
    super.onDestroy()
    Log.d(TAG, "onDestroy")
}</pre></li>
				<li>Build the app, and <a id="_idIndexMarker227"/>once it is running, you’ll see the callbacks from before starting both the fragment and activity. You can use the dustbin icon at the top left of the <code>Logcat</code> window to clear the statements. Then, rotate the app a<a id="_idTextAnchor217"/>nd review the output log statements:</li>
			</ol>
			<div><div><img src="img/B19411_03_06.jpg" alt="Figure 3.6 – Logcat statements shown when closing the app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Logcat statements shown when closing the app</p>
			<p>The <code>onPause</code> and <code>onStop</code> statements are as you might expect in that the fragment gets notified of these callbacks first as it is contained within the activity. You can think of this as being inward to outward in that the child elements are notified before the containing parent, so the parent knows how to respond.</p>
			<p>The fragment is then torn down, removed from the activity, and then destroyed with the <code>onDestroyView</code>, <code>onDestroy</code>, and <code>onDetach</code> functions before the activity itself is destroyed after any final cleanup is done in <code>onDestroy</code>. It doesn’t make sense for the activity to finish until all the component parts that make up the activity are themselves removed.</p>
			<p>The full fragment lifecycle callbacks and how they relate to the activity callbacks are complicated in Android because which callbacks are applied in which situation can differ quite substantially. To view a more detailed overview, see the official documentation at <a href="">https://developer.android.com/guide/fragments</a>.</p>
			<p>For the majority of situations, you will only use the preceding fragment callbacks. This example demonstrates both how self-contained fragments are in their creation, display, and destruction, and also their interdependence with the containing activity.</p>
			<p>Now that we’ve<a id="_idIndexMarker228"/> gone through a basic example of adding a fragment to an activity and examining the interaction between the fragment and the activity, let’s see a more detailed example of how <a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>you add two fragments to an activity.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor220"/>Exercise 3.02 – adding fragments statically to an activity</h2>
			<p>This exercise will<a id="_idIndexMarker229"/> demonstrate how to add two fragments to an activity with their own UI and separate functionality. You’ll create a simple counter class that increments and decrements a number and a color class that changes the color applied programmatically to some <code>Hello World</code> text. Perform the following steps:</p>
			<ol>
				<li>Create an application in Android Studio with an empty activity called <code>Fragment</code> <code>Intro</code>. Then, add the following strings required for the exercise in the <code>res</code> | <code>values</code> | <code>strings.xml</code> file:<pre class="source code">
    &lt;string name="hello_world"&gt;Hello World&lt;/string&gt;
    &lt;string name="red_text"&gt;Red&lt;/string&gt;
    &lt;string name="green_text"&gt;Green&lt;/string&gt;
    &lt;string name="blue_text"&gt;Blue&lt;/string&gt;
    &lt;string name="zero"&gt;0&lt;/string&gt;
    &lt;string name="plus"&gt;+&lt;/string&gt;
    &lt;string name="minus"&gt;-&lt;/string&gt;
    &lt;string name="counter_text"&gt;Counter&lt;/string&gt;</pre></li>
			</ol>
			<p>These strings are used in both the counter fragment as well as the color fragment, which you will create next.</p>
			<ol>
				<li value="2">Add a new blank fragment by going to <code>CounterFragment</code> with the <code>fragment_counter</code> layout name.</li>
				<li>Now, make changes to the <code>fragment_counter.xml</code> file. The following code is truncated for<a id="_idIndexMarker230"/> space. Follow the link shown for the full code you need to use:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">fragment_counter.xml</p>
			<pre class="source code">
&lt;TextView
    android:id="@+id/counter_text"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/counter_text"
    android:paddingTop="10dp"
    android:textSize="44sp"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"/&gt;
&lt;TextView
    android:id="@+id/counter_value"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/zero"
    android:textSize="54sp"
    android:textStyle="bold"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toBottomOf=
        "@id/counter_text"
    app:layout_constraintBottom_toTopOf="@id/plus"/&gt;</pre>
			<p>You can find the complete code for this step at <a href="https://packt.link/ca4EK">https://packt.link/ca4EK</a>.</p>
			<p>We are<a id="_idIndexMarker231"/> using a simple <code>ConstraintLayout</code> file that has a <code>TextView</code> set up for the <code>@+id/counter_text</code> header and a <code>TextView</code> for the value of the counter, <code>android:id="@+id/counter_value"</code> (with a default of <code>@string/zero</code>), which will be changed by the <code>android:id="@+id/plus"</code> and <code>android:id="@+id/minus"</code> buttons.</p>
			<p class="callout heading">Note</p>
			<p class="callout">For a simple example such as this, you are not going to set individual styles on the views with <code>style="@some_style"</code> notation, which would be best practice to avoid repeating these values on each view.</p>
			<ol>
				<li value="4">Now open <code>CounterFragment</code> and add a property to be the counter below the class header (it is a <code>var</code> so it is mutable and can be changed):<pre class="source code">
var counter  = 0</pre></li>
				<li>Now open and add the following <code>onViewCreated</code> function. You <a id="_idIndexMarker232"/>will also need to add the following imports to the top of the class:<pre class="source code">
import android.widget.Button
import android.widget.TextView
override fun onViewCreated(view: View,
savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    val counterValue =
       view.findViewById&lt;TextView&gt;(R.id.counter_value)
    view.findViewById&lt;Button&gt;(R.id.plus)
    .setOnClickListener {
        counter++
        counterValue.text = counter.toString()
    }
    view.findViewById&lt;Button&gt;(R.id.minus)
    .setOnClickListener {
        if (counter &gt; 0) {
            counter--
            counterValue.text = counter.toString()
        }
    }
}</pre></li>
			</ol>
			<p>We’ve added <code>onViewCreated</code>, which is the callback run when the layout has been applied to your fragment. The <code>onCreateView</code> callback, which creates the view, was run when the fragment itself was created.</p>
			<p>The buttons you’ve specified in the preceding fragment have <code>OnClickListener</code> set up on them to increment and decrement the value of the <code>counter</code>.</p>
			<ol>
				<li value="6">Firstly, within the plus button <code>OnClickListener</code>, you are incrementing the counter and setting this value on the view:<pre class="source code">
counter++
counterValue.text = counter.toString()</pre></li>
				<li>Then, within the minus button <code>OnClickListener</code>, it decrements the value by one but <a id="_idIndexMarker233"/>only if the value is greater than one, so no negative numbers are set:<pre class="source code">
if (counter &gt; 0) {
    counter--
    counterValue.text = counter.toString()
}</pre></li>
				<li>You have not added the fragment to the <code>MainActivity</code> layout. To do this, go into <code>activity_main.xml</code> and replace the contents with the following code:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;
    &lt;fragment
        android:id="@+id/counter_fragment"
        android:name="com.example.fragmentintro
            .CounterFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>You are going to<a id="_idIndexMarker234"/> change the layout from <code>ConstraintLayout</code> to <code>LinearLayout</code> for simplicity as you can easily add one fragment above the other when you come to the next stage. You specify the fragment to be used within the <code>fragment</code> XML element with the <code>name</code> attribute with the fully qualified package name used for the class: <code>android:name="com.example.fragmentintro.CounterFragment</code>.</p>
			<p>If you used a different package name when you created the app, then this must refer to the <code>CounterFragment</code> you created. The important thing to grasp here is that you have added a fragment to your main activity layout and the fragment also has a layout.</p>
			<p>This shows some of the power of using fragments as you can encapsulate the functionality of one feature of your app, complete with a layout file and fragment class, and add it to multiple activities.</p>
			<p>Once you’ve done this, run the fragme<a id="_idTextAnchor221"/>nt in the virtual device as in <em class="italic">Figure 3</em><em class="italic">.7</em>:</p>
			<div><div><img src="img/B19411_03_07.jpg" alt="Figure 3.7 – App displaying the counter fragment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – App displaying the counter fragment</p>
			<p>You have created<a id="_idIndexMarker235"/> a simple counter. The basic functionality works as expected, incrementing and decrementing a counter value.</p>
			<ol>
				<li value="9">In the next step, you are going to add another fragment to the bottom half of the screen. This demonstrates the versatility of fragments. You can have encapsulated pieces of the UI with functionality and features in different areas of the screen.</li>
				<li>Now, create a new fragment using the earlier steps for creating the <code>CounterFragment</code> called <code>ColorFragment</code> with the <code>fragment_color</code> layout name.</li>
				<li>Next, open up the <code>fragment_color.xml</code> file that has been created and replace the contents with the code at the following link. The following snippet is truncated – see<a id="_idIndexMarker236"/> the link for the full code:<pre class="source code">
&lt;TextView
        android:id="@+id/hello_world"
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:textSize="34sp"
        android:paddingBottom="12dp"
        android:text="@string/hello_world"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;
    &lt;Button
        android:id="@+id/red_button"
        android:layout_width="wrap_content"
        android:layout_height="0dp"
        android:textSize="24sp"
        android:text="@string/red_text"
app:layout_constraintEnd_toStartOf="@+id/green_button"
app:layout_constraintStart_toStartOf="parent"
app:layout_constraintTop_toBottomOf="@id/hello_world"
/&gt;</pre></li>
			</ol>
			<p>You can find the complete code for this step at <a href="https://packt.link/GCYDR">https://packt.link/GCYDR</a>.</p>
			<p>The layout adds a <code>TextView</code> with three buttons. The <code>TextView</code> text and the text for all the buttons are set as string resources (<code>@string</code>).</p>
			<ol>
				<li value="12">Next, go<a id="_idIndexMarker237"/> into the <code>activity_main.xml</code> file and add <code>ColorFragment</code> below <code>CounterFragment</code> inside <code>LinearLayout</code>:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;
    &lt;fragment
        android:id="@+id/counter_fragment"
        android:name="com.example.fragmentintro
            .CounterFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/&gt;
    &lt;fragment
        android:id="@+id/color_fragment"
        android:name="com.example.fragmentintro
            .ColorFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>When you run<a id="_idIndexMarker238"/> the app, you will see that <code>Co<a id="_idTextAnchor222"/>lorFragment</code> is not visible, as in <em class="italic">Figure 3</em><em class="italic">.8</em>:</p>
			<div><div><img src="img/B19411_03_071.jpg" alt="Figure 3.8 – App shown without ColorFragment displayed"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – App shown without ColorFragment displayed</p>
			<p>You’ve included<a id="_idIndexMarker239"/> <code>ColorFragment</code> in the layout, but because <code>CounterFragment</code> has its width and height set to match its parent (<code>android:layout_width="match_parent android:layout_height="match_parent"</code>) and it is the first view in the layout, it takes up all the space.</p>
			<p>What you need is some way to specify the proportion of the height that each fragment should occupy. The <code>LinearLayout</code> orientation is set to vertical so the fragments will appear one on top of the other when <code>layout_height</code> is not set to <code>match_parent</code>.</p>
			<p>In order to define the proportion of this height, you need to add another attribute, <code>layout_weight</code>, to each fragment in the <code>activity_main.xml</code> layout file. When you use <code>layout_weight</code> to determine the proportional height the fragments should occupy, you set the <code>layout_height</code> value of the fragments to <code>0dp</code>.</p>
			<ol>
				<li value="13">Update the <code>activity_main.xml</code> layout with the following changes, setting <code>layout_height</code> for both fragments to <code>0dp</code> and adding the <code>layout_weight</code> attributes<a id="_idIndexMarker240"/> with the following values:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;
    &lt;fragment
        android:id="@+id/counter_fragment"
        android:name="com.example.fragmentintro
            .CounterFragment"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="2"/&gt;
    &lt;fragment
        android:id="@+id/color_fragment"
        android:name="com.example.fragmentintro
            .ColorFragment"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>These changes<a id="_idIndexMarker241"/> make <code>CounterFragment</code> occupy twice the heigh<a id="_idTextAnchor223"/>t of <code>ColorFragment</code>, as shown in <em class="italic">Figure 3</em><em class="italic">.9</em>:</p>
			<div><div><img src="img/B19411_03_08.jpg" alt="Figure 3.9 – CounterFragment with twice the amount of vertical space allocated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – CounterFragment with twice the amount of vertical space allocated</p>
			<p>You can<a id="_idIndexMarker242"/> experiment by changing the weight values to see the differences you can make to the display of the layout.</p>
			<ol>
				<li value="14">At this point, pressing the <strong class="bold">RED</strong>, <strong class="bold">GREEN</strong>, and <strong class="bold">BLUE</strong> color buttons will have no effect on the <strong class="bold">Hello World</strong> text. The button actions have not been specified. The next step involves adding interactivity to the buttons to make changes to the style of the <strong class="bold">Hello </strong><strong class="bold">World</strong> text.</li>
				<li>Add the following <code>onViewCreated</code> function in <code>ColorFragment</code>, which overrides its parent to add behavior to the fragment after the layout view has been set up. You will also need to add the <code>TextView</code>, <code>Color</code>, and <code>Button</code> imports to<a id="_idIndexMarker243"/> change the color of the text:<pre class="source code">
import android.widget.Button
import android.widget.TextView
import android.graphics.Color
override fun onViewCreated(view: View,
savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    val redButton =
        view.findViewById&lt;Button&gt;(R.id.red_button)
    val greenButton =
        view.findViewById&lt;Button&gt;(R.id.green_button)
    val blueButton =
        view.findViewById&lt;Button&gt;(R.id.blue_button)
    val helloWorldTextView =
        view.findViewById&lt;TextView&gt;(R.id.hello_world)
    redButton.setOnClickListener {
        helloWorldTextView.setTextColor(Color.RED)
    }
    greenButton.setOnClickListener {
        helloWorldTextView.setTextColor(Color.GREEN)
    }
    blueButton.setOnClickListener {
        helloWorldTextView.setTextColor(Color.BLUE)
    }
}</pre></li>
			</ol>
			<p>Here, you are<a id="_idIndexMarker244"/> adding an <code>OnClickListener</code> to each button defined in the layout and setting the <strong class="bold">Hello World</strong> text to the desired color.</p>
			<ol>
				<li value="16">Run the app and press the <strong class="bold">RED</strong>, <strong class="bold">GREEN</strong>, and <strong class="bold">BLUE</strong> buttons. You should<a id="_idTextAnchor224"/> see a similar display to the one in <em class="italic">Figure 3</em><em class="italic">.10</em>:</li>
			</ol>
			<div><div><img src="img/B19411_03_09.jpg" alt="Figure 3.10 – ColorFragment setting text color to red, green, and blue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – ColorFragment setting text color to red, green, and blue</p>
			<p>This exercise, although<a id="_idIndexMarker245"/> simple, has demonstrated some fundamental concepts of using fragments. The features of your app that the user can interact with can be developed independently and not rely on bundling two or more features into one layout and activity. This makes fragments reusable and means you can focus your attention when developing your app on adding a well-defin<a id="_idTextAnchor225"/><a id="_idTextAnchor226"/>ed UI, logic, and features into a single fragment.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor227"/>Static fragments and dual-pane layouts</h1>
			<p>The previous<a id="_idIndexMarker246"/> exercise introduced you to static fragments, those that can be defined in the activity XML layout file. You can also create different layouts and resources for different screen sizes. This is used for deciding which resources to display depending on whether the device is a phone or a tablet.</p>
			<p>The space for laying out UI elements can increase substantially with a larger size tablet. Android allows specifying different resources depending on many different form factors. The qualifier frequently used to define a tablet in the <code>res</code> (resources) folder is <code>sw600dp</code>.</p>
			<p>This states that if the shortest width (<code>sw</code>) of the device is over 600 dp, then use these resources. This qualifier is used for 7” tablets and larger. Tablets facilitate what is known as dual-pane layouts. A pane represents a self-contained part of the user interface. If the screen is large enough, then two panes (dual-pane layouts) can be supported. This also provides the opportunity for o<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>ne pane to interact with another to update content.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor230"/>Exercise 3.03 – dual-pane layouts with static fragments</h2>
			<p>In this exercise, you <a id="_idIndexMarker247"/>are going to create a simple app<a id="_idIndexMarker248"/> that displays a list of star signs and specific information about each star sign. It will use different displays for phones and tablets.</p>
			<p>The phone will display a list and then open the selected list item’s content on another screen while the tablet will display the same list in one pane and open the list item’s content in another pane on the same screen in a dual-pane layout.</p>
			<p>In order to do this, you have to create another layout that will only be used for 7” tablets and above. Perform the following steps:</p>
			<ol>
				<li>Firstly, create a new Android Studio project with an <code>Empty Activity</code> called <code>Dual </code><code>Pane Layouts</code>.</li>
				<li>Then, making sure the Android view is selected in the project view on the left-hand side, go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Android Resource File</strong> and fill in the following fields of the dialog (you need to select <strong class="bold">Smallest Screen Width</strong> in the dialog’s left-hand pane – once you ha<a id="_idTextAnchor231"/>ve selected it, the option changes to <strong class="bold">Screen Width</strong>):</li>
			</ol>
			<div><div><img src="img/B19411_03_10.jpg" alt="Figure 3.11 – Device Variations View"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Device Variations View</p>
			<ol>
				<li value="3">This creates<a id="_idIndexMarker249"/> a <a id="_idIndexMarker250"/>new folder in the <code>main</code> | <code>res</code> folder named <code>'layou<a id="_idTextAnchor232"/>t-sw600dp'</code> with the <code>activity_main.xml</code> layout file added.</li>
			</ol>
			<p>At the moment, it is a duplicate of the <code>activity_main.xml</code> file added when you created the app, but you will change it to customize the screen display for tablets.</p>
			<p>In order to demonstrate the use of dual-pane layouts, you are going to create a list of star signs so that, when a list item is selected, it will display some basic information about the star sign.</p>
			<ol>
				<li value="4">Go to the top toolbar and select <code>ListFragment</code>.</li>
			</ol>
			<p>For this exercise, you need to update the <code>strings.xml</code> and <code>themes.xml</code> files, adding <a id="_idIndexMarker251"/>the<a id="_idIndexMarker252"/> following entries:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">strings.xml</p>
			<pre class="source code">
    &lt;string name="star_signs"&gt;Star Signs&lt;/string&gt;
    &lt;string name="symbol"&gt;Symbol: %s&lt;/string&gt;
    &lt;string name="date_range"&gt;Date Range: %s&lt;/string&gt;
    &lt;string name="aquarius"&gt;Aquarius&lt;/string&gt;
    &lt;string name="pisces"&gt;Pisces&lt;/string&gt;
    &lt;string name="aries"&gt;Aries&lt;/string&gt;
    &lt;string name="taurus"&gt;Taurus&lt;/string&gt;
    &lt;string name="gemini"&gt;Gemini&lt;/string&gt;
    &lt;string name="cancer"&gt;Cancer&lt;/string&gt;
    &lt;string name="leo"&gt;Leo&lt;/string&gt;
    &lt;string name="virgo"&gt;Virgo&lt;/string&gt;
    &lt;string name="libra"&gt;Libra&lt;/string&gt;
    &lt;string name="scorpio"&gt;Scorpio&lt;/string&gt;
    &lt;string name="sagittarius"&gt;Sagittarius&lt;/string&gt;
    &lt;string name="capricorn"&gt;Capricorn&lt;/string&gt;
    &lt;string name="unknown_star_sign"&gt;Unknown Star Sign
    &lt;/string&gt;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">themes.xml</p>
			<pre class="source code">
    &lt;style name="StarSignTextView"
    parent="Base.TextAppearance.AppCompat.Large" &gt;
        &lt;item name="android:padding"&gt;18dp&lt;/item&gt;
    &lt;/style&gt;
    &lt;style name="StarSignTextViewHeader"
    parent="Base.TextAppearance.AppCompat.Display1" &gt;
        &lt;item name="android:padding"&gt;18dp&lt;/item&gt;
    &lt;/style&gt;</pre>
			<ol>
				<li value="5">Open the <code>main</code> | <code>res</code> | <code>layout</code> | <code>fragment_list.xml</code> file and replace the default <a id="_idIndexMarker253"/>contents <a id="_idIndexMarker254"/>with the following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ScrollView
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:context=".ListFragment"&gt;
    &lt;LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"&gt;
        &lt;TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:textSize="24sp"
            android:textStyle="bold"
            style="@style/StarSignTextView"
            android:text="@string/star_signs" /&gt;
        &lt;View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="?android:attr/
                dividerVertical" /&gt;
        &lt;TextView
            android:id="@+id/aquarius"
            style="@style/StarSignTextView"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/aquarius" /&gt;
    &lt;/LinearLayout&gt;
&lt;/ScrollView&gt;</pre></li>
			</ol>
			<p>You will see<a id="_idIndexMarker255"/> that <a id="_idIndexMarker256"/>the first <code>xml</code> element is a <code>ScrollView</code>. A <code>ScrollView</code> is a <code>ViewGroup</code> that allows the contents to scroll, and as you will be adding 12 star signs into the <code>LinearLayout</code> it contains, this is likely to occupy more vertical space than is available on the screen.</p>
			<p>Adding <code>ScrollView</code> prevents the contents from being cut off vertically when there is no more room to display them and scrolls the layout. A <code>ScrollView</code> can only contain one child view. Here, it’s a <code>LinearLayout</code>, and as the contents will be displayed vertically, the orientation is set to vertical (<code>android:orientation="vertical"</code>). Below the first title <code>TextView</code>, you have added a divider <code>View</code> and a <code>TextView</code> for the first star sign, Aquarius.</p>
			<ol>
				<li value="6">Add the other 11 star signs with the same format, adding the divider first and then the <code>TextView</code>. The name of the string resource and the <code>id</code> value should be the same for each <code>TextView</code>. The <a id="_idIndexMarker257"/>names of the star<a id="_idIndexMarker258"/> signs you will create a view from are specified in the <code>strings.xml</code> file.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The technique used to lay out a list is fine for an example, but in a real-world app, you would create a <code>RecyclerView</code> dedicated to displaying lists that can scroll, with the data bound to the list by an adapter. You will cover this in a later chapter.</p>
			<ol>
				<li value="7">Next, create <code>StarSignListener</code> above the <code>MainActivity</code> class header and make <code>MainActivity</code> implement it by adding the following:<pre class="source code">
interface StarSignListener {
    fun onSelected(id: Int)
}
class MainActivity : AppCompatActivity(),
StarSignListener {
    ...
    override fun onSelected(id: Int) {
        TODO("not implemented yet")
    }
}</pre></li>
			</ol>
			<p>This is how the fragments will communicate back to the activity when a user selects a star sign from <code>ListFragment</code> and logic will be added depending on whether a dual pane is available or not.</p>
			<ol>
				<li value="8">Once you’ve created the layout file, go into the <code>ListFragment</code> class and update it with the following contents, keeping <code>onCreateView()</code> in place. You can see in the fragment in the <code>onAttach()</code> callback you are stating that the activity implements the <code>StarSignListener</code> interface so it can be notified<a id="_idIndexMarker259"/> when<a id="_idIndexMarker260"/> the user clicks an item in the list. Add the import for the <code>Context</code> required for <code>onAttach</code> with the other imports at the top of the file:<pre class="source code">
import android.content.Context
class ListFragment : Fragment(), View.OnClickListener
{
    // TODO: Rename and change types of parameters
    private var param1: String? = null
    private var param2: String? = null
    private lateinit var starSignListener:
        StarSignListener
    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is StarSignListener) {
            starSignListener = context
        } else {
            throw RuntimeException("Must implement
                StarSignListener")
        }
}
      override fun onCreateView(...)
      override fun onViewCreated(view: View,
      savedInstanceState:Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val starSigns = listOf&lt;View&gt;(
            view.findViewById(R.id.aquarius),
            view.findViewById(R.id.pisces),
            view.findViewById(R.id.aries),
            view.findViewById(R.id.taurus),
            view.findViewById(R.id.gemini),
            view.findViewById(R.id.cancer),
            view.findViewById(R.id.leo),
            view.findViewById(R.id.virgo),
            view.findViewById(R.id.libra),
            view.findViewById(R.id.scorpio),
            view.findViewById(R.id.sagittarius),
            view.findViewById(R.id.capricorn)
        )
        starSigns.forEach {
            it.setOnClickListener(this)
        }
    }
    override fun onClick(v: View?) {
        v?.let { starSign -&gt;
            starSignListener.onSelected(starSign.id)
        }
    }
}</pre></li>
			</ol>
			<p>The remaining<a id="_idIndexMarker261"/> callbacks<a id="_idIndexMarker262"/> are similar to what you have seen in the previous exercises. You create the fragment view with <code>onCreateView</code>. You set up the buttons with an <code>OnClickListener</code> in <code>onViewCreated</code> and then you handle clicks in <code>onClick</code>.</p>
			<p>The <code>listOf</code> syntax in <code>onViewCreated</code> is a way of creating a <code>readonly</code> list with the specified elements, which in this case are your star sign <code>TextView</code> instances. Then, in the following code, you loop over these <code>TextViews</code>, setting the <code>OnClickListener</code> for each of the individual <code>TextViews</code> by iterating over the <code>TextView</code> list with the <code>forEach</code> statement. The <code>it</code> syntax here refers to the element of the list that is being operated on, which will be one of the 12 star sign <code>TextViews</code>.</p>
			<ol>
				<li value="9">Finally, the <code>onClick</code> statement communicates back to the activity through <code>StarSignListener</code> when one of the star signs in the list has been clicked:<pre class="source code">
v?.let { starSign -&gt;
    starSignListener.onSelected(starSign.id)
}</pre></li>
			</ol>
			<p>You check whether the view specified as <code>v</code> is null with <code>?</code> and then only operate upon it with the <code>let</code> scope function if it isn’t, before passing the <code>id</code> value of the star sign to <code>Activity</code>/<code>StarSignListener</code>.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Listeners are a common way to react to changes. By specifying a <code>Listener</code> interface, you are specifying a contract to be fulfilled. The implementing class is then notified of the results of the listener operation.</p>
			<ol>
				<li value="10">Next, create <code>DetailFragment</code>, which will display the star sign details. Create a <a id="_idIndexMarker263"/>blank<a id="_idIndexMarker264"/> fragment as you have done before and call it <code>DetailFragment</code>. Replace the <code>fragment_detail</code> layout file contents with the following XML file:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".DetailFragment"&gt;
    &lt;TextView
        android:id="@+id/star_sign"
        style="@style/StarSignTextViewHeader"
        android:textStyle="bold"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:text="Aquarius"/&gt;
    &lt;TextView
        android:id="@+id/symbol"
        style="@style/StarSignTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:text="Water Carrier"/&gt;
    &lt;TextView
        android:id="@+id/date_range"
        style="@style/StarSignTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:text="Date Range:
            January 20 - February 18" /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>Here, you create <a id="_idIndexMarker265"/>a <a id="_idIndexMarker266"/>simple <code>LinearLayout</code>, which will display the star sign name, the symbol of the star sign, and the date range. You’ll set these values in <code>DetailFragment</code>.</p>
			<ol>
				<li value="11">Open <code>DetailFragment</code> and update the contents with the following text and also add <code>TextView</code> and <code>Toast</code> imports to the imports list:<pre class="source code">
import android.widget.TextView
import android.widget.Toast
class DetailFragment : Fragment() {
    // TODO: Rename and change types of parameters
    private var param1: String? = null
    private var param2: String? = null
    private val starSign: TextView?
        get() = view?.findViewById(R.id.star_sign)
    private val symbol: TextView?
        get() = view?.findViewById(R.id.symbol)
    private val dateRange: TextView?
        get() = view?.findViewById(R.id.date_range)
    override fun onCreate(...)
    override fun onCreateView(...)
    fun setStarSignData(starSignId: Int) {
        when (starSignId) {
            R.id.aquarius -&gt; {
                starSign?.text =
                    getString(R.string.aquarius)
                symbol?.text =
                    getString(R.string.symbol,
                        "Water Carrier")
                dateRange?.text =
                    getString(R.string.date_range,
                        "January 20 - February 18")
            }
        }
    }
}</pre></li>
			</ol>
			<p>The <code>onCreateView</code> inflates the layout as normal. The <code>setStarSignData()</code> function is what populates the data from the passed-in <code>starSignId</code>. The <code>when</code> expression is used to determine the ID of the star sign and set the appropriate contents.</p>
			<p>The <code>setStarSignData</code> function<a id="_idIndexMarker267"/> here<a id="_idIndexMarker268"/> formats text passed with the <code>getString</code> function – <code>getString(R.string.symbol,"Water Carrier")</code>, for example, passes the text <code>Water Carrier</code> into the <code>symbol</code> string, <code>&lt;string name="symbol"&gt;Symbol: %s&lt;/string&gt;</code>, and replaces <code>%s</code> with the passed-in value. You can see what other string formatting options there are in the official docs: <a href="">https://developer.android.com/guide/topics/resources/string-resource</a>.</p>
			<p>Following the pattern introduced by <code>aquarius</code>, add the other 11 star signs below the <code>aquarius</code> block from the completed file here: <a href="https://packt.link/C9sWZ">https://packt.link/C9sWZ</a>.</p>
			<p>Right now, you have added both <code>ListFragment</code> and <code>DetailFragment</code>. Currently, however, they have not been added to the activity layout and/or synced together, so selecting the star sign item in <code>ListFragment</code> will not load contents into <code>DetailFragment</code>. Let’s look at how you can change that.</p>
			<ol>
				<li value="12">Firstly, you need to change the layout of <code>activity_main.xml</code> in both the <code>layout</code> folder and <code>layout-sw600dp</code>.</li>
				<li>Open up <code>res</code> | <code>layout</code> | <code>activity_main.xml</code> if in the Project view. In the default Android view, open up <code>res</code> | <code>layout</code> | <code>activity_main.xml</code> and select the top <code>activity_main.xml</code> file without (<code>sw600dp</code>). Replace the contents with<a id="_idIndexMarker269"/> the<a id="_idIndexMarker270"/> following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;
    &lt;fragment
        android:id="@+id/star_sign_list"
        android:name="com.example.dualpanelayouts
            .ListFragment"
        android:layout_height="match_parent"
        android:layout_width="match_parent"/&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
			</ol>
			<p>If you run the app and select one of the star signs now, you will get a <code>NotImplementedError</code> as we need to replace the <code>TODO</code> item with this functionality.</p>
			<ol>
				<li value="14">Then, open up <code>res</code> | <code>layout-sw600dp</code> | <code>activity_main.xml</code> if in the Project view. In the default Android view, open up <code>res</code> | <code>layout</code> | <code>activity_main.xml (sw600dp)</code>. Replace <a id="_idIndexMarker271"/>the <a id="_idIndexMarker272"/>contents with the following:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    tools:context=".MainActivity"&gt;
    &lt;fragment
        android:id="@+id/star_sign_list"
        android:name="com.example.dualpanelayouts
            .ListFragment"
        android:layout_height="match_parent"
        android:layout_width="0dp"
        android:layout_weight="1"/&gt;
    &lt;View
        android:layout_width="1dp"
        android:layout_height="match_parent"
        android:background="?android:attr/
            dividerVertical" /&gt;
    &lt;fragment
        android:id="@+id/star_sign_detail"
        android:name="com.example.dualpanelayouts
            .DetailFragment"
        android:layout_height="match_parent"
        android:layout_width="0dp"
        android:layout_weight="2"/&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>You are adding <code>LinearLayout</code>, which will by default lay out its content horizontally.</p>
			<p>You add <code>ListFragment</code>, a divider, and then <code>DetailFragment</code> and assign the<a id="_idIndexMarker273"/> fragments <a id="_idIndexMarker274"/>appropriate IDs. Notice also that you are using the concept of weights to assign the space available for each fragment. When you do this, you specify <code>android:layout_width="0dp"</code>. <code>layout_weight</code> then sets the proportion of the width available by the weight measurements as <code>LinearLayout</code> is set to lay out the fragments horizontally.</p>
			<p><code>ListFragment</code> is specified as <code>android:layout_weight="1"</code> and <code>DetailFragment</code> is specified as <code>android:layout_weight="2"</code>, which tells the system to assign <code>DetailFragment</code> twice the width of <code>ListFragment</code>. In this case, where there are three views including the divider, which is a fixed dp width, this will result roughly in <code>ListFragment</code> occupying one-third of the width and <code>DetailFragment</code> occupying two-thirds.</p>
			<ol>
				<li value="15">To see the app, create a new virtual device as shown in <a href="B19411_01.xhtml#_idTextAnchor025"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First App</em>, and select <strong class="bold">Category</strong> | <strong class="bold">Tablet</strong> | <strong class="bold">Nexus 7</strong>.</li>
				<li>This will create a 7” tablet. Then, launch the virtual device and run the app. This <a id="_idTextAnchor233"/>is the initial view you will see when you launch the tablet in portrait mode:</li>
			</ol>
			<div><div><img src="img/B19411_03_11.jpg" alt="Figure 3.12 – Initial star sign app UI display"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Initial star sign app UI display</p>
			<p>You can see that <a id="_idIndexMarker275"/>the<a id="_idIndexMarker276"/> list takes up about a third of the screen and the blank space two-thirds of the screen.</p>
			<ol>
				<li value="17">Click the <img src="img/B19411_03_12.png" alt=""/> bottom rotate button on the virtual device to turn the virtual device 90 degrees clockwise.</li>
				<li>Once you’ve done that, the virtual device will go into landscape mode. It will not, however, change the screen orientation to landscape.</li>
				<li>In order to do this, click on the <img src="img/B19411_03_13.png" alt="3"/> rotate button in the bottom-left corner of the virtual device. You can also select the status bar at the top of the virtual device and hold and drag down to display the quick settings bar where you can turn on auto-rotation by selecting the rotate button. (You might have to swi<a id="_idTextAnchor234"/>pe left/right within <a id="_idIndexMarker277"/>the <a id="_idIndexMarker278"/>quick settings bar to show the <strong class="bold">Auto-rotate</strong> option.)</li>
			</ol>
			<div><div><img src="img/B19411_03_14.jpg" alt="Figure 3.13 – Quick settings bar wi﻿th Auto-rotate selected"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Quick settings bar wi<a id="_idTextAnchor235"/>th Auto-rotate selected</p>
			<ol>
				<li value="20">This will then change the tablet layout to landscape:</li>
			</ol>
			<div><div><img src="img/B19411_03_15.jpg" alt="Figure 3.14 – Initial star sign app UI display in landscape on a tablet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Initial star sign app UI display in landscape on a tablet</p>
			<ol>
				<li value="21">The next thing to do is enable selecting a list item to load contents into the <code>Detail</code> pane of <a id="_idIndexMarker279"/>the<a id="_idIndexMarker280"/> screen. For that, we need to make changes in <code>MainActivity</code>. Update <code>MainActivity</code> with the following code to retrieve fragments by their ID in the pattern of retrieving views by their IDs (there will be some unused imports that will be required when the phone implementation is done):<pre class="source code">
package com.example.dualpanelayouts
import android.content.Intent
import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
const val STAR_SIGN_ID = "STAR_SIGN_ID"
interface StarSignListener {
    fun onSelected(id: Int)
}
class MainActivity : AppCompatActivity(),
StarSignListener {
    var isDualPane: Boolean = false
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        isDualPane =
            findViewById&lt;View&gt;(R.id.star_sign_detail)
                != null
    }
    override fun onSelected(id: Int) {
        if (isDualPane) {
            val detailFragment =
                supportFragmentManager
                .findFragmentById(
                R.id.star_sign_detail) as
                DetailFragment
        detailFragment.setStarSignData(id)
        }
    }
}</pre></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">Fragments were introduced in API 11 in 2011 with a <code>FragmentManager</code> class to manage their interactions with activities. <code>SupportFragmentManager</code> was introduced to support using fragments in Android versions before API 11 in the Android Support Library. <code>SupportFragmentManager</code> has been further developed as the base for the Jetpack Fragment library, which adds improvements for managing fragments.</p>
			<p>This example and those that follow use <code>supportFragmentManager.findFragmentById</code> to retrieve fragments. You can also, however, retrieve fragments with <code>Tag</code> if you add a tag to the fragment XML by using <code>android:tag="MyFragmentTag"</code>.</p>
			<ol>
				<li value="22">You can <a id="_idIndexMarker281"/>then <a id="_idIndexMarker282"/>retrieve the fragment by using <code>supportFragmentManager.find</code><strong class="source inline">
</strong><code>FragmentByTag("MyFragmentTag")</code>.</li>
				<li>In order to retrieve data from the fragment, the activity needs to implement <code>StarSignListener</code>. This completes the contract set in the fragment to pass back details to the implementing class. The <code>onCreate</code> function sets the layout and then checks whether <code>DetailFragment</code> is in the activity’s inflated layout by checking whether the <code>R.id.star_sign_detail</code> ID exists.</li>
				<li>From the Project view, the <code>res</code> | <code>layout</code> | <code>activity_main.xml</code> file only contains <code>ListFragment</code>, but you’ve added the code in the <code>res</code> | <code>layout-sw600dp</code> | <code>activity_main.xml</code> file to contain <code>DetailFragment</code> with <code>android:id="@+id/star_sign_detail"</code>.</li>
				<li>This will be used for the layout of the Nexus 7 tablet. In the default Android view, open up <code>res</code> | <code>layout</code> | <code>activity_main.xml</code> and select the top <code>activity_main.xml</code> file without (<code>sw600dp</code>) and then select <code>activity_main.xml</code> (<code>sw600dp</code>) to see these differences.</li>
				<li>So now we can retrieve the star sign ID passed from <code>ListFragment</code> back to <code>MainActivity</code> by <code>StarSignListener</code> and pass it into <code>DetailFragment</code>. This is achieved by checking the <code>isDualPane</code> Boolean, and if that evaluates to <code>true</code>, you know you can pass the star sign ID to <code>DetailFragment</code> with this code:<pre class="source code">
val detailFragment = supportFragmentManager
.findFragmentById (R.id.star_sign_detail) as
DetailFragment
detailFragment.setStarSignData(id)</pre></li>
				<li>You cast the fragment from <code>id</code> to <code>DetailFragment</code> and call the following:<pre class="source code">
detailFragment.setStarSignData(id)</pre></li>
				<li>As you’ve<a id="_idIndexMarker283"/> implemented this function in the<a id="_idIndexMarker284"/><a id="_idTextAnchor236"/> fragment and are checking by the <code>id</code> value which contents to display, the UI is updated:</li>
			</ol>
			<div><div><img src="img/B19411_03_16.jpg" alt="Figure 3.15 – Star sign app dual-pane display in landscape on a tablet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Star sign app dual-pane display in landscape on a tablet</p>
			<ol>
				<li value="29">Now clicking on a list item works as intended, showing the dual-pane layout with the contents set correctly.</li>
				<li>If the device is not a tablet, however, even when a list item is clicked, nothing will happen as there is not an <code>else</code> branch condition to do anything if the device is not a tablet, which is defined by the <code>isDualPane</code> Boolean<a id="_idTextAnchor237"/>. The display will<a id="_idIndexMarker285"/> be<a id="_idIndexMarker286"/> as in <em class="italic">Figure 3</em><em class="italic">.16</em> and won’t change when items are selected:</li>
			</ol>
			<div><div><img src="img/B19411_03_17.jpg" alt="Figure 3.16 – Initial star sign app UI display on a phone"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Initial star sign app UI display on a phone</p>
			<ol>
				<li value="31">You are going to display the star sign detail in another activity. Create a new <code>DetailActivity</code> by going to <code>activity_detail.xml</code> with this layout:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".DetailActivity"&gt;
    &lt;fragment
        android:id="@+id/star_sign_detail"
        android:name="com.example.dualpanelayouts
            .DetailFragment"
        android:layout_height="match_parent"
        android:layout_width="match_parent"/&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre></li>
				<li>This adds <code>DetailFragment</code> as the only fragment in the layout. Now, update the <code>onCreate</code> function of <code>DetailActivity</code> with the following contents:<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_detail)
    val starSignId =
        intent.extras?.getInt(STAR_SIGN_ID, 0) ?: 0
    val detailFragment =
        supportFragmentManager.findFragmentById(
        R.id.star_sign_detail) as DetailFragment
    detailFragment.setStarSignData(starSignId)
}</pre></li>
				<li>The star sign <code>id</code> is expected<a id="_idIndexMarker289"/> to <a id="_idIndexMarker290"/>be passed from another activity to this one by setting a key in the intent’s extras (also called a bundle). We covered intents in <a href="B19411_02.xhtml#_idTextAnchor103"><em class="italic">Chapter 2</em></a>, <em class="italic">Building User Screen Flows</em>, but as a reminder, they enable communication between different components and also can send data.</li>
				<li>In this case, the intent that opened this activity has set a star sign ID. It will use <code>id</code> to set the star sign ID in <code>DetailFragment</code>. Next, you need to implement the <code>else</code> branch of the <code>isDualPane</code> check to launch <code>DetailActivity</code>, passing through the star sign ID in the intent.</li>
				<li>Update <code>MainActivity</code> as follows to do this:<pre class="source code">
override fun onSelected(id: Int) {
    if (isDualPane) {
        val detailFragment = supportFragmentManager
            .findFragmentById(R.id.star_sign_detail)
                as DetailFragment
        detailFragment.setStarSignData(id)
    } else {
        val detailIntent = Intent(this,
            DetailActivity::class.java)
                .apply {
                    putExtra(STAR_SIGN_ID, id)
                }
        startActivity(detailIntent)
       }
}</pre></li>
				<li>Once you click on <a id="_idIndexMarker291"/>one <a id="_idIndexMarker292"/>of the star sign names on a phone display, it show<a id="_idTextAnchor238"/>s the contents in <code>DetailActivity</code> occupying the whole of the screen without the list:</li>
			</ol>
			<div><div><img src="img/B19411_03_18.jpg" alt="Figure 3.17 – Single-pane star sign detail screen on a phone"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Single-pane star sign detail screen on a phone</p>
			<p>This exercise <a id="_idIndexMarker293"/>has<a id="_idIndexMarker294"/> demonstrated the flexibility of fragments. They can encapsulate the logic and display different features of your app, which can be integrated in different ways depending on the form factor of the device. They can be arranged onscreen in a variety of ways, which are constrained by the layout they are included in; therefore, they can feature as a part of dual-pane layouts or all or part of a single-pane layout.</p>
			<p>This exercise showed fragments being laid out side by side on a tablet, but they can also be laid out on top of each other and in a variety of other ways. The next topic illustrates how the configuration of fragments used in<a id="_idTextAnchor239"/><a id="_idTextAnchor240"/> your app doesn’t have to be specified statically in XML but can also be done dynamically.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor241"/>Dynamic fragments</h1>
			<p>So far, you’ve only<a id="_idIndexMarker295"/> seen fragments added in XML at compile time. Although this can satisfy many use cases, you might want to add fragments dynamically at runtime to respond to the user’s actions. This can be achieved by adding <code>ViewGroup</code> as a container for fragments and then adding, replacing, and removing fragments from <code>ViewGroup</code>.</p>
			<p>This technique is more flexible as the fragments can be active until they are no longer needed and then removed, instead of always being inflated in XML layouts as you have seen with static fragments. If three or four more fragments are required to fulfill separate user journeys in one activity, then the preferred option is to react to the user’s interaction in the UI by adding/replacing fragments dynamically.</p>
			<p>Using static fragments works better when the user’s interaction with the UI is fixed at compile time and you know in advance how many fragments you need. F<a id="_idTextAnchor242"/><a id="_idTextAnchor243"/>or example, this would be the case for selecting items from a list to display the contents.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor244"/>Exercise 3.04 – adding fragments dynamically to an activity</h2>
			<p>In this exercise, we<a id="_idIndexMarker296"/> will build the same star sign app as before but will demonstrate how the list and detail fragments can be added to screen layouts dynamically and not directly within an XML layout. You can also pass arguments into a fragment. For simplicity, you are going to create the same configuration for both phones and tablets. Perform the following steps:</p>
			<ol>
				<li>Create a new project with an <code>Empty Activity</code> called <code>Dynamic Fragments</code>.</li>
				<li>Once you have done that, add the following dependency – you need to use <code>FragmentContainerView</code>, an optimized ViewGroup for handling fragment transactions with <code>app/build.gradle</code> within the <code>dependences{ }</code> block:<pre class="source code">
implementation 'androidx.fragment:fragment-ktx:1.5.6'</pre></li>
				<li>Copy the contents of the following XML resource files from <em class="italic">Exercise 3.03</em> – <em class="italic">dual-pane layouts with static fragments</em>, and add them to the corresponding files in this exercise: <code>strings.xml</code> (changing the <code>app_name</code> string from <code>Dual Pane Layouts</code> to <code>Dynamic Fragments</code>), <code>fragment_detail.xml</code>, and <code>fragment_list.xml</code>. All of these files exist in the project created in the previous exercise and you simply add the contents to this new project.</li>
				<li>Then, copy <code>DetailFragment</code> and <code>ListFragment</code> to the new project. You will have to change the package name from <code>package com.example.dualpanelayouts</code> to <code>package com.example.dynamicfragments</code> in these two files. Finally, add the styles defined below the base application style in <code>themes.xml</code> from the last exercise to <code>themes.xml</code> in this project.</li>
				<li>You now have the same fragments set up as in the previous exercise. Now, open the <code>activity_main.xml</code> layout<a id="_idIndexMarker297"/> and replace the contents with this:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.fragment.app.FragmentContainerView
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    android:id="@+id/fragment_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent" /&gt;</pre></li>
			</ol>
			<p>This is the <code>FragmentContainerView</code> you will add the fragments to. You’ll notice that there are no fragments added in the layout XML as these will be added dynamically.</p>
			<ol>
				<li value="6">Go into <code>MainActivity</code> and replace the content with the following:<pre class="source code">
package com.example.dynamicfragments
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.fragment.app.FragmentContainerView
const val STAR_SIGN_ID = "STAR_SIGN_ID"
interface StarSignListener {
    fun onSelected(id: Int)
}
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            findViewById&lt;FragmentContainerView&gt;(
            R.id.fragment_container)?.let {
            frameLayout -&gt;
             val listFragment = ListFragment()
             supportFragmentManager.beginTransaction()
                 .add(frameLayout.id,
                 listFragment).commit()
            }
        }
    }
}</pre></li>
			</ol>
			<p>You are getting a reference to the <code>FragmentContainerView</code> specified in <code>activity_main.xml</code>, creating a new <code>ListFragment</code>, and then adding this fragment to the <code>FragmentContainerView</code> with the ID of the <code>fragment_container</code>.</p>
			<p>The fragment transaction specified is <code>add</code> as you are adding a fragment to <code>FrameLayout</code> for the first time. You call <code>commit()</code> to execute the transaction immediately. There is a null check with <code>savedInstanceState</code> to only add this <code>ListFragment</code> if there is no state to restore, which there would be if a fragment had been previously added.</p>
			<ol>
				<li value="7">Next, make <code>MainActivity</code> implement <code>StarSignListener</code> by adding the<a id="_idIndexMarker298"/> following:<pre class="source code">
class MainActivity : AppCompatActivity(),
StarSignListener {
...
override fun onSelected(id: Int) {
    }
}</pre></li>
				<li>Now if you run the app, you will see the star sign list being displayed on mobile and tablet.</li>
			</ol>
			<p>The problem you now come to is how to pass the star sign ID to <code>DetailFragment</code> now that it’s not in an XML layout.</p>
			<p>One option would be to use the same technique as in the last example by creating a new activity and passing the star sign ID in an intent, but you shouldn’t have to create a new activity to add a new fragment; otherwise, you might as well dispense with fragments and just use activities.</p>
			<p>You are going to replace <code>ListFragment</code> in <code>FragmentContainerView</code> with <code>DetailFragment</code>, but first, you need to find a way to pass the star sign ID into <code>DetailFragment</code>. You do this by passing this <code>id</code> value as an argument when you create the fragment. The standard way to do this is by using a <code>Factory</code> method in a fragment.</p>
			<ol>
				<li value="9">Add the following code to the bottom of <code>DetailFragment</code> (a sample <code>factory</code> method will have been added when you created the fragment using the template/wizard, which you can update here):<pre class="source code">
companion object {
    private const val STAR_SIGN_ID = "STAR_SIGN_ID"
    fun newInstance(starSignId: Int) =
    DetailFragment().apply {
        arguments = Bundle().apply {
            putInt(STAR_SIGN_ID, starSignId)
        }
    }
}</pre></li>
			</ol>
			<p>A <code>companion</code> object<a id="_idIndexMarker299"/> allows you to add Java’s equivalent of static members into your class. Here, you are instantiating a new <code>DetailFragment</code> and setting arguments passed into the fragment. The arguments of the fragment are stored in a <code>Bundle()</code>, so in the same way as an activity’s intent extras (which is also a bundle), you add the values as key pairs. In this case, you are adding the <code>STAR_SIGN_ID</code> key with the value <code>starSignId</code>.</p>
			<ol>
				<li value="10">The next thing to do is override one of the <code>DetailFragment</code> lifecycle functions to use the passed-in argument:<pre class="source code">
override fun onViewCreated(view: View,
savedInstanceState: Bundle?) {
    val starSignId = arguments?.getInt(STAR_SIGN_ID,
        0) ?: 0
    setStarSignData(starSignId)
}</pre></li>
				<li>You do this in <code>onViewCreated</code> as at this stage, the layout of the fragment has been set up and you can access the view hierarchy (whereas if you accessed the arguments in <code>onCreate</code>, the fragment layout would not be available as this is done in <code>onCreateView</code>):<pre class="source code">
val starSignId = arguments?.getInt(STAR_SIGN_ID, 0) ?: 0</pre></li>
				<li>This line gets the star sign ID from the passed-in fragment arguments, setting a default of <code>0</code> if the <code>STAR_SIGN_ID</code> key cannot be found. Then, you call <code>setStarSignData(starSignId)</code> to display the star sign contents.</li>
				<li>Now you just need to<a id="_idIndexMarker300"/> implement the <code>StarSignListener</code> interface in <code>MainActivity</code> to retrieve the star sign ID from <code>ListFragment</code>:<pre class="source code">
class MainActivity : AppCompatActivity(),
StarSignListener {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (savedInstanceState == null) {
            findViewById&lt;FragmentContainerView&gt;(
            R.id.fragment_container)?.let {
            frameLayout -&gt;
              val listFragment = ListFragment()
             supportFragmentManager.beginTransaction()
                 .add(frameLayout.id,
                 listFragment).commit()
            }
        }
    }
    override fun onSelected(starSignId: Int) {
        findViewById&lt;FragmentContainerView&gt;(
        R.id.fragment_container)?.let { frameLayout -&gt;
            val detailFragment =
                DetailFragment.newInstance(starSignId)
            supportFragmentManager.beginTransaction()
                .replace(frameLayout.id,
                detailFragment)
                .addToBackStack(null)
                .commit()
        }
    }
}</pre></li>
			</ol>
			<p>You create<a id="_idIndexMarker301"/> <code>DetailFragment</code> as explained earlier with the <code>factory</code> method passing in the star sign ID: <code>DetailFragment.newInstance(starSignId)</code>.</p>
			<p>At this stage, <code>ListFragment</code> is still the fragment that has been added to the activity <code>FrameLayout</code>. You need to replace it with <code>DetailFragment</code>, which requires another transaction. This time, however, you use the <code>replace</code> function to replace <code>ListFragment</code> with <code>DetailFragment</code>.</p>
			<p>Before you commit the transaction, you call <code>.addToBackStack(null)</code> so the app does not exit when the back button is pressed but instead goes back to <code>ListFragment</code> by popping <code>DetailFragment</code> off the fragment stack.</p>
			<p>This exercise has introduced adding fragments dynamically to your activity. The next <a id="_idTextAnchor245"/><a id="_idTextAnchor246"/>topic introduces a<a id="_idIndexMarker302"/> more well-defined structure for creating fragments, called a navigation graph.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor247"/>Jetpack Navigation</h1>
			<p>Using dynamic and<a id="_idIndexMarker303"/> static fragments, although very flexible, introduces a lot of boilerplate code into your app and can become quite complicated when user journeys require adding, removing, and replacing multiple fragments while managing the back stack.</p>
			<p>Google introduced Jetpack components, as you learned in <a href="B19411_01.xhtml#_idTextAnchor025"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First App</em>, to use established best practices in your code. The <code>Navigation</code> component within the suite of Jetpack components enables you to reduce boilerplate co<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/>de and simplify navigation within your app. We are going to use it now to update the Star Sign app.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor250"/>Exercise 3.05 – adding a Jetpack navigation graph</h2>
			<p>In this exercise, we <a id="_idIndexMarker304"/>are going to reuse most of the classes and resources from the last exercise. We will first create an empty project and copy the resources. Next, we will add the dependencies and create a navigation graph.</p>
			<p>Using a step-by-step approach, we will configure the navigation graph and add destinations to navigate between fragments. Perform the following steps:</p>
			<ol>
				<li>Create a new project with an <code>Empty Activity</code> called <code>Jetpack Fragments</code>.</li>
				<li>Copy <code>strings.xml</code>, <code>fragment_detail.xml</code>, <code>fragment_list.xml</code>, <code>DetailFragment</code>, and <code>ListFragment</code> from the previous exercise, remembering to change the <code>app_name</code> string in <code>strings.xml</code> and the package name for the fragment classes. You will need to change the following line for the resources from <code>import com.example.dynamicfragments.R</code> to <code>import com.example.jetpacknavigation.R</code>.</li>
				<li>Finally, add the styles defined below the base application style in <code>themes.xml</code> from the last exercise to <code>themes.xml</code> in this project. You will also need to add the following above the class header in <code>MainActivity</code>:<pre class="source code">
const val STAR_SIGN_ID = "STAR_SIGN_ID"
interface StarSignListener {
    fun onSelected(id: Int)
}</pre></li>
				<li>Once you have<a id="_idIndexMarker305"/> done that, add the following dependencies – you need to use the <code>Navigation</code> component in <code>app/build.gradle</code> within the <code>dependences{ }</code> block:<pre class="source code">
implementation 
"androidx.navigation:navigation-fragment-ktx:2.5.3"
implementation 
"androidx.navigation:navigation-ui-ktx:2.5.3"</pre></li>
				<li>It will prompt you to <code>app</code> module is selected and go to <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Android Resource</strong>.</li>
				<li>Once this dialog appears, change <code>nav_graph</code>:</li>
			</ol>
			<div><div><img src="img/B19411_03_19.jpg" alt="Figure 3.18 – New Resource File dialog"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – New Resource File dialog</p>
			<p>Click <code>res</code> folder called <code>Navigation</code> with <code>nav_graph.xml</code> inside it.</p>
			<ol>
				<li value="7">Update the <code>nav_graph.xml</code> navigation file with the following code:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;navigation
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/nav_graph"
    app:startDestination="@id/starSignList"&gt;
    &lt;fragment
        android:id="@+id/starSignList"
        android:name="com.example.jetpackfragments
            .ListFragment"
        android:label="List"
        tools:layout="@layout/fragment_list"&gt;
        &lt;action
            android:id="@+id/star_sign_id_action"
            app:destination="@id/starSign"&gt;
        &lt;/action&gt;
    &lt;/fragment&gt;
    &lt;fragment
        android:id="@+id/starSign"
        android:name="com.example.jetpackfragments
            .DetailFragment"
        android:label="Detail"
        tools:layout="@layout/fragment_detail" /&gt;
&lt;/navigation&gt;</pre></li>
			</ol>
			<p>The preceding <a id="_idIndexMarker307"/>file is a working navigation graph. Although the syntax is unfamiliar, it is quite straightforward to understand:</p>
			<ol>
				<li><code>ListFragment</code> and <code>DetailFragment</code> are present as they would be if you were adding static fragments.</li>
				<li>There is an <code>id</code> value to identify the graph at the root <code>&lt;navigation&gt;</code> element and IDs on the fragments themselves. Navigation graphs introduce the concept of destinations, so at the root <code>navigation</code> level, there is <code>app:startDestination</code>, which has the ID of <code>starSignList</code>, which is <code>ListFragment</code>, then within the <code>&lt;fragment&gt;</code> tag, there is the <code>&lt;</code><code>action&gt;</code> element.</li>
				<li>Actions are what link the destinations within the navigation graph together. The destination action here has an ID, so you can refer to it in code, and has a destination, which, when used, it will direct to.</li>
			</ol>
			<p>Now that you’ve added the navigation graph, you need to use it to link the activity and fragments together.</p>
			<ol>
				<li value="8">Open up <code>activity_main.xml</code> and replace <code>TextView</code> inside <code>ConstraintLayout</code> with <a id="_idIndexMarker308"/>the following <code>FragmentContainerView</code>:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.fragment.app.FragmentContainerView
xmlns:android=
  "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/nav_host_fragment"
    android:name="androidx.navigation.fragment
        .NavHostFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:defaultNavHost="true"
    app:navGraph="@navigation/nav_graph" /&gt;</pre></li>
			</ol>
			<p><code>FragmentContainerView</code> has been added with the name <code>android:name="androidx.navigation.fragment.NavHostFragment"</code>. It will host the fragments from the <code>app:navGraph="@navigation/nav_graph"</code> that you have just created.</p>
			<p><code>app:defaultNavHost</code> states that it is the app’s default navigation graph. It also controls the back navigation when one fragment replaces another. You can have more than one <code>NavHostFragment</code> in a layout for controlling two or more areas of the screen that manage their own fragments, which you might use for dual-pane layouts in tablets, but there can only be one default.</p>
			<p>There are a few changes you need to make to make the app work as expected in the <code>ListFragment</code>.</p>
			<ol>
				<li value="9">Firstly, remove the <a id="_idIndexMarker309"/>class file header and references to <code>StarSignListener</code>. So, the following will be replaced:<pre class="source code">
interface StarSignListener {
    fun onSelected(starSignId: Int)
}
class ListFragment : Fragment(), View.OnClickListener
{
    private lateinit var starSignListener:
        StarSignListener
    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is StarSignListener) {
            starSignListener = context
        } else {
            throw RuntimeException("Must implement
            StarSignListener")
        }
    }</pre></li>
			</ol>
			<p>And it will be replaced with the following line of code:</p>
			<pre class="source code">
class ListFragment : Fragment() {</pre>
			<ol>
				<li value="10">Next, at the bottom of the class, remove the <code>onClick</code> overridden method as you are not implementing <code>View.OnClicklistener</code>:<pre class="source code">
override fun onClick(v: View?) {
    v?.let { starSign -&gt;
        starSignListener.onSelected(starSign.id)
    }
}</pre></li>
				<li>In the <code>onViewCreated</code> method, replace <a id="_idIndexMarker310"/>the <code>forEach</code> statement that loops over the star sign views:<pre class="source code">
starSigns.forEach {
    it.setOnClickListener(this)
}</pre></li>
			</ol>
			<p>Replace it with the following code and add the <code>Navigation</code> import to the imports list:</p>
			<pre class="source code">
import androidx.navigation.Navigation
starSigns.forEach { starSign -&gt;
    val fragmentBundle = Bundle()
    fragmentBundle.putInt(STAR_SIGN_ID, starSign.id)
    starSign.setOnClickListener(
        Navigation.createNavigateOnClickListener(
            R.id.star_sign_id_action, fragmentBundle)
    )
}</pre>
			<p>Here, you are creating a bundle to pass <code>STAR_SIGN_ID</code> with the view ID of the selected star sign to <code>NavigationClickListener</code>. It uses the ID of the <code>R.id.star_sign_id_action</code> action to load <code>DetailFragment</code> when clicked as that is the destination for the action. <code>DetailFragment</code> does not need any changes and uses the passed-in <code>fragment</code> argument to load the details of the selected star sign ID.</p>
			<ol>
				<li value="12">Run up the app, and you’ll see that the app behaves as it did before.</li>
			</ol>
			<p>Now you’ve been able to remove a significant amount of boilerplate code and document the navigation within the app in the navigation graph. In addition, you have offloaded more of the management of the fragment lifecycle to the Android framework, saving more time to work on features.</p>
			<p>Jetpack Navigation is a powerful <code>androidx</code> component and enables you to map your whole app and the relationships between fragments, activities, and so on. You can also use it selectively to <a id="_idIndexMarker311"/>manage different areas of your app that have a defined user flow, such as the startup of your app and guiding the user through a series of welcome screens, or some wizard layout user journey, for example.</p>
			<p>Wi<a id="_idTextAnchor251"/><a id="_idTextAnchor252"/>th this knowledge, let’s try completing an activity using the techniques learned from all these exercises.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor253"/>Activity 3.01 – creating a quiz on the planets</h2>
			<p>For this <a id="_idIndexMarker312"/>activity, you will create a quiz where users have to answer one of three questions on the planets of the Solar System. The number of fragments you choose to use is up to you. However, considering this chapter’s content, which is separating the UI and logic into separate fragment components, it is likely you will use two fragments or more to achieve this.</p>
			<p>The screenshots that follow show one way this could be done, but there are multiple ways to create this app. You can use one of the approaches detailed in this chapter, such as static fragments, dynamic fragments, or the Jetpack <code>Navigation</code> component, or something custom that uses a combination of these and other approaches.</p>
			<p>The content of the quiz is as follows. In the UI, you need to ask the user these three questions:</p>
			<ul>
				<li>What is the largest planet?</li>
				<li>Which planet has the most moons?</li>
				<li>Which planet spins on its side?</li>
			</ul>
			<p>Then, you need to provide a list of planets so the user can choose the planet that they believe is the answer<a id="_idIndexMarker313"/> to the question:</p>
			<ul>
				<li><code>MERCURY</code></li>
				<li><code>VENUS</code></li>
				<li><code>EARTH</code></li>
				<li><code>MARS</code></li>
				<li><code>JUPITER</code></li>
				<li><code>SATURN</code></li>
				<li><code>URANUS</code></li>
				<li><code>NEPTUNE</code></li>
			</ul>
			<p>Once they have given their answer, you need to show them whether they are correct or wrong. The correct answer should be accompanied by some text that gives more detail about the question’s answer:</p>
			<pre class="source code">
Jupiter is the largest planet and is 2.5 times the mass of all 
the other planets put together.
Saturn has the most moons and has 82 moons.
Uranus spins on its side with its axis at nearly a right angle to the Sun.</pre>
			<p>The following are some scree<a id="_idTextAnchor254"/>nshots of how the UI might look to achieve the requirements of the ap<a id="_idTextAnchor255"/>p you need <a id="_idIndexMarker314"/>to build:</p>
			<p><strong class="bold">Questions screen</strong>:</p>
			<div><div><img src="img/B19411_03_20.jpg" alt="Figure 3.19 – Planet Quiz questi﻿ons screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – Planet Quiz questi<a id="_idTextAnchor256"/>ons screen</p>
			<p><strong class="bold">Answer </strong><strong class="bold">options screen</strong>:</p>
			<div><div><img src="img/B19411_03_21.jpg" alt="Figure 3.20 – Planet Quiz multiple-choice answer screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – Planet Quiz multiple-choice answer screen</p>
			<p><strong class="bold">Answer screen</strong>:</p>
			<div><div><img src="img/B19411_03_22.jpg" alt="Figure 3.21 – Planet Quiz answer screen with detailed answer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – Planet Quiz answer screen with detailed answer</p>
			<p>The following<a id="_idIndexMarker315"/> steps will help to complete the activity:</p>
			<ol>
				<li>Create an Android project with an <code>Empty Activity</code>.</li>
				<li>Update the <code>strings.xml</code> file with the entries you need for the project.</li>
				<li>Amend the <code>themes.xml</code> file with styles for the project.</li>
				<li>Create a <code>QuestionsFragment</code>, update the layout with the questions, and add interaction with buttons and <code>OnClickListener</code>(s).</li>
				<li>Optionally, create a multiple-choice fragment and add answer options and button-click handling (this can also be done by adding the possible answer options to <code>QuestionsFragment</code>).</li>
				<li>Create an <code>AnswersFragment</code> that displays the relevant question’s answer and also displays more details about the answer itself.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor257"/>Summary</h1>
			<p>This chapter has covered fragments in depth, starting with learning about the fragment lifecycle and the key functions to override in your own fragments. We then moved on to adding simple fragments statically to an app in XML and demonstrating how the UI display and logic can be self-contained in individual fragments. Other options for how to add fragments to an app using a <code>FragmentContainerView</code> and dynamically adding and replacing fragments were then covered. We then f<a id="_idTextAnchor258"/>inished with how this can be simplified by using the Jetpack <code>Navigation</code> component.</p>
			<p>Fragments are one of the fundamental building blocks of Android development. The concepts you have learned about here will allow you to build upon them and progress to create increasingly more advanced apps. Fragments are at the core of building effective navigation into your apps in order to bind features and functionality that are simple and easy to use.</p>
			<p>The next chapter will explore this area in detail by using established UI patterns to build clear and consistent navigation and illustrate how fragments are used to enable this.</p>
		</div>
	</body></html>