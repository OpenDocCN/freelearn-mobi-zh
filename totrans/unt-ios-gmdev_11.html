<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Debugging and Optimization</h1></div></div></div><div><blockquote class="blockquote"><p>Now that we have a nearly completed project it's time to start working on getting as much performance out of the system as possible. While we would normally address performance throughout the development process, I felt it was important to look at the project further along, so that we could see how to reengineer the product based on some questionable decisions we might have made earlier in the project. By doing it this way it will be possible to see these decisions within the context of how we might normally build an application.</p></blockquote></div><p>In this chapter we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about debugging options in Unity</li><li class="listitem" style="list-style-type: disc">Learn how to profile a mobile application</li><li class="listitem" style="list-style-type: disc">Learn about object pooling and why it's crucial on mobile devices</li><li class="listitem" style="list-style-type: disc">Learn how to optimize lighting with Beast Lighting</li></ul></div><p>This chapter is where we will highlight some of the key differences between making a game for Unity and making one for Unity on a mobile device. This chapter will make the biggest difference between our application being a hit and it just bring a pretty showpiece that people uninstall a few hours after launching it.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec01"/>Debugging</h1></div></div></div><p>Unity possesses a debugger that is a first-class citizen with the rest of the Unity platform. The debugger will allow you to put breakpoints directly in your Unity scripts, and while the game is running on the target device, allow you to pause the game's execution to enable observation or tweaking of variables. This is a very powerful approach that is often times missing when developing for a device. In the past, the best one could do is emit sounds or change screen colors when certain conditions were met. Today you can watch the values of variables change, make modifications to scripts that are executing on the device, and change the flow of execution of the game dynamically without much impact to the game's frame rate. So let's take a look at how we make this magic happen.<a id="id481" class="indexterm"/>
</p><p>Debugging a running application on real hardware is something that you need to be very comfortable with. While Unity can do an admirable job of helping you simulate your content on your Mac, there is nothing that beats knowing how your application will perform in the wild.<a id="id482" class="indexterm"/>
</p><p>A breakpoint is a place in your game where you want to pause the execution of the application for debugging purposes. As the Unity scripting environment, MonoDevelop, is integrated with the Unity IDE, and consequently the runtime, we can insert breakpoints in our scripts, which will trigger the pause in execution.<a id="id483" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec02"/>Time for action —  Using breakpoints</h1></div></div></div><div><ol class="orderedlist"><li class="listitem">Position the carat on the line that you want to pause execution on and use the hotkey combination<strong> Apple-\</strong> to create the breakpoint. For many keyboard-centric developers this is the preferred way of doing things.<a id="id484" class="indexterm"/><div><img src="img/0409_11_01.jpg" alt="Time for action — Using breakpoints"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The other method is to click on the spine area to the left of the code and line numbers. If you are more a mouse-centric developer, you will find this to be the more natural way for setting breakpoints.<a id="id485" class="indexterm"/></li></ul></div><div><img src="img/0409_11_02.jpg" alt="Time for action — Using breakpoints"/></div></li><li class="listitem">Observe that the line that you created the breakpoint on is highlighted with a red circle in the spine next to the code. This represents an active breakpoint.<a id="id486" class="indexterm"/><p>To deactivate a breakpoint, simply click on the red circle or press <strong>Apple-\</strong> again and the breakpoint will be removed.
</p><p>It should be noted that if you create a breakpoint on a line that contains no actual code, the break point would actually execute on the next line of executable code.
</p></li><li class="listitem">Run the application.</li></ol></div><div><img src="img/0409_11_03.jpg" alt="Time for action — Using breakpoints"/></div><p>We can now observe that the application stops on the line where the breakpoint was located. This gives us an opportunity to observe the state of the application at the time when the breakpoint is reached. Many times it is useful to put a breakpoint inside of some control structure, such as an<code class="literal"> if</code> statement, to see if the conditions which should trigger it are ever met.<a id="id487" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec01"/>What just happened?</h2></div></div></div><p>You have just created a breakpoint within your application and had your app stop on the line specified. When the application is in this state it is paused so that you can examine and/or change the state of any variables of the application.<a id="id488" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec03"/>Time for action —  Debugging the application</h1></div></div></div><p>The process of getting the debugger to communicate with the running application and provide data to the user is known as attaching the debugger to the process.<a id="id489" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Deploy and run your game on your iOS device. Make sure that the device is on the same WiFi network as the machine that will be doing the debugging and then select the iOS device that you want to attach to.</li><li class="listitem">Select the<strong> Debug</strong> button in the toolbar:<a id="id490" class="indexterm"/><div><img src="img/0409_11_04.jpg" alt="Time for action — Debugging the application"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">MonoDevelop will then launch the Unity editor and after some time start the execution of your application. Your application will begin running in the player and stop when the first breakpoint in your code is encountered:</li></ul></div><div><img src="img/0409_11_05.jpg" alt="Time for action — Debugging the application"/></div></li><li class="listitem">Select the game that you want the Unity debugger to attach itself to. In this image we see the Unity Editor as one process we can attach to and another referred to as "null (mono)." This is your game running on your iOS device. Select this instance of your game.<a id="id491" class="indexterm"/></li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec02"/>What just happened?</h2></div></div></div><p>We have just attached our debugger to an instance of our game that is running on our iOS device. This is very useful as we can get real debugging information from our actual device. When testing an application it is important to do this, as there will be times when an application will run fine within Unity on the PC, yet fail on an actual device.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec04"/>Time for action —  Stepping through the game</h1></div></div></div><p>Once you have reached a breakpoint and examined variable values at that point, the next thing you will want to do is step forward in the application so you can watch the application change over time. There are several options available to you for stepping forward through the application depending on what your intentions are. The following screenshot shows these options:<strong> Step Over, Step Into, Step Out, Pause</strong>, and<strong> Detach Debugger:</strong>
<a id="id492" class="indexterm"/>
</p><div><img src="img/0409_11_06.jpg" alt="Time for action — Stepping through the game"/></div><div><ol class="orderedlist"><li class="listitem">Press the Step into icon so that the application will start.</li><li class="listitem">As you can see below, the application is paused at the breakpoint. The current line of execution is highlighted in yellow:<div><img src="img/0409_11_07.jpg" alt="Time for action — Stepping through the game"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">As mentioned earlier, when the debugger is attached, you can get the value of any variable in your game. However, it would be cumbersome to have to constantly look for each individual variable, especially if there is a variable that we want to examine over time. You can accomplish this by setting up a watch for a variable of interest and observe its value as it changes.<a id="id493" class="indexterm"/></li></ul></div></li><li class="listitem">Create a new watch by selecting the<strong> Watch</strong> tab in MonoDevelop. Enter the word<strong> Screen</strong> into the<strong> Watch</strong> tab to have MonoDevelop open an autocomplete dialog showing all of the attributes of the<strong> Screen</strong> object:<div><img src="img/0409_11_08.jpg" alt="Time for action — Stepping through the game"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">We can see here that <strong>Screen</strong> has a <strong>currentResolution</strong> attribute attached to it.<a id="id494" class="indexterm"/></li></ul></div></li><li class="listitem">Select<strong> currentResolution</strong> so that a watch is created for this variable. If the variable you've selected is an object, you will see a triangle to the left of it. Clicking on this triangle will display any attributes of the object as shown in the following screenshot:</li></ol></div><div><img src="img/0409_11_09.jpg" alt="Time for action — Stepping through the game"/></div><p>Here we are able to see all of the attributes of the<strong> Screen.currentResolution</strong> object.<a id="id495" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec03"/>What just happened?</h2></div></div></div><p>We have just stepped through our application using the attached debugger and added a watch so that we can observe a variable as it changes over time. Adding watches is a common way to examine variables as they change during the execution of the game. As you begin writing complex scripts, creating watches will help you determine whether or not the correct behaviors are happening at runtime.<a id="id496" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec05"/>Profiling</h1></div></div></div><p>We've been going along building our game and running it for sometime and it appears to be performing okay, but to really determine how our game is performing, we are going to have to profile. Profiling is the act of gathering information about how each part of our game is performing so that we can optimize the code or assets that are causing performance bottlenecks.<a id="id497" class="indexterm"/>
</p><p>We could make some assumptions about how the game is running and start blindly optimizing code because it should be faster to do it a certain way, but in reality, the biggest performance wins won't be obvious until you see what the profiler is telling you about the game. To successfully profile an application one has to really look at the data objectively as poor performance could result from texture sizes, shaders, scripts, physics, draw calls, or even something as simple as adding fog.</p><p>So let's go through our current application and walk through the process of profiling it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec06"/>Time for action —  Fine tuning the application (Pro Versions)</h1></div></div></div><p>Now we're going to take our application and tune it so that it performs well, and has consistent behavior, regardless of where we are in the environment.<a id="id498" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Start the Profiler by selecting it from the<strong> Window</strong> menu <strong> (Window | Profiler):</strong><div><img src="img/0409_11_10.jpg" alt="Time for action — Fine tuning the application (Pro Versions)"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The profiler will start and display the profiling interface for Unity. If you are familiar with the XCode tool Instruments you will find many of the same design and interface concepts in the Unity profiler:<a id="id499" class="indexterm"/></li></ul></div><div><img src="img/0409_11_11.jpg" alt="Time for action — Fine tuning the application (Pro Versions)"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The <strong>Profiler</strong> will display metrics across a range of different settings: <strong>CPU Usage, Rendering, Memory, Audio</strong>, and <strong>Physics</strong>. You can remove profilers by clicking on the X in the upper-left corner of the <strong>Profiler.
</strong><a id="id500" class="indexterm"/></li></ul></div></li><li class="listitem">Remove the<strong> Audio</strong> profiler by clicking on the X in the upper-left corner of the<strong> Profiler:</strong><div><img src="img/0409_11_12.jpg" alt="Time for action — Fine tuning the application (Pro Versions)"/></div></li><li class="listitem">Add the<strong> Audio</strong> profiler back by clicking on the<strong> Add Profiler</strong> drop-down and selecting the<strong> Audio</strong> profiler:<a id="id501" class="indexterm"/><div><img src="img/0409_11_13.jpg" alt="Time for action — Fine tuning the application (Pro Versions)"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The profilers that are already added will be greyed out. In this example both <strong>Audio</strong> and <strong>Physics</strong> can be added to the <strong>Profiler.
</strong></li></ul></div></li><li class="listitem">Start the game by pressing the<strong> Play</strong> button. Immediately you will see the profiler fill with data from the profiling session:</li></ol></div><div><img src="img/0409_11_14.jpg" alt="Time for action — Fine tuning the application (Pro Versions)"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec04"/>What just happened?</h2></div></div></div><p>We have used the build in Unity profiler to examine the performance of our application and explore the different metrics that it is returning so that we can gain some insight to the bottlenecks in our application. Now that we've done this we can identify some hot spots and look at a few ways to fix the issues that we uncover.<a id="id502" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec07"/>Object pooling — Into the pool</h1></div></div></div><p>As we have learned from our profiling session, one of the largest performance detriments on the mobile platforms is the constant creation and destruction of GameObjects. As you probably noticed earlier when we were testing out firing our weapons, there were noticeable pauses in the game every so often. Let's examine why this happens.<a id="id503" class="indexterm"/>
</p><p>When an instance of the class<code class="literal"> GameObject</code> is created in Unity on a mobile device, the device must allocate memory for this new instance of<code class="literal"> GameObject</code> and potentially clear out memory that is used by some other object that may not be visible. This process, known as garbage collection, takes just enough time that it causes the pauses that you experience in the game. The reason this happens is due to the limited amount of memory available on the target devices and the time it takes to collect the old object. Java developers, particularly those that were brave enough to write games for the platform, are very familiar with the issues associated with garbage collection.</p><p>Typically, one will resolve some of the issues associated with garbage collection through the use of an object pool. An object pool allows one to allocate a number of objects up front and cycle through them such that new objects are never created. In the case of our weapon example we would allocate a number of objects in our game object pool that represent the max number of projectiles we want to be able to display at one time. As projectiles reach a certain distance from the player, we can remove them and free up a new object in the object pool for objects that are going to be visible next.</p><p>This particular implementation of an object pool was created by the Unity3D forum member and has an extension for particle systems as well as audio.</p><div><pre class="programlisting">using UnityEngine;
using System;
using System.Collections;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
public class ObjectPool : MonoBehaviour
{
public static ObjectPool instance;
/// &lt;summary&gt;
/// The object prefabs which the pool can handle.
/// &lt;/summary&gt;
public GameObject[] objectPrefabs;
/// &lt;summary&gt;
/// The pooled objects currently available.
/// &lt;/summary&gt;
public List&lt;GameObject&gt;[] pooledObjects;
/// &lt;summary&gt;
/// The amount of objects of each type to buffer.
/// &lt;/summary&gt;
public int[] amountToBuffer;
public int defaultBufferAmount = 3;
/// &lt;summary&gt;
/// The container object that we will keep unused pooled objects /// so we dont clog up the editor with objects.
/// &lt;/summary&gt;
protected GameObject containerObject;
void Awake ()
profilingobject pooling{
instance = this;
}
// Use this for initialization
void Start ()
{
containerObject = new GameObject("ObjectPool");
//Loop through the object prefabs and make a new list for //each one.
//We do this because the pool can only support prefabs set to it //in the editor,
//so we can assume the lists of pooled objects are in the same //order as object prefabs in the array
pooledObjects = new List&lt;GameObject&gt;[objectPrefabs.Length];
int i = 0;
foreach ( GameObject objectPrefab in objectPrefabs )
{
pooledObjects[i] = new List&lt;GameObject&gt;();
int bufferAmount;
if(i &lt; amountToBuffer.Length) bufferAmount = amountToBuffer[i];
else
bufferAmount = defaultBufferAmount;
for ( int n=0; n&lt;bufferAmount; n++)
{
GameObject newObj = Instantiate(objectPrefab) as GameObject;
newObj.name = objectPrefab.name;
PoolObject(newObj);
}
i++;
}
}
/// &lt;summary&gt;
profilingobject pooling/// Gets a new object for the name type provided. If no object type /// exists or if onlypooled is true and there is no objects of that /// type in the pool
/// then null will be returned.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// The object for type.
/// &lt;/returns&gt;
/// &lt;param name='objectType'&gt;
/// Object type.
/// &lt;/param&gt;
/// &lt;param name='onlyPooled'&gt;
/// If true, it will only return an object if there is one currently /// pooled.
/// &lt;/param&gt;
public GameObject GetObjectForType ( string objectType , bool onlyPooled )
{
for(int i=0; i&lt;objectPrefabs.Length; i++)
{
GameObject prefab = objectPrefabs[i];
if(prefab.name == objectType)
{
if(pooledObjects[i].Count &gt; 0)
{
GameObject pooledObject = pooledObjects[i][0];
pooledObjects[i].RemoveAt(0);
pooledObject.transform.parent = null;
pooledObject.SetActiveRecursively(true);
return pooledObject;
}
else if(!onlyPooled) {
return Instantiate(objectPrefabs[i]) as GameObject;
}
break;
}
}
//If we have gotten here either there was no object of the specified //type or none were left in the pool with onlyPooled set to true
return null;
profilingobject pooling}
/// &lt;summary&gt;
/// Pools the object specified. Will not be pooled if there are no /// prefab of that type.
/// &lt;/summary&gt;
/// &lt;param name='obj'&gt;
/// Object to be pooled.
/// &lt;/param&gt;
public void PoolObject ( GameObject obj )
{
for ( int i=0; i&lt;objectPrefabs.Length; i++)
{
if(objectPrefabs[i].name == obj.name)
{
obj.SetActiveRecursively(false);
obj.transform.parent = containerObject.transform;
pooledObjects[i].Add(obj);
return;
}
}
}
}
</pre></div><p>The<code class="literal"> ObjectPool</code> code is very straight-forward. It exposes several public variables so that you can configure it from the Unity IDE itself. The<code class="literal"> ObjectPool</code> implemented here is designed to pool a variety of classes of objects at once. You don't need an implementation for each type of<code class="literal"> GameObject</code> you want to pool. The<strong> ObjectPool</strong> stores each of the object types you want to pool in the<code class="literal"> ObjectPrefabs</code> array.<a id="id507" class="indexterm"/>
</p><div><img src="img/0409_11_15.jpg" alt="Object pooling — Into the pool"/></div><p>By default the pool will create a maximum of three objects of each type. If you want to configure the amount of objects that an individual object can have, expand the<strong> Amount To Buffer</strong> element and set that size.<a id="id508" class="indexterm"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec08"/>Time for action —  Optimizing with the object pool</h1></div></div></div><p>Now that we have a game object pool and the ability to profile our application we can look at how this optimization improves our application's performance. We will do this by replacing the<code class="literal"> GameObject</code> instantiation approach that we took to creating projectiles when the player fires his weapon.<a id="id509" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">Connect the game to the profiler following the previous<em> Time for action — </em> and run it, firing a large number of projectiles:<div><img src="img/0409_11_16.jpg" alt="Time for action — Optimizing with the object pool"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">What we can see from this object profile is that performance dips considerably when the weapon is fired. The reason for this is because we are creating GameObjects on the fly. We can see here that when these objects are removed from view and collected, the performance of the application becomes more consistent. Things like this are a smoking gun and we have an optimization that can be made to improve performance of the game.<a id="id510" class="indexterm"/></li></ul></div></li><li class="listitem">Create a<strong> GameObject</strong> called<strong> PoolManager:</strong><div><img src="img/0409_11_17.jpg" alt="Time for action — Optimizing with the object pool"/></div></li><li class="listitem">Add the<strong> ObjectPool</strong> script to the<strong> PoolManager:</strong><a id="id511" class="indexterm"/><div><img src="img/0409_11_18.jpg" alt="Time for action — Optimizing with the object pool"/></div></li><li class="listitem">Add the prefabs that you want to pool to the<strong> Object Prefabs</strong> array. You can accomplish this by dragging a prefab from the<strong> Hierarchy</strong> view onto the<strong> Object Prefabs</strong> array:<div><img src="img/0409_11_19.jpg" alt="Time for action — Optimizing with the object pool"/></div></li><li class="listitem">Replace the existing<code class="literal"> fireWeapon</code> script with the optimized<code class="literal"> fireWeapon</code> script that uses the<strong> Object Pool:</strong><a id="id512" class="indexterm"/><div><pre class="programlisting">void fireWeapon()
{
GameObject bullet = ObjectPool.instance.GetObjectForType( "Bullet" , true);
bullet.transform.position = spawnPoint.transform.position;
bullet.transform.rotation = spawnPoint.transform.rotation;
}
</pre></div><p>What we have done here is replace the <code class="literal">GameObject.Instantiate()
</code> method that we were originally using for creating new bullets from our weapon.
<a id="id513" class="indexterm"/>
</p></li><li class="listitem">Start the game again and look at the<strong> Profiler</strong> profile. Fire a lot of projectiles and examine the performance.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec05"/>What just happened?</h2></div></div></div><p>We have just improved the performance of our application using object pooling. As you can see, the performance of the application is consistent now. This is what we are aiming for a consistent frame rate.<a id="id514" class="indexterm"/>
</p><p>Instead of paying the penalty for creating and deleting large numbers of<code class="literal"> GameObject</code> instances, we are instead creating a pool of those objects and simply changing their position, rotation, state, and visibility. This is an old trick that was frequently employed in gaming that was lost in the age of modern computers and graphics capabilities, but is just what we need on mobile devices to ensure optimal performance.<a id="id515" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec09"/>Unleash the beast</h1></div></div></div><p>So often when you're trying to improve the performance of your application you will have to make trade-offs between the visual presentation of your application and its performance. This time we will perform optimizations that will enhance both the performance and visual quality of our application is by using the integrated Beast lightmapping system from Illuminate Labs.</p><p>The goal of lighting in our game is to provide a realistic depiction of our world. Normally the objects in the world would have some base material or texture that describes their natural surface. The lighting algorithms used by the engine would then compute the effects of the lights on the pixels or texels of the object's surface when it is rendered.<a id="id516" class="indexterm"/>
</p><p>Lightmapping, as its name implies, is the process of utilizing lighting data (emissive properties, real lights, and so on) and casting rays from these lights as if they were active in the scene. The engine will then take the actual effect of these lights and store it in texture maps that will be mapped onto textures at run time (Unity refers to this process as baking the lights). As a result you can have a very complex lighting environment based upon a computationally intensive number of lights. You can also have all of this information baked into the texture maps of the scene, resulting in increased visual quality without the expense of having lights within your scene.<a id="id517" class="indexterm"/>
</p><p>As lighting is one of the more expensive operations you can perform on mobile devices, using lightmaps represents a major performance win. While lightmapping will eventually be replaced with per pixel lighting in shaders, today's mobile hardware isn't quite up to the task.</p><p>So let's look at how we can make this work for our application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec10"/>Time for action —  Generating Beast lightmaps</h1></div></div></div><p>To illustrate how lightmapping can improve our application we're going to take our City level scene and add Beast lightmapping to it.<a id="id518" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem">The first step in preparing our scene for lightmapping is to ensure that any object that we want to have lightmaps generated for is declared static. Unity uses this declaration to make assumptions that the object won't move, scale, or change in any way during the scene. Remember, we only want to bake lightmaps on static geometry, as we're generating lighting based on the location of lights in the scene at a given time. If we tried to use this approach on objects that moved, for example, you'd find that even though an object changes its orientation with respect to a light, the lighting and shadow calculations would look as if the object were in a different place:<a id="id519" class="indexterm"/><div><img src="img/0409_11_20.jpg" alt="Time for action — Generating Beast lightmaps"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Here we have specified that one of our birch tree prefabs is <strong>Static</strong>. Similarly we can add the same settings to the terrain.</li></ul></div></li><li class="listitem">Add a light to the scene using<strong> Game Object | Create Other | Point Light</strong>. Position this light in our scene. This is the light whose lighting effects we want to bake into our scene. Now that our objects are defined as being static, let's add a light to the scene that we want to bake to our objects:<a id="id520" class="indexterm"/><div><img src="img/0409_11_21.jpg" alt="Time for action — Generating Beast lightmaps"/></div></li><li class="listitem">Observe the scene to see what everything looks like when the lighting is rendering normally. This will give us an idea of what the lightmapped scene should look like if we perform the operation properly:<a id="id521" class="indexterm"/><div><img src="img/0409_11_22.jpg" alt="Time for action — Generating Beast lightmaps"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Now that we've provided some lighting data for the lightmapper to work with, we can start the baking process.<a id="id522" class="indexterm"/></li></ul></div></li><li class="listitem">In the<strong> Window</strong> menu select the<strong> Lightmapping</strong> option to bring up the Beast lightmapping interface:<a id="id523" class="indexterm"/><div><img src="img/0409_11_23.jpg" alt="Time for action — Generating Beast lightmaps"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This will open the Unity Lightmapping interface which allows us to configure the Beast lightmapping session:<a id="id524" class="indexterm"/></li></ul></div><div><img src="img/0409_11_24.jpg" alt="Time for action — Generating Beast lightmaps"/></div></li><li class="listitem">With the interface is open, select the<strong> Point light</strong> we added to the scene and click on the<strong> Bake</strong> tab:<a id="id525" class="indexterm"/><div><img src="img/0409_11_25.jpg" alt="Time for action — Generating Beast lightmaps"/></div></li><li class="listitem">We can take our simple light and have it baked into the lightmaps of the scene. Press the<strong> Bake</strong> button and observe the debug output window:<a id="id526" class="indexterm"/><div><img src="img/0409_11_26.jpg" alt="Time for action — Generating Beast lightmaps"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The output window is telling us that it is unable to bake the lights because there is no UV data for the geometry in our scene. Remember that our lightmaps are texture maps that are being added as a texture map and, as such, if the geometry does not have UVs generated properly it cannot generate the lightmaps.<a id="id527" class="indexterm"/></li></ul></div></li><li class="listitem">Select the geometry that Unity is reporting does not have UV data and select its<strong> FBXImporter</strong>. Click on the<strong> Generate Lightmap UVs</strong> button to ensure that Unity generates the UV information for this piece of geometry:<a id="id528" class="indexterm"/><div><img src="img/0409_11_27.jpg" alt="Time for action — Generating Beast lightmaps"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Now when you bake the scene, Unity will be able to generate a properly lightmapped scene.</li></ul></div></li><li class="listitem">Select the<strong> Point light</strong> in the<strong> Hierarchy</strong> view and delete it from the scene. When you run the game you will note that the game looks exactly the same as it did before but it is now running without the performance overhead of the lights in the scene.<a id="id529" class="indexterm"/></li></ol></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec06"/>What just happened?</h2></div></div></div><p>What Unity is doing behind the scenes is taking all of the assets and scripts from the Unity IDE and putting together a player that will be able to playback the content and all of its scenarios based on input from the user. This is a very important concept to understand as the content within the Unity IDE is largely platform agnostic and can be readily redeployed after a simple recompile within the Unity environment. This player is the the actual application that is deployed to the iOS device.<a id="id530" class="indexterm"/>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter we learned a little bit about the topic of debugging, profiling and optimizing Unity projects. We've really only just scratched the surface on the subject, however, as game optimization can fill a book in its own right and much of it is related to the design of a particular application.</p><p>Specifically, we covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to attach the Unity debugger to a running application</li><li class="listitem" style="list-style-type: disc">How to profile a Unity application</li><li class="listitem" style="list-style-type: disc">Using object pooling to improve mobile application performance</li><li class="listitem" style="list-style-type: disc">Using Beast lightmapping to improve performance and visual quality</li></ul></div><p>Now that we've profiled our application and worked specifically to improve its performance it's time to investigate monetization of our game and publish it on the AppStore.</p></div></body></html>