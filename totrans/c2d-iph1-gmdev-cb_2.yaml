- en: Chapter 2. User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Tap, hold, and drag input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth testing input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a directional pad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an analog stick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer for steering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the accelerometer for 3D rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinch zooming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without user input a video game is merely a tech demo. iOS touch devices allow
    limitless customization of user input. In this chapter, we will cover the most
    common input methods using both the **touch screen** and the **accelerometer**.
  prefs: []
  type: TYPE_NORMAL
- en: Tap, hold, and drag input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tapping, holding**, and **dragging** are the most commonly used input techniques.
    They form the basic building blocks of input for user interfaces as well as for
    interacting with game objects. In this recipe, we subclass `CCSprite` in order
    to create a sprite which can process touch events and maintain some custom state
    information. This, plus some logic, allows us to touch, hold, and drag this sprite.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tap, hold, and drag input](img/4002_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create the `ColorTouchSprite` class by sub-classing `CCSprite`. Here
    is where we maintain state variables to let us differentiate between a tap, a
    hold, and a drag. We also specify a `(CGRect)rect` method. This is used to determine
    whether or not the sprite was touched. The main recipe layer passes touch event
    information to this sprite using the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These methods are fairly straightforward. Whenever we touch the layer we call
    `ccTouchesBegan`. When we move we call `ccTouchesMoved`. Finally, when we lift
    a finger up we call `ccTouchesEnded`. Each method does a `pointIsInRect` check
    and then calls the requisite touches method on the sprite. Finally, the sprite
    runs some simple logic to determine state and to allow dragging of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique used previously is not the only way to capture input. Cocos2d
    also provides the `CCTouchDispatcher` class. With this you can implement methods
    in the `CCTargetedTouchDelegate` protocol and assign a delegate object to automatically
    handle your touch input.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on this method please consult the official Cocos2d documentation
    and the Cocos2d forum.
  prefs: []
  type: TYPE_NORMAL
- en: Depth testing input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling input manually like in the previous recipe gives us the opportunity
    to manage touchable objects at a high level. Using an array of sprites sorted
    by Z order we can "swallow the input" so that background sprites aren't affected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Depth testing input](img/4002_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our array of sprites has a **node order** which corresponds directly to their
    **Z order**. So, looping through these sprites does implicit **depth testing**.
    When a sprite touch begins we swallow the input allowing only that sprite to be
    touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caveats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only caveat to this technique is that input depth testing is tied to sprite
    array order. Any modification of sprite **Z** order requires a **re-sorting**
    of nodes in the array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Buttons** in one form or another are used in most games. It is easy to implement
    a simple button solution using Cocos2d but creating one that supports **multiple
    simultaneous button touches** is more difficult. In this recipe, we will implement
    a simple but effective solution to this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating buttons](img/4002_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a couple of different classes, all derived from `CCSprite`,
    to create realistic buttons. These buttons can all be touched independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Touching multiple buttons independently:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get multiple-button touching working, first we call the following method
    on our main `UIWindow` in our `AppDelegate` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then our `TouchableSprite` class uses the hash variable that uniquely identifies
    each `UITouch` object that passes through a `ccTouches` method. This way we can
    keep track of each unique touch. A touch can even be used to touch two buttons
    at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Touching two buttons with one touch:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `(CGRect)rect` method uses a `scaleMod` of `1.5f`. This, along with using
    `pointInCircle` for touch detection, allows us to press two buttons with one well
    placed touch. This is vital for many games. For example, the original Super Mario
    Brothers required the user to hold down the B button to run while pressing the
    A button to jump. This technique allows a similar use of the Y and A buttons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a directional pad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another fundamental form of video game input is the **directional pad**. In
    this recipe, you will see how to create a convincing 3D-ish directional pad and
    you will see how to properly process directional pad information in a game situation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a directional pad](img/4002_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a few simple tricks to make a compelling directional pad effect.
    First, we must look at the `DPad` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DPad` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DPad` class determines touch direction by first creating a 2D vector from
    the center of the DPad image to the point where it is touched. It then divides
    the image into eight directional slices. Each direction corresponds to a different
    sprite frame. When everything is put together we get a nice looking pseudo-3D
    effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Processing DPad state and `pressedVector:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DPad` class maintains both a direction enumeration and a direction vector.
    This allows us to determine which of the eight directions our "gunman" sprite
    should be facing and how we should set his `velocity` variable to instigate movement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DPad dead zone:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our DPad has a roughly 10 percent **dead zone** right in the middle. This makes
    the control feel a little more natural to the user. We do this because, on a real
    directional pad, pressing directly in the middle results in no movement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating an analog stick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By building on the last recipe, we can create a more sophisticated virtual **analog
    stick**. This input method measures vector magnitude as well as direction. We've
    also created a cool looking visual effect for the analog stick.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an analog stick](img/4002_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `AnalogStick` class provides the user with more precise control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnalogStick` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like the `DPad` class the `AnalogStick` class determines direction. Unlike
    `DPad` it also determines **magnitude** using the following lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This touched position also determines the position and orientation of the "nub"
    and the "bar". Without going into too much detail, this creates a nice analog
    stick visual effect. Like our `DPad` class from the previous recipe, our `AnalogStick`
    class also includes a dead zone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`AnalogStick` dead zone:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This time, the dead zone involves making the outer 25 percent of the touchable
    area max out the vector's magnitude. To achieve this we store an internal_`pressedVector`
    variable and give `readonly` access to a `pressedVector` property. This points
    to a method that does the proper calculations. The reason we provide this zone
    is so the user can comfortably make the 'gunman' run at top-speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the accelerometer for steering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'iOS applications also have another form of input: the **accelerometer**. This
    measures the **orientation** of the iOS device on the **X, Y**, and **Z planes**.
    Device orientation is a dynamic (if slightly delayed) input mechanism with a variety
    of uses. One of these uses is steering in racing video games.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the accelerometer for steering](img/4002_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rotating your iPhone left or right while looking directly at the screen will
    result in seeing the steering wheel rotate. The 3D vector contained within the
    `UIAcceleration` variable goes up or down by 1 for every 90 degrees the iOS device
    rotates. So, by multiplying this rotation by 180 degrees, we equate a 45-degree
    tilt with a 90-degree turn of the steering wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accelerometer delay:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mechanically the accelerometer has a slight delay compared to the touch screen.
    This makes its application impractical for some gametypes where absolute split
    second control is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the accelerometer for 3D rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using multiple accelerometer values at once can allow the user to manipulate
    the rotation of a 3D object in space. This is used to great effect in the Super
    Monkey Ball series of iOS games.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the accelerometer for 3D rotation](img/4002_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Please note that the `IphoneCube` class code was omitted from this example
    as it is similar to the 3D cube code in [Chapter 1](ch01.html "Chapter 1. Graphics"),
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rotating your device on the **X** or **Y** planes will result in rotating the
    virtual iPhone onscreen. We multiply the `acceleration` variable by 180 to once
    again rotate our object twice as much as the device itself. The `IphoneCube` variable
    `rotation3DAxis` rotates the textured box in 3D space using `glRotatef`.
  prefs: []
  type: TYPE_NORMAL
- en: Pinch zooming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apple's touch devices popularized using two fingers to zoom in and out and this
    method remains the most popular way to zoom on any widely available touch screen
    device. In this recipe, we will see how to zoom a scene in and out by **pinching**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pinch zooming](img/4002_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that the arrow effect shown in the previous screenshot has been
    omitted from the following code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe processes two separate touches and determines their respective
    distance. It maintains this variable to determine whether or not the touches have
    grown closer or farther apart. Then, this distance is used to calculate the new
    zoom level. The following line of code does this while also keeping the zoom effect
    smooth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This achieves the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing multiple simultaneous touches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, processing **multiple touches** is similar to processing a single
    touch. The `touches` variable contains every touch at that specific moment. If
    two touches move together this one method can easily process them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to add to this technique, try implementing iPhoto-esque image panning.
    This pan/zoom combination has become standard on all document and image viewers
    and is a natural UI enhancement for many iOS games.
  prefs: []
  type: TYPE_NORMAL
- en: Performing gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gestures** can act as functional input shortcuts. Simple gestures like swiping
    and scrolling are built into many Apple UI tools. Some games, notably Castlevania:
    Dawn of Sorrow (DS) and Okami (PS2, Wii) use gestures as core gameplay mechanics.
    In this recipe, we will implement a simple and admittedly crude gesture system.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing gestures](img/4002_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that the `GestureLine` and `GestureShapeLayer` classes have
    been omitted for brevity. `GestureLine` simply contains two `CGPoint` structures.
    `GestureShapeLayer` draws a circle or an array of lines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This gesture system tracks each individual point of user input. Each pair of
    points creates a **2D vector**. When the current vector's angle is different enough
    from the previous one, then we consider that this is a new vertex of a shape the
    user is drawing. We then take this vertex and the last one, and create a line.
    By storing every point and line we can determine what the user is attempting to
    draw.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This system, as implemented, leaves much to be desired. However, it provides
    the conceptual groundwork for a more complex and functional system. By looking
    at the succession of points in a certain light we can see patterns emerge. In
    this example, we looked for successive vectors with vastly different angles to
    determine drawn lines. Other things like curves, direction, and point distance
    can lead to the identification of more complex shapes.
  prefs: []
  type: TYPE_NORMAL
