<html><head></head><body>
		<div><h1 id="_idParaDest-94"><em class="italic"><a id="_idTextAnchor098"/>Chapter 9</em>: Implementing an MVI Architecture</h1>
			<p>In this chapter, we will introduce the concept of <strong class="bold">Model-View-Intent</strong> (<strong class="bold">MVI</strong>) and the benefits it provides for managing the state of an application. We will begin by analyzing what MVI is and then move on to implementing it using Kotlin flows. In this chapter's exercise, we will build upon the previous chapter's exercises, and we will re-implement them using the MVI pattern to highlight how this pattern can be integrated into the presentation layer of an application with multiple modules.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing MVI</li>
				<li>Implementing MVI with Kotlin flows</li>
			</ul>
			<p>By the end of the chapter, you will be able to implement the MVI architecture pattern inside a multimodule Android application, using Kotlin flows.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3FYZKLn">https://bit.ly/3FYZKLn</a></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Introducing MVI</h1>
			<p>In this section, we will<a id="_idIndexMarker627"/> look at what the MVI architecture pattern is, the problems it is trying to solve, and the solutions it presents for solving those problems.</p>
			<p>Let's imagine you need to develop a configuration screen for an application. It will load the existing configuration and it will need to toggle various switches and prepopulate input fields with the existing data. After that data is loaded, then the user can modify each of those fields. To achieve this, you would probably need to keep mutable references for the data represented in those fields so that when the user changes a value, the reference changes. </p>
			<p>This may pose a problem because of the mutability of those fields, especially when dealing with concurrent operations or their order. A solution to this problem is to make the data immutable and combine it into a state that the user interface can observe. Any changes the app or user will need to make on the user interfaces will be through a reactive data flow. The flow will then create a new state representing the change and update the user interface. </p>
			<p>This is essentially how MVI operates. In MVI, the <strong class="bold">View</strong> plays <a id="_idIndexMarker628"/>the same role as in MVP or MVVM and the <strong class="bold">Model</strong> holds the <a id="_idIndexMarker629"/>state of the user interface, and it represents the single source of truth. The <strong class="bold">Intent</strong> is <a id="_idIndexMarker630"/>represented by any changes that should be made to the state, which will then be updated. In <em class="italic">Figure 9.1</em>, we can see how the <strong class="bold">View</strong> will send an <strong class="bold">Intent</strong> to the <strong class="bold">Model</strong>, which will then trigger a change in state, which will update the <strong class="bold">View</strong>: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term Intent in the context of MVI is different from the Android <code>Intent</code> class used to interact with different Android components.</p>
			<div><div><img src="img/Figure_9.01_B18320.jpg" alt="Figure 9.1 – MVI diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – MVI diagram</p>
			<p>What is <a id="_idIndexMarker631"/>missing from this diagram is the equivalent of a <strong class="bold">ViewModel</strong> or a <strong class="bold">Presenter</strong>. This is because the MVI pattern isn't a replacement for those patterns but instead builds on top of them. </p>
			<p>To visualize how this might look, let's look at an example of a <code>ViewModel</code>:</p>
			<pre>class MyViewModel @Inject constructor(
    private val getMyDataUseCase: GetMyDataUseCase
) : ViewModel() {
    private val _myDataFlow =
        MutableStateFlow&lt;MyData&gt;(MyData())
    val myDataFlow: StateFlow&lt;MyData&gt; = _myDataFlow
    var text: String = ""
    fun loadMyData() {
        viewModelScope.launch {
            getMyDataUseCase.execute
                (GetPostsWithUsersWithInteractionUseCase.
                    Request)
                .collect {
                    _myDataFlow.value = it
                }
        }
    }
}</pre>
			<p>In the <a id="_idIndexMarker632"/>preceding example, we define a class named <code>MyViewModel</code> in which we have a use case to load data and a <code>text</code> variable that will be changed by the View when the user changes it. We can see that the <code>text</code> variable is a mutable variable accessible from the <code>StateFlow</code> variable holding the data to be loaded and we have a method to load the data. To transition the preceding code to MVI, we will need to first define a state that will hold the data to be loaded and the text. This will represent our source of truth. For the preceding example, this state will look as in the following example:</p>
			<pre>data class MyState(
        val myData: MyData = MyData(),
        val text: String = ""
)</pre>
			<p>In the <code>MyState</code> class, we move the data to be loaded and the text to be changed. Now, we will need to identify the actions; in this case, we have two actions: loading the data and updating the value of the text with a new value introduced by the user:</p>
			<pre>    sealed class MyAction {
        object LoadAction : MyAction()
        data class UpdateAction(val text: String) : 
            MyAction()
    }</pre>
			<p>In the preceding example, we have represented the action as a sealed class and defined two actions for loading and updating the text. Next, we will need to create the appropriate data flows for handling the actions and managing the state:</p>
			<pre>    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;
        (MyState())
    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow
    private val _actionFlow: MutableSharedFlow&lt;MyAction&gt; = 
        MutableSharedFlow()</pre>
			<p>In the <a id="_idIndexMarker633"/>preceding example, we have changed the <code>StateFlow</code> variables to hold the state object defined previously and added a similar <code>SharedFlow</code> variable, which will be responsible for managing the actions inserted by the user. We will now need to subscribe and handle the actions:</p>
			<pre>class MyViewModel @Inject constructor(
    private val getMyDataUseCase: GetMyDataUseCase
) : ViewModel() {
    …
    init {
        viewModelScope.launch {
            action.collect { action -&gt;
                when (action) {
                    is MyViewModel.MyAction.LoadAction -&gt; {
                        loadMyData()
                    }
                    is MyViewModel.MyAction.UpdateAction -&gt; {
                        _myDataFlow.emit(_myDataFlow.value.copy(text = 
    action.text))
                    }
                }
            }
        }
    }
    fun submitAction(action: MyAction) {
        viewModelScope.launch {
            _action.emit(action)
        }
    }
    private fun loadMyData() {
        getMyDataUseCase.execute
            (GetPostsWithUsersWithInteractionUseCase.
                Request)
            .collect {
                _myDataFlow.value = it
            }
    }
    …
}</pre>
			<p>In the <code>init</code> block, we are collecting the actions and then, for each action, we perform the required operation. The View will invoke the <code>submitAction</code> method and pass the action it wants the ViewModel to perform. For this example, <code>MyAction</code> plays the role of the Intent within the MVI context and the ViewModel will sit between the View and Model and will be responsible for managing the flow of data between the Model and the View, as well as managing the state. </p>
			<p>When it comes to the implementation of the MVI pattern, there are many different variations for different technologies and different architecture patterns. From RxJava to <code>LiveData</code>, to flows and coroutines, to MVVM and MVP, there are different approaches to the pattern with different variations. </p>
			<p>Some are <a id="_idIndexMarker634"/>built using concepts such as state machines, others use basic streams, and others use third-party open source libraries. From the preceding example, we can see that the pattern introduces a little bit of boilerplate code, so it is important to perform research and monitor the initial introduction of the pattern into any application. In the section that follows, we will look at how we can implement MVI using Kotlin flows.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor101"/>Implementing MVI with Kotlin flows</h1>
			<p>In this <a id="_idIndexMarker635"/>section, we will look at <a id="_idIndexMarker636"/>how we can implement the MVI architecture pattern using Kotlin flows and the benefits and pitfalls of this approach.</p>
			<p>In the previous section, we defined an MVI approach using <code>StateFlow</code> and <code>SharedFlow</code>, as in the following example:</p>
			<pre>    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;(MyState())
    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow
    private val actionFlow: MutableSharedFlow&lt;MyAction&gt; = MutableSharedFlow()</pre>
			<p>The different types of flows used here serve different purposes. <code>MutableStateFlow</code> will emit the last value held, which is good for the user interface because we want it to display the last data loaded, like how <code>LiveData</code> works. <code>SharedFlow</code> doesn't have this feature, which is useful for actions because we do not want the last action to be emitted twice. Another aspect we will need to consider is one-shot events, which should be emitted using a channel flow. This will be useful when the View will need to respond to events in a channel to display a toast alert or handle navigation to a new screen. We can apply this using the following: </p>
			<pre>class MyViewModel @Inject constructor(
    private val getMyDataUseCase: GetMyDataUseCase
) : ViewModel() {
    …
    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;
        (MyState())
    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow
    private val actionFlow: MutableSharedFlow&lt;MyAction&gt; = 
        MutableSharedFlow()
    private val _myOneOffFlow = Channel&lt;MyOneOffEvent&gt;()
    val myOneOffFlow = _myOneOffFlow.receiveAsFlow()
    … 
}</pre>
			<p>In the <a id="_idIndexMarker637"/>preceding example, we<a id="_idIndexMarker638"/> have integrated the <code>Channel</code> information with the rest of the <code>ViewModel</code>. Because an application will end up having multiple ViewModels, we can create a template that will be used across the application. We can start by defining abstractions for each of the state, action, and one-off events:</p>
			<pre>interface UiState
interface UiAction
interface UiSingleEvent</pre>
			<p>Here, we have opted for a simple interface to represent each of the flows of data the <code>ViewModel</code> will use. We can next define a template for the <code>ViewModel</code>, which can be inherited by the ViewModels used in the application:</p>
			<pre>abstract class MviViewModel&lt;S : UiState, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
    private val _uiStateFlow: MutableStateFlow&lt;S&gt; by lazy {
        MutableStateFlow(initState())
    }
    val uiStateFlow: StateFlow&lt;S&gt; = _uiStateFlow
    private val actionFlow: MutableSharedFlow&lt;A&gt; = 
        MutableSharedFlow()
    private val _singleEventFlow = Channel&lt;E&gt;()
    val singleEventFlow = _singleEventFlow.receiveAsFlow()
    …
}</pre>
			<p>In the<a id="_idIndexMarker639"/> preceding example, we <a id="_idIndexMarker640"/>have used generics for each of the flows that the <code>ViewModel</code> will use. This creates a problem for <code>MutableStateFlow</code>, which requires an initial value. Because we don't have any concrete value to initialize, we will need to create an abstract method that will provide the initial value:</p>
			<pre>abstract class MviViewModel&lt;S : UiState, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
    …
    init {
        viewModelScope.launch {
            actionFlow.collect {
                handleAction(it)
            }
        }
    }
    abstract fun initState(): S
    abstract fun handleAction(action: A)
}</pre>
			<p>In addition<a id="_idIndexMarker641"/> to the <code>initState</code> abstraction, we have also added the <code>handleAction</code> abstraction. This will be called <a id="_idIndexMarker642"/>when new actions are submitted because of user actions or a screen load. Because the mutable variables are set to private, we will need to expose methods that emit events into these flows:</p>
			<pre>abstract class MviViewModel&lt;S : UiState, A : UiAction, E : 
    UiSingleEvent&gt; : ViewModel() {
    …
    fun submitAction(action: A) {
        viewModelScope.launch {
            actionFlow.emit(action)
        }
    }
    fun submitState(state: S) {
        viewModelScope.launch {
            _uiStateFlow.value = state
        }
    }
    fun submitSingleEvent(event: E) {
        viewModelScope.launch {
            _singleEventFlow.send(event)
        }
    }
}</pre>
			<p>In the <a id="_idIndexMarker643"/>preceding example, we <a id="_idIndexMarker644"/>have added the methods that emit, send, or change the value on each of the specific data flows. To implement the template for a specific scenario, we will need to create concretions for <code>UiState</code>:</p>
			<pre>sealed class MyUiState : UiState {
    data class Success(val myData: MyData) : MyUiState()
    object Error : MyUiState()
    object Loading : MyUiState()
}</pre>
			<p>In the preceding example, we have defined different states that the screen might have. We can now create a concretion for <code>UiAction</code>:</p>
			<pre>sealed class MyUiAction : UiAction {
    object Load : MyUiAction()
    object Click : MyUiAction()
}</pre>
			<p>Here, we defined an action for when the data will need to be loaded and another for when something is clicked on the user interface: </p>
			<pre>sealed class MyUiSingleEvent : UiSingleEvent {
    data class ShowToast(val text: String) : 
        MyUiSingleEvent()
}</pre>
			<p>For the <a id="_idIndexMarker645"/>single event fired, we <a id="_idIndexMarker646"/>have defined a show toast alert event. Finally, we can implement the concretion for the <code>ViewModel</code>:</p>
			<pre>class MyViewModel : MviViewModel&lt;MyUiState, MyUiAction, 
    MyUiSingleEvent&gt;() {
    override fun initState(): MyUiState = MyUiState.Loading
    override fun handleAction(action: MyUiAction) {
        when (action) {
            is MyUiAction.Load -&gt; {
                viewModelScope.launch {
                    val state: UiState = // Fetch UI state
                    submitState(state)
                }
            }
            is MyUiAction.Click -&gt; {
                // Handle logic for clicks
                submitSingleEvent(MyUiSingleEvent.
                    ShowToast("Toast"))
            }
        }
    }
}</pre>
			<p>In the preceding example, we have extended the <code>MviViewModel</code> class and passed <code>MyUiState</code>, <code>MyUiAction</code>, and <code>MyUiSingleEvent</code> for the generics. In the <code>initState</code> method, we return the <code>Loading</code> state, and in the <code>handleAction</code> method, we check the actions and then load the data or handle the click event, which will then submit the event to show a toast alert. </p>
			<p>If we <a id="_idIndexMarker647"/>want to integrate the <code>ViewModel</code> with <a id="_idIndexMarker648"/>Jetpack Compose, we will have to use something like the following example:</p>
			<pre>@Composable
fun MyScreen(
    viewModel: MyViewModel
) {
    viewModel.submitAction(MyUiAction.Load)
    viewModel.uiStateFlow.collectAsState().value.let { 
        state -&gt;
        when (state) {
            is MyUiState.Loading -&gt; {
            }
            is MyUiState.Success -&gt; {
                MySuccessScreen(state.myData) {
                    viewModel.submitAction(MyUiAction.
                        Click)
                }
            }
            is MyUiState.Error -&gt; {
            }
        }
    }
}</pre>
			<p>We can<a id="_idIndexMarker649"/> see that observing <code>UiState</code> will<a id="_idIndexMarker650"/> remain the same as for MVVM; however, if we wish to notify the <code>ViewModel</code> of any changes, we will need to use the <code>submitAction</code> method. For the <code>UiSingleEvents</code> object, we will need to use the <code>LaunchedEffect</code> function because we don't want Jetpack Compose to keep recomposing and re-executing the same block; we only want it to be executed once, so we will need to use something such as the following:</p>
			<pre>@Composable
fun MyScreen(
    viewModel: MyViewModel
) {
    …
    LaunchedEffect(Unit, {
        viewModel.singleEventFlow.collectLatest {
            when (it) {
                is MyUiSingleEvent.ShowToast -&gt; {
                    // Show Toast
                }
            }
        }
    })
}</pre>
			<p>In this example, we collect the data from <code>Channel</code> inside the <code>LaunchedEffect</code> method and then show a toast alert when the <code>ShowToast</code> event is received. <code>LaunchedEffect</code> can also be used to ensure that we do not trigger multiple data loads because of the Jetpack Compose recomposition mechanism: </p>
			<pre>@Composable
fun MyScreen(
    viewModel: MyViewModel
) {
    LaunchedEffect(Unit, {
        viewModel.submitAction(MyUiAction.Load)
    }
}</pre>
			<p>In the <a id="_idIndexMarker651"/>preceding snippet, we<a id="_idIndexMarker652"/> have moved the call to <code>submitAction</code> inside <code>LaunchedEffect</code>, to avoid triggering the loading multiple times. More information about Jetpack Compose side effects<a id="_idIndexMarker653"/> can be found here: <a href="https://developer.android.com/jetpack/compose/side-effects">https://developer.android.com/jetpack/compose/side-effects</a>.</p>
			<p>In this section, we have shown how we can integrate the MVI architecture pattern with flows and Jetpack Compose. We have seen how we have translated the interactions between the View and the <code>ViewModel</code> into intents using the <code>UiAction</code> interface and the implementations of this interface. We have also seen some of the downsides of the pattern because of the addition of boilerplate code and, in the case of Jetpack Compose, having to use methods such as <code>LaunchedEffect</code> and <code>Channel</code> for emitting one-off events. In the following section, we will create an application in which we will migrate a previous exercise to use MVI.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor102"/>Exercise 09.01 – Transitioning to MVI</h2>
			<p>Modify <em class="italic">Exercise 08.02 – Multi-module data presentation</em> from <a href="B18320_08_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 8</em></a>, <em class="italic">Implementing an MVVM Architecture</em>, so that the presentation layer uses the MVI architecture <a id="_idIndexMarker654"/>pattern. The <code>UiState</code> class will remain and represent the state of each screen. New interfaces will be added in the <code>presentation-common</code> module representing actions and one-off events. In the same module, an <code>MviViewModel</code> abstract class will be implemented, which will be the template for the other ViewModels used in the application. For <code>PostListViewModel</code>, we will create new user actions for loading the data, clicking on the post, and clicking on the author, and two new one-off events will be needed for opening each of those screens. For <code>PostViewModel</code> and <code>UserViewModel</code>, we will create only a single user action, which will be responsible for loading the data on each screen.</p>
			<p>To complete this <a id="_idIndexMarker655"/>exercise, you will need to do the following:</p>
			<ol>
				<li>In <code>presentation-common</code>, create an interface called <code>UiAction</code> and an interface called <code>UiSingleEvent</code>, and then create the <code>MviViewModel</code> template.</li>
				<li>In the <code>list</code> package of the <code>presentation-post</code> module, create a sealed class called <code>PostListUiAction</code>, which will contain three subclasses called <code>Load</code>, <code>UserClick</code>, and <code>PostClick</code>. Then, create a sealed class called <code>PostListUiSingleEvent</code>, which will have two subclasses named <code>OpenUserScreen</code> and <code>OpenPostScreen</code>. Then, modify <code>PostListViewModel</code> and <code>PostListScreen</code> to use the sp<a id="_idTextAnchor103"/>ecified actions and events.</li>
				<li>In the <code>single</code> package of the <code>presentation-post</code> module, create a sealed class called <code>PostUiAction</code>, which will have one subclass named <code>Load</code>, which will contain the ID of the post. Then, modify <code>PostViewModel</code> and <code>PostScreen</code> to instead use the specified action.</li>
				<li>In the <code>single</code> package of the <code>presentation-user</code> module, create a sealed class called <code>UserUiAction</code>, which will have one subclass named <code>Load</code>, which will contain the ID of the user. Then, modify <code>UserViewModel</code> and <code>UserScreen</code> to instead use the specified action.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the state package of the <code>presentation-common</code> module, create an interface called <code>UiAction</code>:<pre>interface UiAction</pre></li>
				<li>In the same package, create an interface called <code>UiSingleEvent</code>:<pre>interface UiSingleEvent</pre></li>
				<li>In the same package, create an abstract class called <code>MviViewModel</code>:<pre>abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
}</pre></li>
			</ol>
			<p>Because we<a id="_idIndexMarker656"/> are using the <code>UiState</code> class with generics, we will need to also supply that generic field in the generic specification of <code>MviViewModel</code>. </p>
			<ol>
				<li value="4">In the <code>MviViewModel</code> class, add the necessary flows and channels that will hold the states, actions, and events:<pre>abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
    private val _uiStateFlow: MutableStateFlow&lt;S&gt; by 
        lazy {
        MutableStateFlow(initState())
    }
    val uiStateFlow: StateFlow&lt;S&gt; = _uiStateFlow
    private val actionFlow: MutableSharedFlow&lt;A&gt; = 
        MutableSharedFlow()
    private val _singleEventFlow = Channel&lt;E&gt;()
    val singleEventFlow = _singleEventFlow.
        receiveAsFlow()
}</pre></li>
			</ol>
			<p>In this snippet, we have defined <code>StateFlow</code> variables to hold the last value that was emitted, which will be used to manage the state of the user interface, <code>SharedFlow</code>, which is used for handling user actions, and <code>Channel</code> for handling emitting one-off events. In the <code>MviViewModel</code> class, we are also defining generics so that we bind states, actions, and one-off events to their respective types.</p>
			<ol>
				<li value="5">In <code>MviViewModel</code>, add the<a id="_idIndexMarker657"/> abstract methods for initializing the state and handling the actions:<pre>abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
    …
    init {
        viewModelScope.launch {
            actionFlow.collect {
                handleAction(it)
            }
        }
    }
    abstract fun initState(): S
    abstract fun handleAction(action: A)
}</pre></li>
			</ol>
			<p>In this snippet, we are adding the abstraction required to provide an initial value for <code>StateFlow</code>, and then we handle the collection of the user actions, which will be handled in the <code>handleAction</code> method.</p>
			<ol>
				<li value="6">In <code>MviViewModel</code>, add the<a id="_idIndexMarker658"/> required methods to submit the state, events, and actions:<pre>abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {
    …
    fun submitAction(action: A) {
        viewModelScope.launch {
            actionFlow.emit(action)
        }
    }
    fun submitState(state: S) {
        viewModelScope.launch {
            _uiStateFlow.value = state
        }
    }
    fun submitSingleEvent(event: E) {
        viewModelScope.launch {
            _singleEventFlow.send(event)
        }
    }
}</pre></li>
			</ol>
			<p>In this snippet, we are defining a set of methods to emit data into the two <code>Flow</code> objects and the <code>Channel</code> object.</p>
			<ol>
				<li value="7">In the <code>list</code> package <a id="_idIndexMarker659"/>of the <code>presentation-post</code> module, create the <code>PostListUiAction</code> class and its subclasses:<pre>sealed class PostListUiAction : UiAction {
    object Load : PostListUiAction()
    data class UserClick(val userId: Long, val 
        interaction: Interaction) : PostListUiAction()
    data class PostClick(val postId: Long, val 
        interaction: Interaction) : PostListUiAction()
}</pre></li>
			</ol>
			<p>Here, we define a sealed class for loading the data and clicking on the user and the post. Each of them will implement the <code>UiAction</code> interface.</p>
			<ol>
				<li value="8">In the same package, create the <code>PostListUiAction</code> class and its subclasses:<pre>sealed class PostListUiSingleEvent : UiSingleEvent {
    data class OpenUserScreen(val navRoute: String) : 
        PostListUiSingleEvent()
    data class OpenPostScreen(val navRoute: String) : 
        PostListUiSingleEvent()
}</pre></li>
			</ol>
			<p>Here, we define a sealed class for the one-off events that will be emitted when we want the user and post screens to be opened, which is why we are implementing <code>UiSingleEvent</code>.</p>
			<ol>
				<li value="9">In the same package, modify <code>PostListViewModel</code> to extend <code>MviViewModel</code>:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    private val useCase: 
        GetPostsWithUsersWithInteractionUseCase,
    private val converter: PostListConverter,
    private val updateInteractionUseCase: 
        UpdateInteractionUseCase
) : <strong class="bold">MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</strong>
<strong class="bold">    , PostListUiAction, PostListUiSingleEvent&gt;() </strong>{
     …
}</pre></li>
			</ol>
			<p>In this snippet, we are extending <code>MviViewModel</code> and providing the types we defined previously as well as the existing <code>PostListModel</code> type to the generic fields. This is because we want this <code>ViewModel</code> to be bound to the data, actions, and one-off events that occur in <code>PostListScreen</code>.</p>
			<ol>
				<li value="10">Implement <a id="_idIndexMarker660"/>the <code>initState</code> method in the <code>PostListViewModel</code> class:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    …
) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;
    , PostListUiAction, PostListUiSingleEvent&gt;() {
    override fun initState(): UiState&lt;PostListModel&gt; = 
        UiState.Loading
}</pre></li>
			</ol>
			<p>In this snippet, we are implementing the <code>initState</code> method and providing the <code>UiState.Loading</code> value, which will in turn make the <code>uiStateFlow</code> field from the parent class be initialized with the <code>Loading</code> value.</p>
			<ol>
				<li value="11">Implement<a id="_idIndexMarker661"/> the <code>handleAction</code> method in the <code>PostListViewModel</code> class:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    …
) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;
    , PostListUiAction, PostListUiSingleEvent&gt;() {
    …
    override fun handleAction(action: 
        PostListUiAction) {
        when (action) {
            is PostListUiAction.Load -&gt; {
                loadPosts()
            }
            is PostListUiAction.PostClick -&gt; {
                updateInteraction(action.interaction)
                submitSingleEvent(
                    PostListUiSingleEvent.
                        OpenPostScreen(
                        NavRoutes.Post.routeForPost(
                            PostInput(action.postId)
                        )
                    )
                )
            }
            is PostListUiAction.UserClick -&gt; {
                updateInteraction(action.interaction)
                submitSingleEvent(
                    PostListUiSingleEvent.
                        OpenUserScreen(
                        NavRoutes.User.routeForUser(
                            UserInput(action.userId)
                        )
                    )
                )
            }
        }
    }
}</pre></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker662"/> are implementing the <code>handleAction</code> method, which will check what action we will need to handle and perform the necessary operation for each. For loading, we will invoke the <code>loadPosts</code> method, and for clicking on a user and a post, we will invoke the <code>updateInteraction</code> method and then submit a one-off event to open the user and post screens.</p>
			<ol>
				<li value="12">Implement the <code>loadPosts</code> method in the <code>PostListViewModel</code> class:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    …
) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;
    , PostListUiAction, PostListUiSingleEvent&gt;() {
    …
    private fun loadPosts() {
        viewModelScope.launch {
            useCase.execute
            (GetPostsWithUsersWithInteractionUseCase.
            Request)
                .map {
                    converter.convert(it)
                }
                .collect {
                    submitState(it)
                }
        }
    }
}</pre></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker663"/> load the data from <code>GetPostsWithUsersWithInteractionUseCase</code> and collect it and update <code>uiStateFlow</code> through the <code>submitState</code> method inherited from the parent class.</p>
			<ol>
				<li value="13">Implement the <code>updateInteraction</code> method in the <code>PostListViewModel</code> class:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    …
) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;
    , PostListUiAction, PostListUiSingleEvent&gt;() {
    …
    private fun updateInteraction(interaction: 
        Interaction) {
        viewModelScope.launch {
            updateInteractionUseCase.execute(
                UpdateInteractionUseCase.Request(
                    interaction.copy(
                        totalClicks = interaction.
                            totalClicks + 1
                    )
                )
            ).collect()
        }
    }
}</pre></li>
			</ol>
			<p>In this method, we <a id="_idIndexMarker664"/>implement the <code>updateInteraction</code> method, which will submit a new value with an incremented click count using <code>UpdateInteractionUseCase</code>.</p>
			<ol>
				<li value="14">Modify the <code>PostListScreen</code> method in the <code>PostListScreen</code> file in the <code>list</code> package in the <code>presentation-post</code> module so that it will instead use the <code>submitAction</code> method:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel,
    navController: NavController
) {
    <strong class="bold">LaunchedEffect(Unit) {</strong>
        <strong class="bold">viewModel.submitAction(PostListUiAction.Load)</strong>
    <strong class="bold">}</strong>
    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let { 
        state -&gt;
        CommonScreen(state = state) {
            PostList(it, { postListItem -&gt;
                <strong class="bold">viewModel.submitAction</strong>
<strong class="bold">                    (PostListUiAction.PostClick</strong>
<strong class="bold">                    (postListItem.id, it.interaction))</strong>
            }) { postListItem -&gt;
                <strong class="bold">viewModel.submitAction</strong>
<strong class="bold">                    (PostListUiAction.UserClick</strong>
<strong class="bold">                    (postListItem.id, it.interaction))</strong>
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker665"/>are changing how we interact with <code>PostListViewModel</code>. Instead of invoking each separate method for loading and updating the interaction, we instead use the <code>submitAction</code> method from <code>MviViewModel</code>. In order to load the data, we are using <code>LaunchedEffect</code> so that when Jetpack Compose triggers recomposition, the data load won't be retriggered. We are also subscribing to <code>uiStateFlow</code> instead of <code>postListFlow</code>, which no longer exists.</p>
			<ol>
				<li value="15">In the same<a id="_idIndexMarker666"/> method, subscribe to <code>singleEventFlow</code> so that it opens <code>PostScreen</code> and <code>UserScreen</code> when the appropriate events are received:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel,
    navController: NavController
) {
    …
    LaunchedEffect(Unit) {
        viewModel.singleEventFlow.collectLatest {
            when (it) {
                is PostListUiSingleEvent.
                    OpenPostScreen -&gt; {    navController.navigate
                    (it.navRoute)
                }
                is PostListUiSingleEvent.
                    OpenUserScreen -&gt; {
                    navController.navigate
                    (it.navRoute)
                }
            }
        }
    }
}</pre></li>
			</ol>
			<p>In this snippet, we will need to monitor the events from <code>singleEventFlow</code> and then check the events emitted and open the appropriate screen.</p>
			<ol>
				<li value="16">In the <code>single</code> package of the <code>presentation-post</code> module, create the <code>PostUiAction</code> class and its subclass:<pre>sealed class PostUiAction : UiAction {
    data class Load(val postId: Long) : PostUiAction()
}</pre></li>
				<li>In the same <a id="_idIndexMarker667"/>package, modify <code>PostViewModel</code> so that it extends <code>MviViewModel</code>:<pre>@HiltViewModel
class PostViewModel @Inject constructor(
    private val postUseCase: GetPostUseCase,
    private val postConverter: PostConverter
) : <strong class="bold">MviViewModel&lt;PostModel, UiState&lt;PostModel&gt;, </strong>
<strong class="bold">    PostUiAction,</strong> <strong class="bold">UiSingleEvent&gt;()</strong> {
}</pre></li>
			</ol>
			<p>Here, we are using the newly created <code>PostUiAction</code>, but because we have no one-off events to subscribe to, we will use the <code>UiSingleEvent</code> interface.</p>
			<ol>
				<li value="18">In the same class, implement the <code>initState</code> and <code>handleAction</code> methods:<pre>@HiltViewModel
class PostViewModel @Inject constructor(
    …
) : MviViewModel&lt;PostModel, UiState&lt;PostModel&gt;, 
    PostUiAction, UiSingleEvent&gt;() {
    override fun initState(): UiState&lt;PostModel&gt; = 
        UiState.Loading
    override fun handleAction(action: PostUiAction) {
        when (action) {
            is PostUiAction.Load -&gt; {
                loadPost(action.postId)
            }
        }
    }
    private fun loadPost(postId: Long) {
        viewModelScope.launch {
            postUseCase.execute
                (GetPostUseCase.Request(postId))
                .map {
                    postConverter.convert(it)
                }
                .collect {
                    submitState(it)
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we are implementing the <code>initState</code> method and returning the <code>UiState.Loading</code> value and the <code>handleAction</code> method. For <code>handleAction</code>, we only have the action to load the data, which will use <code>GetPostUseCase</code> to retrieve the post data and then update <code>uiStateFlow</code> through the <code>submitState</code> method.</p>
			<ol>
				<li value="19">Modify<a id="_idIndexMarker668"/> the <code>PostScreen</code> method from the <code>PostScreen</code> file in the <code>single</code> package in the <code>presentation-post</code> module so that it instead uses the <code>Load</code> action:<pre>@Composable
fun PostScreen(
    viewModel: PostViewModel,
    postInput: PostInput
) {
    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let {
        result -&gt;
        CommonScreen(result) { postModel -&gt;
            Post(postModel)
        }
    }
    <strong class="bold">LaunchedEffect(postInput.postId) {</strong>
        <strong class="bold">viewModel.submitAction(PostUiAction.</strong>
<strong class="bold">            Load(postInput.postId))</strong>
    <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>In this snippet, we are following the same principle as in <code>PostListScreen</code> where we replace the interaction with <code>PostViewModel</code> to use the <code>submitAction</code> method and use <code>LaunchedEffect</code> to isolate the data loading.</p>
			<ol>
				<li value="20">In the <code>single</code> package<a id="_idIndexMarker669"/> of the <code>presentation-user</code> module, create the <code>UserUiAction</code> class and its subclass:<pre>sealed class UserUiAction : UiAction {
    data class Load(val userId: Long) : UserUiAction()
}</pre></li>
				<li>In the same package, modify <code>UserViewModel</code> so that it extends the <code>MviViewModel</code> class:<pre>@HiltViewModel
class UserViewModel @Inject constructor(
    private val userUseCase: GetUserUseCase,
    private val converter: UserConverter
) : <strong class="bold">MviViewModel&lt;UserModel, UiState&lt;UserModel&gt;, </strong>
<strong class="bold">    UserUiAction,</strong> <strong class="bold">UiSingleEvent&gt;()</strong> {
}</pre></li>
			</ol>
			<p>Here, we are using the newly created <code>UserUiAction</code>, but because we have no one-off events to subscribe to, we will use the <code>UiSingleEvent</code> interface.</p>
			<ol>
				<li value="22">In the same class, implement the <code>initState</code> and <code>handleAction</code> methods:<pre>@HiltViewModel
class UserViewModel @Inject constructor(
    …
) : MviViewModel&lt;UserModel, UiState&lt;UserModel&gt;, 
    UserUiAction, UiSingleEvent&gt;() {
    override fun initState(): UiState&lt;UserModel&gt; = 
        UiState.Loading
    override fun handleAction(action: UserUiAction) {
        when (action) {
            is UserUiAction.Load -&gt; {
                loadUser(action.userId)
            }
        }
    }
    private fun loadUser(userId: Long) {
        viewModelScope.launch {
            userUseCase.execute
                (GetUserUseCase.Request(userId))
                .map {
                    converter.convert(it)
                }
                .collect {
                    submitState(it)
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we are following the same principle as for <code>PostViewModel</code>, which is to implement the <code>initState</code> method to return <code>UiState.Loading</code>, then in <code>handleAction</code>, we check the type, and for the <code>Load</code> action, we load the user information.</p>
			<ol>
				<li value="23">Modify <a id="_idIndexMarker670"/>the <code>UserScreen</code> method from the <code>UserScreen</code> file in the <code>single</code> package in the <code>presentation-user</code> module so that it instead uses the <code>Load</code> action:<pre>@Composable
fun UserScreen(
    viewModel: UserViewModel,
    userInput: UserInput
) {
    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let { 
        result -&gt;
        CommonScreen(result) { userModel -&gt;
            User(userModel)
        }
    }
    <strong class="bold">LaunchedEffect(userInput.userId) {</strong>
        <strong class="bold">viewModel.submitAction(UserUiAction.</strong>
<strong class="bold">            Load(userInput.userId))</strong>
    <strong class="bold">}</strong>
}</pre></li>
			</ol>
			<p>In this snippet, we are following the same principle as in <code>PostScreen</code> where we replace the interaction with <code>UserViewModel</code> to use the <code>submitAction</code> method and<a id="_idIndexMarker671"/> use <code>LaunchedEffect</code> to isolate the data loading.</p>
			<p>If we run the application, we will see the same output as in <em class="italic">Exercise 08.02 – Multi-module data presentation</em>:</p>
			<div><div><img src="img/Figure_9.02_B18320_Merged.jpg" alt="Figure 9.2 – Output of Exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Output of Exercise 09.01</p>
			<p>After introducing <a id="_idIndexMarker672"/>MVI into the exercise, we can see that we already had the groundwork because of how Jetpack Compose requires states to manage the user interface. This represents one of the reasons we ended up creating the <code>UiState</code> class in previous chapters. We have also observed the downsides of the pattern through the addition of boilerplate code and the handling of one-off events, the latter not being limited to MVI. The use of <code>MviViewModel</code> shows how we can have the same template across different modules of the presentation layer.</p>
			<p>From a Clean Architecture perspective, we can see that the changes we have done in our presentation layer haven't affected the rest of the layers of the application, which is a sign that we are going down the right path.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor104"/>Summary</h1>
			<p>In this chapter, we studied the MVI architecture pattern and the benefits it provides to applications using reactive streams of data, by centralizing user and application actions into a unidirectional flow of data. </p>
			<p>We then looked at how we can implement this pattern using Kotlin flows and the role it plays when combined with other patterns, such as MVP and MVVM, with a focus on MVVM. We can observe the downsides of the pattern on simple presentations, but its benefits become more visible in applications with complicated user interfaces that take in multiple user inputs, which can change the states of other inputs. In the chapter's exercise, we looked at how we can transition an application with MVVM to MVI and how it fits into Clean Architecture. </p>
			<p>In the next chapter, we will take a step back and look at what we have implemented and studied so far. We will see what we can improve and how we can take advantage of the different layers of the application, as well as how we can swap dependencies for the various configurations an application might have.</p>
		</div>
	</body></html>