<html><head></head><body>
		<div id="_idContainer054">
			<h1 id="_idParaDest-94"><em class="italic"><a id="_idTextAnchor098"/>Chapter 9</em>: Implementing an MVI Architecture</h1>
			<p>In this chapter, we will introduce the concept of <strong class="bold">Model-View-Intent</strong> (<strong class="bold">MVI</strong>) and the benefits it provides for managing the state of an application. We will begin by analyzing what MVI is and then move on to implementing it using Kotlin flows. In this chapter's exercise, we will build upon the previous chapter's exercises, and we will re-implement them using the MVI pattern to highlight how this pattern can be integrated into the presentation layer of an application with multiple modules.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing MVI</li>
				<li>Implementing MVI with Kotlin flows</li>
			</ul>
			<p>By the end of the chapter, you will be able to implement the MVI architecture pattern inside a multimodule Android application, using Kotlin flows.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>The hardware and software requirements are as follows:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3FYZKLn">https://bit.ly/3FYZKLn</a></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Introducing MVI</h1>
			<p>In this section, we will<a id="_idIndexMarker627"/> look at what the MVI architecture pattern is, the problems it is trying to solve, and the solutions it presents for solving those problems.</p>
			<p>Let's imagine you need to develop a configuration screen for an application. It will load the existing configuration and it will need to toggle various switches and prepopulate input fields with the existing data. After that data is loaded, then the user can modify each of those fields. To achieve this, you would probably need to keep mutable references for the data represented in those fields so that when the user changes a value, the reference changes. </p>
			<p>This may pose a problem because of the mutability of those fields, especially when dealing with concurrent operations or their order. A solution to this problem is to make the data immutable and combine it into a state that the user interface can observe. Any changes the app or user will need to make on the user interfaces will be through a reactive data flow. The flow will then create a new state representing the change and update the user interface. </p>
			<p>This is essentially how MVI operates. In MVI, the <strong class="bold">View</strong> plays <a id="_idIndexMarker628"/>the same role as in MVP or MVVM and the <strong class="bold">Model</strong> holds the <a id="_idIndexMarker629"/>state of the user interface, and it represents the single source of truth. The <strong class="bold">Intent</strong> is <a id="_idIndexMarker630"/>represented by any changes that should be made to the state, which will then be updated. In <em class="italic">Figure 9.1</em>, we can see how the <strong class="bold">View</strong> will send an <strong class="bold">Intent</strong> to the <strong class="bold">Model</strong>, which will then trigger a change in state, which will update the <strong class="bold">View</strong>: </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term Intent in the context of MVI is different from the Android <strong class="source-inline">Intent</strong> class used to interact with different Android components.</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_9.01_B18320.jpg" alt="Figure 9.1 – MVI diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – MVI diagram</p>
			<p>What is <a id="_idIndexMarker631"/>missing from this diagram is the equivalent of a <strong class="bold">ViewModel</strong> or a <strong class="bold">Presenter</strong>. This is because the MVI pattern isn't a replacement for those patterns but instead builds on top of them. </p>
			<p>To visualize how this might look, let's look at an example of a <strong class="source-inline">ViewModel</strong>:</p>
			<p class="source-code">class MyViewModel @Inject constructor(</p>
			<p class="source-code">    private val getMyDataUseCase: GetMyDataUseCase</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    private val _myDataFlow =</p>
			<p class="source-code">        MutableStateFlow&lt;MyData&gt;(MyData())</p>
			<p class="source-code">    val myDataFlow: StateFlow&lt;MyData&gt; = _myDataFlow</p>
			<p class="source-code">    var text: String = ""</p>
			<p class="source-code">    fun loadMyData() {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            getMyDataUseCase.execute</p>
			<p class="source-code">                (GetPostsWithUsersWithInteractionUseCase.</p>
			<p class="source-code">                    Request)</p>
			<p class="source-code">                .collect {</p>
			<p class="source-code">                    _myDataFlow.value = it</p>
			<p class="source-code">                }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker632"/>preceding example, we define a class named <strong class="source-inline">MyViewModel</strong> in which we have a use case to load data and a <strong class="source-inline">text</strong> variable that will be changed by the View when the user changes it. We can see that the <strong class="source-inline">text</strong> variable is a mutable variable accessible from the <strong class="bold">View</strong>. We also have a <strong class="source-inline">StateFlow</strong> variable holding the data to be loaded and we have a method to load the data. To transition the preceding code to MVI, we will need to first define a state that will hold the data to be loaded and the text. This will represent our source of truth. For the preceding example, this state will look as in the following example:</p>
			<p class="source-code">data class MyState(</p>
			<p class="source-code">        val myData: MyData = MyData(),</p>
			<p class="source-code">        val text: String = ""</p>
			<p class="source-code">)</p>
			<p>In the <strong class="source-inline">MyState</strong> class, we move the data to be loaded and the text to be changed. Now, we will need to identify the actions; in this case, we have two actions: loading the data and updating the value of the text with a new value introduced by the user:</p>
			<p class="source-code">    sealed class MyAction {</p>
			<p class="source-code">        object LoadAction : MyAction()</p>
			<p class="source-code">        data class UpdateAction(val text: String) : </p>
			<p class="source-code">            MyAction()</p>
			<p class="source-code">    }</p>
			<p>In the preceding example, we have represented the action as a sealed class and defined two actions for loading and updating the text. Next, we will need to create the appropriate data flows for handling the actions and managing the state:</p>
			<p class="source-code">    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;</p>
			<p class="source-code">        (MyState())</p>
			<p class="source-code">    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow</p>
			<p class="source-code">    private val _actionFlow: MutableSharedFlow&lt;MyAction&gt; = </p>
			<p class="source-code">        MutableSharedFlow()</p>
			<p>In the <a id="_idIndexMarker633"/>preceding example, we have changed the <strong class="source-inline">StateFlow</strong> variables to hold the state object defined previously and added a similar <strong class="source-inline">SharedFlow</strong> variable, which will be responsible for managing the actions inserted by the user. We will now need to subscribe and handle the actions:</p>
			<p class="source-code">class MyViewModel @Inject constructor(</p>
			<p class="source-code">    private val getMyDataUseCase: GetMyDataUseCase</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            action.collect { action -&gt;</p>
			<p class="source-code">                when (action) {</p>
			<p class="source-code">                    is MyViewModel.MyAction.LoadAction -&gt; {</p>
			<p class="source-code">                        loadMyData()</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                    is MyViewModel.MyAction.UpdateAction -&gt; {</p>
			<p class="source-code">                        _myDataFlow.emit(_myDataFlow.value.copy(text = </p>
			<p class="source-code">    action.text))</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fun submitAction(action: MyAction) {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            _action.emit(action)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private fun loadMyData() {</p>
			<p class="source-code">        getMyDataUseCase.execute</p>
			<p class="source-code">            (GetPostsWithUsersWithInteractionUseCase.</p>
			<p class="source-code">                Request)</p>
			<p class="source-code">            .collect {</p>
			<p class="source-code">                _myDataFlow.value = it</p>
			<p class="source-code">            }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">init</strong> block, we are collecting the actions and then, for each action, we perform the required operation. The View will invoke the <strong class="source-inline">submitAction</strong> method and pass the action it wants the ViewModel to perform. For this example, <strong class="source-inline">MyAction</strong> plays the role of the Intent within the MVI context and the ViewModel will sit between the View and Model and will be responsible for managing the flow of data between the Model and the View, as well as managing the state. </p>
			<p>When it comes to the implementation of the MVI pattern, there are many different variations for different technologies and different architecture patterns. From RxJava to <strong class="source-inline">LiveData</strong>, to flows and coroutines, to MVVM and MVP, there are different approaches to the pattern with different variations. </p>
			<p>Some are <a id="_idIndexMarker634"/>built using concepts such as state machines, others use basic streams, and others use third-party open source libraries. From the preceding example, we can see that the pattern introduces a little bit of boilerplate code, so it is important to perform research and monitor the initial introduction of the pattern into any application. In the section that follows, we will look at how we can implement MVI using Kotlin flows.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor101"/>Implementing MVI with Kotlin flows</h1>
			<p>In this <a id="_idIndexMarker635"/>section, we will look at <a id="_idIndexMarker636"/>how we can implement the MVI architecture pattern using Kotlin flows and the benefits and pitfalls of this approach.</p>
			<p>In the previous section, we defined an MVI approach using <strong class="source-inline">StateFlow</strong> and <strong class="source-inline">SharedFlow</strong>, as in the following example:</p>
			<p class="source-code">    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;(MyState())</p>
			<p class="source-code">    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow</p>
			<p class="source-code">    private val actionFlow: MutableSharedFlow&lt;MyAction&gt; = MutableSharedFlow()</p>
			<p>The different types of flows used here serve different purposes. <strong class="source-inline">MutableStateFlow</strong> will emit the last value held, which is good for the user interface because we want it to display the last data loaded, like how <strong class="source-inline">LiveData</strong> works. <strong class="source-inline">SharedFlow</strong> doesn't have this feature, which is useful for actions because we do not want the last action to be emitted twice. Another aspect we will need to consider is one-shot events, which should be emitted using a channel flow. This will be useful when the View will need to respond to events in a channel to display a toast alert or handle navigation to a new screen. We can apply this using the following: </p>
			<p class="source-code">class MyViewModel @Inject constructor(</p>
			<p class="source-code">    private val getMyDataUseCase: GetMyDataUseCase</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    private val _myStateFlow = MutableStateFlow&lt;MyState&gt;</p>
			<p class="source-code">        (MyState())</p>
			<p class="source-code">    val myStateFlow: StateFlow&lt;MyState&gt; = _myDataFlow</p>
			<p class="source-code">    private val actionFlow: MutableSharedFlow&lt;MyAction&gt; = </p>
			<p class="source-code">        MutableSharedFlow()</p>
			<p class="source-code">    private val _myOneOffFlow = Channel&lt;MyOneOffEvent&gt;()</p>
			<p class="source-code">    val myOneOffFlow = _myOneOffFlow.receiveAsFlow()</p>
			<p class="source-code">    … </p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker637"/>preceding example, we<a id="_idIndexMarker638"/> have integrated the <strong class="source-inline">Channel</strong> information with the rest of the <strong class="source-inline">ViewModel</strong>. Because an application will end up having multiple ViewModels, we can create a template that will be used across the application. We can start by defining abstractions for each of the state, action, and one-off events:</p>
			<p class="source-code">interface UiState</p>
			<p class="source-code">interface UiAction</p>
			<p class="source-code">interface UiSingleEvent</p>
			<p>Here, we have opted for a simple interface to represent each of the flows of data the <strong class="source-inline">ViewModel</strong> will use. We can next define a template for the <strong class="source-inline">ViewModel</strong>, which can be inherited by the ViewModels used in the application:</p>
			<p class="source-code">abstract class MviViewModel&lt;S : UiState, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p>
			<p class="source-code">    private val _uiStateFlow: MutableStateFlow&lt;S&gt; by lazy {</p>
			<p class="source-code">        MutableStateFlow(initState())</p>
			<p class="source-code">    }</p>
			<p class="source-code">    val uiStateFlow: StateFlow&lt;S&gt; = _uiStateFlow</p>
			<p class="source-code">    private val actionFlow: MutableSharedFlow&lt;A&gt; = </p>
			<p class="source-code">        MutableSharedFlow()</p>
			<p class="source-code">    private val _singleEventFlow = Channel&lt;E&gt;()</p>
			<p class="source-code">    val singleEventFlow = _singleEventFlow.receiveAsFlow()</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>In the<a id="_idIndexMarker639"/> preceding example, we <a id="_idIndexMarker640"/>have used generics for each of the flows that the <strong class="source-inline">ViewModel</strong> will use. This creates a problem for <strong class="source-inline">MutableStateFlow</strong>, which requires an initial value. Because we don't have any concrete value to initialize, we will need to create an abstract method that will provide the initial value:</p>
			<p class="source-code">abstract class MviViewModel&lt;S : UiState, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    init {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            actionFlow.collect {</p>
			<p class="source-code">                handleAction(it)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    abstract fun initState(): S</p>
			<p class="source-code">    abstract fun handleAction(action: A)</p>
			<p class="source-code">}</p>
			<p>In addition<a id="_idIndexMarker641"/> to the <strong class="source-inline">initState</strong> abstraction, we have also added the <strong class="source-inline">handleAction</strong> abstraction. This will be called <a id="_idIndexMarker642"/>when new actions are submitted because of user actions or a screen load. Because the mutable variables are set to private, we will need to expose methods that emit events into these flows:</p>
			<p class="source-code">abstract class MviViewModel&lt;S : UiState, A : UiAction, E : </p>
			<p class="source-code">    UiSingleEvent&gt; : ViewModel() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    fun submitAction(action: A) {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            actionFlow.emit(action)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fun submitState(state: S) {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            _uiStateFlow.value = state</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fun submitSingleEvent(event: E) {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            _singleEventFlow.send(event)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker643"/>preceding example, we <a id="_idIndexMarker644"/>have added the methods that emit, send, or change the value on each of the specific data flows. To implement the template for a specific scenario, we will need to create concretions for <strong class="source-inline">UiState</strong>:</p>
			<p class="source-code">sealed class MyUiState : UiState {</p>
			<p class="source-code">    data class Success(val myData: MyData) : MyUiState()</p>
			<p class="source-code">    object Error : MyUiState()</p>
			<p class="source-code">    object Loading : MyUiState()</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have defined different states that the screen might have. We can now create a concretion for <strong class="source-inline">UiAction</strong>:</p>
			<p class="source-code">sealed class MyUiAction : UiAction {</p>
			<p class="source-code">    object Load : MyUiAction()</p>
			<p class="source-code">    object Click : MyUiAction()</p>
			<p class="source-code">}</p>
			<p>Here, we defined an action for when the data will need to be loaded and another for when something is clicked on the user interface: </p>
			<p class="source-code">sealed class MyUiSingleEvent : UiSingleEvent {</p>
			<p class="source-code">    data class ShowToast(val text: String) : </p>
			<p class="source-code">        MyUiSingleEvent()</p>
			<p class="source-code">}</p>
			<p>For the <a id="_idIndexMarker645"/>single event fired, we <a id="_idIndexMarker646"/>have defined a show toast alert event. Finally, we can implement the concretion for the <strong class="source-inline">ViewModel</strong>:</p>
			<p class="source-code">class MyViewModel : MviViewModel&lt;MyUiState, MyUiAction, </p>
			<p class="source-code">    MyUiSingleEvent&gt;() {</p>
			<p class="source-code">    override fun initState(): MyUiState = MyUiState.Loading</p>
			<p class="source-code">    override fun handleAction(action: MyUiAction) {</p>
			<p class="source-code">        when (action) {</p>
			<p class="source-code">            is MyUiAction.Load -&gt; {</p>
			<p class="source-code">                viewModelScope.launch {</p>
			<p class="source-code">                    val state: UiState = // Fetch UI state</p>
			<p class="source-code">                    submitState(state)</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            is MyUiAction.Click -&gt; {</p>
			<p class="source-code">                // Handle logic for clicks</p>
			<p class="source-code">                submitSingleEvent(MyUiSingleEvent.</p>
			<p class="source-code">                    ShowToast("Toast"))</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we have extended the <strong class="source-inline">MviViewModel</strong> class and passed <strong class="source-inline">MyUiState</strong>, <strong class="source-inline">MyUiAction</strong>, and <strong class="source-inline">MyUiSingleEvent</strong> for the generics. In the <strong class="source-inline">initState</strong> method, we return the <strong class="source-inline">Loading</strong> state, and in the <strong class="source-inline">handleAction</strong> method, we check the actions and then load the data or handle the click event, which will then submit the event to show a toast alert. </p>
			<p>If we <a id="_idIndexMarker647"/>want to integrate the <strong class="source-inline">ViewModel</strong> with <a id="_idIndexMarker648"/>Jetpack Compose, we will have to use something like the following example:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyScreen(</p>
			<p class="source-code">    viewModel: MyViewModel</p>
			<p class="source-code">) {</p>
			<p class="source-code">    viewModel.submitAction(MyUiAction.Load)</p>
			<p class="source-code">    viewModel.uiStateFlow.collectAsState().value.let { </p>
			<p class="source-code">        state -&gt;</p>
			<p class="source-code">        when (state) {</p>
			<p class="source-code">            is MyUiState.Loading -&gt; {</p>
			<p class="source-code">            }</p>
			<p class="source-code">            is MyUiState.Success -&gt; {</p>
			<p class="source-code">                MySuccessScreen(state.myData) {</p>
			<p class="source-code">                    viewModel.submitAction(MyUiAction.</p>
			<p class="source-code">                        Click)</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            is MyUiState.Error -&gt; {</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We can<a id="_idIndexMarker649"/> see that observing <strong class="source-inline">UiState</strong> will<a id="_idIndexMarker650"/> remain the same as for MVVM; however, if we wish to notify the <strong class="source-inline">ViewModel</strong> of any changes, we will need to use the <strong class="source-inline">submitAction</strong> method. For the <strong class="source-inline">UiSingleEvents</strong> object, we will need to use the <strong class="source-inline">LaunchedEffect</strong> function because we don't want Jetpack Compose to keep recomposing and re-executing the same block; we only want it to be executed once, so we will need to use something such as the following:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyScreen(</p>
			<p class="source-code">    viewModel: MyViewModel</p>
			<p class="source-code">) {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    LaunchedEffect(Unit, {</p>
			<p class="source-code">        viewModel.singleEventFlow.collectLatest {</p>
			<p class="source-code">            when (it) {</p>
			<p class="source-code">                is MyUiSingleEvent.ShowToast -&gt; {</p>
			<p class="source-code">                    // Show Toast</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    })</p>
			<p class="source-code">}</p>
			<p>In this example, we collect the data from <strong class="source-inline">Channel</strong> inside the <strong class="source-inline">LaunchedEffect</strong> method and then show a toast alert when the <strong class="source-inline">ShowToast</strong> event is received. <strong class="source-inline">LaunchedEffect</strong> can also be used to ensure that we do not trigger multiple data loads because of the Jetpack Compose recomposition mechanism: </p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MyScreen(</p>
			<p class="source-code">    viewModel: MyViewModel</p>
			<p class="source-code">) {</p>
			<p class="source-code">    LaunchedEffect(Unit, {</p>
			<p class="source-code">        viewModel.submitAction(MyUiAction.Load)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker651"/>preceding snippet, we<a id="_idIndexMarker652"/> have moved the call to <strong class="source-inline">submitAction</strong> inside <strong class="source-inline">LaunchedEffect</strong>, to avoid triggering the loading multiple times. More information about Jetpack Compose side effects<a id="_idIndexMarker653"/> can be found here: <a href="https://developer.android.com/jetpack/compose/side-effects">https://developer.android.com/jetpack/compose/side-effects</a>.</p>
			<p>In this section, we have shown how we can integrate the MVI architecture pattern with flows and Jetpack Compose. We have seen how we have translated the interactions between the View and the <strong class="source-inline">ViewModel</strong> into intents using the <strong class="source-inline">UiAction</strong> interface and the implementations of this interface. We have also seen some of the downsides of the pattern because of the addition of boilerplate code and, in the case of Jetpack Compose, having to use methods such as <strong class="source-inline">LaunchedEffect</strong> and <strong class="source-inline">Channel</strong> for emitting one-off events. In the following section, we will create an application in which we will migrate a previous exercise to use MVI.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor102"/>Exercise 09.01 – Transitioning to MVI</h2>
			<p>Modify <em class="italic">Exercise 08.02 – Multi-module data presentation</em> from <a href="B18320_08_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 8</em></a>, <em class="italic">Implementing an MVVM Architecture</em>, so that the presentation layer uses the MVI architecture <a id="_idIndexMarker654"/>pattern. The <strong class="source-inline">UiState</strong> class will remain and represent the state of each screen. New interfaces will be added in the <strong class="source-inline">presentation-common</strong> module representing actions and one-off events. In the same module, an <strong class="source-inline">MviViewModel</strong> abstract class will be implemented, which will be the template for the other ViewModels used in the application. For <strong class="source-inline">PostListViewModel</strong>, we will create new user actions for loading the data, clicking on the post, and clicking on the author, and two new one-off events will be needed for opening each of those screens. For <strong class="source-inline">PostViewModel</strong> and <strong class="source-inline">UserViewModel</strong>, we will create only a single user action, which will be responsible for loading the data on each screen.</p>
			<p>To complete this <a id="_idIndexMarker655"/>exercise, you will need to do the following:</p>
			<ol>
				<li>In <strong class="source-inline">presentation-common</strong>, create an interface called <strong class="source-inline">UiAction</strong> and an interface called <strong class="source-inline">UiSingleEvent</strong>, and then create the <strong class="source-inline">MviViewModel</strong> template.</li>
				<li>In the <strong class="source-inline">list</strong> package of the <strong class="source-inline">presentation-post</strong> module, create a sealed class called <strong class="source-inline">PostListUiAction</strong>, which will contain three subclasses called <strong class="source-inline">Load</strong>, <strong class="source-inline">UserClick</strong>, and <strong class="source-inline">PostClick</strong>. Then, create a sealed class called <strong class="source-inline">PostListUiSingleEvent</strong>, which will have two subclasses named <strong class="source-inline">OpenUserScreen</strong> and <strong class="source-inline">OpenPostScreen</strong>. Then, modify <strong class="source-inline">PostListViewModel</strong> and <strong class="source-inline">PostListScreen</strong> to use the sp<a id="_idTextAnchor103"/>ecified actions and events.</li>
				<li>In the <strong class="source-inline">single</strong> package of the <strong class="source-inline">presentation-post</strong> module, create a sealed class called <strong class="source-inline">PostUiAction</strong>, which will have one subclass named <strong class="source-inline">Load</strong>, which will contain the ID of the post. Then, modify <strong class="source-inline">PostViewModel</strong> and <strong class="source-inline">PostScreen</strong> to instead use the specified action.</li>
				<li>In the <strong class="source-inline">single</strong> package of the <strong class="source-inline">presentation-user</strong> module, create a sealed class called <strong class="source-inline">UserUiAction</strong>, which will have one subclass named <strong class="source-inline">Load</strong>, which will contain the ID of the user. Then, modify <strong class="source-inline">UserViewModel</strong> and <strong class="source-inline">UserScreen</strong> to instead use the specified action.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">In the state package of the <strong class="source-inline">presentation-common</strong> module, create an interface called <strong class="source-inline">UiAction</strong>:<p class="source-code">interface UiAction</p></li>
				<li>In the same package, create an interface called <strong class="source-inline">UiSingleEvent</strong>:<p class="source-code">interface UiSingleEvent</p></li>
				<li>In the same package, create an abstract class called <strong class="source-inline">MviViewModel</strong>:<p class="source-code">abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p><p class="source-code">}</p></li>
			</ol>
			<p>Because we<a id="_idIndexMarker656"/> are using the <strong class="source-inline">UiState</strong> class with generics, we will need to also supply that generic field in the generic specification of <strong class="source-inline">MviViewModel</strong>. </p>
			<ol>
				<li value="4">In the <strong class="source-inline">MviViewModel</strong> class, add the necessary flows and channels that will hold the states, actions, and events:<p class="source-code">abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p><p class="source-code">    private val _uiStateFlow: MutableStateFlow&lt;S&gt; by </p><p class="source-code">        lazy {</p><p class="source-code">        MutableStateFlow(initState())</p><p class="source-code">    }</p><p class="source-code">    val uiStateFlow: StateFlow&lt;S&gt; = _uiStateFlow</p><p class="source-code">    private val actionFlow: MutableSharedFlow&lt;A&gt; = </p><p class="source-code">        MutableSharedFlow()</p><p class="source-code">    private val _singleEventFlow = Channel&lt;E&gt;()</p><p class="source-code">    val singleEventFlow = _singleEventFlow.</p><p class="source-code">        receiveAsFlow()</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we have defined <strong class="source-inline">StateFlow</strong> variables to hold the last value that was emitted, which will be used to manage the state of the user interface, <strong class="source-inline">SharedFlow</strong>, which is used for handling user actions, and <strong class="source-inline">Channel</strong> for handling emitting one-off events. In the <strong class="source-inline">MviViewModel</strong> class, we are also defining generics so that we bind states, actions, and one-off events to their respective types.</p>
			<ol>
				<li value="5">In <strong class="source-inline">MviViewModel</strong>, add the<a id="_idIndexMarker657"/> abstract methods for initializing the state and handling the actions:<p class="source-code">abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    init {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            actionFlow.collect {</p><p class="source-code">                handleAction(it)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    abstract fun initState(): S</p><p class="source-code">    abstract fun handleAction(action: A)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are adding the abstraction required to provide an initial value for <strong class="source-inline">StateFlow</strong>, and then we handle the collection of the user actions, which will be handled in the <strong class="source-inline">handleAction</strong> method.</p>
			<ol>
				<li value="6">In <strong class="source-inline">MviViewModel</strong>, add the<a id="_idIndexMarker658"/> required methods to submit the state, events, and actions:<p class="source-code">abstract class MviViewModel&lt;T : Any, S : UiState&lt;T&gt;, A : UiAction, E : UiSingleEvent&gt; : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    fun submitAction(action: A) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            actionFlow.emit(action)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    fun submitState(state: S) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            _uiStateFlow.value = state</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    fun submitSingleEvent(event: E) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            _singleEventFlow.send(event)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are defining a set of methods to emit data into the two <strong class="source-inline">Flow</strong> objects and the <strong class="source-inline">Channel</strong> object.</p>
			<ol>
				<li value="7">In the <strong class="source-inline">list</strong> package <a id="_idIndexMarker659"/>of the <strong class="source-inline">presentation-post</strong> module, create the <strong class="source-inline">PostListUiAction</strong> class and its subclasses:<p class="source-code">sealed class PostListUiAction : UiAction {</p><p class="source-code">    object Load : PostListUiAction()</p><p class="source-code">    data class UserClick(val userId: Long, val </p><p class="source-code">        interaction: Interaction) : PostListUiAction()</p><p class="source-code">    data class PostClick(val postId: Long, val </p><p class="source-code">        interaction: Interaction) : PostListUiAction()</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we define a sealed class for loading the data and clicking on the user and the post. Each of them will implement the <strong class="source-inline">UiAction</strong> interface.</p>
			<ol>
				<li value="8">In the same package, create the <strong class="source-inline">PostListUiAction</strong> class and its subclasses:<p class="source-code">sealed class PostListUiSingleEvent : UiSingleEvent {</p><p class="source-code">    data class OpenUserScreen(val navRoute: String) : </p><p class="source-code">        PostListUiSingleEvent()</p><p class="source-code">    data class OpenPostScreen(val navRoute: String) : </p><p class="source-code">        PostListUiSingleEvent()</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we define a sealed class for the one-off events that will be emitted when we want the user and post screens to be opened, which is why we are implementing <strong class="source-inline">UiSingleEvent</strong>.</p>
			<ol>
				<li value="9">In the same package, modify <strong class="source-inline">PostListViewModel</strong> to extend <strong class="source-inline">MviViewModel</strong>:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    private val useCase: </p><p class="source-code">        GetPostsWithUsersWithInteractionUseCase,</p><p class="source-code">    private val converter: PostListConverter,</p><p class="source-code">    private val updateInteractionUseCase: </p><p class="source-code">        UpdateInteractionUseCase</p><p class="source-code">) : <strong class="bold">MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</strong></p><p class="source-code"><strong class="bold">    , PostListUiAction, PostListUiSingleEvent&gt;() </strong>{</p><p class="source-code">     …</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are extending <strong class="source-inline">MviViewModel</strong> and providing the types we defined previously as well as the existing <strong class="source-inline">PostListModel</strong> type to the generic fields. This is because we want this <strong class="source-inline">ViewModel</strong> to be bound to the data, actions, and one-off events that occur in <strong class="source-inline">PostListScreen</strong>.</p>
			<ol>
				<li value="10">Implement <a id="_idIndexMarker660"/>the <strong class="source-inline">initState</strong> method in the <strong class="source-inline">PostListViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</p><p class="source-code">    , PostListUiAction, PostListUiSingleEvent&gt;() {</p><p class="source-code">    override fun initState(): UiState&lt;PostListModel&gt; = </p><p class="source-code">        UiState.Loading</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are implementing the <strong class="source-inline">initState</strong> method and providing the <strong class="source-inline">UiState.Loading</strong> value, which will in turn make the <strong class="source-inline">uiStateFlow</strong> field from the parent class be initialized with the <strong class="source-inline">Loading</strong> value.</p>
			<ol>
				<li value="11">Implement<a id="_idIndexMarker661"/> the <strong class="source-inline">handleAction</strong> method in the <strong class="source-inline">PostListViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</p><p class="source-code">    , PostListUiAction, PostListUiSingleEvent&gt;() {</p><p class="source-code">    …</p><p class="source-code">    override fun handleAction(action: </p><p class="source-code">        PostListUiAction) {</p><p class="source-code">        when (action) {</p><p class="source-code">            is PostListUiAction.Load -&gt; {</p><p class="source-code">                loadPosts()</p><p class="source-code">            }</p><p class="source-code">            is PostListUiAction.PostClick -&gt; {</p><p class="source-code">                updateInteraction(action.interaction)</p><p class="source-code">                submitSingleEvent(</p><p class="source-code">                    PostListUiSingleEvent.</p><p class="source-code">                        OpenPostScreen(</p><p class="source-code">                        NavRoutes.Post.routeForPost(</p><p class="source-code">                            PostInput(action.postId)</p><p class="source-code">                        )</p><p class="source-code">                    )</p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">            is PostListUiAction.UserClick -&gt; {</p><p class="source-code">                updateInteraction(action.interaction)</p><p class="source-code">                submitSingleEvent(</p><p class="source-code">                    PostListUiSingleEvent.</p><p class="source-code">                        OpenUserScreen(</p><p class="source-code">                        NavRoutes.User.routeForUser(</p><p class="source-code">                            UserInput(action.userId)</p><p class="source-code">                        )</p><p class="source-code">                    )</p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker662"/> are implementing the <strong class="source-inline">handleAction</strong> method, which will check what action we will need to handle and perform the necessary operation for each. For loading, we will invoke the <strong class="source-inline">loadPosts</strong> method, and for clicking on a user and a post, we will invoke the <strong class="source-inline">updateInteraction</strong> method and then submit a one-off event to open the user and post screens.</p>
			<ol>
				<li value="12">Implement the <strong class="source-inline">loadPosts</strong> method in the <strong class="source-inline">PostListViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</p><p class="source-code">    , PostListUiAction, PostListUiSingleEvent&gt;() {</p><p class="source-code">    …</p><p class="source-code">    private fun loadPosts() {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            useCase.execute</p><p class="source-code">            (GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">            Request)</p><p class="source-code">                .map {</p><p class="source-code">                    converter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    submitState(it)</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we<a id="_idIndexMarker663"/> load the data from <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong> and collect it and update <strong class="source-inline">uiStateFlow</strong> through the <strong class="source-inline">submitState</strong> method inherited from the parent class.</p>
			<ol>
				<li value="13">Implement the <strong class="source-inline">updateInteraction</strong> method in the <strong class="source-inline">PostListViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;PostListModel, UiState&lt;PostListModel&gt;</p><p class="source-code">    , PostListUiAction, PostListUiSingleEvent&gt;() {</p><p class="source-code">    …</p><p class="source-code">    private fun updateInteraction(interaction: </p><p class="source-code">        Interaction) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            updateInteractionUseCase.execute(</p><p class="source-code">                UpdateInteractionUseCase.Request(</p><p class="source-code">                    interaction.copy(</p><p class="source-code">                        totalClicks = interaction.</p><p class="source-code">                            totalClicks + 1</p><p class="source-code">                    )</p><p class="source-code">                )</p><p class="source-code">            ).collect()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we <a id="_idIndexMarker664"/>implement the <strong class="source-inline">updateInteraction</strong> method, which will submit a new value with an incremented click count using <strong class="source-inline">UpdateInteractionUseCase</strong>.</p>
			<ol>
				<li value="14">Modify the <strong class="source-inline">PostListScreen</strong> method in the <strong class="source-inline">PostListScreen</strong> file in the <strong class="source-inline">list</strong> package in the <strong class="source-inline">presentation-post</strong> module so that it will instead use the <strong class="source-inline">submitAction</strong> method:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel,</p><p class="source-code">    navController: NavController</p><p class="source-code">) {</p><p class="source-code">    <strong class="bold">LaunchedEffect(Unit) {</strong></p><p class="source-code">        <strong class="bold">viewModel.submitAction(PostListUiAction.Load)</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let { </p><p class="source-code">        state -&gt;</p><p class="source-code">        CommonScreen(state = state) {</p><p class="source-code">            PostList(it, { postListItem -&gt;</p><p class="source-code">                <strong class="bold">viewModel.submitAction</strong></p><p class="source-code"><strong class="bold">                    (PostListUiAction.PostClick</strong></p><p class="source-code"><strong class="bold">                    (postListItem.id, it.interaction))</strong></p><p class="source-code">            }) { postListItem -&gt;</p><p class="source-code">                <strong class="bold">viewModel.submitAction</strong></p><p class="source-code"><strong class="bold">                    (PostListUiAction.UserClick</strong></p><p class="source-code"><strong class="bold">                    (postListItem.id, it.interaction))</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker665"/>are changing how we interact with <strong class="source-inline">PostListViewModel</strong>. Instead of invoking each separate method for loading and updating the interaction, we instead use the <strong class="source-inline">submitAction</strong> method from <strong class="source-inline">MviViewModel</strong>. In order to load the data, we are using <strong class="source-inline">LaunchedEffect</strong> so that when Jetpack Compose triggers recomposition, the data load won't be retriggered. We are also subscribing to <strong class="source-inline">uiStateFlow</strong> instead of <strong class="source-inline">postListFlow</strong>, which no longer exists.</p>
			<ol>
				<li value="15">In the same<a id="_idIndexMarker666"/> method, subscribe to <strong class="source-inline">singleEventFlow</strong> so that it opens <strong class="source-inline">PostScreen</strong> and <strong class="source-inline">UserScreen</strong> when the appropriate events are received:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel,</p><p class="source-code">    navController: NavController</p><p class="source-code">) {</p><p class="source-code">    …</p><p class="source-code">    LaunchedEffect(Unit) {</p><p class="source-code">        viewModel.singleEventFlow.collectLatest {</p><p class="source-code">            when (it) {</p><p class="source-code">                is PostListUiSingleEvent.</p><p class="source-code">                    OpenPostScreen -&gt; {    navController.navigate</p><p class="source-code">                    (it.navRoute)</p><p class="source-code">                }</p><p class="source-code">                is PostListUiSingleEvent.</p><p class="source-code">                    OpenUserScreen -&gt; {</p><p class="source-code">                    navController.navigate</p><p class="source-code">                    (it.navRoute)</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we will need to monitor the events from <strong class="source-inline">singleEventFlow</strong> and then check the events emitted and open the appropriate screen.</p>
			<ol>
				<li value="16">In the <strong class="source-inline">single</strong> package of the <strong class="source-inline">presentation-post</strong> module, create the <strong class="source-inline">PostUiAction</strong> class and its subclass:<p class="source-code">sealed class PostUiAction : UiAction {</p><p class="source-code">    data class Load(val postId: Long) : PostUiAction()</p><p class="source-code">}</p></li>
				<li>In the same <a id="_idIndexMarker667"/>package, modify <strong class="source-inline">PostViewModel</strong> so that it extends <strong class="source-inline">MviViewModel</strong>:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostViewModel @Inject constructor(</p><p class="source-code">    private val postUseCase: GetPostUseCase,</p><p class="source-code">    private val postConverter: PostConverter</p><p class="source-code">) : <strong class="bold">MviViewModel&lt;PostModel, UiState&lt;PostModel&gt;, </strong></p><p class="source-code"><strong class="bold">    PostUiAction,</strong> <strong class="bold">UiSingleEvent&gt;()</strong> {</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are using the newly created <strong class="source-inline">PostUiAction</strong>, but because we have no one-off events to subscribe to, we will use the <strong class="source-inline">UiSingleEvent</strong> interface.</p>
			<ol>
				<li value="18">In the same class, implement the <strong class="source-inline">initState</strong> and <strong class="source-inline">handleAction</strong> methods:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;PostModel, UiState&lt;PostModel&gt;, </p><p class="source-code">    PostUiAction, UiSingleEvent&gt;() {</p><p class="source-code">    override fun initState(): UiState&lt;PostModel&gt; = </p><p class="source-code">        UiState.Loading</p><p class="source-code">    override fun handleAction(action: PostUiAction) {</p><p class="source-code">        when (action) {</p><p class="source-code">            is PostUiAction.Load -&gt; {</p><p class="source-code">                loadPost(action.postId)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private fun loadPost(postId: Long) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            postUseCase.execute</p><p class="source-code">                (GetPostUseCase.Request(postId))</p><p class="source-code">                .map {</p><p class="source-code">                    postConverter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    submitState(it)</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are implementing the <strong class="source-inline">initState</strong> method and returning the <strong class="source-inline">UiState.Loading</strong> value and the <strong class="source-inline">handleAction</strong> method. For <strong class="source-inline">handleAction</strong>, we only have the action to load the data, which will use <strong class="source-inline">GetPostUseCase</strong> to retrieve the post data and then update <strong class="source-inline">uiStateFlow</strong> through the <strong class="source-inline">submitState</strong> method.</p>
			<ol>
				<li value="19">Modify<a id="_idIndexMarker668"/> the <strong class="source-inline">PostScreen</strong> method from the <strong class="source-inline">PostScreen</strong> file in the <strong class="source-inline">single</strong> package in the <strong class="source-inline">presentation-post</strong> module so that it instead uses the <strong class="source-inline">Load</strong> action:<p class="source-code">@Composable</p><p class="source-code">fun PostScreen(</p><p class="source-code">    viewModel: PostViewModel,</p><p class="source-code">    postInput: PostInput</p><p class="source-code">) {</p><p class="source-code">    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let {</p><p class="source-code">        result -&gt;</p><p class="source-code">        CommonScreen(result) { postModel -&gt;</p><p class="source-code">            Post(postModel)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">LaunchedEffect(postInput.postId) {</strong></p><p class="source-code">        <strong class="bold">viewModel.submitAction(PostUiAction.</strong></p><p class="source-code"><strong class="bold">            Load(postInput.postId))</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are following the same principle as in <strong class="source-inline">PostListScreen</strong> where we replace the interaction with <strong class="source-inline">PostViewModel</strong> to use the <strong class="source-inline">submitAction</strong> method and use <strong class="source-inline">LaunchedEffect</strong> to isolate the data loading.</p>
			<ol>
				<li value="20">In the <strong class="source-inline">single</strong> package<a id="_idIndexMarker669"/> of the <strong class="source-inline">presentation-user</strong> module, create the <strong class="source-inline">UserUiAction</strong> class and its subclass:<p class="source-code">sealed class UserUiAction : UiAction {</p><p class="source-code">    data class Load(val userId: Long) : UserUiAction()</p><p class="source-code">}</p></li>
				<li>In the same package, modify <strong class="source-inline">UserViewModel</strong> so that it extends the <strong class="source-inline">MviViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class UserViewModel @Inject constructor(</p><p class="source-code">    private val userUseCase: GetUserUseCase,</p><p class="source-code">    private val converter: UserConverter</p><p class="source-code">) : <strong class="bold">MviViewModel&lt;UserModel, UiState&lt;UserModel&gt;, </strong></p><p class="source-code"><strong class="bold">    UserUiAction,</strong> <strong class="bold">UiSingleEvent&gt;()</strong> {</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are using the newly created <strong class="source-inline">UserUiAction</strong>, but because we have no one-off events to subscribe to, we will use the <strong class="source-inline">UiSingleEvent</strong> interface.</p>
			<ol>
				<li value="22">In the same class, implement the <strong class="source-inline">initState</strong> and <strong class="source-inline">handleAction</strong> methods:<p class="source-code">@HiltViewModel</p><p class="source-code">class UserViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">) : MviViewModel&lt;UserModel, UiState&lt;UserModel&gt;, </p><p class="source-code">    UserUiAction, UiSingleEvent&gt;() {</p><p class="source-code">    override fun initState(): UiState&lt;UserModel&gt; = </p><p class="source-code">        UiState.Loading</p><p class="source-code">    override fun handleAction(action: UserUiAction) {</p><p class="source-code">        when (action) {</p><p class="source-code">            is UserUiAction.Load -&gt; {</p><p class="source-code">                loadUser(action.userId)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    private fun loadUser(userId: Long) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            userUseCase.execute</p><p class="source-code">                (GetUserUseCase.Request(userId))</p><p class="source-code">                .map {</p><p class="source-code">                    converter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    submitState(it)</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are following the same principle as for <strong class="source-inline">PostViewModel</strong>, which is to implement the <strong class="source-inline">initState</strong> method to return <strong class="source-inline">UiState.Loading</strong>, then in <strong class="source-inline">handleAction</strong>, we check the type, and for the <strong class="source-inline">Load</strong> action, we load the user information.</p>
			<ol>
				<li value="23">Modify <a id="_idIndexMarker670"/>the <strong class="source-inline">UserScreen</strong> method from the <strong class="source-inline">UserScreen</strong> file in the <strong class="source-inline">single</strong> package in the <strong class="source-inline">presentation-user</strong> module so that it instead uses the <strong class="source-inline">Load</strong> action:<p class="source-code">@Composable</p><p class="source-code">fun UserScreen(</p><p class="source-code">    viewModel: UserViewModel,</p><p class="source-code">    userInput: UserInput</p><p class="source-code">) {</p><p class="source-code">    viewModel.<strong class="bold">uiStateFlow</strong>.collectAsState().value.let { </p><p class="source-code">        result -&gt;</p><p class="source-code">        CommonScreen(result) { userModel -&gt;</p><p class="source-code">            User(userModel)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">LaunchedEffect(userInput.userId) {</strong></p><p class="source-code">        <strong class="bold">viewModel.submitAction(UserUiAction.</strong></p><p class="source-code"><strong class="bold">            Load(userInput.userId))</strong></p><p class="source-code">    <strong class="bold">}</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>In this snippet, we are following the same principle as in <strong class="source-inline">PostScreen</strong> where we replace the interaction with <strong class="source-inline">UserViewModel</strong> to use the <strong class="source-inline">submitAction</strong> method and<a id="_idIndexMarker671"/> use <strong class="source-inline">LaunchedEffect</strong> to isolate the data loading.</p>
			<p>If we run the application, we will see the same output as in <em class="italic">Exercise 08.02 – Multi-module data presentation</em>:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_9.02_B18320_Merged.jpg" alt="Figure 9.2 – Output of Exercise 09.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Output of Exercise 09.01</p>
			<p>After introducing <a id="_idIndexMarker672"/>MVI into the exercise, we can see that we already had the groundwork because of how Jetpack Compose requires states to manage the user interface. This represents one of the reasons we ended up creating the <strong class="source-inline">UiState</strong> class in previous chapters. We have also observed the downsides of the pattern through the addition of boilerplate code and the handling of one-off events, the latter not being limited to MVI. The use of <strong class="source-inline">MviViewModel</strong> shows how we can have the same template across different modules of the presentation layer.</p>
			<p>From a Clean Architecture perspective, we can see that the changes we have done in our presentation layer haven't affected the rest of the layers of the application, which is a sign that we are going down the right path.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor104"/>Summary</h1>
			<p>In this chapter, we studied the MVI architecture pattern and the benefits it provides to applications using reactive streams of data, by centralizing user and application actions into a unidirectional flow of data. </p>
			<p>We then looked at how we can implement this pattern using Kotlin flows and the role it plays when combined with other patterns, such as MVP and MVVM, with a focus on MVVM. We can observe the downsides of the pattern on simple presentations, but its benefits become more visible in applications with complicated user interfaces that take in multiple user inputs, which can change the states of other inputs. In the chapter's exercise, we looked at how we can transition an application with MVVM to MVI and how it fits into Clean Architecture. </p>
			<p>In the next chapter, we will take a step back and look at what we have implemented and studied so far. We will see what we can improve and how we can take advantage of the different layers of the application, as well as how we can swap dependencies for the various configurations an application might have.</p>
		</div>
	</body></html>