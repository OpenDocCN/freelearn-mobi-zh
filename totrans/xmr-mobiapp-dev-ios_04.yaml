- en: Chapter 4. Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In iOS app development there has to be some form of a controller, as the iOS
    app development framework implements the **Model** **View Controller** (**MVC**)
    design pattern. Controllers in iOS are split into one of the two categories: tables
    or not tables. While I have touched upon the `TableView` methods when I discussed
    `MonoTouch.Dialog`, I''ve not actually given that much detail about them, which,
    given their importance with iOS, is rather disingenuous to say the least!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: UITableView and UITableViewCell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UINavigationController
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UITabBar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UIPageControl
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLKit View Controller
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UITableView and UITableViewCell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `TableView` method is the main workhorse for iOS. If you consider the likes
    of Facebook, e-mail, messages, Twitter, and many other applications, they display
    their data through a list-based interface. It may contain different attributes
    (such as images, header text, date and time, colors, and a range of other widgets),
    but at the end of the day, it's a table of data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting up a table, there are two formats it can take: *plain* and *grouped*.
    The grouped view is depicted in the following image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![UITableView and UITableViewCell](img/00023.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'The plain view can be viewed as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![UITableView and UITableViewCell](img/00024.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: The grouped approach is better suited to username/password or settings style
    information, while the plain view is best for purely list-based information (such
    as city names, chemical elements, or tweets).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: As the table requires data to propagate the view, it is usual for a delegate
    (or source) class to be defined as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Each of the elements in the preceding screenshot (such as **Brea**, **Burlingame**,
    and **Canoga Park**) uses `UITableViewCell`. The data can be entered or edited
    in these cells.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating a read-only table
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within Xcode, I've created a table, and into this I created another table and
    added a number of English Premiership teams. The simplest way to do this is through
    a list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple code results in the following image. All that the code has done
    is taken the view created in Xcode and displayed the data. This is the simplest
    form the table can take:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a read-only table](img/00025.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: '**Liverpool** has been selected (in blue), but we''re not doing anything with
    it. The beauty of the `UITableView` class is the power behind it. When a cell
    has been selected, it can be used to navigate elsewhere, have data entered in
    it, or just simply put a checkmark next to the selected cell value!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the code to react to a cell being selected, another override has
    to be added to `myViewSource`, namely:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On top of `RowSelected`, the `UITableView` control provides a `DetailDisclosureButton`—this
    button allows multiple actions to occur within a cell. (So let''s say that we
    have a periodic table of elements with a picture and a book icon next to the name:
    clicking on the name gives the atomic details and a picture of what the element
    looks like, and the book icon gives the history.) To enable this within the `GetCell`
    method, consider the following line of code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other options available for `UITableViewAccessory` are `Checkmark` (single or
    multiselection within a table), `Disclosure` (a gray arrow indicating that touching
    the cell results in navigation), and `DetailDisclosure` (a white arrow). `UITableViewAccessory`
    also has a `None` option that has a placement position but nothing in it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: UITableViewCell
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TableViewCell` is plain to look at by default. As with everything in iOS,
    the cells can be altered in a number of ways. Cells always start off as `UITableViewCellStyle.Default`.
    This supports a `TextLabel` component with an optional image on its left side.
    The other styles are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| UITableViewCellStyle | What it does |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `Subtitle` | Gives two left-aligned fields: `TextLabel` and `DetailTextLabel`.
    An image can be optionally added to the left of both of these. `DetailTextLabel`
    is in gray and has a smaller font size than `TextLabel`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `Value1` | In this, `TextLabel` is right-aligned and blue. `DetailTextLabel`
    is black and left-aligned. No optional images are available. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `Value2` | In this, `TextLabel` is left-aligned and black. `DetailTextLabel`
    is right-aligned and blue. No optional images are available. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: Reusable cells within a table
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `CollectionView`, the `TableView` methods also reuse cells. The reuse
    is simply to prevent the app from running out of memory and slowing down. To this
    end, the default is for only 10 cells to be displayed at any one time (though
    this number may vary depending on the cells and the `UITableView` height).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: To enable this reuse, the cell in my example needs to be instantiated using
    a different one of the overloads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `reuseID` is the identifier that the table uses to identify
    the cell to be reused.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: To fully demonstrate this, I have extended the list of teams in our original
    example and amended the `GetCell` method. All other code remains the same.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sections and Rows
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grouped data is made simpler to handle with `UITableView` as they use a `Section`
    and `Row` system to identify cells (these are the two parameters of `NSIndexPath`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Indexes on a TableView
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By overriding `SectionIndexTitles`, an index table can be added to the right
    side of a table. Clicking on an item on the index table will jump the table to
    that value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Customizing a `UITableViewCell` component can be performed in or out of Xcode.
    To be honest, the simplest way is doing it in Xcode. Drag a cell to an empty view
    and add the widgets you want in there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Navigation with UITableView
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigation with tables is provided by `UINavigationController`. Simply put,
    `NavigationController` allows you to move between table views with the standard
    back button at the top of the screen. The navigation controller can be set up
    using Xcode or purely with code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Within code
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up the `NavigationController` is performed within the `AppDelegate.cs`
    file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This places the navigation bar at the top of the screen. When a new view is
    shown, the back button becomes visible. The back button can be hidden using the
    following line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `NavigationController` can also be hidden using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem here is that as you go forward to a view and back again, the bar
    will no longer be hidden. The code that has to be called is the `ViewWillAppear`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: With Xcode
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a couple of ways of using `NavigationController` within Xcode. However,
    they can be quite painful to use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![With Xcode](img/00026.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: '**Navigation Controller** (Image B) creates a view with the controller bar
    at the top. It has the big advantage of having both the navigation section and
    an area for a view controller to be loaded into (Image A). To use this, simply
    create a view controller as you would. Within the `RootViewController` source,
    the following will load the other `ViewController` into the `RootViewController`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each navigation controller requires a bar with an optional navigation controller
    button.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![With Xcode](img/00027.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'The title bar can also be placed into a typical view and connected in the standard
    way. **Navigation Item** is not what it seems. By the looks of the item, it would
    be presumed that the button can be used for the likes of a back button, menu button,
    or the buttons that can be placed on the title bar. *It isn''t!* For that, `ButtonBarItem`
    has to be added to the title bar directly and the **Navigation Item** should be
    connected to the bar, which can be seen as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![With Xcode](img/00028.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Drag the **Navigation Item** (Image D) to the bar so that it is under the View
    icon (Image C). Drag the **Bar Button Item** onto a title bar already on the view.
    This will give you a bar with a button on the left (assuming you placed it on
    the left). The next stage is to connect the **Navigation Item** to the button
    on the bar. To do this, press the *Shift* button and drag the **Navigation Item**
    onto the **Bar Button Item**. When that has been done, you will see a menu giving
    you the option of what that item represents, shown as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![With Xcode](img/00029.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Selecting **backBarButtonItem** will give the back button. If you select **leftBarButtonItem**
    or **rightBarButtonItem**, these will give a button that can be used for other
    purposes (such as icons for an address book, or menu). To check whether the connection
    has been made, the outlet''s connection on the right will confirm it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![With Xcode](img/00030.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'To access the `backBarButtonItem` within the code, something akin to the following
    can be used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Navigation using UITableView
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, I will assume that the view already has a valid table with some
    data in it. One of the key points of the `UITableView` is that the user can select
    a table cell and that cell can be moved to another view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'For the following line of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To start a new `ViewController`, we need to do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will start a new view, and when the back button is selected the view reappears.
    The **backBarButtonItem** title will show the title of the view that started the
    new view. `DeselectRow` removes the blue selection color from the view. If it
    is not called when the back button is pressed, the selection will still show as
    being selected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the RootView
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To return to the top level of the view, use the following method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TabBars
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`A`nother simple method of navigation is through `UITabBar`. Typically, the
    bars are at the bottom of the screen, but there is nothing to stop a view having
    a `UITabBar` at the top of the screen as well.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![TabBars](img/00031.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Placing a tab bar on a view is the same as placing any other view onto a screen;
    drag it onto the screen. By default, two `TabBarItem` items are added to `TabBar`.
    You can add more by dragging the **Tab Bar Item** widget onto the bar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Each `TabBarItem` has a `Title` and `Image` property that can be set; however,
    these buttons must be set as **Custom** type within Xcode.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The two **Space Bar Button Item** components allow for button items to be added
    to a view with space between them. **Fixed** has a finite amount of space between
    buttons, while **Flexible** allows more buttons to be added but for them to be
    kept at equidistant.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The `TabBar` components are not the same as the other mechanisms for navigation.
    While a `TabBarItem` can certainly start a new view, it is more common that the
    same view is used all the time but the new view controller is loaded into the
    blank frame between the navigation bar (or whatever you have at the top of the
    screen and the `TabBarItem` at the bottom).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The `TabBarItem` components are also good if a view containing the `TabBar`
    is generating the view dynamically and displaying on screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Tab Bar in code
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within your code, it is not the **Tab Bar Item** that needs to be handled with
    events but the **Tab Bar** itself. The **Tab Bar Item** components will still
    need connecting, so they can be handled within the main controller source.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Possibly the simplest method of determining which **Tab Bar Item** has been
    selected is to set the `Tag` property on each (either in Xcode or in controller
    source). In `TabBarSelected`, the correct `TabBarItem` can then be found.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: PageControl
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UIPageControl` method is a handy mechanism to mark that we have multiple
    pages on a single view. It is typically used with a `UIScrollView` to display
    the index of the page in `UIScrollView`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![PageControl](img/00032.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: They can also be used for navigation. When you click on the left or right side
    of the page, an event is thrown for page movement. The number of dots indicates
    the number of pages. This number can always be altered in the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用于导航。当你点击页面左侧或右侧时，会抛出一个事件以实现页面移动。点的数量表示页数。这个数字可以在代码中随时更改。
- en: GLKit
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLKit
- en: A `GLKit` view enables the use of **OpenGL for Embedded Systems** (**OpenGL
    ES**) in an application. Animation and graphics are outside the scope of this
    book, but there are a large number of Xamarin.iOS examples available that can
    demonstrate how to use OpenGL ES.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`GLKit`视图使应用程序能够使用**嵌入式系统的OpenGL**（**OpenGL ES**）。动画和图形不在此书的范围之内，但有许多Xamarin.iOS示例可用，可以演示如何使用OpenGL
    ES。'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given you the basics of the two most used forms of *Navigation*
    and *View*. While `UITableView` is undoubtedly extremely powerful, it is cumbersome
    when you have the ability to use the much simpler `MonoTouch.Dialog` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已向你介绍了两种最常用的导航和视图形式的基础知识。虽然`UITableView`无疑非常强大，但当你有能力使用更简单的`MonoTouch.Dialog`类时，它就显得有些繁琐。
