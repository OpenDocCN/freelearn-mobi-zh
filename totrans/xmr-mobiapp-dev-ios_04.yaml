- en: Chapter 4. Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。控制器
- en: 'In iOS app development there has to be some form of a controller, as the iOS
    app development framework implements the **Model** **View Controller** (**MVC**)
    design pattern. Controllers in iOS are split into one of the two categories: tables
    or not tables. While I have touched upon the `TableView` methods when I discussed
    `MonoTouch.Dialog`, I''ve not actually given that much detail about them, which,
    given their importance with iOS, is rather disingenuous to say the least!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 应用程序开发中，必须有一些形式的控制器，因为 iOS 应用程序开发框架实现了**模型-视图-控制器**（**MVC**）设计模式。iOS 中的控制器分为两类之一：表格或非表格。虽然我在讨论`MonoTouch.Dialog`时提到了`TableView`方法，但我实际上并没有给出很多细节，考虑到它们在
    iOS 中的重要性，这至少是相当不诚实的！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: UITableView and UITableViewCell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UITableView 和 UITableViewCell
- en: UINavigationController
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UINavigationController
- en: UITabBar
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UITabBar
- en: UIPageControl
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UIPageControl
- en: GLKit View Controller
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLKit 视图控制器
- en: UITableView and UITableViewCell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UITableView 和 UITableViewCell
- en: A `TableView` method is the main workhorse for iOS. If you consider the likes
    of Facebook, e-mail, messages, Twitter, and many other applications, they display
    their data through a list-based interface. It may contain different attributes
    (such as images, header text, date and time, colors, and a range of other widgets),
    but at the end of the day, it's a table of data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableView` 方法是 iOS 中的主要工作马。如果你考虑像 Facebook、电子邮件、消息、Twitter 以及许多其他应用程序，它们通过基于列表的界面来显示数据。它可能包含不同的属性（如图像、标题文本、日期和时间、颜色以及一系列其他小部件），但最终，它是一个数据表。'
- en: 'When setting up a table, there are two formats it can take: *plain* and *grouped*.
    The grouped view is depicted in the following image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置表格时，它可以采用两种格式：*纯文本*和*分组*。分组视图在以下图像中展示：
- en: '![UITableView and UITableViewCell](img/00023.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![UITableView 和 UITableViewCell](img/00023.jpeg)'
- en: 'The plain view can be viewed as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本视图可以如下查看：
- en: '![UITableView and UITableViewCell](img/00024.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![UITableView 和 UITableViewCell](img/00024.jpeg)'
- en: The grouped approach is better suited to username/password or settings style
    information, while the plain view is best for purely list-based information (such
    as city names, chemical elements, or tweets).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 分组方法更适合用户名/密码或设置风格的信息，而纯文本视图最适合纯列表信息（如城市名称、化学元素或推文）。
- en: As the table requires data to propagate the view, it is usual for a delegate
    (or source) class to be defined as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表格需要数据来传播视图，因此通常还会定义一个代理（或源）类。
- en: Each of the elements in the preceding screenshot (such as **Brea**, **Burlingame**,
    and **Canoga Park**) uses `UITableViewCell`. The data can be entered or edited
    in these cells.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前一截图中的每个元素（如**Brea**、**Burlingame**和**Canoga Park**）都使用了`UITableViewCell`。数据可以在这些单元格中输入或编辑。
- en: Creating a read-only table
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建只读表格
- en: Within Xcode, I've created a table, and into this I created another table and
    added a number of English Premiership teams. The simplest way to do this is through
    a list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，我创建了一个表格，并在其中创建另一个表格并添加了一些英格兰超级联赛球队。最简单的方法是通过列表来实现。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple code results in the following image. All that the code has done
    is taken the view created in Xcode and displayed the data. This is the simplest
    form the table can take:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码产生了以下图像。代码所做的只是从 Xcode 中创建的视图显示数据。这是表格最简单的形式：
- en: '![Creating a read-only table](img/00025.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建只读表格](img/00025.jpeg)'
- en: '**Liverpool** has been selected (in blue), but we''re not doing anything with
    it. The beauty of the `UITableView` class is the power behind it. When a cell
    has been selected, it can be used to navigate elsewhere, have data entered in
    it, or just simply put a checkmark next to the selected cell value!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**利物浦**已被选中（以蓝色显示），但我们并没有对它做任何事情。`UITableView`类的美妙之处在于其背后的力量。当一个单元格被选中时，它可以用来导航到其他地方，在其中输入数据，或者只是简单地在一个选中的单元格值旁边放置一个勾选标记！'
- en: 'To enable the code to react to a cell being selected, another override has
    to be added to `myViewSource`, namely:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使代码能够对单元格的选择做出反应，必须在`myViewSource`中添加另一个重写，即：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On top of `RowSelected`, the `UITableView` control provides a `DetailDisclosureButton`—this
    button allows multiple actions to occur within a cell. (So let''s say that we
    have a periodic table of elements with a picture and a book icon next to the name:
    clicking on the name gives the atomic details and a picture of what the element
    looks like, and the book icon gives the history.) To enable this within the `GetCell`
    method, consider the following line of code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RowSelected` 之上，`UITableView` 控件提供了一个 `DetailDisclosureButton`——此按钮允许在单元格内执行多个操作。（比如说，我们有一个元素周期表，旁边有图片和书图标：点击名称会显示原子详情和元素的图片，而书图标会显示历史。）要在
    `GetCell` 方法中启用此功能，请考虑以下代码行：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other options available for `UITableViewAccessory` are `Checkmark` (single or
    multiselection within a table), `Disclosure` (a gray arrow indicating that touching
    the cell results in navigation), and `DetailDisclosure` (a white arrow). `UITableViewAccessory`
    also has a `None` option that has a placement position but nothing in it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的其他 `UITableViewAccessory` 选项包括 `Checkmark`（在表格中的单选或多选）、`Disclosure`（一个灰色箭头，表示触摸单元格会导致导航）和
    `DetailDisclosure`（一个白色箭头）。`UITableViewAccessory` 还有一个 `None` 选项，它有一个放置位置但没有内容。
- en: UITableViewCell
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`UITableViewCell`'
- en: '`TableViewCell` is plain to look at by default. As with everything in iOS,
    the cells can be altered in a number of ways. Cells always start off as `UITableViewCellStyle.Default`.
    This supports a `TextLabel` component with an optional image on its left side.
    The other styles are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`TableViewCell` 看起来很简洁。与 iOS 中的所有内容一样，单元格可以通过多种方式修改。单元格始终以 `UITableViewCellStyle.Default`
    开始。这支持一个带有可选左侧图片的 `TextLabel` 组件。其他样式包括：
- en: '| UITableViewCellStyle | What it does |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `UITableViewCellStyle` | 它的作用 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Subtitle` | Gives two left-aligned fields: `TextLabel` and `DetailTextLabel`.
    An image can be optionally added to the left of both of these. `DetailTextLabel`
    is in gray and has a smaller font size than `TextLabel`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Subtitle` | 提供两个左对齐字段：`TextLabel` 和 `DetailTextLabel`。可以可选地将图片添加到这两个字段的左侧。`DetailTextLabel`
    为灰色，字体大小比 `TextLabel` 小。 |'
- en: '| `Value1` | In this, `TextLabel` is right-aligned and blue. `DetailTextLabel`
    is black and left-aligned. No optional images are available. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Value1` | 在这个例子中，`TextLabel` 是右对齐且为蓝色。`DetailTextLabel` 是黑色且左对齐。没有可选的图片可用。
    |'
- en: '| `Value2` | In this, `TextLabel` is left-aligned and black. `DetailTextLabel`
    is right-aligned and blue. No optional images are available. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Value2` | 在这个例子中，`TextLabel` 是左对齐且为黑色。`DetailTextLabel` 是右对齐且为蓝色。没有可选的图片可用。
    |'
- en: Reusable cells within a table
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格中的可重用单元格
- en: As with `CollectionView`, the `TableView` methods also reuse cells. The reuse
    is simply to prevent the app from running out of memory and slowing down. To this
    end, the default is for only 10 cells to be displayed at any one time (though
    this number may vary depending on the cells and the `UITableView` height).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `CollectionView` 类似，`TableView` 方法也重用单元格。重用的目的是为了防止应用程序耗尽内存并减慢速度。为此，默认情况下，任何一次只显示
    10 个单元格（尽管这个数字可能因单元格和 `UITableView` 的高度而有所不同）。
- en: To enable this reuse, the cell in my example needs to be instantiated using
    a different one of the overloads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这种重用，我示例中的单元格需要使用不同的重载之一进行实例化。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `reuseID` is the identifier that the table uses to identify
    the cell to be reused.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`reuseID` 是表格用来识别要重用单元格的标识符。
- en: To fully demonstrate this, I have extended the list of teams in our original
    example and amended the `GetCell` method. All other code remains the same.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全展示这一点，我扩展了我们原始示例中的团队列表，并修改了 `GetCell` 方法。所有其他代码保持不变。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sections and Rows
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分（Sections）和行（Rows）
- en: Grouped data is made simpler to handle with `UITableView` as they use a `Section`
    and `Row` system to identify cells (these are the two parameters of `NSIndexPath`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UITableView` 可以简化分组数据的处理，因为它们使用 `Section` 和 `Row` 系统来识别单元格（这些是 `NSIndexPath`
    的两个参数）。
- en: Indexes on a TableView
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TableView 上的索引
- en: By overriding `SectionIndexTitles`, an index table can be added to the right
    side of a table. Clicking on an item on the index table will jump the table to
    that value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写 `SectionIndexTitles`，可以在表格的右侧添加一个索引表。点击索引表中的项目将使表格跳转到该值。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Customizing a `UITableViewCell` component can be performed in or out of Xcode.
    To be honest, the simplest way is doing it in Xcode. Drag a cell to an empty view
    and add the widgets you want in there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中或外部自定义 `UITableViewCell` 组件。说实话，最简单的方法是在 Xcode 中进行。将单元格拖动到空白视图中，并添加您想要其中的小部件。
- en: Navigation with UITableView
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `UITableView` 进行导航
- en: Navigation with tables is provided by `UINavigationController`. Simply put,
    `NavigationController` allows you to move between table views with the standard
    back button at the top of the screen. The navigation controller can be set up
    using Xcode or purely with code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController`提供了带有表格的导航。简单来说，`NavigationController`允许你通过屏幕顶部的标准返回按钮在表视图之间移动。可以使用Xcode或纯代码设置导航控制器。'
- en: Within code
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中
- en: Setting up the `NavigationController` is performed within the `AppDelegate.cs`
    file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppDelegate.cs`文件中设置`NavigationController`。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This places the navigation bar at the top of the screen. When a new view is
    shown, the back button becomes visible. The back button can be hidden using the
    following line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导航栏放置在屏幕顶部。当显示新视图时，返回按钮变得可见。可以使用以下代码行隐藏返回按钮：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `NavigationController` can also be hidden using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法隐藏`NavigationController`：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem here is that as you go forward to a view and back again, the bar
    will no longer be hidden. The code that has to be called is the `ViewWillAppear`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，当你向前到一个视图并返回时，栏将不再隐藏。必须调用的代码是`ViewWillAppear`方法。
- en: With Xcode
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Xcode
- en: There are a couple of ways of using `NavigationController` within Xcode. However,
    they can be quite painful to use.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中使用`NavigationController`有几种方法。然而，它们可能很难使用。
- en: '![With Xcode](img/00026.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode](img/00026.jpeg)'
- en: '**Navigation Controller** (Image B) creates a view with the controller bar
    at the top. It has the big advantage of having both the navigation section and
    an area for a view controller to be loaded into (Image A). To use this, simply
    create a view controller as you would. Within the `RootViewController` source,
    the following will load the other `ViewController` into the `RootViewController`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航控制器**（图像B）创建一个视图，其中控制器栏位于顶部。它有一个大优点，即既有导航部分，也有用于加载视图控制器区域（图像A）。要使用它，只需创建一个视图控制器，就像你通常做的那样。在`RootViewController`源中，以下代码将其他`ViewController`加载到`RootViewController`中：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each navigation controller requires a bar with an optional navigation controller
    button.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个导航控制器都需要一个带有可选导航控制器按钮的栏。
- en: '![With Xcode](img/00027.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode](img/00027.jpeg)'
- en: 'The title bar can also be placed into a typical view and connected in the standard
    way. **Navigation Item** is not what it seems. By the looks of the item, it would
    be presumed that the button can be used for the likes of a back button, menu button,
    or the buttons that can be placed on the title bar. *It isn''t!* For that, `ButtonBarItem`
    has to be added to the title bar directly and the **Navigation Item** should be
    connected to the bar, which can be seen as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 标题栏也可以放置到典型视图中，并以标准方式连接。**导航项**并不像它看起来那样。从项的外观来看，人们可能会认为按钮可以用于类似返回按钮、菜单按钮或可以放置在标题栏上的按钮。**并不是这样**！为此，需要直接在标题栏上添加`BarButtonItem`，并将**导航项**连接到栏，如下所示：
- en: '![With Xcode](img/00028.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode](img/00028.jpeg)'
- en: 'Drag the **Navigation Item** (Image D) to the bar so that it is under the View
    icon (Image C). Drag the **Bar Button Item** onto a title bar already on the view.
    This will give you a bar with a button on the left (assuming you placed it on
    the left). The next stage is to connect the **Navigation Item** to the button
    on the bar. To do this, press the *Shift* button and drag the **Navigation Item**
    onto the **Bar Button Item**. When that has been done, you will see a menu giving
    you the option of what that item represents, shown as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Navigation Item**（图像D）拖到栏上，使其位于视图图标（图像C）下方。将**Bar Button Item**拖到视图上已经存在的标题栏上。这将为你提供一个带有左侧按钮的栏（假设你将其放置在左侧）。下一步是将**Navigation
    Item**连接到栏上的按钮。为此，按下*Shift*按钮并将**Navigation Item**拖到**Bar Button Item**上。完成此操作后，你将看到一个菜单，显示该项代表的内容，如下所示：
- en: '![With Xcode](img/00029.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode](img/00029.jpeg)'
- en: 'Selecting **backBarButtonItem** will give the back button. If you select **leftBarButtonItem**
    or **rightBarButtonItem**, these will give a button that can be used for other
    purposes (such as icons for an address book, or menu). To check whether the connection
    has been made, the outlet''s connection on the right will confirm it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**backBarButtonItem**将得到返回按钮。如果你选择**leftBarButtonItem**或**rightBarButtonItem**，这些将提供可用于其他目的的按钮（例如地址簿的图标或菜单）。要检查是否已建立连接，可以在右侧的输出连接上确认：
- en: '![With Xcode](img/00030.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Xcode](img/00030.jpeg)'
- en: 'To access the `backBarButtonItem` within the code, something akin to the following
    can be used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中访问`backBarButtonItem`，可以使用以下类似的方法：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Navigation using UITableView
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 UITableView 进行导航
- en: At this point, I will assume that the view already has a valid table with some
    data in it. One of the key points of the `UITableView` is that the user can select
    a table cell and that cell can be moved to another view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我将假设视图已经有一个有效的表，其中包含一些数据。`UITableView` 的一个关键点是用户可以选择一个表格单元格，并且该单元格可以被移动到另一个视图中。
- en: 'For the following line of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下代码行：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To start a new `ViewController`, we need to do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个新的 `ViewController`，我们需要做以下事情：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will start a new view, and when the back button is selected the view reappears.
    The **backBarButtonItem** title will show the title of the view that started the
    new view. `DeselectRow` removes the blue selection color from the view. If it
    is not called when the back button is pressed, the selection will still show as
    being selected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的视图，当选择返回按钮时，视图重新出现。**backBarButtonItem** 标题将显示启动新视图的视图的标题。`DeselectRow`
    从视图中移除蓝色选择颜色。如果按下返回按钮时没有调用它，选择仍然会显示为选中状态。
- en: Returning to the RootView
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回到 RootView
- en: 'To return to the top level of the view, use the following method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到视图的顶层，使用以下方法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: TabBars
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签栏
- en: '`A`nother simple method of navigation is through `UITabBar`. Typically, the
    bars are at the bottom of the screen, but there is nothing to stop a view having
    a `UITabBar` at the top of the screen as well.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简单的导航方法是通过 `UITabBar`。通常，这些条形位于屏幕底部，但没有任何阻止视图在屏幕顶部也拥有 `UITabBar` 的东西。
- en: '![TabBars](img/00031.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![TabBars](img/00031.jpeg)'
- en: Placing a tab bar on a view is the same as placing any other view onto a screen;
    drag it onto the screen. By default, two `TabBarItem` items are added to `TabBar`.
    You can add more by dragging the **Tab Bar Item** widget onto the bar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将标签栏放置在视图中与将任何其他视图放置在屏幕上相同；将其拖到屏幕上。默认情况下，`TabBar` 中添加了两个 `TabBarItem` 项目。您可以通过将
    **Tab Bar Item** 小部件拖到条上添加更多。
- en: Each `TabBarItem` has a `Title` and `Image` property that can be set; however,
    these buttons must be set as **Custom** type within Xcode.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `TabBarItem` 都有一个 `Title` 和 `Image` 属性可以设置；然而，这些按钮必须在 Xcode 中设置为 **Custom**
    类型。
- en: The two **Space Bar Button Item** components allow for button items to be added
    to a view with space between them. **Fixed** has a finite amount of space between
    buttons, while **Flexible** allows more buttons to be added but for them to be
    kept at equidistant.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 **Space Bar Button Item** 组件允许在视图之间添加按钮项，并保持它们之间有空间。**Fixed** 之间有有限的空间，而
    **Flexible** 允许添加更多按钮，但保持它们等距。
- en: The `TabBar` components are not the same as the other mechanisms for navigation.
    While a `TabBarItem` can certainly start a new view, it is more common that the
    same view is used all the time but the new view controller is loaded into the
    blank frame between the navigation bar (or whatever you have at the top of the
    screen and the `TabBarItem` at the bottom).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`TabBar` 组件与其他导航机制不同。虽然 `TabBarItem` 当然可以启动一个新的视图，但更常见的是始终使用相同的视图，但新的视图控制器被加载到导航栏（或屏幕顶部的任何内容）和底部
    `TabBarItem` 之间的空白框架中。'
- en: The `TabBarItem` components are also good if a view containing the `TabBar`
    is generating the view dynamically and displaying on screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包含 `TabBar` 的视图正在动态生成视图并在屏幕上显示，`TabBarItem` 组件也是很好的。
- en: Handling the Tab Bar in code
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中处理标签栏
- en: Within your code, it is not the **Tab Bar Item** that needs to be handled with
    events but the **Tab Bar** itself. The **Tab Bar Item** components will still
    need connecting, so they can be handled within the main controller source.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，需要处理事件的是 **Tab Bar** 而不是 **Tab Bar Item**。**Tab Bar Item** 组件仍然需要连接，因此它们可以在主控制器源中处理。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Possibly the simplest method of determining which **Tab Bar Item** has been
    selected is to set the `Tag` property on each (either in Xcode or in controller
    source). In `TabBarSelected`, the correct `TabBarItem` can then be found.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确定哪个 **Tab Bar Item** 被选中的可能最简单的方法是在每个项目上设置 `Tag` 属性（无论是在 Xcode 中还是在控制器源中）。在
    `TabBarSelected` 中，可以找到正确的 `TabBarItem`。
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: PageControl
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面控制
- en: The `UIPageControl` method is a handy mechanism to mark that we have multiple
    pages on a single view. It is typically used with a `UIScrollView` to display
    the index of the page in `UIScrollView`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPageControl` 方法是一个方便的机制，用于标记我们在单个视图中有多页。它通常与 `UIScrollView` 一起使用，以显示 `UIScrollView`
    中的页面索引。'
- en: '![PageControl](img/00032.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![PageControl](img/00032.jpeg)'
- en: They can also be used for navigation. When you click on the left or right side
    of the page, an event is thrown for page movement. The number of dots indicates
    the number of pages. This number can always be altered in the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用于导航。当你点击页面左侧或右侧时，会抛出一个事件以实现页面移动。点的数量表示页数。这个数字可以在代码中随时更改。
- en: GLKit
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLKit
- en: A `GLKit` view enables the use of **OpenGL for Embedded Systems** (**OpenGL
    ES**) in an application. Animation and graphics are outside the scope of this
    book, but there are a large number of Xamarin.iOS examples available that can
    demonstrate how to use OpenGL ES.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`GLKit`视图使应用程序能够使用**嵌入式系统的OpenGL**（**OpenGL ES**）。动画和图形不在此书的范围之内，但有许多Xamarin.iOS示例可用，可以演示如何使用OpenGL
    ES。'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given you the basics of the two most used forms of *Navigation*
    and *View*. While `UITableView` is undoubtedly extremely powerful, it is cumbersome
    when you have the ability to use the much simpler `MonoTouch.Dialog` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已向你介绍了两种最常用的导航和视图形式的基础知识。虽然`UITableView`无疑非常强大，但当你有能力使用更简单的`MonoTouch.Dialog`类时，它就显得有些繁琐。
