<html><head></head><body><h1 id="e-uBRf">Chapter 6. Making Your App Orientation-aware</h1>
<p id="e-ziH3">This chapter will walk you through the process of dealing with the Android application behavior on device configuration changes. In the course of this chapter, we will cover comprehensive details of the theoretical concepts, but we will not make any significant changes to the <code>POIApp</code>. The following topics will be covered in this chapter:</p>
<ul id="e-Wajk">
<li id="e-xrQj">The Android behavior on configuration changes</li>
<li id="e-cqno">Locking the Android application orientation</li>
<li id="e-i29k">Saving the activity state for configuration changes</li>
<li id="e-df2B">Adding alternative resources</li>
<li id="e-R0UT">Manually handling the orientation behavior</li>
</ul>
<h1 id="e-biRt">The Android behavior on configuration changes</h1>
<p id="e-ljAf">All modern smartphones and tablets switch between portrait and landscape modes in response to the way a user rotates the device. The Android application is expected to respond to the configuration changes and displays appropriate layouts for the current device configuration. The Android device configuration can be changed at runtime in many forms, such as device orientation changes, device language changes, device font updates, device connected to external displays, device connected to docks, and so on. In all of the earlier cases, Android restarts the running activity, loads alternative resources if available, to properly load your application for the given configurations. The activity goes through a series of life cycle methods, such as <code>OnDestroy()</code>, followed by <code>OnCreate()</code> to deal with the activity restart behavior.</p>
<p id="e-EeTn">For example, if you are running your application on Nexus 5 device with 1080 x 1920 resolution in the portrait mode, and while the orientation changes to landscape, the application has to respond appropriately to fit the layout and its child views for the 1920 x 1080 dimension. You may ask why not just adjust the view in the layout to fit to the appropriate size? Why should the activity be restarted? Well, Android does this to keep things simple. However, internally, it does many things and provides some of the advance features to make the configuration changes smoother.</p>
<p id="e-nOBB">If the device configuration changes, Android destroys and restarts only the activity in the foreground, but the application instance still remains unchanged. When the activity restarts, the appropriate layout for that configuration is loaded. For such events, it is important that your application must restore the state of your activity and the user entered data on the UI. This can be possible using the <code>OnSaveInstanceState()</code> and <code>OnRestoreInstanceState()</code> callback methods.</p>
<p id="e-c8KT">This chapter tackles some of the key points to build smooth, responsive, and orientation aware applications.</p>

<h1 id="e-cpYw">Locking the Android application orientation</h1>
<p id="e-DObW">According to the Google design guidelines, the Android application must respond to the device orientation and display an appropriate layout for the given orientation. However, some kind of applications, such as games, video players, and so on, are intended to restrict the orientation to landscape or portrait only. For native Android applications, this can be achieved using the <code>android:screenOrientation</code> property to the <code>&amp;lt;activity&amp;gt;</code> declaration in the <code>AndroidManifest.xml</code> descriptor file. Xamarin makes this even simplified and recommends that you do not to edit the <code>AndroidManifest.xml</code> file manually at any point of time, instead it allows you to set all the application configuration metadata using <code>[Activity]</code> attribute custom properties to the activity declaration.</p>
<p id="e-TFTY">As we recall from Chapter 3, <em>Creating the Points Of Interest App</em>, we are already using some of the properties of the <code>[Activity]</code> attribute, such as <code>Label</code>, <code>MainLauncher</code>, and <code>Icon</code>. Now to lock the activity orientation behavior, we can use the <strong>ScreenOrientation</strong> property on the activity class declaration. The <code>ScreenOrientation</code> property needs to be specified statically to each activity that requires control over the orientation lock. It cannot be controlled globally for the whole application scope.</p>
<p id="e-CK17">The <code>ScreenOrientation</code> attribute expects any one of the possible constants defined in the <code>Android.Content.PM.ScreenOrientation</code> enumeration. The <code>ScreenOrientation</code> enum defines all the set of device configuration constants such as <code>FullSensor</code>, <code>FullUser</code>, <code>Landscape</code>, <code>Locked</code>, <code>Nosensor</code>, <code>Portrait</code>, and so on.</p>
<p id="e-EXTw">For the complete set of <code>ScreenOrientation</code> constants, visit the official Xamarin.Android documentation at <a href="http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/">http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/</a>.</p>
<p id="e-wN5z">Note that in this book, we will build the <code>POIApp</code> to respond to the device orientation and other different configuration's change events. The following code block is used for demonstration purpose only and will not be continued along with the <code>POIApp</code> example code. You can add the following attributes to lock the <code>POIListActivity</code> orientation to landscape only:</p>
<pre id="e-zHDM">namespace POIApp
{
    [Activity (Label = "POI List", ScreenOrientation = ScreenOrientation.Landscape)]
    public class POIListActivity : Activity
    {
    &amp;#x2026;&amp;#x2026;
    &amp;#x2026;&amp;#x2026;&amp;#x2026;
    }
}</pre>
<p id="e-sEvm">Make the preceding changes to <code>POIListActivity</code> and run the app. You will notice that the POI list screen overrides the device orientation lock settings and it will always be shown in the landscape mode.</p>

<h1 id="e-CJc1">Dynamically requesting the orientation</h1>
<p id="e-e9qM">You can also change the desired activity orientation dynamically by setting the <code>RequestedOrientation</code> property to your activity. This allows further flexibility to dynamically change the orientation anytime as required. Add the following code snippet anywhere in your activity to restrict the currently running activity orientation to landscape only:</p>
<pre id="e-M7JH">RequestedOrientation = ScreenOrientation.Landscape;</pre>
<p id="e-IKLE">The changes made to the <code>RequestedOrientation</code> property has an impact on the activity in the foreground and a request for the specified orientation is made immediately by causing the current activity to restart. You can use the same property to obtain the current configuration that is in effect for the current activity.</p>

<h1 id="e-Srog">Saving the activity state for configuration changes</h1>
<p id="e-aHFL">Runtime configuration changes in the Android device cause the activity in the foreground to go through a restart process. This behavior is intended to simplify the process for the activity to reinitialize with alternative resources for the given configuration. As the activity goes through the recreation process, you might lose the user entered data or the current state of the activity. For any such course of events, all the Android applications must retain the activity state quickly and cheaply to avoid undesirable user experience. The following section will help you dive deeper to understand the process to retain the activity state.</p>
<p id="e-f7Od">With the configuration changes, the activity goes through a series of life cycle methods, such as <code>OnDestroy()</code> followed by <code>OnCreate()</code>. On its way, it calls <code>OnSaveInstanceState()</code> before it destroys the activity so that you can save the activity state data. The application state can be retained during the <code>onCreate()</code> or <code>OnRestoreInstanceState()</code> callback methods. To understand the whole process, we must recall the activity life cycle methods as described in Chapter 1, <em>The Anatomy of an Android App</em>. The following figure depicts the activity life cycle and the <code>OnSaveInstanceState</code> and <code>OnRestoreInstanceState ()</code> method's call flow with their respective configuration changes:</p>
<img data-width="700" data-height="292" src="img/zHkF0fQQ.jpg"/><p id="e-mGCg">A change in the orientation calls the <code>OnPause()</code>, <code>OnSaveInstanceState()</code>, <code>OnStop()</code>, and <code>OnDestroy()</code> methods followed by <code>OnCreate()</code>, <code>OnStart()</code>, <code>OnRestoreInstanceState()</code>, and <code>OnResume()</code>. Remember that this sequence is not always true. For example, when a user presses the device back button or calls the <code>Finish()</code> method, you do not need to save the activity state; hence, it just calls <code>OnPause()</code>, <code>OnStop()</code>, and <code>OnDestroy()</code>, but the <code>OnSaveInstanceState()</code> method is never called.</p>
<p id="e-ThDO">The default implementation of <code>OnSaveInstanceState()</code> and <code>OnRestoreInstanceState()</code> takes care of saving and retaining the data on all the Android view input widgets (for example, <code>EditText</code>, <code>CheckBox</code>, <code>RadioButton</code>, and so on) that are attached to the layout with an <code>id</code> property. This means that the Android SDK implements the <code>OnSaveInstanceState()</code> and the <code>OnRestoreInstanceState()</code> methods on each of the view controls.</p>
<p id="e-YjN4">Based on two factors, Android decides whether the state of a view attached to a view group will be retained in the orientation change. One factor is the <code>id</code> property and the other is based on the value set for the <code>view.SaveEnabled</code> property. The <code>SaveEnabled</code> property checks whether the <code>onSaveInstanceState()</code> method will be called on that view. The default value for <code>SaveEnabled</code> is <code>true</code>.</p>
<p id="e-xVVp">Apart from the <code>SaveEnabled</code> property, Android provides yet another interesting method that allows you to control the save state behavior for the entire hierarchy under a view. For example, if you have five different views under a <code>LinearLayout</code>, and you wish not to save state for all those five views, including <code>LinearLayout</code>, you can just achieve this by setting the <code>SaveFromParentEnabled</code> property of <code>LinearLayout</code> to <code>false</code>.</p>
<p id="e-XcSo">For applications using custom or compound views, you must handle the state restoration manually. You need to override the <code>OnSaveInstanceState()</code> and <code>OnRestoreInstanceState()</code> methods in your custom view implementation to store the state of your view.</p>
<h2 id="e-lhOp">Manually saving the activity state</h2>
<p id="e-fiCd">If you need to manually save the activity state, you must override the following methods in your activity and write your own logic to save and restore the activity state in data bundles. The <code>OnSaveInstanceState()</code> method supplies an instance of <code>Bundle</code> in which we can dump the data, and the <code>OnRestoreInstanceState()</code> method returns the previously saved <code>Bundle</code>.</p>
<p id="e-oDeb"><code>Bundle</code> is a special kind of container that provides the key/value maps of heterogeneous values. <code>Bundle</code> is generally used for parsing data from one activity to another or while saving and retrieving the view state. The <code>Bundle</code> class provides a set of overloaded <code>PutXXX()</code> and <code>GetXXX()</code> methods to store and retrieve the values.</p>
<p id="e-pbJY">The following code snippet depicts the <code>OnSaveInstanceState()</code> and <code>OnRestoreInstanceState()</code> methods' prototype:</p>
<pre id="e-gLKy">protected override void OnSaveInstanceState (Bundle outState)
{
  base.OnSaveInstanceState (outState);
  // Place your logic to save activity state 
}
 protected override void OnRestoreInstanceState (Bundle savedInstanceState)
{
  base.OnRestoreInstanceState (savedInstanceState);
  // Place your logic to restore activity state 
}</pre>
<h2 id="e-Zq5s">Retaining the POI list scroll position</h2>
<p id="e-lgcx">So far, we had quite a lot of ground on the activity life cycle behavior on configuration changes. Let's now implement it to <code>POIApp</code>. When the POI list grows, it allows the user to scroll vertically to see all of the list items. Let's say, the user has scrolled till the 10th element in the list, and in the meantime, the device orientation changed. Due to the device configuration change request, the activity restarted and causes the list to appear from the top. It is a good idea to retain the list scroll position for better user experience.</p>
<p id="e-v6ll">Let's perform the following steps to retain the POI list scroll position when the device configuration changes:</p>
<ol id="e-CXDi">
<li id="e-koy8">Get the index of the first visible list item and save it in <code>Bundle</code> in the <code>OnSaveInstanceState()</code> method:<pre id="e-KKVr">protected override void OnSaveInstanceState (Bundle outState)
{
  base.OnSaveInstanceState (outState); 
  int currentPosition = poiListView.FirstVisiblePosition;
  outState.PutInt ("scroll_position", currentPosition);
}</pre>
<p id="e-gJv3">In the preceding code snippet, the string <code>scroll_position</code> is used as the key to save the current scroll position of <code>ListView</code> on orientation change. The same key should be used while retrieving the data from the <code>OnRestoreInstanceState()</code> callback.</p>
</li>
<li id="e-ES62">Restore the saved list scrolling position in <code>OnRestoreInstanceState()</code>. Note that we have to use the same key that was used to save the current scroll position:<pre id="e-LWhm">int scrollPosition;
protected override void OnRestoreInstanceState (Bundle savedInstanceState)
{
  base.OnRestoreInstanceState (savedInstanceState);
  scrollPosition = savedInstanceState.GetInt ("scroll_position");
}</pre>
</li>
<li id="e-rFvx">Add the following code snippet to the <code>DownloadPoisListAsync()</code> method in the <code>POIListActivity</code> class and queue the message for scrolling the POI list to the last saved scroll position:<pre id="e-B2sE">poiListView.Post(() =&amp;gt; {
  poiListView.SetSelection(scrollPosition);
});</pre>
</li>
</ol>
<p id="e-u7wi">Now run the application and test the POI application by changing the orientation; notice that the scroll positions are retained.</p>

<h1 id="e-BUzK">Building the orientation-aware layout</h1>
<p id="e-W2to">Android allows you to add multiple competing versions of resources to make an application compatible with different device configurations. The Android system comes handy when it comes to picking up the right resources for a given configuration. You don't need to write any code to find what is the current configuration and choose the appropriate resources. All you need to do is to add multiple versions of resources, such as <code>string.xml</code>, <code>.png</code> drawable images, or layout XML files, so that the best version of resource can be picked up under different circumstances.</p>
<p id="e-uCh7">Imagine that your app was primarily targeted to the U.S. market, but now we are looking forward to targeting Russia with the Russian language support. In this case, multiple versions of <code>string.xml</code> can be added to support the Russian language. Or imagine that a user is running the app on a tablet in the portrait mode, and now the device rotates to the landscape orientation. The screen width gets doubled and provides the opportunity to display more information. In such cases, you will need to add multiple versions of activity layouts for different orientations. Let's hold our breath till the next chapter to learn more about how to build the orientation aware layout for Android tablets.</p>
<p id="e-YJfV">All the resources added to the application will be added to various subdirectories under the <code>Resources</code> directory. The default resource directory structure is shown as follows:</p>
<img data-width="313" data-height="254" src="img/YRuxqZab.jpg"/><p id="e-oesK">Any resource that is added as a default resource will be used when there are no alternative best match resources available for the given configuration. Alternative resources are designed for a specific configuration.</p>
<p id="e-Fwd6">To add alternative resources, you just need to use the specific configuration qualifier. The configuration qualifiers you can use for device screen sizes are small, normal, large, and xlarge. For example, layouts for an extra-large screen, such as a tablet layout, should go in the <strong>layout-xlarge</strong> directory. Since Android 3.2, Android recommends that you use the <code>sw&amp;lt;N&amp;gt;dp</code> configuration qualifier to define an extra-large layout for the tablet. For example, if your multipane tablet layout requires at least 600dp of screen width, you should place it in the layout-<code>sw600dp</code> directory.</p>
<p id="e-mO2c">To provide the translated version of the <code>strings.xml</code> file for Russian users, you have to place the <code>string.xml</code> file in the <code>Resources/values-ru/</code> directory.</p>
<p id="e-PjPe">The following table depicts the list of configuration qualifiers that allow you to provide special resources for different screen configurations:</p>
<p id="e-PKIJ">Characteristic</p>
<p id="e-mMrf">Qualifier</p>
<p id="e-F0I4">Description</p>
<p id="e-zGAs">Screen size</p>
<p id="e-PCD7">small, normal, large, and xlarge</p>
<p id="e-nHEr">Resources for small, normal, large, and extra-large screen sizes.</p>
<p id="e-rctf"> </p>
<p id="e-Lhka">l dpi</p>
<p id="e-kwEc">Resources for low-density (l dpi) screens (~120 dpi). You can now ignore this resource set, as no new Android devices with ldpi density are out in the market.</p>
<p id="e-lv6B">mdpi</p>
<p id="e-ZSx1">Resources for medium-density (mdpi) screens (~160 dpi). (This is the baseline density.)</p>
<p id="e-Cy5e">hdpi</p>
<p id="e-UrRY">Resources for high-density (hdpi) screens (~240 dpi).</p>
<p id="e-vFgC">xhdpi</p>
<p id="e-B1Rs">Resources for extra-high-density (xhdpi) screens (~320 dpi).</p>
<p id="e-H67a">xxhdpi</p>
<p id="e-Qdez">Resources for extra-extra-high-density (xxhdpi) screens (~480 dpi).</p>
<p id="e-TW84">xxxhdpi</p>
<p id="e-IKPT">Resources for extra-extra-extra-high-density (xxxhdpi) use (~640 dpi). Use this for the launcher icon only; see the earlier note.</p>
<p id="e-V4LE">nodpi</p>
<p id="e-vmvz">Resources for all densities. These are density-independent resources. The system does not scale resources tagged with this qualifier.</p>
<p id="e-QvhI">Device orientation</p>
<p id="e-s0na">land</p>
<p id="e-ZoJP">Resources for screens in the landscape orientation.</p>
<p id="e-c5Nb">port</p>
<p id="e-ih5W">Resources for screens in the portrait orientation.</p>
<p id="e-qRZb">Aspect ratio</p>
<p id="e-vpKB">long</p>
<p id="e-b5Cj">Resources for screens that have a significantly taller or wider aspect ratio (when in the portrait or landscape orientation, respectively) than the baseline screen configuration.</p>
<p id="e-tbNZ">notlong</p>
<p id="e-f64r">Resources for use screens that have an aspect ratio that is similar to the baseline screen configuration.</p>
<p id="e-FOgC">In the following Chapter 7, <em>Designing for Multiple Screen Sizes</em>, we will make use of the alternative layout resource to make the application compatible for Android tablets.</p>

<h1 id="e-U2T6">Manually handling the orientation behavior</h1>
<p id="e-D3Fk">As described, the Android system automatically takes care of updating appropriate resources when the configuration changes. However, at times due to performance reasons, you might like to restrict the activity restart and write your own logic to update appropriate resources for the given configuration. But remember that this is not recommended by the Google guidelines; if you're implementing this for your application, do it at your own risk.</p>
<p id="e-rYzD">The following steps will guide you to manually handle the required configuration for your app:</p>
<ol id="e-PZgo">
<li id="e-A9lv">Add the <code>ConfigurationChanges</code> attribute to the activity declaration. This allows you to declare all possible configurations values defined in <code>Android.Content.PM.ConfigChanges</code> that you want to handle yourself for your app. At runtime, this adds the <code>android:configChanges</code> attribute to your activity declaration in the <code>AndroidManifest.xml</code> file:<pre id="e-XdRB">[Activity (Label = "POI List", ConfigurationChanges= ConfigChanges.Orientation | ConfigChanges.KeyboardHidden)]
public class POIListActivity : Activity
{
---
}</pre>
<p id="e-el5S">In the preceding code syntax, we stated that we will be manually handling the configuration for the device orientation and sliding keyboard state changes. Note that the preceding declaration bypasses the whole activity destruction process and simply returns a callback to let you know about the changes.</p>
</li>
<li id="e-pjvy">Override <code>OnConfigurationChanged()</code> in your activity. This method will be called when one of the configuration changes, as listed in the <code>ConfigurationChanges</code> attribute declaration:<pre id="e-ZlGi">public override void OnConfigurationChanged (Android.Content.Res.Configuration newConfig)
{
  base.OnConfigurationChanged (newConfig);
  //update UI to reflect the orientation change
}</pre>
</li>
</ol>
<p id="e-SxJg">Here, in the <code>OnConfigurationChanged()</code> method, you need to update the UI so that it reflects the orientation change. For our <code>POIApp</code>, we allow the system to handle the configuration itself. Note that the all the code snippets used in this chapter are for demonstration purpose only, and we will not continue with these changes to build <code>POIApp</code> for rest of the chapters in this book.</p>

<h1 id="e-JCqW">Summary</h1>
<p id="e-mEct">In this chapter, we covered a lot of ground on the behavior of an activity when the device configuration is changed, forcing the activity to display a specified orientation and to save and restore the activity state. The next chapter will guide you to deal with designing applications for various device form factors such as Android tablets.</p>
</body></html>