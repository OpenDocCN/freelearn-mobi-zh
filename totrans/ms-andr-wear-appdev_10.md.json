["```java\nsetWatchFaceStyle(new WatchFaceStyle.Builder(mService) \n  .setAcceptsTapEvents(true) \n\n  // other style customizations \n  .build()); \n\n```", "```java\n<!— Required to act as a custom watch face. —> \n<uses-permission android:name=\"android.permission.WAKE_LOCK\" /> \n\n<service \n  android:name=\".TodayWatchFaceService\" \n  android:label=\"@string/digital_name\" \n  android:permission=\"android.permission.BIND_WALLPAPER\" > \n  <meta-data \n    android:name=\"android.service.wallpaper\" \n    android:resource=\"@xml/watch_face\" /> \n\n  <meta-data \n    android:name=\"com.google.android.wearable.watchface.preview\" \n    android:resource=\"@drawable/preview_digital\" /> \n\n  <meta-data \n    android:name=\"com.google.android.wearable.watchface.preview_circular\" \n    android:resource=\"@drawable/preview_digital_circular\" /> \n\n  <meta-data \n    android:name=\"com.google.android.wearable.watchface.companionConfigurationAction\" \n    android:value=\"com.siddique.androidwear.today.CONFIG_DIGITAL\"/> \n\n  <meta-data \n    android:name=\"com.google.android.wearable.watchface.wearableConfigurationAction\" \n    android:value=\"com.siddique.androidwear.today.CONFIG_DIGITAL\"/>  \n  <intent-filter> \n    <action android:name=\"android.service.wallpaper.WallpaperService\" /> \n\n    <category android:name=\"com.google.android.wearable.watchface.category.WATCH_FACE\" /> \n  </intent-filter> \n</service> \n\n<activity \n  android:name=\".WatchFaceConfigActivity\" \n  android:label=\"@string/digital_config_name\" > \n  <intent-filter> \n    <action android:name=\"com.siddique.androidwear.today.CONFIG_DIGITAL\" /> \n\n      <category android:name=\"com.google.android.wearable.watchface.category.WEARABLE_CONFIGURATION\" /> \n      <category android:name=\"android.intent.category.DEFAULT\" /> \n    </intent-filter> \n</activity> \n\n```", "```java\npublic class TodayWatchFaceService extends CanvasWatchFaceService { \n  @Override \n  public Engine onCreateEngine()  \n  { \n    return new Engine(); \n  } \n  private class Engine extends CanvasWatchFaceService.Engine  implements DataApi.DataListener,  GoogleApiClient.ConnectionCallbacks,  GoogleApiClient.OnConnectionFailedListener  \n  { \n    ... \n  } \n} \n\n```", "```java\n@Override \npublic void onTimeTick()  \n  { \n    super.onTimeTick(); \n    if (Log.isLoggable(TAG, Log.DEBUG))  \n    { \n      Log.d(TAG, \"onTimeTick: ambient = \" + isInAmbientMode()); \n    } \n  invalidate(); \n} \n\n```", "```java\n@Override \npublic void onDraw(Canvas canvas, Rect bounds)  \n{ \n  long now = System.currentTimeMillis(); \n  mCalendar.setTimeInMillis(now); \n  mDate.setTime(now); \n  boolean is24Hour =  DateFormat.is24HourFormat(TodayWatchFaceService.this); \n\n  // Show colons for the first half of each second so the colons blink on when the time \n  // updates. \n  mShouldDrawColons = (System.currentTimeMillis() % 1000) < 500; \n\n  // Draw the background. \n  canvas.drawRect(0, 0, bounds.width(), bounds.height(), mBackgroundPaint); \n\n  // Draw the hours. \n  float x = mXOffset; \n  String hourString; \n  if (is24Hour)  \n  { \n    hourString =  formatTwoDigitNumber(mCalendar.get(Calendar.HOUR_OF_DAY));   }  \n  else  \n  { \n    int hour = mCalendar.get(Calendar.HOUR); \n    if (hour == 0)  \n    { \n      hour = 12; \n    } \n    hourString = String.valueOf(hour); \n  } \n  canvas.drawText(hourString, x, mYOffset, mHourPaint); \n  x += mHourPaint.measureText(hourString); \n\n  // In ambient and mute modes, always draw the first colon.  Otherwise, draw the \n  // first colon for the first half of each second. \n  if (isInAmbientMode() || mMute || mShouldDrawColons)  \n  { \n    canvas.drawText(COLON_STRING, x, mYOffset, mColonPaint); \n  } \n  x += mColonWidth; \n\n  // Draw the minutes. \n  String minuteString =  formatTwoDigitNumber(mCalendar.get(Calendar.MINUTE)); \n  canvas.drawText(minuteString, x, mYOffset, mMinutePaint); \n  x += mMinutePaint.measureText(minuteString); \n\n  // In unmuted interactive mode, draw a second blinking colon  followed by the seconds. \n  // Otherwise, if we're in 12-hour mode, draw AM/PM \n  if (!isInAmbientMode() && !mMute)  \n  { \n    if (mShouldDrawColons)  \n    { \n      canvas.drawText(COLON_STRING, x, mYOffset, mColonPaint); \n    } \n  x += mColonWidth; \n  canvas.drawText(formatTwoDigitNumber(mCalendar.get(Calendar.SECOND)), x, mYOffset, mSecondPaint); \n  }  \n  else if (!is24Hour)  \n  { \n    x += mColonWidth; \n    canvas.drawText(getAmPmString(  mCalendar.get(Calendar.AM_PM)), x, mYOffset, mAmPmPaint); \n  } \n\n  // Only render the day of week and date if there is no peek card, so they do not bleed \n  // into each other in ambient mode. \n  if (getPeekCardPosition().isEmpty())  \n  { \n    if (tapCount == 0)  \n    { \n      // Day of week \n      canvas.drawText(mDayOfWeekFormat.format(mDate), mXOffset, mYOffset + mLineHeight, mDatePaint); \n      canvas.drawText(mDateFormat.format(mDate), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); \n    }  \n    else if (tapCount == 1)  \n    { \n      // Day of Year \n      canvas.drawText(\"Day of year\", mXOffset, mYOffset + mLineHeight, mDatePaint); \n      canvas.drawText(Integer.toString(TodayUtil.getDayOfYear()), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); \n    } \n    else if (tapCount == 2)  \n    { \n      // Days left in Year \n       canvas.drawText(\"Days left in year\", mXOffset, mYOffset + mLineHeight, mDatePaint); \n     canvas.drawText(Integer.toString(TodayUtil.getDaysLeftInYear()), mXOffset, mYOffset + mLineHeight * 2, mDatePaint); \n    } \n  } \n} \n\n```", "```java\n@Override \npublic void onAmbientModeChanged(boolean inAmbientMode)  \n{ \n  super.onAmbientModeChanged(inAmbientMode); \n  if (Log.isLoggable(TAG, Log.DEBUG))  \n  { \n    Log.d(TAG, \"onAmbientModeChanged: \" + inAmbientMode); \n  } \n  adjustPaintColorToCurrentMode(mBackgroundPaint, mInteractiveBackgroundColor,WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_BACKGROUND); \n  adjustPaintColorToCurrentMode(mHourPaint, mInteractiveHourDigitsColor,WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_HOUR_DIGITS); \n  adjustPaintColorToCurrentMode(mMinutePaint, mInteractiveMinuteDigitsColor, WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_MINUTE_DIGITS); \n\n  // Actually, the seconds are not rendered in the ambient mode, so we could pass just any \n  // value as ambientColor here. \n  adjustPaintColorToCurrentMode(mSecondPaint,  mInteractiveSecondDigitsColor, WatchFaceUtil.COLOR_VALUE_DEFAULT_AND_AMBIENT_SECOND_DIGITS); \n\n  if (mLowBitAmbient)  \n  { \n    boolean antiAlias = !inAmbientMode; \n    mDatePaint.setAntiAlias(antiAlias); \n    mHourPaint.setAntiAlias(antiAlias); \n    mMinutePaint.setAntiAlias(antiAlias); \n    mSecondPaint.setAntiAlias(antiAlias); \n    mAmPmPaint.setAntiAlias(antiAlias); \n    mColonPaint.setAntiAlias(antiAlias); \n  } \n  invalidate(); \n  // Whether the timer should be running depends on whether we're in ambient mode (as well \n  // as whether we're visible), so we may need to start or stop the timer. \n  updateTimer(); \n} \n\n```", "```java\npublic class WatchFaceConfigActivity extends Activity implements WearableListView.ClickListener, WearableListView.OnScrollListener  \n{ \n  @Override \n  protected void onCreate(Bundle savedInstanceState)  \n  { \n    super.onCreate(savedInstanceState); \n    setContentView(R.layout.activity_digital_config); \n    mHeader = (TextView) findViewById(R.id.header); \n    WearableListView listView = (WearableListView) findViewById(R.id.color_picker); \n    BoxInsetLayout content = (BoxInsetLayout) findViewById(R.id.content); \n  } \n} \n\n```"]