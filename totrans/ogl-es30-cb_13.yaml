- en: Appendix A. Supplementary Information on OpenGL ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this appendix, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The fixed function and programmable pipeline architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software requirements for OpenGL ES 3.0 – Android ADT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Hello World Triangle application on Android Studio with OpenGL ES
    3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software requirements for OpenGL ES 3.0 – iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a sample project in Android and iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application of the Lambert's cosine law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating cosine between two vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swizzling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fixed function and programmable pipeline architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into OpenGL ES programming, it''s very important to understand
    how the underlying architecture is stacked. There are two types of OpenGL ES architectures:
    fixed and programmable pipelines. This section will provide you a simple overview
    of these architectures; this overview will also help us to grasp the technical
    jargon of computer graphics terminology.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed pipeline architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following image shows the OpenGL ES 1.1 fixed function pipeline architecture.
    It also provides the sequence of events from the moment input data is sent to
    the rendering engine to output an image generated on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed pipeline architecture](img/5527OT_A_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Input** refers to the supply of raw data and drawing information required
    by the rendering engine to draw an object on the screen. For example, the preceding
    image shows three vertices, and three color data are provided to the graphics
    engine as raw data. In addition, we specified the engine that will draw this raw
    data in the form of a triangle.
  prefs: []
  type: TYPE_NORMAL
- en: In **Per Vertex Operation**, transformations on input vertex coordinates are
    performed. Each geometrical input vertex is transformed on the basis of the camera
    view or object translation.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, at this stage, the modeling transformation is performed to
    convert object coordinates to world space coordinates. Further, these coordinates
    are converted to eye space coordinates by view transformation. Light information
    and texture coordinates are also calculated according to these transformations
    for all vertices. The second chapter, OpenGL ES 3.0 essentials, covers all the
    technical jargon that we have used for transformation in this section under *Transformation
    with the model, view, and projection analogies* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Primitive** assembly takes all the transformed coordinates from the previous
    stage and arranges them as per the specified draw or the primitive type (point,
    line, triangle) information provided at the input stage. For example, we supplied
    three vertices and instructed the engine to render them as a triangle. There are
    basically three types of primitives available in OpenGL ES: point, line, and triangle
    (also the variants of line and triangle). These basic three primitives can be
    used to render any complex geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Clip**, **Viewport**, and **Culling** stages, the projection transformation
    is applied to generate clip space coordinates. In this, vertices that are outside
    the camera viewing volume are discarded. The resultant vertex coordinates are
    treated with the perspective division where normalize device coordinates are generated.
    Finally, viewport transformation is applied to normalize device coordinates to
    form screen space pixel coordinates. Faces are culled on the basis of the direction
    of the face, as specified to the graphics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Rasterization is the process of converting transformed screen space primitives
    (point, line, and triangle) to discrete elements called fragments. The output
    of each fragment are screen coordinates and related attributes, such as color,
    texture coordinates, depth, and stencil.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment processing stage processes each fragment generated in the rasterization
    stage. This stage processes the fragment appearance information using the color
    or texture information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **per-fragment operations** stage performs some important tests before
    rendering images on screen. It consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The pixel ownership test**: This is a test where pixel screen coordinates
    generated by the rasterization stage are tested to see whether they belong to
    the OpenGL ES context. For example, it may be possible that the rendering screen
    is overlaid with some text messages or obscured by other windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The scissor test**: This stage ensures that fragments that are present outside
    the rectangle formed by four values of the scissor rectangle region should not
    be considered in rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The stencil and depth test**: This test checks the stencil and depth value
    to see whether the fragment needs to be discarded or not. For example, if two
    primitives are obscuring each other, the primitive fragment on top is kept by
    the OpenGL ES state. However, fragments belonging to the behind one will be discarded,
    irrespective of the rendering order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blending**: This is a process of generating new color information, using
    the previous color specified earlier in the same color buffer location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dithering**: This technique uses existing colors to create effects of other
    colors. For example, various shades of gray color can be produced using various
    patterns generated by white and black colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programmable pipeline architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the fixed function pipeline, the programmable pipeline architecture provides
    the flexibility to modify some stages of the graphics pipeline. OpenGL ES 2.0
    and 3.0 follows the programmable pipeline architecture. These stages are modified
    using special programs called shaders. The following image shows the programmable
    pipeline architecture for OpenGL ES 3.0\. The architecture for 2.0 is also similar
    to the following image, except that it does not support a special stage called
    the Transform feedback. Transform feedback is a new stage introduced in OpenGL
    ES 3.0\. This stage is responsible for capturing the processed vertex data buffer
    after the geometric shading stage. These programmable stages can be seen in the
    following figure with green boxes. Developers need to program the shader to render
    object using OpenGL ES 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: The programmable pipeline architecture requires at least two shaders, namely,
    the vertex shader and the fragment shader to render geometry on screen. Without
    these shaders, rendering is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader is the first shader in the programmable pipeline architecture.
    Its responsibility is to perform processing on vertex coordinates to produce coordinate
    transformations. In most cases, it''s used to calculate clipped coordinates from
    the model, view, and projection information. An example of the vertex shader is
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The fragment shader is the last shader that works on the pixel level; it uses
    the output data from the rasterization stage, which generates primitive fragments.
    This shader is responsible for calculating colors for each and every fragment
    rendering object on screen. The fragment shader is also capable of applying textures
    on the fragment shader. Here is an example of the fragment shader:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![The programmable pipeline architecture](img/5527OT_A_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The programmable pipeline architecture needs a special type of language to program
    shaders. This language is called the OpenGL ES Shading Language. In this book,
    we will use specifications of OpenGL ES Shading Language 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements for OpenGL ES 3.0 – Android ADT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have implemented the source code for our first simple
    program in OpenGL ES 3.0\. We will use the same program to render the output on
    the Android and iOS platforms. This section will cover all the basic requirements
    that we need to develop OpenGL ES 3.0 applications on the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: Android is a Linux-based operating system; therefore, most of its development
    and configuration requires UNIX-based tools. This section discusses all the prerequisites
    for OpenGL ES 3.0's development on Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android supports the OpenGL ES application development in two ways: the Java
    framework API and **Native Development Kit** (**NDK**). The Java framework APIs
    for OpenGL ES 3.0 focuses on the Java code style of development. Therefore, if
    you are developing an application purely in Java code, you can build the OpenGL
    ES 3.0 code within the Java-based application framework. In contrast, the NDK
    uses the C/C++ language to build the OpenGL ES 3.0 application. This is more suitable
    for developers who are interested to develop OpenGL ES applications in the C/C++
    language. The additional benefit is that the same code can be used across different
    platforms, which support the C/C++ language, such as iOS, Blackberry, Windows,
    and so on. JNI works as an interface between the core Java application framework
    and the NDK C/C++ code.'
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on the native development of the OpenGL ES application through
    NDK. We will also see the advantages of using NDK over Java framework APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Android development, you must ensure the following prerequisites are fulfilled
    on your machine (Window/Linux/Mac) before starting the development sessions. Download
    the following packages and proceed to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADT bundle**: [https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android** **NDK**: [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cygwin**: [http://www.cygwin.com/install.html](http://www.cygwin.com/install.html)
    (only for Windows users)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ADT bundle**: Android Developer Tools (ADT) are a combo set of the Android
    software development kit. This provides us all necessary APIs, debugger, and test
    applications to build Android apps. It contains a variety of other tools that
    help us in profiling apps and provides an emulation support to run apps on an
    emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the ADT bundle according to your operating system. The downloaded
    package will be in ZIP form; unzip it. This will extract a folder with the `adt-bundle-xxxxx`
    name. The name is dependent on the operating system and its version type: 32/64
    bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This extracted ADT bundle contains the following important folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse folder**: This folder contains the Eclipse IDE, which is an integrated
    environment to develop Android applications. This special Eclipse lets users to
    quickly set up new Android projects, add framework packages, create UI, export
    `.apk`, and provide many more features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SDK folder**: This folder contains tools to develop and debug your app; tools
    to support new features on the Android platform, sample apps, documentation, system
    images; and SDK dependent tools that are available when new platforms are released.
    For more information on the SDK, refer to [https://developer.android.com/sdk/exploring.html](https://developer.android.com/sdk/exploring.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For the sake of better project management, keep your installation in the central
    location. We have created a folder called Android and extracted the ADT bundle
    within this folder. The folder name and location can be as per your personal choice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**JDK**: Depending on the ADT''s requirements, you may need to update the Java
    Development kit. JDK contains tools to develop, debug, and monitor Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to the previously mentioned URL and download the JDK. The minimum requirement
    is JDK 6.0\. However, higher versions must be workable. Download the installer
    and install it on your machine. JDK automatically contains the **Java Runtime
    Environment** (**JRE**), which contains everything required to run Java applications
    on your system. Therefore, there is no need to install any other software package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NDK**: The Native Development Kit is a toolset that helps to develop some
    parts of the Android application in the C/C++ language. It provides an interface
    between the Java and C++ code to communicate with each other. Download the latest
    NDK package and uncompress it into our Android folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variables**: Make sure that you define the system environment
    variable path to locate your NDK, SDK, and platform tools. This will be helpful
    in running executables from command-line terminals. Additionally, we need to define
    `ANDROID_HOME` to locate the SDK folder in the ADT bundle. The following sample
    shows the definition of these environment variables in the `.bash_profile` file
    under the Mac operating system. Similarly, these need to be defined in other operating
    systems, according to their way of defining environment variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Android SDK Manager**: In the ADT bundle folder, open Eclipse IDE and navigate
    to **Window** | **Android SDK Manager**. Install Android 4.3 and its related subcomponents,
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For OpenGL ES 3.0, we need Android 4.3 (the Level 18 API) or higher versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_A_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Cygwin**: Cygwin is a UNIX-based command-line terminal application that allows
    Windows users to compile and debug Unix-based applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the `setup.exe` from the URL mentioned in the previous section and
    execute it. This will open the installation interface for the app. Click on default
    selection on each window and click on the **Next** button until the list of packages
    needed to be installed does not appear.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for make and select **Devel/make**. Similarly, search shell, select
    Shells/bash, click on next and then click on **Finish**. This will install a Cygwin
    Terminal in your Windows program list. Make a shortcut on your desktop for quick
    launch. Refer to the following screenshot for assistance:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_A_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android SDK provides a beautiful modular package that contains all required
    tools that are necessary to build an Android application. SDK and platform tools
    in conjunction with the SDK platform act as a backbone of the Android application
    development. These provide services to debug, manage, and deploy Android applications.
    They manage various Android platforms and related SDK APIs. This package also
    contains a customized eclipse for Android development; it helps to build the applications
    UI quickly. IDE provides special tools (such as the Android SDK Manager) that
    allow you to install new Android platforms and many other helper tools.
  prefs: []
  type: TYPE_NORMAL
- en: Android supports the development of some portions of its application in the
    C/C++ language. This kind of development is supported through the NDK tool; this
    tool offers an interface called Java Native Interface (JNI) that helps to set
    up communication between the Java framework and native code to communicate with
    each other. NDK needs a Unix-based command-line terminal to build C/C++ libraries.
    This command-line terminal is built in under UNIX-based operating systems. On
    Windows, it's provided by the Cygwin application. Developers build the code and
    export the native code functionality through libraries (`.so`/`.dll`/`.a`). The
    Android application uses these libraries in static or uses the shared form to
    integrate it into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Hello World Triangle application on Android Studio with OpenGL
    ES 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio is another new **Integrated Development Environment** (**IDE**)
    for the Android application development; the community is rapidly migrating to
    it. Unlike the other recipes in this book that are based on Android ADT, you can
    also use the Android studio to develop OpenGL ES 3.0 applications. It uses the
    Gradle build system to create scalable applications. The template-based wizard
    helps in designing common components and layouts quickly. This IDE has many other
    cool features to make the development quicker, robust, and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous recipe, *Software requirements for OpenGL ES 3.0 – Android ADT,*
    uses the **Android development tool** (**ADT**) and Eclipse ADT plugin to build
    Android-based OpenGL ES applications. All the recipes implemented in the book
    uses the ADT-based development system to program OpenGL ES 3.0 applications. However,
    we also want to provide an option to our readers to develop their recipes using
    Android Studio. Android Studio is very easy to use and set up. Unlike the ADT,
    it provides a rich interface and built-in support for NDK build. In this recipe,
    we will reuse the Android ADT-based first recipe: `HelloWorldTriangle` and create
    a new recipe using Android Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to get and install Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://developer.android.com/sdk/installing/index.html?pkg=studio](https://developer.android.com/sdk/installing/index.html?pkg=studio)
    to get the latest Android studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest SDK tools and platforms using the SDK Manager at [https://developer.android.com/tools/help/sdk-manager.html](https://developer.android.com/tools/help/sdk-manager.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can learn to install the SDK package at [https://developer.android.com/sdk/installing/adding-packages.html](https://developer.android.com/sdk/installing/adding-packages.html).
    For Android OpenGL ES 3.0, any API level greater than 18 will work completely
    fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the overview of the Android Studio at [https://developer.android.com/tools/studio/index.html](https://developer.android.com/tools/studio/index.html)
    to know more about it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not forget to set the Android SDK path; the setup will automatically ask
    you to provide the directory path for the Android SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow the given steps to create the first Android Hello World application on
    Android Studio. I hope that after learning this, you can port the rest of the
    chapters recipe as per your need.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android application project by navigating to **New** | **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Application name** as `HelloWorldTriangle` and **Company Domain** as `cookbook.gles`,
    as shown in the following screenshot:![How to do it...](img/5527OT_A_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the target platform SDK''s; we will use **API 18: Android 4.3 (Jelly
    Bean)**. Refer to the following screenshot for more information:![How to do it...](img/5527OT_A_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the **Blank Activity**, change **Activity Name** to `GLESActivity`, and
    click on **Finish**. This will create the project solution, as shown in the following
    screenshot:![How to do it...](img/5527OT_A_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the current `java` folder or package name and select **File** | **New**
    | **Java Class**. Add two new classes called `GLESView` and `GLESNativeLib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from [Chapter
    1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS,*
    and copy its `JNI` folder to the `<ProjectLocation>\HelloWorldTriangle\app\src\main`
    location. This folder contains `Android.mk`, `Application.mk`, `NativeTemplate.h`,
    and `NativeTemplate.cpp`. The following screenshot shows the folder structure:![How
    to do it...](img/5527OT_A_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, use the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from
    [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0
    on Android/iOS,* and reuse the contents of `GLESActivity.java`, `GLESView.java,`
    and `GLESNativeLib.java` to the respective files of this project. Make sure that
    the package name should not be replaced because this project has different package
    name compared to the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from
    [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0
    in Android/iOS*. For more information, you can refer to the `HelloWorldTriangleAndroidStudio`
    example recipe provided with the sample code of this appendix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `NativeTemplate.h`/`.cpp` and correct the JNI interface declaration and
    definition. Replace the old package name with the new one. The following example
    shows the change we made in the `init()` function with respect to the new package
    name in the current recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The original declaration is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The new declaration with the new package name is shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to `Application.mk` and declare the build variant and version of the
    SDK to be used for compilation. The `APP_ABI` tells the NDK compiler to build
    shared libraries for every possible target. The `APP_PLATFORM` informs the compiler
    to use a specified platform for compilation. For example, as we are using API
    level 18; therefore, for OpenGL ES, the EGL and GLESv3 libraries will be referenced
    from the platform API level 18:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to `build.gradle` present in the `<ProjectLocation>\HelloWorldTriangle \app\build.gradle4`
    and make the following two changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The Module name**: This informs the native code module name to Gradle system;
    this must be the same as the module name specified in the `Android.mk`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**The NDK external build**: This compiles the makefile manually using the `ndk-build`
    command as we performed this for all other Android recipes. For this, we need
    to inform the Gradle build system not to prebuild the NDK. The `jni.srcDirs` tells
    the build system not to use the `ndk-build` command from the Android Studio. The
    `jniLibs.srcDir` gives the location of the build libraries for different targets
    using the external NDK compilation:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Refer to the following screenshot for the two changes we made in the `build.gradle`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_A_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open the command-line terminal. Navigate to the current `JNI` folder path and
    execute `ndk-build`. This command compiles source files and generates the shared
    library in the `<Project>\app\src\main\libs \<targetplatform>` folder path with
    the help of `Android.mk`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After building the library, use Android Studio and click on the **Project Execute**
    button to view the output on the device or emulator. The following is the output
    of the Hello World Triangle:![How to do it...](img/5527OT_A_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of this recipe is the same as we implemented in [Chapter 1](ch01.html
    "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS* except
    the fact that we will now use Android Studio to build the project. Refer to the
    *Developing the Hello World Triangle application on Android Studio with OpenGL
    ES 3.0* recipe and look for the *How it works…* section. This section will provide
    the necessary details of the working of OpenGL ES along with Android Java and
    native interfaces for the OpenGL ES 3.0 application development.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Using JNI on Android to communicate with C/C++* and *Developing
    an Android OpenGL ES 3.0 application* recipes in [Chapter 1](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software requirements for OpenGL ES 3.0 – iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specifications of OpenGL ES 3.0 are fully supported by iOS 7 and later versions.
    iPhone 5s, along with Apple's A7 GPU supports OpenGL ES 3.0 and the earlier version
    of OpenGL ES 2.0 and 1.1\. Apple A7 GPU, provides the accessibility of all new
    features of OpenGL ES 3.0\. It also has a larger pool of rendering resources.
    The shaders capability in 3.0 to access texture resource is twice as compared
    to OpenGL ES 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAC provides the Xcode IDE for development of iOS applications, which targets
    iPhone, iPad, and iPod. The minimum requirements to support OpenGL ES 3.0 is version
    5.0; all versions of Xcode beyond 5.0 supports iOS 7 build targets. This book
    will use the Xcode 5.2 version for its sample recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 is supported by the iOS 7 SDK on Xcode 5.0 and higher versions.
    The Xcode 5.0 version contains the iOS 7 SDK. If you are a new user, you can install
    it using your App store application. If you are using an older version of Xcode,
    you must update it to at least 5.0\. The iOS 7 SDK and higher versions support
    OpenGL ES 3.0 through iOS 7 target devices.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 on the iOS7 with powerful GPU can perform sophisticated graphics
    rendering. The GPU is capable of high complex calculations in shaders for every
    pixel on the screen. OpenGL ES 3.0 is a C-based API seamlessly integrated into
    Object or C/C++. The OpenGL ES specification does not define the Windowing layer
    because the windowing mechanisms for all operating systems are very different
    from each other. Therefore, the underlying operating system is responsible for
    generating the rendering context to provide the windowing layer. In addition to
    this, the operating system must also provide a presentation layer where OpenGL
    ES can be rendered. iOS provides GLKit, which gives the presentation layer by
    providing the draw surface. GLKit was introduced in iOS 5 for the development
    of OpenGL ES. This is a 3D graphics development kit for OpenGL ES 2.0/3.0 using
    objective C/C++. This kit makes the programming job easier for the programmable
    pipeline architecture. For more information, refer to the Apple developer site
    at [https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GLKit is developed using the C/C++ objective language. This language is only
    supported in Mac and iOS-based applications. Therefore, if we want our code to
    be portable across platforms, we need to program it in C/C++. The Objective C
    language supports the C/C++ language seamlessly within its framework.
  prefs: []
  type: TYPE_NORMAL
- en: The game engines, which work beautifully across platforms, actually use their
    own platform-independent frameworks for OpenGL ES programming. These frameworks
    are similar to GLKit, or even more powerful. In our approach, we will develop
    our own engine from scratch in C/C++ in order to build an acceptable cross-platform
    3D graphics framework for Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple provides special references to develop OpenGL ES applications on iOS.
    These references cover various aspects of OpenGL ES with respect to iOS. For more
    information, visit [https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: Opening a sample project on Android ADT and iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Opening the sample** **source for the Android platform**:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Eclipse ID, navigate to **New** | **Project** | **Android Project from
    Existing Code**. Click on **Next** and specify the path of the folder that contains
    `Android.xml`. Open the command-line terminal, change the directory path to the
    `JNI` folder, and execute the `ndk-build` command in the terminal. Launch application
    from Eclipse using **Run** or (*Ctrl* + *F11*) as the shortcut key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The path of the project should be the directory name that contains `Android.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening the sample source for the iOS platform**:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the recipe folder and locate **<Project Name>.xcodeproj**, double-click
    on to open the project in the Xcode editor. Launch the application using **Product**
    | **Run** or (*Command* + *R*).
  prefs: []
  type: TYPE_NORMAL
- en: Application of the Lambert's cosine law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how the cosine angle is calculated mathematically in order
    to implement Lambert''s cosine law in our diffuse light shading recipe. The cosine
    angle between two vectors can be calculated using the dot product between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dot product**:'
  prefs: []
  type: TYPE_NORMAL
- en: Dot product between the two vectors P (ai, bj, cz) and O (di, ej, fk) can be
    defined as the product of the magnitudes of the two vector and the cosine angle
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: '*P.Q = |P|*|Q|*cos(θ)…………Equation 1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where |P| and |Q| are magnitude of P and Q, which can be calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '|*P| = √(a*a) +(b*b) +(c*c) and |Q| = √(d*d) +(e*e) +(f*f)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, it is the product of respective components along x, y and z
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P.Q = (ai, bj, cz) * (di, ej, fk) => (ai*di)+ (bi*ei) +(ci*fi)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P.Q = (a*d)*(i*i) + (b*e)*(j*j) +(c*f)*(k*k) = ad + be + ef*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P.Q = ad + be + ef…………Equation 2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equate Equation 1 and Equation 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ad + be + ef = |P|*|Q|*cos(θ)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If P and Q are units vectors, then Equation 1 can be deduced as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P.Q = cos(θ)…………Equation 3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also find the cosine angle by dividing |P|*|Q| both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cos(θ) = ( P.Q )/( |P|*|Q| )…………Equation 4*'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating cosine between two vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an illustration of how to calculate the cosine angle between two vectors
    formed by the **0**, **20**, and **0** points on a flat *x-z* plane surface and
    the light source situated at **20**, **20**, and **40**, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating cosine between two vectors](img/5527OT_A_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Calculate ON and OL vectors, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot product between OL and ON is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using *Equation 1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using *Equation 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Equating both equations, the result is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `cos(`θ`) = 0.40` implies that the `θ` is `65.90` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Swizzling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swizzling is a new GL shading language feature that allows you to rearrange
    components of a vector. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `vec4` is represented by the x, y, z, and w component. The result is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, B is equivalent to {1.0, 1.0, 2.0, 2.0}
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The component access of the vec2/3/4s data type in the shading language can
    be considered either as vector, color, or texture coordinates or an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Form type | Components | Example: vec4(1.1, 2.2, 3.3, 4.4 ); |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Vector | `{x, y, z, w}` | `float a = v.x;``float b= v.y;` |'
  prefs: []
  type: TYPE_TB
- en: '| Color | `{r, g, b, a}` | `float a = v.r;``float b= v.g;` |'
  prefs: []
  type: TYPE_TB
- en: '| Texture coordinates | `{s, t, p, q}` | `float a = v.s;``float b= v.t;` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | `[0, 1, 2, 3]` | `float a = v[0];``float b= v[1];` |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swizzling is a mechanism of accessing a component directly using component
    names. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5527OT_A_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In preceding cases, swizzling occurs on the right-hand side of assignments.
    However, swizzling may occur on the left-hand side of assignments as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/5527OT_A_07.jpg)'
  prefs: []
  type: TYPE_IMG
