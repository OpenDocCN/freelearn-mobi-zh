<html><head></head><body>
		<div id="_idContainer064">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor094"/>Chapter 6</em>: Functions and Closures</h1>
			<p>At this point, you can write reasonably complex programs that can make decisions and repeat instruction sequences. You can also store data for your programs using collection types. As the programs you write grow in size and complexity, it will become harder to comprehend what they do.</p>
			<p>To make large programs easier to understand, Swift allows you to create <strong class="bold">functions</strong>, which lets you combine a number of instructions together and execute them by calling a single name. You can also create <strong class="bold">closures</strong>, which lets you combine a number of instructions together without a name and assign it to a constant or variable.</p>
			<p>By the end of this chapter, you'll have learned about functions, nested functions, functions as return types, functions as arguments and the <strong class="source-inline">guard</strong> statement. You'll also have learned how to create and use closures.</p>
			<p>The following topics will be covered: </p>
			<ul>
				<li>Understanding functions</li>
				<li>Understanding closures</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>The Xcode playground for this chapter is in the <strong class="source-inline">Chapter06</strong> folder of the code bundle for this book, which can be downloaded here: </p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a></p>
			<p>Check out the following video to see the code in action: </p>
			<p><a href="https://bit.ly/3o2MYTs">https://bit.ly/3o2MYTs</a></p>
			<p>If you wish to start from scratch, create a new playground and name it <strong class="source-inline">FunctionsAndClosures</strong>.</p>
			<p>You can type in and run all of the code in this chapter as you go along. Let's start by learning about functions.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/>Understanding functions</h1>
			<p>Functions are<a id="_idIndexMarker187"/> useful for encapsulating a number of instructions that collectively perform a specific task, for example:</p>
			<ul>
				<li>Calculating the 10% service charge for a meal at a restaurant. </li>
				<li>Calculating the monthly payment for a car that you wish to purchase.</li>
			</ul>
			<p>Here's what a function looks like:</p>
			<p class="source-code">func functionName(parameter1: ParameterType, ...) -&gt; ReturnType {</p>
			<p class="source-code">   code</p>
			<p class="source-code">}</p>
			<p>Every function has a descriptive name. You can define one or more values that the function takes as input, known<a id="_idIndexMarker188"/> as <strong class="bold">parameters</strong>. You can also define what the function will output when done, known<a id="_idIndexMarker189"/> as its <strong class="bold">return type</strong>. Both parameters and return types are optional. </p>
			<p>You "call" a function's name to execute it. This is what a function call looks like:</p>
			<p class="source-code">functionName(parameter1: argument1, …)</p>
			<p>You provide input values (known <a id="_idIndexMarker190"/>as <strong class="bold">arguments</strong>) that match the type of the function's parameters.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more<a id="_idIndexMarker191"/> about functions, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html">https://docs.swift.org/swift-book/LanguageGuide/Functions.html</a>.</p>
			<p>Let's see how you can create a function to calculate a service charge in the next section.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor097"/>Creating a function</h2>
			<p>In its simplest <a id="_idIndexMarker192"/>form, a function just executes some instructions, and does not have any parameters or return types. You'll see how this works by writing a function to calculate the service charge for a meal. The service charge should be 10% of the meal cost. </p>
			<p>Add the following code to your playground to create and call this function and click the <strong class="bold">Play/Stop</strong> button to run it:</p>
			<p class="source-code">func serviceCharge() {</p>
			<p class="source-code">   let mealCost = 50</p>
			<p class="source-code">   let serviceCharge = mealCost / 10</p>
			<p class="source-code">   print("Service charge is \(serviceCharge)")</p>
			<p class="source-code">}</p>
			<p class="source-code">serviceCharge()</p>
			<p>You've just created a very simple function named <strong class="source-inline">serviceCharge()</strong>. All it does is calculate the 10% service charge for a meal costing $50, which is <strong class="source-inline">50 / 10</strong>, returning <strong class="source-inline">5</strong>. You then call this function using its name. You'll see <strong class="source-inline">Service charge is 5</strong> displayed in the Debug area.</p>
			<p>This function is not very useful because <strong class="source-inline">mealCost</strong> is always <strong class="source-inline">50</strong> every time you call this function, and the result, <strong class="source-inline">5</strong>, is only printed in the Debug area and can't be used elsewhere in your program. Let's add some parameters and a return type to this function to make it more useful. </p>
			<p>Modify your code as shown:</p>
			<p class="source-code">func serviceCharge(<strong class="bold">mealCost: Int) -&gt; Int</strong> {</p>
			<p class="source-code"><strong class="bold">   return mealCost / 10</strong></p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">let serviceChargeAmount = serviceCharge(mealCost: 50)</strong></p>
			<p class="source-code"><strong class="bold">print(serviceChargeAmount)</strong></p>
			<p>This is much better. Now, you can set the meal cost when you call the <strong class="source-inline">serviceCharge(mealCost:)</strong> function, and the result can be assigned to a variable or constant. It looks a bit awkward, though. You should try to make function signatures in Swift read like an English sentence, as this is considered best practice. Let's see how to do that in the next section, where you'll use <strong class="bold">custom labels</strong> to make your function <a id="_idIndexMarker193"/>more English-like and easier to understand.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Using custom argument labels</h2>
			<p>Note that <a id="_idIndexMarker194"/>the <strong class="source-inline">serviceCharge(mealCost:)</strong> function is not very English-like. You can add a custom label to the parameter to make the function easier to understand.</p>
			<p>Modify your code as shown:</p>
			<p class="source-code">func serviceCharge(<strong class="bold">forMealPrice</strong> mealCost: Int) -&gt; Int {</p>
			<p class="source-code">   return mealCost / 10</p>
			<p class="source-code">}</p>
			<p class="source-code">let serviceChargeAmount = serviceCharge(<strong class="bold">forMealPrice</strong>: 50)</p>
			<p class="source-code">print(serviceChargeAmount)</p>
			<p>The function works exactly the same as before, but to call it, you use <strong class="source-inline">serviceCharge(forMealPrice:)</strong>. This sounds more like English and makes it easier to figure out what the function does.</p>
			<p>In the next section, you'll learn how to use several smaller functions within the bodies of other functions, and these are known as <strong class="bold">nested functions</strong>.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Using nested functions</h2>
			<p>It's possible to <a id="_idIndexMarker195"/>have <a id="_idIndexMarker196"/>a function within the body of another function, and these are called nested functions. A nested function can use the variables of the enclosing function. Let's see how nested functions work by writing a function to calculate monthly payments for a loan.</p>
			<p>Type in and run the following code:</p>
			<p class="source-code">func calculateMonthlyPayments(carPrice: Double, downPayment: Double, interestRate: Double, paymentTerm: Double) -&gt; Double {</p>
			<p class="source-code">   func loanAmount() -&gt; Double {</p>
			<p class="source-code">      return carPrice - downPayment</p>
			<p class="source-code">   }</p>
			<p class="source-code">   func totalInterest() -&gt; Double {</p>
			<p class="source-code">      return interestRate * paymentTerm</p>
			<p class="source-code">   }</p>
			<p class="source-code">   func numberOfMonths() -&gt; Double {</p>
			<p class="source-code">      return paymentTerm * 12</p>
			<p class="source-code">   }</p>
			<p class="source-code">   return ((loanAmount() + ( loanAmount() * </p>
			<p class="source-code">   totalInterest() / 100 )) / numberOfMonths())</p>
			<p class="source-code">}</p>
			<p class="source-code">calculateMonthlyPayments(carPrice: 50000, downPayment: 5000, interestRate: 3.5, paymentTerm: 7.0)</p>
			<p>Here, there <a id="_idIndexMarker197"/>are <a id="_idIndexMarker198"/>three functions within <strong class="source-inline">calculateMonthlyPayments (carPrice:downPayment:interestRate:paymentTerm:)</strong>. Let's take a look at them:</p>
			<ul>
				<li>The first nested function, <strong class="source-inline">loanAmount()</strong>, calculates the total loan amount by subtracting <strong class="source-inline">downPayment</strong> from <strong class="source-inline">carPrice</strong>. It returns <strong class="source-inline">50000 - 5000</strong> = <strong class="source-inline">45000</strong>.</li>
				<li>The second nested function, <strong class="source-inline">totalInterest()</strong>, calculates the total interest amount incurred for the payment term by multiplying <strong class="source-inline">interestRate</strong> with <strong class="source-inline">paymentTerm</strong>. It returns <strong class="source-inline">3.5 * 7</strong> = <strong class="source-inline">24.5</strong>.</li>
				<li>The third nested function, <strong class="source-inline">numberOfMonths()</strong>, calculates the total number of months in the payment term by multiplying <strong class="source-inline">paymentTerm</strong> with <strong class="source-inline">12</strong>. It returns <strong class="source-inline">7 * 12</strong> = <strong class="source-inline">84</strong>. </li>
			</ul>
			<p>Note that the three nested functions all use the variables of the enclosing function. The value returned is <strong class="source-inline">( 45000 + ( 45000 * 24.5 / 100 ) ) / 84</strong> = <strong class="source-inline">666.96</strong>, which is the amount you have to pay monthly for 7 years to buy this car.</p>
			<p>As you have seen, functions in Swift are similar to functions in other languages, but they have a cool feature. Functions are<strong class="bold"> first-class types </strong>in Swift, so they can be used as parameters and<a id="_idIndexMarker199"/> return<a id="_idIndexMarker200"/> types. Let's see how that is done in the next section.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor100"/>Using functions as return types</h2>
			<p>A function <a id="_idIndexMarker201"/>can return another function as its return type. Type in and run the following code to create a function that generates a value for Pi:</p>
			<p class="source-code">func makePi() -&gt; (() -&gt; Double) {</p>
			<p class="source-code">   func generatePi() -&gt; Double {</p>
			<p class="source-code">      return 22.0 / 7.0</p>
			<p class="source-code">   }</p>
			<p class="source-code">   return generatePi</p>
			<p class="source-code">}</p>
			<p class="source-code">let pi = makePi()</p>
			<p class="source-code">print(pi())</p>
			<p>The <strong class="source-inline">makePi()</strong> function's return type is a function that has no parameters and the return type is <strong class="source-inline">Double</strong>. <strong class="source-inline">generatePi()</strong> is a function that has no parameters and the return type is <strong class="source-inline">Double</strong>, and will be the function that is returned. So, <strong class="source-inline">pi</strong> will be assigned <strong class="source-inline">generatePi()</strong> and will return <strong class="source-inline">22.0/7.0</strong> when called. <strong class="source-inline">3.142857142857143</strong> will be printed in the Debug area.</p>
			<p>Let's see how a function can be used as a parameter for another function in the next section.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Using functions as parameters</h2>
			<p>A function <a id="_idIndexMarker202"/>can take a function as a parameter. Type in and run the following code to create a function that determines if a number meeting a certain condition exists within a l<a id="_idTextAnchor102"/><a id="_idTextAnchor103"/>ist of numbers:</p>
			<p class="source-code">func isThereAMatch(listOfNumbers: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {</p>
			<p class="source-code">   for item in listOfNumbers {</p>
			<p class="source-code">      if condition(item) {</p>
			<p class="source-code">         return true</p>
			<p class="source-code">      }</p>
			<p class="source-code">   }</p>
			<p class="source-code">   return false</p>
			<p class="source-code">}</p>
			<p class="source-code">func oddNumber(number: Int) -&gt; Bool {</p>
			<p class="source-code">   return (number % 2) &gt; 0</p>
			<p class="source-code">}</p>
			<p class="source-code">var numbersList = [2, 4, 6, 7]</p>
			<p class="source-code">isThereAMatch(listOfNumbers: numbersList, condition: oddNumber)</p>
			<p><strong class="source-inline">isThereAMatch(listOfNumbers:condition:)</strong> has two parameters; an array of integers and a function. The function provided as an argument must take an integer value and return a Boolean value. <strong class="source-inline">oddNumber(number:)</strong> takes an integer and returns <strong class="source-inline">true</strong> if the number is an odd number, which means it can be an argument for the second parameter. <strong class="source-inline">numbersList</strong>, an array containing an odd number, is used as the argument for the first parameter. Since <strong class="source-inline">numbersList</strong> contains an odd number, <strong class="source-inline">isThereAMatch(listOfNumbers:condition:)</strong> will return <strong class="source-inline">true</strong> when called.</p>
			<p>In the next section, you'll see how you can perform an early exit on a function if the arguments used are not suitable.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor104"/>Using a guard statement to exit a function early</h2>
			<p>If there is <a id="_idIndexMarker203"/>something wrong with the input data, it is useful to be able to exit a function early. Let's say you need a function to be used in an online purchasing terminal. This function will calculate the remaining balance of a debit or credit card when you buy something. The price of the item that you want to buy is entered in a text field. The value in the text field is converted into an integer so that you can calculate the remaining card balance. </p>
			<p>Type in and run the following code:</p>
			<p class="source-code">func buySomething(itemValueEntered itemValueField: String, cardBalance: Int) -&gt; Int {</p>
			<p class="source-code">   guard let itemValue = Int(itemValueField) else {</p>
			<p class="source-code">      print("error in item value")</p>
			<p class="source-code">      return cardBalance</p>
			<p class="source-code">   }</p>
			<p class="source-code">   let remainingBalance = cardBalance - itemValue </p>
			<p class="source-code">   return remainingBalance</p>
			<p class="source-code">}</p>
			<p class="source-code">print(buySomething(itemValueEntered: "10", cardBalance: 50))</p>
			<p class="source-code">print(buySomething(itemValueEntered: "blue", cardBalance: 50))</p>
			<p>You should see this result in the Debug area:</p>
			<p class="source-code">40</p>
			<p class="source-code">error in item value</p>
			<p class="source-code">50</p>
			<p>Let's see how this function works. The first line in the function body is a <strong class="source-inline">guard</strong> statement. This checks to see whether a condition is <strong class="source-inline">true</strong>; if not, it exits the function. Here, it is used to check and see whether the user entered a valid price in the online purchasing terminal. If so, the value can be converted successfully into an integer, and you can calculate the remaining card balance. Otherwise, the <strong class="source-inline">else</strong> clause in the <strong class="source-inline">guard</strong> statement is executed. An error message is printed to the Debug area and the unchanged card balance is returned.</p>
			<p>For <strong class="source-inline">print(buySomething(itemValueEntered: "10", cardBalance: 50))</strong>, the item price is deducted successfully from the card balance, and <strong class="source-inline">40</strong> is returned.</p>
			<p>For <strong class="source-inline">print(buySomething(itemValueEntered: "blue", cardBalance: 50))</strong>, the <strong class="source-inline">guard</strong> statement's condition fails and its <strong class="source-inline">else</strong> clause is executed, resulting in an error message being printed to the Debug area and <strong class="source-inline">50</strong> being returned.</p>
			<p>You now know how to create and use functions. You have also seen how to use custom argument labels, nested functions, functions as parameters or return types, and the <strong class="source-inline">guard</strong> statement. </p>
			<p>Now, let's look at closures. Like functions, closures allow you to combine a number of instructions <a id="_idIndexMarker204"/>together, but closures do not have names and can be assigned to a constant or a variable. You'll see how they work in the next section.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor105"/>Understanding closures</h1>
			<p>A closure, like a<a id="_idIndexMarker205"/> function, contains a sequence of instructions and can take arguments and return values. However, closures don't have names. The sequence of instructions in a closure is surrounded by curly braces (<strong class="source-inline">{ }</strong>), and the <strong class="source-inline">in</strong> keyword separates the arguments and return type from the closure body.</p>
			<p>Closures can be assigned to a constant or variable, so they're handy if you need to pass them around inside your program. For instance, let's say you have an app that downloads a file from the internet, and you need to do something to the file once it has finished downloading. You can put a list of instructions to process the file inside a closure and have your program execute it once the file finishes downloading. You'll see how closures are used in <a href="B17469_16_Final_VK_ePub.xhtml#_idTextAnchor223"><em class="italic">Chapter 16</em></a>, <em class="italic">Getting Started with MapKit</em>.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout">To learn more <a id="_idIndexMarker206"/>about closures, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">https://docs.swift.org/swift-book/LanguageGuide/Closures.html</a>.</p>
			<p>You'll now write a closure that applies a calculation on each element of an array of numbers. Add the following code to your playground and click the <strong class="bold">Play/Stop</strong> button to run it:</p>
			<p class="source-code">var numbersArray = [2, 4, 6, 7]</p>
			<p class="source-code">let myClosure = { (number: Int) -&gt; Int in </p>
			<p class="source-code">   let result = number * number</p>
			<p class="source-code">   return result</p>
			<p class="source-code">}</p>
			<p class="source-code">let mappedNumbers = numbersArray.map(myClosure)</p>
			<p>This assigns a closure that calculates a number's power of two to <strong class="source-inline">myClosure</strong>. The <strong class="source-inline">map()</strong> function then applies this closure to every element in <strong class="source-inline">numbersArray</strong>. Each element is <a id="_idIndexMarker207"/>multiplied by itself, and <strong class="source-inline">[4, 16, 36, 49]</strong> appears in the Results area.</p>
			<p>It's possible to write closures in a more concise fashion, and you'll see how to do that in the next section.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Simplifying closures</h2>
			<p>One of the<a id="_idIndexMarker208"/> things that new developers have trouble with is the very concise way experienced Swift programmers use to write closures. Consider the code shown in the following example:</p>
			<p class="source-code">var testNumbers = [2, 4, 6, 7]</p>
			<p class="source-code">let mappedTestNumbers = testNumbers.map({ (number: Int) </p>
			<p class="source-code">   -&gt; Int in </p>
			<p class="source-code">   let result = number * number</p>
			<p class="source-code">   return result</p>
			<p class="source-code">})</p>
			<p class="source-code">print(mappedTestNumbers)</p>
			<p>Here, you have <strong class="source-inline">testNumbers</strong>, an array of numbers, and you use the <strong class="source-inline">map(_:)</strong> function to map a closure to each element of the array in turn. The code in the closure multiplies the number by itself, generating the square of that number. The result, <strong class="source-inline">[4, 16, 36, 49]</strong>, is then printed to the Debug area. As you will see, the closure code can be written more concisely.</p>
			<p>When a closure's type is already known, you can remove the parameter type, return type, or both. Single statement closures implicitly return the value of their only statement, which means you can remove the <strong class="source-inline">return</strong> statement as well. So, you can write the closure as follows:</p>
			<p class="source-code">let mappedTestNumbers = testNumbers.map({ <strong class="bold">number in </strong></p>
			<p class="source-code"><strong class="bold">  number * number</strong> </p>
			<p class="source-code">})</p>
			<p>When a<a id="_idIndexMarker209"/> closure is the only argument to a function, you can omit the parentheses enclosing the closure, as follows:</p>
			<p class="source-code">let mappedTestNumbers = testNumbers.map { number in </p>
			<p class="source-code">  number * number </p>
			<p class="source-code">}</p>
			<p>You can refer to parameters by a number expressing their relative position in the list of arguments instead of by name, as follows:</p>
			<p class="source-code">let mappedTestNumbers = testNumbers.map { <strong class="bold">$0 * $0</strong> }</p>
			<p>So, the closure now is very concise indeed, but will be challenging for new developers to understand. Feel free to write closures in a way that you are comfortable with.</p>
			<p>You now know <a id="_idIndexMarker210"/>how to create and use closures, and how to write them more concisely. Great!</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, you studied how to group statements together into functions. You learned how to use custom argument labels, functions inside other functions, functions as return types, and functions as parameters. This will be useful later when you need to accomplish the same task at different points in your program.</p>
			<p>You also learned how to create closures. This will be useful when you need to pass around blocks of code within your program.</p>
			<p>In the next chapter, you will study classes, structures, and enumerations. Classes and structures allow for the creation of complex objects that can store state and behavior, and enumerations can be used to limit the values that can be assigned to a variable or constant, reducing the chances for error.</p>
		</div>
	</body></html>