<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Importance of Immutability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Importance of Immutability</h1></div></div></div><p>In object-oriented and functional programming, immutable objects are objects whose state cannot be changed or altered after they are initiated. Therefore, a mutable object stays the same until the end of its life cycle, when it is deinitialized. In contrast, a mutable object can be altered countless times by other objects after it is initiated.</p><p>Immutable objects improve readability and runtime efficiency and using them simplifies our applications.</p><p>This chapter will cover the concept of immutability by discussing the following topics with coding examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Immutability</li><li class="listitem" style="list-style-type: disc">The benefits of immutability</li><li class="listitem" style="list-style-type: disc">Cases for mutability</li><li class="listitem" style="list-style-type: disc">An example with approach comparisons<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Side-effects and unintended consequences</li><li class="listitem" style="list-style-type: disc">Testability</li></ul></div></li><li class="listitem" style="list-style-type: disc">Copy constructors</li><li class="listitem" style="list-style-type: disc">Lenses</li></ul></div><div class="section" title="Immutability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Immutability</h1></div></div></div><p>An immutable object is an object whose state cannot be modified after it is initiated. This quality of immutable objects is essential in multithreaded applications because it allows a thread to act on the data represented by immutable objects without worrying about changes from other threads.</p><p>An object is considered immutable if the object itself, and in fact all of its properties, are immutable. In some cases, an object is considered immutable even if some of its internal properties change but the object's state appears to be immutable from an external point of view. For instance, an object that uses the memoization technique to cache the results of resource-greedy calculations can be considered as an immutable object.</p><p>Immutable objects have the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are simple to construct, test, and use</li><li class="listitem" style="list-style-type: disc">They are simple to understand and reason about</li><li class="listitem" style="list-style-type: disc">They are inherently thread-safe and have no synchronization issues</li><li class="listitem" style="list-style-type: disc">They do not require a copy constructor</li><li class="listitem" style="list-style-type: disc">They always have failure atomicity so if an immutable object throws an exception, it will not be stuck in an undesirable/indeterminate state</li><li class="listitem" style="list-style-type: disc">They offer higher security</li></ul></div></div></div>
<div class="section" title="Immutable variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Immutable variables</h1></div></div></div><p>In the imperative programming style, values held in application variables whose contents never change are known as constants to differentiate them from variables that could be altered during execution. Examples might include a view's height and width or the value of Π to several decimal places.</p><p>Unlike programming languages such as Objective-C in which some types are mutable and some are not, Swift provides a way to create an immutable or mutable version of the same type. In Swift, we use the <code class="literal">let</code> and <code class="literal">var</code> keywords to create and store values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">var</code> keyword is used to create a variable that can be altered later, in other words, to create mutable variables</li><li class="listitem" style="list-style-type: disc">The <code class="literal">let</code> keyword is used to create a constant that cannot be altered later, in other words, immutable variables or constants</li></ul></div><p>Therefore, in Swift, we do not need to have any type such as <code class="literal">NSMutableArray</code> opposed to <code class="literal">NSArray</code> or <code class="literal">NSMutableDictionary</code> opposed to <code class="literal">NSDictionary</code> to differentiate between mutability and immutability. We can simply define <code class="literal">Dictionary</code> with <code class="literal">var</code> or <code class="literal">let</code> to make it mutable or immutable.</p><p>In addition, the Swift compiler always suggests and warns us about variables that are not changed and will be converted to constants later.</p><div class="section" title="Weak versus strong immutability"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec60"/>Weak versus strong immutability</h2></div></div></div><p>Sometimes, certain properties of an object can be immutable while the others may be mutable. These types of objects are called weakly immutable. Weak immutability means that we cannot change the immutable parts of the object state even though other parts of the object may be mutable. If all properties are immutable, then the object is immutable. If the whole object cannot be mutated after its creation, the object is called strongly immutable.</p></div></div>
<div class="section" title="Reference types versus value types"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Reference types versus value types</h1></div></div></div><p>We covered this topic in a previous chapter, but it is important to emphasize that in most <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) languages, instances can be shared and objects can be passed around with their references. This is true for Swift classes and closures as well. In those cases, it is important to understand that the state of an object can be altered when objects are shared via references. In other words, in case any user of a reference to a mutable object changes the object, all other users of that object will be affected by the change.</p></div>
<div class="section" title="The benefits of immutability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>The benefits of immutability</h1></div></div></div><p>We already know that immutability helps safety and performance, but in real-world application development, immutability can provide us with more benefits, which will be explained in the following sections.</p><div class="section" title="Thread safety"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec61"/>Thread safety</h2></div></div></div><p>Immutable objects are useful in multithreaded applications because multiple threads can act on the data of immutable objects without worrying about changes to the data by other threads.</p><p>As immutable objects are closed to change, it is safe to assume that they will stay unchanged while we access the object from different threads. This assumption simplifies most of the multithreading problems that are complex to solve and maintain. For instance, we do not need to think about the synchronization/locking mechanism at all.</p><p>Suppose that we have a mutable object that includes a mutable array of a type, for example, a <code class="literal">Product</code> class that has four properties:</p><pre class="programlisting">struct Producer {&#13;
    let name: String&#13;
    let address: String&#13;
}&#13;
&#13;
class Product {&#13;
    var name: String = ""&#13;
    var price: Double = 0.0&#13;
    var quantity: Int = 0&#13;
    var producer: Producer&#13;
 &#13;
    init(name: String,&#13;
        price: Double,&#13;
     quantity: Int,&#13;
     producer: Producer) {&#13;
 &#13;
        self.name = name&#13;
        self.price = price&#13;
        self.quantity = quantity&#13;
        self.producer = producer&#13;
    }&#13;
}&#13;
</pre><p>As seen from the preceding example, all properties are defined as mutable. Now let's create an array of <code class="literal">Product</code>:</p><pre class="programlisting">let producer = Producer(name: "ABC",&#13;
                     address: "Toronto, Ontario, Canada")&#13;
&#13;
var bananas = Product(name: "Banana",&#13;
                     price: 0.79,&#13;
                  quantity: 2,&#13;
                  producer: producer)&#13;
&#13;
var oranges = Product(name: "Orange",&#13;
                     price: 2.99,&#13;
                  quantity: 1,&#13;
                  producer: producer)&#13;
&#13;
var apples = Product(name: "Apple",&#13;
                    price: 3.99,&#13;
                 quantity: 3,&#13;
                 producer: producer)&#13;
&#13;
var products = [bananas, oranges, apples]&#13;
</pre><p>Suppose that we need the <code class="literal">products</code> array to be shared between different threads. Different threads may change the array in different ways. Some may change the price while others may change the quantity. Some may add or remove items from the array.</p><p>The first issue to solve is keeping track of changes and knowing who changes the array and when. This is already complex, so let's simplify the issue and only add an item to the array. Also, let's assume that we are only interested in the latest change.</p><p>To be able to track the latest change, let's create another object:</p><pre class="programlisting">class ProductTracker {&#13;
    private var products: [Product] = []&#13;
    private var lastModified: NSDate?&#13;
 &#13;
    func addNewProduct(item: Product) -&gt; (date: NSDate,&#13;
                                  productCount: Int) {&#13;
        products.append(item)&#13;
        lastModified = NSDate()&#13;
        return (date: lastModified!, productCount: products.count)&#13;
    }&#13;
 &#13;
    func lastModifiedDate() -&gt; NSDate? {&#13;
        return lastModified&#13;
    }&#13;
 &#13;
    func productList() -&gt; [Product] {&#13;
        return products&#13;
    }&#13;
}&#13;
</pre><p>The <code class="literal">ProductTracker</code> class has an array of <code class="literal">products</code> and a <code class="literal">lastModified</code> variable to track the latest change. In addition, it has three methods: one to add a new product to the array, another to retrieve the last modification date, and the last one to retrieve the product list.</p><p>Suppose that we want to make our <code class="literal">ProductTracker</code> class thread-safe and allow multiple objects to access our <code class="literal">ProductTracker</code> object. We cannot allow multiple threads execute <code class="literal">addNewProduct</code> while multiple others list products. First of all, we will need a locking mechanism to lock the class during the modifications, second, we need to protect <code class="literal">lastModified</code> against modification without locking, and finally, an unlocking mechanism.</p><p>Apple provides multiple multithreading mechanisms such as <code class="literal">NSThread</code>, Grand Central Dispatch (GCD), and operation queues to overcome these types of issues but still multithreading remains complex.</p></div><div class="section" title="Referential transparency"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec62"/>Referential transparency</h2></div></div></div><p>Referential transparency generally means that we can always replace a function with its return value without an effect on the application's behavior.</p><p>Referential transparency is a guarantee of code reusability. Also, it denies the mutable state of data. In the case of a mutable state, two calls of the same function can potentially produce two different results, which is very difficult to test and maintain.</p></div><div class="section" title="Low coupling"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec63"/>Low coupling</h2></div></div></div><p>Coupling is the measure of code dependency. We always want to reduce coupling and make our code components independent of each other as much as possible. Low coupling allows us to change the component without affecting other code components. The low-coupled code is easier to read because each component has its own, relatively small area of responsibility, though we need to understand only this code without spending time on figuring out how the entire system works.</p><p>Immutability helps achieving low coupling. Immutable data can be safely passed through different code blocks without worrying about it being transformed and causing effects on other parts of the code. Pure functions transform the data and return the result without affecting the input data. So, if the function contains errors, we can easily find it. Also, using value types and immutable data structures means that we can significantly reduce object referencing.</p><p>The following shows the data transformation idea. We have immutable array numbers, and we need the sum of all the even numbers that it contains:</p><pre class="programlisting">let numbers: [Int] = [1, 2, 3, 4, 5]&#13;
let sumOfEvens = numbers.reduce(0){$0 + (($1 % 2 == 0) ? $1 : 0) }&#13;
</pre><p>The <code class="literal">numbers</code> array is not changed and can be passed to any other function without any side-effects:</p><pre class="programlisting">print(numbers) // [1, 2, 3, 4, 5] &#13;
print(sumOfEvens) // 6&#13;
</pre><p>Using in-place transformation of the immutable data will help us reduce coupling.</p></div><div class="section" title="Avoiding temporal coupling"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec64"/>Avoiding temporal coupling</h2></div></div></div><p>Suppose that we have a code statement that is dependent on another code statement, as shown in the following code:</p><pre class="programlisting">func sendRequest() {&#13;
    let sessionConfig = URLSessionConfiguration.default()&#13;
    let session = URLSession(configuration: sessionConfig,&#13;
                                  delegate: nil,&#13;
                             delegateQueue: nil)&#13;
 &#13;
    var url: NSURL?&#13;
    var request: URLRequest&#13;
 &#13;
    /* First request block starts: */&#13;
    url = URL(string: "https://httpbin.org/get")&#13;
    request = URLRequest(url: url! as URL)&#13;
    request.httpMethod = "GET"&#13;
 &#13;
    let task = session.dataTask(with: request,&#13;
                   completionHandler: {&#13;
 &#13;
        (data: Data?, response: URLResponse?, error: NSError?) -&gt; Void in&#13;
        if (error == nil) {&#13;
            let statusCode = (response as! HTTPURLResponse).statusCode&#13;
            print("URL Session Task Succeeded: HTTP \(statusCode)")&#13;
        } else {&#13;
            print("URL Session Task Failed: %@",   error!.localizedDescription);&#13;
        }&#13;
        })&#13;
    task.resume()&#13;
    /* First request block ends */&#13;
 &#13;
    /* Second request block starts */&#13;
    url = URL(string: "http://requestb.in/1g4pzn21") // replace with&#13;
      a new requestb.in&#13;
    request = URLRequest(url: url! as URL)&#13;
 &#13;
    let secondTask = session.dataTask(with: request,&#13;
                         completionHandler: {&#13;
 &#13;
        (data: Data?, response: URLResponse?, error: NSError?) -&gt; Void in&#13;
        if (error == nil) {&#13;
            let statusCode = (response as! HTTPURLResponse).statusCode&#13;
            print("URL Session Task Succeeded: HTTP \(statusCode)")&#13;
        } else {&#13;
            print("URL Session Task Failed: %@",&#13;
              error!.localizedDescription);&#13;
        }&#13;
    })&#13;
    secondTask.resume()&#13;
}&#13;
</pre><p>In the preceding code example, we set two different HTTP requests. Suppose that we do not need our first request anymore and we delete the following code block:</p><pre class="programlisting">url = URL(string: "https://httpbin.org/get")&#13;
      request = URLRequest(url: url! as URL)&#13;
      request.httpMethod = "GET"</pre><p>The compiler will not complain but as we deleted <code class="literal">request.httpMethod = "GET"</code>, our second request is not going to work. This situation is called temporal coupling. If we had immutable definitions with <code class="literal">let</code>, we would avoid temporal coupling.</p></div><div class="section" title="Avoiding identity mutability"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec65"/>Avoiding identity mutability</h2></div></div></div><p>We may need objects to be identical if their internal states are the same. When modifying the state of an object, we are not expecting it to change its identity. Immutable objects avoid this completely.</p></div><div class="section" title="Failure atomicity"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec66"/>Failure atomicity</h2></div></div></div><p>A class can be left in a broken state if it throws a runtime exception. Immutability prevents this problem. An object will never be left in a broken state because its state is modified only during its initialization. The initialization will either fail, rejecting object initialization, or succeed, making a valid solid object, which never changes its encapsulated state.</p></div><div class="section" title="Parallelization"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec67"/>Parallelization</h2></div></div></div><p>Immutability makes it easier to parallelize code execution as there are no conflicts among objects and instances.</p></div><div class="section" title="Exception handling and error management"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec68"/>Exception handling and error management</h2></div></div></div><p>If we use immutable types only, the internal state of our application will be consistent even if we have exceptions because our immutable objects do not maintain different states.</p></div><div class="section" title="Caching"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Caching</h2></div></div></div><p>References to immutable objects can be cached as they are not going to change; therefore, the same immutable object will be retrieved quickly the next time we try to access it. An example technique is memoization, which we have explained in <a class="link" href="ch02.html" title="Chapter 2. Functions and Closures">Chapter 2</a>, <span class="emphasis"><em>Functions and Closures</em></span>.</p></div><div class="section" title="State comparison"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec70"/>State comparison</h2></div></div></div><p>The state of an application is the state of all its objects at a given time. State changes rapidly over time and an application needs to change state in order to continue running.</p><p>Immutable objects, however, have fixed state over time. Once created, the state of an immutable object does not change although the state of the application as a whole might change. This makes it easy to keep track of what is happening and simplify state comparison.</p></div><div class="section" title="Compiler optimization"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec71"/>Compiler optimization</h2></div></div></div><p>The compiler optimizes <code class="literal">let</code> statements better for items whose values will not change during their lifetime. For example, Apple writes, <span class="emphasis"><em>"It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so enables the Swift compiler to optimize the performance of the collections you create."</em></span> (Do prefer using <code class="literal">let</code> over <code class="literal">var</code> where appropriate.)</p></div></div>
<div class="section" title="Cases for mutability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Cases for mutability</h1></div></div></div><p>Whenever we require to change an immutable object, we will need to create a new, modified copy of it. This might not be costly and tedious for small and simple objects but will be in cases where we have large or complex objects with lots of properties and operations.</p><p>Also, changing an existing object is simpler and much more intuitive than creating a new, modified copy of it for objects with a distinct identity, for instance, a profile of a user. We may want to maintain a single object of a user's profile and modify it when necessary. This might not be a great example as it is hard to see the performance penalty for this case but the speed of execution can be a very important differentiator for some types of applications such as games. As an example, representing our game characters with mutable objects may make our game run faster than an alternative implementation where we will need to create a new, modified copy of the game character whenever we need to change it.</p><p>Furthermore, our real-world perception is inevitably based on the concept of mutable objects. We deal with all objects around us in our real life. These objects are identical most of the time and we change some of their characteristics if required.</p><p>For instance, we paint a wall in our home instead of replacing the whole wall. We perceive the wall as the same object with a modified property, in this case, color. The wall's identity is maintained while its state changes when we paint it.</p><p>Therefore, whenever we model a real-world domain to represent real-world objects in our applications, it is inevitably easier to perceive and implement the domain model using mutable objects.</p></div>
<div class="section" title="An example"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/>An example</h1></div></div></div><p>We understand that there are cases where immutability makes our life harder. We barely touched the surface of these problems in a previous section. We will examine issues in more detail in the following chapters.</p><p>Let's redevelop our <code class="literal">Product</code> example with a <span class="strong"><strong>functional programming</strong></span> (<span class="strong"><strong>FP</strong></span>) style and compare the outcome to its OOP counterpart.</p><p>Let's make our <code class="literal">Product</code> example in this chapter immutable and examine the outcome:</p><pre class="programlisting">struct FunctionalProduct {&#13;
    let name: String&#13;
    let price: Double&#13;
    let quantity: Int&#13;
    let producer: Producer&#13;
}&#13;
</pre><p>Now we have <code class="literal">struct</code> instead of class and all properties are immutable. Also, we do not need an <code class="literal">init</code> method as <code class="literal">struct</code> provides it automatically.</p><p>We also need to modify our <code class="literal">ProductTracker</code> class:</p><pre class="programlisting">struct FunctionalProductTracker {&#13;
    let products: [FunctionalProduct]&#13;
    let lastModified: NSDate&#13;
 &#13;
    func addNewProduct(item: FunctionalProduct) -&gt; (date: NSDate,&#13;
                                                products:&#13;
                                                  [FunctionalProduct]) {&#13;
 &#13;
        let newProducts = self.products + [item]&#13;
        return (date: NSDate(), products: newProducts)&#13;
    }&#13;
}&#13;
</pre><p>Our <code class="literal">FunctionalProductTracker</code> is simplified: it is <code class="literal">struct</code> with an immutable array of <code class="literal">products</code> and our <code class="literal">addNewProduct</code> does not modify the state of our object but provides a new array of <code class="literal">products</code> each time. In fact, we can remove the <code class="literal">addNewProduct</code> method from this <code class="literal">struct</code> and handle it in a client object.</p><div class="section" title="Side-effects and unintended consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec72"/>Side-effects and unintended consequences</h2></div></div></div><p>Our mutable example's design can produce unpredictable side-effects. If multiple clients hold a reference to the <code class="literal">ProductTracker</code> instance, there are two ways for the products to change from underneath any of these clients:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We could simply reassign a value to the <code class="literal">products</code> directly. This is fixable by making it <code class="literal">private</code> for client calls but it is not fixable for in-class modifications.</li><li class="listitem" style="list-style-type: disc">We could call <code class="literal">addNewProduct()</code> from any client and modify the <code class="literal">products</code>.</li></ul></div><p>Either way, there are going to be side-effects and unintended consequences because of the mutation.</p><p>In our immutable example, it is impossible to cause those unintended consequences because our <code class="literal">FunctionalProductTracker</code> is a value type and all the properties are immutable. The <code class="literal">products</code> cannot be changed directly (it is a constant), and <code class="literal">addNewProduct()</code> returns a whole new instance, so all clients will be dealing with the instance that they expect to deal with.</p></div><div class="section" title="Testability"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec73"/>Testability</h2></div></div></div><p>Our mutable example's <code class="literal">addNewProduct()</code> method has no return values. While it is possible to write a unit test for it, it is not obvious how we should implement asserting because the method causes a side-effect in our existing instance that we need to know about.</p><p>Our immutable example's <code class="literal">addNewProduct()</code> method returns a new <code class="literal">Array</code> of <code class="literal">Product</code>. We simply inspect the value of <code class="literal">products</code> and assert. We still have both the old and new instances, so we have everything we need to ensure that our code works as intended.</p><p>Although we do not cover unit-testing in this book, it is highly recommended that you explore QuickCheck-based libraries such as Quick (<a class="ulink" href="https://github.com/Quick/Quick">https://github.com/Quick/Quick</a>) and SwiftCheck (<a class="ulink" href="https://github.com/typelift/SwiftCheck">https://github.com/typelift/SwiftCheck</a>) as they employ FP techniques to ease the unit testing process of our applications.</p></div></div>
<div class="section" title="Copy constructors and lenses"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Copy constructors and lenses</h1></div></div></div><p>After examining our immutable example implementation, we are not able to say that it covers all the functionalities of the imperative approach. For instance, it does not provide us with a way to change the <code class="literal">producer</code> of a <code class="literal">product</code>. After all, we cannot change it.</p><p>Whenever we need to change any property of the <code class="literal">product</code>, we need to go through the following process:</p><pre class="programlisting">let mexicanBananas = FunctionalProduct(name: bananas.name,&#13;
                                      price: bananas.price,&#13;
                                   quantity: bananas.quantity,&#13;
                                   producer: Producer(name: "XYZ",&#13;
                                                   address: "New Mexico,&#13;
                                                     Mexico"))</pre><p>This solution is verbose and does not look nice. Let's examine how we can improve this process.</p><div class="section" title="Copy constructor"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec74"/>Copy constructor</h2></div></div></div><p>The first solution is to provide a new <code class="literal">init</code> method that copies the current instance. This approach is called copy constructor. Let's add our new <code class="literal">init</code> method and leverage it:</p><pre class="programlisting">init(products: [FunctionalProduct],&#13;
    lastModified: NSDate) {&#13;
 &#13;
    self.products = products&#13;
    self.lastModified = lastModified&#13;
    }&#13;
 &#13;
    init(productTracker: FunctionalProductTracker,&#13;
               products: [FunctionalProduct]? = nil,&#13;
           lastModified: NSDate? = nil) {&#13;
 &#13;
    self.products = products ?? productTracker.products&#13;
    self.lastModified = lastModified ?? productTracker.lastModified&#13;
 }&#13;
</pre><p>We added the default <code class="literal">init</code> as well because by adding a new <code class="literal">init</code> method to our <code class="literal">struct</code>, we lost the benefit of automatic <code class="literal">init</code> generation. We also need to change our <code class="literal">addNewProduct</code> to accommodate these changes:</p><pre class="programlisting">  func addNewProduct(item: FunctionalProduct) -&gt; FunctionalProductTracker {&#13;
&#13;
    return FunctionalProductTracker(productTracker: self,&#13;
                                          products: self.products + [item])&#13;
}&#13;
</pre><p>Whenever we need to modify our object partially, we will be able to do so easily using this technique.</p></div><div class="section" title="Lens"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec75"/>Lens</h2></div></div></div><p>In the previous section, we covered copy constructors. Here, we will examine a functional structure called lens. Simply put, lenses are <span class="emphasis"><em>functional getters and setters</em></span> that are implemented for a whole object and its parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getters: We can <span class="emphasis"><em>look through</em></span> the lens at an immutable object to get its parts</li><li class="listitem" style="list-style-type: disc">Setters: We can use the lens to change a part of an immutable object</li></ul></div><p>Let's implement a <code class="literal">Lens</code>:</p><pre class="programlisting">struct Lens&lt;Whole, Part&gt; {&#13;
    let get: Whole -&gt; Part&#13;
    let set: (Part, Whole) -&gt; Whole&#13;
}&#13;
</pre><p>Let's use it to change our <code class="literal">FunctionalProduct</code> object to get and set the <code class="literal">producer</code> property:</p><pre class="programlisting">let prodProducerLens: Lens&lt;FunctionalProduct, Producer&gt; =&#13;
  Lens(get: { $0.producer},&#13;
       set: { FunctionalProduct(name: $1.name,&#13;
                               price: $1.price,&#13;
                            quantity: $1.quantity,&#13;
                            producer: $0)})</pre><p>Let's change the producer for <code class="literal">mexicanBananas</code>:</p><pre class="programlisting">let mexicanBananas2 = prodProducerLens.set(Producer(name: "QAZ",&#13;
                                                 address: "Yucatan,&#13;
                                                   Mexico"),&#13;
                                           mexicanBananas)</pre><p>Through our lens, we can change it as shown in the preceding code.</p><p>Let's examine another example. Suppose that we have a <code class="literal">Producer</code> object as follows:</p><pre class="programlisting">let chineeseProducer = Producer(name: "KGJ",&#13;
                             address: "Beijing, China")&#13;
</pre><p>We want to change the <code class="literal">address</code>:</p><pre class="programlisting">let producerAddressLens: Lens&lt;Producer, String&gt; =&#13;
  Lens(get: { $0.address },&#13;
       set: { Producer(name: $1.name,&#13;
                    address: $0)})&#13;
&#13;
let chineeseProducer2 = producerAddressLens.set("Shanghai, China",&#13;
  chineeseProducer)</pre><p>Suppose that we had <code class="literal">mexicanBananas2</code> and needed to have a Chinese banana producer, then we could use:</p><pre class="programlisting">let chineseBananaProducer = prodProducerLens.set(&#13;
  producerAddressLens.set("Shanghai, China", chineseProducer), &#13;
  mexicanBananas2)</pre><p>This syntax does not look very simple, and it seems that we did not gain much after all. In the next section, we will simplify it.</p><div class="section" title="Lens composition"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec57"/>Lens composition</h3></div></div></div><p>Lens composition will help to simplify our lens; let's examine how:</p><pre class="programlisting">infix operator &gt;&gt;&gt; { associativity right precedence 100 }&#13;
&#13;
func &gt;&gt;&gt;&lt;A,B,C&gt;(l: Lens&lt;A,B&gt;, r: Lens&lt;B,C&gt;) -&gt; Lens&lt;A,C&gt; {&#13;
    return Lens(get: { r.get(l.get($0)) },&#13;
                set: { (c, a) in&#13;
                    l.set(r.set(c,l.get(a)), a)&#13;
    })&#13;
}&#13;
</pre><p>Let's test this:</p><pre class="programlisting">let prodProducerAddress = prodProducerLens &gt;&gt;&gt; producerAddressLens&#13;
let mexicanBananaProducerAddress = prodProducerAddress.get(mexicanBananas2)&#13;
let newProducer = prodProducerAddress.set("Acupulco, Mexico",&#13;
  mexicanBananas2)&#13;
print(newProducer)&#13;
</pre><p>The result is going to be:</p><pre class="programlisting">FunctionalProduct(name: "Banana",&#13;
                  price: 0.79,&#13;
                  quantity: 2,&#13;
                  producer: Producer(name: "QAZ", address: "Acupulco, Mexico"))</pre><p>Using lenses and composition, we were able to get and set a product's producer address.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Summary</h1></div></div></div><p>In this chapter, we started by exploring the concept of immutability. We looked into its importance and benefits with examples. Then we looked at cases for mutability and went through an example to compare mutability and immutability effects on our code.</p><p>Finally, we explored the means to get and set immutable objects in a functional way, such as copy constructors and lenses.</p><p>In the following chapter, we will be introduced to OOP, <span class="strong"><strong>protocol-oriented programming</strong></span> (<span class="strong"><strong>POP</strong></span>), and <span class="strong"><strong>Functional Reactive Programming</strong></span> (<span class="strong"><strong>FRP</strong></span>). Then, we will explore the concept of mixing OOP and FP paradigms, in other words, object functional programming.</p></div></body></html>