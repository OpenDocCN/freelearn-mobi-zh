<html><head></head><body>
  <div id="_idContainer112">
    <h1 class="chapterNumber">20</h1>
    <h1 id="_idParaDest-311" class="chapterTitle">Adopting Design Patterns in Swift</h1>
    <p class="normal">Although the first publication of the <em class="italic">Gang of Four's Design Patterns: Elements of Reusable Object-Oriented Software</em> was released in October 1994, I have only been paying attention to design patterns for the last 14 years. Like most experienced developers, when I first started reading about design patterns, I recognized a lot of the patterns because I had already been using them without realizing what they were. I would have to say that since I first read about design patterns, I have not written a serious application without using at least one of them. I will tell you that I am definitely not a design pattern zealot, and if I get into a conversation about design patterns, there are usually only a couple of them that I can name without having to look them up. But one thing that I do remember is the concepts behind the major patterns and the problems they are designed to solve. This way, when I encounter one of these problems, I can look up the appropriate pattern and apply it. So, remember, as you go through this chapter, to take the time to understand the major concepts behind design patterns rather than trying to memorize the patterns themselves.</p>
    <p class="normal">In this chapter, you will learn about the following topics:</p>
    <ul>
      <li class="bullet">What are design patterns?</li>
      <li class="bullet">What types of patterns make up the creational, structural, and behavioral categories of design patterns?</li>
      <li class="bullet">How to implement the singleton and builder creational patterns in Swift</li>
      <li class="bullet">How to implement the bridge, facade, and proxy structural patterns in Swift</li>
      <li class="bullet">How to implement the command and strategy behavioral patterns in Swift</li>
    </ul>
    <h1 id="_idParaDest-312" class="title">What are design patterns?</h1>
    <p class="normal">Every experienced developer has a set of informal strategies that shape how they design and write applications. These strategies are shaped by their past experiences and the obstacles that <a id="_idIndexMarker779"/>they have had to overcome in previous projects. While these developers might swear by their own strategies, it does not mean that their strategies have been fully vetted. The use of these strategies can also introduce inconsistent implementations between different projects and developers.</p>
    <p class="normal">While the concept of design patterns dates back to the mid-1980s, they did not gain popularity until the Gang of Four released <em class="italic">Elements of Reusable Object-Oriented Software</em>, published in 1994. The book's authors, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (also known as the Gang of Four), discuss the pitfalls of object-oriented programming and describe 23 classic software design patterns. These patterns are broken up into three categories: <em class="italic">creational</em>, <em class="italic">structural</em>, and <em class="italic">behavioral</em>.</p>
    <p class="normal">A design pattern identifies common software development problems and provides a strategy to deal with them. These strategies have been proven, over the years, to be an effective solution for the problems they are intended to solve. Using these patterns can greatly speed up the development process because they provide us with solutions that have been proven to solve common software development problems.</p>
    <p class="normal">Another advantage that we get when using design patterns is consistent code that is easy to maintain because months or years from now when we look at the code, we will recognize the patterns and understand what the code does. If we properly document the code and document the design pattern we are implementing, it will also help other developers to understand what the code is doing.</p>
    <p class="normal">The two main philosophies behind design patterns are code reuse and flexibility. As a software architect, it is essential that we build reusability and flexibility into the code. This allows us to easily maintain the code in the future and also makes it easier for the applications to expand to meet future requirements, because we all know how quickly requirements change.</p>
    <p class="normal">While there is a lot to like about design patterns, and they are extremely beneficial for developers and architects, they are not the solution to world hunger that some developers make them out to be. Sometime in your development career, you will probably meet a developer or an architect who thinks that design patterns are immutable laws. These developers usually try to force the use of design patterns even when they are not necessary. A good rule of thumb is to make sure that you have a problem that needs to be fixed before you try to fix it.</p>
    <p class="normal">Design patterns are starting points for avoiding and solving common programming problems. We can think of each design pattern as a recipe. Just like a good recipe, we can tinker and adjust it to meet particular tastes. But we usually do not want to stray too far from the original recipe because we may mess it up.</p>
    <p class="normal">There are also times when we do not have a recipe for a certain dish that we want to make, just like <a id="_idIndexMarker780"/>there are times when there isn't a design pattern to solve the problem we face. In cases like this, we can use our knowledge of design patterns and their underlying philosophy to come up with an effective solution for the problem.</p>
    <p class="normal">Design patterns are generally split into three categories. These are as follows:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Creational patterns</strong>: Creational <a id="_idIndexMarker781"/>patterns support the creation of objects</li>
      <li class="bullet"><strong class="keyword">Structural patterns</strong>: Structural <a id="_idIndexMarker782"/>patterns concern types and object compositions</li>
      <li class="bullet"><strong class="keyword">Behavioral patterns</strong>: Behavioral <a id="_idIndexMarker783"/>patterns communicate between types</li>
    </ul>
    <p class="normal">While the Gang of Four defined over 20 design patterns, we are only going to look at examples of some of the more popular patterns in this chapter. Let's start off by looking at creational patterns.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Design patterns were originally defined for object-oriented programming. In this chapter, where possible, we will focus on implementing patterns in a more protocol-oriented way. Therefore, the examples in this chapter may look a little different from examples in other design pattern books, but the underlying philosophy of the solutions will be the same.</p>
    </div>
    <h1 id="_idParaDest-313" class="title">Creational design patterns</h1>
    <p class="normal">Creational patterns are design <a id="_idIndexMarker784"/>patterns that deal with how an object is created. These patterns <a id="_idIndexMarker785"/>create objects in a manner suitable for a particular situation.</p>
    <p class="normal">There are two basic ideas behind creational patterns. The first is encapsulating the knowledge of <em class="italic">which</em> concrete types should be created and the second is hiding <em class="italic">how</em> the instances of these types are created.</p>
    <p class="normal">There are five well-known patterns that are a part of the creational pattern category. They are as follows:</p>
    <ul>
      <li class="bullet"><strong class="keyword">The abstract factory pattern</strong>: This provides an interface for creating related objects without <a id="_idIndexMarker786"/>specifying the concrete type</li>
      <li class="bullet"><strong class="keyword">The builder pattern</strong>: This <a id="_idIndexMarker787"/>separates the construction of a complex object from its representation, so the same process can be used to create similar types</li>
      <li class="bullet"><strong class="keyword">The factory method pattern</strong>: This <a id="_idIndexMarker788"/>creates objects without exposing the underlying logic of how the object (or which type of object) is created</li>
      <li class="bullet"><strong class="keyword">The prototype pattern</strong>: This <a id="_idIndexMarker789"/>creates an object by cloning an existing one</li>
      <li class="bullet"><strong class="keyword">The singleton pattern</strong>: This <a id="_idIndexMarker790"/>allows one (and only one) instance of a class for the lifetime of an application</li>
    </ul>
    <p class="normal">In this chapter, we are <a id="_idIndexMarker791"/>going to show examples of how to implement <a id="_idIndexMarker792"/>the singleton and builder patterns in Swift. Let's start off by looking at one of the most controversial and possibly overused design patterns, the singleton pattern.</p>
    <h2 id="_idParaDest-314" class="title">The singleton pattern</h2>
    <p class="normal">The use of the <strong class="keyword">singleton pattern</strong> is a fairly controversial subject among certain corners of the <a id="_idIndexMarker793"/>development community. One of the main reasons for this is that the singleton pattern is probably the most overused and misused pattern. Another reason <a id="_idIndexMarker794"/>this pattern is controversial is that it introduces a global state into an application, which provides the ability to change the object at any point within the application. The singleton pattern can also introduce hidden dependencies and tight compiling. My personal opinion is that, if the singleton pattern is used correctly, there is nothing wrong with using it. However, we do need to be careful not to misuse it.</p>
    <p class="normal">The singleton pattern restricts the instantiation of a class to a single instance for the lifetime of an application. This pattern is very effective when we need exactly one object to coordinate actions within the application. An example of a good use of a singleton is if the application communicates with a remote device over Bluetooth and we also want to maintain that connection throughout the application. Some would say that we could pass the instance of the connection class from one page to the next, which is essentially what a singleton is. In my opinion, the singleton pattern, in this instance, is a much cleaner solution, because with the singleton pattern any page that needs the connection can get it without forcing every page to maintain the instance. This also allows us to maintain the connection without having to reconnect each time we go to another page.</p>
    <h3 id="_idParaDest-315" class="title">Understanding the problem</h3>
    <p class="normal">The problem that the singleton pattern is designed to address is when we need one and only one <a id="_idIndexMarker795"/>instance of a type for the lifetime of the application. The singleton pattern is usually used when we need centralized management of an internal or external resource, and a single global point of access. Another popular use of the singleton pattern is when we want to consolidate a set of related activities needed throughout the application that do not maintain a state in one place.</p>
    <p class="normal">In <em class="chapterRef">Chapter 9</em>, <em class="italic">Protocols and Protocol Extensions</em>, we used the singleton pattern in the text validation example. In that example, we used the singleton pattern because we wanted to create a single instance of the types that could then be used by all the components of the application without requiring us to create new instances of the types. These text validation types did not have a state that could be changed. They only had methods that performed the validation on the text and constants that defined how to validate the text. While some may disagree with me, I believe types like these are excellent candidates for the singleton pattern because there is no reason to create multiple instances of these types.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In that example, we implemented it using structures, which isn't a true singleton because a structure is a value type. A true singleton is implemented using a reference (class) type.</p>
    </div>
    <p class="normal">When using the singleton pattern, one of the biggest concerns is multi-threaded applications with race conditions. The issue occurs when one thread changes the state of the singleton while another thread is accessing it, producing unexpected results. As an example, if the <code class="Code-In-Text--PACKT-">TextValidation</code> classes stored the text to be validated and then we called a method to do the validation, one thread could change the stored text before the original thread did the validation. It is advisable to understand how a singleton will be used in your application, before implementing this pattern.</p>
    <h3 id="_idParaDest-316" class="title">Understanding the solution</h3>
    <p class="normal">There are <a id="_idIndexMarker796"/>several ways to implement the singleton pattern in Swift. In the method that we use here, a single instance of the class is created the first time the class constant is accessed. We will then use the class constant to gain access to this instance throughout the lifetime of the application. We will also create a private initializer <a id="_idIndexMarker797"/>that will prevent external code from creating additional instances of the class.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that we use the word <em class="italic">class</em> in this description and not <em class="italic">type</em>. The reason for this is that the singleton pattern can only truly be implemented using a reference type.</p>
    </div>
    <h3 id="_idParaDest-317" class="title">Implementing the singleton pattern</h3>
    <p class="normal">Let's look <a id="_idIndexMarker798"/>at how we implement the singleton pattern with Swift. The following code example shows how to create a singleton class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MySingleton</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> sharedInstance = <span class="hljs-type">MySingleton</span>() 
    <span class="hljs-keyword">var</span> number = <span class="hljs-number">0</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() {}
}
</code></pre>
    <p class="normal">We can see that, within the <code class="Code-In-Text--PACKT-">MySingleton</code> class, we created a static constant named <code class="Code-In-Text--PACKT-">sharedInstance</code>, which contains an instance of the <code class="Code-In-Text--PACKT-">MySingleton</code> class. A static constant can be called without having to instantiate the class. Since we declared the <code class="Code-In-Text--PACKT-">sharedInstance</code> constant static, only one instance will exist throughout the lifecycle of the application, thereby creating the singleton pattern.</p>
    <p class="normal">We also created the private initiator, which cannot be accessed outside of the class, which will restrict other code from creating additional instances of the <code class="Code-In-Text--PACKT-">MySingleton</code> class.</p>
    <p class="normal">Now, let's see how this pattern works. The <code class="Code-In-Text--PACKT-">MySingleton</code> pattern has another property, named <code class="Code-In-Text--PACKT-">number</code>, which is an integer. We will monitor how this property changes as we use the <code class="Code-In-Text--PACKT-">sharedInstance</code> property to create multiple variables of the <code class="Code-In-Text--PACKT-">MySingleton</code> type, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> singleA = <span class="hljs-type">MySingleton</span>.sharedInstance 
<span class="hljs-keyword">var</span> singleB = <span class="hljs-type">MySingleton</span>.sharedInstance 
<span class="hljs-keyword">var</span> singleC = <span class="hljs-type">MySingleton</span>.sharedInstance
singleB.number = <span class="hljs-number">2</span>
<span class="hljs-built_i">print</span>(singleA.number)
<span class="hljs-built_i">print</span>(singleB.number)
<span class="hljs-built_i">print</span>(singleC.number)
singleC.number = <span class="hljs-number">3</span>
<span class="hljs-built_i">print</span>(singleA.number)
<span class="hljs-built_i">print</span>(singleB.number)
<span class="hljs-built_i">print</span>(singleC.number)
</code></pre>
    <p class="normal">In this example, we used the <code class="Code-In-Text--PACKT-">sharedInstance</code> property to create three variables of the <code class="Code-In-Text--PACKT-">MySingleton</code> type. We initially set the <code class="Code-In-Text--PACKT-">number</code> property of the second <code class="Code-In-Text--PACKT-">MySingleton</code> variable (<code class="Code-In-Text--PACKT-">singleB</code>) to the number <code class="Code-In-Text--PACKT-">2</code>. When we printed out the value of the <code class="Code-In-Text--PACKT-">number</code> property for the <code class="Code-In-Text--PACKT-">singleA</code>, <code class="Code-In-Text--PACKT-">singleB</code>, and <code class="Code-In-Text--PACKT-">singleC</code> instances, we saw that the <code class="Code-In-Text--PACKT-">number</code> property for all three equaled <code class="Code-In-Text--PACKT-">2</code>.</p>
    <p class="normal">We then changed the value of the <code class="Code-In-Text--PACKT-">number</code> property of the third <code class="Code-In-Text--PACKT-">MySingleton</code> instance (<code class="Code-In-Text--PACKT-">singleC</code>) to the number <code class="Code-In-Text--PACKT-">3</code>. When we printed out the value of the <code class="Code-In-Text--PACKT-">number</code> property again, we saw that all three now have a value of <code class="Code-In-Text--PACKT-">3</code>. Therefore, when we change the value of the <code class="Code-In-Text--PACKT-">number</code> property in any of the instances, the values of all three change because each variable is pointed to the same instance.</p>
    <p class="normal">In this example, we implemented the singleton pattern using a reference (class) type because we <a id="_idIndexMarker799"/>wanted to ensure that only one instance of the type existed throughout the application. If we implemented this pattern with a value type, such as a structure or an enumeration, we would run the risk of there being multiple instances of the type.</p>
    <p class="normal">If you recall, each time we pass an instance of a value type, we are actually passing a copy of that instance, which means that, if we implemented the singleton pattern with a value type, each time we called the <code class="Code-In-Text--PACKT-">sharedInstance</code> property we would receive a new copy, which would effectively break the singleton pattern.</p>
    <p class="normal">The singleton pattern can be very useful when we need to maintain the state of an object throughout the application; however, be careful not to overuse it. The singleton pattern should not be used unless there is a specific requirement (<em class="italic">requirement</em> is the keyword here) for having one, and only one, instance of the class throughout the lifecycle of the application. If we are using the singleton pattern simply for convenience, then we are probably misusing it.</p>
    <p class="normal">Keep in mind that, while Apple generally recommends that we prefer value types to reference types, there are still plenty of examples, such as the singleton pattern, where we need to use reference types. When we continually tell ourselves to prefer value types to reference types, it can be very easy to forget that there are times when a reference type is needed. Don't forget to use reference types with this pattern.</p>
    <p class="normal">Now, let's look at the builder design pattern.</p>
    <h2 id="_idParaDest-318" class="title">The builder pattern</h2>
    <p class="normal">The <strong class="keyword">builder pattern</strong> helps us <a id="_idIndexMarker800"/>with the creation of complex objects and enforces <a id="_idIndexMarker801"/>the process of how these objects are created. With this pattern, we generally separate the creation logic from the complex type and put the creation logic into another type. This allows us to use the same construction process to create different representations of the type.</p>
    <h3 id="_idParaDest-319" class="title">Understanding the problem</h3>
    <p class="normal">The problem that the builder pattern is designed to address is when an instance of a type requires <a id="_idIndexMarker802"/>a large number of configurable values. We could set the configuration options when we create instances of the class, but that can cause issues if the options are not set correctly or we do not know the proper values for all the options. Another issue is the amount of code that may be needed to set all the configurable options each time we create an instance of the types.</p>
    <h3 id="_idParaDest-320" class="title">Understanding the solution</h3>
    <p class="normal">The builder pattern <a id="_idIndexMarker803"/>solves this problem by introducing an intermediary known as a builder type. This builder type contains most, if not all, of the information necessary to create an instance of the original complex type.</p>
    <p class="normal">There are two methods that we can use to implement the builder pattern. The first method is to have multiple builder types where each of the types contains the information to configure the original complex object in a specific way. In the second method, we implement the builder pattern with a single builder type that sets all the configurable options to a default value, and then we would change the values as needed.</p>
    <p class="normal">In this section, we will look at both ways to use the builder pattern, because it is important to understand how each works.</p>
    <h3 id="_idParaDest-321" class="title">Implementing the builder pattern</h3>
    <p class="normal">Before we <a id="_idIndexMarker804"/>show how we would use the builder pattern, let's look at how to create a complex structure without the builder pattern and the problems we run into.</p>
    <p class="normal">The following code creates a structure named <code class="Code-In-Text--PACKT-">BurgerOld</code>, and does not use the builder pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">BurgerOld</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> patties: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> bacon: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> cheese: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> pickles: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> ketchup: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> mustard: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> lettuce: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">var</span> tomato: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, patties: <span class="hljs-type">Int</span>, bacon: <span class="hljs-type">Bool</span>, cheese: <span class="hljs-type">Bool</span>, pickles:<span class="hljs-type">Bool</span>, ketchup: <span class="hljs-type">Bool</span>, mustard: <span class="hljs-type">Bool</span>,lettuce: <span class="hljs-type">Bool</span>, tomato: <span class="hljs-type">Bool</span>) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.patties = patties
        <span class="hljs-keyword">self</span>.bacon = bacon 
        <span class="hljs-keyword">self</span>.cheese = cheese
        <span class="hljs-keyword">self</span>.pickles = pickles
        <span class="hljs-keyword">self</span>.ketchup = ketchup
        <span class="hljs-keyword">self</span>.mustard = mustard
        <span class="hljs-keyword">self</span>.lettuce = lettuce
        <span class="hljs-keyword">self</span>.tomato = tomato
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure, we have several properties that define which condiments are on the burger and the name of the burger. Since we need to know which items are on the burgers <a id="_idIndexMarker805"/>and which items aren't, when we create an instance of the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure, the initializer requires us to define each item. This can lead to some complex initializations throughout the application, not to mention that, if we had more than one standard burger (bacon cheeseburger, cheeseburger, hamburger, and so on), we would need to make sure that each is defined correctly. Let's see how to create instances of the <code class="Code-In-Text--PACKT-">BurgerOld</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Create Hamburger</span>
<span class="hljs-keyword">var</span> hamburger = <span class="hljs-type">BurgerOld</span>(name: <span class="hljs-string">"Hamburger"</span>, patties: <span class="hljs-number">1</span>, bacon: <span class="hljs-literal">false</span>, cheese: <span class="hljs-literal">false</span>, pickles: <span class="hljs-literal">true</span>, ketchup: <span class="hljs-literal">true</span>, mustard: <span class="hljs-literal">true</span>, lettuce: <span class="hljs-literal">false</span>, tomato: <span class="hljs-literal">false</span>)
<span class="hljs-comment">// Create Cheeseburger</span>
<span class="hljs-keyword">var</span> cheeseburger = <span class="hljs-type">BurgerOld</span>(name: <span class="hljs-string">"Cheeseburger"</span>, patties: <span class="hljs-number">1</span> , bacon: <span class="hljs-literal">false</span>, cheese: <span class="hljs-literal">true</span>, pickles: <span class="hljs-literal">true</span>, ketchup: <span class="hljs-literal">true</span>, mustard: <span class="hljs-literal">true</span>, lettuce: <span class="hljs-literal">false</span>, tomato: <span class="hljs-literal">false</span>)
</code></pre>
    <p class="normal">As we can see, creating instances of the <code class="Code-In-Text--PACKT-">BurgerOld</code> type requires a lot of code. Now, let's look at a better way to do this. In this example, we will show how to use multiple builder types <a id="_idIndexMarker806"/>where each type will define what goes on each type of burger. We will begin by creating a <code class="Code-In-Text--PACKT-">BurgerBuilder</code> protocol that will have the following code in it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">BurgerBuilder</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> patties: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> bacon: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> cheese: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> pickles: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> ketchup: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> mustard: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> lettuce: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">var</span> tomato: <span class="hljs-type">Bool</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
    <p class="normal">This protocol simply defines the nine properties that will be required for any type that implements this protocol. Now, let's create two structures that implement this protocol: the <code class="Code-In-Text--PACKT-">HamburgerBuilder</code> and <code class="Code-In-Text--PACKT-">CheeseBurgerBuilder</code> structures:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">HamburgerBuilder</span><span class="hljs-class">: </span><span class="hljs-title">BurgerBuilder</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">"Burger"</span>
    <span class="hljs-keyword">let</span> patties = <span class="hljs-number">1</span> 
    <span class="hljs-keyword">let</span> bacon = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> cheese = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> pickles = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> ketchup = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> mustard = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> lettuce = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">let</span> tomato = <span class="hljs-literal">false</span>
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">CheeseBurgerBuilder</span><span class="hljs-class">: </span><span class="hljs-title">BurgerBuilder</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">let</span> name = <span class="hljs-string">"CheeseBurger"</span>
    <span class="hljs-keyword">let</span> patties = <span class="hljs-number">1</span> 
    <span class="hljs-keyword">let</span> bacon = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">let</span> cheese = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> pickles = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> ketchup = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">let</span> mustard = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> lettuce = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> tomato = <span class="hljs-literal">false</span>
}
</code></pre>
    <p class="normal">In both the <code class="Code-In-Text--PACKT-">HamburgerBuilder</code> and the <code class="Code-In-Text--PACKT-">CheeseBurgerBuilder</code> structures, all we are doing is defining the values for each of the required properties. In more complex types, we might need to initialize additional resources.</p>
    <p class="normal">Now, let's look at the <code class="Code-In-Text--PACKT-">Burger</code> structure, which will use instances of the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> protocol to <a id="_idIndexMarker807"/>create instances of itself. The following code shows this new <code class="Code-In-Text--PACKT-">Burger</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Burger</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> patties: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> bacon: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> cheese: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> pickles: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> ketchup: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> mustard: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> lettuce: <span class="hljs-type">Bool</span> 
    <span class="hljs-keyword">var</span> tomato: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">init</span>(builder: <span class="hljs-type">BurgerBuilder</span>) { 
        <span class="hljs-keyword">self</span>.name = builder.name
        <span class="hljs-keyword">self</span>.patties = builder.patties
        <span class="hljs-keyword">self</span>.bacon = builder.bacon
        <span class="hljs-keyword">self</span>.cheese = builder.cheese
        <span class="hljs-keyword">self</span>.pickles = builder.pickles
        <span class="hljs-keyword">self</span>.ketchup = builder.ketchup
        <span class="hljs-keyword">self</span>.mustard = builder.mustard
        <span class="hljs-keyword">self</span>.lettuce = builder.lettuce
        <span class="hljs-keyword">self</span>.tomato = builder.tomato
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">showBurger</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Name:\(name)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Patties: \(patties)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Bacon: \(bacon)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Cheese: \(cheese)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Pickles: \(pickles)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Ketchup: \(ketchup)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Mustard: \(mustard)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Lettuce: \(lettuce)"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Tomato: \(tomato)"</span>)
    }
}
</code></pre>
    <p class="normal">The difference between this <code class="Code-In-Text--PACKT-">Burger</code> structure and the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure shown earlier is the initializer. In the previous <code class="Code-In-Text--PACKT-">BurgerOld</code> structure, the initializer took nine arguments—one for each constant defined in the structure. In the new structure, the initializer takes <a id="_idIndexMarker808"/>one argument, which is an instance of a type that conforms to the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> protocol. This new initializer allows us to create instances of the <code class="Code-In-Text--PACKT-">Burger</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// Create Hamburger</span>
<span class="hljs-keyword">var</span> myBurger = <span class="hljs-type">Burger</span>(builder: <span class="hljs-type">HamburgerBuilder</span>()) 
myBurger.showBurger()
<span class="hljs-comment">// Create Cheeseburger</span>
<span class="hljs-keyword">var</span> myCheeseBurger = <span class="hljs-type">Burger</span>(builder: <span class="hljs-type">CheeseBurgerBuilder</span>())
<span class="hljs-comment">// Let's hold the ketchup</span>
myCheeseBurger.ketchup = <span class="hljs-literal">false</span>
myCheeseBurger.showBurger()
</code></pre>
    <p class="normal">If we compare how we create instances of the new <code class="Code-In-Text--PACKT-">Burger</code> structure to the earlier <code class="Code-In-Text--PACKT-">BurgerOld</code> structure, we can see that it is much easier to create instances of the <code class="Code-In-Text--PACKT-">Burger</code> structure. We also know that we are correctly setting the property values for each type of burger because the values are set directly in the builder classes.</p>
    <p class="normal">As we mentioned earlier, there is a second method that we can use to implement the builder pattern. Rather than having multiple builder types, we can have a single builder type that sets all the configurable options to a default value; then we change the values as needed. I use this implementation method a lot when I am updating older code because it is easy to integrate it with preexisting code.</p>
    <p class="normal">For this implementation, we will create a single <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure. This structure will be used to create instances of the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure and will, by default, set all the ingredients to their default values.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure also gives us the ability to change which ingredients will go on the burger <a id="_idIndexMarker809"/>prior to creating instances of the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure. We create the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">BurgerBuilder</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Burger"</span>
    <span class="hljs-keyword">var</span> patties = <span class="hljs-number">1</span>
    <span class="hljs-keyword">var</span> bacon = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">var</span> cheese = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">var</span> pickles = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">var</span> ketchup = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">var</span> mustard = <span class="hljs-literal">true</span> 
    <span class="hljs-keyword">var</span> lettuce = <span class="hljs-literal">false</span> 
    <span class="hljs-keyword">var</span> tomato = <span class="hljs-literal">false</span>
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setPatties</span><span class="hljs-params">(choice: Int)</span> { 
        <span class="hljs-keyword">self</span>.patties = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setBacon</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.bacon = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setCheese</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.cheese = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setPickles</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.pickles = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setKetchup</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.ketchup = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setMustard</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.mustard = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setLettuce</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.lettuce = choice
    }
<span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">setTomato</span><span class="hljs-params">(choice: Bool)</span> { 
        <span class="hljs-keyword">self</span>.tomato = choice
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">buildBurgerOld</span><span class="hljs-params">(name: String)</span> -&gt; <span class="hljs-type">BurgerOld</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">BurgerOld</span>(name: name, patties: <span class="hljs-keyword">self</span>.patties,bacon: <span class="hljs-keyword">self</span>.bacon, cheese: <span class="hljs-keyword">self</span>.cheese,pickles: <span class="hljs-keyword">self</span>.pickles, ketchup: <span class="hljs-keyword">self</span>.ketchup,mustard: <span class="hljs-keyword">self</span>.mustard, lettuce: <span class="hljs-keyword">self</span>.lettuce,tomato: <span class="hljs-keyword">self</span>.tomato)
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure, we define the nine properties (ingredients) for the burger and then create a setter method for each of the properties except for the <code class="Code-In-Text--PACKT-">name</code> property. </p>
    <p class="normal">We also <a id="_idIndexMarker810"/>create one method named <code class="Code-In-Text--PACKT-">buildBurgerOld()</code>, which will create an instance of the <code class="Code-In-Text--PACKT-">BurgerOld</code> structure based on the values of the properties for the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> instance. We use the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> burgerBuilder = <span class="hljs-type">BurgerBuilder</span>()
burgerBuilder.setCheese(choice: <span class="hljs-literal">true</span>)
burgerBuilder.setBacon(choice: <span class="hljs-literal">true</span>)
<span class="hljs-keyword">var</span> jonBurger = burgerBuilder.buildBurgerOld(name: <span class="hljs-string">"Jon's Burger"</span>)
</code></pre>
    <p class="normal">In this example, we create an instance of the <code class="Code-In-Text--PACKT-">BurgerBuilder</code> structure. We then use the <code class="Code-In-Text--PACKT-">setCheese()</code> and <code class="Code-In-Text--PACKT-">setBacon()</code> methods to add cheese and bacon to the burger. Finally, we call the <code class="Code-In-Text--PACKT-">buildBurgerOld()</code> method to create the instance of the <code class="Code-In-Text--PACKT-">burgerOld</code> structure.</p>
    <p class="normal">As we can see, both methods that were used to implement the builder pattern greatly simplify the creation of the complex type. Both methods also ensured that the instances were properly configured with default values. If you find yourself creating instances of types with very long and complex initialization commands, I recommend that you look at the builder pattern to see if you can use it to simplify the initialization.</p>
    <p class="normal">Now, let's look at structural design patterns.</p>
    <h1 id="_idParaDest-322" class="title">Structural design patterns</h1>
    <p class="normal"><strong class="keyword">Structural design patterns</strong> describe <a id="_idIndexMarker811"/>how types can be combined to form larger structures. These larger structures can generally be easier to work with and hide a lot of the complexity of the individual types. Most patterns in the structural pattern category involve connections between objects.</p>
    <p class="normal">There are seven well-known patterns that are part of the structural design pattern type. These are as follows:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Adapter</strong>: This allows <a id="_idIndexMarker812"/>types with incompatible interfaces to work together</li>
      <li class="bullet"><strong class="keyword">Bridge</strong>: This is <a id="_idIndexMarker813"/>used to separate the abstract elements of a type from the implementation so the two can vary</li>
      <li class="bullet"><strong class="keyword">Composite</strong>: This <a id="_idIndexMarker814"/>allows us to treat a group of objects as a single object</li>
      <li class="bullet"><strong class="keyword">Decorator</strong>: This lets <a id="_idIndexMarker815"/>us add or override behavior in an existing method of an object</li>
      <li class="bullet"><strong class="keyword">Facade</strong>: This <a id="_idIndexMarker816"/>provides a simplified interface for a larger and more complex body of code</li>
      <li class="bullet"><strong class="keyword">Flyweight</strong>: This <a id="_idIndexMarker817"/>allows us to reduce the resources needed to create and use a large number of similar objects</li>
      <li class="bullet"><strong class="keyword">Proxy</strong>: This is <a id="_idIndexMarker818"/>a type acting as an interface for another class or classes</li>
    </ul>
    <p class="normal">In this chapter, we are going to give examples of how to use the bridge, facade, and proxy patterns in Swift. Let's start off by looking at the bridge pattern.</p>
    <h2 id="_idParaDest-323" class="title">The bridge pattern</h2>
    <p class="normal">The <strong class="keyword">bridge pattern</strong> decouples <a id="_idIndexMarker819"/>the abstraction <a id="_idIndexMarker820"/>from the implementation so that they can both vary independently. The bridge pattern can also be thought of as a two-layer abstraction.</p>
    <h3 id="_idParaDest-324" class="title">Understanding the problem</h3>
    <p class="normal">The bridge pattern <a id="_idIndexMarker821"/>is designed to solve a couple of problems, but the one we are going to focus on here tends to arise over time as new requirements come in with new features. At some point, as these come in, we will need to change how the features interact. Eventually, this will require us to refactor the code.</p>
    <p class="normal">In object-oriented programming, this is known as an exploding class hierarchy, but it can also <a id="_idIndexMarker822"/>happen in protocol-oriented programming.</p>
    <h3 id="_idParaDest-325" class="title">Understanding the solution</h3>
    <p class="normal">The bridge pattern <a id="_idIndexMarker823"/>solves this problem by taking the interacting features and separating the functionality that is specific to each feature from the functionality that is shared between them. A bridge type can then be created, which will encapsulate the shared functionality, bringing them together.</p>
    <h3 id="_idParaDest-326" class="title">Implementing the bridge pattern</h3>
    <p class="normal">To demonstrate how we would use the bridge pattern, we will create two features. The first feature is <a id="_idIndexMarker824"/>a message feature that will store and prepare a message that we wish to send out. The second feature is the sender feature that will send the message through a specific channel, such as email or SMS messaging.</p>
    <p class="normal">Let's start off by creating two protocols named <code class="Code-In-Text--PACKT-">Message</code> and <code class="Code-In-Text--PACKT-">Sender</code>. The <code class="Code-In-Text--PACKT-">Message</code> protocol will define the requirements for types that are used to create messages. The <code class="Code-In-Text--PACKT-">Sender</code> protocol will be used to define the requirements for types that are used to send the messages through the specific channels. </p>
    <p class="normal">The following code shows how we define these two protocols:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Message</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> messageString: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">init</span>(messageString: <span class="hljs-type">String</span>)
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">prepareMessage</span><span class="hljs-params">()</span>
}
<span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">(message: Message)</span>
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Message</code> protocol defines a single property named <code class="Code-In-Text--PACKT-">messageString</code> of the <code class="Code-In-Text--PACKT-">String</code> type. This property will contain the text of the message and cannot be nil. We also define one initiator and a method named <code class="Code-In-Text--PACKT-">prepareMessage()</code>. The initializer will be used to set the <code class="Code-In-Text--PACKT-">messageString</code> property and anything else required by the message type. The <code class="Code-In-Text--PACKT-">prepareMessage()</code> method will be used to prepare the message prior to sending it. This method can be used to encrypt the message or add formatting.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Sender</code> protocol defines a method named <code class="Code-In-Text--PACKT-">sendMessage()</code>. This method will send the message through the channel defined by conforming types. In this function, we will need to ensure that the <code class="Code-In-Text--PACKT-">prepareMessage()</code> method from the message type is called prior to sending the message.</p>
    <p class="normal">Now let's see how we define two types that conform to the <code class="Code-In-Text--PACKT-">Message</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PlainTextMessage</span><span class="hljs-class">: </span><span class="hljs-title">Message</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> messageString: <span class="hljs-type">String</span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(messageString: <span class="hljs-type">String</span>) { 
        <span class="hljs-keyword">self</span>.messageString = messageString
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">prepareMessage</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">//Nothing to do</span>
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">DESEncryptedMessage</span><span class="hljs-class">: </span><span class="hljs-title">Message</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> messageString: <span class="hljs-type">String</span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(messageString: <span class="hljs-type">String</span>) { 
        <span class="hljs-keyword">self</span>.messageString = messageString
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">prepareMessage</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Encrypt message here</span>
        <span class="hljs-keyword">self</span>.messageString = <span class="hljs-string">"DES: "</span> + <span class="hljs-keyword">self</span>.messageString
    }
}
</code></pre>
    <p class="normal">Each of these types contains the required functionality to conform to the <code class="Code-In-Text--PACKT-">Message</code> protocol. The <a id="_idIndexMarker825"/>only real difference between these types is in the <code class="Code-In-Text--PACKT-">prepareMessage()</code> methods. In the <code class="Code-In-Text--PACKT-">PlainTextMessage</code> class, the <code class="Code-In-Text--PACKT-">prepareMessage()</code> method is empty because we do not need to do anything to the message prior to sending it. The <code class="Code-In-Text--PACKT-">prepareMessage()</code> method of the <code class="Code-In-Text--PACKT-">DESEncryptionMessage</code> class would normally contain the logic to encrypt the message, but for this example we will just prepend a <code class="Code-In-Text--PACKT-">DES</code> tag to the beginning of the message, letting us know that this method was called.</p>
    <p class="normal">Now let's create two types that will conform to the <code class="Code-In-Text--PACKT-">Sender</code> protocol. These types would typically handle sending the message through a specific channel; however, in the example, we will simply print a message to the console:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmailSender</span><span class="hljs-class">: </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">(message: Message)</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Sending through E-Mail:"</span>)
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(message.messageString)"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SMSSender</span><span class="hljs-class">: </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">(message: Message)</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Sending through SMS:"</span>)
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(message.messageString)"</span>)
    }
}
</code></pre>
    <p class="normal">Both the <code class="Code-In-Text--PACKT-">EmailSender</code> and the <code class="Code-In-Text--PACKT-">SMSSender</code> types conform to the <code class="Code-In-Text--PACKT-">Sender</code> protocol by implementing the <code class="Code-In-Text--PACKT-">sendMessage()</code> function.</p>
    <p class="normal">We can now use these two features, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myMessage = <span class="hljs-type">PlainTextMessage</span>(messageString: <span class="hljs-string">"Plain Text Message"</span>) 
myMessage.prepareMessage()
<span class="hljs-keyword">var</span> sender = <span class="hljs-type">SMSSender</span>() 
sender.sendMessage(message: myMessage)
</code></pre>
    <p class="normal">This will work well, and we could add code similar to this anywhere we need to create and send a message. Now let's say that, one day in the near future, we get a requirement to <a id="_idIndexMarker826"/>add a new functionality to verify the message prior to sending it, to make sure it meets the requirements of the channel we are sending the message through. </p>
    <p class="normal">To do this, we would start off by changing the <code class="Code-In-Text--PACKT-">Sender</code> protocol to add the <code class="Code-In-Text--PACKT-">verify</code> functionality.</p>
    <p class="normal">The new <code class="Code-In-Text--PACKT-">Sender</code> protocol would look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> message: <span class="hljs-type">Message?</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">()</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">verifyMessage</span><span class="hljs-params">()</span>
}
</code></pre>
    <p class="normal">To the <code class="Code-In-Text--PACKT-">Sender</code> protocol, we added a method named <code class="Code-In-Text--PACKT-">verifyMessage()</code> and added a property named <code class="Code-In-Text--PACKT-">Message</code>. We also changed the definition of the <code class="Code-In-Text--PACKT-">sendMessage()</code> method. The original <code class="Code-In-Text--PACKT-">Sender</code> protocol was designed to simply send the message, but now we need to verify the message prior to calling the <code class="Code-In-Text--PACKT-">sendMessage()</code> function; therefore, we couldn't simply pass the message to it, as we did in the previous definition.</p>
    <p class="normal">Now we will need to change the types that conform to the <code class="Code-In-Text--PACKT-">Sender</code> protocol to make them conform to this new protocol. The following code shows how we would make these changes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmailSender</span><span class="hljs-class">: </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> message: <span class="hljs-type">Message?</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Sending through E-Mail:"</span>)
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(message!.messageString)"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">verifyMessage</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Verifying E-Mail message"</span>)
    }
}
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SMSSender</span><span class="hljs-class">: </span><span class="hljs-title">Sender</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> message: <span class="hljs-type">Message?</span> 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Sending through SMS:"</span>) 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"\(message!.messageString)"</span>)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">verifyMessage</span><span class="hljs-params">()</span> { 
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Verifying SMS message"</span>)
    }
}
</code></pre>
    <p class="normal">With the changes <a id="_idIndexMarker827"/>that we made to the types that conform to the <code class="Code-In-Text--PACKT-">Sender</code> protocol, we will need to change how the code uses these types. The following example shows how we can now use them:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> myMessage = <span class="hljs-type">PlainTextMessage</span>(messageString: <span class="hljs-string">"Plain Text Message"</span>)
myMessage.prepareMessage()
<span class="hljs-keyword">var</span> sender = <span class="hljs-type">SMSSender</span>()
sender.message = myMessage
sender.verifyMessage()
sender.sendMessage()
</code></pre>
    <p class="normal">These changes are not that hard to make; however, without the bridge pattern, we would need to refactor the entire code base and make the change everywhere that we are sending messages. The bridge pattern tells us that when we have two hierarchies that closely interact together like this, we should put this interaction logic into a bridge type that will encapsulate the logic in one spot. This way, when we receive new requirements or enhancements, we can make the change in one spot, thereby limiting the refactoring that we must do. We could make a bridge type for the message and sender hierarchies, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">MessagingBridge</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">sendMessage</span><span class="hljs-params">(message: Message, sender: Sender)</span> { 
        <span class="hljs-keyword">var</span> sender = sender
        message.prepareMessage()
        sender.message = message
        sender.verifyMessage()
        sender.sendMessage()
    }
}
</code></pre>
    <p class="normal">The logic of how <a id="_idIndexMarker828"/>the messaging and sender hierarchies interact is now encapsulated into the <code class="Code-In-Text--PACKT-">MessagingBridge</code> structure. Now, when the logic needs to change, we only need to make the change to this one structure rather than having to refactor the entire code base.</p>
    <p class="normal">The bridge pattern is a very good pattern to remember and use. There have been (and still are) times that I have regretted not using the bridge pattern in my code because, as we all know, requirements change frequently, and being able to make the changes in one spot rather than throughout the code base can save us a lot of time in the future.</p>
    <p class="normal">Now, let's look at the next pattern in the structural category: the facade pattern.</p>
    <h2 id="_idParaDest-327" class="title">The facade pattern</h2>
    <p class="normal">The <strong class="keyword">facade pattern</strong> provides a <a id="_idIndexMarker829"/>simplified interface <a id="_idIndexMarker830"/>to a larger and more complex body of code. This allows us to make the libraries easier to use and understand by hiding some of the complexities. It also allows us to combine multiple APIs into a single, easier-to-use API, which is what we will see in the example.</p>
    <h3 id="_idParaDest-328" class="title">Understanding the problem</h3>
    <p class="normal">The facade pattern is often used when we have a complex system that has a large number of <a id="_idIndexMarker831"/>independent APIs that are designed to work together. Sometimes it is hard to tell where we should use the facade pattern during the initial application design. The reason for this is that we normally try to simplify the initial API design; however, over time, and as requirements change and new features are added, the APIs become more and more complex, and then it becomes evident where the facade pattern should be used.</p>
    <h3 id="_idParaDest-329" class="title">Understanding the solution</h3>
    <p class="normal">The main idea <a id="_idIndexMarker832"/>of the facade pattern is to hide the complexity of the APIs behind a simple interface. This offers us several advantages, the most obvious being that it simplifies how we interact with the APIs. It also promotes loose coupling, which allows the APIs to change as requirements change, without the need to refactor all the code that uses them.</p>
    <h3 id="_idParaDest-330" class="title">Implementing the facade pattern</h3>
    <p class="normal">To demonstrate <a id="_idIndexMarker833"/>the facade pattern, we will create three APIs: <code class="Code-In-Text--PACKT-">HotelBooking</code>, <code class="Code-In-Text--PACKT-">FlightBooking</code>, and <code class="Code-In-Text--PACKT-">RentalCarBooking</code>. These APIs will be used to search for and book hotels, flights, and rental cars for trips. While we could very easily call each of the APIs individually in the code, we are going to create a <code class="Code-In-Text--PACKT-">TravelFacade</code> structure that will allow us to access the functionality of the APIs in single calls.</p>
    <p class="normal">We will begin by defining the three APIs. Each of the APIs will need a data storage class that will store the information about the hotel, flight, or rental car. We will start off by implementing the hotel API:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Hotel</span><span class="hljs-class"> </span>{
    <span class="hljs-comment">//Information about hotel room</span>
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">HotelBooking</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getHotelNameForDates</span><span class="hljs-params">(to: Date, from: Date)</span> -&gt; [<span class="hljs-type">Hotel</span>]? { 
        <span class="hljs-keyword">let</span> hotels = [<span class="hljs-type">Hotel</span>]()
        <span class="hljs-comment">//logic to get hotels</span>
        <span class="hljs-keyword">return</span> hotels
    }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">bookHotel</span><span class="hljs-params">(hotel: Hotel)</span> {
        <span class="hljs-comment">// logic to reserve hotel room</span>
    }
}
</code></pre>
    <p class="normal">The hotel API consists of the <code class="Code-In-Text--PACKT-">Hotel</code> and <code class="Code-In-Text--PACKT-">HotelBooking</code> structures. The <code class="Code-In-Text--PACKT-">Hotel</code> structure will be used to store the information about a hotel room, and the <code class="Code-In-Text--PACKT-">HotelBooking</code> structure will <a id="_idIndexMarker834"/>be used to search for a hotel room and to book the room for the trip. The flight and rental car APIs are very similar to the hotel API. The following code shows both of these APIs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Flight</span><span class="hljs-class"> </span>{
    <span class="hljs-comment">//Information about flights</span>
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">FlightBooking</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getFlightNameForDates</span><span class="hljs-params">(to: Date, from: Date)</span> -&gt;[<span class="hljs-type">Flight</span>]? {
        <span class="hljs-keyword">let</span> flights = [<span class="hljs-type">Flight</span>]()
        <span class="hljs-comment">//logic to get flights return flights</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">bookFlight</span><span class="hljs-params">(flight: Flight)</span> {
        <span class="hljs-comment">// logic to reserve flight</span>
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">RentalCar</span><span class="hljs-class"> </span>{
    <span class="hljs-comment">//Information about rental cars</span>
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">RentalCarBooking</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getRentalCarNameForDates</span><span class="hljs-params">(to: Date, from: Date)</span>-&gt; [<span class="hljs-type">RentalCar</span>]?
    {
        <span class="hljs-keyword">let</span> cars = [<span class="hljs-type">RentalCar</span>]()
        <span class="hljs-comment">//logic to get flights return cars</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">bookRentalCar</span><span class="hljs-params">(rentalCar: RentalCar)</span> {
        <span class="hljs-comment">// logic to reserve rental car</span>
    }
}
</code></pre>
    <p class="normal">In each of these APIs, we have a structure that is used to store information and a structure that is used to provide the search/booking functionality. In the initial design, it would be very easy to call these individual APIs within the application; however, as we all know, requirements tend to change, which causes the APIs to change over time.</p>
    <p class="normal">By using the facade pattern here, we are able to hide how we implement the APIs; therefore, if we need to change how the APIs work in the future, we will only need to update the <a id="_idIndexMarker835"/>facade type rather than refactoring all of the code. This makes the code easier to maintain and update in the future. Now let's look at how we will implement the facade pattern by creating a <code class="Code-In-Text--PACKT-">TravelFacade</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">TravelFacade</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> hotels: [<span class="hljs-type">Hotel</span>]?
    <span class="hljs-keyword">var</span> flights: [<span class="hljs-type">Flight</span>]? 
    <span class="hljs-keyword">var</span> cars: [<span class="hljs-type">RentalCar</span>]?
    <span class="hljs-keyword">init</span>(to: <span class="hljs-type">Date</span>, from: <span class="hljs-type">Date</span>) {
        hotels = <span class="hljs-type">HotelBooking</span>.getHotelNameForDates(to: to, from:from) 
        flights = <span class="hljs-type">FlightBooking</span>.getFlightNameForDates(to: to, from:from) 
        cars = <span class="hljs-type">RentalCarBooking</span>.getRentalCarNameForDates(to: to, from:from)
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">bookTrip</span><span class="hljs-params">(hotel: Hotel, flight: Flight, rentalCar: RentalCar)</span> {
        <span class="hljs-type">HotelBooking</span>.bookHotel(hotel: hotel) 
        <span class="hljs-type">FlightBooking</span>.bookFlight(flight: flight)
        <span class="hljs-type">RentalCarBooking</span>.bookRentalCar(rentalCar: rentalCar)
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">TravelFacade</code> class contains the functionality to search the three APIs and book a hotel, flight, and rental car. We can now use the <code class="Code-In-Text--PACKT-">TravelFacade</code> class to search for hotels, flights, and rental cars without having to directly access the individual APIs.</p>
    <p class="normal">As we mentioned at the start of this chapter, it is not always obvious when we should use the facade pattern in the initial design.</p>
    <p class="normal">A good rule to follow is: if we have several APIs that are working together to perform a task, we should <a id="_idIndexMarker836"/>think about using the facade pattern.</p>
    <p class="normal">Now, let's look at the last structural pattern, which is the proxy design pattern.</p>
    <h2 id="_idParaDest-331" class="title">The proxy pattern</h2>
    <p class="normal">In the <strong class="keyword">proxy design pattern</strong>, there is one <a id="_idIndexMarker837"/>type acting as an interface for <a id="_idIndexMarker838"/>another type or API. This wrapper class, which is the proxy, can then add functionality to the object, make the object available over a network, or restrict access to the object.</p>
    <h3 id="_idParaDest-332" class="title">Understanding the problem</h3>
    <p class="normal">We can use <a id="_idIndexMarker839"/>the proxy pattern to solve several problems, but I find that I mainly use this pattern to solve one of two problems.</p>
    <p class="normal">The first problem that I use this pattern to solve is when I want to create a layer of abstraction between a single API and my code. The API could be a local or remote API, but I usually use this pattern to put an abstraction layer between my code and a remote service. This will allow changes to the remote API without the need to refactor large portions of the application code.</p>
    <p class="normal">The second problem that I use the proxy pattern to solve is when I need to make changes to an API, but I do not have the code or there is already a dependency on the API elsewhere in the application.</p>
    <h3 id="_idParaDest-333" class="title">Understanding the solution</h3>
    <p class="normal">To solve <a id="_idIndexMarker840"/>these problems, the proxy pattern tells us that we should create a type that will act as an interface for interacting with the other type or API. In the example, we will show how to use the proxy pattern to add functionality to an existing type.</p>
    <h3 id="_idParaDest-334" class="title">Implementing the proxy pattern</h3>
    <p class="normal">In this <a id="_idIndexMarker841"/>section, we will demonstrate the proxy pattern by creating a house class that we can add multiple floor plans to, where each floor plan represents a different story of the house. Let's begin by creating a <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">FloorPlan</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> bedRooms: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> utilityRooms: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">var</span> bathRooms: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> } 
    <span class="hljs-keyword">var</span> kitchen: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> livingRooms: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol, we define five properties that will represent the number of rooms contained in each floor plan. Now, let's create an implementation of the <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol named <code class="Code-In-Text--PACKT-">HouseFloorPlan</code>, which is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">HouseFloorPlan</span><span class="hljs-class">: </span><span class="hljs-title">FloorPlan</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> bedRooms = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> utilityRooms = <span class="hljs-number">0</span> 
    <span class="hljs-keyword">var</span> bathRooms = <span class="hljs-number">0</span> 
    <span class="hljs-keyword">var</span> kitchen = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> livingRooms = <span class="hljs-number">0</span>
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">HouseFloorPlan</code> structure implements all five properties required from the <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol and <a id="_idIndexMarker842"/>assigns default values to them. Next, we will create the <code class="Code-In-Text--PACKT-">House</code> type, which will represent a house:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">House</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> stories = [<span class="hljs-type">FloorPlan</span>]()
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">addStory</span><span class="hljs-params">(floorPlan: FloorPlan)</span> { 
        stories.append(floorPlan)
    }
}
</code></pre>
    <p class="normal">Within the <code class="Code-In-Text--PACKT-">House</code> structure, we have an array of instances that conforms to the <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol where each floor plan will represent one story of the house. We also have a function named <code class="Code-In-Text--PACKT-">addStory()</code>, which accepts an instance of a type that conforms to the <code class="Code-In-Text--PACKT-">FloorPlan</code> protocol. This function will add the floor plan to the array of <code class="Code-In-Text--PACKT-">FloorPlan</code> protocols.</p>
    <p class="normal">If we think about the logic of this class, there is one problem that we might encounter: we are allowed to add as many floor plans as we want, which may lead to houses that are 60 or 70 stories high. This would be great if we were building skyscrapers, but we just want to build basic single-family houses. If we want to limit the number of floor plans without changing the <code class="Code-In-Text--PACKT-">House</code> class (either we cannot change it, or we simply do not want to), we can implement the proxy pattern. The following example shows how to implement the <code class="Code-In-Text--PACKT-">HouseProxy</code> class, where we limit the number of floor plans we can add to the house:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">HouseProxy</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">var</span> house = <span class="hljs-type">House</span>()
    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">addStory</span><span class="hljs-params">(floorPlan: FloorPlan)</span> -&gt; <span class="hljs-type">Bool</span> { 
        <span class="hljs-keyword">if</span> house.stories.<span class="hljs-built_i">count</span> &lt; <span class="hljs-number">3</span> {
            house.addStory(floorPlan: floorPlan)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }
}
</code></pre>
    <p class="normal">We begin the <code class="Code-In-Text--PACKT-">HouseProxy</code> class by creating an instance of the <code class="Code-In-Text--PACKT-">House</code> class. We then create a method named <code class="Code-In-Text--PACKT-">addStory()</code>, which lets us add a new floor plan to the house. In the <code class="Code-In-Text--PACKT-">addStory()</code> method, we check to see if the number of stories in the house is fewer than three; if so, we add <a id="_idIndexMarker843"/>the floor plan to the house and return <code class="Code-In-Text--PACKT-">true</code>. If the number of stories is equal to or greater than three, then we do not add the floor plan to the house and return <code class="Code-In-Text--PACKT-">false</code>. Let's see how we can use this proxy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> ourHouse = <span class="hljs-type">HouseProxy</span>()
<span class="hljs-keyword">var</span> basement = <span class="hljs-type">HouseFloorPlan</span>(bedRooms: <span class="hljs-number">0</span>, utilityRooms: <span class="hljs-number">1</span>, bathRooms:<span class="hljs-number">1</span>,kitchen: <span class="hljs-number">0</span>, livingRooms: <span class="hljs-number">1</span>)
<span class="hljs-keyword">var</span> firstStory = <span class="hljs-type">HouseFloorPlan</span> (bedRooms: <span class="hljs-number">1</span>, utilityRooms: <span class="hljs-number">0</span>,bathRooms: <span class="hljs-number">2</span>,kitchen: <span class="hljs-number">1</span>, livingRooms: <span class="hljs-number">1</span>)
<span class="hljs-keyword">var</span> secondStory = <span class="hljs-type">HouseFloorPlan</span> (bedRooms: <span class="hljs-number">2</span>, utilityRooms: <span class="hljs-number">0</span>,bathRooms: <span class="hljs-number">1</span>,kitchen: <span class="hljs-number">0</span>, livingRooms: <span class="hljs-number">1</span>)
<span class="hljs-keyword">var</span> additionalStory = <span class="hljs-type">HouseFloorPlan</span> (bedRooms: <span class="hljs-number">1</span>, utilityRooms: <span class="hljs-number">0</span>,bathRooms:<span class="hljs-number">1</span>, kitchen: <span class="hljs-number">1</span>, livingRooms: <span class="hljs-number">1</span>)
ourHouse.addStory(floorPlan: basement)
ourHouse.addStory(floorPlan: firstStory)
ourHouse.addStory(floorPlan: secondStory)
ourHouse.addStory(floorPlan: additionalStory)
</code></pre>
    <p class="normal">In the example code, we start off by creating an instance of the <code class="Code-In-Text--PACKT-">HouseProxy</code> class named <code class="Code-In-Text--PACKT-">ourHouse</code>. We then create four instances of the <code class="Code-In-Text--PACKT-">HouseFloorPlan</code> type, each with a different number of rooms. Finally, we attempt to add each of the floor plans to the <code class="Code-In-Text--PACKT-">ourHouse</code> instance. If we run this code, we will see that the first three instances of the <code class="Code-In-Text--PACKT-">floorplans</code> class were <a id="_idIndexMarker844"/>added to the house successfully, but the last one wasn't because we are only allowed to add three floors.</p>
    <p class="normal">The proxy pattern is very useful when we want to add some additional functionality or error checking to a type, but we do not want to change the actual type itself. We can also use it to add a layer of abstraction between a remote or local API.</p>
    <p class="normal">Now, let's look at behavioral design patterns.</p>
    <h1 id="_idParaDest-335" class="title">Behavioral design patterns</h1>
    <p class="normal">Behavioral design patterns explain how types interact with each other. These patterns describe <a id="_idIndexMarker845"/>how different instances of types send messages to each other to make things happen.</p>
    <p class="normal">There are nine well-known patterns that are part of the behavioral design pattern type. They are as follows:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Chain of responsibility</strong>: This is <a id="_idIndexMarker846"/>used to process a variety of requests, each of which may be delegated to a different handler.</li>
      <li class="bullet"><strong class="keyword">Command</strong>: This <a id="_idIndexMarker847"/>creates objects that can encapsulate actions or parameters so that they can be invoked later or by a different component.</li>
      <li class="bullet"><strong class="keyword">Iterator</strong>: This <a id="_idIndexMarker848"/>allows us to access the elements of an object sequentially without exposing the underlying structure.</li>
      <li class="bullet"><strong class="keyword">Mediator</strong>: This is <a id="_idIndexMarker849"/>used to reduce coupling between types that communicate with each other.</li>
      <li class="bullet"><strong class="keyword">Memento</strong>: This is <a id="_idIndexMarker850"/>used to capture the current state of an object and store it in a manner that can be restored later.</li>
      <li class="bullet"><strong class="keyword">Observer</strong>: This <a id="_idIndexMarker851"/>allows an object to publish changes to an object's state. Other objects can then subscribe so they can be notified of any changes.</li>
      <li class="bullet"><strong class="keyword">State</strong>: This is used <a id="_idIndexMarker852"/>to alter the behavior of an object when its internal state changes.</li>
      <li class="bullet"><strong class="keyword">Strategy</strong>: This <a id="_idIndexMarker853"/>allows one out of a family of algorithms to be chosen at runtime.</li>
      <li class="bullet"><strong class="keyword">Visitor</strong>: This is <a id="_idIndexMarker854"/>a way of separating an algorithm from an object structure.</li>
    </ul>
    <p class="normal">In this section, we are <a id="_idIndexMarker855"/>going to give examples of how to use strategy and command patterns in Swift. Let's start off by looking at the command pattern.</p>
    <h2 id="_idParaDest-336" class="title">The command pattern</h2>
    <p class="normal">The command design pattern lets us <a id="_idIndexMarker856"/>define actions that we <a id="_idIndexMarker857"/>can execute later. This pattern generally encapsulates all the information needed to call or trigger the actions at a later time.</p>
    <h3 id="_idParaDest-337" class="title">Understanding the problem</h3>
    <p class="normal">There are <a id="_idIndexMarker858"/>times in applications when we need to separate the execution of a command from its invoker. Typically, this is when we have a type that needs to perform one of several actions, but the choice of which action to use needs to be made at runtime.</p>
    <h3 id="_idParaDest-338" class="title">Understanding the solution</h3>
    <p class="normal">The command pattern tells us that we should encapsulate the logic for the actions into a type that <a id="_idIndexMarker859"/>conforms to a command protocol. We can then provide instances of the command types for use by the invoker. The invoker will use the interface provided by the protocol to invoke the necessary actions.</p>
    <h3 id="_idParaDest-339" class="title">Implementing the command pattern</h3>
    <p class="normal">In this section, we will demonstrate how to use the command pattern by creating a <code class="Code-In-Text--PACKT-">Light</code> type. In this type, we will define the <code class="Code-In-Text--PACKT-">lightOnCommand</code> and <code class="Code-In-Text--PACKT-">lightOffCommand</code> commands and <a id="_idIndexMarker860"/>will use the <code class="Code-In-Text--PACKT-">turnOnLight()</code> and <code class="Code-In-Text--PACKT-">turnOffLight()</code> methods to invoke these commands. We will begin by creating a protocol named <code class="Code-In-Text--PACKT-">Command</code>, which all of the command types will conform to. Here is the <code class="Code-In-Text--PACKT-">Command</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">Command</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">execute</span><span class="hljs-params">()</span>
}
</code></pre>
    <p class="normal">This protocol contains a method named <code class="Code-In-Text--PACKT-">execute()</code>, which will be used to execute the command. Now, let's look at the command types that the <code class="Code-In-Text--PACKT-">Light</code> type will use to turn the light on and off. They are as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">RockerSwitchLightOnCommand</span><span class="hljs-class">: </span><span class="hljs-title">Command</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Rocker Switch:Turning Light On"</span>)
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">RockerSwitchLightOffCommand</span><span class="hljs-class">: </span><span class="hljs-title">Command</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Rocker Switch:Turning Light Off"</span>)
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">PullSwitchLightOnCommand</span><span class="hljs-class">: </span><span class="hljs-title">Command</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Pull Switch:Turning Light On"</span>)
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">PullSwitchLightOffCommand</span><span class="hljs-class">: </span><span class="hljs-title">Command</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">execute</span><span class="hljs-params">()</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Pull Switch:Turning Light Off"</span>)
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">RockerSwitchLightOffCommand</code>, <code class="Code-In-Text--PACKT-">RockerSwitchLightOnCommand</code>, <code class="Code-In-Text--PACKT-">PullSwitchLightOnCommand</code>, and <code class="Code-In-Text--PACKT-">PullSwitchLightOffCommand</code> commands all conform to the <code class="Code-In-Text--PACKT-">Command</code> protocol by implementing the <code class="Code-In-Text--PACKT-">execute()</code> method; therefore, we will be able to use them in the <code class="Code-In-Text--PACKT-">Light</code> type. Now, let's look at how to implement the <code class="Code-In-Text--PACKT-">Light</code> type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">Light</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> lightOnCommand: <span class="hljs-type">Command</span>
    <span class="hljs-keyword">var</span> lightOffCommand: <span class="hljs-type">Command</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">turnOnLight</span><span class="hljs-params">()</span> { 
        <span class="hljs-keyword">self</span>.lightOnCommand.execute()
    }
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">turnOffLight</span><span class="hljs-params">()</span> { 
        <span class="hljs-keyword">self</span>.lightOffCommand.execute()
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">Light</code> type, we start off by creating two variables, named <code class="Code-In-Text--PACKT-">lightOnCommand</code> and <code class="Code-In-Text--PACKT-">lightOffCommand</code>, which will contain instances of types that conform to the <code class="Code-In-Text--PACKT-">Command</code> protocol. Then we create the <code class="Code-In-Text--PACKT-">turnOnLight()</code> and <code class="Code-In-Text--PACKT-">turnOffLight()</code> methods that we will use to turn <a id="_idIndexMarker861"/>the light on and off. In these methods, we call the appropriate command to turn the light on or off.</p>
    <p class="normal">We would then use the <code class="Code-In-Text--PACKT-">Light</code> type as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> on = <span class="hljs-type">PullSwitchLightOnCommand</span>()
<span class="hljs-keyword">var</span> off = <span class="hljs-type">PullSwitchLightOffCommand</span>()
<span class="hljs-keyword">var</span> light = <span class="hljs-type">Light</span>(lightOnCommand: on, lightOffCommand: off)
light.turnOnLight()
light.turnOffLight()
light.lightOnCommand = <span class="hljs-type">RockerSwitchLightOnCommand</span>() 
light.turnOnLight()
</code></pre>
    <p class="normal">In this example, we begin by creating an instance of the <code class="Code-In-Text--PACKT-">PullSwitchLightOnCommand</code> type named <code class="Code-In-Text--PACKT-">on</code> and an instance of the <code class="Code-In-Text--PACKT-">PullSwitchLightOffCommand</code> type named <code class="Code-In-Text--PACKT-">off</code>. We then create an instance of the <code class="Code-In-Text--PACKT-">Light</code> type using the two commands that we just created and call the <code class="Code-In-Text--PACKT-">turnOnLight()</code> and <code class="Code-In-Text--PACKT-">turnOffLight()</code> methods of the <code class="Code-In-Text--PACKT-">Light</code> instance to turn the light on and off. In the last two lines, we change the <code class="Code-In-Text--PACKT-">lightOnCommand</code> method, which was originally set to an instance of the <code class="Code-In-Text--PACKT-">PullSwitchLightOnCommand</code> class, to an instance of the <code class="Code-In-Text--PACKT-">RockerSwitchLightOnCommand</code> type. The <code class="Code-In-Text--PACKT-">Light</code> instance will now use the <code class="Code-In-Text--PACKT-">RockerSwitchLightOnCommand</code> type whenever we turn the light on. This allows us to change the functionality of the <code class="Code-In-Text--PACKT-">Light</code> type during runtime.</p>
    <p class="normal">There are several benefits of using the command pattern. One of the main benefits is that we are able to set which command to invoke at runtime, which also lets us swap the commands out with different implementations that conform to the <code class="Code-In-Text--PACKT-">Command</code> protocol as needed throughout the life of the application. Another advantage of the command pattern is that we encapsulate the details of command implementations within the <a id="_idIndexMarker862"/>command types themselves rather than in the container type.</p>
    <p class="normal">Now, let's look at the last design pattern, the strategy pattern.</p>
    <h2 id="_idParaDest-340" class="title">The strategy pattern</h2>
    <p class="normal">The strategy pattern is pretty similar to the command pattern in that they both allow us to decouple <a id="_idIndexMarker863"/>implementation details from the calling type, and also allow us to switch the implementation out at runtime. The big <a id="_idIndexMarker864"/>difference is that the strategy pattern is intended to encapsulate algorithms. By swapping out an algorithm, we are expecting the object to perform the same functionality, but in a different way. In the command pattern, when we swap out the commands, we are expecting the object to change the functionality.</p>
    <h3 id="_idParaDest-341" class="title">Understanding the problem</h3>
    <p class="normal">There are <a id="_idIndexMarker865"/>times in applications when we need to change the backend algorithm that is used to perform an operation. Typically, this is when we have a type that has several different algorithms that can be used to perform the same task, but the choice of which algorithm to use needs to be made at runtime.</p>
    <h3 id="_idParaDest-342" class="title">Understanding the solution</h3>
    <p class="normal">The strategy <a id="_idIndexMarker866"/>pattern tells us that we should encapsulate the algorithm in a type that conforms to a strategy protocol. We can then provide instances of the strategy types for use by the invoker. The invoker will use the interface provided by the protocol to invoke the algorithm.</p>
    <h3 id="_idParaDest-343" class="title">Implementing the strategy pattern</h3>
    <p class="normal">In this section, we will demonstrate the strategy pattern by showing you how we could swap out <a id="_idIndexMarker867"/>compression algorithms at runtime. Let's begin this example by creating a <code class="Code-In-Text--PACKT-">CompressionStrategy</code> protocol that each one of the compression types will conform to. Let's look at the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protocol</span><span class="hljs-class"> </span><span class="hljs-title">CompressionStrategy</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">compressFiles</span><span class="hljs-params">(filePaths: [String])</span>
}
</code></pre>
    <p class="normal">This protocol defines a method named <code class="Code-In-Text--PACKT-">compressFiles()</code> that accepts a single parameter, which is an array of strings that contains the paths to the files we want to compress. We will now create two structures that conform to this protocol. These are the <code class="Code-In-Text--PACKT-">ZipCompressionStrategy</code> and <code class="Code-In-Text--PACKT-">RarCompressionStrategy</code> structures, which are as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">ZipCompressionStrategy</span><span class="hljs-class">: </span><span class="hljs-title">CompressionStrategy</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">compressFiles</span><span class="hljs-params">(filePaths: [String])</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Using Zip Compression"</span>)
    }
}
<span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">RarCompressionStrategy</span><span class="hljs-class">: </span><span class="hljs-title">CompressionStrategy</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">compressFiles</span><span class="hljs-params">(filePaths: [String])</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"Using RAR Compression"</span>)
    }
}
</code></pre>
    <p class="normal">Both of these structures implement the <code class="Code-In-Text--PACKT-">CompressionStrategy</code> protocol by using a method named <code class="Code-In-Text--PACKT-">compressFiles()</code>, which accepts an array of strings. Within these methods, we simply print out the name of the compression that we are using. Normally, we would implement the compression logic in these methods.</p>
    <p class="normal">Now, let's look at the <code class="Code-In-Text--PACKT-">CompressContent</code> class, which will be used to compress the files:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">CompressContent</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">var</span> strategy: <span class="hljs-type">CompressionStrategy</span>
    <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">compressFiles</span><span class="hljs-params">(filePaths: [String])</span> { 
        <span class="hljs-keyword">self</span>.strategy.compressFiles(filePaths: filePaths)
    }
}
</code></pre>
    <p class="normal">In this class, we start <a id="_idIndexMarker868"/>off by defining a variable, named <code class="Code-In-Text--PACKT-">strategy</code>, which will contain an instance of a type that conforms to the <code class="Code-In-Text--PACKT-">CompressionStrategy</code> protocol. Then we create a method named <code class="Code-In-Text--PACKT-">compressFiles()</code>, which accepts an array of strings that contains the paths to the list of files that we wish to compress. In this method, we compress the files using the compression strategy that is set in the <code class="Code-In-Text--PACKT-">strategy</code> variable.</p>
    <p class="normal">We will use the <code class="Code-In-Text--PACKT-">CompressContent</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> filePaths = [<span class="hljs-string">"file1.txt"</span>, <span class="hljs-string">"file2.txt"</span>]
<span class="hljs-keyword">var</span> <span class="hljs-built_i">zip</span> = <span class="hljs-type">ZipCompressionStrategy</span>()
<span class="hljs-keyword">var</span> rar = <span class="hljs-type">RarCompressionStrategy</span>()
<span class="hljs-keyword">var</span> compress = <span class="hljs-type">CompressContent</span>(strategy: <span class="hljs-built_i">zip</span>)
compress.compressFiles(filePaths: filePaths)
compress.strategy = rar
compress.compressFiles(filePaths: filePaths)
</code></pre>
    <p class="normal">We begin by creating an array of strings that contains the files we wish to compress. We also create an instance of both the <code class="Code-In-Text--PACKT-">ZipCompressionStrategy</code> and <code class="Code-In-Text--PACKT-">RarCompressionStrategy</code> types. We then create an instance of the <code class="Code-In-Text--PACKT-">CompressContent</code> class, setting the compression strategy to the <code class="Code-In-Text--PACKT-">ZipCompressionStrategy</code> instance, and call the <code class="Code-In-Text--PACKT-">compressFiles()</code> method, which will print the <code class="Code-In-Text--PACKT-">Using zip compression</code> message to the console. We then set the compression strategy to the <code class="Code-In-Text--PACKT-">RarCompressionStrategy</code> instance and call the <code class="Code-In-Text--PACKT-">compressFiles()</code> method again, which will print the <code class="Code-In-Text--PACKT-">Using rar compression</code> message to the console.</p>
    <p class="normal">The strategy pattern is really good for setting the algorithms to use at runtime, which also lets us swap the algorithms out with different implementations as needed by the application. Another advantage of the strategy pattern is that we encapsulate the details of the algorithm within the strategy types themselves and not in the main implementation type.</p>
    <p class="normal">This <a id="_idIndexMarker869"/>concludes the tour of design patterns in Swift.</p>
    <h1 id="_idParaDest-344" class="title">Summary</h1>
    <p class="normal">Design patterns are solutions to software design problems that we tend to see over and over again in real-world application design. These patterns are designed to help us create reusable and flexible code. Design patterns can also make code easier to read and understand for other developers and also for ourselves when we look back at the code months or years later.</p>
    <p class="normal">If we look at the examples in this chapter carefully, we will notice that one of the backbones of design patterns is the protocol. Almost all design patterns (the singleton design pattern is an exception) use protocols to help us create very flexible and reusable code.</p>
    <p class="normal">If this was the first time that you really looked at design patterns, you probably noticed some strategies that you have used in the past in your own code. This is expected when experienced developers are first introduced to design patterns. I would also encourage you to read more about design patterns because they will definitely help you to create more flexible and reusable code.</p>
    <p class="normal">Swift is a language that is rapidly changing and it is important to keep up to date with it. Since Swift is an open source project, there are plenty of resources that will help you. I would definitely recommend bookmarking <a href="http://swiftdoc.org"><span class="url">http://swiftdoc.org</span></a> in your favorite browser. It has auto-generated documentation for the Swift language and is a great resource.</p>
    <p class="normal">Another site to bookmark is <a href="https://swift.org"><span class="url">https://swift.org</span></a>. This is the main open source Swift site. On this site, you will find links to the Swift source code, blog posts, getting started pages, and information on how to install Swift.</p>
    <p class="normal">I would also recommend signing up for some of the mailing lists on the swift.org site. The lists are located in the community section. The <code class="Code-In-Text--PACKT-">Swift-users</code> mailing list is an excellent place to ask questions and is the list that Apple monitors. If you want to stay up to date with changes to Swift, then I would recommend the <code class="Code-In-Text--PACKT-">swift-evolution-announce</code> list.</p>
    <p class="normal">I hope you have enjoyed reading this book as much as I have enjoyed writing it.</p>
  </div>
</body></html>