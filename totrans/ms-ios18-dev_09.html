<html><head></head><body>
		<div><h1 id="_idParaDest-164" class="chapter-number"><a id="_idTextAnchor289"/><st c="0">9</st></h1>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor290"/><st c="1">Creating Dynamic Graphs with Swift Charts</st></h1>
			<p><strong class="bold"><st c="42">Swift Charts</st></strong><st c="55"> is a framework by Apple that allows</st><a id="_idIndexMarker481"/><st c="91"> us to present data in beautiful and expressive charts. </st><st c="147">Working with charts is not a minor topic – data is an essential topic in mobile apps, and the ability to show glance information of insights and trends is crucial to our app’s </st><st c="323">user experience.</st></p>
			<p><st c="339">In this chapter, we will cover the </st><st c="375">following topics:</st></p>
			<ul>
				<li><st c="392">Understanding why we need charts in </st><st c="429">our apps</st></li>
				<li><st c="437">Meeting the Swift </st><st c="456">Charts framework</st></li>
				<li><st c="472">Creating charts such as bar, line, pie, area, and </st><st c="523">point charts</st></li>
				<li><st c="535">Visualizing functions </st><st c="558">with Charts</st></li>
				<li><st c="569">Implementing user interaction to our charts </st><st c="614">using ChartProxy</st></li>
				<li><st c="630">Allowing different data types to work with charts by conforming to the </st><st c="702">Plottable protocol</st></li>
			</ul>
			<p><st c="720">Before we create our first chart, let’s understand why charts are important and what value </st><st c="812">they bring.</st></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor291"/><st c="823">Technical requirements</st></h1>
			<p><st c="846">For this chapter, you must download Xcode version 15.0 or above from Apple’s </st><st c="924">App Store.</st></p>
			<p><st c="934">You’ll also need to run the latest version of macOS (Ventura or above). </st><st c="1007">Simply search for Xcode in the App Store and select and download the latest version. </st><st c="1092">Launch Xcode and follow any additional installation instructions that your system may prompt you with. </st><st c="1195">Once Xcode has fully launched, you’re ready </st><st c="1239">to go.</st></p>
			<p><st c="1245">Download the sample code from the following GitHub </st><st c="1297">link: </st><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm"><st c="1303">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter9/Chapter9.swiftpm</st></a></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor292"/><st c="1402">Why charts?</st></h1>
			<p><st c="1414">The following is not necessarily </st><a id="_idIndexMarker482"/><st c="1448">a mobile-specific section but an important one nevertheless. </st><st c="1509">Many apps display helpful information in a textual way, such as tables, lists, or grids. </st><st c="1598">While displaying information in a list or a grid can be beneficial, it’s much harder to tell the story </st><st c="1701">that way.</st></p>
			<p><st c="1710">Users sometimes struggle to process a textual representation of information, and visualizing it may help them gain interesting insights and make decisions. </st><st c="1867">There might be different types of insights, which can be relationships between data points, trends, and </st><st c="1971">repeated patterns.</st></p>
			<p><st c="1989">Data can be even more difficult to digest on a mobile phone due to the screen size and the challenge of presenting information in grids. </st><st c="2127">However, screen size is not the only challenge with mobile phones – users often expect to glimpse data insights rather than analyze spreadsheets. </st><st c="2273">A mobile user experience differs from a desktop one because of different use cases and behavior. </st><st c="2370">Due to that difference, charts have even greater value on mobile than on desktop apps, as they provide a way to present </st><st c="2490">information visually.</st></p>
			<p><st c="2511">Having said that, it is essential not to overuse charts or to use charts where a table or a list makes more sense. </st><st c="2627">For example, a banking app that shows the user’s latest transactions would use a list rather than a chart. </st><st c="2734">A list is a great way to present raw data in a scannable format that is also interactive and allows users to perform actions or view </st><st c="2867">more details.</st></p>
			<p><st c="2880">Just as we have Lists, Tables, and Collection Views, we now have Swift Charts, a framework dedicated to presenting data in an informative, </st><st c="3020">visualized way.</st></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor293"/><st c="3035">Introducing the Swift Charts framework</st></h1>
			<p><st c="3074">Creating charts that are simple and easy</st><a id="_idIndexMarker483"/><st c="3115"> to use was always a challenge. </st><st c="3147">Unlike Tables, Collection views, or Lists, most third-party chart frameworks</st><a id="_idIndexMarker484"/><st c="3223"> never felt natural </st><st c="3243">in </st><strong class="bold"><st c="3246">UIKit/SwiftUI</st></strong><st c="3259">.</st></p>
			<p><st c="3260">In iOS 16, Apple announced Swift Charts, a SwiftUI framework that presents structured data in a chart and fits</st><a id="_idIndexMarker485"/><st c="3371"> nicely in a </st><st c="3384">SwiftUI view.</st></p>
			<p><st c="3397">Let’s see an example of a </st><st c="3424">bar chart:</st></p>
			<pre class="source-code"><st c="3434">
import Charts
struct BarMarkView: View {
    struct Sales: Identifiable {
        var id: UUID = UUID()
        let itemType: String
        let qty: Int
    }
    let data: [Sales] = [
        Sales(itemType: "Apples", qty: 50),
        Sales(itemType: "Oranges", qty: 60),
        Sales(itemType: "Watermelons", qty: 30)
    ]
    var body: some View {
        VStack {
            </st><strong class="bold"><st c="3731">Chart(data) {</st></strong>
<strong class="bold"><st c="3744">                BarMark(</st></strong>
<strong class="bold"><st c="3753">                    x: .value("Fruit", $0.itemType),</st></strong>
<strong class="bold"><st c="3786">                    y: .value("qty", $0.qty)</st></strong>
<strong class="bold"><st c="3811">                )</st></strong>
<strong class="bold"><st c="3813">            }</st></strong><st c="3815">
        }
    }
}</st></pre>			<p><st c="3821">Even though the code example seems long, it is simple to read and understand. </st><st c="3900">This example displays a </st><code><st c="3924">BarMark</st></code><st c="3931"> chart showing different sales figures for fruits. </st><st c="3982">It has a </st><code><st c="3991">Sales</st></code><st c="3996"> structure that contains a single sales information for a specific fruit type and a </st><code><st c="4080">data</st></code><st c="4084"> array that contains sales information about several </st><st c="4137">fruit types.</st></p>
			<p><st c="4149">In the SwiftUI body part, we add a new view</st><a id="_idIndexMarker486"/><st c="4193"> called </st><code><st c="4201">Chart</st></code><st c="4206"> with the </st><code><st c="4216">data</st></code><st c="4220"> array as a parameter. </st><st c="4243">Inside that </st><code><st c="4255">Chart</st></code><st c="4260"> view, we add a </st><code><st c="4276">BarMark</st></code><st c="4283"> view – a way to present data information in bars – passing the </st><code><st c="4347">x</st></code><st c="4348"> and </st><code><st c="4353">y</st></code><st c="4354"> values from our </st><code><st c="4371">Sales</st></code><st c="4376"> struct.</st></p>
			<p><em class="italic"><st c="4384">Figure 9</st></em><em class="italic"><st c="4393">.1</st></em><st c="4395"> shows </st><st c="4402">the result:</st></p>
			<div><div><img src="img/B21795_09_1.jpg" alt="Figure 9.1: A BarMark chart"/><st c="4413"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4422">Figure 9.1: A BarMark chart</st></p>
			<p><em class="italic"><st c="4449">Figure 9</st></em><em class="italic"><st c="4458">.1</st></em><st c="4460"> shows our code result—a view with three red bars, including a legend and titles. </st><st c="4542">We can see how much easier it is to create a chart, similar to how we would make a </st><code><st c="4625">List</st></code><st c="4629"> or a </st><code><st c="4635">VStack</st></code><st c="4641"> view.</st></p>
			<p><st c="4647">Let’s explore and learn how to create the different chart types and understand </st><st c="4727">their usage.</st></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor294"/><st c="4739">Creating charts</st></h1>
			<p><st c="4755">Before we continue, let’s understand</st><a id="_idIndexMarker487"/><st c="4792"> the view structure of a chart in the Swift Charts framework. </st><st c="4854">As we can see from the last code example, the chart view is </st><st c="4914">called </st><code><st c="4921">Chart</st></code><st c="4926">:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="4928">Chart</st></strong><st c="4933">(data) {
                </st><strong class="bold"><st c="4943">BarMark</st></strong><st c="4950">(
                    x: .value("Fruit", $0.itemType),
                    y: .value("qty", $0.qty)
                )
            }</st></pre>			<p><st c="5014">Each data point</st><a id="_idIndexMarker488"/><st c="5030"> in the chart is called a </st><code><st c="5138">BarMark</st></code><st c="5145"> type. </st><st c="5152">If the Chart receives an array as a parameter, it performs a </st><code><st c="5213">ForEach</st></code><st c="5220"> loop under the hood and creates </st><st c="5253">several marks.</st></p>
			<p><st c="5267">In fact, we could write the same code as </st><st c="5309">the following:</st></p>
			<pre class="source-code"><strong class="bold"><st c="5323">Chart</st></strong><st c="5329"> {
                </st><strong class="bold"><st c="5332">ForEach</st></strong><st c="5339">(data, id:\.id) { item in
                    </st><strong class="bold"><st c="5366">BarMark</st></strong><st c="5373">(x: .value("Fruit",
                              item.itemType),
                            y: .value("qty", item.qty))
                }
            }</st></pre>			<p><st c="5441">In this code example, we take the same data array as before, iterate it using a </st><code><st c="5522">ForEach</st></code><st c="5529"> loop, and create a </st><code><st c="5549">BarMark</st></code><st c="5556"> view for each array item. </st><st c="5583">This example is crucial to understanding how charts are built so we can customize and configure</st><a id="_idIndexMarker489"/><st c="5678"> them in </st><st c="5687">the future.</st></p>
			<p><st c="5698">Now, let’s explore the </st><code><st c="5722">BarMark</st></code><st c="5729"> chart </st><st c="5736">even further.</st></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor295"/><st c="5749">Creating BarMark chart</st></h2>
			<p><st c="5772">We can use a </st><code><st c="5786">BarMark</st></code><st c="5793">-based chart</st><a id="_idIndexMarker490"/><st c="5806"> to compare different data points, such as sales figures and country population sizes. </st><st c="5893">We saw how simple creating a chart with multiple bar </st><st c="5946">marks is.</st></p>
			<p><st c="5955">However, implementing a chart with BarMark views doesn’t end here. </st><st c="6023">We have more options to expand that mark to provide even </st><st c="6080">more information.</st></p>
			<p><st c="6097">We’ll start with a stacked </st><st c="6125">bar chart.</st></p>
			<h3><st c="6135">Adding Stacked Marks</st></h3>
			<p><st c="6156">Standard marks represent two-dimensional data</st><a id="_idIndexMarker491"/><st c="6202"> points, comparing one value to another. </st><st c="6243">Sometimes, datasets may have a deeper story, as each bar may be constructed from </st><st c="6324">several values.</st></p>
			<p><st c="6339">For example, let’s take the sales chart we have just created and discuss the sales of apples. </st><st c="6434">The current value of apple sales is 50 items. </st><st c="6480">Perhaps we want to display how this value is divided between green and red apples. </st><st c="6563">In this case, we can use a </st><st c="6590">stacked mark.</st></p>
			<p><st c="6603">We will now add a stacked bar to our </st><st c="6641">existing chart.</st></p>
			<p><st c="6656">First, we need to adjust</st><a id="_idIndexMarker492"/><st c="6681"> our </st><code><st c="6686">Sales</st></code><st c="6691"> structure to contain our </st><st c="6717">fr</st><a id="_idTextAnchor296"/><a id="_idTextAnchor297"/><st c="6719">uit color:</st></p>
			<pre class="source-code"><st c="6730">
struct Sales: Identifiable {
    var id: UUID = UUID()
    let itemType: String
    let qty: Int
</st><strong class="bold"><st c="6816">    var fruitColor: String = ""</st></strong><st c="6843">
}</st></pre>			<p><st c="6845">Now that we have added a </st><code><st c="6870">fruitColor</st></code><st c="6880"> property to the </st><code><st c="6897">Sales</st></code><st c="6902"> structure, we can update </st><st c="6928">our dataset:</st></p>
			<pre class="source-code"><st c="6940">
let data: [Sales] = [
        Sales(itemType: "Apples", qty: 20, fruitColor:
          "Green"),
        Sales(itemType: "Apples", qty: 30, fruitColor:
          "Red"),
        Sales(itemType: "Oranges", qty: 60),
        Sales(itemType: "Watermelons", qty: 30)
]</st></pre>			<p><st c="7153">Currently, our updated dataset</st><a id="_idIndexMarker493"/><st c="7184"> has two records related to apple sales, each containing the </st><st c="7245">color sold.</st></p>
			<p><st c="7256">Now that we have all the data that we need, let’s create a chart and assign each of the properties to the right role in </st><st c="7377">the chart:</st></p>
			<pre class="source-code"><st c="7387">
Chart(data) {
            BarMark(x: .value("Fruit", $0.itemType),
                    y: .value("qty", $0.qty))
                </st><strong class="bold"><st c="7469">.foregroundStyle(by: .value("Color",</st></strong>
<strong class="bold"><st c="7505">                  $0.fruitColor))</st></strong><st c="7521">
        }</st></pre>			<p><st c="7523">In this code example, the only difference we have is the </st><code><st c="7580">foregroundStyle</st></code><st c="7595"> view modifier, which helps distinguish between the different fruit colors. </st><st c="7671">Let’s see the result in </st><em class="italic"><st c="7695">Figure 9</st></em><em class="italic"><st c="7703">.2</st></em><st c="7705">:</st></p>
			<div><div><img src="img/B21795_09_2.jpg" alt="Figure 9.2: Stacked bar view"/><st c="7707"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7712">Figure 9.2: Stacked bar view</st></p>
			<p><st c="7740">In </st><em class="italic"><st c="7744">Figure 9</st></em><em class="italic"><st c="7752">.2</st></em><st c="7754">, we can see that the apples bar is built from two types of values. </st><st c="7822">The blue represents green apples, and the green represents </st><st c="7881">red apples.</st></p>
			<p><st c="7892">We saw that when we add several marks</st><a id="_idIndexMarker494"/><st c="7930"> with the same </st><em class="italic"><st c="7945">x</st></em><st c="7946"> values, the Charts framework knows how to stack </st><st c="7995">them together.</st></p>
			<p><st c="8009">Next, let’s see what happens when we don’t add </st><em class="italic"><st c="8057">y</st></em><st c="8058"> values to our </st><st c="8073">data set.</st></p>
			<h3><st c="8082">Adding 1D bar marks</st></h3>
			<p><st c="8102">Most charts are two-dimensional, meaning</st><a id="_idIndexMarker495"/><st c="8143"> they have an </st><em class="italic"><st c="8157">x</st></em><st c="8158"> and </st><em class="italic"><st c="8163">y</st></em><st c="8164"> axis that</st><a id="_idIndexMarker496"/><st c="8174"> compares different data categories. </st><st c="8211">However, we can focus on one category (meaning the chart will have only one </st><em class="italic"><st c="8287">y</st></em><st c="8288"> axis value) and create a </st><st c="8314">one-dimensional chart.</st></p>
			<p><st c="8336">For instance, let’s take the apple category from the previous example and try to create a 1D bar based </st><st c="8440">on it.</st></p>
			<p><st c="8446">First, let’s enrich our data and add </st><code><st c="8484">Yellow</st></code><st c="8490"> as an additional </st><st c="8508">fruit color:</st></p>
			<pre class="source-code"><st c="8520">
    let data: [Sales] = [
        Sales(itemType: "Apples", qty: 20, fruitColor:
              "Green"),
        Sales(itemType: "Apples", qty: 30, fruitColor:
              "Red"),
        </st><strong class="bold"><st c="8655">Sales(itemType: "Apples", qty: 40, fruitColor:</st></strong>
<strong class="bold"><st c="8701">              "Yellow"),</st></strong><st c="8712">
    ]</st></pre>			<p><st c="8714">Our dataset now includes</st><a id="_idIndexMarker497"/><st c="8738"> the </st><code><st c="8743">Green</st></code><st c="8748">, </st><code><st c="8750">Red</st></code><st c="8753">, and </st><code><st c="8759">Yellow</st></code> <st c="8765">fruit</st><a id="_idIndexMarker498"/><st c="8771"> colors.</st></p>
			<p><st c="8779">Next, let’s create our chart, but this time, we won’t define </st><st c="8841">the </st><em class="italic"><st c="8845">y</st></em><st c="8846">-axis:</st></p>
			<pre class="source-code"><st c="8852">
Chart(data) {
                BarMark(
</st><strong class="bold"><st c="8876">                    x: .value("Qty", $0.qty)</st></strong><st c="8900">
                )
                .foregroundStyle(by: .value("Color",
                  $0.fruitColor))
            }</st></pre>			<p><st c="8957">In this code example, we passed only the </st><code><st c="8999">x</st></code> <code><st c="9000">BarMark</st></code><st c="9007"> parameter. </st><st c="9019">However, if we examine the </st><code><st c="9046">BarMark</st></code><st c="9053"> header, we can see that there’s a method that requires only the </st><code><st c="9118">x</st></code><st c="9119"> parameter:</st></p>
			<pre class="source-code"><st c="9130">
public init&lt;X&gt;(</st><code><st c="9316">init()</st></code><st c="9322"> function in this code example is the method that we are using. </st><st c="9386">Now, let’s see what the chart we create looks like when it’s only one-dimensional (</st><em class="italic"><st c="9469">Figure 9</st></em><em class="italic"><st c="9478">.3</st></em><st c="9480">):</st></p>
			<div><div><img src="img/B21795_09_3.jpg" alt="Figure 9.3: A 1D chart"/><st c="9483"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9510">Figure 9.3: A 1D chart</st></p>
			<p><st c="9532">In </st><em class="italic"><st c="9536">Figure 9</st></em><em class="italic"><st c="9544">.3</st></em><st c="9546">, our data is presented in a one-dimensional chart presenting three different types </st><st c="9630">of apples.</st></p>
			<p><st c="9640">One thing still bothers us here: notice</st><a id="_idIndexMarker499"/><st c="9680"> that the fruit colors don’t match</st><a id="_idIndexMarker500"/><st c="9714"> the actual colors the Charts framework assigned to each fruit when it created the chart. </st><st c="9804">That’s because the Charts framework generates the colors while encoding the value. </st><st c="9887">If we want to match the fruit color to the chart presented color, we need to use the </st><code><st c="9972">chartForegroundStyleScale</st></code> <st c="9997">view modifier:</st></p>
			<pre class="source-code"><st c="10012">
Chart(data) {
                BarMark(
                    x: .value("Qty", $0.qty)
                )
                .foregroundStyle(by: .value("Color",
                  $0.fruitColor))
            }
            </st><strong class="bold"><st c="10118">.chartForegroundStyleScale(["Green" :</st></strong>
<strong class="bold"><st c="10155">              Color.green, "Red" : Color.red,</st></strong>
<code><st c="10218">chartForegroundStyleScale</st></code><st c="10243"> function is a view modifier we can apply to the Chart and different </st><code><st c="10312">ShapeStyle</st></code><st c="10322"> protocol to different values. </st><st c="10353">In this case, we use colors that reflect the fruit colors and </st><st c="10415">improve clarity.</st></p>
			<p><em class="italic"><st c="10431">Figure 9</st></em><em class="italic"><st c="10440">.4</st></em><st c="10442"> shows how the chart looks now that we matched the colors to </st><st c="10503">the names:</st></p>
			<div><div><img src="img/B21795_09_4.jpg" alt="Figure 9.4: A 1D chart with custom colors"/><st c="10513"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10547">Figure 9.4: A 1D chart with custom colors</st></p>
			<p><st c="10588">We can use </st><code><st c="10600">chartForegroundStyleScale</st></code><st c="10625"> not only for 1D charts but also for all other types </st><st c="10678">of charts.</st></p>
			<p><st c="10688">We saw how</st><a id="_idIndexMarker501"/><st c="10699"> to use BarMarks</st><a id="_idIndexMarker502"/><st c="10715"> for stacked and one-dimensional marks. </st><st c="10755">Yet another way we can use BarMarks is for interval </st><st c="10807">bar charts.</st></p>
			<h3><st c="10818">Adding interval bar charts</st></h3>
			<p><st c="10845">We use </st><strong class="bold"><st c="10853">interval bar charts</st></strong><st c="10872"> to represent data grouped</st><a id="_idIndexMarker503"/><st c="10898"> into intervals, such </st><a id="_idIndexMarker504"/><st c="10920">as periods, age groups, o</st><a id="_idTextAnchor298"/><a id="_idTextAnchor299"/><st c="10945">r </st><st c="10948">numerical ranges.</st></p>
			<p><st c="10965">For example, let’s say we want to display a list of workers and the time intervals they worked throughout </st><st c="11072">the day.</st></p>
			<p><st c="11080">First, let’s create a data set that represents a list of </st><st c="11138">working periods:</st></p>
			<pre class="source-code"><st c="11154">
let emma = "Emma Johnson"
let liam = "Liam Patel"
let sophia = "Sophia Garcia"
let data: [EmployeDayWork] = [
        EmployeDayWork(name:emma, startTime: 10, endTime:
          12),
        EmployeDayWork(name:liam, startTime: 8, endTime:
          11),
        EmployeDayWork(name: sophia, startTime: 10.5,
          endTime: 11.5),
        EmployeDayWork(name: emma, startTime: 14, endTime:
          15),
        EmployeDayWork(name: liam, startTime: 13.5,
          endTime: 14.2),
        EmployeDayWork(name: sophia, startTime: 15,
          endTime: 16)
]</st></pre>			<p><st c="11610">Each item in the </st><code><st c="11628">data</st></code><st c="11632"> array represents one employee’s working period. </st><st c="11681">Notice that we don’t care about the item’s order—the Charts framework is responsible for ordering them correctly. </st><st c="11795">However, we care about consistency with the employee’s name, so the Charts framework can also properly group </st><st c="11904">the items.</st></p>
			<p><st c="11914">Let’s see how we can build</st><a id="_idIndexMarker505"/><st c="11941"> an interval chart based</st><a id="_idIndexMarker506"/><st c="11965"> on </st><st c="11969">that dataset:</st></p>
			<pre class="source-code"><st c="11982">
Chart(data) {
                BarMark(
                    </st><strong class="bold"><st c="12006">xStart</st></strong><st c="12012">: .value("Start", $0.startTime),
                    </st><strong class="bold"><st c="12046">xEnd</st></strong><st c="12050">: .value("End", $0.endTime),
                    </st><strong class="bold"><st c="12080">y</st></strong><st c="12081">: .value("Employee", $0.name)
                )
            }</st></pre>			<p><st c="12114">In this code example, we create a BarMark initializer that includes new parameters—</st><code><st c="12198">xStart</st></code><st c="12205">, which represents the value where the interval begins, </st><code><st c="12261">xEnd</st></code><st c="12265">, detailing where it ends, and </st><code><st c="12296">y</st></code><st c="12297">, the </st><st c="12303">employee’s name.</st></p>
			<p><st c="12319">Now, let’s see how an interval chart looks when we run it (</st><em class="italic"><st c="12379">Figure 9</st></em><em class="italic"><st c="12388">.5</st></em><st c="12390">):</st></p>
			<div><div><img src="img/B21795_09_5.jpg" alt="Figure 9.5: An interval chart"/><st c="12393"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12444">Figure 9.5: An interval chart</st></p>
			<p><st c="12473">In </st><em class="italic"><st c="12477">Figure 9</st></em><em class="italic"><st c="12485">.5</st></em><st c="12487">, we can see a timeline when each of the employees is represented in a row, and their working periods are interva</st><a id="_idTextAnchor300"/><a id="_idTextAnchor301"/><st c="12600">ls in this timeline. </st><st c="12622">The interval bar chart is an excellent example of a component that can be complex to build from the ground up, and the Charts framework can simplify </st><st c="12771">the process.</st></p>
			<p><st c="12783">BarMark seems like a very flexible chart type, and that’s part of the reason it is so common. </st><st c="12878">It allows us to present different information types, whether comparing values or different trends over time, in stacked, one-dimensional, or </st><st c="13019">interval layouts.</st></p>
			<p><st c="13036">However, sometimes, it’s a better choice</st><a id="_idIndexMarker507"/><st c="13077"> to pick a more specific chart</st><a id="_idIndexMarker508"/><st c="13107"> that expresses data </st><st c="13128">more precisely.</st></p>
			<p><st c="13143">So, let’s me</st><a id="_idTextAnchor302"/><a id="_idTextAnchor303"/><st c="13156">et the </st><st c="13164">LineMark chart.</st></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor304"/><st c="13179">Creating LineMark charts</st></h2>
			<p><st c="13204">One of the challenges of presenting data</st><a id="_idIndexMarker509"/><st c="13245"> in a table is showing trends and patterns. </st><st c="13289">Even though the BarMark chart type can do that better than a table, there are better ways to show trends, especially when dealing with a large amount </st><st c="13439">of information.</st></p>
			<p><st c="13454">To show trends and patterns more efficiently, we can use the LineMark chart, which represents data using a line representing a list of </st><st c="13590">data points.</st></p>
			<p><st c="13602">Let’s take, for example, a chart that shows phone sales over time. </st><st c="13670">We create a structure named </st><code><st c="13698">SalesFigure</st></code><st c="13709"> that contains information about the product type, the day of the sales, and the </st><st c="13790">total amount:</st></p>
			<pre class="source-code"><st c="13803">
struct SalesFigure: Identifiable {
    var id: UUID = UUID()
    let product: String
    let day: Date
    let amount: Double
}</st></pre>			<p><st c="13915">Now that we have a structure, let’s create</st><a id="_idIndexMarker510"/><st c="13958"> our dataset like we did in all </st><st c="13990">previous examples:</st></p>
			<pre class="source-code"><st c="14008">
let phoneProduct = "Phone"
let salesFigures: [SalesFigure] = [
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714078800), amount:
            100),
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714165200), amount:
            120),
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714251600), amount:
            90),
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714338000), amount:
            70)
    ]</st></pre>			<p><st c="14450">The </st><code><st c="14455">salesFigures</st></code><st c="14467"> variable contains information</st><a id="_idIndexMarker511"/><st c="14497"> about four days of sales. </st><st c="14524">The LineMark chart is suitable for working with many entries, but we use only four for </st><st c="14611">demonstration purposes.</st></p>
			<p><st c="14634">Now, let’s connect the </st><code><st c="14658">salesFigures</st></code><st c="14670"> variable to a chart using the </st><code><st c="14701">LinkMark</st></code><st c="14709"> view:</st></p>
			<pre class="source-code"><st c="14715">
Chart(salesFigures) {
                </st><strong class="bold"><st c="14738">LineMark(</st></strong>
<strong class="bold"><st c="14747">                    x: .value("time", $0.day),</st></strong>
<strong class="bold"><st c="14774">                    y: .value("amount", $0.amount)</st></strong>
<strong class="bold"><st c="14805">                )</st></strong><st c="14807">
            }</st></pre>			<p><st c="14809">We created a LineMark inside the chart, setting the day as the </st><em class="italic"><st c="14872">x</st></em><st c="14873"> axis and the amount as the </st><em class="italic"><st c="14901">y</st></em><st c="14902"> axis. </st><st c="14909">Running that code should show us a chart that looks like </st><em class="italic"><st c="14966">Figure 9</st></em><em class="italic"><st c="14974">.6</st></em><st c="14976">:</st></p>
			<div><div><img src="img/B21795_09_6.jpg" alt="Figure 9.6: A LineMark chart"/><st c="14978"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15010">Figure 9.6: A LineMark chart</st></p>
			<p><st c="15038">The chart in </st><em class="italic"><st c="15052">Figure 9</st></em><em class="italic"><st c="15060">.6</st></em><st c="15062"> shows the declining trend of phone sales over the dataset period. </st><st c="15129">What’s nice about line charts is that it’s easy to compare one LineMark to another. </st><st c="15213">All we need to do is to update our dataset. </st><st c="15257">So, let’s also add tablet sales to compare it with </st><st c="15308">phone sales:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="15320">let tabletProduct = "Tablet"</st></strong><st c="15349">
let salesFigures: [SalesFigure] = [
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714078800), amount:
            100),
</st><strong class="bold"><st c="15481">        SalesFigure(product: tabletProduct, day:</st></strong>
<strong class="bold"><st c="15521">          Date(timeIntervalSince1970: 1714078800), amount:</st></strong>
<strong class="bold"><st c="15570">            70),</st></strong><st c="15575">
// …
        SalesFigure(product: phoneProduct, day:
          Date(timeIntervalSince1970: 1714338000), amount:
            70),
</st><strong class="bold"><st c="15675">        SalesFigure(product: tabletProduct, day:</st></strong>
<strong class="bold"><st c="15715">          Date(timeIntervalSince1970: 1714338000), amount:</st></strong>
<strong class="bold"><st c="15764">            110)</st></strong><st c="15769">
 ]</st></pre>			<p><st c="15771">In this code example, we updated </st><a id="_idIndexMarker512"/><st c="15804">our dataset by adding tablet sales figures items to </st><st c="15856">the array.</st></p>
			<p><st c="15866">To make the chart distinct between the two product types, we use the </st><code><st c="15936">foregroundStyle</st></code> <st c="15951">view modifier:</st></p>
			<pre class="source-code"><st c="15966">
LineMark(
     x: .value("time", $0.day),
     y: .value("amount", $0.amount)
     )</st><code><st c="16099">foregroundStyle</st></code><st c="16114"> view modifier applies different styles to different product types. </st><st c="16182">Looking at the code, we can see that the chart can distinguish between these </st><st c="16259">two types.</st></p>
			<p><st c="16269">Let’s see what the chart looks like after we have added the tablet sales figures (</st><em class="italic"><st c="16352">Figure 9</st></em><em class="italic"><st c="16361">.7</st></em><st c="16363">):</st></p>
			<div><div><img src="img/B21795_09_7.jpg" alt="Figure 9.7: LineMark chart with two types of product sales figures"/><st c="16366"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="16416">Figure 9.7: LineMark chart with two types of product sales figures</st></p>
			<p><em class="italic"><st c="16482">Figure 9</st></em><em class="italic"><st c="16491">.7</st></em><st c="16493"> shows tablet sales compared to phone sales. </st><st c="16538">We can see that while the phone sales declined, the tablet sales increased. </st><st c="16614">That’s an insight that is difficult to get just from </st><st c="16667">the dataset.</st></p>
			<p><st c="16679">Thus far, we have created two primary</st><a id="_idIndexMarker513"/><st c="16717"> types of charts: bar and line charts. </st><st c="16756">These two types are pretty popular, as they are simple to understand and work for many </st><st c="16843">use cases.</st></p>
			<p><st c="16853">Another popular chart type Apple added in iOS 17 is </st><strong class="bold"><st c="16906">SectorMark</st></strong><st c="16916">, also known as a </st><st c="16934">pie chart.</st></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor305"/><st c="16944">Creating a SectorMark chart</st></h2>
			<p><st c="16972">A SectorMark, or pie, chart</st><a id="_idIndexMarker514"/><st c="17000"> provides a way to visualize the proportions of different values. </st><st c="17066">Unlike the other charts, the pie chart is based on a circular shape divided into slices, and each slide represents a different </st><st c="17193">item value.</st></p>
			<p><st c="17204">Apparently, the SectorMark chart looks like another form of Stacked Marks we covered earlier (under </st><em class="italic"><st c="17305">Adding </st></em><em class="italic"><st c="17312">Stacked Marks</st></em><st c="17325">).</st></p>
			<p><st c="17328">However, SectorMark charts became more popular than Stacked Marks as they are visually appealing and easier to understand. </st><st c="17452">Moreover, StackedMark and SectorMark charts are excellent for comparing different parts and seeing their contribution to the whole. </st><st c="17584">However, stacked marks are practical when we want to compare one whole to another, and SectorMark charts are helpful when we want to focus on </st><st c="17726">one whole.</st></p>
			<p><st c="17736">Like the previous examples, to create a SectorMark chart, we need to prepare a dataset. </st><st c="17825">So, let’s create a dataset representing a poll result about </st><st c="17885">consuming fruits:</st></p>
			<pre class="source-code"><st c="17902">
let data: [FavoriteFruit] = [
        FavoriteFruit(name: "Apple", value: 30),
        FavoriteFruit(name: "Banana", value: 25),
        FavoriteFruit(name: "Orange", value: 20),
        FavoriteFruit(name: "Strawberries", value: 15),
        FavoriteFruit(name: "Grapes", value: 10)
    ]</st></pre>			<p><st c="18148">In this example, we created a structure named </st><code><st c="18195">FavoriteFruit</st></code><st c="18208">, which contains the name of the fruit and the number of people who chose </st><st c="18282">that fruit.</st></p>
			<p><st c="18293">To use the data dataset, we will add a </st><code><st c="18333">SectorMark</st></code><st c="18343"> view to </st><st c="18352">our chart:</st></p>
			<pre class="source-code"><st c="18362">
        Chart(data) {item in
           </st><strong class="bold"><st c="18384">SectorMark(angle: .value("Value", item.value))</st></strong><st c="18430">
                    .foregroundStyle(by: .value("Fruit",
                    item.name))
        }</st></pre>			<p><st c="18480">The </st><code><st c="18485">SectorMark</st></code><st c="18495"> structure has an angle parameter that reflects the numeric value of the slice. </st><st c="18575">We also added the </st><code><st c="18593">foregroundStyle</st></code><st c="18608"> view modifier, which colors the slice according to the item’s </st><st c="18671">fruit property.</st></p>
			<p><st c="18686">Let’s look at what the SectorMark chart looks like when running our code (</st><em class="italic"><st c="18761">Figure 9</st></em><em class="italic"><st c="18770">.8</st></em><st c="18772">):</st></p>
			<div><div><img src="img/B21795_09_8.jpg" alt="Figure 9.8: SectorMark chart"/><st c="18775"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18777">Figure 9.8: SectorMark chart</st></p>
			<p><em class="italic"><st c="18805">Figure 9</st></em><em class="italic"><st c="18814">.8</st></em><st c="18816"> shows a beautiful, colorful pie</st><a id="_idIndexMarker515"/><st c="18848"> chart, including the legend titles. </st><st c="18885">We can even set an inner radius to add a </st><strong class="bold"><st c="18926">donut style</st></strong><st c="18937"> to </st><st c="18941">the chart:</st></p>
			<pre class="source-code"><st c="18951">
Chart(data) {item in
    SectorMark(angle: .value("Value", item.value),
      </st><strong class="bold"><st c="19020">innerRadius: 50</st></strong><st c="19035">)
      .foregroundStyle(by: .value("Fruit", item.name))
 }</st></pre>			<p><st c="19088">The addition of the inner radius creates a </st><strong class="bold"><st c="19132">hole</st></strong><st c="19136"> in the pie chart, as we can see in </st><em class="italic"><st c="19172">Figure 9</st></em><em class="italic"><st c="19180">.9</st></em><st c="19182">:</st></p>
			<div><div><img src="img/B21795_09_9.jpg" alt="Figure 9.9: A SectorMark chart with an inner radius"/><st c="19184"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19185">Figure 9.9: A SectorMark chart with an inner radius</st></p>
			<p><em class="italic"><st c="19236">Figure 9</st></em><em class="italic"><st c="19245">.9</st></em><st c="19247"> shows a donut-shaped SectorMark chart. </st><st c="19287">This shape allows us to provide more information in the center of the chart. </st><st c="19364">Some even say that this form is more readable to users as it eliminates the need to </st><st c="19448">compare angles.</st></p>
			<p><st c="19463">Until now, we have</st><a id="_idIndexMarker516"/><st c="19482"> created </st><code><st c="19491">BarMark</st></code><st c="19498">, </st><code><st c="19500">LineMark</st></code><st c="19508">, and </st><code><st c="19514">SectorMark</st></code><st c="19524"> charts. </st><st c="19533">The following chart combines two charts we discussed – the LineMark and stacked BarMark charts. </st><st c="19629">That’s the </st><code><st c="19640">AreaMark</st></code><st c="19648"> chart.</st></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor306"/><st c="19655">Creating an AreaMark chart</st></h2>
			<p><st c="19682">The stacked BarMark chart</st><a id="_idIndexMarker517"/><st c="19708"> we discussed under the </st><em class="italic"><st c="19732">Adding Stacked Marks</st></em><st c="19752"> section shows two important figures – the total value of a category and how that total is divided into sub-categories while observing the different proportions. </st><st c="19914">The LineMark chart, on the other hand, shows the trend or patterns between different </st><st c="19999">data points.</st></p>
			<p><st c="20011">However, what if we want to combine these two types of marks, showing how a value is composed of different categories </st><st c="20130">over time?</st></p>
			<p><st c="20140">That’s what the AreaMark chart </st><st c="20172">is for.</st></p>
			<p><st c="20179">Let’s take our LineMark sales figures example. </st><st c="20227">We have a dataset representing phone and tablet sales over time. </st><st c="20292">Now, we want to see the total sales of these two types of products over time while still observing the different trends of </st><st c="20415">each product.</st></p>
			<p><st c="20428">So, we can create an </st><code><st c="20450">AreaMark</st></code><st c="20458"> chart based on the </st><st c="20478">same dataset:</st></p>
			<pre class="source-code"><st c="20491">
Chart(salesFigures) { data in
            </st><strong class="bold"><st c="20522">AreaMark</st></strong><st c="20530">(
                x: .value("Date", data.day),
                y: .value("Sales", data.amount)
            )
            .foregroundStyle(by: .value("Product",
              data.product))
        }</st></pre>			<p><st c="20651">Our code example is identical</st><a id="_idIndexMarker518"/><st c="20681"> to the LineMark example we discussed under the </st><em class="italic"><st c="20729">Creating LineMark charts</st></em><st c="20753"> section; the only difference is that we are now using AreaMark instead </st><st c="20825">of LineMark.</st></p>
			<p><st c="20837">However, the result is different (</st><em class="italic"><st c="20872">Figure 9</st></em><em class="italic"><st c="20881">.10</st></em><st c="20884">):</st></p>
			<div><div><img src="img/B21795_09_10.jpg" alt="Figure 9.10: An AreaMark chart for total sales"/><st c="20887"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20889">Figure 9.10: An AreaMark chart for total sales</st></p>
			<p><st c="20935">At first glance, </st><em class="italic"><st c="20953">Figure 9</st></em><em class="italic"><st c="20961">.10</st></em><st c="20964"> shows similar information as </st><em class="italic"><st c="20994">Figure 9</st></em><em class="italic"><st c="21002">.7</st></em><st c="21004">—trends of product sales figures. </st><st c="21039">However, there are differences. </st><st c="21071">The filled area in </st><em class="italic"><st c="21090">Figure 9</st></em><em class="italic"><st c="21098">.10</st></em><st c="21101"> represents the </st><strong class="bold"><st c="21117">total sales</st></strong><st c="21128"> of products for both phones and tablets, and each color represents a different product type. </st><st c="21222">On the other hand, </st><em class="italic"><st c="21241">Figure 9</st></em><em class="italic"><st c="21249">.7</st></em><st c="21251"> only shows a comparison between these two product types, side </st><st c="21314">by side.</st></p>
			<p><st c="21322">The AreaMark chart</st><a id="_idIndexMarker519"/><st c="21341"> is great for market share analysis, financial data visualization, and general information, including data trends and </st><st c="21459">cumulative totals.</st></p>
			<p><st c="21477">However, charts can give us much more than data comparison and trends. </st><st c="21549">Let’s meet our final chart, PointMark, which can provide a different level </st><st c="21624">of insight.</st></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor307"/><st c="21635">Creating a PointMark chart</st></h2>
			<p><st c="21662">Until now, we have discussed</st><a id="_idIndexMarker520"/><st c="21691"> marks that have helped us compare sales figures or observe trends. </st><st c="21759">What about areas such as correlation analysis or predictive modeling? </st><st c="21829">To fulfill that need, the PointMark chart, also known as the </st><strong class="bold"><st c="21890">scatterplot chart</st></strong><st c="21907">, aims to show the relatio</st><a id="_idTextAnchor308"/><a id="_idTextAnchor309"/><st c="21933">nships</st><a id="_idIndexMarker521"/><st c="21940"> between </st><st c="21949">two variables.</st></p>
			<p><st c="21963">Let’s find the correlation</st><a id="_idIndexMarker522"/><st c="21990"> between students’ study hours and grades. </st><st c="22033">First, we create a dataset representing </st><st c="22073">the data:</st></p>
			<pre class="source-code"><st c="22082">
struct StudentData: Identifiable {
    var id: UUID = UUID()
    var hoursStudied: Double
    var examScore: Double
}
let studentDataSet: [StudentData] = [
    StudentData(hoursStudied: 1.7, examScore: 61.8),
    StudentData(hoursStudied: 7.9, examScore: 78.6),
    StudentData(hoursStudied: 4.1, examScore: 44.3),
    StudentData(hoursStudied: 4.7, examScore: 63.4),
    StudentData(hoursStudied: 7.8, examScore: 90.4),
    StudentData(hoursStudied: 8.6, examScore: 83.2),
    StudentData(hoursStudied: 2.8, examScore: 29.7),
    StudentData(hoursStudied: 6.3, examScore: 72.9),
    StudentData(hoursStudied: 6.4, examScore: 73.8),
    StudentData(hoursStudied: 6.1, examScore: 77.6)
]</st></pre>			<p><st c="22717">This code example has a </st><code><st c="22742">StudentData</st></code><st c="22753"> structure containing information about student study time and grades. </st><code><st c="22824">studentsDataSet</st></code><st c="22839"> is an array that contains information about </st><st c="22884">ten students.</st></p>
			<p><st c="22897">Now, let’s create a </st><code><st c="22918">PointMark</st></code><st c="22927"> chart based on </st><st c="22943">that array:</st></p>
			<pre class="source-code"><st c="22954">
Chart(studentDataSet) {
            </st><strong class="bold"><st c="22979">PointMark(x: .value("hours", $0.hoursStudied),</st></strong>
<strong class="bold"><st c="23025">                      y: .value("score", $0.examScore))</st></strong><st c="23059">
        }</st></pre>			<p><st c="23061">Like previous charts, the </st><code><st c="23087">PointMark</st></code><st c="23096"> structure</st><a id="_idIndexMarker523"/><st c="23106"> has </st><code><st c="23111">x</st></code><st c="23112"> and </st><code><st c="23117">y</st></code><st c="23118"> parameters. </st><st c="23131">The </st><code><st c="23135">x</st></code><st c="23136"> parameter represents the hours studied, and the </st><code><st c="23185">y</st></code><st c="23186"> parameter represents </st><st c="23208">the score.</st></p>
			<p><em class="italic"><st c="23218">Figure 9</st></em><em class="italic"><st c="23227">.11</st></em><st c="23230"> shows what the </st><code><st c="23246">PointMark</st></code><st c="23255"> chart looks like when running </st><st c="23286">the code:</st></p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21795_09_11.jpg" alt="Figure 9.11: PointMark chart"/><st c="23295"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23300">Figure 9.11: PointMark chart</st></p>
			<p><em class="italic"><st c="23328">Figure 9</st></em><em class="italic"><st c="23337">.11</st></em><st c="23340"> shows that most students achieve high grades when studying more hours. </st><st c="23412">We can also identify one student who managed to achieve a mid-level grade almost without studying </st><st c="23510">at all!</st></p>
			<p><st c="23517">Even though PointMark is less common than the previous charts we reviewed, it can be helpful in financial, CRM, or </st><st c="23633">education apps.</st></p>
			<p><st c="23648">Speaking of education apps, many apps require other types of charts. </st><st c="23718">That includes charts that are based on functions</st><a id="_idIndexMarker524"/><st c="23766"> and not datasets. </st><st c="23785">With Charts, we can also work more dynamically and straightforwardly visualize functions. </st><st c="23875">Let’s see how to </st><st c="23892">do that.</st></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor310"/><st c="23900">Visualizing functions with Charts</st></h1>
			<p><st c="23934">Until now, we have discussed</st><a id="_idIndexMarker525"/><st c="23963"> how to build charts using datasets, which include raw data</st><a id="_idIndexMarker526"/><st c="24022"> information such as sales figures, market shares, or usage trends. </st><st c="24090">However, we don’t have to use datasets to create charts, as functions can also perform as a data source for </st><st c="24198">our charts.</st></p>
			<p><st c="24209">For example, we may want to display a normal distribution line graph next to our BarMark chart. </st><st c="24306">We could also create an education app that displays mathematical functions such as circles or a </st><st c="24402">sinus function.</st></p>
			<p><st c="24417">To do that, we need to use a different</st><a id="_idIndexMarker527"/><st c="24456"> type of chart </st><st c="24471">called </st><strong class="bold"><st c="24478">plot</st></strong><st c="24482">.</st></p>
			<p><st c="24483">The Charts framework has two types of plots – </st><code><st c="24530">LinePlot</st></code><st c="24538"> and </st><code><st c="24543">AreaPlot</st></code><st c="24551">. Let’s see an example of </st><code><st c="24577">LinePlot</st></code><st c="24585"> sh</st><a id="_idTextAnchor311"/><a id="_idTextAnchor312"/><st c="24588">owing a graph for a </st><st c="24609">sinus function:</st></p>
			<pre class="source-code"><st c="24624">
Chart {
     </st><strong class="bold"><st c="24633">LinePlot</st></strong><st c="24641">(x:"x", y:"y") { x in
         return sin(x)
     }
}</st></pre>			<p><st c="24681">In this (very!) short code example, we added a </st><code><st c="24729">LinePlot</st></code><st c="24737"> chart with a closure that returns the </st><code><st c="24776">y</st></code><st c="24777"> value of a given </st><code><st c="24795">x</st></code><st c="24796"> value. </st><st c="24804">In this case, we used a simple </st><code><st c="24835">sin</st></code><st c="24838"> function. </st><em class="italic"><st c="24849">Figure 9</st></em><em class="italic"><st c="24857">.12</st></em><st c="24860"> shows what the chart </st><st c="24882">looks like:</st></p>
			<div><div><img src="img/B21795_09_12.jpg" alt="Figure 9.12: A LinePlot chart"/><st c="24893"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24895">Figure 9.12: A LinePlot chart</st></p>
			<p><st c="24924">In </st><em class="italic"><st c="24928">Figure 9</st></em><em class="italic"><st c="24936">.12</st></em><st c="24939">, we can see the </st><code><st c="24956">LinePlot</st></code><st c="24964"> chart generated from a simple </st><st c="24995">mathematical function.</st></p>
			<p><st c="25017">As mentioned earlier</st><a id="_idIndexMarker528"/><st c="25038"> in this section, the second chart type we can use to visualize</st><a id="_idIndexMarker529"/><st c="25101"> functions is </st><code><st c="25115">AreaPlot</st></code><st c="25123">, the equivalent </st><st c="25140">of </st><code><st c="25143">AreaMark</st></code><st c="25151">:</st></p>
			<pre class="source-code"><st c="25153">
Chart {
     </st><strong class="bold"><st c="25162">AreaPlot</st></strong><st c="25170">(x:"x", y:"y") { </st><a id="_idTextAnchor313"/><a id="_idTextAnchor314"/><st c="25188">x in
         return sin(x)
     }
}</st></pre>			<p><st c="25210">In this code example, we only changed the chart type from </st><code><st c="25269">LinePlot</st></code><st c="25277"> to </st><code><st c="25281">AreaPlot</st></code><st c="25289">. </st><code><st c="25291">AreaPlot</st></code><st c="25299"> visualizes the function by filling the area it defines. </st><st c="25356">Let’s see the output in </st><em class="italic"><st c="25380">Figure 9</st></em><em class="italic"><st c="25388">.13</st></em><st c="25391">:</st></p>
			<div><div><img src="img/B21795_09_13.jpg" alt="Figure 9.13: The AreaPlot chart type"/><st c="25393"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25394">Figure 9.13: The AreaPlot chart type</st></p>
			<p><em class="italic"><st c="25430">Figure 9</st></em><em class="italic"><st c="25439">.13</st></em><st c="25442"> shows the same sinus function graph, now filled </st><st c="25491">with color.</st></p>
			<p><st c="25502">Using the LinePlot and AreaPlot chart types to visualize math functions is about much more than just showing how the sinus function behaves. </st><st c="25644">It is excellent for education, scientific research, finance, health, and business apps. </st><st c="25732">Now that we know how to create LinePlot and AreaPlot, we have whole </st><st c="25800">new options.</st></p>
			<p><st c="25812">We went over many chart</st><a id="_idIndexMarker530"/><st c="25836"> types, and by now, we can quickly</st><a id="_idIndexMarker531"/><st c="25870"> create charts, just like creating a </st><st c="25907">simple list!</st></p>
			<p><st c="25919">The </st><strong class="bold"><st c="25924">List</st></strong><st c="25928"> type provides a way to interact</st><a id="_idIndexMarker532"/><st c="25960"> with its items, allowing us to navigate or delve into more information. </st><st c="26033">So, let’s see how to make our </st><st c="26063">charts interactive!</st></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor315"/><st c="26082">Allowing interaction using ChartProxy</st></h1>
			<p><st c="26120">Now that we know how to create</st><a id="_idIndexMarker533"/><st c="26151"> charts, let’s discover more hidden tricks by adding user interaction capabilities. </st><st c="26235">User interaction in charts, with its many uses, allows users to explore the chart’s data using touch. </st><st c="26337">Here are some use cases for user interaction </st><st c="26382">with charts:</st></p>
			<ul>
				<li><code><st c="26446">BarMark</st></code><st c="26453"> or </st><code><st c="26457">SectorMark</st></code><st c="26467"> charts, the user can navigate to a new screen that shows additional information about the particular data point. </st><st c="26581">For example, if the </st><code><st c="26601">BarMark</st></code><st c="26608"> chart shows information about watermelon sales, we can navigate the user to a screen that details the watermelon </st><st c="26722">sales deals.</st></li>
				<li><code><st c="26794">LineMark</st></code><st c="26802"> charts, for example, provides insights to the user on data points not originally part of the dataset if our </st><code><st c="26911">LinkMark</st></code><st c="26919"> chart includes information about the growing population in a specific city over time, touching a particular point the chart can display the population value on a </st><st c="27082">specific date.</st></li>
				<li><strong class="bold"><st c="27096">Comparing data marks</st></strong><st c="27117">: The user can highlight and compare multiple data marks, which is extremely useful in </st><st c="27205">BarMark-based charts.</st></li>
			</ul>
			<p><st c="27226">Moreover, learning how to add interaction capabilities can help us explore more things with our charts, such as how the charts are built and how their calculation </st><st c="27390">logic works.</st></p>
			<p><st c="27402">To understand how interaction works, we need to get to know more Swift Charts </st><st c="27481">framework components:</st></p>
			<ul>
				<li><code><st c="27502">chartOverlay</st></code><st c="27515">: This is a view modifier that helps us add an overlay view to a chart. </st><st c="27588">We can use the </st><code><st c="27603">chartOverlay</st></code><st c="27615"> view modifier to add more graphic details to our chart, such as rulers and texts. </st><st c="27698">We can also use the </st><code><st c="27718">chartOverlay</st></code><st c="27730"> view modifier to observe gestures and </st><st c="27769">user interaction.</st></li>
				<li><code><st c="27786">ChartProxy</st></code><st c="27797">: This is a proxy that lets us access the chart values based on the chart area. </st><st c="27878">Using </st><code><st c="27884">ChartProxy</st></code><st c="27894">, we can convert locations to values and </st><st c="27935">vice versa.</st></li>
			</ul>
			<p><code><st c="27946">ChartOverlay</st></code><st c="27959"> and </st><code><st c="27964">ChartProxy</st></code><st c="27974"> are essential components when handling user interaction; therefore, they come hand in hand. </st><st c="28067">When adding a </st><code><st c="28081">chartOverlay</st></code><st c="28093"> view modifier, it comes with a prox</st><a id="_idTextAnchor316"/><a id="_idTextAnchor317"/><a id="_idTextAnchor318"/><st c="28129">y</st><a id="_idIndexMarker534"/><st c="28131"> to have complete access to </st><st c="28159">the chart.</st></p>
			<p><st c="28169">Let’s try to take a LineMark chart and add a horizontal ruler that allows users to drag their fingers across it. </st><st c="28283">We’ll start by adding </st><st c="28305">an overlay.</st></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor319"/><st c="28316">Adding an overlay to our chart</st></h2>
			<p><st c="28347">The solution for providing</st><a id="_idIndexMarker535"/><st c="28374"> an overlay to our chart consists</st><a id="_idIndexMarker536"/><st c="28407"> of a common practice in SwiftUI using a view modifier. </st><st c="28463">Look at the following </st><st c="28485">code example:</st></p>
			<pre class="source-code"><st c="28498">
Chart(salesFigures){
            LineMark(
                x: .value("time", $0.day),
                y: .value("amount", $0.amount)
            )
            .foregroundStyle(by: .value("Product",
              $0.product))
        }
</st><strong class="bold"><st c="28644">        .chartOverlay { proxy in</st></strong>
<code><st c="28753">chartOverlay</st></code><st c="28765"> view modifier in this </st><st c="28788">code example.</st></p>
			<p><st c="28801">We can see that </st><code><st c="28818">chartOverlay</st></code><st c="28830"> comes with a </st><code><st c="28844">proxy</st></code><st c="28849"> variable, which is the </st><code><st c="28873">ChartProxy</st></code><st c="28883"> component we </st><st c="28897">discussed earlier.</st></p>
			<p><code><st c="28915">ChartOverlay</st></code><st c="28928"> is not a view but a view modifier that lets us add new views to the chart. </st><st c="29004">So, to recognize gestures and add a ruler, we can add a transparent view with a drag gesture and add a </st><st c="29107">ruler view:</st></p>
			<pre class="source-code"><st c="29118">
        .chartOverlay { proxy in
            ZStack(alignment: .topLeading) {
                    Rectangle().fill(.clear)
                        .contentShape(Rectangle())
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                            }
                        )
                    let lineHeight = proxy.plotSize.height
                    Rectangle()
                        .fill(.red)
                        .frame(width: 2, height:
                          lineHeight)
                        .position(x: markerX, y:
                          lineHeight/2)
            }
        }</st></pre>			<p><st c="29420">In this code example, we added a </st><code><st c="29454">ZStack</st></code><st c="29460"> view with a clear rectangle that covers the whole chart and, on top of it, a red ruler view. </st><st c="29554">The ruler view </st><em class="italic"><st c="29569">x</st></em><st c="29570"> axis is a </st><st c="29581">state variable:</st></p>
			<pre class="source-code"><st c="29596">
@State var markerX: CGFloat = 50</st></pre>			<p><st c="29629">We are going to change it according to the user’s </st><st c="29680">tap locations.</st></p>
			<p><st c="29694">Notice that we used our </st><code><st c="29719">proxy</st></code><st c="29724"> object to determine</st><a id="_idIndexMarker537"/><st c="29744"> the chart size for the ruler view. </st><st c="29780">This is crucial proxy</st><a id="_idIndexMarker538"/><st c="29801"> usage, as we will need it on other occasions, such as calculations for displaying different views in </st><st c="29903">particular locations.</st></p>
			<p><st c="29924">To see our view structure, look at </st><em class="italic"><st c="29960">Figure 9</st></em><em class="italic"><st c="29968">.14</st></em><st c="29971">:</st></p>
			<div><div><img src="img/B21795_09_14.jpg" alt="Figure 9.14: Chart and chartOverlay structures"/><st c="29973"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29988">Figure 9.14: Chart and chartOverlay structures</st></p>
			<p><em class="italic"><st c="30034">Figure 9</st></em><em class="italic"><st c="30043">.14</st></em><st c="30046"> shows our chart view and the rectangle we added using the </st><code><st c="30105">chartOverlay</st></code><st c="30117"> view modifier. </st><st c="30133">We can also see that they are connected using the </st><st c="30183">proxy object.</st></p>
			<p><st c="30196">Also, we added</st><a id="_idIndexMarker539"/><st c="30211"> a drag gesture</st><a id="_idIndexMarker540"/><st c="30226"> to the rectangle. </st><st c="30245">Let’s see how to use it to change our ruler </st><st c="30289">position accordingly.</st></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor320"/><st c="30310">Responding to the user’s gesture</st></h2>
			<p><st c="30343">To respond to the user’s gesture</st><a id="_idIndexMarker541"/><st c="30376"> and move the horizontal ruler to the closest data point, we need to implement the </st><code><st c="30459">onChanged</st></code><st c="30468"> closure:</st></p>
			<pre class="source-code"><st c="30477">
.onChanged { value in
</st><strong class="bold"><st c="30499">   mark</st><a id="_idTextAnchor321"/><a id="_idTextAnchor322"/><st c="30503">erX = value.location.x</st></strong>
<strong class="bold"><st c="30526">   if let closestDate = getClosestDateForLocation(x:</st></strong>
<strong class="bold"><st c="30576">     value.location.x, proxy: proxy) {</st></strong>
<strong class="bold"><st c="30610">        if let positionX = proxy.position(forX:</st></strong>
<strong class="bold"><st c="30650">          closestDate) {</st></strong>
<strong class="bold"><st c="30665">            markerX = positionX</st></strong><st c="30685">
     }
}</st></pre>			<p><st c="30689">The </st><code><st c="30694">onChanged</st></code><st c="30703"> closure implementation does </st><st c="30732">three things:</st></p>
			<ul>
				<li><st c="30745">First, it </st><em class="italic"><st c="30756">finds the closest sales data point</st></em><st c="30790"> according to the tap location and the proxy. </st><st c="30836">We will go over the </st><code><st c="30856">getClosestDateForLocation</st></code><st c="30881"> function in </st><st c="30894">a minute.</st></li>
				<li><st c="30903">After we found the closest sales data point according to the tap location, we used the proxy object to </st><em class="italic"><st c="31007">retrieve its position</st></em><st c="31028"> on the chart. </st><st c="31043">One of the proxy’s capabilities is to convert data points to position and </st><st c="31117">vice versa.</st></li>
				<li><st c="31128">When we have the position of the closest data point, we adjust the ruler location by setting the </st><code><st c="31226">markerX</st></code> <st c="31233">state variable.</st></li>
			</ul>
			<p><st c="31249">This piece of code is a good</st><a id="_idIndexMarker542"/><st c="31278"> demonstration of what we can do with the </st><st c="31320">proxy object.</st></p>
			<p><st c="31333">For more proxy object usage, let’s see the </st><code><st c="31377">getClosestDateForLocation</st></code><st c="31402"> function.</st></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor323"/><st c="31412">Finding the closest data point to the user’s touch</st></h2>
			<p><st c="31463">The </st><code><st c="31468">getClosestDateForLocation</st></code><st c="31493"> function goal</st><a id="_idIndexMarker543"/><st c="31507"> is to find the closest date with a data point according to a </st><st c="31569">specific position.</st></p>
			<p><st c="31587">The function receives two parameters – the position (</st><code><st c="31641">CGFloat</st></code><st c="31649">) and the </st><st c="31660">proxy object:</st></p>
			<pre class="source-code"><st c="31673">
func getClosestDateForLocation(x: CGFloat, proxy: ChartProxy) -&gt; Date? </st><st c="31745">{
        var returnedSalesFigure: SalesFigure?
        </st><st c="31785">if let date = proxy.value(atX: x) as Date? </st><st c="31828">{
            var mDistance: TimeInterval = .infinity
            for salesFigure in salesFigures {
                let distance =
                  abs(salesFigure.day.distance(to: date))
                if distance &lt; mDistance {
                    returnedSalesFigure = salesFigure
                    mDistance = distance
                }
            }
        }
        return returnedSalesFigure?.day
    }</st></pre>			<p><st c="32079">Remember what our chart looks like – the </st><em class="italic"><st c="32121">y</st></em><st c="32122"> axis represents the timeline, and the </st><em class="italic"><st c="32161">x</st></em><st c="32162"> axis represents the total sales on a </st><st c="32200">specific date.</st></p>
			<p><st c="32214">So, we can use the proxy object to find the date for a specific </st><code><st c="32279">x</st></code><st c="32280"> value, and that’s our </st><st c="32303">first step:</st></p>
			<pre class="source-code"><st c="32314">
if let date = proxy.value(atX: x) as Date? </st><st c="32358">{</st></pre>			<p><st c="32359">The proxy’s </st><code><st c="32371">value(atX:)</st></code><st c="32382"> function calculates the date value for a specific </st><code><st c="32433">x</st></code><st c="32434"> value.</st></p>
			<p><st c="32441">However, the returned value is arbitrary; to locate the closest data point, we must iterate through our dataset and search for the nearest </st><code><st c="32581">SalesFigure</st></code><st c="32592"> object. </st><st c="32601">Once identified, the function can then </st><st c="32640">return it.</st></p>
			<p><st c="32650">Even though allowing user interaction</st><a id="_idIndexMarker544"/><st c="32688"> with charts is not complex, it includes interesting view modifiers and objects that enable us to access the chart data, perform calculations, and display overlay UI components. </st><st c="32866">We don’t have to use the </st><code><st c="32891">proxy</st></code><st c="32896"> object and the </st><code><st c="32912">chartOverlay</st></code><st c="32924"> view modifier just for interaction—we can show additional information, improve the chart design, and, in rare cases, even create </st><st c="33054">our chart.</st></p>
			<p><st c="33064">Until now, we used data sets with foundation types – </st><code><st c="33118">String</st></code><st c="33124">, </st><code><st c="33126">Double</st></code><st c="33132">, and </st><code><st c="33138">Date</st></code><st c="33142">. However, when we look at the Swift Charts framework headers, we see </st><st c="33212">something interesting:</st></p>
			<pre class="source-code"><st c="33234">
func position&lt;P&gt;(forX value: P) -&gt; CGFloat? </st><st c="33279">where P :
  </st><strong class="bold"><st c="33289">Plottable</st></strong><st c="33298">
public struct LineMark {
     init&lt;X, Y&gt;(x: </st><strong class="bold"><st c="33338">PlottableValue</st></strong><st c="33352">&lt;X&gt;, y: PlottableValue&lt;Y&gt;)
     where X : </st><strong class="bold"><st c="33389">Plottable</st></strong><st c="33398">, Y : </st><strong class="bold"><st c="33404">Plottable</st></strong><st c="33413">
}</st></pre>			<p><st c="33415">It seems that the different chart functions</st><a id="_idIndexMarker545"/><st c="33458"> only work with types that conform to the </st><code><st c="33500">Plottable</st></code><st c="33509"> protocol. </st><st c="33520">Let’s find out what </st><st c="33540">that is.</st></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor324"/><st c="33548">Conforming to the Plottable protocol</st></h1>
			<p><st c="33585">Until now, we have been under the assumption</st><a id="_idIndexMarker546"/><st c="33630"> that any data set we threw on our charts would work. </st><st c="33684">However, we saw that the proxy object can perform interesting calculations that are not possible with any data, and that’s only one reason why our data types need to support the ability to be drawn in </st><st c="33885">a chart.</st></p>
			<p><st c="33893">Therefore, the Swift Charts framework only works with data types that conform to the </st><code><st c="33979">Plottable</st></code><st c="33988"> protocol, which allows data to be drawn in </st><st c="34032">a chart.</st></p>
			<p><st c="34040">First, every primitive data type already conforms to the </st><code><st c="34098">Plottable</st></code><st c="34107"> protocol. </st><st c="34118">Also, the </st><code><st c="34128">Date</st></code><st c="34132"> class that we used in our last example conforms to the </st><code><st c="34188">Plottable</st></code><st c="34197"> protocol. </st><st c="34208">We can even see that in the apple </st><st c="34242">header files:</st></p>
			<pre class="source-code"><st c="34255">
extension Date : Plottable, PrimitivePlottableProtocol
extension String : Plottable, PrimitivePlottableProtocol</st></pre>			<p><st c="34367">However, working only with primitive or Foundation types is not </st><st c="34432">always practical.</st></p>
			<p><st c="34449">Let’s take, for example, our </st><code><st c="34479">Sales</st></code><st c="34484"> structure from the </st><em class="italic"><st c="34504">Adding Stacked </st></em><em class="italic"><st c="34519">Marks</st></em><st c="34524"> section:</st></p>
			<pre class="source-code"><st c="34533">
struct Sales: Identifiable {
    var id: UUID = UUID()
    let itemType: String
    let qty: Int
</st><strong class="bold"><st c="34619">    var fruitColor: String = ""</st></strong><st c="34646">
}</st></pre>			<p><st c="34648">Declaring the </st><code><st c="34662">itemType</st></code><st c="34670"> property as a string</st><a id="_idIndexMarker547"/><st c="34691"> is not always a best practice. </st><st c="34723">Typically, types are part of a closed list, and using strings may lead to typos and duplicates. </st><st c="34819">We probably would like to use an enum for that, as it</st><a id="_idTextAnchor325"/><a id="_idTextAnchor326"/><st c="34872"> is more suitable for handling a list </st><st c="34910">of types:</st></p>
			<pre class="source-code"><st c="34919">
enum FruitType {
    case Apples
    case Oranges
    case Watermelons
}
struct Sales: Identifiable {
    var id: UUID = UUID()
    </st><strong class="bold"><st c="35032">let itemType: FruitType</st></strong><st c="35055">
    let qty: Int
    var fruitColor: String = ""
}</st></pre>			<p><st c="35098">In this example, we created a </st><code><st c="35129">FruitType</st></code><st c="35138"> enum to replace the </st><code><st c="35159">itemType</st></code><st c="35167"> type </st><st c="35173">from </st><code><st c="35178">String</st></code><st c="35184">.</st></p>
			<p><st c="35185">Our next step is to make the </st><code><st c="35215">FruitType</st></code><st c="35224"> enum conform </st><st c="35238">to </st><code><st c="35241">Plottable</st></code><st c="35250">:</st></p>
			<pre class="source-code"><st c="35252">
extension FruitType: </st><strong class="bold"><st c="35274">Plottable</st></strong><st c="35283"> {
    var </st><strong class="bold"><st c="35290">primitivePlottable</st></strong><st c="35308">: String {
        rawValue
    }
}</st></pre>			<p><st c="35332">In this example, we used the </st><code><st c="35362">primitivePlottable</st></code><st c="35380"> variable getter to return the type’s primitive value. </st><st c="35435">That would make the </st><code><st c="35455">FruitType</st></code><st c="35464"> type eligible to be used </st><st c="35490">inside Charts.</st></p>
			<p><st c="35504">Even though not every type can be used</st><a id="_idIndexMarker548"/><st c="35543"> inside a chart, we can easily make them eligible for that. </st><st c="35603">Conforming to the </st><code><st c="35621">Plottable</st></code><st c="35630"> protocol is simple and straightforward and allows us to use our custom-made types </st><st c="35713">within charts.</st></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor327"/><st c="35727">Summary</st></h1>
			<p><st c="35735">The Swift Charts framework is exciting. </st><st c="35776">It allows us to create amazing-looking charts using a simple data set, making it much easier to display data insights, trends, </st><st c="35903">and comparisons.</st></p>
			<p><st c="35919">This chapter reviewed the different chart types of the Swift Charts framework, including BarMark, LineMark, SectorMark, AreaMark, </st><st c="36050">and PointMark.</st></p>
			<p><st c="36064">We also discussed each chart’s different usage and goals, learned how to customize them, and added user interaction to add more capabilities. </st><st c="36207">At last, we went over the </st><code><st c="36233">Plottable</st></code><st c="36242"> protocol, which allows our charts to use almost any data type we want. </st><st c="36314">By now, we should be able to implement charts in our </st><st c="36367">apps quickly.</st></p>
			<p><st c="36380">Our next chapter includes an advanced yet very powerful topic – </st><st c="36445">Swift macros.</st></p>
		</div>
	<div><div><h1 id="_idParaDest-182" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor328"/><st c="0">Part 2: Refine your iOS Development with Advanced Techniques</st></h1>
			<p><st c="61">In this part, you will step up your iOS development and explore advanced topics, such as Swift macros, testing, Combine, architectures, </st><strong class="bold"><st c="198">machine learning</st></strong><st c="214"> (</st><strong class="bold"><st c="216">ML</st></strong><st c="218">), and AI. </st><st c="230">This part is a must-read if you want to get the most from </st><st c="288">iOS 18.</st></p>
			<p><st c="295">This section contains the </st><st c="322">following chapters:</st></p>
			<ul>
				<li><a href="B21795_10.xhtml#_idTextAnchor329"><em class="italic"><st c="341">Chapter 10</st></em></a><st c="352">, </st><em class="italic"><st c="354">Swift Macros </st></em></li>
				<li><a href="B21795_11.xhtml#_idTextAnchor346"><em class="italic"><st c="367">Chapter 11</st></em></a><st c="377">, </st><em class="italic"><st c="379">Creating Pipelines with Combine </st></em></li>
				<li><a href="B21795_12.xhtml#_idTextAnchor369"><em class="italic"><st c="411">Chapter 12</st></em></a><st c="421">, </st><em class="italic"><st c="423">Being Smart with Apple Intelligence and ML </st></em></li>
				<li><a href="B21795_13.xhtml#_idTextAnchor401"><em class="italic"><st c="466">Chapter 13</st></em></a><st c="476">, </st><em class="italic"><st c="478">Exposing Your App to Siri with App Intents </st></em></li>
				<li><a href="B21795_14.xhtml#_idTextAnchor430"><em class="italic"><st c="521">Chapter 14</st></em></a><st c="531">, </st><em class="italic"><st c="533">Improving the App Quality with Swift Testing</st></em></li>
				<li><a href="B21795_15.xhtml#_idTextAnchor463"><em class="italic"><st c="577">Chapter 15</st></em></a><st c="588">, </st><em class="italic"><st c="590">Exploring Architectures for iOS</st></em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	<div></body></html>