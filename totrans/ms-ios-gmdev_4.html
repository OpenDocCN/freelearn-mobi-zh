<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Let's Keep Going! Adding More Functionality</h1></div></div></div><p>We got a lot accomplished in the last chapter! We figured out level creation, importing our levels into Xcode and getting them and our player all showing up in our game. Are you well rested and ready to tackle even more programming awesomeness? Let's see what we will do in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding awesome sound effects</li><li class="listitem" style="list-style-type: disc">Character animations</li><li class="listitem" style="list-style-type: disc">Playing with particles</li><li class="listitem" style="list-style-type: disc">Menus</li><li class="listitem" style="list-style-type: disc">Adding some enemies</li></ul></div><p>Our game looks pretty awesome, but there's still tons of work to be completed before we can even remotely consider releasing it!</p><p>Let's get into it, shall we?</p><p>First things first, we ended the last chapter we had just discussed winning the level, and dying during the level, however if you tested it and you died or beat the level and clicked on the replay button, did the game crash? That's because we need to add one final method:</p><div><pre class="programlisting">- (void)replay:(id)sender
{
    [[self.view viewWithTag:321] removeFromSuperview];
    [self.view presentScene:[[GameLevelScene alloc] initWithSize:self.size]];
   
}</pre></div><p>This block of code simply removes the button from the screen and resets the game. Let's proceed!</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Adding awesome sound effects</h1></div></div></div><p>Yes! We will give <a id="id126" class="indexterm"/>our little guy some sound, specifically, when jumping and dying. That's not all though! No no! We will also get some groovy tunes playing in our levels.</p><p>Let's open up our <code class="literal">GameLevelScene.m</code> file and import the SpriteKit Audio framework to play sounds! At the top of the file where all our import methods are, add the following line:</p><div><pre class="programlisting">#import "SKTAudio.h"</pre></div><p>I've included some audio for our use as well, so if you haven't imported them into your project, go ahead and do that now, or you can use your own music if you like. Once your file has been imported into the project, back in our <code class="literal">GameLevelScene.m</code> file, within our <code class="literal">-(id)initWithSize</code> method, we will add the following line of code to get our music playing:</p><div><pre class="programlisting">[[SKTAudio sharedInstance] playBackgroundMusic:@"BackgroundAudio.mp3"]; //change the file name to whatever file you imported</pre></div><p>Test the project and now you should have some rocking tunes playing in the background! So cool!</p><p>I think we should now create a sound effect for the jump movement, shouldn't we?</p><p>Hopping (no pun intended) on to our <code class="literal">Player.m</code> file, we will locate the block of code where we make our player dance. That method is found in the <code class="literal">update</code> method, and in that method, we will locate the '<code class="literal">if (self.jumping &amp;&amp; self.onGround)</code> statement. In the <code class="literal">if</code> statement, we will add the following code just after the open braces of the <code class="literal">if</code> statement (That is, <code class="literal">{</code>):</p><div><pre class="programlisting">[self runAction:[SKAction playSoundFileNamed:@"jump.wav" waitForCompletion:NO]];</pre></div><p>Let's break this function down a little bit. We tell <strong>self</strong> to run an action, which self in this case is the player class inherited from SKNode, which is where that <code class="literal">runAction</code> method comes from. Then, we declare that action as a SpriteKit action, which is used to play a sound file. We declare the sound file, then we tell SpriteKit not to wait for completion.</p><p>Awesome! Now the character will emit a little blip noise every time the player taps the jump button. You can apply these methods to anywhere you want to play a sound, be it dying, shooting, walking—you name it!</p><p>Notice how we used a different method to play the background music then we did to play the jumping sound effect? Do you know why we did this?</p><p>When you play the game, there will be a bunch of sound effects playing at one a time. If we play the sound effects using the same method that we use to play our music, it would potentially stop playing the music in order to play a new sound effect that has been called, as we can only play one background music file at a time. So when we play a sound effect, we will not interfere with our background music as it plays on a different channel.</p><p>This way, the music will be played without any interruption, unless you get a call while playing it, as there's nothing we can do about that.</p><p>Our game is now <a id="id127" class="indexterm"/>coming together, but I don't like how our player just stays still when he's walking or jumping. Let's add in some animations!</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Character animations</h2></div></div></div><p>Almost all games contain <a id="id128" class="indexterm"/>character or object animations. They add life to the objects or characters, and they make the game look way more appealing. Take the game we are making as an example. Say we pushed the game for sale, and the player just remained in his idle pose all the time, dying, walking, or jumping—there he was just standing as he is.</p><p>Doesn't look proper, does it? We need to change that!</p><p>We've already imported the Sprite atlas file that contains all the images required to create our character animations, so that saves a lot of the work. The Sprite atlas is where all the sprites will go for SpriteKit to access. Instead of having images randomly imported all over the place in our project, the Sprite atlas organizes them all nicely.</p><p>We will go into our <code class="literal">Player.m</code> class, and just below our <code class="literal">@implementation Player</code> line, add the following line of code so that our implementation looks like this:</p><div><pre class="programlisting">@implementation Player
{
  NSArray *walkingAnimation
}</pre></div><p>We need to add an array of images that will make up our walking animations or any other animations that you would like to create.</p><p>Now, in our <code class="literal">initWithImageNamed</code> method, we need to create the array, locate the walking images within the atlas, and then add them to our array. To do this, add the following code directly under the opening bracket for our <code class="literal">init</code> method:</p><div><pre class="programlisting">    NSMutableArray *walkingFrames = [NSMutableArray array];
    SKTextureAtlas *playerAtlas = [SKTextureAtlas atlasNamed:@"sprites"];
    
    int numberOfImages = 8;
    for (int i=1; i &lt;= numberOfImages/2; i++) {
        NSString *imageName = [NSString stringWithFormat:@"P1Walking%d", i];
        SKTexture *temporaryTexture = [playerAtlas textureNamed: imageName];
        [walkingFrames addObject:temporaryTexture];
    }
    walkingAnimation = walkingFrames;</pre></div><p>Let's discuss what just happened here because it's a lot of confusing jargon!</p><p>In the first line, we added sets to an array to hold all the walking images within the atlas. Next, we load the texture atlas that contains all our images. What's great is that the SpriteKit automatically loads the correct resolution for the device we are using, hence the @2x images to make up for the <a id="id129" class="indexterm"/>higher resolution images used for retina displays.</p><p>Next, we tell Xcode to search through the atlas for images named <code class="literal">P1Walking</code>; the <code class="literal">%d</code> automatically searches through all the images named <code class="literal">P1Walking</code>. So, this will start at image <code class="literal">0</code>, then <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, and so forth. Finally, we add the images into our walking animation array.</p><p>We now need to add an action that will fire the animation and stop it when called. We need to add the following methods into our <code class="literal">Player.m</code> file:</p><div><pre class="programlisting">-(void)playWalkingAnim {
[self runAction:[SKAction repeatActionForever:[SKAction animateWith  Textures:walkingAnimation
  timePerFrame:0.1f
  resize:NO
  restore:YES]]
  withKey:@"PlayerWalking"];
    
return;
}

-(void)PlayerStoppedMoving {
 [self removeAllActions];
}</pre></div><p>We add an action key, <code class="literal">PlayerWalking</code> to be able to stop the animation when needed.</p><p>We call this method once when the player is touching the walking zones we created in the previous chapter. Let's go over to our <code class="literal">Player.h</code> file and create another property. With all our other properties, add the following:</p><div><pre class="programlisting">@property (nonatomic, assign) BOOL animateWalking;</pre></div><p>Now, to get our little guy actually animated, we need to jump on to <code class="literal">GameLevelScene.m</code> file. In our <code class="literal">touchesBegan</code> method, where we call the <code class="literal">walking</code> and <code class="literal">goingBackwards</code> Booleans, we need to add the following code:</p><div><pre class="programlisting">self.player1.animateWalking = YES;</pre></div><p>So, now <a id="id130" class="indexterm"/>our <code class="literal">touchesBegan</code> method will look like this (with the new code highlighted):</p><div><pre class="programlisting">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &gt; self.size.width / 2.0) {
            self.player1.jumping = YES;
        }        
        else {
            if (touchLocation.x &lt; self.size.width / 2.0) {
//This will check our touch position on the left hand side of the screen
                if (touchLocation.y &gt; self.size.height / 2){
//This checks if we are in the top left hand corner of the screen, if so trigger walking backward
                    self.player1.goingBackwards = YES;
<strong>                    self.player1.animateWalking = YES;</strong>
                    self.player1.xScale = -1.0;
                }
                if (touchLocation.y &lt; self.size.height / 2){
//This checks if we are touching the bottom left corner. If we are trigger walking forward.
                    self.player1.walking = YES;
<strong>                    self.player1.animateWalking = YES;</strong>
                    self.player1.xScale = 1.0;
                }
            }
            
        }
    }
}</pre></div><p>This will now set our Boolean <code class="literal">true</code> whenever the player touches these walking zones. We also need to set them <code class="literal">false</code> when the touches end, so we will scroll down to our <code class="literal">touchesEnded</code> method and add the following where we turn our walking and <code class="literal">goingBackwards</code> method to <code class="literal">no</code>:</p><div><pre class="programlisting">self.player1.animateWalking = NO;</pre></div><p>Now let's go back to our <code class="literal">Player.m</code> file, and we are going to add the following lines of code to our <code class="literal">update</code> section:</p><div><pre class="programlisting"> if (self.animateWalking) {
        [self actionForKey:@"PlayerWalking"];
    }
    else {
        [self PlayerStoppedMoving];
        
    }
    if (![self actionForKey:@"PlayerWalking"]) {
        
        [self playWalkingAnim];
    }</pre></div><p>Now when the player touches a walking zone, it will set the <code class="literal">animateWalking</code> Boolean to <code class="literal">true</code>, which will call the <code class="literal">PlayerWalking</code> action. When that action is called, we will then animate the character with a walking animation, and when the player removes their fingers from the walking zone, it will stop animating.</p><p>Whew! That's a <a id="id131" class="indexterm"/>lot of code for something so simple, but the results look great!</p><div><img src="img/B03553_04_01.jpg" alt="Character animations"/></div><p>Bit by bit, our little game is coming together! Let's make this level look a little dark and dreary. Let's play with some particles to add depth!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Playing with particles</h2></div></div></div><p>SpriteKit makes <a id="id132" class="indexterm"/>particles super easy, so easy that, in fact, a lot of common particle effects, such as flames, smoke, and rain are premade templates available when creating our particle file.</p><p>In Xcode, to create a new particle emitter, simply navigate to <strong>File</strong> | <strong>New</strong> | <strong>File</strong>. Under the template creator in the <strong>iOS</strong> section (ignore the fact that I have OS X selected in the previous screenshot) and under <strong>Resource</strong>, select <strong>SpriteKit Particle File</strong>, as shown in the following screenshot:</p><div><img src="img/B03553_04_02.jpg" alt="Playing with particles"/></div><p>This is where creating the effects are super easy, simply select <strong>Rain</strong> from the particle template.</p><div><img src="img/B03553_04_03.jpg" alt="Playing with particles"/></div><p>Yes, it's that easy to<a id="id133" class="indexterm"/> create particles!</p><p>Now, all that we have to do is save it, which I just did in the <code class="literal">ADESA</code> project folder. Now, you will see our new particle emitter file in the project explorer in Xcode. Click on it and you should see something similar to the following screenshot:</p><div><img src="img/B03553_04_04.jpg" alt="Playing with particles"/></div><p>Don't worry if<a id="id134" class="indexterm"/> you don't exactly like the look of the particle effect, we can do a whole bunch of adjustments to it.</p><p>At the top of the right-hand side bar, click on the <strong>Show SK Node inspector</strong> button to see all the adjustments we can make. The only thing I changed here is the position range, I changed the value of <strong>X</strong> to <strong>1500</strong> so that it will stretch across the whole screen.</p><div><img src="img/B03553_04_05.jpg" alt="Playing with particles"/></div><p>If you want to make<a id="id135" class="indexterm"/> other adjustments, let me tell you what all these options do.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Background</h3></div></div></div><p>The background option is provided so you can test the visibility of the particles against various colored backgrounds. Changing this option will have no effect on the particles.<a id="id136" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Particle texture</h3></div></div></div><p>The particle texture<a id="id137" class="indexterm"/> is the image file that the emitter will use for the particles. The standard provided image is simply a soft white sphere, so you get a nice smooth and soft particle. This image is great because it can be used for pretty much all types of particles.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Particle birthrate</h3></div></div></div><p>The particle birthrate<a id="id138" class="indexterm"/> is the rate at which new particles are emitted by the emitter. The higher the value, the faster the new particles are spat out. (Be warned, less particles give better performance). The total number of particles to be emitted may also be specified. If you set the value to <strong>0</strong>, this will cause particles to be emitted indefinitely. If you specify a maximum value, the emitter will stop when particles in the scene reach that value.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Particle life cycle</h3></div></div></div><p>The particle life cycle<a id="id139" class="indexterm"/> controls the length of time in seconds for which a particle remains alive. The range property can be used to vary the duration of the life of particles, for example, if you create an explosion, you can use a larger range so you have some particles visible for longer than the others.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Particle position range</h3></div></div></div><p>The particle position range option<a id="id140" class="indexterm"/> defines the location from which particles are created (self-explanatory, right?). The <strong>X</strong> and <strong>Y</strong> values can be used to declare an area around the center of the node location from which particles will be created randomly.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Angle</h3></div></div></div><p>The angle option<a id="id141" class="indexterm"/> relates to the angle at which a newly emitted particle will travel away from the creation point in counterclockwise degrees, where a value of <strong>0</strong> degrees equates to rightward movement. When we set a range value, it will vary the direction in which the particles are emitted.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Particle speed</h3></div></div></div><p>Again, the particle speed option<a id="id142" class="indexterm"/> is pretty self-explanatory. It deals with the speed at which particles move when they are created. When we set a range value, it will vary the direction in which the particles are emitted.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Particle acceleration</h3></div></div></div><p>The acceleration properties<a id="id143" class="indexterm"/> control the speed at which a particle accelerates or decelerates after emission. I'll use explosions for an example again, with this option, you can have them fly out fast but have the shrapnels slow down.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Particle scale</h3></div></div></div><p>The particle scale option<a id="id144" class="indexterm"/> obviously refers to the size of the particles, which again can be varied with the range setting.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Particle rotation</h3></div></div></div><p>The particle rotation<a id="id145" class="indexterm"/> controls the speed at which a particle rotates. Again, you can have a shrapnel rotating as it flies from the explosion.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Particle color</h3></div></div></div><p>The particles<a id="id146" class="indexterm"/> created by an emitter can change colors during their life. To add a new color in the life cycle timeline, click on the color ramp at the location where the color is to change and select a new color (think of creating a gradient in Photoshop or Illustrator). You can also change an existing color by double-clicking on the marker to display the color selection.</p><p>To remove a color from the gradient, click and drag it downward.</p><p>The color blend option controls how many colors in the particles texture image, and how they blend with the main color in the color gradient.</p><p>The greater the <strong>Factor</strong> option, the more the colors blend, where <strong>0</strong> causes no blending.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Particle blend mode</h3></div></div></div><p>The blend mode option<a id="id147" class="indexterm"/> controls the way in which the particle image blends with the scene. The available options are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Alpha</strong>: This blends <a id="id148" class="indexterm"/>transparent backgrounds in the particle image.</li><li class="listitem" style="list-style-type: disc"><strong>Add</strong>: This adds the <a id="id149" class="indexterm"/>particle pixels to the corresponding background image pixels.</li><li class="listitem" style="list-style-type: disc"><strong>Subtract</strong>: This <a id="id150" class="indexterm"/>subtracts the particle pixels from the corresponding background image pixels.</li><li class="listitem" style="list-style-type: disc"><strong>Multiply</strong>: This <a id="id151" class="indexterm"/>multiplies the particle pixels by the corresponding background image pixels. This results in a darker particle effect.</li><li class="listitem" style="list-style-type: disc"><strong>MultiplyX2</strong>: This <a id="id152" class="indexterm"/>creates a darker particle effect than the standard multiply mode.</li><li class="listitem" style="list-style-type: disc"><strong>Screen</strong>: This inverts<a id="id153" class="indexterm"/> pixels, then multiplies and inverts them a second time. This results in lighter particle effects (great for flame effects or sparks).</li><li class="listitem" style="list-style-type: disc"><strong>Replace</strong>: This<a id="id154" class="indexterm"/> results in no blending <a id="id155" class="indexterm"/>with the background. Only the particle's colors are used.</li></ul></div><p>To implement<a id="id156" class="indexterm"/> our particles<a id="id157" class="indexterm"/> into the scene, let's go on over to our <code class="literal">GameLevelScene.m</code> file, and in the <code class="literal">initWithSize</code> method inside the <code class="literal">if (self = [super initWithSize:size])</code> parentheses, add the following block of code:</p><div><pre class="programlisting">NSString *rainParticles =
        [[NSBundle mainBundle] pathForResource:@"Rain" ofType:@"sks"];
        
        SKEmitterNode *rainEmitter =
        [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];
                 rainEmitter.position = CGPointMake(0, self.scene.size.height);
        
        [self addChild:rainEmitter];</pre></div><p>Build and run to see the great results!</p><div><img src="img/B03553_04_07.jpg" alt="Particle blend mode"/></div><p>It looks great, but<a id="id158" class="indexterm"/> now that we have it in the scene, I don't quite like <a id="id159" class="indexterm"/>the look of the rain; I want to tweak it so that it looks a little more realistic. Let's go to the particle editor (again, by clicking on the particle file in our project explorer) and increase the birthrate of the particles.</p><p>Currently, the birthrate is at 150, but I want it to be pouring, so I will increase it to 2500. I will also change the scale down from 0.1 to 0.02 because I think the raindrops look way too big. I'll also change the speed to 500 so that it looks a little more torrential.</p><div><img src="img/B03553_04_08.jpg" alt="Particle blend mode"/></div><p>That does look a lot better! It's tough to tell on paper but the effect looks great on screen.</p><p>Now that we have the <a id="id160" class="indexterm"/>rain looking awesome, let's add in some flames and <a id="id161" class="indexterm"/>smoke effects to our wrecked ship. Create a new particle file, and instead of selecting rain in the template creator, select fire, then save it.</p><p>Our fire effect will be implemented differently as we want it to scroll with the map. With the rain, we added it to the current screen so that it doesn't move with the scene but with the fire. If we were to add it to the scene the same way we did the rain, the particles would stay in the same position according to the screen, not the whole map.</p><p>Back in our <code class="literal">GameLevelScene.m</code> file, in the same location where we added our rain emitter code, add in the following method:</p><div><pre class="programlisting">        NSString *fireParticles =
        [[NSBundle mainBundle] pathForResource:@"Flames"              ofType:@"sks"];
        
        SKEmitterNode *fireEmitter =
        [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];
        fireEmitter.position = CGPointMake(25, 50);

        [_map addChild:fireEmitter];</pre></div><p>See the difference in code? Instead of adding the <code class="literal">fireEmitter</code> as a child to <code class="literal">self</code> or <code class="literal">GameLevelScene</code> class, we add it directly to the map at <code class="literal">25x</code> and <code class="literal">50y</code>, so now when the player begins to scroll through the scene, the fire stays put, burning away the poor crashed ship.</p><div><img src="img/B03553_04_09.jpg" alt="Particle blend mode"/></div><p>Ignore the extreme<a id="id162" class="indexterm"/> drop in frame rate in the screenshot here; whenever <a id="id163" class="indexterm"/>I take a screenshot, the frame rate plummets, as I am running a slightly older iMac. The fire looks good though!</p><p>I did, however, notice that the frame rate stuck at an almost constant 30fps with the flames on the screen. This is where the performance and battery drainage comes into play.</p><p>I'm running the iPhone 4S simulator in Xcode because it fits properly on my screen, which means people with older devices will have difficulty running this game, especially when graphic-intensive elements come onto screen like the particle effects.</p><p>However, running it on my iPhone 5S, the game hit an average of 60fps. These are all the things we have to take into consideration before we publish our game. We will discuss this later on<a id="id164" class="indexterm"/> in <a id="id165" class="indexterm"/>this book.</p><p>Now, let's create a menu system!</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Creating menus and multiple levels</h2></div></div></div><p>Our game is looking really good, but instead of simply throwing the player into the gameplay, let's talk about menus.</p><p>Menus are pretty <a id="id166" class="indexterm"/>important (obviously). It's the stepping stone into the gameplay, and <a id="id167" class="indexterm"/>its absence can leave the players dazed and confused. We don't want that now, do we?</p><p>As we've been going crazy with our level development, we haven't focused on the structure of the game; namely, we've done everything without taking menus or any other functionality into consideration.</p><p>First off, I've included some more images for your use that need to be imported into the project for the following code to work. If you have your own images, simply change the name of the button image accordingly.</p><p>Now, we have to make some substantial modifications to our <code class="literal">GameLevelScene.m</code> file. First things first, we need to create a new integer variable. This will count our levels, with level <code class="literal">0</code> being our main menu. So, in the <code class="literal">@interface GameLevelScene ()</code> method where we begin our declarations, let's add in one more declaration:</p><div><pre class="programlisting">@property (nonatomic, assign) NSInteger level;</pre></div><p>Now, let's do some editing!</p><p>Let's start off with the <code class="literal">initWithSize</code> method. We will edit it so that it looks as follows:</p><div><pre class="programlisting">-(id)initWithSize:(CGSize)size {
    if (self = [super initWithSize:size]) {
        
        self.userInteractionEnabled = YES;
        self.backgroundColor = [SKColor colorWithRed:.0 green:.0 blue:.0 alpha:1.0];
        
      
        if (_level == 0){
        SKLabelNode *playLabel = [SKLabelNode labelNodeWithFontNamed:@"AvenirNext-Heavy"];
        playLabel.text = @"Adesa";
        playLabel.fontSize = 40;
        playLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);
        [self addChild:playLabel];
            
        SKSpriteNode *playButton = [SKSpriteNode spriteNodeWithImageNamed:@"play"];
        playButton.position = CGPointMake(self.size.width /2.0 , self.size.height / 2.5);
        playButton.name = @"playButton";
        [self addChild:playButton];
        }

    }
    return self;
}</pre></div><p>All the init code we had in there originally is now gone. We have placed a nice little label and a button. We also changed the background to black but that part isn't important. Notice how we name the <code class="literal">playButton</code>? This comes in handy when we detect player touches, which you'll see in a moment.</p><p>Now, let's scroll on <a id="id168" class="indexterm"/>down to our <code class="literal">touchesBegan</code> method and add the following code inside<a id="id169" class="indexterm"/> the <code class="literal">for</code> method:</p><div><pre class="programlisting">SKNode *node = [self nodeAtPoint:touchLocation];
        
        if ([node.name isEqualToString:@"playButton"]) {
            _level = 1;
            [self removeAllChildren];
            
            [[SKTAudio sharedInstance] playBackgroundMusic:@"BackgroundAudio.mp3"];
            self.map = [JSTileMap mapNamed:@"level1.tmx"];
            [self addChild:self.map];
            NSString *rainParticles =
            [[NSBundle mainBundle] pathForResource:@"Rain" ofType:@"sks"];
            
            SKEmitterNode *rainEmitter =
            [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];
            
            rainEmitter.position = CGPointMake(0, self.scene.size.height);
            
            [self addChild:rainEmitter];
            
            NSString *fireParticles =
            [[NSBundle mainBundle] pathForResource:@"Flames" ofType:@"sks"];
            
            SKEmitterNode *fireEmitter =
            [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];
            fireEmitter.position = CGPointMake(25, 50);
            
            [_map addChild:fireEmitter];
            
            self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
            self.player1.position = CGPointMake(100, 50);
            self.player1.zPosition = 15;
            [self.map addChild:self.player1];
            self.walls = [self.map layerNamed:@"walls"];
            self.hazards = [self.map layerNamed:@"hazards"];
        }</pre></div><p>Here, we add a new SpriteKit node that is created at the location of your touch. We then detect whether that node is touching our play button, and then we set up all our level 1 stuff.</p><p>I will also change <a id="id170" class="indexterm"/>how the game over is handled. As of this moment, when the<a id="id171" class="indexterm"/> player dies, the screen pops up saying <strong>You have died</strong>, followed by the big <code class="literal">replay</code> button. If we were to leave it as it is, that <code class="literal">replay</code> button method resets the entire game, and I don't think people want to lose their progress when they die in a level.</p><p>Make the following changes to the code. We will delete the highlighted code and replace it with this text:</p><div><pre class="programlisting">-(void)gameOver:(BOOL)won {
    if (_level &gt; 0){
    self.gameOver = YES;
    
    NSString *gameText;
    if (won) {
        gameText = @"Level Complete!";
        
    } else {
        gameText = @"You have died!";
        //add the following lines of code here:
<code class="literal">        self.player1.position = CGPointMake(100, 50);</code>
<code class="literal">    self.player1.zPosition = 15;</code>
<code class="literal">    [self setViewpointCenter:self.player1.position];</code>
<code class="literal">    self.gameOver = NO;</code>
    }
}
}
<strong>    UIButton *replay = [UIButton buttonWithType:UIButtonTypeCustom];</strong>
<strong>    replay.tag = 321;</strong>
<strong>    UIImage *replayImage = [UIImage imageNamed:@"replay"];</strong>
<strong>    [replay setImage:replayImage forState:UIControlStateNormal];</strong>
<strong>    [replay addTarget:self action:@selector(replay:) forControlEvents:UIControlEventTouchUpInside];</strong>
<strong>    replay.frame = CGRectMake(self.size.width / 2.0 - replayImage.size.width / 2.0, self.size.height / 2.0 - replayImage.size.height / 2.0, replayImage.size.width, replayImage.size.height);</strong>
<strong>    [self.view addSubview:replay];</strong>
<strong>    </strong>
<strong>}</strong>
<strong>}</strong>

<strong>- (void)replay:(id)sender</strong>
<strong>{</strong>
<strong>    [[self.view viewWithTag:321] removeFromSuperview];</strong>
<strong>  //  [self.view presentScene:[[GameLevelScene alloc] initWithSize:self.size]];</strong>
<strong>  </strong>
<strong>}</strong>
</pre></div><p>Now, when you <a id="id172" class="indexterm"/>test it and the player dies, he simply teleports to the beginning of the <a id="id173" class="indexterm"/>level instead of having the <code class="literal">replay</code> button pop up, which could prove to be intrusive after a while.</p><p>With our menu built, when you build and run the project, the main menu should look like this:</p><div><img src="img/B03553_04_10.jpg" alt="Creating menus and multiple levels"/></div><p>We will now<a id="id174" class="indexterm"/> implement multiple levels, as I'm pretty sure players would <a id="id175" class="indexterm"/>get bored of playing the same level over and over again. I created a new level for you in the resources section of this book. For this level, our player will locate his lost equipment, but in order to find it, the player needs to work around a little trap in the level.</p><p>Once you've imported the <code class="literal">level2.tmx</code> file into your project, hop on to <code class="literal">GameLevelScene.m</code> file and scroll down to our <code class="literal">didHeWin</code> method and edit it to look as follows:</p><div><pre class="programlisting">-(void)didHeWin {
    if (self.player1.position.x &gt; 3200.0) {
     
        if (_level == 1) {
        [self.map removeFromParent];
        self.map = [JSTileMap mapNamed:@"level2.tmx"];
        [self addChild:self.map];
           
        }
        self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
        self.player1.position = CGPointMake(100, 50);
        self.player1.zPosition = 15;
        [self.map addChild:self.player1];
        self.walls = [self.map layerNamed:@"walls"];
        self.hazards = [self.map layerNamed:@"hazards"];
    }
}</pre></div><p>This new method still detects the player's position, but now we set up a secondary <code class="literal">if</code> statement that detects the level the player is on. In this case, if the level is equal to 1, we then remove the current map from the view, and we add the <code class="literal">level2.tmx</code> file to the view as a child. After this, we relocate the player to the beginning position in the level and check again for the map layers. Fairly easy, right?</p><p>Don't forget to <a id="id176" class="indexterm"/>reimport the <code class="literal">tileSet.png</code> and <code class="literal">tileSet@2x.png</code> files with the ones provided for this chapter, as they contain the new tiles. If you don't reimport these, Xcode will either throw an error or our new tiles just won't appear!</p><p>You can now build <a id="id177" class="indexterm"/>and run our project; now, when the player reaches the end of the level, it should switch over to the next level, which as you can see by the following image, looks pretty awesome!</p><div><img src="img/B03553_04_11.jpg" alt="Creating menus and multiple levels"/></div><p>Yes! Our game is <a id="id178" class="indexterm"/>coming together more and more! However, as awesome as our game <a id="id179" class="indexterm"/>looks, it's pretty darn boring without any enemies! Let's give our little spaceman some competition.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Creating enemies</h1></div></div></div><p>This game isn't simply an<a id="id180" class="indexterm"/> exploration game! We need to make this game intense and exciting!</p><p>Go ahead and import the Squiggy set of images that I've included, or again you can use your own.</p><div><img src="img/B03553_04_12.jpg" alt="Creating enemies"/></div><p>In our <code class="literal">GameLevelScene.m</code> file, we will add a new method to begin spawning random enemies. These ones will start off easy, but we will get into some baddies that will actually try to kill you!</p><p>Anyways, anywhere within the <code class="literal">GameLevelScene.m</code> file, add the following method:</p><div><pre class="programlisting">- (void)addSquiggy {

    SKSpriteNode * squiggy = [SKSpriteNode spriteNodeWithImageNamed:@"Squiggy"];

    int minY = squiggy.size.height / 2;
    int maxY = self.frame.size.height - squiggy.size.height / 2;
    int rangeY = maxY - minY;
    int actualY = (arc4random() % rangeY) + minY;
    squiggy.xScale = -1.0;
    squiggy.position = CGPointMake(self.player1.position.x + 1000 + squiggy.size.width/2, actualY);
    
    squiggy.name = @"squiggy";
    
    [self.map addChild:squiggy];
    
    // Setting the Speed of SQUIGGY!
    int minDuration = 10.0;
    int maxDuration = 20.0;
    int rangeDuration = maxDuration - minDuration;
    int actualDuration = (arc4random() % rangeDuration) + minDuration;
    
    SKAction * actionMove = [SKAction moveTo:CGPointMake(-squiggy.size.width/2, actualY) duration:actualDuration];
    SKAction * actionMoveDone = [SKAction removeFromParent];
    [squiggy runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
}</pre></div><p>This method creates the <a id="id181" class="indexterm"/>Squiggy sprite node. Then, we create a random <em>y</em> axis coordinate to spawn our Squiggy. Why a random <em>y</em> axis? <em>y</em> you ask? (ah, pun intended). Our Squiggy is a flying creature, of course! We also spawn him a little past the visible edge of the screen so that it looks like he's flying into the scene, hence we will add the Squiggy 1000px beyond the position of the player.</p><p>We will add him as a child of the map because we want him to scroll with the map, as well as give him a name so that we can do our collision detection.</p><p>Then, we set a random speed range for our Squiggies to be flying at. Then we create the actions for SpriteKit to get them flying.</p><p>We now need to implement two new properties in our <code class="literal">GameLevelScene.m</code> class. These new classes will control the spawn rate of our Squiggies. So, at the top of the class file, add the following implementations:</p><div><pre class="programlisting">@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;
@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;</pre></div><p>We will use the <code class="literal">lastSpawnTimeInterval</code> method to keep track of the elapsed time since we spawned a Squiggy and the <code class="literal">lastUpdateTimeInterval</code> method to detect the time elapsed since the last update.</p><p>We are now going to create a new update method, but don't worry, it won't interfere with our main <code class="literal">update</code> method. Go ahead and add this method anywhere in the <code class="literal">GameLevelScene.m</code> file:</p><div><pre class="programlisting">- (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {
    
    self.lastSpawnTimeInterval += timeSinceLast;
    if (self.lastSpawnTimeInterval &gt; 2) {
        self.lastSpawnTimeInterval = 0;
        [self addSquiggy];
    }
}

//Then add this method into our regular update method to call our new updateWithTimeSinceLastUpdate method

       CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;
    self.lastUpdateTimeInterval = currentTime;
    if (timeSinceLast &gt; 1) {
        timeSinceLast = 1.0 / 60.0;
        
    }
    
    [self updateWithTimeSinceLastUpdate:timeSinceLast];</pre></div><p>Build, run, and forecast calls for<a id="id182" class="indexterm"/> scattered showers and Squiggies! The result looks pretty cool! We need to make our player get hurt when he touches a Squiggy. Hey, they look cute, but they're dangerous!</p><div><img src="img/B03553_04_13.jpg" alt="Creating enemies"/></div><p>We need to do some work with physics here, so bare with me.</p><p>At the top of our <code class="literal">GameLevelScene.m</code> class, between the <code class="literal">@interface</code> and the <code class="literal">#import</code> section, add the following two lines of code:</p><div><pre class="programlisting">static const uint32_t playerCategory = 0x1 &lt;&lt; 0;
static const uint32_t enemyCategory = 0x1 &lt;&lt; 1;</pre></div><p>These lines set up two categories, one for the enemies and one for the players. We will later add another category for player and enemy projectiles when we incorporate shooting.</p><p>We now need to set up the physics of the world, so inside of our <code class="literal">initWithSize</code> method, we need to add the following lines of code:</p><div><pre class="programlisting">self.physicsWorld.gravity = CGVectorMake(0,0);
self.physicsWorld.contactDelegate = self;</pre></div><p>The preceding code sets up the world gravity and sets the scene as the delegate that will be notified when two objects collide (or physics bodies).</p><p>Physic body is anything within the level, such as the character, objects, or enemies that are controlled by physics.</p><p>Inside of our <code class="literal">addSquiggy</code> method, we need to add the following lines of code, just after we create the actual Squiggy sprite:</p><div><pre class="programlisting">squiggy.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:squiggy.size];
    squiggy.physicsBody.dynamic = YES;
    squiggy.physicsBody.categoryBitMask = enemyCategory;
    squiggy.physicsBody.contactTestBitMask = playerCategory;
    squiggy.physicsBody.collisionBitMask = 0;</pre></div><p>What does this code do, you<a id="id183" class="indexterm"/> ask? Well, let me explain!</p><p>The first line creates a physics body for our Squiggy sprite. The body is the rectangle surrounding the sprite. The next line sets the sprite to be dynamic, meaning that the SpriteKit physics engine will have no bearing over the movement of our Squiggy. The only thing that controls it is our code. The third line puts our Squiggy into the <code class="literal">enemyCategory</code> method.</p><p>We then tell the engine which category method, if a collision occurs between the two objects, should notify us. Obviously, we selected the <code class="literal">playerCategory</code> method.</p><p>The next and final line we added is a bit of a doozy to understand, we set the <code class="literal">collisionBitMask</code> value to <code class="literal">0</code>. The collision bit mask defines the response of each object when a collision occurs. In our case, we set it to <code class="literal">0</code>, meaning that they won't react to each other as far as a ricochet or bounce is concerned.</p><p>We need to add similar code for our player when we create it, so let's create a new method that we will call each time our player is created (that is, just after he dies, or spawns a new level, and so on):</p><div><pre class="programlisting"> -(void)setUpPlayerPhysics{
    self.player1.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:self.player1.size];
    self.player1.physicsBody.dynamic = YES;
    self.player1.physicsBody.categoryBitMask = playerCategory;
    self.player1.physicsBody.contactTestBitMask = enemyCategory;
    self.player1.physicsBody.collisionBitMask = 0;
}</pre></div><p>This is the same method <a id="id184" class="indexterm"/>that we used to set up our enemy's physics; we just switched around the categories.</p><p>Now, at the bottom of the <code class="literal">didHeWin</code> method, as well as in the <code class="literal">touchesBegan</code> method where we set up our player after we touch the button, add this line of code:</p><div><pre class="programlisting"> [self setUpPlayerPhysics];</pre></div><p>Super duper easy peasy! Now we need to actually detect the collisions between the two objects.</p><p>We need to add the following method anywhere in our <code class="literal">GameLevelScene.m</code> class file:</p><div><pre class="programlisting">- (void)didBeginContact:(SKPhysicsContact *)contact
{
    SKPhysicsBody *firstBody, *secondBody;
    
    uint32_t collision = (contact.bodyA.categoryBitMask | contact.bodyB.categoryBitMask);
    
    if (collision == (playerCategory | enemyCategory)) {
        [contact.bodyA.node removeFromParent];
        [contact.bodyB.node removeFromParent];
        [self gameOver:0];
    }
    
    else if (collision == (bulletCategory | enemyCategory)) {
        for (SKSpriteNode *playerBullet in _playerBullets) {
            if (playerBullet.hidden == NO) {
                [contact.bodyA.node removeFromParent];
                [contact.bodyB.node removeFromParent];
            }
        }
    }
    
    if (contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask)
    {
        firstBody = contact.bodyA;
        secondBody = contact.bodyB;

    }
    else
    {
        firstBody = contact.bodyB;
        secondBody = contact.bodyA;
        
    }
}</pre></div><p>We still have to add <a id="id185" class="indexterm"/>the <code class="literal">bulletCategory</code> function, so if you were to build the project right now, it would show you an error. Don't worry, we will add it in just a few moments. Finally, we will make some slight adjustments to our <code class="literal">GameOver</code> method:</p><div><pre class="programlisting">-(void)gameOver:(BOOL)won {
    if (_level &gt; 0){
    self.gameOver = YES;
        [_player1 removeFromParent];
    NSString *gameText;
    if (won) {
        gameText = @"Level Complete!";
        
    } else {
        gameText = @"You have died!";
        self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
        self.player1.position = CGPointMake(100, 50);
        self.player1.zPosition = 15;
        [self setUpPlayerPhysics];
        [self.map addChild:self.player1];
        [self setViewpointCenter:self.player1.position];
        self.gameOver = NO;
    }
}
}</pre></div><p>Here, we changed our code so every time our player is killed, he is removed from the scene, and a new player is created at the beginning of the level. Also, the physics is set up yet again.</p><p>After testing a few methods, the above method is the one that worked the best. I simply teleported our player about 100px ahead of the normal beginning position. No idea why. This works though!</p><p>Now let's get shooting!</p><p>To begin with, we will add another category like we did earlier; this will be as follows:</p><div><pre class="programlisting">static const uint32_t bulletCategory = 0x1 &lt;&lt; 2;</pre></div><p>We will now use this for our player's bullets. Also, we want to add a new definition, so just under the <code class="literal">#import</code> section, add the following line of code:</p><div><pre class="programlisting">#define kNumBullets 20</pre></div><p>This definition will assist in creating an array for all our bullets, which we will do a little further in just a bit.</p><p>Just above the <code class="literal">@implementation</code> line and just before the <code class="literal">@end</code> line of our property declarations, add the following two lines of code:</p><div><pre class="programlisting">NSMutableArray *_playerBullets;
int _nextPlayerBullet;</pre></div><p>We created the player bullet<a id="id186" class="indexterm"/> array that will allow us to create multiple bullets at once. We then defined the number of the next bullet within the array.</p><p>Inside our <code class="literal">setUpPlayerPhysics</code> method, add the following block of code (don't forget to import all the images located in the resource section of this book):</p><div><pre class="programlisting">  #pragma mark - Setup the bullets
    _playerBullets = [[NSMutableArray alloc] initWithCapacity:kNumBullets];
    for (int i = 0; i &lt; kNumBullets; ++i) {
        SKSpriteNode *playerBullet = [SKSpriteNode spriteNodeWithImageNamed:@"Bullet"];
        playerBullet.hidden = YES;
        [_playerBullets addObject:playerBullet];
        [self.map addChild:playerBullet];
    }</pre></div><p>Welcome to arrays! What does all this mean? Easy! We take the <code class="literal">_playerBullets</code> array, initialize it with a predefined number of bullets in the array; the <code class="literal">kNumBullets</code> variable which was <code class="literal">20</code>. So now the array has a value of <code class="literal">20</code>. Then, for every entry in the array, from <code class="literal">0</code>-<code class="literal">20</code>, add a bullet. It really is that easy.</p><p>We will create a new method, which will be as follows:</p><div><pre class="programlisting">-(void) startTheGame {
    for (SKSpriteNode *playerBullet in _playerBullets) {
        playerBullet.hidden = YES;
    }
}</pre></div><p>We will call the preceding method when the player presses the play button, so in our <code class="literal">touchesBegan</code> method, at the bottom of the <code class="literal">if ([node.name isEqualToString:@"playButton"]) {</code> statement, add the following:</p><div><pre class="programlisting">[self startTheGame];</pre></div><p>Now, we need to create a<a id="id187" class="indexterm"/> new touch zone. So, in our <code class="literal">touchesBegan</code> method, we need to edit our <code class="literal">if (touchLocation.x &gt; self.size.width / 2.0) {</code> statement to the following:</p><div><pre class="programlisting"> if (touchLocation.x &gt; self.size.width / 2.0) {
            if (touchLocation.y &lt; self.size.height / 2.0) {
            self.player1.jumping = YES;
            }
            else if (touchLocation.y &gt; self.size.height / 2.0) {
                NSLog(@"PEW");
                if (touchLocation.x &gt; self.size.width / 2.0) {
                    if (touchLocation.y &lt; self.size.height / 2.0) {
                        self.player1.jumping = YES;
                    }
                    else if (touchLocation.y &gt; self.size.height / 2.0) {
                        if (self.player1.xScale == - 1.0) {
                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];
                            _nextPlayerBullet++;
                            if (_nextPlayerBullet &gt;= _playerBullets.count) {
                                _nextPlayerBullet = 0;
                            }
                            
                            
                            bullet.position = CGPointMake(_player1.position.x-bullet.size.width/2,_player1.position.y+0);
                            bullet.hidden = NO;
                            [bullet removeAllActions];
                            
                            
                            CGPoint location = CGPointMake(_player1.position.x - 1000, _player1.position.y);
                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];
                            
                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {
                                bullet.hidden = YES;
                            }];
                            
                            
                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];
                            [bullet runAction:moveBulletActionWithDone withKey:@"bulletFired"];
                        }
                        
                        
                        else {
                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];
                            _nextPlayerBullet++;
                            if (_nextPlayerBullet &gt;= _playerBullets.count) {
                                _nextPlayerBullet = 0;
                            }
                            
                            
                            bullet.position = CGPointMake(_player1.position.x+bullet.size.width/2,_player1.position.y+0);
                            bullet.hidden = NO;
                            [bullet removeAllActions];
                            
                            
                            CGPoint location = CGPointMake(_player1.position.x + 1000, _player1.position.y);
                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];
                            
                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {
                                bullet.hidden = YES;
                            }];
                            
                            
                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];
                            [bullet runAction:moveBulletActionWithDone withKey:@"bulletFired"];
                        }
                    }
                }
            }
        }</pre></div><p>Here, we selected one <a id="id188" class="indexterm"/>of the bullets within the array. We then set the position of that bullet at the player's position. Next, we set the bullet's final position off the screen, which is why we added two methods, one if the player presses the button when walking backward, and the other going forward.</p><p>Now, when you test it you will see the following output:</p><div><img src="img/B03553_04_14.jpg" alt="Creating enemies"/></div><p>Lots of pew pew! And it <a id="id189" class="indexterm"/>shoots according to the direction you're facing too, so that's pretty awesome.</p><p>Now, back in our <code class="literal">setUpPlayerPhysics</code> method, where we set up the bullets, we need to set the <code class="literal">physicsBody</code> value for each bullet. In the <code class="literal">for</code> loop, just before we add the bullet to the map as a child, add the following code:</p><div><pre class="programlisting">playerBullet.hidden = YES;
        playerBullet.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:playerBullet.size];
        playerBullet.physicsBody.dynamic = YES;
        playerBullet.physicsBody.categoryBitMask = bulletCategory;
        playerBullet.physicsBody.contactTestBitMask = enemyCategory;
        playerBullet.physicsBody.collisionBitMask = 0;</pre></div><p>This is the same as our previous <code class="literal">physicsBody</code> setup, except we changed the bullet's category to the <code class="literal">bulletCategory</code>.</p><p>Now, when you test your<a id="id190" class="indexterm"/> project, you should be shooting, dying, and killing without a care in the world! Isn't it great?</p><div><img src="img/B03553_04_15.jpg" alt="Creating enemies"/></div><p>If it is working for you, great! I'm happy for you! We've done a lot of work in this chapter and our game really isn't even close to finishing. Why not try to take what you've learned in this chapter and create your own levels? Spawn some new enemies, and maybe try having some shooting baddies? If not, I'll cover some crazier baddies later on in this book. For now let's go take a break!</p><p>Our game is running efficiently, running at an almost constant 60 fps! Awesome! In case you don't have things working just right, the following is the complete source code you should have up until now:</p><div><pre class="programlisting">//  GameLevelScene.m


#import "GameLevelScene.h"
#import "JSTileMap.h"
#import "Player.h"
#import "SKTUtils.h"
#import "SKTAudio.h"
#define kNumBullets 20

static const uint32_t playerCategory = 0x1 &lt;&lt; 0;
static const uint32_t enemyCategory = 0x1 &lt;&lt; 1;
static const uint32_t bulletCategory = 0x1 &lt;&lt; 2;

@interface GameLevelScene() &lt;SKPhysicsContactDelegate&gt;
@property (nonatomic, strong) JSTileMap *map;
@property (nonatomic, strong) Player *player1;
@property (nonatomic, assign) NSTimeInterval previousTime;
@property (nonatomic, strong) TMXLayer *walls;
@property (nonatomic, strong) TMXLayer *hazards;
@property (nonatomic, assign) BOOL gameOver;

@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;
@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;
@property (nonatomic, assign) NSInteger level;
@end

NSMutableArray *_playerBullets;
int _nextPlayerBullet;

@implementation GameLevelScene


-(id)initWithSize:(CGSize)size {
    if (self = [super initWithSize:size]) {

        
        self.userInteractionEnabled = YES;
        self.backgroundColor = [SKColor colorWithRed:.0 green:.0 blue:.0 alpha:1.0];
        self.physicsWorld.gravity = CGVectorMake(0, 0);
        self.physicsWorld.contactDelegate = self;
       
      
        
        if (_level == 0){
        SKLabelNode *playLabel = [SKLabelNode labelNodeWithFontNamed:@"AvenirNext-Heavy"];
        playLabel.text = @"Adesa";
        playLabel.fontSize = 40;
        playLabel.position = CGPointMake(self.size.width / 2.0, self.size.height / 1.7);
        [self addChild:playLabel];
            
        SKSpriteNode *playButton = [SKSpriteNode spriteNodeWithImageNamed:@"play"];
        playButton.position = CGPointMake(self.size.width /2.0 , self.size.height / 2.5);
        playButton.name = @"playButton";
        [self addChild:playButton];
            
        
        }
   
    }
    return self;
}

-(void) startTheGame {
    for (SKSpriteNode *playerBullet in _playerBullets) {
        playerBullet.hidden = YES;
    }
}

- (void)addSquiggy {

    SKSpriteNode * squiggy = [SKSpriteNode spriteNodeWithImageNamed:@"Squiggy"];
    squiggy.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:squiggy.size];
    squiggy.physicsBody.dynamic = YES;
    squiggy.physicsBody.categoryBitMask = enemyCategory;
    squiggy.physicsBody.contactTestBitMask = playerCategory;
    squiggy.physicsBody.collisionBitMask = 0;
    
    
    int minY = squiggy.size.height / 2;
    int maxY = self.frame.size.height - squiggy.size.height / 2;
    int rangeY = maxY - minY;
    int actualY = (arc4random() % rangeY) + minY;
    squiggy.xScale = -1.0;
    squiggy.position = CGPointMake(self.player1.position.x + 1000 + squiggy.size.width/2, actualY);
    [self.map addChild:squiggy];
    
    // Setting the Speed of SQUIGGY!
    int minDuration = 10.0;
    int maxDuration = 20.0;
    int rangeDuration = maxDuration - minDuration;
    int actualDuration = (arc4random() % rangeDuration) + minDuration;
    
    SKAction * actionMove = [SKAction moveTo:CGPointMake(-squiggy.size.width/2, actualY) duration:actualDuration];
    SKAction * actionMoveDone = [SKAction removeFromParent];
    [squiggy runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
}

- (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {
    
    self.lastSpawnTimeInterval += timeSinceLast;
    if (self.lastSpawnTimeInterval &gt; 2) {
        self.lastSpawnTimeInterval = 0;
        [self addSquiggy];
    
    }
}


-(CGRect)tileRectFromTileCoords:(CGPoint)tileCoords {
    float levelHeightInPixels = self.map.mapSize.height * self.map.tileSize.height;
    CGPoint origin = CGPointMake(tileCoords.x * self.map.tileSize.width, levelHeightInPixels - ((tileCoords.y + 1) * self.map.tileSize.height));
    return CGRectMake(origin.x, origin.y, self.map.tileSize.width, self.map.tileSize.height);
}

- (NSInteger)tileGIDAtTileCoord:(CGPoint)coord forLayer:(TMXLayer *)layer {
    TMXLayerInfo *layerInfo = layer.layerInfo;
    return [layerInfo tileGidAtCoord:coord];
}

- (void)handleHazardCollisions:(Player *)player
{
    [self didHeWin];
    
    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};
    
    for (NSUInteger i = 0; i &lt; 8; i++) {
        NSInteger tileIndex = indices[i];
       
        
        CGRect playerRect = [player collisionBox];
        CGPoint playerCoord = [self.hazards coordForPoint:player.desiredPosition];
        
        NSInteger tileColumn = tileIndex % 3;
        NSInteger tileRow = tileIndex / 3;
        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));
        
        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:self.hazards];
        if (gid != 0) {
            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];
            if (CGRectIntersectsRect(playerRect, tileRect)) {
                [self gameOver:0];
            }
        }
    }
}

-(void)gameOver:(BOOL)won {
    if (_level &gt; 0){
    self.gameOver = YES;
        [_player1 removeFromParent];
    NSString *gameText;
    if (won) {
        gameText = @"Level Complete!";
        
    } else {
        gameText = @"You have died!";
        self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
        self.player1.position = CGPointMake(100, 50);
        self.player1.zPosition = 15;
        [self setUpPlayerPhysics];
        [self.map addChild:self.player1];
        [self setViewpointCenter:self.player1.position];
        self.gameOver = NO;
    }
}
}

-(void)setUpPlayerPhysics{
    self.player1.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:self.player1.size];
    self.player1.physicsBody.dynamic = YES;
    self.player1.physicsBody.categoryBitMask = playerCategory;
    self.player1.physicsBody.contactTestBitMask = enemyCategory;
    self.player1.physicsBody.collisionBitMask = 0;
    
#pragma mark - Setup the bullets
    _playerBullets = [[NSMutableArray alloc] initWithCapacity:kNumBullets];
    for (int i = 0; i &lt; kNumBullets; ++i) {
        SKSpriteNode *playerBullet = [SKSpriteNode spriteNodeWithImageNamed:@"Bullet"];
        playerBullet.hidden = YES;
        playerBullet.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:playerBullet.size];
        playerBullet.physicsBody.dynamic = YES;
        playerBullet.physicsBody.categoryBitMask = bulletCategory;
        playerBullet.physicsBody.contactTestBitMask = enemyCategory;
        playerBullet.physicsBody.collisionBitMask = 0;
        
        [_playerBullets addObject:playerBullet];
        [self.map addChild:playerBullet];
    }
}

-(void)didHeWin {
    if (self.player1.position.x &gt; 3200.0) {
     
        if (_level == 1) {
        [self.map removeFromParent];
        self.map = [JSTileMap mapNamed:@"level2.tmx"];
        [self addChild:self.map];
        }
        self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
        self.player1.position = CGPointMake(100, 50);
        self.player1.zPosition = 15;
        [self.map addChild:self.player1];
        self.walls = [self.map layerNamed:@"walls"];
        self.hazards = [self.map layerNamed:@"hazards"];
        [self setUpPlayerPhysics];
    }
}


- (void)checkForAndResolveCollisionsForPlayer:(Player *)player forLayer:(TMXLayer *)layer
{
   
    
    NSInteger indices[8] = {7, 1, 3, 5, 0, 2, 6, 8};
    player.onGround = NO;
    for (NSUInteger i = 0; i &lt; 8; i++) {
        NSInteger tileIndex = indices[i];
        
        CGRect playerRect = [player collisionBox];
        CGPoint playerCoord = [layer coordForPoint:player.desiredPosition];
        if (playerCoord.y &gt;= self.map.mapSize.height - 1) {
            [self gameOver:0];
            return;
        }
        
        NSInteger tileColumn = tileIndex % 3;
        NSInteger tileRow = tileIndex / 3;
        CGPoint tileCoord = CGPointMake(playerCoord.x + (tileColumn - 1), playerCoord.y + (tileRow - 1));
        
        NSInteger gid = [self tileGIDAtTileCoord:tileCoord forLayer:layer];
        if (gid != 0) {
            CGRect tileRect = [self tileRectFromTileCoords:tileCoord];

            if (CGRectIntersectsRect(playerRect, tileRect)) {
                CGRect intersection = CGRectIntersection(playerRect, tileRect);
          
                if (tileIndex == 7) {
                 
                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height);
                    player.velocity = CGPointMake(player.velocity.x, 0.0);
                    player.onGround = YES;
                } else if (tileIndex == 1) {
                    
                    player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y - intersection.size.height);
                } else if (tileIndex == 3) {
                    
                    player.desiredPosition = CGPointMake(player.desiredPosition.x + intersection.size.width, player.desiredPosition.y);
                } else if (tileIndex == 5) {
                    
                    player.desiredPosition = CGPointMake(player.desiredPosition.x - intersection.size.width, player.desiredPosition.y);
                  
                } else {
                    if (intersection.size.width &gt; intersection.size.height) {
                        
                        player.velocity = CGPointMake(player.velocity.x, 0.0);
                        float intersectionHeight;
                        if (tileIndex &gt; 4) {
                            intersectionHeight = intersection.size.height;
                            player.onGround = YES;
                        } else {
                            intersectionHeight = -intersection.size.height;
                        }
                        player.desiredPosition = CGPointMake(player.desiredPosition.x, player.desiredPosition.y + intersection.size.height );
                    } else {
                       
                        float intersectionWidth;
                        if (tileIndex == 6 || tileIndex == 0) {
                            intersectionWidth = intersection.size.width;
                        } else {
                            intersectionWidth = -intersection.size.width;
                        }
                        
                        player.desiredPosition = CGPointMake(player.desiredPosition.x  + intersectionWidth, player.desiredPosition.y);
                    }
                }
            }
        }
    }

    player.position = player.desiredPosition;
    [self handleHazardCollisions:self.player1];
}


- (void)didBeginContact:(SKPhysicsContact *)contact
{
    SKPhysicsBody *firstBody, *secondBody;
    
    uint32_t collision = (contact.bodyA.categoryBitMask | contact.bodyB.categoryBitMask);
    
    if (collision == (playerCategory | enemyCategory)) {
        [contact.bodyA.node removeFromParent];
        [contact.bodyB.node removeFromParent];
        [self gameOver:0];
    }
    
    else if (collision == (bulletCategory | enemyCategory)) {
        for (SKSpriteNode *playerBullet in _playerBullets) {
            if (playerBullet.hidden == NO) {
                [contact.bodyA.node removeFromParent];
                [contact.bodyB.node removeFromParent];
            }
        }
    }
    
    if (contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask)
    {
        firstBody = contact.bodyA;
        secondBody = contact.bodyB;

    }
    else
    {
        firstBody = contact.bodyB;
        secondBody = contact.bodyA;
        
    }
}




- (void)setViewpointCenter:(CGPoint)position {
    NSInteger x = MAX(position.x, self.size.width / 2);
    NSInteger y = MAX(position.y, self.size.height / 2);
    x = MIN(x, (self.map.mapSize.width * self.map.tileSize.width) - self.size.width / 2);
    y = MIN(y, (self.map.mapSize.height * self.map.tileSize.height) - self.size.height / 2);
    CGPoint actualPosition = CGPointMake(x, y);
    CGPoint centerOfView = CGPointMake(self.size.width/2, self.size.height/2);
    CGPoint viewPoint = CGPointSubtract(centerOfView, actualPosition);
    self.map.position = viewPoint;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        
        SKNode *node = [self nodeAtPoint:touchLocation];
        
        if ([node.name isEqualToString:@"playButton"]) {
            _level = 1;
            [self removeAllChildren];
            self.backgroundColor = [SKColor colorWithRed:.25 green:.0 blue:.25 alpha:1.0];
            [[SKTAudio sharedInstance] playBackgroundMusic:@"BackgroundAudio.mp3"];
            self.map = [JSTileMap mapNamed:@"level1.tmx"];
            [self addChild:self.map];
            NSString *rainParticles =
            [[NSBundle mainBundle] pathForResource:@"Rain" ofType:@"sks"];
            
            SKEmitterNode *rainEmitter =
            [NSKeyedUnarchiver unarchiveObjectWithFile:rainParticles];
            
            rainEmitter.position = CGPointMake(0, self.scene.size.height);
            
            [self addChild:rainEmitter];
            
            NSString *fireParticles =
            [[NSBundle mainBundle] pathForResource:@"Flames" ofType:@"sks"];
            
            SKEmitterNode *fireEmitter =
            [NSKeyedUnarchiver unarchiveObjectWithFile:fireParticles];
            fireEmitter.position = CGPointMake(25, 50);
            
            [_map addChild:fireEmitter];
            
            self.player1 = [[Player alloc] initWithImageNamed:@"P1idle"];
            self.player1.position = CGPointMake(100, 50);
            self.player1.zPosition = 15;
            [self.map addChild:self.player1];
            self.walls = [self.map layerNamed:@"walls"];
            self.hazards = [self.map layerNamed:@"hazards"];
            [self setUpPlayerPhysics];
            [self startTheGame];
        }
        
        if (touchLocation.x &gt; self.size.width / 2.0) {
            if (touchLocation.y &lt; self.size.height / 2.0) {
            self.player1.jumping = YES;
            }
            else if (touchLocation.y &gt; self.size.height / 2.0) {
                NSLog(@"PEW");
                if (touchLocation.x &gt; self.size.width / 2.0) {
                    if (touchLocation.y &lt; self.size.height / 2.0) {
                        self.player1.jumping = YES;
                    }
                    else if (touchLocation.y &gt; self.size.height / 2.0) {
                        if (self.player1.xScale == - 1.0) {
                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];
                            _nextPlayerBullet++;
                            if (_nextPlayerBullet &gt;= _playerBullets.count) {
                                _nextPlayerBullet = 0;
                            }
                            
                            
                            bullet.position = CGPointMake(_player1.position.x-bullet.size.width/2,_player1.position.y+0);
                            bullet.hidden = NO;
                            [bullet removeAllActions];
                            
                            
                            CGPoint location = CGPointMake(_player1.position.x - 1000, _player1.position.y);
                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];
                            
                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {
                                bullet.hidden = YES;
                            }];
                            
                            
                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];
                            [bullet runAction:moveBulletActionWithDone withKey:@"bulletFired"];
                        }
                        
                        
                        else {
                            SKSpriteNode *bullet = [_playerBullets objectAtIndex:_nextPlayerBullet];
                            _nextPlayerBullet++;
                            if (_nextPlayerBullet &gt;= _playerBullets.count) {
                                _nextPlayerBullet = 0;
                            }
                            
                            
                            bullet.position = CGPointMake(_player1.position.x+bullet.size.width/2,_player1.position.y+0);
                            bullet.hidden = NO;
                            [bullet removeAllActions];
                            
                            
                            CGPoint location = CGPointMake(_player1.position.x + 1000, _player1.position.y);
                            SKAction *bulletMoveAction = [SKAction moveTo:location duration:2.5];
                            
                            SKAction *bulletDoneAction = [SKAction runBlock:(dispatch_block_t)^() {
                                bullet.hidden = YES;
                            }];
                            
                            
                            SKAction *moveBulletActionWithDone = [SKAction sequence:@[bulletMoveAction,bulletDoneAction]];
                            [bullet runAction:moveBulletActionWithDone withKey:@"bulletFired"];
                        }
                    }
                }
            }
        }
     
        else {
            if (touchLocation.x &lt; self.size.width / 2.0) {
                if (touchLocation.y &gt; self.size.height / 2){
                    self.player1.goingBackwards = YES;
                    self.player1.animateWalking = YES;
                    self.player1.xScale = -1.0;
                }
                if (touchLocation.y &lt; self.size.height / 2){
                    self.player1.walking = YES;
                    self.player1.animateWalking = YES;
                    self.player1.xScale = 1.0;
                }
            }
            
        }
    }
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    for (UITouch *touch in touches) {
        
        float halfWidth = self.size.width / 2.0;
        CGPoint touchLocation = [touch locationInNode:self];
        
       
        CGPoint previousTouchLocation = [touch previousLocationInNode:self];
        
        if (touchLocation.x &gt; halfWidth &amp;&amp; previousTouchLocation.x &lt;= halfWidth) {
            self.player1.walking = NO;
            self.player1.goingBackwards = NO;
            self.player1.jumping = YES;
        } else if (previousTouchLocation.x &gt; halfWidth &amp;&amp; touchLocation.x &lt;= halfWidth) {

            self.player1.goingBackwards = NO;
            self.player1.jumping = NO;
        }
        else if (previousTouchLocation.x &gt; halfWidth &amp;&amp; touchLocation.x &lt;= halfWidth) {
            if (touchLocation.y &gt; self.size.height / 2){
            self.player1.walking = NO;
            self.player1.jumping = NO;
            }
        }
    }
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    
    for (UITouch *touch in touches) {
        CGPoint touchLocation = [touch locationInNode:self];
        if (touchLocation.x &lt; self.size.width / 2.0) {
            if (touchLocation.x &lt; self.size.width / 2.0) {
                if (touchLocation.y &gt; self.size.height / 2){
                    self.player1.goingBackwards = NO;
                    self.player1.animateWalking = NO;
                }
                if (touchLocation.y &lt; self.size.height / 2){
                    self.player1.walking = NO;
                    self.player1.animateWalking = NO;
                }
            }
            
        } else {
            self.player1.jumping = NO;
        }
    }
}



- (void)update:(NSTimeInterval)currentTime
{

    
    CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;
    self.lastUpdateTimeInterval = currentTime;
    if (timeSinceLast &gt; 1) {
        timeSinceLast = 1.0 / 60.0;
        self.lastUpdateTimeInterval = currentTime;
    }
    
    [self updateWithTimeSinceLastUpdate:timeSinceLast];
    
    if (self.gameOver) return;
    
    [self setViewpointCenter:self.player1.position];
    NSTimeInterval delta = currentTime - self.previousTime;
    
    if (delta &gt; 0.02) {
        delta = 0.02;
    }
    
    self.previousTime = currentTime;
    
    [self.player1 update:delta];
    
    [self checkForAndResolveCollisionsForPlayer:self.player1 forLayer:self.walls];
}

@end //(which is fitting because this is the end of the chapter... and end of the page :D)</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Summary</h1></div></div></div><p>Let's recall all that we covered in this chapter. We added some music and cool sound effects to our game. Then, we gave our player a proper walking animation so that he doesn't look like he's floating in the air! However, if that's not an effect you're looking for, you can save yourself a bunch of typing. Next, we made some really awesome looking particles! We made it rain, and we made the wrecked ship burn in flames!</p><p>We briefly discussed menus, and how we can create a simple main menu. We will polish this up later when preparing for publishing.</p><p>Then, the enemies! We made our Squiggies, those cute yet dangerous enemies in our game. Things are going to get scary, so buckle up and enjoy the ride.</p><p>Note: It will only get scary for our player, and not for us because we are the ones creating the madness.</p></div></body></html>