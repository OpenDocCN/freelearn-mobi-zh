- en: Designed for Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为并发设计
- en: In this chapter, we'll discuss the most common concurrency design patterns,
    implemented with coroutines, and how coroutines can synchronize their execution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论最常见的并发设计模式，这些模式使用协程实现，以及协程如何同步它们的执行。
- en: Concurrent design patterns help us to manage many tasks at once. Yeah, I know,
    that's what we did in the last chapter. That's because some of those design patterns
    are already built into the language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并发设计模式帮助我们同时管理许多任务。是的，我知道，我们在上一章就是这样做的。那是因为其中一些设计模式已经内置到语言中。
- en: In this chapter, we'll briefly cover design patterns and other concurrent design
    patterns that you'll need to implement by yourself, with little effort.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍你需要自己实现的设计模式和并发设计模式，这些模式需要付出很少的努力。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Active Object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动对象
- en: Deferred value
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟值
- en: Barrier
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 障碍
- en: Scheduler
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Pipelines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Fan out
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出
- en: Fan in
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇入
- en: Buffered channels
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: Unbiased select
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无偏选择
- en: Mutex
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁
- en: Select on close
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关闭时选择
- en: Sidekick channel
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伴随通道
- en: Deferred channel
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟通道
- en: Active Object
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动对象
- en: This design pattern allows a method to be executed in a safe way on another
    thread. Guess what else is being executed on another thread?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式允许一个方法以安全的方式在另一个线程上执行。猜猜还有什么是在另一个线程上执行的？
- en: 'You''re totally right: `actor()`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全正确：`actor()`。
- en: So, it's one of those design patterns that is already built into the language.
    Or, to be precise, into one of the accommodating libraries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它是一种已经内置到语言中的设计模式。或者，更准确地说，内置到其中一个兼容库中。
- en: We've already seen how to send data to `actor()`. But how do we receive data
    from it?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何向`actor()`发送数据。但我们如何从它那里接收数据？
- en: 'One way is to supply it with a channel for output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是为它提供一个输出通道：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember to close the output channel when you're done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在你完成时关闭输出通道。
- en: Testing
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'To test the **Active Object** pattern, we''ll launch two jobs. One will send
    data to our actor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试**活动对象**模式，我们将启动两个作业。一个将数据发送到我们的actor：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And another will wait for output on the outbound channel:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将等待输出通道上的输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Deferred value
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟值
- en: We've already met deferred values in [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7), *Threads
    and Coroutines*, in the *Returning results* section. `Deferred` is the result
    of the `async()` function, for example. You may also know them as *Futures* from
    Java or Scala, or as *Promises* from JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第8章](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7)的*线程和协程*部分遇到了延迟值，*返回结果*部分。`Deferred`是`async()`函数的结果，例如。你可能也知道它们来自Java或Scala的*Future*，或者来自JavaScript的*Promise*。
- en: Interestingly enough, Deferred is a **Proxy** design pattern that we've met
    in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Deferred是一种我们在前面章节中遇到的**代理**设计模式。
- en: Much as the Kotlin `Sequence` is very similar to the Java8 `Stream`, Kotlin
    Deferred is very similar to Java Future. You'll rarely need to create your own
    Deferred. Usually, you would work with the one returned from `async().`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kotlin的`Sequence`与Java8的`Stream`非常相似一样，Kotlin的Deferred与Java Future也非常相似。你很少需要自己创建Deferred。通常，你会使用`async()`返回的那个。
- en: 'In cases where you do need to return a placeholder for a value that would be
    evaluated in the future, you can do it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在你需要返回一个未来将评估的值的占位符的情况下，你可以这样做：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code will print `OK` half of the time, and throw `RuntimeException` the
    other half of the time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将有一半的时间打印`OK`，另一半的时间抛出`RuntimeException`。
- en: Make sure that you always complete your deferred. It is usually a good idea
    to wrap any code containing deferred into a `try...catch` block.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你总是完成你的延迟。通常，将包含延迟的任何代码包装在`try...catch`块中是一个好主意。
- en: 'It is also possible to cancel a deferred if you''re no longer interested in
    its results. Simply call `cancel()` on it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对延迟的结果不再感兴趣，也可以取消延迟。只需在它上面调用`cancel()`即可：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Barrier
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍
- en: The Barrier design pattern provides us with the means to wait for multiple concurrent
    tasks before proceeding further. A common use case is composing objects from different
    sources.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 障碍设计模式为我们提供了在进一步操作之前等待多个并发任务的手段。一个常见的用例是从不同的来源组合对象。
- en: 'Take, for example, the following class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个类：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Assume that we're fetching name, `catchphrase`, and number. This `catchphrase`
    is being repeated from three different sources.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在获取名称、`catchphrase`和数字。这个`catchphrase`正从三个不同的来源重复。
- en: 'The most basic way would be to use `CountDownLatch`, as we did in some of the
    previous examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的方法是使用 `CountDownLatch`，就像我们在一些之前的例子中所做的那样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''ll notice that the order of the async tasks completing is changing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到异步任务完成的顺序正在改变：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But in the end, we always print the same result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终，我们总是打印出相同的结果：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But this solution brings a lot of problems. We need to work with mutable variables
    and either set defaults for them or use nulls.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个解决方案带来了很多问题。我们需要处理可变变量，要么为它们设置默认值，要么使用空值。
- en: Also, this would work as long as we use closures. What if our functions were
    longer than a few lines?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，只要我们使用闭包，这也会工作。如果我们的函数比几行长呢？
- en: CountDownLatch
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CountDownLatch
- en: 'We could pass them the latch, of course. The latch, which we''ve already seen
    a couple of times, allows one thread to wait until the other threads have completed
    working:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以传递它们闩锁。我们已经见过几次的闩锁允许一个线程等待，直到其他线程完成工作：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But it's not a clear separation of concerns. Do we really want to specify how
    this function should be synchronized?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是一个清晰的职责分离。我们真的想要指定这个函数应该如何同步吗？
- en: 'Let''s have a second take:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just a reminder, `fun getRepeats() = async { ... }` has nothing magical in
    it. Its longer equivalent is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个提醒，`fun getRepeats() = async { ... }` 中并没有什么魔法。它的更长等效形式是：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can call our code to get the same results as before:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用我们的代码来得到与之前相同的结果：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But we can improve it further by using our old friend, data class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以通过使用我们的老朋友，数据类，来进一步改进它。
- en: Data class as Barrier
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类作为屏障
- en: 'Now our data class is the Barrier:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据类是屏障：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The additional benefit of data classes as Barriers is the ability to destructure
    them easily:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类作为屏障的额外好处是能够轻松地解构它们：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This works well if the type of data we receive from different asynchronous tasks
    is widely different. In this example, we receive both `String` and `Int`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从不同的异步任务中接收到的数据类型差异很大，这会工作得很好。在这个例子中，我们接收到了 `String` 和 `Int`。
- en: In some cases, we receive the same types of data from different sources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们从不同的来源接收相同类型的数据。
- en: 'For example, let''s ask Michael (our canary product owner), Jake (our barista),
    and me who our favorite movie character is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们问问迈克尔（我们的金丝雀产品负责人），杰克（我们的咖啡师），以及我，我们最喜欢的电影角色是谁：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In that case, we can use a list to gather the results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以使用列表来收集结果：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scheduler
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scheduler
- en: This is another concept we discussed briefly in [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7),
    *Threads and Coroutines*, in the *Starting a coroutine* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 *启动协程* 部分简要讨论过的另一个概念，在 *第8章* 中，*线程和协程*。
- en: Remember how our `launch()` or `async()` could receive `CommonPool`?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的 `launch()` 或 `async()` 可以接收 `CommonPool` 吗？
- en: 'Here''s an example to remind you that you could specify it explicitly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来提醒你，你可以明确指定它：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This `CommonPool` is a Scheduler design pattern in a bad disguise. Many async
    tasks may be mapped to the same Scheduler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `CommonPool` 是一个伪装成调度器的调度器设计模式。许多异步任务可能被映射到同一个调度器。
- en: 'Run the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What is interesting is the fact that the same coroutine is picked up by different
    threads:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，同一个协程被不同的线程选中：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also specify the context as `Unconfined`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定上下文为 `Unconfined`：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will run the coroutine on the main thread. It prints:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在主线程上运行协程。它打印：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also inherit context from your parent coroutine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从你的父协程继承上下文：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note though, that running in the same context doesn't mean that we run on the
    same thread.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，但运行在同一个上下文中并不意味着我们在同一个线程上运行。
- en: 'You may ask yourself: what''s the difference between inheriting the context
    and using `Unconfined`? We''ll discuss this in detail in the next section.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：继承上下文和使用 `Unconfined` 之间有什么区别？我们将在下一节详细讨论这个问题。
- en: Understanding contexts
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解上下文
- en: 'To understand different contexts, let''s look at the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解不同的上下文，让我们看看下面的代码：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of `yield()`, we're using the `delay()` function, which also suspends
    the current coroutine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用 `yield()`，而是使用 `delay()` 函数，它也会挂起当前的协程。
- en: 'But the output compared to `yield()` is different:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但与 `yield()` 相比，输出是不同的：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After calling `delay()` for the first time, the coroutine has switched context,
    and as a result, threads.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用 `delay()` 之后，协程已经切换了上下文，从而导致了线程的切换。
- en: For that reason, using `Unconfined` is not recommended for CPU-intensive tasks
    or tasks that need to run on a particular thread, such as UI rendering.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不建议对于CPU密集型任务或需要在特定线程上运行的任务（如UI渲染）使用`Unconfined`。
- en: 'You can also create your own thread pool for coroutines to run on:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为协程创建自己的线程池来运行：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It prints:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you create your own thread pool, make sure that you either release it with
    `close()` or reuse it, since creating a new thread pool and holding to it is expensive
    in terms of resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了自己的线程池，请确保你使用`close()`释放它或重用它，因为创建新的线程池并持有它从资源角度来看是昂贵的。
- en: Pipelines
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: In our `StoryLand`, the same lazy architect, me, is struggling with a problem.
    Back in [Chapter 4](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7), *Getting
    Familiar with Behavioral Patterns*, we wrote an HTML page parser. But it depends
    on whether somebody already fetched the pages to parse for us. It is also not
    very flexible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`StoryLand`中，同样的懒散建筑师，也就是我，正在努力解决一个问题。回到[第4章](part0112.html#3APV00-6704093aa34748cfa77c54bdc1a20dc7)，*熟悉行为模式*，我们编写了一个HTML页面解析器。但它取决于是否有人已经为我们抓取了要解析的页面。它也不够灵活。
- en: What we would like is for one coroutine to produce an infinite stream of news,
    and for others to parse that stream in steps.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个协程产生无限的新闻流，而其他协程则逐步解析这个流。
- en: 'To start working with DOM, we''ll need a library, such as `kotlinx.dom`*. *If
    you''re using **Gradle**, make sure you add the following lines to your `build.gradle`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用DOM，我们需要一个库，例如`kotlinx.dom`。如果你使用**Gradle**，请确保将以下行添加到你的`build.gradle`文件中：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, to the task at hand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们着手处理当前的任务。
- en: 'First, we would like to fetch news pages once in a while. For that, we''ll
    have a producer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望偶尔抓取新闻页面。为此，我们将有一个生产者：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use `shuffled()` here so the order of the list elements won't be the same
    all the time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`shuffled()`，这样列表元素的顺序就不会总是相同。
- en: The `isActive` flag will be true as long as the coroutine is running and hasn't
    been canceled. It is good practice to check this property in loops that may run
    for a long time, so they could be stopped between iterations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只要协程正在运行且未被取消，`isActive`标志将为真。在可能运行很长时间的循环中检查此属性是一种良好的做法，这样它们就可以在迭代之间停止。
- en: Each time we receive new titles, we send them downstream.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们收到新的标题时，我们就将它们发送到下游。
- en: Since tech news isn't updated very often. We can check for updates only once
    in a while, using `delay()`. In the actual code, the delay would probably be minutes,
    if not hours.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于科技新闻更新并不频繁。我们可以偶尔使用`delay()`检查更新。在实际代码中，延迟可能是几分钟，甚至几小时。
- en: 'The next step is creating **Document Object Model** (**DOM**) out of those
    raw strings containing HTML. For that we''ll have a second producer, this one
    receiving a channel that connects it to the first one:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建包含HTML的原始字符串的**文档对象模型**（**DOM**）。为此，我们将有一个第二个生产者，这个生产者接收一个连接到第一个生产者的通道：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can use the `for` loop to iterate over the channel as long as more data is
    coming. This is a very elegant way of consuming data from a channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环遍历通道，直到有更多数据到来。这是从通道中消费数据的一种非常优雅的方式。
- en: 'In this producer, we finally make use of the DOM parser we imported a while
    ago. We also introduced an extension function on `String` for our convenience:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生产者中，我们最终使用了我们之前导入的DOM解析器。我们还引入了一个方便的`String`扩展函数：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'That''s because `parseXml()` expects `InputSource` as its input. Basically,
    this is an **Adapter** design pattern in action:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`parseXml()`期望`InputSource`作为其输入。基本上，这是一个**适配器**设计模式的应用：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're looking for the headers, hence `getElementsByTagName("H1")`. For each
    header found, and there may be more than one, we get its text with `textContent`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找标题，因此使用`getElementsByTagName("H1")`。对于找到的每个标题，可能有多个，我们使用`textContent`获取其文本。
- en: Finally, we're sending each header from each page to the next in line.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将每个页面的每个标题发送到下一个。
- en: Establishing a pipeline
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立管道
- en: 'Now, to establish our pipeline:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了建立我们的管道：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下内容：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A pipeline is a great way to break a long process into smaller steps. Note that
    each producing coroutine is a pure function, so it's also easy to test and reason
    about.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是将长过程分解成更小步骤的绝佳方式。请注意，每个生产协程都是一个纯函数，因此它也很容易测试和推理。
- en: The entire pipeline could be stopped by calling `cancel()` on the first coroutine
    in line.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个管道可以通过在第一个协程上调用`cancel()`来停止。
- en: 'We can achieve an even nicer API by using the extension functions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用扩展函数来实现更友好的API：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we can call our code like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样调用我们的代码：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Kotlin really excels at creating expressive and fluent APIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin在创建表达性和流畅的API方面真的很出色。
- en: The fan-out design pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扇出设计模式
- en: What if the amount of work at different steps in our pipeline is very different?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们管道中不同步骤的工作量差异很大怎么办？
- en: For example, it takes a lot more time to fetch the HTML than to parse it. Or
    what if we don't have a pipeline at all, just a lot of tasks we would like to
    distribute between coroutines.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，获取HTML比解析它花费的时间要多得多。或者如果我们根本没有任何管道，只是有很多任务我们希望在协程之间分配。
- en: That's where the fan-out design pattern kicks in. The number of coroutines may
    read from the same channel, distributing the work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是扇出设计模式发挥作用的地方。协程的数量可以从同一个通道读取，分配工作。
- en: 'We can have one coroutine produce some results:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个协程产生一些结果：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And have a function that would create a coroutine that reads those results:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 并有一个函数可以创建一个读取这些结果的协程：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This allows us to generate an arbitrary number of consumers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够生成任意数量的消费者：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The fan-out design pattern allows us to efficiently distribute the work across
    a number of coroutines, threads, and CPUs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 扇出设计模式允许我们高效地将工作分配给多个协程、线程和CPU。
- en: The fan-in design pattern
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扇入设计模式
- en: It would be great if our coroutines could always make decisions by themselves. But
    what if they need to return some results from the computation to another coroutine?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的协程总是可以自己做出决定，那会很好。但它们如果需要将计算结果返回给另一个协程怎么办？
- en: The opposite of **fan-out** is the **fan-in** design pattern. Instead of multiple
    coroutines reading from the same channel, multiple coroutines can write their
    results to the same channel.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与**扇出**相反的是**扇入**设计模式。不是多个协程从同一个通道读取，而是多个协程可以将他们的结果写入同一个通道。
- en: 'Imagine that you''re reading news from two prominent tech resources: `techBunch`
    and `theFerge`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在从两个显赫的科技资源中阅读新闻：`techBunch`和`theFerge`。
- en: 'Each resource produces the values at its own pace, and sends them over a channel:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源以自己的速度产生值，并将它们通过通道发送：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By providing them with the same channel, we can combine their results:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供相同的通道，我们可以合并他们的结果：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Combining the fan-out and fan-in design patterns is a good base for **Map**/**Reduce**
    algorithms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结合扇出和扇入设计模式是**Map**/**Reduce**算法的良好基础。
- en: To demonstrate that, we'll generate 10,000,000 random numbers and compute the
    maximum number among them by dividing this task multiple times.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们将生成10,000,000个随机数，并通过多次分割这个任务来计算它们中的最大数。
- en: 'First, to generate the list of 10,000,000 random integers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成10,000,000个随机整数的列表：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Managing workers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工人
- en: 'Now we''ll have two types of workers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将有两种类型的工人：
- en: 'The divide worker will receive the list of numbers, determine the biggest number
    in the list, and send it over to the output channel:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割工人将接收到数字列表，确定列表中的最大数，并将其发送到输出通道：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The collector will listen to this channel and each time a new sub-max number
    arrives, will decide whether it''s the all-time biggest:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集器将监听这个通道，并且每次有新的子最大数到达时，将决定它是否是史上最大的：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we only need to establish those channels:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要建立那些通道：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that in this case, we don't gain performance benefits, and naive `numbers.max()`
    would produce better results. But the more data you need to collect, the more
    useful this pattern becomes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，我们不会获得性能上的好处，而简单的`numbers.max()`会产生更好的结果。但随着需要收集的数据量增加，这种模式变得更加有用。
- en: Buffered channels
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: Up until now, all the channels that we used had a capacity of exactly one element.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有通道的容量都是正好一个元素。
- en: 'This means that if you write to this channel but no one reads from it, the
    sender will be suspended:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你向这个通道写入，但没有人在读取，发送者将被挂起：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code doesn't print anything because the coroutine is waiting for someone
    to read from the channel.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有打印任何东西，因为协程正在等待有人从通道读取。
- en: 'To avoid that, we can create a buffered channel:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以创建一个缓冲通道：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now suspension will occur only when the channel capacity is reached.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有在通道容量达到时才会发生挂起。
- en: 'It prints:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since `produce()` and `actor()` are also backed up by a channel, we can make
    it buffered too:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`produce()`和`actor()`也由通道支持，我们也可以将其设置为缓冲：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Unbiased select
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无偏选择
- en: One of the most useful ways to work with channels is the `select {}` clause
    we saw in [Chapter 8](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7), *Threads
    and Coroutines*, in the *Producers* section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与通道一起工作的最有用的一种方式是我们之前在[第8章](part0196.html#5QTE80-6704093aa34748cfa77c54bdc1a20dc7)“*生产者*”部分中看到的`select
    {}`子句，*线程和协程*。
- en: But select is inherently biased. If two events happen at the same time, it will
    select the first clause.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但选择是固有的有偏见的。如果两个事件同时发生，它将选择第一个子句。
- en: 'In the following example, we''ll have a producer that sends five values with
    a very short delay:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将有一个生产者，它以很短的延迟发送五个值：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll create three such producers and see the results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个这样的生产者并查看结果：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We run this code five times. Here are some of the results:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了五次这个代码。以下是一些结果：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, `A` almost always wins, while `C` is always third. The more
    `repeats` you set, the larger the bias gets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`A`几乎总是赢，而`C`总是第三。你设置的`repeats`越多，偏差就越大。
- en: 'Now let''s use `selectUnbiased` instead:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`selectUnbiased`代替：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The results of the first five executions may look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前五次执行的结果可能看起来像这样：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not only are the numbers distributed more evenly now, but all clauses have an
    equal chance of being selected.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数字分布得更均匀了，而且所有子句都有相同的机会被选中。
- en: Mutexes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: Also known as mutual exclusions, mutexes provide a means to protect a shared
    state.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为互斥排他，互斥锁提供了一种保护共享状态的手段。
- en: 'Let''s start with same, old, dreaded counter example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从那个陈旧、令人讨厌的反例开始：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you've probably guessed, this prints anything but the result of `10*100`.
    Totally embarrassing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这会打印出除了`10*100`的结果之外的所有内容。真是尴尬至极。
- en: 'To solve that, we introduce a mutex:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们引入了一个互斥锁：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now our example always prints the correct number.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的例子总是打印出正确的数字。
- en: This is good for simple cases. But what if the code within the critical section
    (that is, between `lock()` and `unlock()`) throws an exception?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这对简单情况很有用。但如果关键部分（即`lock()`和`unlock()`之间）的代码抛出异常怎么办？
- en: 'Then we''ll have to wrap everything in `try...catch`, which is not very convenient:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将所有内容包裹在`try...catch`中，这并不方便：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Exactly for that purpose, Kotlin also introduces `withLock()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正是为了这个目的，Kotlin还引入了`withLock()`：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Selecting on close
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择在关闭时
- en: Reading from a channel using `select()` is nice until it gets closed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`select()`从通道中读取直到它关闭是件好事。
- en: 'You can see an example of that problem here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到那个问题的例子：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Although the numbers add up, we may often receive `ClosedReceiveChannelException`
    running this code. That's because the second producer has fewer items, and as
    soon as it finishes, it will close its channel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数字相加，但我们运行此代码时可能会经常收到`ClosedReceiveChannelException`。这是因为第二个生产者有更少的物品，一旦它完成，它将关闭其通道。
- en: To avoid that, we can use `onReceiveOrNull`, which will return a nullable version
    at the same time. Once the channel gets closed, we'll receive `null` in our `select`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以使用`onReceiveOrNull`，它将同时返回一个可空版本。一旦通道关闭，我们在`select`中就会收到`null`。
- en: 'We can handle this null value in any way we want, for example, by making use
    of the `elvis` operator:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按任何我们想要的方式处理这个空值，例如，通过使用`elvis`运算符：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using that knowledge, we can drain both channels by skipping the null results:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些知识，我们可以通过跳过空结果来排空两个通道：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Sidekick channel
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助通道
- en: Up until now, we've only discussed the usages of `select` as a receiver. But
    we can also use `select` to send items to another channel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了`select`作为接收者的用法。但我们也可以使用`select`将项目发送到另一个通道。
- en: 'Let''s look at the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下例子：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We have a superhero and their sidekick as two actors. Since the superhero is
    more experienced, it usually takes them less time to beat the villain they're
    facing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个超级英雄及其助手作为两个演员。由于超级英雄更有经验，他们通常花费更少的时间来击败他们面对的恶棍。
- en: But in some cases, they still have their hands full, so a sidekick needs to
    step in.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，它们仍然手头很忙，所以需要一个助手来帮忙。
- en: 'We''ll throw five villains at the pair with a few delays, and see how they
    fare:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这对组合投掷五个恶棍，并观察它们的反应，同时加入一些延迟：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It prints:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that the type parameter for this select refers to what is returned from
    the block, and not what is being sent to the channels.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个选择的类型参数指的是从块中返回的内容，而不是发送到通道的内容。
- en: That's the reason we use `Pair<String, String>` here.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在这里使用`Pair<String, String>`的原因。
- en: Deferred channel
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟通道
- en: The more you work with coroutines, the more you'll get used to await results.
    At some point, you'll start sending deferred values over channels.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你与协程工作得越多，就越习惯于等待结果。在某个时刻，你将开始在通道中发送延迟值。
- en: 'We''ll start by creating 10 async tasks. The first will delay for a long time,
    and others we delay for a short time:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建10个异步任务。第一个将延迟很长时间，其余的我们将延迟很短的时间：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We'll put all those results into a buffered channel.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些结果放入一个缓冲通道中。
- en: 'Now we can read from this channel, and be using a second `select` block, and
    await the results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从这个通道读取，并使用第二个`select`块，等待结果：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note that the resulting time is of the slowest task:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果时间是最慢的任务的时间：
- en: '[PRE67]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can also use `onAwait()` as a stop signal for another channel.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`onAwait()`作为另一个通道的停止信号。
- en: 'For that, we''ll create an async task that will complete in 600 ms:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个将在600毫秒内完成的异步任务：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And, as in the previous example, we''ll send 10 deferred values over the buffered
    channel:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，就像上一个例子一样，我们将通过缓冲通道发送10个延迟值：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then we''ll wait for either a new value or a notification that the channel
    should be closed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将等待新的值或通知通道应该关闭：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This prints only six values out of ten, as expected, stopping after 600 ms have
    passed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这仅打印了十个值中的六个，在600毫秒后停止。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered various design patterns related to concurrency in
    Kotlin. Most of them are based on coroutines, channels, deferred values, or a
    combination.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与Kotlin中并发相关的各种设计模式。其中大多数都是基于协程、通道、延迟值或它们的组合。
- en: '**Pipeline**, **fan-in**, and **fan-out** help distribute work and collect
    the results. **Deferred values** are used as placeholders for something that would
    resolve at a later time. **Schedulers** help us manage resources, mainly threads
    that back up the coroutines. **Mutexes** and **Barriers** help control that concurrency.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**、**扇入**和**扇出**有助于分配工作和收集结果。**延迟值**用作稍后解决某事的占位符。**调度器**帮助我们管理资源，主要是支持协程的线程。**互斥锁**和**屏障**有助于控制并发。'
- en: Now you should understand the `select` block and how it can be combined with
    channels and deferred values efficiently.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该理解了`select`块以及它如何有效地与通道和延迟值结合使用。
- en: In the next chapter, we'll discuss Kotlin's idioms, best practices, and some
    of the anti-patterns that emerged with the language.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Kotlin的惯用用法、最佳实践以及随着语言出现的某些反模式。
