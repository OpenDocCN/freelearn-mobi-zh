<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer051">
			<h1 id="_idParaDest-106"><a id="_idTextAnchor135"/>Chapter 8: Working with Animations</h1>
			<p>In the previous chapters, I introduced you to many technical aspects of Jetpack Compose and showed you how to write well-behaving and good-looking apps. Now, adding animations and transitions will make your apps really shine! Compose simplifies the process of adding animation effects greatly over the old View-based approach.</p>
			<p>In this chapter, you will learn important animation-related application programming interfaces, see animations of single and multiple properties, as well as transitions between composables in action, and master the relationship between state changes and visual interactions.</p>
			<p>The main sections of this chapter are as follows:</p>
			<ul>
				<li>Using animation to visualize state changes</li>
				<li>Showing and hiding UI elements with animations</li>
				<li>Spicing up transitions through visual effects</li>
			</ul>
			<p>We start by using animations to visualize state changes. Think of a simple use case: clicking a button might change the color of a UI object. But, just switching between colors feels somewhat abrupt, whereas a gradual change is much more visually pleasing. Also, if you want to change several values during the animation, Jetpack Compose can do that easily, too. I'll introduce you to the <strong class="source-inline">updateTransition()</strong> composable, which is used in such scenarios.</p>
			<p>The <em class="italic">Showing and hiding UI elements with animations</em> section introduces you to the <strong class="source-inline">AnimatedVisibility()</strong> composable function. It allows you to apply enter and exit transitions, which will be played back while the content appears or disappears. We will also animate size changes and learn about the corresponding <strong class="source-inline">animateContentSize()</strong> modifier.</p>
			<p>In the <em class="italic">Spicing up transitions through visual effects</em> section, we will be using the <strong class="source-inline">Crossfade()</strong> composable to switch between two layouts with a crossfade animation. Furthermore, you will learn about <strong class="source-inline">AnimationSpec</strong>. This interface represents the specification of an animation. A take on infinite animations concludes the section.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>This chapter is based on the <strong class="source-inline">AnimationDemo</strong> sample. Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08</a>.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor137"/>Using animation to visualize state changes</h1>
			<p>State is app data<a id="_idIndexMarker290"/> that may change <a id="_idIndexMarker291"/>over time. In a Compose app, state (for example, a color) is represented through <strong class="source-inline">State</strong> or <strong class="source-inline">MutableState</strong> instances. State changes trigger recompositions. The following example shows a button and a box. Clicking the button toggles the color of the box between red and white by changing state:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun StateChangeDemo() {</p>
			<p class="source-code">  var <strong class="bold">toggled</strong> by remember {</p>
			<p class="source-code">    mutableStateOf(false)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  val <strong class="bold">color</strong> = if (toggled)</p>
			<p class="source-code">    Color.White</p>
			<p class="source-code">  else</p>
			<p class="source-code">    Color.Red</p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp),</p>
			<p class="source-code">    horizontalAlignment = Alignment.CenterHorizontally</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Button(onClick = {</p>
			<p class="source-code">      <strong class="bold">toggled = !toggled</strong></p>
			<p class="source-code">    }) {</p>
			<p class="source-code">      Text(</p>
			<p class="source-code">        stringResource(R.string.toggle)</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .padding(top = 32.dp)</p>
			<p class="source-code">        .<strong class="bold">background(color = color)</strong></p>
			<p class="source-code">        .size(128.dp)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In this <a id="_idIndexMarker292"/>example, <strong class="source-inline">color</strong> is a simple<a id="_idIndexMarker293"/> immutable variable. It is set each time <strong class="source-inline">toggled</strong> (a mutable <strong class="source-inline">Boolean</strong> state) changes (this happens inside <strong class="source-inline">onClick</strong>). As <strong class="source-inline">color</strong> is used with a modifier applied to <strong class="source-inline">Box()</strong> (<strong class="source-inline">background(color = color)</strong>), clicking the button changes the box color. </p>
			<p>If you try the code, the switch feels very sudden and abrupt. This is because white and red are not very similar. Using an animation will make the change much more pleasant. Let's see how this works.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor138"/>Animating single value changes</h2>
			<p>To <a id="_idIndexMarker294"/>animate a color, you can use the built-in <strong class="source-inline">animateColorAsState()</strong> composable. Replace the <strong class="source-inline">val color  = if (toggled) …</strong> assignment inside <strong class="source-inline">StateDemo()</strong> with the following code block. If you want to try it out, you can find a composable function called <strong class="source-inline">SingleValueAnimationDemo()</strong> in <strong class="source-inline">AnimationDemoActivity.kt</strong>, which belongs to the <strong class="source-inline">AnimationDemo</strong> sample:</p>
			<p class="source-code">val color by animateColorAsState(</p>
			<p class="source-code">  targetValue = if (toggled)</p>
			<p class="source-code">    Color.White</p>
			<p class="source-code">  else</p>
			<p class="source-code">    Color.Red</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">animateColorAsState()</strong> returns a <strong class="source-inline">State&lt;Color&gt;</strong> instance. Whenever <strong class="source-inline">targetValue</strong> changes, the animation will run automatically. If the change occurs while the animation is in progress, the ongoing animation will adjust to match the new target value.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Using the <strong class="source-inline">by</strong> keyword, you can access the color state like ordinary variables.</p>
			<p>You can provide an optional listener to get notified when the animation is finished. The following line of code prints the color that matches the new state:</p>
			<p class="source-code">finishedListener = { color -&gt; println(color)}</p>
			<p>To customize your animation, you can pass an instance of <strong class="source-inline">AnimationSpec&lt;Color&gt;</strong> to <strong class="source-inline">animateColorAsState()</strong>. The default value is <strong class="source-inline">colorDefaultSpring</strong>, a private value in <strong class="source-inline">SingleValueAnimation.kt</strong>:</p>
			<p class="source-code">private val colorDefaultSpring = spring&lt;Color&gt;()</p>
			<p><strong class="source-inline">spring()</strong> is a top-level function in <strong class="source-inline">AnimationSpec.kt</strong>. It receives a damping ratio, a stiffness, and a visibility threshold. The following line of code makes the color animation very soft:</p>
			<p class="source-code">animationSpec = spring(stiffness = Spring.StiffnessVeryLow)</p>
			<p><strong class="source-inline">spring()</strong> returns <strong class="source-inline">SpringSpec</strong>. This class implements the <strong class="source-inline">FiniteAnimationSpec</strong> interface, which in turn extends <strong class="source-inline">AnimationSpec</strong>. This interface defines the specification of an animation, which includes the data type to be animated and the <a id="_idIndexMarker295"/>animation configuration, in this case, a spring metaphor. There are others. We will be returning to this interface in the <em class="italic">Spicing up transitions through visual effects</em> section. Next, we look at animating multiple value changes.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor139"/>Animating multiple value changes</h2>
			<p>In this <a id="_idIndexMarker296"/>section, I will show you how to animate several values at once upon a state change. The setup is similar to <strong class="source-inline">StateDemo()</strong> and <strong class="source-inline">SingleValueAnimationDemo()</strong>: a <strong class="source-inline">Column()</strong> instance contains a <strong class="source-inline">Button()</strong> instance and a <strong class="source-inline">Box()</strong> instance. But this time, the content of the box is <strong class="source-inline">Text()</strong>. The button toggles a state, which starts the animation. </p>
			<p>The following version of <strong class="source-inline">MultipleValuesAnimationDemo()</strong> does not yet contain an animation. It will be inserted below the comment reading <strong class="bold">FIXME: animation setup missing</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun MultipleValuesAnimationDemo() {</p>
			<p class="source-code">  var toggled by remember {</p>
			<p class="source-code">    mutableStateOf(false)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">// FIXME: animation setup missing</strong></p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp),</p>
			<p class="source-code">    horizontalAlignment = Alignment.CenterHorizontally</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Button(onClick = {</p>
			<p class="source-code">      toggled = !toggled</p>
			<p class="source-code">    }) {</p>
			<p class="source-code">      Text(</p>
			<p class="source-code">        stringResource(R.string.toggle)</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      contentAlignment = Alignment.Center,</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .padding(top = 32.dp)</p>
			<p class="source-code"><strong class="bold">        .border(</strong></p>
			<p class="source-code"><strong class="bold">          width = borderWidth,</strong></p>
			<p class="source-code"><strong class="bold">          color = Color.Black</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code">        .size(128.dp)</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      Text(</p>
			<p class="source-code">        text = stringResource(id = R.string.app_name),</p>
			<p class="source-code">        modifier = <strong class="bold">Modifier.rotate(degrees = degrees)</strong></p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Box()</strong> shows a black border, whose width is controlled by <strong class="source-inline">borderWidth</strong>. To apply borders to your composable functions, just add the <strong class="source-inline">border()</strong> modifier. <strong class="source-inline">Text()</strong> is rotated. You can achieve this with the <strong class="source-inline">rotate()</strong> modifier. The <strong class="source-inline">degrees</strong> variable holds <a id="_idIndexMarker297"/>the angle. <strong class="source-inline">degrees</strong> and <strong class="source-inline">borderWidth</strong> will change during the animation. Here's how this is done:</p>
			<p class="source-code">val transition = updateTransition(targetState = toggled)</p>
			<p class="source-code">val borderWidth by transition.animateDp() { state -&gt;</p>
			<p class="source-code">  if (state)</p>
			<p class="source-code">    10.dp</p>
			<p class="source-code">  else</p>
			<p class="source-code">    1.dp</p>
			<p class="source-code">}</p>
			<p class="source-code">val degrees by transition.animateFloat() { state -&gt;</p>
			<p class="source-code">  if (state) -90F</p>
			<p class="source-code">  else</p>
			<p class="source-code">    0F</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">updateTransition()</strong> composable function configures and returns a <strong class="source-inline">Transition</strong>. When <strong class="source-inline">targetState</strong> changes, the transition will run all of its child animations toward their target values. Child animations are added using <strong class="source-inline">animate…()</strong> functions. They are not part of a <strong class="source-inline">Transition</strong> instance but are extension functions. <strong class="source-inline">animateDp()</strong> adds an animation based on density-independent pixels.</p>
			<p>In my example, it controls the border width. <strong class="source-inline">animateFloat()</strong> creates a <strong class="source-inline">Float</strong> animation. This function is ideal for changing the rotation of <strong class="source-inline">Text()</strong>, which is a <strong class="source-inline">Float</strong> value. There are more <strong class="source-inline">animate…()</strong> functions, which operate on other data types. For example, <strong class="source-inline">animateInt()</strong> works with <strong class="source-inline">Int</strong> values. <strong class="source-inline">animateOffset()</strong> animates an <strong class="source-inline">Offset</strong> instance. You can find them in the <strong class="source-inline">Transition.kt</strong> file, which belongs to the <strong class="source-inline">androidx.compose.animation.core</strong> package.</p>
			<p><strong class="source-inline">Transition</strong> instances provide several properties reflecting the status of a transition. For example, <strong class="source-inline">isRunning</strong> indicates whether any animation in the transition is currently running. <strong class="source-inline">segment</strong> contains the initial state and the target state of the currently ongoing transition. The current state of the transition is available through <strong class="source-inline">currentState</strong>. This <a id="_idIndexMarker298"/>will be the initial state until the transition is finished. Then, <strong class="source-inline">currentState</strong> is set to the target state.</p>
			<p>As you have seen, it is very easy to use state changes to trigger animations. So far, these animations have modified the visual appearance of one or more composable functions. In the next section, I will show you how to apply animations while showing or hiding UI elements.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor140"/>Showing and hiding UI elements with animations</h1>
			<p>Often, your <a id="_idIndexMarker299"/>UI will contain information that need not be visible all the time. For example, in an address book you may want to show only key attributes of a contact, and present detailed information upon request, typically after a button click. However, just showing and hiding the additional data feels sudden and abrupt. Using animations leads to a more pleasant experience, so let's look into this more.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor141"/>Understanding AnimatedVisibility()</h2>
			<p>In this section, we<a id="_idIndexMarker300"/> will look at my sample composable <strong class="source-inline">AnimatedVisibilityDemo()</strong>. It belongs to the <strong class="source-inline">AnimationDemo</strong> project. Like <strong class="source-inline">StateDemo()</strong>, <strong class="source-inline">SingleValueAnimationDemo()</strong>, and <strong class="source-inline">MultipleValuesAnimationDemo()</strong>, it uses a <strong class="source-inline">Column()</strong> instance, which contains a <strong class="source-inline">Button()</strong> instance and a <strong class="source-inline">Box()</strong> instance. This part of the code is simple and straightforward, so there is no need to repeat it in print. The button toggles a state, which starts the animation. Let's see how this works:</p>
			<p class="source-code">AnimatedVisibility(</p>
			<p class="source-code">  visible = visible,</p>
			<p class="source-code">  enter = slideInHorizontally(),</p>
			<p class="source-code">  exit = slideOutVertically()</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .padding(top = 32.dp)</p>
			<p class="source-code">      .background(color = Color.Red)</p>
			<p class="source-code">      .size(128.dp)</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The box is <a id="_idIndexMarker301"/>wrapped in <strong class="source-inline">AnimatedVisibility()</strong>. This built-in composable function animates the appearance and disappearance of its content, when the <strong class="source-inline">visible</strong> parameter changes. You can specify different <strong class="source-inline">EnterTransition</strong> and <strong class="source-inline">ExitTransition</strong> instances. In my example, the box enters by sliding in horizontally and exits by sliding out vertically.</p>
			<p>Currently, there are three transition types:</p>
			<ul>
				<li>Fade</li>
				<li>Expand and shrink</li>
				<li>Slide</li>
			</ul>
			<p>They can be combined using <strong class="source-inline">+</strong>: </p>
			<p class="source-code">enter = slideInHorizontally() + fadeIn(),</p>
			<p>The combination order doesn't matter as the animations start simultaneously.</p>
			<p>If you do not pass a value for <strong class="source-inline">enter</strong>, the content will default to fading in while expanding vertically. Omitting <strong class="source-inline">exit</strong> will cause the content to fade out while shrinking vertically.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">At the time of writing, <strong class="source-inline">AnimatedVisibility()</strong> is experimental. To use it in your app, you must add the <strong class="source-inline">@ExperimentalAnimationApi</strong> annotation. This will change with Jetpack Compose 1.1.</p>
			<p>In this section, I showed you <a id="_idIndexMarker302"/>how to animate the appearance and disappearance of content. A variation of this subject is to visualize size changes (if either <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, or both are <strong class="source-inline">0</strong>, the UI element is no longer visible). Let's find out how to do this in the following section.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor142"/>Animating size changes</h2>
			<p>Sometimes<a id="_idIndexMarker303"/> you may want to change the amount of space a UI element requires onscreen. Think of text fields. In compact mode, your app could show only three lines, whereas in detail mode it might display 10 lines or more. My <strong class="source-inline">SizeChangeAnimationDemo()</strong> sample composable (<em class="italic">Figure 8.1</em>) uses a slider to control the <strong class="source-inline">maxLines</strong> value of <strong class="source-inline">Text()</strong>:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/B17505_08_1.jpg" alt="Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()&#13;&#10;" width="1378" height="476"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()</p>
			<p>The general setup follows the examples from the previous sections: a <strong class="source-inline">Column()</strong> instance acts as a container for some composable functions, in this case a <strong class="source-inline">Slider()</strong> instance and a <strong class="source-inline">Text()</strong> instance. Then a state change triggers the animation. Here is the code:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun SizeChangeAnimationDemo() {</p>
			<p class="source-code">  var size by remember { mutableStateOf(1F) }</p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(16.dp)</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Slider(</p>
			<p class="source-code">      value = size,</p>
			<p class="source-code">      valueRange = (1F..4F),</p>
			<p class="source-code">      steps = 3,</p>
			<p class="source-code">      onValueChange = {</p>
			<p class="source-code">        size = it</p>
			<p class="source-code">      },</p>
			<p class="source-code">      modifier = Modifier.padding(bottom = 8.dp)</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = stringResource(id = R.string.lines),</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .fillMaxWidth()</p>
			<p class="source-code">        .background(Color.White)</p>
			<p class="source-code">        .<strong class="bold">animateContentSize()</strong>,</p>
			<p class="source-code">      maxLines = size.toInt(),</p>
			<p class="source-code">      color = Color.Blue</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">size</strong> is a mutable <strong class="source-inline">Float</strong> state. It is passed to <strong class="source-inline">Slider()</strong> as its default value. When the slider is moved, <strong class="source-inline">onValueChange {}</strong> is invoked. The lambda expression receives the new<a id="_idIndexMarker304"/> value, which is assigned to <strong class="source-inline">size</strong>. The <strong class="source-inline">Text()</strong> composable uses the state as a value for <strong class="source-inline">maxLines</strong>.</p>
			<p>The animation is handled by the <strong class="source-inline">animateContentSize()</strong> modifier. It belongs to the <strong class="source-inline">androidx.compose.animation</strong> package. The modifier expects two parameters, <strong class="source-inline">animationSpec</strong> and <strong class="source-inline">finishedListener</strong>. I introduced both briefly in the <em class="italic">Animating single value changes</em> section. <strong class="source-inline">animationSpec</strong> defaults to <strong class="source-inline">spring()</strong>. If you want the lines to appear all at once after some delay, you can add the following:</p>
			<p class="source-code">animationSpec = snap(1000)</p>
			<p>A snap animation immediately switches the animating value to the end value. You pass the number of milliseconds to wait before the animation runs. It defaults to <strong class="source-inline">0</strong>. Now, <strong class="source-inline">snap()</strong> returns an instance of <strong class="source-inline">SnapSpec</strong>, an implementation of <strong class="source-inline">AnimationSpec</strong>. We will turn to this interface in the <em class="italic">Spicing up transitions through visual effects</em> section.</p>
			<p>The default value of <strong class="source-inline">finishedListener</strong> is <strong class="source-inline">null</strong>. You can provide an implementation, if your app wants to get notified when the size change animation is finished. Both the initial value and the final size are passed to the listener. If the animation is interrupted, the initial value will be the size at the point of interruption. This helps determine the direction of the size change.</p>
			<p>This concludes our look at showing and hiding UI elements with animations. In the next section, we focus on exchanging parts of the UI. For example, we will be using <strong class="source-inline">Crossfade()</strong> to switch between two composable functions with a crossfade animation.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor143"/>Spicing up transitions through visual effects</h1>
			<p>So far, I have <a id="_idIndexMarker305"/>shown you animations that modify certain aspects of a UI element, like its color, size, or visibility. But sometimes you may want to <em class="italic">exchange</em> parts of your UI. Then, <strong class="source-inline">Crossfade()</strong> comes in handy. It allows you to switch between two composable functions with a crossfade animation. Let's look at my <strong class="source-inline">CrossfadeAnimationDemo()</strong> sample (<em class="italic">Figure 8.2</em>), part of the <strong class="source-inline">AnimationDemo</strong> project, to see how <a id="_idTextAnchor144"/>this works:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/B17505_08_2.jpg" alt="Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()&#13;&#10;" width="1058" height="596"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()</p>
			<p>A switch toggles between two screens. As we are focusing on animation, I kept the <strong class="source-inline">Screen()</strong>composable very simple, just a box with customizable background color, and a big text centered inside. You can find its source code in <strong class="source-inline">AnimationDemoActivity.kt</strong>.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor145"/>Crossfading composable functions</h2>
			<p>Like most examples<a id="_idIndexMarker306"/> in this chapter, <strong class="source-inline">CrossfadeAnimationDemo()</strong> uses a <strong class="source-inline">Column()</strong> as the root element. The column contains a switch, and the <a id="_idIndexMarker307"/>screen to display. Which one is shown depends on a mutable <strong class="source-inline">Boolean</strong> state:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun CrossfadeAnimationDemo() {</p>
			<p class="source-code">  var isFirstScreen by remember { mutableStateOf(true) }</p>
			<p class="source-code">  Column(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize(),</p>
			<p class="source-code">    horizontalAlignment = Alignment.CenterHorizontally</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Switch(</p>
			<p class="source-code">      checked = isFirstScreen,</p>
			<p class="source-code">      onCheckedChange = {</p>
			<p class="source-code">        isFirstScreen = !isFirstScreen</p>
			<p class="source-code">      },</p>
			<p class="source-code">      modifier = Modifier.padding(top = 16.dp,</p>
			<p class="source-code">                                  bottom = 16.dp)</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Crossfade(targetState = isFirstScreen) { it -&gt;</p>
			<p class="source-code">      if (it) {</p>
			<p class="source-code">        Screen(</p>
			<p class="source-code">          text = stringResource(id = R.string.letter_w),</p>
			<p class="source-code">          backgroundColor = Color.Gray</p>
			<p class="source-code">        )</p>
			<p class="source-code">      } else {</p>
			<p class="source-code">        Screen(</p>
			<p class="source-code">          text = stringResource(id = R.string.letter_i),</p>
			<p class="source-code">          backgroundColor = Color.LightGray</p>
			<p class="source-code">        )</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">onCheckedChange</strong> lambda expression of <strong class="source-inline">Switch()</strong> toggles <strong class="source-inline">isFirstScreen</strong>. This state is passed to <strong class="source-inline">Crossfade()</strong> as the <strong class="source-inline">targetState</strong> parameter. Like in the other animations I showed you so far, it triggers the animation every time <a id="_idIndexMarker308"/>the value changes. Specifically, the content called with the old value will be faded out, and the content called with the new one will be faded in. </p>
			<p><strong class="source-inline">Crossfade()</strong> receives<a id="_idIndexMarker309"/> an <strong class="source-inline">animationSpec</strong> of type <strong class="source-inline">FiniteAnimationSpec&lt;Float&gt;</strong>. It defaults to <strong class="source-inline">tween()</strong>. This function returns a <strong class="source-inline">TweenSpec</strong> instance configured with the given duration, delay, and easing curve. The parameters default to <strong class="source-inline">DefaultDurationMillis</strong> (300 ms), <strong class="source-inline">0</strong>, and <strong class="source-inline">FastOutSlowInEasing</strong>. The easing curve is represented by instances of <strong class="source-inline">CubicBezierEasing</strong>. This class models third-order Bézier curves. Its constructor receives four parameters: </p>
			<ul>
				<li>The <em class="italic">x</em> and <em class="italic">y</em> coordinates of the first control point</li>
				<li>The <em class="italic">x</em> and <em class="italic">y</em> coordinates of the second control point</li>
			</ul>
			<p>The documentation explains that the line through the point (0, 0) and the first control point is tangent to the easing at the point (0, 0), and that the line through the point (1, 1) and the second control point is tangent to the easing at the point (1, 1). <strong class="source-inline">CubicBezierEasing</strong> is an implementation of the <strong class="source-inline">Easing</strong> interface (the <strong class="source-inline">androidx.compose.animation.core</strong> package). Besides <strong class="source-inline">FastOutSlowInEasing</strong>, you can choose from three other predefined curves: <strong class="source-inline">LinearOutSlowInEasing</strong>, <strong class="source-inline">FastOutLinearInEasing</strong>, and <strong class="source-inline">LinearEasing</strong> to customize your animation.</p>
			<p>As <strong class="source-inline">Crossfade()</strong> receives<a id="_idIndexMarker310"/> an <strong class="source-inline">animationSpec</strong> of type <strong class="source-inline">FiniteAnimationSpec&lt;Float&gt;</strong>, you can, for example, pass the following code to use a spring<a id="_idIndexMarker311"/> animation with very low stiffness:</p>
			<p class="source-code">animationSpec = spring(stiffness = Spring.StiffnessVeryLow)</p>
			<p>In the next section, we look at how the different specifications of an animation are related.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor146"/>Understanding animation specifications</h2>
			<p><strong class="source-inline">AnimationSpec</strong> is<a id="_idIndexMarker312"/> the base interface for defining animation specifications. It stores the data type to be animated and the animation configuration. Its only <a id="_idIndexMarker313"/>function, <strong class="source-inline">vectorize()</strong>, creates a <strong class="source-inline">VectorizedAnimationSpec</strong> instance with the given <strong class="source-inline">TwoWayConverter</strong> (which converts a given type to and from <strong class="source-inline">AnimationVector</strong>).</p>
			<p>The animation system operates on <strong class="source-inline">AnimationVector</strong> instances. <strong class="source-inline">VectorizedAnimationSpec</strong> describes how these vectors should be animated, for example, simply interpolating between the start and end values (as you have seen with <strong class="source-inline">TweenSpec</strong>), showing no animation at all (<strong class="source-inline">SnapSpec</strong>), or applying spring physics to produce the motion (<strong class="source-inline">SpringSpec</strong>). </p>
			<p>The <strong class="source-inline">FiniteAnimationSpec</strong> interface extends <strong class="source-inline">AnimationSpec</strong>. It is directly implemented by the <strong class="source-inline">RepeatableSpec</strong> and <strong class="source-inline">SpringSpec</strong> classes. It overrides <strong class="source-inline">vectorize()</strong> to return <strong class="source-inline">VectorizedFiniteAnimationSpec</strong>. Now, <strong class="source-inline">FiniteAnimationSpec</strong> is the parent of the interface <strong class="source-inline">DurationBasedAnimationSpec</strong>, which overrides <strong class="source-inline">vectorize()</strong> to return <strong class="source-inline">VectorizedDurationBasedAnimationSpec</strong>. Then, <strong class="source-inline">DurationBasedAnimationSpec</strong> is implemented by the <strong class="source-inline">TweenSpec</strong>, <strong class="source-inline">SnapSpec</strong>, and <strong class="source-inline">KeyframesSpec</strong> classes.</p>
			<p>To create a <strong class="source-inline">KeyframesSpec</strong> instance, you can invoke the <strong class="source-inline">keyframes()</strong> function and pass an initialization function for the animation. After the duration of the animation, you pass mappings of the animating value at a given amount of time in milliseconds:</p>
			<p class="source-code">animationSpec = keyframes {</p>
			<p class="source-code">      durationMillis = 8000</p>
			<p class="source-code">      0f at 0</p>
			<p class="source-code">      1f at 2000</p>
			<p class="source-code">      0f at 4000</p>
			<p class="source-code">      1f at 6000</p>
			<p class="source-code">    }</p>
			<p>In this example, the animation takes 8 seconds, which is longer than you'd ever practically use, but allows you to observe the changes. If you apply the code snippet to <strong class="source-inline">CrossfadeAnimationDemo()</strong>, you will notice that each letter is visible twice during the course of the animation.</p>
			<p>So far, we <a id="_idIndexMarker314"/>have looked at finite animations. What if you want an animation to continue forever? Jetpack Compose does this in the <strong class="source-inline">CircularProgressIndicator()</strong> and <strong class="source-inline">LinearProgressIndicator()</strong> composables. <strong class="source-inline">InfiniteRepeatableSpec</strong> repeats the provided animation until it is canceled manually.</p>
			<p>When used with transitions or other animation composables, the animation will stop when the composable is removed from the compose tree. <strong class="source-inline">InfiniteRepeatableSpec</strong> implements <strong class="source-inline">AnimationSpec</strong>. The constructor expects two arguments, <strong class="source-inline">animation</strong> and <strong class="source-inline">repeatMode</strong>. The <strong class="source-inline">RepeatMode</strong> enum class defines two values, <strong class="source-inline">Restart</strong> and <strong class="source-inline">Reverse</strong>. The default value for <strong class="source-inline">repeatMode</strong> is <strong class="source-inline">RepeatMode.Restart</strong>, meaning each repeat restarts from the beginning.</p>
			<p>You can use <strong class="source-inline">infiniteRepeatable()</strong> to create an <strong class="source-inline">InfiniteRepeatableSpec</strong> instance. My <strong class="source-inline">InfiniteRepeatableDemo()</strong> sample composable (<em class="italic">Figure 8.3</em>) shows you how to do this:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="Images/B17505_08_3.jpg" alt="Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()&#13;&#10;" width="1038" height="457"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()</p>
			<p>The composable rotates<a id="_idIndexMarker315"/> a text clockwise from 0 to 359 degrees. Then, the animation restarts. <strong class="source-inline">Text()</strong> is centered inside <strong class="source-inline">Box()</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun InfiniteRepeatableDemo() {</p>
			<p class="source-code">  val infiniteTransition = rememberInfiniteTransition()</p>
			<p class="source-code">  val degrees by infiniteTransition.animateFloat(</p>
			<p class="source-code">    initialValue = 0F,</p>
			<p class="source-code">    targetValue = 359F,</p>
			<p class="source-code">    animationSpec = infiniteRepeatable(animation =</p>
			<p class="source-code">                        keyframes {</p>
			<p class="source-code">      durationMillis = 1500</p>
			<p class="source-code">      0F at 0</p>
			<p class="source-code">      359F at 1500</p>
			<p class="source-code">    })</p>
			<p class="source-code">  )</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier.fillMaxSize(),</p>
			<p class="source-code">    contentAlignment = Alignment.Center</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Text(text = stringResource(id = R.string.app_name),</p>
			<p class="source-code">    modifier = Modifier.rotate(degrees = degrees))</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>To create a<a id="_idIndexMarker316"/> potentially infinite animation, you first need to remember an infinite transition using <strong class="source-inline">rememberInfiniteTransition()</strong>. You can then invoke <strong class="source-inline">animateFloat()</strong> on the transition instance. This returns <strong class="source-inline">State&lt;Float&gt;</strong>, which is used with the <strong class="source-inline">rotate()</strong> modifier. <strong class="source-inline">infiniteRepeatable()</strong> is passed to <strong class="source-inline">animateFloat()</strong> as its <strong class="source-inline">animationSpec</strong> parameter. The animation itself is based on keyframes. We need to define only two frames, the first representing the start, and the second representing the end angle.</p>
			<p>If you want the text to return to its initial angle rather than rotating continuously, you can change the <strong class="source-inline">repeatMode</strong> parameter to the following:</p>
			<p class="source-code">repeatMode = RepeatMode.Reverse</p>
			<p>Then you should add short delays to the beginning and the end. <strong class="source-inline">keyframes {}</strong> should look like this:</p>
			<p class="source-code">keyframes {</p>
			<p class="source-code">      durationMillis = 2000</p>
			<p class="source-code">      0F at 500</p>
			<p class="source-code">      359F at 1500</p>
			<p class="source-code">}</p>
			<p>This concludes our look at animation specifications. To finish this chapter, let me briefly summarize what you have learned, and what you can expect in the next chapter.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor147"/>Summary</h1>
			<p>This chapter showed you how easy it is to use Jetpack Compose to enrich your apps with animations and transitions. We started by using simple animations to visualize state changes. For example, I introduced you to <strong class="source-inline">animateColorAsState()</strong>. We then used <strong class="source-inline">updateTransition()</strong> to obtain <strong class="source-inline">Transition</strong> instances and invoked extension functions such as <strong class="source-inline">animateDp()</strong> and <strong class="source-inline">animateFloat()</strong> to animate several values based on state changes simultaneously.</p>
			<p>The <em class="italic">Showing and hiding UI elements with animations</em> section introduced you to the <strong class="source-inline">AnimatedVisibility()</strong> composable function, which allows you to apply enter and exit transitions. They are played back while the content appears or disappears. You also learned how to animate size changes using the <strong class="source-inline">animateContentSize()</strong> modifier.</p>
			<p>In the final main section, <em class="italic">Spicing up transitions through visual effects</em>, we used the <strong class="source-inline">Crossfade()</strong> composable function to switch between two layouts with a crossfade animation. Furthermore, you learned about <strong class="source-inline">AnimationSpec</strong> and related classes and interfaces. I concluded the section with a take on infinite animations.</p>
			<p>In <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>, you will learn how to mix old-fashioned views and composable functions. We will once again return to ViewModels as a means for sharing data between both worlds. And I will show you how to integrate third-party libraries in your Compose app.</p>
		</div>
	</div></body></html>