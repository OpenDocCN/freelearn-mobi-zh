<html><head></head><body><div><div><h1 id="_idParaDest-106"><a id="_idTextAnchor135"/>Chapter 8: Working with Animations</h1>
			<p>In the previous chapters, I introduced you to many technical aspects of Jetpack Compose and showed you how to write well-behaving and good-looking apps. Now, adding animations and transitions will make your apps really shine! Compose simplifies the process of adding animation effects greatly over the old View-based approach.</p>
			<p>In this chapter, you will learn important animation-related application programming interfaces, see animations of single and multiple properties, as well as transitions between composables in action, and master the relationship between state changes and visual interactions.</p>
			<p>The main sections of this chapter are as follows:</p>
			<ul>
				<li>Using animation to visualize state changes</li>
				<li>Showing and hiding UI elements with animations</li>
				<li>Spicing up transitions through visual effects</li>
			</ul>
			<p>We start by using animations to visualize state changes. Think of a simple use case: clicking a button might change the color of a UI object. But, just switching between colors feels somewhat abrupt, whereas a gradual change is much more visually pleasing. Also, if you want to change several values during the animation, Jetpack Compose can do that easily, too. I'll introduce you to the <code>updateTransition()</code> composable, which is used in such scenarios.</p>
			<p>The <em class="italic">Showing and hiding UI elements with animations</em> section introduces you to the <code>AnimatedVisibility()</code> composable function. It allows you to apply enter and exit transitions, which will be played back while the content appears or disappears. We will also animate size changes and learn about the corresponding <code>animateContentSize()</code> modifier.</p>
			<p>In the <em class="italic">Spicing up transitions through visual effects</em> section, we will be using the <code>Crossfade()</code> composable to switch between two layouts with a crossfade animation. Furthermore, you will learn about <code>AnimationSpec</code>. This interface represents the specification of an animation. A take on infinite animations concludes the section.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>This chapter is based on the <code>AnimationDemo</code> sample. Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get the repository accompanying this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08</a>.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor137"/>Using animation to visualize state changes</h1>
			<p>State is app data<a id="_idIndexMarker290"/> that may change <a id="_idIndexMarker291"/>over time. In a Compose app, state (for example, a color) is represented through <code>State</code> or <code>MutableState</code> instances. State changes trigger recompositions. The following example shows a button and a box. Clicking the button toggles the color of the box between red and white by changing state:</p>
			<pre>@Composable
fun StateChangeDemo() {
  var <strong class="bold">toggled</strong> by remember {
    mutableStateOf(false)
  }
  val <strong class="bold">color</strong> = if (toggled)
    Color.White
  else
    Color.Red
  Column(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Button(onClick = {
      <strong class="bold">toggled = !toggled</strong>
    }) {
      Text(
        stringResource(R.string.toggle)
      )
    }
    Box(
      modifier = Modifier
        .padding(top = 32.dp)
        .<strong class="bold">background(color = color)</strong>
        .size(128.dp)
    )
  }
}</pre>
			<p>In this <a id="_idIndexMarker292"/>example, <code>color</code> is a simple<a id="_idIndexMarker293"/> immutable variable. It is set each time <code>toggled</code> (a mutable <code>Boolean</code> state) changes (this happens inside <code>onClick</code>). As <code>color</code> is used with a modifier applied to <code>Box()</code> (<code>background(color = color)</code>), clicking the button changes the box color. </p>
			<p>If you try the code, the switch feels very sudden and abrupt. This is because white and red are not very similar. Using an animation will make the change much more pleasant. Let's see how this works.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor138"/>Animating single value changes</h2>
			<p>To <a id="_idIndexMarker294"/>animate a color, you can use the built-in <code>animateColorAsState()</code> composable. Replace the <code>val color  = if (toggled) …</code> assignment inside <code>StateDemo()</code> with the following code block. If you want to try it out, you can find a composable function called <code>SingleValueAnimationDemo()</code> in <code>AnimationDemoActivity.kt</code>, which belongs to the <code>AnimationDemo</code> sample:</p>
			<pre>val color by animateColorAsState(
  targetValue = if (toggled)
    Color.White
  else
    Color.Red
)</pre>
			<p><code>animateColorAsState()</code> returns a <code>State&lt;Color&gt;</code> instance. Whenever <code>targetValue</code> changes, the animation will run automatically. If the change occurs while the animation is in progress, the ongoing animation will adjust to match the new target value.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Using the <code>by</code> keyword, you can access the color state like ordinary variables.</p>
			<p>You can provide an optional listener to get notified when the animation is finished. The following line of code prints the color that matches the new state:</p>
			<pre>finishedListener = { color -&gt; println(color)}</pre>
			<p>To customize your animation, you can pass an instance of <code>AnimationSpec&lt;Color&gt;</code> to <code>animateColorAsState()</code>. The default value is <code>colorDefaultSpring</code>, a private value in <code>SingleValueAnimation.kt</code>:</p>
			<pre>private val colorDefaultSpring = spring&lt;Color&gt;()</pre>
			<p><code>spring()</code> is a top-level function in <code>AnimationSpec.kt</code>. It receives a damping ratio, a stiffness, and a visibility threshold. The following line of code makes the color animation very soft:</p>
			<pre>animationSpec = spring(stiffness = Spring.StiffnessVeryLow)</pre>
			<p><code>spring()</code> returns <code>SpringSpec</code>. This class implements the <code>FiniteAnimationSpec</code> interface, which in turn extends <code>AnimationSpec</code>. This interface defines the specification of an animation, which includes the data type to be animated and the <a id="_idIndexMarker295"/>animation configuration, in this case, a spring metaphor. There are others. We will be returning to this interface in the <em class="italic">Spicing up transitions through visual effects</em> section. Next, we look at animating multiple value changes.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor139"/>Animating multiple value changes</h2>
			<p>In this <a id="_idIndexMarker296"/>section, I will show you how to animate several values at once upon a state change. The setup is similar to <code>StateDemo()</code> and <code>SingleValueAnimationDemo()</code>: a <code>Column()</code> instance contains a <code>Button()</code> instance and a <code>Box()</code> instance. But this time, the content of the box is <code>Text()</code>. The button toggles a state, which starts the animation. </p>
			<p>The following version of <code>MultipleValuesAnimationDemo()</code> does not yet contain an animation. It will be inserted below the comment reading <strong class="bold">FIXME: animation setup missing</strong>:</p>
			<pre>@Composable
fun MultipleValuesAnimationDemo() {
  var toggled by remember {
    mutableStateOf(false)
  }
  <strong class="bold">// FIXME: animation setup missing</strong>
  Column(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Button(onClick = {
      toggled = !toggled
    }) {
      Text(
        stringResource(R.string.toggle)
      )
    }
    Box(
      contentAlignment = Alignment.Center,
      modifier = Modifier
        .padding(top = 32.dp)
<strong class="bold">        .border(</strong>
<strong class="bold">          width = borderWidth,</strong>
<strong class="bold">          color = Color.Black</strong>
<strong class="bold">        )</strong>
        .size(128.dp)
    ) {
      Text(
        text = stringResource(id = R.string.app_name),
        modifier = <strong class="bold">Modifier.rotate(degrees = degrees)</strong>
      )
    }
  }
}</pre>
			<p>The <code>Box()</code> shows a black border, whose width is controlled by <code>borderWidth</code>. To apply borders to your composable functions, just add the <code>border()</code> modifier. <code>Text()</code> is rotated. You can achieve this with the <code>rotate()</code> modifier. The <code>degrees</code> variable holds <a id="_idIndexMarker297"/>the angle. <code>degrees</code> and <code>borderWidth</code> will change during the animation. Here's how this is done:</p>
			<pre>val transition = updateTransition(targetState = toggled)
val borderWidth by transition.animateDp() { state -&gt;
  if (state)
    10.dp
  else
    1.dp
}
val degrees by transition.animateFloat() { state -&gt;
  if (state) -90F
  else
    0F
}</pre>
			<p>The <code>updateTransition()</code> composable function configures and returns a <code>Transition</code>. When <code>targetState</code> changes, the transition will run all of its child animations toward their target values. Child animations are added using <code>animate…()</code> functions. They are not part of a <code>Transition</code> instance but are extension functions. <code>animateDp()</code> adds an animation based on density-independent pixels.</p>
			<p>In my example, it controls the border width. <code>animateFloat()</code> creates a <code>Float</code> animation. This function is ideal for changing the rotation of <code>Text()</code>, which is a <code>Float</code> value. There are more <code>animate…()</code> functions, which operate on other data types. For example, <code>animateInt()</code> works with <code>Int</code> values. <code>animateOffset()</code> animates an <code>Offset</code> instance. You can find them in the <code>Transition.kt</code> file, which belongs to the <code>androidx.compose.animation.core</code> package.</p>
			<p><code>Transition</code> instances provide several properties reflecting the status of a transition. For example, <code>isRunning</code> indicates whether any animation in the transition is currently running. <code>segment</code> contains the initial state and the target state of the currently ongoing transition. The current state of the transition is available through <code>currentState</code>. This <a id="_idIndexMarker298"/>will be the initial state until the transition is finished. Then, <code>currentState</code> is set to the target state.</p>
			<p>As you have seen, it is very easy to use state changes to trigger animations. So far, these animations have modified the visual appearance of one or more composable functions. In the next section, I will show you how to apply animations while showing or hiding UI elements.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor140"/>Showing and hiding UI elements with animations</h1>
			<p>Often, your <a id="_idIndexMarker299"/>UI will contain information that need not be visible all the time. For example, in an address book you may want to show only key attributes of a contact, and present detailed information upon request, typically after a button click. However, just showing and hiding the additional data feels sudden and abrupt. Using animations leads to a more pleasant experience, so let's look into this more.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor141"/>Understanding AnimatedVisibility()</h2>
			<p>In this section, we<a id="_idIndexMarker300"/> will look at my sample composable <code>AnimatedVisibilityDemo()</code>. It belongs to the <code>AnimationDemo</code> project. Like <code>StateDemo()</code>, <code>SingleValueAnimationDemo()</code>, and <code>MultipleValuesAnimationDemo()</code>, it uses a <code>Column()</code> instance, which contains a <code>Button()</code> instance and a <code>Box()</code> instance. This part of the code is simple and straightforward, so there is no need to repeat it in print. The button toggles a state, which starts the animation. Let's see how this works:</p>
			<pre>AnimatedVisibility(
  visible = visible,
  enter = slideInHorizontally(),
  exit = slideOutVertically()
) {
  Box(
    modifier = Modifier
      .padding(top = 32.dp)
      .background(color = Color.Red)
      .size(128.dp)
  )
}</pre>
			<p>The box is <a id="_idIndexMarker301"/>wrapped in <code>AnimatedVisibility()</code>. This built-in composable function animates the appearance and disappearance of its content, when the <code>visible</code> parameter changes. You can specify different <code>EnterTransition</code> and <code>ExitTransition</code> instances. In my example, the box enters by sliding in horizontally and exits by sliding out vertically.</p>
			<p>Currently, there are three transition types:</p>
			<ul>
				<li>Fade</li>
				<li>Expand and shrink</li>
				<li>Slide</li>
			</ul>
			<p>They can be combined using <code>+</code>: </p>
			<pre>enter = slideInHorizontally() + fadeIn(),</pre>
			<p>The combination order doesn't matter as the animations start simultaneously.</p>
			<p>If you do not pass a value for <code>enter</code>, the content will default to fading in while expanding vertically. Omitting <code>exit</code> will cause the content to fade out while shrinking vertically.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">At the time of writing, <code>AnimatedVisibility()</code> is experimental. To use it in your app, you must add the <code>@ExperimentalAnimationApi</code> annotation. This will change with Jetpack Compose 1.1.</p>
			<p>In this section, I showed you <a id="_idIndexMarker302"/>how to animate the appearance and disappearance of content. A variation of this subject is to visualize size changes (if either <code>width</code>, <code>height</code>, or both are <code>0</code>, the UI element is no longer visible). Let's find out how to do this in the following section.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor142"/>Animating size changes</h2>
			<p>Sometimes<a id="_idIndexMarker303"/> you may want to change the amount of space a UI element requires onscreen. Think of text fields. In compact mode, your app could show only three lines, whereas in detail mode it might display 10 lines or more. My <code>SizeChangeAnimationDemo()</code> sample composable (<em class="italic">Figure 8.1</em>) uses a slider to control the <code>maxLines</code> value of <code>Text()</code>:</p>
			<div><div><img src="img/B17505_08_1.jpg" alt="Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()&#13;&#10;" width="1378" height="476"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()</p>
			<p>The general setup follows the examples from the previous sections: a <code>Column()</code> instance acts as a container for some composable functions, in this case a <code>Slider()</code> instance and a <code>Text()</code> instance. Then a state change triggers the animation. Here is the code:</p>
			<pre>@Composable
fun SizeChangeAnimationDemo() {
  var size by remember { mutableStateOf(1F) }
  Column(
    modifier = Modifier
      .fillMaxSize()
      .padding(16.dp)
  ) {
    Slider(
      value = size,
      valueRange = (1F..4F),
      steps = 3,
      onValueChange = {
        size = it
      },
      modifier = Modifier.padding(bottom = 8.dp)
    )
    Text(
      text = stringResource(id = R.string.lines),
      modifier = Modifier
        .fillMaxWidth()
        .background(Color.White)
        .<strong class="bold">animateContentSize()</strong>,
      maxLines = size.toInt(),
      color = Color.Blue
    )
  }
}</pre>
			<p><code>size</code> is a mutable <code>Float</code> state. It is passed to <code>Slider()</code> as its default value. When the slider is moved, <code>onValueChange {}</code> is invoked. The lambda expression receives the new<a id="_idIndexMarker304"/> value, which is assigned to <code>size</code>. The <code>Text()</code> composable uses the state as a value for <code>maxLines</code>.</p>
			<p>The animation is handled by the <code>animateContentSize()</code> modifier. It belongs to the <code>androidx.compose.animation</code> package. The modifier expects two parameters, <code>animationSpec</code> and <code>finishedListener</code>. I introduced both briefly in the <em class="italic">Animating single value changes</em> section. <code>animationSpec</code> defaults to <code>spring()</code>. If you want the lines to appear all at once after some delay, you can add the following:</p>
			<pre>animationSpec = snap(1000)</pre>
			<p>A snap animation immediately switches the animating value to the end value. You pass the number of milliseconds to wait before the animation runs. It defaults to <code>0</code>. Now, <code>snap()</code> returns an instance of <code>SnapSpec</code>, an implementation of <code>AnimationSpec</code>. We will turn to this interface in the <em class="italic">Spicing up transitions through visual effects</em> section.</p>
			<p>The default value of <code>finishedListener</code> is <code>null</code>. You can provide an implementation, if your app wants to get notified when the size change animation is finished. Both the initial value and the final size are passed to the listener. If the animation is interrupted, the initial value will be the size at the point of interruption. This helps determine the direction of the size change.</p>
			<p>This concludes our look at showing and hiding UI elements with animations. In the next section, we focus on exchanging parts of the UI. For example, we will be using <code>Crossfade()</code> to switch between two composable functions with a crossfade animation.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor143"/>Spicing up transitions through visual effects</h1>
			<p>So far, I have <a id="_idIndexMarker305"/>shown you animations that modify certain aspects of a UI element, like its color, size, or visibility. But sometimes you may want to <em class="italic">exchange</em> parts of your UI. Then, <code>Crossfade()</code> comes in handy. It allows you to switch between two composable functions with a crossfade animation. Let's look at my <code>CrossfadeAnimationDemo()</code> sample (<em class="italic">Figure 8.2</em>), part of the <code>AnimationDemo</code> project, to see how <a id="_idTextAnchor144"/>this works:</p>
			<div><div><img src="img/B17505_08_2.jpg" alt="Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()&#13;&#10;" width="1058" height="596"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()</p>
			<p>A switch toggles between two screens. As we are focusing on animation, I kept the <code>Screen()</code>composable very simple, just a box with customizable background color, and a big text centered inside. You can find its source code in <code>AnimationDemoActivity.kt</code>.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor145"/>Crossfading composable functions</h2>
			<p>Like most examples<a id="_idIndexMarker306"/> in this chapter, <code>CrossfadeAnimationDemo()</code> uses a <code>Column()</code> as the root element. The column contains a switch, and the <a id="_idIndexMarker307"/>screen to display. Which one is shown depends on a mutable <code>Boolean</code> state:</p>
			<pre>@Composable
fun CrossfadeAnimationDemo() {
  var isFirstScreen by remember { mutableStateOf(true) }
  Column(
    modifier = Modifier
      .fillMaxSize(),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {
    Switch(
      checked = isFirstScreen,
      onCheckedChange = {
        isFirstScreen = !isFirstScreen
      },
      modifier = Modifier.padding(top = 16.dp,
                                  bottom = 16.dp)
    )
    Crossfade(targetState = isFirstScreen) { it -&gt;
      if (it) {
        Screen(
          text = stringResource(id = R.string.letter_w),
          backgroundColor = Color.Gray
        )
      } else {
        Screen(
          text = stringResource(id = R.string.letter_i),
          backgroundColor = Color.LightGray
        )
      }
    }
  }
}</pre>
			<p>The <code>onCheckedChange</code> lambda expression of <code>Switch()</code> toggles <code>isFirstScreen</code>. This state is passed to <code>Crossfade()</code> as the <code>targetState</code> parameter. Like in the other animations I showed you so far, it triggers the animation every time <a id="_idIndexMarker308"/>the value changes. Specifically, the content called with the old value will be faded out, and the content called with the new one will be faded in. </p>
			<p><code>Crossfade()</code> receives<a id="_idIndexMarker309"/> an <code>animationSpec</code> of type <code>FiniteAnimationSpec&lt;Float&gt;</code>. It defaults to <code>tween()</code>. This function returns a <code>TweenSpec</code> instance configured with the given duration, delay, and easing curve. The parameters default to <code>DefaultDurationMillis</code> (300 ms), <code>0</code>, and <code>FastOutSlowInEasing</code>. The easing curve is represented by instances of <code>CubicBezierEasing</code>. This class models third-order Bézier curves. Its constructor receives four parameters: </p>
			<ul>
				<li>The <em class="italic">x</em> and <em class="italic">y</em> coordinates of the first control point</li>
				<li>The <em class="italic">x</em> and <em class="italic">y</em> coordinates of the second control point</li>
			</ul>
			<p>The documentation explains that the line through the point (0, 0) and the first control point is tangent to the easing at the point (0, 0), and that the line through the point (1, 1) and the second control point is tangent to the easing at the point (1, 1). <code>CubicBezierEasing</code> is an implementation of the <code>Easing</code> interface (the <code>androidx.compose.animation.core</code> package). Besides <code>FastOutSlowInEasing</code>, you can choose from three other predefined curves: <code>LinearOutSlowInEasing</code>, <code>FastOutLinearInEasing</code>, and <code>LinearEasing</code> to customize your animation.</p>
			<p>As <code>Crossfade()</code> receives<a id="_idIndexMarker310"/> an <code>animationSpec</code> of type <code>FiniteAnimationSpec&lt;Float&gt;</code>, you can, for example, pass the following code to use a spring<a id="_idIndexMarker311"/> animation with very low stiffness:</p>
			<pre>animationSpec = spring(stiffness = Spring.StiffnessVeryLow)</pre>
			<p>In the next section, we look at how the different specifications of an animation are related.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor146"/>Understanding animation specifications</h2>
			<p><code>AnimationSpec</code> is<a id="_idIndexMarker312"/> the base interface for defining animation specifications. It stores the data type to be animated and the animation configuration. Its only <a id="_idIndexMarker313"/>function, <code>vectorize()</code>, creates a <code>VectorizedAnimationSpec</code> instance with the given <code>TwoWayConverter</code> (which converts a given type to and from <code>AnimationVector</code>).</p>
			<p>The animation system operates on <code>AnimationVector</code> instances. <code>VectorizedAnimationSpec</code> describes how these vectors should be animated, for example, simply interpolating between the start and end values (as you have seen with <code>TweenSpec</code>), showing no animation at all (<code>SnapSpec</code>), or applying spring physics to produce the motion (<code>SpringSpec</code>). </p>
			<p>The <code>FiniteAnimationSpec</code> interface extends <code>AnimationSpec</code>. It is directly implemented by the <code>RepeatableSpec</code> and <code>SpringSpec</code> classes. It overrides <code>vectorize()</code> to return <code>VectorizedFiniteAnimationSpec</code>. Now, <code>FiniteAnimationSpec</code> is the parent of the interface <code>DurationBasedAnimationSpec</code>, which overrides <code>vectorize()</code> to return <code>VectorizedDurationBasedAnimationSpec</code>. Then, <code>DurationBasedAnimationSpec</code> is implemented by the <code>TweenSpec</code>, <code>SnapSpec</code>, and <code>KeyframesSpec</code> classes.</p>
			<p>To create a <code>KeyframesSpec</code> instance, you can invoke the <code>keyframes()</code> function and pass an initialization function for the animation. After the duration of the animation, you pass mappings of the animating value at a given amount of time in milliseconds:</p>
			<pre>animationSpec = keyframes {
      durationMillis = 8000
      0f at 0
      1f at 2000
      0f at 4000
      1f at 6000
    }</pre>
			<p>In this example, the animation takes 8 seconds, which is longer than you'd ever practically use, but allows you to observe the changes. If you apply the code snippet to <code>CrossfadeAnimationDemo()</code>, you will notice that each letter is visible twice during the course of the animation.</p>
			<p>So far, we <a id="_idIndexMarker314"/>have looked at finite animations. What if you want an animation to continue forever? Jetpack Compose does this in the <code>CircularProgressIndicator()</code> and <code>LinearProgressIndicator()</code> composables. <code>InfiniteRepeatableSpec</code> repeats the provided animation until it is canceled manually.</p>
			<p>When used with transitions or other animation composables, the animation will stop when the composable is removed from the compose tree. <code>InfiniteRepeatableSpec</code> implements <code>AnimationSpec</code>. The constructor expects two arguments, <code>animation</code> and <code>repeatMode</code>. The <code>RepeatMode</code> enum class defines two values, <code>Restart</code> and <code>Reverse</code>. The default value for <code>repeatMode</code> is <code>RepeatMode.Restart</code>, meaning each repeat restarts from the beginning.</p>
			<p>You can use <code>infiniteRepeatable()</code> to create an <code>InfiniteRepeatableSpec</code> instance. My <code>InfiniteRepeatableDemo()</code> sample composable (<em class="italic">Figure 8.3</em>) shows you how to do this:</p>
			<div><div><img src="img/B17505_08_3.jpg" alt="Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()&#13;&#10;" width="1038" height="457"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()</p>
			<p>The composable rotates<a id="_idIndexMarker315"/> a text clockwise from 0 to 359 degrees. Then, the animation restarts. <code>Text()</code> is centered inside <code>Box()</code>:</p>
			<pre>@Composable
fun InfiniteRepeatableDemo() {
  val infiniteTransition = rememberInfiniteTransition()
  val degrees by infiniteTransition.animateFloat(
    initialValue = 0F,
    targetValue = 359F,
    animationSpec = infiniteRepeatable(animation =
                        keyframes {
      durationMillis = 1500
      0F at 0
      359F at 1500
    })
  )
  Box(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.Center
  ) {
    Text(text = stringResource(id = R.string.app_name),
    modifier = Modifier.rotate(degrees = degrees))
  }
}</pre>
			<p>To create a<a id="_idIndexMarker316"/> potentially infinite animation, you first need to remember an infinite transition using <code>rememberInfiniteTransition()</code>. You can then invoke <code>animateFloat()</code> on the transition instance. This returns <code>State&lt;Float&gt;</code>, which is used with the <code>rotate()</code> modifier. <code>infiniteRepeatable()</code> is passed to <code>animateFloat()</code> as its <code>animationSpec</code> parameter. The animation itself is based on keyframes. We need to define only two frames, the first representing the start, and the second representing the end angle.</p>
			<p>If you want the text to return to its initial angle rather than rotating continuously, you can change the <code>repeatMode</code> parameter to the following:</p>
			<pre>repeatMode = RepeatMode.Reverse</pre>
			<p>Then you should add short delays to the beginning and the end. <code>keyframes {}</code> should look like this:</p>
			<pre>keyframes {
      durationMillis = 2000
      0F at 500
      359F at 1500
}</pre>
			<p>This concludes our look at animation specifications. To finish this chapter, let me briefly summarize what you have learned, and what you can expect in the next chapter.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor147"/>Summary</h1>
			<p>This chapter showed you how easy it is to use Jetpack Compose to enrich your apps with animations and transitions. We started by using simple animations to visualize state changes. For example, I introduced you to <code>animateColorAsState()</code>. We then used <code>updateTransition()</code> to obtain <code>Transition</code> instances and invoked extension functions such as <code>animateDp()</code> and <code>animateFloat()</code> to animate several values based on state changes simultaneously.</p>
			<p>The <em class="italic">Showing and hiding UI elements with animations</em> section introduced you to the <code>AnimatedVisibility()</code> composable function, which allows you to apply enter and exit transitions. They are played back while the content appears or disappears. You also learned how to animate size changes using the <code>animateContentSize()</code> modifier.</p>
			<p>In the final main section, <em class="italic">Spicing up transitions through visual effects</em>, we used the <code>Crossfade()</code> composable function to switch between two layouts with a crossfade animation. Furthermore, you learned about <code>AnimationSpec</code> and related classes and interfaces. I concluded the section with a take on infinite animations.</p>
			<p>In <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>, you will learn how to mix old-fashioned views and composable functions. We will once again return to ViewModels as a means for sharing data between both worlds. And I will show you how to integrate third-party libraries in your Compose app.</p>
		</div>
	</div></body></html>