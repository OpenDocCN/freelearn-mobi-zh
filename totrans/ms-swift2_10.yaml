- en: Chapter 10. Using Optional Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。使用可选类型
- en: When I first started using Swift, the concept that I had the most trouble with
    was optional types. Coming from an Objective-C, C, Java, and Python background,
    I was able to relate to most of Swift's features to how things worked in one of
    the other languages that I knew, but optionals were different. There really was
    nothing like optionals in the other languages that I used, so it took a lot of
    reading to fully understand them. While I briefly covered optionals in [Chapter
    2](ch02.html "Chapter 2. Learning about Variables, Constants, Strings, and Operators"),
    *Learning about Variables, Constants, Strings, and Operators*, which gave enough
    of an overview to get started with, we need to cover a lot more information to
    really understand what optionals are, how to properly use them, and why they are
    so important in the Swift language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始使用 Swift 时，我遇到的最大难题是可选类型。由于我的背景是 Objective-C、C、Java 和 Python，我能够将 Swift
    的许多特性与我所知道的另一种语言中的工作方式联系起来，但可选类型却不同。在我使用的其他语言中，真的没有什么与可选类型相似的东西，因此我花了很多时间去完全理解它们。虽然我在[第
    2 章](ch02.html "第 2 章。学习变量、常量、字符串和运算符")中简要介绍了可选类型，即“学习变量、常量、字符串和运算符”，这足以让我们开始学习，但我们还需要涵盖更多信息，才能真正理解可选类型是什么，如何正确使用它们，以及为什么它们在
    Swift 语言中如此重要。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to optional types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选类型的简介
- en: The need for optional types in Swift
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中可选类型的必要性
- en: Unwrapping an optional
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包可选类型
- en: Optional binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选绑定
- en: Optional chaining
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选链
- en: Introducing optionals
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍可选类型
- en: When we declare variables in Swift, they are, by default, non-optional, which
    means that they must contain a valid, non-nil value. If we try to set a non-optional
    variable to nil, it will result in a `Type '{type}' does not conform to protocol
    'NilLiteralConvertible'` error, where `{type}` is the type of the variable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Swift 中声明变量时，它们默认是非可选的，这意味着它们必须包含一个有效、非 nil 的值。如果我们尝试将非可选变量设置为 nil，将会导致一个
    `Type '{type}' does not conform to protocol 'NilLiteralConvertible'` 错误，其中 `{type}`
    是变量的类型。
- en: 'For example, the following code will throw an error when we attempt to set
    the `message` variable to `nil` because `message` is a non-optional type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在尝试将 `message` 变量设置为 `nil` 时将抛出错误，因为 `message` 是一个非可选类型：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is very important to understand that nil in Swift is very different from
    nil in Objective-C. In Objective-C, nil is a pointer to non-existent object; however,
    in Swift, nil is the absence of a value. This concept is very important to fully
    understand optionals in Swift.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解 Swift 中的 nil 与 Objective-C 中的 nil 非常不同。在 Objective-C 中，nil 是指向不存在对象的指针；然而，在
    Swift 中，nil 是值的缺失。这个概念对于完全理解 Swift 中的可选类型非常重要。
- en: A variable defined as an optional can contain a valid value or it can indicate
    an absence of a value. We indicate an absence of a value by assigning it a special
    nil value. Optionals of any type can be set to nil, whereas in Objective-C, only
    objects can be set to nil.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为可选的变量可以包含一个有效值，也可以表示值的缺失。我们通过将其分配一个特殊的 nil 值来表示值的缺失。任何类型的可选类型都可以设置为 nil，而在
    Objective-C 中，只有对象可以设置为 nil。
- en: 'To really understand the concept behind optionals, let''s look at a line of
    code that defines an optional:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解可选类型背后的概念，让我们看看定义可选类型的一行代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The question mark at the end indicates that the `myString` variable is an optional.
    When we look at this code, it would be wrong to read this line of code as "the
    `myString` variable is a string type that is optional". We should actually read
    this line of code as "the `myString` variable is an optional type, which may contain
    a string type or may contain no value". The subtle difference between the two
    lines actually makes a big difference in understanding how optionals work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的问号表示 `myString` 变量是一个可选类型。当我们查看这段代码时，将这一行代码读作“`myString` 变量是一个可选的字符串类型”是不正确的。实际上，我们应该将这一行代码读作“`myString`
    变量是一个可选类型，它可能包含一个字符串类型，也可能不包含任何值”。这两行代码之间的细微差别实际上在理解可选类型的工作方式上有着很大的不同。
- en: 'Optionals are a special type in Swift. When we defined the `myString` variable,
    we actually defined it as an optional type. To understand this, let''s look at
    some more code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型是 Swift 中的一个特殊类型。当我们定义 `myString` 变量时，我们实际上将其定义为可选类型。为了理解这一点，让我们看看一些更多的代码：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two declarations are equivalent. Both lines declare an optional type that
    may contain a string type or may be absent of a value. In Swift, we can think
    of the absence of a value as being set to nil, but always remember that this is
    different than setting something to nil in Objective-C. In this book, when we
    refer to nil, we are referring to how Swift uses nil and not how Objective-C uses
    nil.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个声明是等效的。两行都声明了一个可能包含字符串类型或可能没有值的可选类型。在Swift中，我们可以将值的缺失视为设置为 `nil`，但始终要记住，这与在Objective-C中设置
    `nil` 是不同的。在这本书中，当我们提到 `nil` 时，我们是指Swift如何使用 `nil`，而不是Objective-C如何使用 `nil`。
- en: The optional type is an enumeration with two possible values, `None` and `Some(T)`,
    where `T` is the associated value of the appropriate type. If we set the optional
    to `nil`, then it will have a value of `None`, and if we set a value, then the
    optional will have a value of `Some` with an associated value of the appropriate
    type. In [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants,
    Strings, and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    we explained that an enum in Swift may have associated values. Associated values
    allow us to store additional information along with the enum's member value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型是一个有两个可能值的枚举，`None` 和 `Some(T)`，其中 `T` 是相关类型的关联值。如果我们将可选设置为 `nil`，那么它将具有
    `None` 的值，如果我们设置一个值，那么可选将具有 `Some` 的值，并带有相关类型的关联值。在 [第2章](ch02.html "第2章. 学习变量、常量、字符串和运算符")，*学习变量、常量、字符串和运算符*
    中，我们解释了Swift中的枚举可以有关联值。关联值允许我们在枚举成员值中存储额外的信息。
- en: 'Internally, an optional is defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，可选类型定义如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `T` is the type to associate with the optional. The `T` symbol is used
    to define a generic. We can read more about generics in [Chapter 11](ch11.html
    "Chapter 11. Working with Generics"), *Working with Generics*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`T` 是与可选类型关联的类型。`T` 符号用于定义泛型。我们可以在 [第11章](ch11.html "第11章. 使用泛型")，*使用泛型*
    中了解更多关于泛型的信息。
- en: The need for optional types in Swift
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中可选类型的需求
- en: Now, the burning question is why does Swift need optionals? To understand why
    Swift has optionals, we should examine what problems optionals are designed to
    solve.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最迫切的问题是为什么Swift需要可选类型？为了理解为什么Swift有可选类型，我们应该检查可选类型旨在解决什么问题。
- en: 'In most languages, it is possible to create a variable without giving it an
    initialized value. For example, in Objective-C, both lines of code are valid:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数语言中，可以在不提供初始化值的情况下创建一个变量。例如，在Objective-C中，两行代码都是有效的：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s say that the `MyObject` class has the following method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设 `MyObject` 类有如下方法：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This method takes the value passed in from the `i` parameter, multiplies it
    by 2, and returns the results. Let''s try to call this method using the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受从 `i` 参数传递的值，将其乘以2，并返回结果。让我们尝试使用以下代码调用这个方法：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our first thought might be that this code would display `Value: 10`; however,
    this would be wrong. In reality, this code would display `Value: 0` because we
    did not initialize the `m` object prior to using it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一反应可能是认为这段代码会显示 `Value: 10`；然而，这是错误的。实际上，这段代码会显示 `Value: 0`，因为我们没有在使用之前初始化
    `m` 对象。'
- en: When we forget to initialize an object or set a value for a variable, we can
    get unexpected results at runtime, as we just demonstrated. The unexpected results
    can be, at times, very difficult to track down.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忘记初始化一个对象或为变量设置值时，我们可能会在运行时得到意外的结果，就像我们刚才演示的那样。有时，这些意外的结果可能非常难以追踪。
- en: 'With optionals, Swift is able to detect problems like this at compile time
    and alert us at runtime. If we expect a variable or object to always contain a
    value prior to using it, we will declare the variable as a non-optional (this
    is the default declaration). Then, at compile time, we would receive an error
    if we try to use it prior to initializing it. Let''s look at an example of this.
    The following code would display an error at compile time because we are attempting
    to use a non-optional variable prior to initialize it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选类型，Swift能够在编译时检测到这类问题，并在运行时提醒我们。如果我们期望在使用变量或对象之前它始终包含一个值，我们将变量声明为非可选类型（这是默认声明）。然后，在编译时，如果我们尝试在使用之前初始化它，我们会收到一个错误。让我们看看这个例子。以下代码会在编译时显示错误，因为我们试图在使用之前初始化一个非可选变量：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a variable is declared as an optional, it is good programming practice to
    verify that it contains a valid value before attempting to use it. We should only
    declare a variable as an optional if there is a valid reason for the variable
    to contain no value. This is the reason Swift declares variables a non-optional
    by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量被声明为可选类型，在尝试使用它之前验证它是否包含有效的值是良好的编程实践。我们只应该声明变量为可选类型，如果确实有理由让变量不包含值。这也是Swift默认将变量声明为非可选类型的原因。
- en: Now that we (hopefully) have a good understanding of what optionals are and
    what types of problems they are designed to solve, let's look at how to use them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们（希望）已经很好地理解了可选类型是什么以及它们旨在解决哪些类型的问题，让我们看看如何使用它们。
- en: Defining an optional
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可选类型
- en: 'Typically, to define an optional type, we put a question mark after the type
    in the variable declaration. Keep in mind that the type we define in the variable''s
    declaration is actually the associated value in the optional enum. The following
    code shows us how we would typically declare an optional:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要定义可选类型，我们在变量声明中的类型后放置一个问号。请注意，我们在变量声明中定义的类型实际上是可选枚举中的关联值。以下代码展示了我们通常如何声明可选类型：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code declares an optional variable that might contain a string or no value
    (nil). When a variable is declared like this, by default, it is set to no value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一个可能包含字符串或无值（nil）的可选变量。当一个变量以这种方式声明时，默认情况下，它被设置为无值。
- en: Using optionals
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可选类型
- en: There are a number of ways that we can use optionals within our code. The key
    to using optionals is to always verify that they contain a valid value prior to
    accessing it. We use the unwrapping term to refer to retrieve the value of an
    optional.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中用多种方式使用可选类型。使用可选类型的关键是在访问之前始终验证它们是否包含有效的值。我们使用解包这个术语来指代检索可选类型的值。
- en: Forced unwrapping an optional
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制解包可选类型
- en: To unwrap or retrieve the value of an optional, we place an exclamation mark
    (`!`) after the variable name. Forced unwrapping, in this manner, can be very
    dangerous and should be used only if we are certain that the value is not nil.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包或检索可选类型的值，我们在变量名后放置一个感叹号（`!`）。以这种方式强制解包可能非常危险，并且只有在我们确定值不是nil的情况下才应使用。
- en: 'When we use the exclamation mark to unwrap an optional, we are telling the
    compiler that we know the optional does not contain a nil value, so go ahead and
    give us the value. Let''s look at how to do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用感叹号来解包可选类型时，我们是在告诉编译器我们知道可选类型不包含nil值，因此请继续并给我们值。让我们看看如何做到这一点：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code will work as we expect it to, where the `test` variable will contain
    the `test` string; however, if the line that set the `myString1` optional to `test`
    was removed, we would receive a runtime error when we run the application. Note
    that the compiler will not alert us of an issue because we are using the exclamation
    point to unwrap the optional; therefore, the compiler assumes that we know what
    we are doing and will happily compile the code for us. We should verify that the
    `myString1` optional contains a valid value prior to unwrapping it. The following
    example is one way to do this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将按预期工作，其中`test`变量将包含`test`字符串；然而，如果设置`myString1`可选类型为`test`的行被移除，当我们运行应用程序时，我们会收到运行时错误。请注意，编译器不会提醒我们问题，因为我们正在使用感叹号来解包可选类型；因此，编译器假设我们知道我们在做什么，并会愉快地为我们编译代码。我们应该在解包`myString1`可选类型之前验证它是否包含有效的值。以下示例是这样做的一种方式：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if the line that sets the `myString1` optional to `test` was removed, we
    would not receive a runtime error because we are only unwrapping the `myString`
    optional, if it contains a valid (non-nil) value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果设置`myString1`可选类型为`test`的行被移除，我们不会收到运行时错误，因为我们只解包了`myString`可选类型，如果它包含一个有效的（非nil）值。
- en: Unwrapping optionals, as we just described, is not the most optimal way, and
    it is not recommended that we unwrap optionals in this manner. We can combine
    the verification and unwrapping into one step called **optional binding**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们刚才所描述的，解包可选类型并不是最理想的方式，我们不推荐以这种方式解包可选类型。我们可以将验证和解包合并为一步，称为**可选绑定**。
- en: Optional binding
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选绑定
- en: Optional binding is the recommended way to unwrap an optional. With optional
    binding, we perform a check to see whether the optional contains a valid value
    and, if so, unwrap it into a temporary variable or constant. This is all performed
    in one step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是解包可选推荐的方式。使用可选绑定，我们执行检查以查看可选是否包含有效值，如果是，则将其解包到临时变量或常量中。这一切都在一个步骤中完成。
- en: 'Optional binding is performed with the `if` or `while` conditional statements.
    It takes the following format if we want to put the value of the optional in a
    constant:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定使用`if`或`while`条件语句执行。如果我们想将可选的值放入常量中，其格式如下：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we need to put the value in a variable, instead of a constant, we can use
    the `var` keyword instead of the `let` keyword, as shown in the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将值放入变量而不是常量中，可以使用`var`关键字而不是`let`关键字，如下例所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following example shows how to perform optional binding:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何执行可选绑定：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example, we define the `myString3` variable as an optional type. If the
    `myString3` optional contains a valid value, then we set the new variable named
    `tempvar` to the value of the `myString3` optional and print the value to the
    console. If the `myString3` optional does not contain a value, then we print `No`
    value to the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将`myString3`变量定义为可选类型。如果`myString3`可选包含有效值，则我们将新变量`tempvar`设置为`myString3`可选的值，并将值打印到控制台。如果`myString3`可选不包含值，则打印`No`值到控制台。
- en: 'Starting with Swift 1.2, we are able to use optional binding to unwrap multiple
    optionals within the same optional binding line. For example, if we had three
    optionals named `optional1`, `optional2` and `optional3`, we could use the following
    code to attempt to unwrap all the three at once:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift 1.2开始，我们能够使用可选绑定在同一可选绑定行中解包多个可选。例如，如果我们有三个名为`optional1`、`optional2`和`optional3`的可选，我们可以使用以下代码一次性尝试解包所有三个：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If any of the three optionals failed to unwrap, the whole optional binding statement
    fails.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果三个可选中的任何一个解包失败，整个可选绑定语句将失败。
- en: 'It is perfectly acceptable with optional binding to assign the value to a variable
    of the same name. The following code illustrates this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选绑定将值赋给同名变量是完全可接受的。以下代码说明了这一点：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One thing to note is that the `temp` variable is scoped only for the conditional
    block and cannot be used outside the conditional block. To illustrate the scope
    of the temporary variable, let''s take a look at the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，`temp`变量仅在条件块内作用域，不能在条件块外使用。为了说明临时变量的作用域，让我们看一下以下代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code would not compile because the `tmp` variable is only valid within
    the conditional block and we are attempting to use it outside of the conditional
    block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码无法编译，因为`tmp`变量仅在条件块内有效，而我们试图在条件块外使用它。
- en: Using optional binding is a lot cleaner and easier than manually verifying that
    the optional has a value and then forcing the unwrapping of the optional.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选绑定比手动验证可选是否有值然后强制解包可选要干净和简单得多。
- en: Returning optionals from functions, methods, and subscripts
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从函数、方法和子脚本返回可选
- en: We can set the return type of a function or a method to the optional type. This
    allows us to return a nil (no value) from the function or method. To set the return
    type to an optional type, we will insert a question mark after the name of the
    type in the function or method declaration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将函数或方法的返回类型设置为可选类型。这允许我们从函数或方法返回nil（无值）。要设置返回类型为可选类型，我们将在函数或方法声明中的类型名称后插入一个问号。
- en: 'The following example shows us how we will return an optional from a function
    or method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何从函数或方法返回可选：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the example, we defined the return type as an optional that can be either
    a string value or no value. Inside the function, we will return the name if the
    index is within the bounds of the array, or `nil` if it is outside the bounds
    of the array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将返回类型定义为可选，可以是字符串值或无值。在函数内部，如果索引在数组范围内，我们将返回名称；如果索引超出数组范围，则返回`nil`。
- en: 'The following code shows how to call this function where the return value is
    an optional:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何调用此函数，其中返回值是可选的：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous code, the `name` variable will contain `Kailey`, while the `name2`
    variable will contain `nil` (no value). Note that we do not have to define the
    variable as an optional (with a question mark) since Swift knows it is an optional
    type because that is the return type defined by the function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`name`变量将包含`Kailey`，而`name2`变量将包含`nil`（无值）。注意，我们不需要将变量定义为可选的（使用问号），因为Swift知道它是一个可选类型，因为这是函数定义的返回类型。
- en: 'We can also define a subscript that returns an optional type. We define a subscript
    as an optional exactly like we defined functions. Here is an example template
    of a subscript that returns an optional:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义一个返回可选类型的下标。我们定义下标的方式与定义函数的方式相同。以下是一个返回可选的下标示例模板：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this definition, we are able to return a `nil` (no value) from our subscript.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，我们能够从我们的下标返回一个`nil`（无值）。
- en: Using optionals as a parameter in a function or method
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在函数或方法中使用可选作为参数
- en: 'We can also accept an optional as a parameter to a function or a method. This
    allows us to have the option of passing a nil (no value) into a function or method
    if required. The following example shows how to define an optional parameter for
    a function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将可选作为函数或方法的参数。这允许我们在需要时将`nil`（无值）传递给函数或方法。以下示例展示了如何为函数定义可选参数：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To define a parameter as an optional type, we use the question mark within the
    parameter definition. Within this example, we use optional binding to check whether
    the optional contains a value or not. If it contains a value, we print `Contains
    value to the console;` otherwise, we print `Does not contain value`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要将参数定义为可选类型，我们在参数定义中使用问号。在这个示例中，我们使用可选绑定来检查可选是否包含值。如果包含值，我们在控制台打印`Contains value`；否则，我们打印`Does
    not contain value`。
- en: Optional types with tuples
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组中的可选类型
- en: 'We can define a whole tuple as an optional or any of the elements within a
    tuple as an optional. It is especially useful to use optionals with tuples when
    we return a tuple from a function or method. This allows us to return part (or
    all) of the tuples as nil. The following example shows how to define a tuple as
    an optional, and also how to define individual elements of a tuple as an optional
    type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将整个元组定义为可选的，或者将元组内的任何元素定义为可选的。当从函数或方法返回元组时，使用可选与元组结合特别有用。这允许我们返回元组的一部分（或全部）作为`nil`。以下示例展示了如何将元组定义为可选的，以及如何将元组的单个元素定义为可选类型：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line defines the whole tuple as an optional type. The second line
    defines the second value within the tuple as an optional, while the first value
    is a non-optional.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将整个元组定义为可选类型。第二行将元组内的第二个值定义为可选，而第一个值是非可选的。
- en: Optional chaining
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选链
- en: 'Optional binding allows us to unwrap one optional at a time, but what would
    happen if we had optional types embedded within other optional types? This would
    force us to have optional binding statements embedded within other optional binding
    statements. There is a better way to handle this by using optional chaining. Before
    we look at optional chaining, let''s see how this would work with optional binding:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定允许我们一次解包一个可选，但如果可选类型嵌套在其他可选类型中会怎样？这将迫使我们必须在其他可选绑定语句中嵌入可选绑定语句。有一种更好的方法来处理这个问题，那就是使用可选链。在我们查看可选链之前，让我们看看这是如何与可选绑定一起工作的：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we begin by defining a `Collar` class, which has one property
    defined. This property is named `color`, which is of the type string. We can see
    that the `color` property is not an optional; therefore, we can safely assume
    that it will always have a valid value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先定义一个`Collar`类，它有一个属性定义。这个属性名为`color`，其类型为字符串。我们可以看到`color`属性不是可选的；因此，我们可以安全地假设它将始终有一个有效的值。
- en: Next, we define a `Pet` class that has two properties defined. These properties
    are named `name` and `collar`. The `name` property is of the string type and the
    `collar` property is an optional that may contain a `Collar` type object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Pet`类，它有两个属性定义。这些属性分别命名为`name`和`collar`。`name`属性是字符串类型，而`collar`属性是可选的，可能包含一个`Collar`类型对象。
- en: Finally, we define the `Person` class that also has two properties. These properties
    are named `name` and `pet`. The `name` property is of the string type and the
    `pet` property is an optional that may contain a `Pet` type object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`Person`类，它也有两个属性。这些属性分别命名为`name`和`pet`。`name`属性是字符串类型，而`pet`属性是可选的，可能包含一个`Pet`类型对象。
- en: 'For the examples that follow, let''s use the following code to initialize the
    classes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的示例，让我们使用以下代码来初始化类：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s say that we want to get the color of the collar for a person''s
    pet; however, the person may not have a pet (the `pet` property is `nil`) or the
    pet may not have a collar (the `collar` property is `nil`). We could use optional
    binding to drill down through each layer, as shown in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想获取某人的宠物的颜色；然而，这个人可能没有宠物（`pet` 属性为 `nil`）或者宠物可能没有项圈（`collar` 属性为 `nil`）。我们可以使用可选绑定来钻入每一层，如下例所示：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While this example is perfectly valid and would print out the message, `The
    color of the collar is red`, the code is rather messy and hard to follow because
    we have optional binding statements embedded within other optional binding statements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子完全有效，并且会打印出消息“The color of the collar is red”，但代码相当混乱且难以理解，因为我们嵌套了可选绑定语句。
- en: Optional chaining allows us to drill down through multiple optional type layers
    of properties, methods, and subscripts in one line of code. These layers can be
    chained together and if any layer returns a `nil`, the entire chain gracefully
    fails and returns nil. If none of the values return `nil`, the last value of the
    chain is returned. Since the results of optional chaining may be a `nil` value,
    the results are always returned as an optional type, even if the final value we
    are retrieving is a non-optional type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链允许我们在一行代码中钻入多个可选类型层级的属性、方法和子脚本。这些层级可以连在一起，如果任何一层返回 `nil`，整个链将优雅地失败并返回 `nil`。如果没有值返回
    `nil`，则返回链的最后一个值。由于可选链的结果可能是一个 `nil` 值，结果总是以可选类型返回，即使我们检索的最终值不是可选类型。
- en: 'To specify optional chaining, we will place a question mark (`?`) after each
    of the optional values within the chain. The following example shows how to use
    optional chaining to make the preceding example much cleaner and easier to read:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定可选链，我们将在链中的每个可选值后面放置一个问号 (`?`)。以下示例展示了如何使用可选链使前一个示例更简洁、更容易阅读：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we put a question mark after the `pet` and `collar` properties
    to signify that they are of the optional type and if either value is `nil`, the
    whole chain will return `nil`. This code would also print out the message, `The
    color of the collar is red`; however, it is much easier to read than the preceding
    example that used optional binding.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `pet` 和 `collar` 属性后面加上问号，表示它们是可选类型，如果任一值是 `nil`，整个链将返回 `nil`。这段代码也会打印出消息“The
    color of the collar is red”；然而，它比使用可选绑定的前一个例子更容易阅读。
- en: The nil coalescing operator
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并运算符
- en: The nil coalescing operator is similar to the ternary operator that we discussed
    in [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants, Strings,
    and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    of this book. The ternary operator assigns a value to a variable, based on the
    evaluation of a comparison operator or a Boolean value. The nil coalescing operator
    unwraps an optional, and if it contains a value, it will return that value, or
    a default value if the optional is `nil`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符与我们在本书第 2 章[学习变量、常量、字符串和运算符](ch02.html "Chapter 2. Learning about Variables,
    Constants, Strings, and Operators")中讨论的三元运算符类似。三元运算符根据比较运算符或布尔值的评估给变量赋值。空值合并运算符解包可选值，如果它包含一个值，则返回该值，如果可选值为
    `nil`，则返回默认值。
- en: 'Let''s look at a prototype for the nil coalescing operator:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看空值合并运算符的原型：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we demonstrate the nil coalescing operator when the optional
    contains a nil and also when it contains a value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们演示了当可选值包含 `nil` 和包含值时如何使用空值合并运算符：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we begin by initializing our `defaultName` variable to `Jon`.
    We then define two optionals that are named `optionalA` and `optionalB`. The `optionalA`
    variable will be set to `nil` while the `optionalB` variable is set to `Buddy`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先将 `defaultName` 变量初始化为 `Jon`。然后我们定义了两个名为 `optionalA` 和 `optionalB`
    的可选值。`optionalA` 变量将被设置为 `nil`，而 `optionalB` 变量将被设置为 `Buddy`。
- en: The nil coalescing operator is used in the final two lines. Since the `optionalA`
    variable contains a `nil`, the `nameA` variable will be set to the value of the
    `defaultName` variable, which is `Jon`. The `nameB` variable will be set to the
    value of the `optionalB` variable as it contains a value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: nil 合并运算符在最后两行中使用。由于 `optionalA` 变量包含一个 `nil`，`nameA` 变量将被设置为 `defaultName`
    变量的值，即 `Jon`。`nameB` 变量将被设置为 `optionalB` 变量的值，因为它包含一个值。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While the concept of optional types, as used in the Swift language, might seem
    a little foreign at first, the more you use them, the more they will make sense.
    One of the biggest advantages with optional types is we get additional compile
    time checks that alert us if we forget to initialize non-optionals prior to using
    them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 语言中使用的可选类型的概念一开始可能有些陌生，但随着你使用它们的频率增加，它们会变得更加有意义。可选类型的一个最大优点是我们得到了额外的编译时检查，这会提醒我们在使用之前是否忘记初始化非可选变量。
- en: The one thing to take away from this chapter is the concept of what optionals
    are. To reinforce this concept, let's review a couple of paragraphs from this
    chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要掌握的一个要点是可选的概念。为了加强这个概念，让我们回顾一下本章的一些段落。
- en: It is very important to understand that nil in Swift is very different than
    nil in Objective-C. In Objective-C, nil is a pointer to a non-existent object;
    however, in Swift nil is an absence of a value. This concept is very important
    to fully understand optionals in Swift.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解 Swift 中的 nil 与 Objective-C 中的 nil 非常不同。在 Objective-C 中，nil 是一个指向不存在对象的指针；然而，在
    Swift 中 nil 是一个值的缺失。这个概念对于完全理解 Swift 中的可选类型非常重要。
- en: A variable defined as an optional can contain a valid value or it can be absent
    of a value. We set a variable to a valueless state by assigning it Swift's special
    nil value. Optionals of any type can be set to nil, whereas in Objective-C, only
    objects could be set to nil.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 被定义为可选的变量可以包含一个有效值，或者它可能没有值。我们通过将 Swift 的特殊 nil 值赋给变量来设置变量为无值状态。任何类型的可选变量都可以设置为
    nil，而在 Objective-C 中，只有对象可以被设置为 nil。
- en: The optional type is an enumeration with two possible values, `None` and `Some
    (T)`, where `T` is the associated value of the appropriate type. If we set the
    optional to `nil`, it will have a value of `None`, and if we set a value, the
    optional will have a value of `Some` with an associated value of the appropriate
    type. In [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants,
    Strings, and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    we explained that an enum in Swift may have associated values. Associated values
    allow us to store additional information along with the enum's member value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型是一个有两个可能值的枚举，`None` 和 `Some (T)`，其中 `T` 是相关类型的关联值。如果我们将可选设置为 `nil`，它将具有
    `None` 的值，如果我们设置一个值，可选将具有 `Some` 的值，并带有相关类型的关联值。在 [第 2 章](ch02.html "第 2 章。学习变量、常量、字符串和运算符")，*学习变量、常量、字符串和运算符*
    中，我们解释了 Swift 中的枚举可以有关联值。关联值允许我们在枚举成员值中存储额外的信息。
