- en: Chapter 10. Using Optional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started using Swift, the concept that I had the most trouble with
    was optional types. Coming from an Objective-C, C, Java, and Python background,
    I was able to relate to most of Swift's features to how things worked in one of
    the other languages that I knew, but optionals were different. There really was
    nothing like optionals in the other languages that I used, so it took a lot of
    reading to fully understand them. While I briefly covered optionals in [Chapter
    2](ch02.html "Chapter 2. Learning about Variables, Constants, Strings, and Operators"),
    *Learning about Variables, Constants, Strings, and Operators*, which gave enough
    of an overview to get started with, we need to cover a lot more information to
    really understand what optionals are, how to properly use them, and why they are
    so important in the Swift language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to optional types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for optional types in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrapping an optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare variables in Swift, they are, by default, non-optional, which
    means that they must contain a valid, non-nil value. If we try to set a non-optional
    variable to nil, it will result in a `Type '{type}' does not conform to protocol
    'NilLiteralConvertible'` error, where `{type}` is the type of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will throw an error when we attempt to set
    the `message` variable to `nil` because `message` is a non-optional type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to understand that nil in Swift is very different from
    nil in Objective-C. In Objective-C, nil is a pointer to non-existent object; however,
    in Swift, nil is the absence of a value. This concept is very important to fully
    understand optionals in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined as an optional can contain a valid value or it can indicate
    an absence of a value. We indicate an absence of a value by assigning it a special
    nil value. Optionals of any type can be set to nil, whereas in Objective-C, only
    objects can be set to nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'To really understand the concept behind optionals, let''s look at a line of
    code that defines an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The question mark at the end indicates that the `myString` variable is an optional.
    When we look at this code, it would be wrong to read this line of code as "the
    `myString` variable is a string type that is optional". We should actually read
    this line of code as "the `myString` variable is an optional type, which may contain
    a string type or may contain no value". The subtle difference between the two
    lines actually makes a big difference in understanding how optionals work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionals are a special type in Swift. When we defined the `myString` variable,
    we actually defined it as an optional type. To understand this, let''s look at
    some more code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two declarations are equivalent. Both lines declare an optional type that
    may contain a string type or may be absent of a value. In Swift, we can think
    of the absence of a value as being set to nil, but always remember that this is
    different than setting something to nil in Objective-C. In this book, when we
    refer to nil, we are referring to how Swift uses nil and not how Objective-C uses
    nil.
  prefs: []
  type: TYPE_NORMAL
- en: The optional type is an enumeration with two possible values, `None` and `Some(T)`,
    where `T` is the associated value of the appropriate type. If we set the optional
    to `nil`, then it will have a value of `None`, and if we set a value, then the
    optional will have a value of `Some` with an associated value of the appropriate
    type. In [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants,
    Strings, and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    we explained that an enum in Swift may have associated values. Associated values
    allow us to store additional information along with the enum's member value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, an optional is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `T` is the type to associate with the optional. The `T` symbol is used
    to define a generic. We can read more about generics in [Chapter 11](ch11.html
    "Chapter 11. Working with Generics"), *Working with Generics*.
  prefs: []
  type: TYPE_NORMAL
- en: The need for optional types in Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the burning question is why does Swift need optionals? To understand why
    Swift has optionals, we should examine what problems optionals are designed to
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most languages, it is possible to create a variable without giving it an
    initialized value. For example, in Objective-C, both lines of code are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that the `MyObject` class has the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes the value passed in from the `i` parameter, multiplies it
    by 2, and returns the results. Let''s try to call this method using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first thought might be that this code would display `Value: 10`; however,
    this would be wrong. In reality, this code would display `Value: 0` because we
    did not initialize the `m` object prior to using it.'
  prefs: []
  type: TYPE_NORMAL
- en: When we forget to initialize an object or set a value for a variable, we can
    get unexpected results at runtime, as we just demonstrated. The unexpected results
    can be, at times, very difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: 'With optionals, Swift is able to detect problems like this at compile time
    and alert us at runtime. If we expect a variable or object to always contain a
    value prior to using it, we will declare the variable as a non-optional (this
    is the default declaration). Then, at compile time, we would receive an error
    if we try to use it prior to initializing it. Let''s look at an example of this.
    The following code would display an error at compile time because we are attempting
    to use a non-optional variable prior to initialize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If a variable is declared as an optional, it is good programming practice to
    verify that it contains a valid value before attempting to use it. We should only
    declare a variable as an optional if there is a valid reason for the variable
    to contain no value. This is the reason Swift declares variables a non-optional
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we (hopefully) have a good understanding of what optionals are and
    what types of problems they are designed to solve, let's look at how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, to define an optional type, we put a question mark after the type
    in the variable declaration. Keep in mind that the type we define in the variable''s
    declaration is actually the associated value in the optional enum. The following
    code shows us how we would typically declare an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code declares an optional variable that might contain a string or no value
    (nil). When a variable is declared like this, by default, it is set to no value.
  prefs: []
  type: TYPE_NORMAL
- en: Using optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways that we can use optionals within our code. The key
    to using optionals is to always verify that they contain a valid value prior to
    accessing it. We use the unwrapping term to refer to retrieve the value of an
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: Forced unwrapping an optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To unwrap or retrieve the value of an optional, we place an exclamation mark
    (`!`) after the variable name. Forced unwrapping, in this manner, can be very
    dangerous and should be used only if we are certain that the value is not nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the exclamation mark to unwrap an optional, we are telling the
    compiler that we know the optional does not contain a nil value, so go ahead and
    give us the value. Let''s look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will work as we expect it to, where the `test` variable will contain
    the `test` string; however, if the line that set the `myString1` optional to `test`
    was removed, we would receive a runtime error when we run the application. Note
    that the compiler will not alert us of an issue because we are using the exclamation
    point to unwrap the optional; therefore, the compiler assumes that we know what
    we are doing and will happily compile the code for us. We should verify that the
    `myString1` optional contains a valid value prior to unwrapping it. The following
    example is one way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the line that sets the `myString1` optional to `test` was removed, we
    would not receive a runtime error because we are only unwrapping the `myString`
    optional, if it contains a valid (non-nil) value.
  prefs: []
  type: TYPE_NORMAL
- en: Unwrapping optionals, as we just described, is not the most optimal way, and
    it is not recommended that we unwrap optionals in this manner. We can combine
    the verification and unwrapping into one step called **optional binding**.
  prefs: []
  type: TYPE_NORMAL
- en: Optional binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optional binding is the recommended way to unwrap an optional. With optional
    binding, we perform a check to see whether the optional contains a valid value
    and, if so, unwrap it into a temporary variable or constant. This is all performed
    in one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional binding is performed with the `if` or `while` conditional statements.
    It takes the following format if we want to put the value of the optional in a
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to put the value in a variable, instead of a constant, we can use
    the `var` keyword instead of the `let` keyword, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to perform optional binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we define the `myString3` variable as an optional type. If the
    `myString3` optional contains a valid value, then we set the new variable named
    `tempvar` to the value of the `myString3` optional and print the value to the
    console. If the `myString3` optional does not contain a value, then we print `No`
    value to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Swift 1.2, we are able to use optional binding to unwrap multiple
    optionals within the same optional binding line. For example, if we had three
    optionals named `optional1`, `optional2` and `optional3`, we could use the following
    code to attempt to unwrap all the three at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If any of the three optionals failed to unwrap, the whole optional binding statement
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is perfectly acceptable with optional binding to assign the value to a variable
    of the same name. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that the `temp` variable is scoped only for the conditional
    block and cannot be used outside the conditional block. To illustrate the scope
    of the temporary variable, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code would not compile because the `tmp` variable is only valid within
    the conditional block and we are attempting to use it outside of the conditional
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Using optional binding is a lot cleaner and easier than manually verifying that
    the optional has a value and then forcing the unwrapping of the optional.
  prefs: []
  type: TYPE_NORMAL
- en: Returning optionals from functions, methods, and subscripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can set the return type of a function or a method to the optional type. This
    allows us to return a nil (no value) from the function or method. To set the return
    type to an optional type, we will insert a question mark after the name of the
    type in the function or method declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows us how we will return an optional from a function
    or method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we defined the return type as an optional that can be either
    a string value or no value. Inside the function, we will return the name if the
    index is within the bounds of the array, or `nil` if it is outside the bounds
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to call this function where the return value is
    an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `name` variable will contain `Kailey`, while the `name2`
    variable will contain `nil` (no value). Note that we do not have to define the
    variable as an optional (with a question mark) since Swift knows it is an optional
    type because that is the return type defined by the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a subscript that returns an optional type. We define a subscript
    as an optional exactly like we defined functions. Here is an example template
    of a subscript that returns an optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this definition, we are able to return a `nil` (no value) from our subscript.
  prefs: []
  type: TYPE_NORMAL
- en: Using optionals as a parameter in a function or method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also accept an optional as a parameter to a function or a method. This
    allows us to have the option of passing a nil (no value) into a function or method
    if required. The following example shows how to define an optional parameter for
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To define a parameter as an optional type, we use the question mark within the
    parameter definition. Within this example, we use optional binding to check whether
    the optional contains a value or not. If it contains a value, we print `Contains
    value to the console;` otherwise, we print `Does not contain value`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional types with tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define a whole tuple as an optional or any of the elements within a
    tuple as an optional. It is especially useful to use optionals with tuples when
    we return a tuple from a function or method. This allows us to return part (or
    all) of the tuples as nil. The following example shows how to define a tuple as
    an optional, and also how to define individual elements of a tuple as an optional
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines the whole tuple as an optional type. The second line
    defines the second value within the tuple as an optional, while the first value
    is a non-optional.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Optional binding allows us to unwrap one optional at a time, but what would
    happen if we had optional types embedded within other optional types? This would
    force us to have optional binding statements embedded within other optional binding
    statements. There is a better way to handle this by using optional chaining. Before
    we look at optional chaining, let''s see how this would work with optional binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by defining a `Collar` class, which has one property
    defined. This property is named `color`, which is of the type string. We can see
    that the `color` property is not an optional; therefore, we can safely assume
    that it will always have a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define a `Pet` class that has two properties defined. These properties
    are named `name` and `collar`. The `name` property is of the string type and the
    `collar` property is an optional that may contain a `Collar` type object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define the `Person` class that also has two properties. These properties
    are named `name` and `pet`. The `name` property is of the string type and the
    `pet` property is an optional that may contain a `Pet` type object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the examples that follow, let''s use the following code to initialize the
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we want to get the color of the collar for a person''s
    pet; however, the person may not have a pet (the `pet` property is `nil`) or the
    pet may not have a collar (the `collar` property is `nil`). We could use optional
    binding to drill down through each layer, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While this example is perfectly valid and would print out the message, `The
    color of the collar is red`, the code is rather messy and hard to follow because
    we have optional binding statements embedded within other optional binding statements.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining allows us to drill down through multiple optional type layers
    of properties, methods, and subscripts in one line of code. These layers can be
    chained together and if any layer returns a `nil`, the entire chain gracefully
    fails and returns nil. If none of the values return `nil`, the last value of the
    chain is returned. Since the results of optional chaining may be a `nil` value,
    the results are always returned as an optional type, even if the final value we
    are retrieving is a non-optional type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify optional chaining, we will place a question mark (`?`) after each
    of the optional values within the chain. The following example shows how to use
    optional chaining to make the preceding example much cleaner and easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we put a question mark after the `pet` and `collar` properties
    to signify that they are of the optional type and if either value is `nil`, the
    whole chain will return `nil`. This code would also print out the message, `The
    color of the collar is red`; however, it is much easier to read than the preceding
    example that used optional binding.
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nil coalescing operator is similar to the ternary operator that we discussed
    in [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants, Strings,
    and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    of this book. The ternary operator assigns a value to a variable, based on the
    evaluation of a comparison operator or a Boolean value. The nil coalescing operator
    unwraps an optional, and if it contains a value, it will return that value, or
    a default value if the optional is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a prototype for the nil coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we demonstrate the nil coalescing operator when the optional
    contains a nil and also when it contains a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we begin by initializing our `defaultName` variable to `Jon`.
    We then define two optionals that are named `optionalA` and `optionalB`. The `optionalA`
    variable will be set to `nil` while the `optionalB` variable is set to `Buddy`.
  prefs: []
  type: TYPE_NORMAL
- en: The nil coalescing operator is used in the final two lines. Since the `optionalA`
    variable contains a `nil`, the `nameA` variable will be set to the value of the
    `defaultName` variable, which is `Jon`. The `nameB` variable will be set to the
    value of the `optionalB` variable as it contains a value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the concept of optional types, as used in the Swift language, might seem
    a little foreign at first, the more you use them, the more they will make sense.
    One of the biggest advantages with optional types is we get additional compile
    time checks that alert us if we forget to initialize non-optionals prior to using
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The one thing to take away from this chapter is the concept of what optionals
    are. To reinforce this concept, let's review a couple of paragraphs from this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that nil in Swift is very different than
    nil in Objective-C. In Objective-C, nil is a pointer to a non-existent object;
    however, in Swift nil is an absence of a value. This concept is very important
    to fully understand optionals in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined as an optional can contain a valid value or it can be absent
    of a value. We set a variable to a valueless state by assigning it Swift's special
    nil value. Optionals of any type can be set to nil, whereas in Objective-C, only
    objects could be set to nil.
  prefs: []
  type: TYPE_NORMAL
- en: The optional type is an enumeration with two possible values, `None` and `Some
    (T)`, where `T` is the associated value of the appropriate type. If we set the
    optional to `nil`, it will have a value of `None`, and if we set a value, the
    optional will have a value of `Some` with an associated value of the appropriate
    type. In [Chapter 2](ch02.html "Chapter 2. Learning about Variables, Constants,
    Strings, and Operators"), *Learning about Variables, Constants, Strings, and Operators*,
    we explained that an enum in Swift may have associated values. Associated values
    allow us to store additional information along with the enum's member value.
  prefs: []
  type: TYPE_NORMAL
