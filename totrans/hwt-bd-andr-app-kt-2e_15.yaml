- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecture Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to architectural patterns you can use for your
    Android projects. It covers using the **Model-View-ViewModel** (**MVVM**) pattern,
    adding ViewModels, and using data binding. You will also learn about using the
    Repository pattern for caching data and WorkManager for scheduling data retrieval
    and storage.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to structure your Android project
    using MVVM and data binding. You will also be able to use the Repository pattern
    with the Room library to cache data and WorkManager to fetch and save data at
    a scheduled interval.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about using Coroutines and Flow for background
    operations and data manipulation. Now, you will learn about architectural patterns
    so you can improve your application.
  prefs: []
  type: TYPE_NORMAL
- en: When developing an Android application, you may tend to write most of the code
    (including business logic) in activities or fragments. This will make your project
    hard to test and maintain later. As your project grows and becomes more complex,
    the difficulty also increases. You can improve your projects with architectural
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns are general solutions for designing and developing parts
    of applications, especially for large apps. There are architectural patterns you
    can use to structure your project into different layers (the presentation layer,
    the **user interface** (**UI**) layer, and the data layer) or functions (observer/observable).
    With architectural patterns, you can organize your code in a way that makes it
    easier for you to develop, test, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: For Android development, commonly used patterns include **Model-View-Controller**
    (**MVC**), **Model-View-Presenter** (**MVP**), and MVVM. The recommended architectural
    pattern is MVVM, which will be discussed in this chapter. You will also learn
    about data binding, the Repository pattern using the Room library, and WorkManager.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding data on Android with data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Retrofit and Moshi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WorkManager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/PZNNT](https://packt.link/PZNNT)
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVVM allows you to separate the UI and business logic. When you need to redesign
    the UI or update the Model/business logic, you only need to touch the relevant
    component without affecting the other components of your app. This will make it
    easier for you to add new features and test your existing code. MVVM is also useful
    in creating huge applications that use a lot of data and views.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the MVVM architectural pattern, your application will be grouped into
    three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This represents the data layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This is the UI that displays the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model` and provides it to `View`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MVVM architectural pattern can be understood better through the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – The MVVM architectural pattern](img/B19411_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – The MVVM architectural pattern
  prefs: []
  type: TYPE_NORMAL
- en: The Model contains the data of the application. The activities, fragments, and
    layouts that your users see and interact with are the Views in MVVM. Views only
    deal with how the app looks. They let `ViewModel` know about user actions (such
    as opening an activity or clicking on a button).
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel links `View` and `Model`. ViewModels also perform the business logic
    processing and transform them for display in the View. Views subscribe to the
    ViewModel and update the UI when a value changes.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Jetpack’s ViewModel to create the ViewModel classes for your app.
    Jetpack’s ViewModel manages its own lifecycle so you don’t need to handle it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add ViewModel to your project by adding the following code in your
    `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you’re working on an app that displays movies, you could have
    `MovieViewModel`. This ViewModel will have a function that fetches a list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In your activity, you can create ViewModel using `ViewModelProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can connect to the `movies` Flow from `ViewModel` and automatically
    update the list on the UI when the list of movies changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Views are notified when values in `ViewModel` have changed. You can also use
    data binding to connect `View` with the data from `ViewModel`. You will learn
    more about data binding in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Binding data on Android with data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: View binding and data binding are two ways to bind data to Android Views. View
    binding is a simpler and faster binding, which you can use to replace `findViewById`
    in your code. Data binding is more powerful and can be customized to connect your
    data with layout variables and expressions.
  prefs: []
  type: TYPE_NORMAL
- en: With data binding, you can link the views in your layout to data from a source
    such as a ViewModel. Instead of adding code to find the views in the layout file
    and updating them when the value from the ViewModel changes, data binding can
    handle that for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use data binding in your Android project, you should add the following in
    the `android` block of the `app/build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `layout` file, you must wrap the root element with a `layout` tag. Inside
    the `layout` tag, you need to define the `data` element for the data to be bound
    to this `layout` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `movie` layout variable represents the `com.example.model.Movie` class
    that will be displayed in the layout. To set the attribute to fields in the data
    model, you need to use the `@{}` syntax. For example, to use the movie’s title
    as the text value of `TextView`, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to change your activity file. If your `layout` file is named
    `activity_movies.xml`, the data binding library will generate a `binding` class
    named `ActivityMoviesBinding` in your project’s build files. In the activity,
    you can replace the `setContentView(R.layout.activity_movies)` line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `inflate` method of the `binding` class or the `DataBindingUtil`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can set the `movie` instance to bind in the layout with the `layout`
    variable named `movie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using `LiveData` or `Flow` as the item to bind to the layout, you
    need to set `lifeCycleOwner` for the `binding` variable. `lifeCycleOwner` specifies
    the scope of the object. You can use the activity as `lifeCycleOwner` of the `binding`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this, when the values in `ViewModel` change their value, `View` will automatically
    update with the new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You set the movie title in `TextView` with `android:text="@{movie.title}"`.
    The data binding library has default binding adapters that handle the binding
    to the `android:text` attribute. Sometimes, there are no default attributes that
    you can use. You can create your own binding adapter. For example, if you want
    to bind the list of movies for `RecyclerView`, you can create a custom `BindingAdapter`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow you to add an `app:list` attribute to `RecyclerView` that accepts
    a list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try implementing data binding on an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.01– using data binding in an Android project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, you worked on an application that displays popular
    movies using the Movie Database API. For this chapter, you will be improving the
    app using MVVM. You can use the `Popular Movies` project from the previous chapter
    or make a copy of it. In this exercise, you will add data binding to bind the
    list of movies from `ViewModel` to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file and add the following in the `android` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This enables data binding for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `kotlin-kapt` plugin at the end of the plugins block in your `app/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `kotlin-kapt` plugin is the Kotlin annotation processing tool, which is
    needed for using data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `RecyclerViewBinding` that contains the binding adapter
    for the `RecyclerView` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow you to add an `app:list` attribute for `RecyclerView` where
    you can pass the list of movies to be displayed. The list of movies will be set
    to the adapter, updating `RecyclerView` in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file and wrap everything inside a `layout` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, the data binding library will be able to generate a binding class
    for this layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `layout` tag and before the `ConstraintLayout` tag, add a data element
    with a variable for `viewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a `viewModel` layout variable that corresponds to your `MovieViewModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `RecyclerView`, add the list to be displayed with `app:list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`popularMovies` from `MovieViewModel.getPopularMovies` will be passed as the
    list of movies for `RecyclerView`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MainActivity`. In the `onCreate` function, replace the `setContentView`
    line with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets the `layout` file to be used and creates a binding object.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the collection of `popularMoviesView` from `movieViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following after the initialization of `movieViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This binds `movieViewModel` to the `viewModel` layout variable in the `activity_main.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. It should work as usual, displaying the list of popular
    movies, where clicking on one will open the details of the movie selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2 – The main screen (left) with the year’s popular movies and the
    details screen (right) with more information about the selected movie](img/B19411_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – The main screen (left) with the year’s popular movies and the
    details screen (right) with more information about the selected movie
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have used data binding on an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding links the Views to the ViewModel. The ViewModel retrieves the data
    from the Model. Some of the libraries you can use to fetch data are Retrofit and
    Moshi, which you will learn more about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Retrofit and Moshi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When connecting to your remote network, you can use Retrofit. Retrofit is an
    HTTP client that makes it easy to implement creating requests and retrieving responses
    from your backend server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add Retrofit to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can then convert the JSON response from Retrofit by using Moshi, a library
    for parsing JSON into Java objects. For example, you can convert the JSON string
    response from getting the list of movies into a `ListofMovie` object for display
    and storage in your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the Moshi Converter to your project by adding the following code
    to your `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In your Retrofit builder code, you can call `addConverterFactory` and pass
    `Moshi``ConverterFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can call the data layer from the ViewModel. To reduce its complexity, you
    can use the Repository pattern for loading and caching data. You will learn about
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of `ViewModel` directly calling the services for getting and storing
    data, it should delegate that task to another component, such as a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Repository pattern, you can move the code in the `ViewModel` that
    handles the data layer into a separate class. This reduces the complexity of `ViewModel`,
    making it easier to maintain and test. The repository will manage where the data
    is fetched and stored, just as if the local database or the network service were
    used to get or store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – ViewModel with the Repository pattern](img/B19411_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – ViewModel with the Repository pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ViewModel`, you can add a property for the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewModel` will get the movies from the repository, or it can listen to them.
    It will not know where you actually got the list from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a repository interface that connects to a data source, such
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `MovieRepository` interface has a `getMovies` function that your repository
    implementation class will override to fetch movies from the data source. You can
    also have a single repository class that handles the fetching of data from either
    the local database or from your remote endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: When using the local database as the data source for your repository, you can
    use the Room library, which makes it easier for you to work with the SQLite database
    by writing less code and having compile-time checks on queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add Room to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try adding the Repository pattern with Room to an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.02 – using Repository with Room in an Android project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have added data binding in the `Popular Movies` project in the previous
    exercise. In this exercise, you will update the app with the Repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'When opening the app, it fetches the list of movies from the network. This
    takes a while. You will cache this data into the local database every time you
    fetch them. When the user opens the app next time, the app will immediately display
    the list of movies from the database on the screen. You will be using Room for
    data caching:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Popular Movies` project that you used in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file and add the dependencies for the Room library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Movie` class and add an `Entity` annotation for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Entity` annotation will create a table named `movies` for the list of movies.
    It also sets `id` as the primary key of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a new package called `com.example.popularmovies.database`. Create a `MovieDao`
    data access object for accessing the `movies` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class contains a function for adding a list of movies in the database and
    another for getting all the movies from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `MovieDatabase` class in the `com.example.popularmovies.database`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This database has a version of `1`, a single entity for `Movie`, and the data
    access object for the movies. It also has a `getInstance` function to generate
    an instance of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `MovieRepository` class with constructors for `movieDatabase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `fetchMovies` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will fetch the movies from the database. If there’s nothing saved yet, it
    will retrieve the list from the network endpoint and then save it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MovieApplication` and in the `onCreate` function, replace the `movieRepository`
    initialization with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application. It will display the list of popular movies, and clicking
    on one will open the details of the movie selected. If you turn off mobile data
    or disconnect from the wireless network, it will still display the list of movies,
    which is now cached in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The Popular Movies app using Repository with Room](img/B19411_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The Popular Movies app using Repository with Room
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have improved the app by moving the loading and storing
    of data into a repository. You have also used Room to cache the data.
  prefs: []
  type: TYPE_NORMAL
- en: The repository fetches the data from the data source. If there’s no data stored
    in the database yet, the app will call the network to request the data. This can
    take a while. You can improve the user experience by pre-fetching data at a scheduled
    time so the next time the user opens the app, they will already see the updated
    contents. You can do this with WorkManager, which we will discuss in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using WorkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WorkManager** is a Jetpack library for background operations that can be
    delayed and can run based on the constraints you set. It is ideal for doing something
    that must be run but can be done later or at regular intervals, regardless of
    whether the app is running or not.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use WorkManager to run tasks such as fetching the data from the network
    and storing it in your database at scheduled intervals. WorkManager will run the
    task even if the app has been closed or if the device restarts. This will keep
    your database up to date with your backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add WorkManager to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: WorkManager can call the repository to fetch and store data from either the
    local database or the network server.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try adding WorkManager to an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.03 – adding WorkManager to an Android Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you added the Repository pattern with Room to cache
    data in the local database. The app can now fetch the data from the database instead
    of the network. Now, you will be adding WorkManager to schedule a task for fetching
    data from the server and saving it to the database at scheduled intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Popular Movies project you used in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file and add the dependency for the WorkManager
    library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow you to add the WorkManager workers to your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MovieRepository` and add a suspending function for fetching movies from
    the network using `apiKey` from `movieDatabase` and saving them to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be the function that will be called by the `Worker` class that will
    be running to fetch and save the movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `MovieWorker` class in the `com.example.popularmovies` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MovieApplication` and at the end of the `onCreate` function, schedule
    `MovieWorker` to retrieve and save the movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This schedules `MovieWorker` to run every hour when the device is connected
    to the network. `MovieWorker` will fetch the list of movies from the network and
    save it to the local database.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application. Close it and make sure the device is connected to the internet.
    After more than an hour, open the application again and check whether the list
    of movies displayed has been updated. If not, try again in a few hours. The list
    of movies displayed will be updated regularly, around every hour, even if the
    app has been closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.5 – The Popular Movies app updates its list with WorkManager](img/B19411_15_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – The Popular Movies app updates its list with WorkManager
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you added WorkManager to your application to automatically
    update the database with the list of the movies retrieved from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 15.01 – revisiting the TV Guide app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, you developed an app that can display a list of TV
    shows that are on the air. The app had two screens: the main screen and the details
    screen. On the main screen, there’s a list of TV shows. When clicking on a TV
    show, the details screen will be displayed with the details of the selected show.'
  prefs: []
  type: TYPE_NORMAL
- en: When running the app, it takes a while to display the list of shows. Update
    the app to cache the list so it will be immediately displayed when opening the
    app. Also, improve the app by using MVVM with data binding and adding WorkManager.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the TV Guide app you worked on in the previous chapter or download
    it from the GitHub repository ([https://packt.link/Eti8M](https://packt.link/Eti8M)).
    The following steps will help guide you through this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the TV Guide app in Android Studio. Open the `app/build.gradle` file and
    add the `kotlin-kapt` plugin, the data binding dependency, and the dependencies
    for Room and WorkManager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a binding adapter class for `RecyclerView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `activity_main.xml`, wrap everything inside a `layout` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `layout` tag and before the `ConstraintLayout` tag, add a data element
    with a variable for `ViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `RecyclerView`, add the list to be displayed with `app:list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity`, replace the line for `setContentView` with the `DataBindingUtil.setContentView`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the observer from `TVShowViewModel` with the data binding code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Entity` annotation in the `TVShow` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVDao` data access object for accessing the `TV` `shows` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `TVDatabase` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `TVShowRepository` with a constructor for `tvDatabase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `fetchTVShows` function to get the TV shows from the local database.
    If there’s nothing there yet, retrieve the list from the endpoint and save it
    in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a suspending `fetchTVShowsFromNetwork` function to get the TV shows from
    the network and save them to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `TVShowWorker` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `TVApplication` file. In `onCreate`, schedule `TVShowWorker` to retrieve
    and save the shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the movie details. The
    main screen and details screen will be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The main screen and details screen of the TV Guide app](img/B19411_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – The main screen and details screen of the TV Guide app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focused on architectural patterns for Android. You started with
    the MVVM architectural pattern. You learned about its three components: the Model,
    the View, and the ViewModel. You also used data binding to link the View with
    the ViewModel.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned about how the Repository pattern can be used to cache data.
    Then, you learned about WorkManager and how you can schedule tasks such as retrieving
    data from the network and saving that data to the database to update your local
    data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to improve the look and design of your
    apps with animations. You will add animations and transitions to your apps with
    `CoordinatorLayout` and `MotionLayout`.
  prefs: []
  type: TYPE_NORMAL
