- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Architecture Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构模式
- en: This chapter will introduce you to architectural patterns you can use for your
    Android projects. It covers using the **Model-View-ViewModel** (**MVVM**) pattern,
    adding ViewModels, and using data binding. You will also learn about using the
    Repository pattern for caching data and WorkManager for scheduling data retrieval
    and storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍你可以用于你的 Android 项目的架构模式。它涵盖了使用 **模型-视图-视图模型**（**MVVM**）模式、添加视图模型和使用数据绑定。你还将了解使用存储库模式进行数据缓存和使用
    WorkManager 在计划的时间间隔内检索和存储数据。
- en: By the end of the chapter, you will be able to structure your Android project
    using MVVM and data binding. You will also be able to use the Repository pattern
    with the Room library to cache data and WorkManager to fetch and save data at
    a scheduled interval.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 MVVM 和数据绑定来构建你的 Android 项目结构。你还将能够使用 Room 库的存储库模式来缓存数据，并使用 WorkManager
    在计划的时间间隔内检索和存储数据。
- en: In the previous chapter, you learned about using Coroutines and Flow for background
    operations and data manipulation. Now, you will learn about architectural patterns
    so you can improve your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用协程和流进行后台操作和数据操作。现在，你将学习架构模式，以便你可以改进你的应用。
- en: When developing an Android application, you may tend to write most of the code
    (including business logic) in activities or fragments. This will make your project
    hard to test and maintain later. As your project grows and becomes more complex,
    the difficulty also increases. You can improve your projects with architectural
    patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Android 应用时，你可能倾向于在活动或片段中编写大部分代码（包括业务逻辑）。这将使你的项目在以后难以测试和维护。随着你的项目增长和变得更加复杂，难度也会增加。你可以通过使用架构模式来改进你的项目。
- en: Architectural patterns are general solutions for designing and developing parts
    of applications, especially for large apps. There are architectural patterns you
    can use to structure your project into different layers (the presentation layer,
    the **user interface** (**UI**) layer, and the data layer) or functions (observer/observable).
    With architectural patterns, you can organize your code in a way that makes it
    easier for you to develop, test, and maintain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 架构模式是设计和发展应用程序部分的一般解决方案，特别是对于大型应用。你可以使用架构模式将你的项目结构化成不同的层（表示层、**用户界面**（**UI**）层和数据层）或功能（观察者/可观察）。使用架构模式，你可以以使开发、测试和维护更容易的方式进行代码组织。
- en: For Android development, commonly used patterns include **Model-View-Controller**
    (**MVC**), **Model-View-Presenter** (**MVP**), and MVVM. The recommended architectural
    pattern is MVVM, which will be discussed in this chapter. You will also learn
    about data binding, the Repository pattern using the Room library, and WorkManager.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 开发，常用的模式包括 **模型-视图-控制器**（**MVC**）、**模型-视图-表示者**（**MVP**）和 MVVM。推荐的架构模式是
    MVVM，这将在本章中讨论。你还将了解数据绑定、使用 Room 库的存储库模式和工作管理器。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Getting started with MVVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 MVVM
- en: Binding data on Android with data binding
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 上使用数据绑定绑定数据
- en: Using Retrofit and Moshi
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Retrofit 和 Moshi
- en: Implementing the Repository pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现存储库模式
- en: Using WorkManager
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WorkManager
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/PZNNT](https://packt.link/PZNNT)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在 GitHub 上找到，网址为 [https://packt.link/PZNNT](https://packt.link/PZNNT)
- en: Getting started with MVVM
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 MVVM
- en: MVVM allows you to separate the UI and business logic. When you need to redesign
    the UI or update the Model/business logic, you only need to touch the relevant
    component without affecting the other components of your app. This will make it
    easier for you to add new features and test your existing code. MVVM is also useful
    in creating huge applications that use a lot of data and views.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 允许你分离 UI 和业务逻辑。当你需要重新设计 UI 或更新模型/业务逻辑时，你只需触摸相关组件，而不会影响你应用的其他组件。这将使你更容易添加新功能和测试现有代码。MVVM
    在创建使用大量数据和视图的巨大应用中也很有用。
- en: 'With the MVVM architectural pattern, your application will be grouped into
    three components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MVVM 架构模式，你的应用将被分为三个组件：
- en: '**Model**: This represents the data layer'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这代表数据层'
- en: '**View**: This is the UI that displays the data'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是显示数据的 UI'
- en: '`Model` and provides it to `View`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model` 和将其提供给 `View`'
- en: 'The MVVM architectural pattern can be understood better through the following
    diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下图表可以更好地理解MVVM架构模式：
- en: '![Figure 15.1 – The MVVM architectural pattern](img/B19411_15_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – MVVM架构模式](img/B19411_15_01.jpg)'
- en: Figure 15.1 – The MVVM architectural pattern
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – MVVM架构模式
- en: The Model contains the data of the application. The activities, fragments, and
    layouts that your users see and interact with are the Views in MVVM. Views only
    deal with how the app looks. They let `ViewModel` know about user actions (such
    as opening an activity or clicking on a button).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模型包含应用程序的数据。用户看到并与之交互的活动、片段和布局是MVVM中的视图。视图只处理应用程序的外观。它们让`ViewModel`知道用户操作（如打开活动或点击按钮）。
- en: ViewModel links `View` and `Model`. ViewModels also perform the business logic
    processing and transform them for display in the View. Views subscribe to the
    ViewModel and update the UI when a value changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel链接`View`和`Model`。ViewModel还执行业务逻辑处理，并将它们转换为在视图中显示。视图订阅ViewModel，并在值更改时更新UI。
- en: You can use Jetpack’s ViewModel to create the ViewModel classes for your app.
    Jetpack’s ViewModel manages its own lifecycle so you don’t need to handle it yourself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Jetpack的ViewModel为您的应用程序创建ViewModel类。Jetpack的ViewModel管理自己的生命周期，因此您不需要自己处理它。
- en: 'You can add ViewModel to your project by adding the following code in your
    `app/build.gradle` file dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在您的`app/build.gradle`文件中添加以下代码将ViewModel添加到项目中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, if you’re working on an app that displays movies, you could have
    `MovieViewModel`. This ViewModel will have a function that fetches a list of movies:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在开发一个显示电影的App，您可能有一个`MovieViewModel`。这个ViewModel将有一个函数来获取电影列表：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In your activity, you can create ViewModel using `ViewModelProvider`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的活动中，您可以使用`ViewModelProvider`创建ViewModel：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you can connect to the `movies` Flow from `ViewModel` and automatically
    update the list on the UI when the list of movies changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从`ViewModel`连接到`movies`Flow，并在电影列表更改时自动更新UI上的列表：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Views are notified when values in `ViewModel` have changed. You can also use
    data binding to connect `View` with the data from `ViewModel`. You will learn
    more about data binding in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ViewModel`中的值发生变化时，视图会收到通知。您还可以使用数据绑定将`View`与`ViewModel`中的数据连接起来。您将在下一节中了解更多关于数据绑定的信息。
- en: Binding data on Android with data binding
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据绑定在Android上绑定数据
- en: View binding and data binding are two ways to bind data to Android Views. View
    binding is a simpler and faster binding, which you can use to replace `findViewById`
    in your code. Data binding is more powerful and can be customized to connect your
    data with layout variables and expressions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 视图绑定和数据绑定是两种将数据绑定到Android视图的方法。视图绑定是一种更简单、更快的绑定方式，您可以使用它来替换代码中的`findViewById`。数据绑定功能更强大，可以自定义以将数据与布局变量和表达式连接起来。
- en: With data binding, you can link the views in your layout to data from a source
    such as a ViewModel. Instead of adding code to find the views in the layout file
    and updating them when the value from the ViewModel changes, data binding can
    handle that for you automatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据绑定，您可以将布局中的视图与来自源（如ViewModel）的数据连接起来。您不需要在布局文件中添加代码来查找视图并在ViewModel的值更改时更新它们，数据绑定可以自动为您处理这些操作。
- en: 'To use data binding in your Android project, you should add the following in
    the `android` block of the `app/build.gradle` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的Android项目中使用数据绑定，您应该在`app/build.gradle`文件的`android`块中添加以下内容：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `layout` file, you must wrap the root element with a `layout` tag. Inside
    the `layout` tag, you need to define the `data` element for the data to be bound
    to this `layout` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`layout`文件中，您必须使用`layout`标签包装根元素。在`layout`标签内部，您需要定义要绑定到此`layout`文件的数据的`data`元素：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `movie` layout variable represents the `com.example.model.Movie` class
    that will be displayed in the layout. To set the attribute to fields in the data
    model, you need to use the `@{}` syntax. For example, to use the movie’s title
    as the text value of `TextView`, you can use the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`movie`布局变量代表将在布局中显示的`com.example.model.Movie`类。要将属性设置为数据模型中的字段，您需要使用`@{}`语法。例如，要使用电影的标题作为`TextView`的文本值，您可以使用以下代码：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You also need to change your activity file. If your `layout` file is named
    `activity_movies.xml`, the data binding library will generate a `binding` class
    named `ActivityMoviesBinding` in your project’s build files. In the activity,
    you can replace the `setContentView(R.layout.activity_movies)` line with the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改你的活动文件。如果你的`layout`文件名为`activity_movies.xml`，数据绑定库将在你的项目构建文件中生成一个名为`ActivityMoviesBinding`的绑定类。在活动中，你可以将`setContentView(R.layout.activity_movies)`行替换为以下内容：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use the `inflate` method of the `binding` class or the `DataBindingUtil`
    class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`binding`类或`DataBindingUtil`类的`inflate`方法：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, you can set the `movie` instance to bind in the layout with the `layout`
    variable named `movie`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用名为“movie”的布局变量将“movie”实例绑定到布局中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are using `LiveData` or `Flow` as the item to bind to the layout, you
    need to set `lifeCycleOwner` for the `binding` variable. `lifeCycleOwner` specifies
    the scope of the object. You can use the activity as `lifeCycleOwner` of the `binding`
    class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`LiveData`或`Flow`作为绑定到布局的项目，你需要为`binding`变量设置`lifeCycleOwner`。`lifeCycleOwner`指定了对象的范围。你可以使用活动作为`binding`类的`lifeCycleOwner`：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this, when the values in `ViewModel` change their value, `View` will automatically
    update with the new values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当`ViewModel`中的值发生变化时，`View`将自动使用新值更新。
- en: 'You set the movie title in `TextView` with `android:text="@{movie.title}"`.
    The data binding library has default binding adapters that handle the binding
    to the `android:text` attribute. Sometimes, there are no default attributes that
    you can use. You can create your own binding adapter. For example, if you want
    to bind the list of movies for `RecyclerView`, you can create a custom `BindingAdapter`
    call:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`android:text="@{movie.title}"`在`TextView`中设置电影标题。数据绑定库有默认的绑定适配器，可以处理对`android:text`属性的绑定。有时，可能没有可用的默认属性。你可以创建自己的绑定适配器。例如，如果你想绑定`RecyclerView`的电影列表，你可以创建一个自定义的`BindingAdapter`调用：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will allow you to add an `app:list` attribute to `RecyclerView` that accepts
    a list of movies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你为`RecyclerView`添加一个接受电影列表的`app:list`属性：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s try implementing data binding on an Android project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在一个 Android 项目中实现数据绑定。
- en: Exercise 15.01– using data binding in an Android project
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.01 - 在 Android 项目中使用数据绑定
- en: 'In the previous chapter, you worked on an application that displays popular
    movies using the Movie Database API. For this chapter, you will be improving the
    app using MVVM. You can use the `Popular Movies` project from the previous chapter
    or make a copy of it. In this exercise, you will add data binding to bind the
    list of movies from `ViewModel` to the UI:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用 Movie Database API 开发了一个显示热门电影的程序。在本章中，你将使用 MVVM 来改进这个应用。你可以使用上一章的“热门电影”项目，或者复制它。在这个练习中，你将为从“ViewModel”到
    UI 绑定电影列表添加数据绑定：
- en: Open the `Popular Movies` project in Android Studio.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开“热门电影”项目。
- en: 'Open the `app/build.gradle` file and add the following in the `android` block:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/build.gradle`文件，并在`android`块中添加以下内容：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This enables data binding for your application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用你的应用程序的数据绑定。
- en: 'Add the `kotlin-kapt` plugin at the end of the plugins block in your `app/build.gradle`
    file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`app/build.gradle`文件中的插件块末尾添加`kotlin-kapt`插件：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `kotlin-kapt` plugin is the Kotlin annotation processing tool, which is
    needed for using data binding.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`kotlin-kapt`插件是 Kotlin 注解处理工具，它是使用数据绑定所必需的。'
- en: 'Create a new file called `RecyclerViewBinding` that contains the binding adapter
    for the `RecyclerView` list:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RecyclerViewBinding`的新文件，其中包含`RecyclerView`列表的绑定适配器：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will allow you to add an `app:list` attribute for `RecyclerView` where
    you can pass the list of movies to be displayed. The list of movies will be set
    to the adapter, updating `RecyclerView` in the UI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你为“RecyclerView”添加一个`app:list`属性，你可以传递要显示的电影列表。电影列表将被设置到适配器中，从而更新 UI 中的“RecyclerView”。
- en: 'Open the `activity_main.xml` file and wrap everything inside a `layout` tag:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，将所有内容包裹在一个`layout`标签内：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this, the data binding library will be able to generate a binding class
    for this layout.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，数据绑定库将能够为这个布局生成一个绑定类。
- en: 'Inside the `layout` tag and before the `ConstraintLayout` tag, add a data element
    with a variable for `viewModel`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`layout`标签和`ConstraintLayout`标签之前，添加一个数据元素，包含一个名为`viewModel`的变量：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This creates a `viewModel` layout variable that corresponds to your `MovieViewModel`
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个与你的`MovieViewModel`类对应的`viewModel`布局变量。
- en: 'In `RecyclerView`, add the list to be displayed with `app:list`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecyclerView` 中，使用 `app:list` 添加要显示的列表：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`popularMovies` from `MovieViewModel.getPopularMovies` will be passed as the
    list of movies for `RecyclerView`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`popularMovies` 从 `MovieViewModel.getPopularMovies` 将作为电影列表传递给 `RecyclerView`。'
- en: 'Open `MainActivity`. In the `onCreate` function, replace the `setContentView`
    line with the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity`。在 `onCreate` 函数中，将 `setContentView` 行替换为以下内容：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This sets the `layout` file to be used and creates a binding object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了要使用的 `layout` 文件并创建了一个绑定对象。
- en: Remove the collection of `popularMoviesView` from `movieViewModel`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `movieViewModel` 中删除 `popularMoviesView` 的集合。
- en: 'Add the following after the initialization of `movieViewModel`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `movieViewModel` 初始化之后添加以下代码：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This binds `movieViewModel` to the `viewModel` layout variable in the `activity_main.xml`
    file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `movieViewModel` 绑定到 `activity_main.xml` 文件中的 `viewModel` 布局变量。
- en: 'Run the application. It should work as usual, displaying the list of popular
    movies, where clicking on one will open the details of the movie selected:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。它应该像往常一样工作，显示热门电影的列表，点击其中一项将打开所选电影的详细信息：
- en: '![Figure 15.2 – The main screen (left) with the year’s popular movies and the
    details screen (right) with more information about the selected movie](img/B19411_15_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 主屏幕（左侧）显示当年的热门电影和详细信息屏幕（右侧）显示所选电影的更多信息](img/B19411_15_02.jpg)'
- en: Figure 15.2 – The main screen (left) with the year’s popular movies and the
    details screen (right) with more information about the selected movie
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 主屏幕（左侧）显示当年的热门电影和详细信息屏幕（右侧）显示所选电影的更多信息
- en: In this exercise, you have used data binding on an Android project.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经在 Android 项目中使用了数据绑定。
- en: Data binding links the Views to the ViewModel. The ViewModel retrieves the data
    from the Model. Some of the libraries you can use to fetch data are Retrofit and
    Moshi, which you will learn more about in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定将视图与 ViewModel 连接起来。ViewModel 从模型中检索数据。您可以使用的某些库来获取数据是 Retrofit 和 Moshi，您将在下一节中了解更多关于它们的信息。
- en: Using Retrofit and Moshi
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Retrofit 和 Moshi
- en: When connecting to your remote network, you can use Retrofit. Retrofit is an
    HTTP client that makes it easy to implement creating requests and retrieving responses
    from your backend server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到您的远程网络时，您可以使用 Retrofit。Retrofit 是一个 HTTP 客户端，它使实现向后端服务器发送请求和检索响应变得容易。
- en: 'You can add Retrofit to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `app/build.gradle` 文件依赖项中添加以下代码将 Retrofit 添加到您的项目中：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can then convert the JSON response from Retrofit by using Moshi, a library
    for parsing JSON into Java objects. For example, you can convert the JSON string
    response from getting the list of movies into a `ListofMovie` object for display
    and storage in your app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Moshi，一个将 JSON 解析为 Java 对象的库，将 Retrofit 的 JSON 响应进行转换。例如，您可以将获取电影列表的 JSON
    字符串响应转换为 `ListofMovie` 对象，以便在您的应用程序中进行显示和存储。
- en: 'You can add the Moshi Converter to your project by adding the following code
    to your `app/build.gradle` file dependencies:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `app/build.gradle` 文件依赖项中添加以下代码将 Moshi Converter 添加到您的项目中：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In your Retrofit builder code, you can call `addConverterFactory` and pass
    `Moshi``ConverterFactory`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Retrofit 构建器代码中，您可以调用 `addConverterFactory` 并传递 `MoshiConverterFactory`：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can call the data layer from the ViewModel. To reduce its complexity, you
    can use the Repository pattern for loading and caching data. You will learn about
    this in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 ViewModel 调用数据层。为了减少其复杂性，您可以使用 Repository 模式来加载和缓存数据。您将在下一节中了解这一点。
- en: Implementing the Repository pattern
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 Repository 模式
- en: Instead of `ViewModel` directly calling the services for getting and storing
    data, it should delegate that task to another component, such as a repository.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接由 `ViewModel` 调用获取和存储数据的服务，它应该将这项任务委托给另一个组件，例如仓库。
- en: 'With the Repository pattern, you can move the code in the `ViewModel` that
    handles the data layer into a separate class. This reduces the complexity of `ViewModel`,
    making it easier to maintain and test. The repository will manage where the data
    is fetched and stored, just as if the local database or the network service were
    used to get or store data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Repository 模式，您可以将处理数据层的代码从 `ViewModel` 中移动到单独的类。这减少了 `ViewModel` 的复杂性，使其更容易维护和测试。仓库将管理数据的获取和存储，就像使用本地数据库或网络服务来获取或存储数据一样：
- en: '![Figure 15.3 – ViewModel with the Repository pattern](img/B19411_15_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – 使用 Repository 模式的 ViewModel](img/B19411_15_03.jpg)'
- en: Figure 15.3 – ViewModel with the Repository pattern
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 带有Repository模式的ViewModel
- en: 'In `ViewModel`, you can add a property for the repository:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`中，你可以为仓库添加一个属性：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ViewModel` will get the movies from the repository, or it can listen to them.
    It will not know where you actually got the list from.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`将从仓库中获取电影，或者它可以监听它们。它将不知道你实际上是从哪里获取列表的。'
- en: 'You can create a repository interface that connects to a data source, such
    as in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个仓库接口，它连接到数据源，例如以下示例：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `MovieRepository` interface has a `getMovies` function that your repository
    implementation class will override to fetch movies from the data source. You can
    also have a single repository class that handles the fetching of data from either
    the local database or from your remote endpoint.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovieRepository`接口有一个`getMovies`函数，你的仓库实现类将覆盖它以从数据源获取电影。你也可以有一个单独的仓库类，它处理从本地数据库或远程端点获取数据。'
- en: When using the local database as the data source for your repository, you can
    use the Room library, which makes it easier for you to work with the SQLite database
    by writing less code and having compile-time checks on queries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用本地数据库作为仓库的数据源时，你可以使用Room库，这使你通过编写更少的代码并在编译时检查查询来更容易地与SQLite数据库一起工作。
- en: 'You can add Room to your project by adding the following code to your `app/build.gradle`
    file dependencies:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将以下代码添加到`app/build.gradle`文件中的依赖项来将Room添加到你的项目中：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s try adding the Repository pattern with Room to an Android project.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将Repository模式和Room添加到Android项目中。
- en: Exercise 15.02 – using Repository with Room in an Android project
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02 – 在Android项目中使用Room的Repository
- en: You have added data binding in the `Popular Movies` project in the previous
    exercise. In this exercise, you will update the app with the Repository pattern.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你已经在`热门电影`项目中添加了数据绑定。在这个练习中，你将使用Repository模式来更新应用。
- en: 'When opening the app, it fetches the list of movies from the network. This
    takes a while. You will cache this data into the local database every time you
    fetch them. When the user opens the app next time, the app will immediately display
    the list of movies from the database on the screen. You will be using Room for
    data caching:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开应用时，它会从网络上获取电影列表。这需要一些时间。每次你获取这些数据时，你都会将它们缓存到本地数据库中。当用户下次打开应用时，应用将立即在屏幕上显示从数据库获取的电影列表。你将使用Room进行数据缓存：
- en: Open the `Popular Movies` project that you used in the previous exercise.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在上一个练习中使用的`热门电影`项目。
- en: 'Open the `app/build.gradle` file and add the dependencies for the Room library:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/build.gradle`文件，并添加Room库的依赖项：
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the `Movie` class and add an `Entity` annotation for it:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Movie`类，并为它添加一个`Entity`注解：
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Entity` annotation will create a table named `movies` for the list of movies.
    It also sets `id` as the primary key of the table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`注解将为电影列表创建一个名为`movies`的表。它还将`id`设置为表的键。'
- en: 'Make a new package called `com.example.popularmovies.database`. Create a `MovieDao`
    data access object for accessing the `movies` table:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包`com.example.popularmovies.database`。为访问`movies`表创建一个`MovieDao`数据访问对象：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class contains a function for adding a list of movies in the database and
    another for getting all the movies from the database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含一个用于在数据库中添加电影列表的函数，以及一个用于从数据库获取所有电影的函数。
- en: 'Create a `MovieDatabase` class in the `com.example.popularmovies.database`
    package:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.popularmovies.database`包中创建一个`MovieDatabase`类：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This database has a version of `1`, a single entity for `Movie`, and the data
    access object for the movies. It also has a `getInstance` function to generate
    an instance of the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库有一个版本`1`，一个用于`Movie`的单个实体，以及电影的访问对象。它还有一个`getInstance`函数来生成数据库的实例。
- en: 'Update the `MovieRepository` class with constructors for `movieDatabase`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MovieRepository`类，为`movieDatabase`添加构造函数：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update the `fetchMovies` function:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`fetchMovies`函数：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It will fetch the movies from the database. If there’s nothing saved yet, it
    will retrieve the list from the network endpoint and then save it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从数据库中获取电影。如果没有保存任何内容，它将从一个网络端点检索列表并将其保存。
- en: 'Open `MovieApplication` and in the `onCreate` function, replace the `movieRepository`
    initialization with the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieApplication`，在`onCreate`函数中，将`movieRepository`的初始化替换为以下内容：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the application. It will display the list of popular movies, and clicking
    on one will open the details of the movie selected. If you turn off mobile data
    or disconnect from the wireless network, it will still display the list of movies,
    which is now cached in the database:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用。它将显示流行电影的列表，点击其中一个将打开所选电影的详细信息。如果你关闭移动数据或断开无线网络连接，它仍然会显示电影列表，这些电影现在已缓存在数据库中：
- en: '![Figure 15.4 – The Popular Movies app using Repository with Room](img/B19411_15_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – 使用 Repository 和 Room 的 Popular Movies 应用](img/B19411_15_04.jpg)'
- en: Figure 15.4 – The Popular Movies app using Repository with Room
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – 使用 Repository 和 Room 的 Popular Movies 应用
- en: In this exercise, you have improved the app by moving the loading and storing
    of data into a repository. You have also used Room to cache the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你通过将数据的加载和存储移动到仓库来改进了应用。你还使用了 Room 来缓存数据。
- en: The repository fetches the data from the data source. If there’s no data stored
    in the database yet, the app will call the network to request the data. This can
    take a while. You can improve the user experience by pre-fetching data at a scheduled
    time so the next time the user opens the app, they will already see the updated
    contents. You can do this with WorkManager, which we will discuss in the next
    section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库从数据源获取数据。如果数据库中还没有存储数据，应用将调用网络请求数据。这可能需要一段时间。你可以通过在预定时间预取数据来改善用户体验，这样当用户下次打开应用时，他们已经可以看到更新后的内容。你可以使用
    WorkManager 来实现这一点，我们将在下一节中讨论。
- en: Using WorkManager
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WorkManager
- en: '**WorkManager** is a Jetpack library for background operations that can be
    delayed and can run based on the constraints you set. It is ideal for doing something
    that must be run but can be done later or at regular intervals, regardless of
    whether the app is running or not.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**WorkManager** 是一个用于后台操作的 Jetpack 库，它可以延迟执行，可以根据你设置的约束条件运行。它非常适合执行必须运行但可以稍后或定期执行的任务，无论应用是否正在运行。'
- en: You can use WorkManager to run tasks such as fetching the data from the network
    and storing it in your database at scheduled intervals. WorkManager will run the
    task even if the app has been closed or if the device restarts. This will keep
    your database up to date with your backend.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 WorkManager 在预定的时间间隔运行任务，例如从网络获取数据并将其存储到你的数据库中。即使应用已被关闭或设备重启，WorkManager
    也会运行任务。这将确保你的数据库与后端保持最新。
- en: 'You can add WorkManager to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将以下代码添加到你的 `app/build.gradle` 文件依赖项中来将 WorkManager 添加到你的项目中：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: WorkManager can call the repository to fetch and store data from either the
    local database or the network server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: WorkManager 可以调用仓库从本地数据库或网络服务器获取和存储数据。
- en: Let’s try adding WorkManager to an Android project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将 WorkManager 添加到 Android 项目中。
- en: Exercise 15.03 – adding WorkManager to an Android Project
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.03 – 将 WorkManager 添加到 Android 项目
- en: 'In the previous exercise, you added the Repository pattern with Room to cache
    data in the local database. The app can now fetch the data from the database instead
    of the network. Now, you will be adding WorkManager to schedule a task for fetching
    data from the server and saving it to the database at scheduled intervals:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你通过 Room 将 Repository 模式添加到本地数据库中缓存数据。现在，应用可以从数据库而不是网络中获取数据。现在，你将添加
    WorkManager 来安排从服务器获取数据并将其保存到数据库的定时任务：
- en: Open the Popular Movies project you used in the previous exercise.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在上一个练习中使用的 Popular Movies 项目。
- en: 'Open the `app/build.gradle` file and add the dependency for the WorkManager
    library:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/build.gradle` 文件并添加 WorkManager 库的依赖项：
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will allow you to add the WorkManager workers to your app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你将 WorkManager 工作者添加到你的应用中。
- en: 'Open `MovieRepository` and add a suspending function for fetching movies from
    the network using `apiKey` from `movieDatabase` and saving them to the database:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieRepository` 并添加一个用于从网络使用 `movieDatabase` 中的 `apiKey` 获取电影并将其保存到数据库的挂起函数：
- en: '[PRE36]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will be the function that will be called by the `Worker` class that will
    be running to fetch and save the movies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是 `Worker` 类将要调用的函数，用于检索和保存电影。
- en: 'Create the `MovieWorker` class in the `com.example.popularmovies` package:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.popularmovies` 包中创建 `MovieWorker` 类：
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open `MovieApplication` and at the end of the `onCreate` function, schedule
    `MovieWorker` to retrieve and save the movies:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieApplication` 并在 `onCreate` 函数的末尾，安排 `MovieWorker` 来检索并保存电影：
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This schedules `MovieWorker` to run every hour when the device is connected
    to the network. `MovieWorker` will fetch the list of movies from the network and
    save it to the local database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在设备连接到网络时每小时调度 `MovieWorker` 运行。`MovieWorker` 将从网络获取电影列表并将其保存到本地数据库中。
- en: Run the application. Close it and make sure the device is connected to the internet.
    After more than an hour, open the application again and check whether the list
    of movies displayed has been updated. If not, try again in a few hours. The list
    of movies displayed will be updated regularly, around every hour, even if the
    app has been closed.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。关闭它并确保设备已连接到互联网。超过一小时后，再次打开应用程序并检查显示的电影列表是否已更新。如果没有，几小时后再试。显示的电影列表将定期更新，大约每小时更新一次，即使应用程序已关闭。
- en: '![Figure 15.5 – The Popular Movies app updates its list with WorkManager](img/B19411_15_041.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.5 – 使用 WorkManager 更新热门电影应用程序的列表](img/B19411_15_041.jpg)'
- en: Figure 15.5 – The Popular Movies app updates its list with WorkManager
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 使用 WorkManager 更新热门电影应用程序的列表
- en: In this exercise, you added WorkManager to your application to automatically
    update the database with the list of the movies retrieved from the network.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你向应用程序添加了 WorkManager，以自动使用从网络检索的电影列表更新数据库。
- en: Activity 15.01 – revisiting the TV Guide app
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十五点零一 - 重访电视指南应用程序
- en: 'In the previous chapter, you developed an app that can display a list of TV
    shows that are on the air. The app had two screens: the main screen and the details
    screen. On the main screen, there’s a list of TV shows. When clicking on a TV
    show, the details screen will be displayed with the details of the selected show.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你开发了一个可以显示正在播出的电视剧列表的应用程序。该应用程序有两个屏幕：主屏幕和详情屏幕。在主屏幕上，有一个电视剧列表。点击电视剧时，将显示选中电视剧的详情屏幕。
- en: When running the app, it takes a while to display the list of shows. Update
    the app to cache the list so it will be immediately displayed when opening the
    app. Also, improve the app by using MVVM with data binding and adding WorkManager.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，显示节目列表需要一段时间。更新应用程序以缓存列表，以便在打开应用程序时立即显示。此外，通过使用数据绑定和添加 WorkManager
    来改进应用程序。
- en: 'You can use the TV Guide app you worked on in the previous chapter or download
    it from the GitHub repository ([https://packt.link/Eti8M](https://packt.link/Eti8M)).
    The following steps will help guide you through this activity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上一章中工作的电视指南应用程序或从 GitHub 仓库（[https://packt.link/Eti8M](https://packt.link/Eti8M)）下载它。以下步骤将帮助你完成此活动：
- en: Open the TV Guide app in Android Studio. Open the `app/build.gradle` file and
    add the `kotlin-kapt` plugin, the data binding dependency, and the dependencies
    for Room and WorkManager.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开电视指南应用程序。打开 `app/build.gradle` 文件并添加 `kotlin-kapt` 插件、数据绑定依赖项以及
    Room 和 WorkManager 的依赖项。
- en: Create a binding adapter class for `RecyclerView`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `RecyclerView` 创建一个绑定适配器类。
- en: In `activity_main.xml`, wrap everything inside a `layout` tag.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `activity_main.xml` 中，将所有内容包裹在一个 `layout` 标签内。
- en: Inside the `layout` tag and before the `ConstraintLayout` tag, add a data element
    with a variable for `ViewModel`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `layout` 标签内和 `ConstraintLayout` 标签之前，添加一个数据元素，其中包含 `ViewModel` 的变量。
- en: In `RecyclerView`, add the list to be displayed with `app:list`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecyclerView` 中，使用 `app:list` 添加要显示的列表。
- en: In `MainActivity`, replace the line for `setContentView` with the `DataBindingUtil.setContentView`
    function.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，将 `setContentView` 的行替换为 `DataBindingUtil.setContentView`
    函数。
- en: Replace the observer from `TVShowViewModel` with the data binding code.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TVShowViewModel` 中的观察者替换为数据绑定代码。
- en: Add an `Entity` annotation in the `TVShow` class.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TVShow` 类中添加 `Entity` 注解。
- en: Create a `TVDao` data access object for accessing the `TV` `shows` table.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为访问 `TV` `shows` 表创建一个 `TVDao` 数据访问对象。
- en: Create a `TVDatabase` class.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TVDatabase` 类。
- en: Update `TVShowRepository` with a constructor for `tvDatabase`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tvDatabase` 构造函数更新 `TVShowRepository`。
- en: Update the `fetchTVShows` function to get the TV shows from the local database.
    If there’s nothing there yet, retrieve the list from the endpoint and save it
    in the database.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `fetchTVShows` 函数以从本地数据库获取电视剧。如果还没有，则从端点检索列表并将其保存到数据库中。
- en: Add a suspending `fetchTVShowsFromNetwork` function to get the TV shows from
    the network and save them to the database.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个挂起函数 `fetchTVShowsFromNetwork`，从网络获取电视剧并将其保存到数据库中。
- en: Create the `TVShowWorker` class.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `TVShowWorker` 类。
- en: Open the `TVApplication` file. In `onCreate`, schedule `TVShowWorker` to retrieve
    and save the shows.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `TVApplication` 文件。在 `onCreate` 中，安排 `TVShowWorker` 检索并保存节目。
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the movie details. The
    main screen and details screen will be similar to the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用。应用将显示电视节目列表。点击一个电视节目将打开详情活动，显示电影详情。主屏幕和详情屏幕将类似于以下内容：
- en: '![Figure 15.6 – The main screen and details screen of the TV Guide app](img/B19411_15_05.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – TV指南应用的主屏幕和详情屏幕](img/B19411_15_05.jpg)'
- en: Figure 15.6 – The main screen and details screen of the TV Guide app
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – TV指南应用的主屏幕和详情屏幕
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在[https://packt.link/By7eE](https://packt.link/By7eE)找到。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter focused on architectural patterns for Android. You started with
    the MVVM architectural pattern. You learned about its three components: the Model,
    the View, and the ViewModel. You also used data binding to link the View with
    the ViewModel.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了Android的架构模式。你从MVVM架构模式开始学习。你了解了它的三个组成部分：模型(Model)、视图(View)和视图模型(ViewModel)。你还使用了数据绑定来将视图与视图模型连接起来。
- en: Next, you learned about how the Repository pattern can be used to cache data.
    Then, you learned about WorkManager and how you can schedule tasks such as retrieving
    data from the network and saving that data to the database to update your local
    data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何使用Repository模式来缓存数据。然后，你学习了WorkManager以及如何安排诸如从网络获取数据并将数据保存到数据库以更新本地数据等任务。
- en: In the next chapter, you will learn how to improve the look and design of your
    apps with animations. You will add animations and transitions to your apps with
    `CoordinatorLayout` and `MotionLayout`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过动画来改善和提高你应用的外观和设计。你将使用`CoordinatorLayout`和`MotionLayout`为你的应用添加动画和过渡效果。
