- en: Chapter 1. The Swift Programming Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Swift编程语言
- en: At the core of game development is your game's code. It is the brain of your
    project and outside of the art, sound, and various asset developments. It is where
    you will spend most of your time creating and testing your game. Up until Apple's
    **Worldwide Developers Conference WWDC14** in June of 2014, the code of choice
    for iOS game and app development was **Objective-C**. At *WWDC14*, a new and faster
    programming language, Swift, was announced and is now the recommended language
    for all current and future iOS games and general app creation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发的核心理念是游戏代码。它是项目的灵魂，除了艺术、声音和各种资产开发之外。你将在那里花费大部分时间创建和测试你的游戏。直到2014年6月的苹果公司**全球开发者大会WWDC14**，iOS游戏和应用程序开发的代码选择一直是**Objective-C**。在*WWDC14*上，宣布了一种新的更快编程语言Swift，现在它是所有当前和未来iOS游戏以及通用应用程序创建的推荐语言。
- en: As of the time of writing, you can still use Objective-C to design your games,
    but programmers, both, new and seasoned, will see why writing in Swift is not
    only easier for expressing your game's logic, but even more preformat. Keeping
    your game running at that critical 60 fps is dependent on fast code and logic.
    Engineers at Apple developed the Swift programming language from the ground up
    with performance and readability in mind, so this language can execute certain
    code iterations faster than Objective-C while also keeping code ambiguity to a
    minimum. Swift also uses many of the methodologies and syntaxes found in more
    modern languages, such as Scala, JavaScript, Ruby, and Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你仍然可以使用Objective-C来设计你的游戏，但无论是新手还是经验丰富的程序员，都会看到为什么用Swift编写不仅更容易表达游戏逻辑，而且更加规范。保持游戏在关键性的60
    fps运行取决于快速代码和逻辑。苹果公司的工程师从头开始开发Swift编程语言，考虑到性能和可读性，因此这种语言可以比Objective-C更快地执行某些代码迭代，同时将代码歧义降到最低。Swift还使用了更多现代语言中找到的许多方法和语法，例如Scala、JavaScript、Ruby和Python。
- en: So, let's dive into the Swift language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入探讨Swift语言。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that some basic knowledge of object-oriented programming (OOP)
    be known previously, but we will try to keep the build-up and explanation of code
    simple and easy to follow as we move on to the more advanced topics related to
    game development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在之前对面向对象编程（OOP）有一些基本了解，但我们将努力使代码构建和解释简单易懂，随着我们转向与游戏开发相关的更高级主题。
- en: Hello World!
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World!
- en: It's somewhat traditional when learning programming languages to begin with
    a **Hello World** example. A Hello World program is simply using your code to
    display or log the text Hello World. It's always been the general starting point
    because sometimes just getting your code environment set up and having your code
    executing correctly is half the battle. At least, this was more the case in older
    programming languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习编程语言时，从**Hello World**示例开始是一种相当传统的做法。Hello World程序只是使用你的代码来显示或记录文本“Hello
    World”。它一直是通用起点，因为有时只是设置你的代码环境并确保代码正确执行就是战斗的一半。至少，这在较老的编程语言中更为常见。
- en: 'Swift makes this easier than ever, and without going into the structure of
    a Swift file (which we shall do later on and is also much easier than Objective-C
    and past languages), here''s how you create a Hello World program:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Swift使得这一切变得比以往任何时候都更容易，而且不需要深入了解Swift文件的结构（我们将在稍后进行，这比Objective-C和过去使用的语言都要简单得多），以下是如何创建一个Hello
    World程序的方法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it! That is all you need to have the text `Hello World` appear in Xcode's
    debug area output.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这就是你需要在Xcode的调试区域输出中看到文本“Hello World”的全部内容。
- en: No more semicolons
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不再需要分号
- en: Those of us who have been programming for some time might note that the usually
    all-important semicolon (`;`) is missing. This isn't a mistake; in Swift, we don't
    have to use a semicolon to mark the end of an expression. We can if we'd like,
    and some of us might still do it as a force of habit, but Swift has omitted that
    common concern.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这些编程一段时间的人可能会注意到通常至关重要的分号（`;`）不见了。这不是一个错误；在Swift中，我们不需要使用分号来标记表达式的结束。如果我们想，我们可以这样做，有些人可能仍然会这样做作为一种习惯，但Swift已经省略了这种常见的担忧。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the semicolon to mark the end of an expression stems from the earliest
    days of programming when code was written in simple word processors and needed
    a special character to represent when the code's expression ends and the next
    begins.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分号标记表达式结束的做法源于编程的早期，当时代码是在简单的文字处理器中编写的，需要特殊字符来表示代码的表达式何时结束以及何时开始。
- en: Variables, constants, and primitive data types
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量、常量和原始数据类型
- en: While programming any application, either if new to programming or trying to
    learn a different language, first we should get an understanding of how a language
    handles variables, constants, and various data types, such as Booleans, integers,
    floats, strings, and arrays. You can think of the data in your program as boxes
    or containers of information. Those containers can be of different flavors or
    types. Throughout the life of your game, the data can change (variables, objects,
    and so on) or they can stay the same.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程任何应用程序时，无论是编程新手还是试图学习不同的语言，首先我们应该了解一种语言如何处理变量、常量和各种数据类型，例如布尔值、整数、浮点数、字符串和数组。你可以把程序中的数据想象成信息或容器。这些容器可以是不同风味或类型的。在整个游戏的生命周期中，数据可以改变（变量、对象等）或者保持不变。
- en: For example, the number of lives a player has would be stored as a variable,
    as that is expected to change during the course of the game. That variable would
    then be of the primitive data type integer, which is basically whole numbers.
    Data that stores, say, the name of a certain weapon or power-up in your game,
    would be stored in what's known as a constant, as the name of that item is never
    going to change. In a game where the player can have interchangeable weapons or
    power-ups, the best way to represent the currently equipped item would be to use
    a variable. A variable is a piece of data that is bound to change. That weapon
    or power-up will also most likely have a bit more information to it than just
    a name or number; the primitive types we mentioned prior. The currently equipped
    item would be made up of properties, such as its name, power, effects, index number,
    and the sprite or 3D model that visually represents it. Thus, the currently equipped
    item wouldn't just be a variable of a primitive data type, but be what is known
    as a type of object. Objects in programming can hold a number of properties and
    functionalities that can be thought of as a *black box* of both function and information.
    The currently equipped item in our case would be a sort of *placeholder* that
    can hold an item of that type and interchange it when needed, fulfilling its purpose
    as a replaceable item.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，玩家拥有的生命值将作为变量存储，因为预计在游戏过程中会发生变化。这个变量将是原始数据类型整数，基本上是整数。存储诸如游戏中某种武器或增强效果的名称的数据将存储在所谓的常量中，因为这个项目的名称永远不会改变。在玩家可以更换武器或增强效果的游戏中，表示当前装备物品的最佳方式是使用变量。变量是一段会变化的绑定数据。这种武器或增强效果可能还会包含比名称或数字更多的信息；我们之前提到的原始类型。当前装备的物品将由属性组成，例如其名称、力量、效果、索引号以及代表它的精灵或3D模型。因此，当前装备的物品不仅是一个原始数据类型的变量，而是一种称为对象类型的类型。编程中的对象可以包含许多属性和功能，可以将其视为功能和信息的一种*黑盒*。在我们的例子中，当前装备的物品将是一种*占位符*，可以持有该类型的物品并在需要时进行交换，从而完成其作为可替换物品的用途。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift is what's known as a *type-safe language*, so we should keep track of
    the exact type of data and even it's future usage (that is, if the data is or
    will be `NULL`), as it's very important when working with Swift compared with
    other languages. Apple made Swift behave this way to help keep runtime errors
    and bugs in your applications to a minimum, so we can find them much earlier in
    the development process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种被称为*类型安全语言*的语言，因此我们应该跟踪数据的精确类型及其未来的使用（即，数据是否或将是`NULL`），因为在与其他语言相比使用Swift时，这非常重要。苹果让Swift以这种方式运行，以帮助将应用程序中的运行时错误和错误降到最低，这样我们就可以在开发过程中更早地发现它们。
- en: Variables
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Let's look at how variables are declared in Swift.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Swift中如何声明变量。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Those of us who have been developing in JavaScript will feel right at home here.
    Like JavaScript, we use the keyword `var` to represent a variable, and we named
    the variable `lives`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在JavaScript中开发过的人来说，这里会感到非常熟悉。就像JavaScript一样，我们使用关键字`var`来表示一个变量，并将其命名为`lives`。
- en: The compiler implicitly knows that the type of this variable is a whole number,
    the primitive data type `Int`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器隐式地知道这个变量的类型是一个整数，原始数据类型`Int`。
- en: 'The type can be explicitly declared as such:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以显式地声明如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also represent lives as the floating point data types double or float,
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将生命值表示为浮点数据类型double或float，如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a colon after the variable's name declaration allows us to explicitly
    typecast the variable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量名称声明后使用冒号允许我们显式地进行类型转换。
- en: Constants
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: During your game, there will be points of data that don't change throughout
    the life of the game or the game's current level/scene. These can be various data,
    such as gravity, a text label in the **Heads-Up Display** (**HUD**), the center
    point of character's 2D animation, an event declaration, or the time before your
    game checks for new touches/swipes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，将会有一些数据在整个游戏生命周期或当前关卡/场景中不会改变。这些可以是各种数据，例如重力、**抬头显示**（**HUD**）中的文本标签、角色
    2D 动画的中心点、事件声明或游戏检查新触摸/滑动之前的时间。
- en: Declaring constants is almost the same as declaring variables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明常量几乎与声明变量相同。
- en: Using a colon after the variable's name declaration allows us to explicitly
    typecast the variable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量名声明后使用冒号允许我们显式地进行类型转换。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, we use the keyword `let` to declare constants.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用关键字 `let` 来声明常量。
- en: 'Here''s another example using a string that could represent a message displayed
    on the screen at the start or end of a stage:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个使用字符串的例子，它可以代表在阶段开始或结束时在屏幕上显示的消息：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the string `stageMessage` is a constant, we cannot change it once it has
    been declared. Something like this would be better as a variable using `var` instead
    of `let`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串 `stageMessage` 是一个常量，一旦声明后我们无法更改它。像这样使用 `var` 而不是 `let` 的变量会更好。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '"Why don''t we declare everything as a variable?"'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么我们不把所有东西都声明为变量？”
- en: This is a question sometimes asked by new developers and is understandable why
    it's asked, especially since game apps tend to have a large number of variables
    and more interchangeable states than an average application. When the compiler
    is building its internal list of your game's objects and data, more goes on behind
    the scenes with variables than with constants.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些新开发者经常提出的问题，为什么会有这样的疑问是可以理解的，尤其是考虑到游戏应用通常比普通应用有更多的变量和可交换的状态。当编译器构建它内部的游戏对象和数据列表时，在变量方面比在常量方面幕后发生的事情更多。
- en: Without getting too much into topics, such as the program's stack and other
    details, in short, having objects, events, and data declared as constants with
    the `let` keyword is more efficient than `var`. In a small app on the newest devices
    today, though not recommended, we could possibly get away with this without seeing
    a great deal of loss in app performance. When it comes to video games, however,
    performance is critical. Buying back as much performance as possible can allow
    a better player experience. Apple recommends that when in doubt, always use `let`
    at the time of declaration and have the compiler say when to change to `var`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨诸如程序的堆栈和其他细节等主题，简而言之，使用 `let` 关键字将对象、事件和数据声明为常量比使用 `var` 更有效率。尽管在今天最新的设备上的小型应用中不推荐这样做，但我们可能在不看到大量性能损失的情况下做到这一点。然而，当涉及到视频游戏时，性能是关键。尽可能多地恢复性能可以允许更好的玩家体验。苹果建议，在不确定的情况下，始终在声明时使用
    `let`，让编译器决定何时改为 `var`。
- en: More about constants…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于常量的更多信息...
- en: As of Swift version 1.2, constants can have a conditionally controlled initial
    value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 版本 1.2 中，常量可以有一个条件控制的初始值。
- en: 'Prior to this update, we had to initialize a constant with a single starting
    value or be forced to make the property a variable. In Xcode 6.3 and newer, we
    can perform the following logic:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新之前，我们必须使用单个起始值初始化常量，或者被迫将属性变为变量。在 Xcode 6.3 及更高版本中，我们可以执行以下逻辑：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An example of this in a game could be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，这样的例子可以是：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this functionality, a constant''s initialization can have a layer of variance
    while still keeping it unchangeable, or immutable through its use. Here, the constant
    `stageBoss` can be one of two types based on the game''s difficulty: `Boss.toughBoss()`
    or `Boss.normalBoss()`. The boss won''t change for the course of this stage, so
    it makes sense to keep it as a constant. More on **if and else statements** is
    covered later in the chapter.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，常量的初始化可以有一个可变性的层级，同时仍然保持其不可变性，或者通过其使用保持不变。在这里，常量 `stageBoss` 可以根据游戏难度是两种类型之一：`Boss.toughBoss()`
    或 `Boss.normalBoss()`。在这个阶段过程中，Boss 不会改变，所以将其保持为常量是有意义的。关于 **if 和 else 语句** 的更多内容将在本章后面介绍。
- en: Arrays, matrices, sets, and dictionaries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、矩阵、集合和字典
- en: 'Variables and constants can represent a collection of various properties and
    objects. The most common collection types are arrays, matrices, sets, and dictionaries.
    An array is an ordered list of distinct objects; a matrix is, in short, an array
    of arrays; a set is an unordered list of distinct objects; and a dictionary is
    an unordered list that utilizes a *key : value* association with the data.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '变量和常量可以表示各种属性和对象的集合。最常见的集合类型有数组、矩阵、集合和字典。数组是有序的不同对象的列表；矩阵简而言之，是数组的数组；集合是无序的不同对象的列表；而字典是无序的列表，它利用了
    *键 : 值* 关联来存储数据。'
- en: Arrays
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'Here''s an example of an array in Swift:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Swift 中数组的示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The object `stageNames` is a collection of strings representing the names of
    a game's stages. Arrays are ordered by subscripts from `0` to array length `-1`.
    So, `stageNames[0]` would be `Downtown Tokyo`; `stageNames[2]` would be `Nether`;
    and `stageNames[4]` would give an error since that's beyond the limits of the
    array and doesn't exist. We use `[]` brackets around the class type of `stageNames`,
    `[String]`, to tell the compiler that we are dealing with an array of strings.
    Brackets are also used around the individual members of this array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `stageNames` 是一个表示游戏阶段名称的字符串集合。数组通过下标从 `0` 到数组长度 `-1` 进行排序。因此，`stageNames[0]`
    将会是 `Downtown Tokyo`；`stageNames[2]` 将会是 `Nether`；而 `stageNames[4]` 会引发错误，因为那超出了数组的范围且不存在。我们使用
    `[]` 方括号包围 `stageNames` 的类类型 `[String]`，以告诉编译器我们正在处理字符串数组。方括号也用于包围这个数组的各个成员。
