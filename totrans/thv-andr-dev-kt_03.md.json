["```kt\n    dependencies {\n        implementation \"io.ktor:ktor-client-\n            websockets:2.2.4\"\n        implementation \"io.ktor:ktor-client-okhttp:2.2.4\"\n    }\n    ```", "```kt\n    <uses-permission android:name=\n        \"android.permission.INTERNET\" />\n    ```", "```kt\nfun main() = runBlocking {\n    // Define a simple flow that emits three strings\n    val helloFlow = flow {\n        emit(\"Hello\")\n        emit(\"from\")\n        emit(\"Flow!\")\n    }\n    // Collect and print each value emitted by the flow\n    helloFlow.collect { value ->\n        println(value)\n    }\n}\n```", "```kt\nHello\nfrom\nFlow!\n```", "```kt\nobject WebsocketClient {\n    val client = HttpClient(OkHttp) {\n        install(WebSockets)\n    }\n}\n```", "```kt\nclass MessagesSocketDataSource @Inject constructor(\n    private val httpClient: HttpClient,\n) {\n    private lateinit var webSocketSession:\n        DefaultClientWebSocketSession\n    suspend fun connect(url: String): Flow<Message>{\n        return httpClient.webSocketSession { url(url) }\n            .apply { webSocketSession = this }\n            .incoming\n            .receiveAsFlow()\n            .map{ frame ->\n                webSocketSession.handleMessage(frame) }\n            .filterNotNull()\n            .map { it.toDomain() }\n    }\n//...\n}\n```", "```kt\nsuspend fun sendMessage(message: String) {\n    webSocketSession.send(Frame.Text(message))\n}\nsuspend fun disconnect() {\n    webSocketSession.close(CloseReason(\n        CloseReason.Codes.NORMAL, \"Disconnect\"))\n}\n```", "```kt\nprivate suspend fun\nDefaultClientWebSocketSession.handleMessage(frame: Frame):\nWebsocketMessageModel? {\n    return when (frame) {\n        is Frame.Text -> converter?.deserialize(frame)\n        is Frame.Close -> {\n            disconnect()\n            null\n        }\n        else -> null\n    }\n}\n```", "```kt\nimplementation(\"io.ktor:ktor-serialization-kotlinx-json:2.2.4)\n```", "```kt\nobject WebsocketClient {\n    val client = HttpClient(OkHttp) {\n        install(WebSockets) {\n            contentConverter =\n               KotlinxWebsocketSerializationConverter(Json)\n        }\n    }\n}\n```", "```kt\n@Serializable\nclass WebsocketMessageModel(\n    val id: String,\n    val message: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val timestamp: String,\n    val isMine: Boolean,\n    val messageType: String,\n    val messageDescription: String\n)\n```", "```kt\ndata class Message(\n    val id: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val timestamp: String,\n    val isMine: Boolean,\n    val contentType: ContentType,\n    val content: String,\n    val contentDescription: String\n) {\n    enum class ContentType {\n        TEXT, IMAGE\n    }\n}\n```", "```kt\n@Serializable\nclass WebsocketMessageModel(\n    val id: String,\n    val message: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val timestamp: String,\n    val isMine: Boolean,\n    val messageType: String,\n    val messageDescription: String\n) {\n    companion object {\n        const val TYPE_TEXT = \"TEXT\"\n        const val TYPE_IMAGE = \"IMAGE\"\n    }\n    fun toDomain(): Message {\n        return Message(\n            id = id,\n            content = message,\n            senderAvatar = senderAvatar,\n            senderName = senderName,\n            timestamp = timestamp,\n            isMine = isMine,\n            contentDescription = messageDescription,\n            contentType = toContentType()\n        )\n    }\n    fun toContentType(): Message.ContentType {\n        return when(messageType) {\n            TYPE_IMAGE -> Message.ContentType.IMAGE\n            else -> Message.ContentType.TEXT\n        }\n    }\n}\n```", "```kt\ncompanion object {\n    const val TYPE_TEXT = \"TEXT\"\n    const val TYPE_IMAGE = \"IMAGE\"\n    fun fromDomain(message: Message): WebsocketMessageModel {\n        return WebsocketMessageModel(\n            id = message.id,\n            message = message.content,\n            senderAvatar = message.senderAvatar,\n            senderName = message.senderName,\n            timestamp = message.timestamp,\n            isMine = message.isMine,\n            messageType = message.fromContentType(),\n            messageDescription = message.contentDescription\n        )\n    }\n}\n```", "```kt\nsuspend fun sendMessage(message: Message) {\n    val websocketMessage =\n        WebsocketMessageModel.fromDomain(message)\n    webSocketSession.converter?\n        .serialize(websocketMessage)?.let\n    {\n        webSocketSession.send(it)\n    }\n}\n```", "```kt\nclass MessagesRepository @Inject constructor(\n    private val dataSource: MessagesSocketDataSource\n) {\n    suspend fun getMessages(): Flow<Message> {\n        return dataSource.connect()\n    }\n    suspend fun sendMessage(message: Message) {\n        dataSource.sendMessage(message)\n    }\n    suspend fun disconnect() {\n        dataSource.disconnect()\n    }\n}\n```", "```kt\ninterface IMessagesRepository {\n    suspend fun getMessages(): Flow<Message>\n    suspend fun sendMessage(message: Message)\n    suspend fun disconnect()\n}\n```", "```kt\nclass MessagesRepository @Inject constructor(\n    private val dataSource: MessagesSocketDataSource\n): IMessagesRepository {\n    override suspend fun getMessages(): Flow<Message> {\n        return dataSource.connect()\n    }\n    override suspend fun sendMessage(message: Message) {\n        dataSource.sendMessage(message)\n    }\n    override suspend fun disconnect() {\n        dataSource.disconnect()\n    }\n}\n```", "```kt\nclass RetrieveMessages @Inject constructor(\n    private val repository: IMessagesRepository\n) {\n    suspend operator fun invoke(): Flow<Message> {\n        return repository.getMessages()\n    }\n}\n```", "```kt\nclass SendMessage @Inject constructor(\n    private val repository: IMessagesRepository\n) {\n    suspend operator fun invoke(message: Message) {\n        repository.sendMessage(message)\n    }\n}\n```", "```kt\nclass DisconnectMessages @Inject constructor(\n    private val repository: IMessagesRepository\n) {\n    suspend operator fun invoke() {\n        repository.disconnect()\n    }\n}\n```", "```kt\n@HiltViewModel\nclass ChatViewModel @Inject constructor(\n    private val retrieveMessages: RetrieveMessages,\n    private val sendMessage: SendMessage,\n    private val disconnectMessages: DisconnectMessages\n) : ViewModel() {\n// ....\n}\n```", "```kt\nprivate val _messages =\nMutableStateFlow<List<Message>>(emptyList())\n```", "```kt\nval messages: StateFlow<List<Message>> = _messages\n```", "```kt\nprivate var messageCollectionJob: Job? = null\nfun loadAndUpdateMessages() {\n    messageCollectionJob =\n    viewModelScope.launch(Dispatchers.IO) {\n        retrieveMessages()\n            .map { it.toUI() }\n            .collect { message ->\n                withContext(Dispatchers.Main) {\n                    _messages.value = _messages.value +\n                    message\n                }\n            }\n    }\n}\n```", "```kt\nprivate fun DomainMessage.toUI(): Message {\n    return Message(\n        id = id,\n        senderName = senderName,\n        senderAvatar = senderAvatar,\n        timestamp = timestamp,\n        isMine = isMine,\n        messageContent = getMessageContent()\n    )\n}\nprivate fun DomainMessage.getMessageContent():\nMessageContent {\n    return when (contentType) {\n        DomainMessage.ContentType.TEXT ->\n            MessageContent.TextMessage(content)\n        DomainMessage.ContentType.IMAGE ->\n            MessageContent.ImageMessage(content,\n            contentDescription)\n    }\n}\n```", "```kt\nretrieveMessages()\n    .map { it.toUI() }\n```", "```kt\nfun onSendMessage(messageText: String) {\n    viewModelScope.launch(Dispatchers.IO) {\n        val message = Message(messageText) // We will add\n                                              here the rest\n                                              of the fields\n        sendMessage(message)\n    }\n}\n```", "```kt\noverride fun onCleared() {\n    messageCollectionJob?.cancel()\n    viewModelScope.launch(Dispatchers.IO) {\n        disconnectMessages()\n    }\n}\n```", "```kt\nimport com.packt.feature.chat.domain.models.Message as\nDomainMessage\n// We are using this import with an alias to make it easier\n   to identify the Message class from the domain layer\n@HiltViewModel\nclass ChatViewModel @Inject constructor(\n    private val retrieveMessages: RetrieveMessages,\n    private val sendMessage: SendMessage,\n    private val disconnectMessages: DisconnectMessages\n) : ViewModel() {\n    private val _messages =\n        MutableStateFlow<List<Message>>(emptyList())\n    val messages: StateFlow<List<Message>> = _messages\n    private var messageCollectionJob: Job? = null\n    fun loadAndUpdateMessages() {\n        messageCollectionJob =\n        viewModelScope.launch(Dispatchers.IO) {\n            retrieveMessages()\n                .map { it.toUI() }\n                .collect { message ->\n                    withContext(Dispatchers.Main) {\n                        _messages.value = _messages.value +\n                        message\n                }\n            }\n        }\n    }\n    private fun DomainMessage.toUI(): Message {\n        return Message(\n            id = id,\n            senderName = senderName,\n            senderAvatar = senderAvatar,\n            timestamp = timestamp,\n            isMine = isMine,\n            messageContent = getMessageContent()\n        )\n    }\n    private fun DomainMessage.getMessageContent():\n    MessageContent {\n        return when (contentType) {\n            DomainMessage.ContentType.TEXT ->\n                MessageContent.TextMessage(content)\n            DomainMessage.ContentType.IMAGE ->\n                MessageContent.ImageMessage(content,\n                contentDescription)\n        }\n    }\n    fun onSendMessage(messageText: String) {\n        viewModelScope.launch(Dispatchers.IO) {\n            val message = Message(messageText)\n            sendMessage(message)\n        }\n    }\n    override fun onCleared() {\n        messageCollectionJob?.cancel()\n        viewModelScope.launch(Dispatchers.IO) {\n            disconnectMessages()\n        }\n    }\n}\n```", "```kt\n@Composable\nfun ChatScreen(\n    viewModel: ChatViewModel = hiltViewModel(),\n    chatId: String?,\n    onBack: () -> Unit\n) {\n}\n```", "```kt\nLaunchedEffect(Unit) {\n    viewModel.loadAndUpdateMessages()\n}\n```", "```kt\nSendMessageBox { viewModel.onSendMessage(it) }\n```", "```kt\n@Composable\nfun SendMessageBox(sendMessage: (String)->Unit) {\n    Box(modifier = Modifier\n        .defaultMinSize()\n        .padding(top = 0.dp, start = 16.dp, end = 16.dp,\n            bottom = 16.dp)\n        .fillMaxWidth()\n    ) {\n        var text by remember { mutableStateOf(\"\") }\n        OutlinedTextField(\n            value = text,\n            onValueChange = { newText -> text = newText },\n            modifier = Modifier\n                .fillMaxWidth(0.85f)\n                .align(Alignment.CenterStart)\n                .height(56.dp),\n        )\n        IconButton(\n            modifier = Modifier\n                .align(Alignment.CenterEnd)\n                .height(56.dp),\n            onClick = {\n                sendMessage(text)\n                text = \"\"\n            }\n        ) {\n            Icon(\n                imageVector = Icons.Default.Send,\n                tint = MaterialTheme.colors.primary,\n                contentDescription = \"Send message\"\n            )\n        }\n    }\n}\n```", "```kt\nListOfMessages(paddingValues = paddingValues, messages = messages)\n```", "```kt\n@Composable\nfun ListOfMessages(messages: List<Message>, paddingValues: PaddingValues) {\n    Box(modifier = Modifier\n        .fillMaxSize()\n        .padding(paddingValues)) {\n        Row(modifier = Modifier\n            .fillMaxWidth()\n            .padding(16.dp)\n        ) {\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize(),\n                verticalArrangement =\n                    Arrangement.spacedBy(8.dp),\n            ) {\n                items(messages) { message ->\n                    MessageItem(message = message)\n                }\n            }\n        }\n    }\n}\n```", "```kt\nimplementation \"io.ktor:ktor-client-content-negotiation:\n$ktor_version\"\n```", "```kt\nobject RestClient {\n    val client = HttpClient{\n        install(ContentNegotiation) {\n            json()\n        }\n    }\n}\n```", "```kt\nclass ChatRoomDataSource @Inject constructor(\n    private val client: HttpClient,\n    private val url: String\n) {\n    suspend fun getInitialChatRoom(id: String):\n    ChatRoomModel {\n        return client.get(url.format(id)).body()\n    }\n}\n```", "```kt\n    val response: HttpResponse =\n    client.get(\"https://api.example.com/data\")\n    ```", "```kt\n    val response: HttpResponse =\n    client.post(\"https://api.example.com/data\") {\n    body = yourData }\n    ```", "```kt\n    val response: HttpResponse =\n    client.put(\"https://api.example.com/data\") {\n    body = yourUpdatedData }\n    ```", "```kt\n    val response: HttpResponse =\n    client.delete(\"https://api.example.com/data/ID\")\n    ```", "```kt\n    val response: HttpResponse =\n    client.patch(\"https://api.example.com/data\") {\n    body = yourPartialData }\n    ```", "```kt\n@kotlinx.serialization.Serializable\ndata class ChatRoomModel(\n    val id: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val lastMessages: List<WebsocketMessageModel>\n)\n```", "```kt\n@InstallIn(SingletonComponent::class)\n@Module\nabstract class ChatModule {\n    companion object {\n        const val WEBSOCKET_URL =\n            \"ws://whatspackt.com/chat/%s\"\n        const val WEBSOCKET_URL_NAME = \"WEBSOCKET_URL\"\n        const val WEBSOCKET_CLIENT = \"WEBSOCKET_CLIENT\"\n        const val API_CHAT_ROOM_URL =\n            \"http://whatspackt.com/chats/%s\"\n        const val API_CHAT_ROOM_URL_NAME = \"CHATROOM_URL\"\n        const val API_CLIENT = \"API_CLIENT\"\n    }\n    @Provides\n    @Named(WEBSOCKET_CLIENT)\n    fun providesWebsocketHttpClient(): HttpClient {\n        return WebsocketClient.client\n    }\n    @Provides\n    @Named(WEBSOCKET_URL_NAME)\n    fun providesWebsocketURL(): String {\n        return WEBSOCKET_URL\n    }\n    @Binds\n    abstract fun providesMessagesRepository(\n        messagesRepository: MessagesRepository\n    ): IMessagesRepository\n    @Provides\n    @Named(API_CLIENT)\n    fun providesAPIHttpClient(): HttpClient {\n        return RestClient.client\n    }\n}\n```", "```kt\n@Provides\n@Named(WEBSOCKET_CLIENT)\nfun providesWebsocketHttpClient(): HttpClient {\n    return WebsocketClient.client\n}\n@Provides\n@Named(API_CLIENT)\nfun providesAPIHttpClient(): HttpClient {\n    return RestClient.client\n}\n```", "```kt\nclass ChatRoomDataSource @Inject constructor(\n    @Named(API_CLIENT) private val client: HttpClient,\n    @Named(API_CHAT_ROOM_URL_NAME) private val url: String\n) {\n    suspend fun getInitialChatRoom(id: String):\n    ChatRoomModel {\n        return client.get(url.format(id)).body()\n    }\n}\n```", "```kt\nclass MessagesSocketDataSource @Inject constructor(\n    @Named(WEBSOCKET_CLIENT) private val httpClient:\n        HttpClient,\n    @Named(WEBSOCKET_URL_NAME) private val websocketUrl:\n        String\n) { ... }\n```", "```kt\npackage com.packt.feature.chat.domain\nimport com.packt.feature.chat.domain.models.ChatRoom\ninterface IChatRoomRepository {\n    suspend fun getInitialChatRoom(id: String): ChatRoom\n}\n```", "```kt\npackage com.packt.feature.chat.data.network.repository\nimport com.packt.feature.chat.data.network.datasource\n.ChatRoomDataSource\nimport com.packt.feature.chat.domain.IChatRoomRepository\nimport com.packt.feature.chat.domain.models.ChatRoom\nimport javax.inject.Inject\nclass ChatRoomRepository @Inject constructor(\n    private val dataSource: ChatRoomDataSource\n): IChatRoomRepository {\n    override suspend fun getInitialChatRoom(id: String):\n    ChatRoom {\n        val chatRoomApiModel =\n            dataSource.getInitialChatRoom(id)\n        return chatRoomApiModel.toDomain()\n    }\n}\n```", "```kt\npackage com.packt.feature.chat.domain.models\ndata class ChatRoom(\n    val id: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val lastMessages: List<Message>\n)\n```", "```kt\n@Serializable\ndata class ChatRoomModel(\n    val id: String,\n    val senderName: String,\n    val senderAvatar: String,\n    val lastMessages: List<WebsocketMessageModel>\n) {\n    fun toDomain(): ChatRoom {\n        return ChatRoom(\n            id = id,\n            senderName = senderName,\n            senderAvatar = senderAvatar,\n            lastMessages = lastMessages.map { it.toDomain() }\n        )\n    }\n}\n```", "```kt\n@Binds\nabstract fun providesChatRoomRepository(\n    chatRoomRepository: ChatRoomRepository\n): IChatRoomRepository\n```", "```kt\npackage com.packt.feature.chat.domain.usecases\nimport com.packt.feature.chat.domain.IChatRoomRepository\nimport com.packt.feature.chat.domain.models.ChatRoom\nimport javax.inject.Inject\nclass GetInitialChatRoomInformation @Inject constructor(\n    private val repository: IChatRoomRepository\n) {\n    suspend operator fun invoke(id: String): ChatRoom {\n        return repository.getInitialChatRoom(id)\n    }\n}\n```", "```kt\n@HiltViewModel\nclass ChatViewModel @Inject constructor(\n    private val retrieveMessages: RetrieveMessages,\n    private val sendMessage: SendMessage,\n    private val disconnectMessages: DisconnectMessages,\n    private val getInitialChatRoomInformation:\n        GetInitialChatRoomInformation\n) : ViewModel() {...}\n```", "```kt\nprivate val _uiState = MutableStateFlow(Chat())\nval uiState: StateFlow<Chat> = _uiState\n```", "```kt\nfun loadChatInformation(id: String) {\n    messageCollectionJob =\n    viewModelScope.launch(Dispatchers.IO) {\n        val chatRoom = getInitialChatRoomInformation(id)\n        withContext(Dispatchers.Main) {\n            _uiState.value = chatRoom.toUI()\n            _messages.value = chatRoom.lastMessages.map {\n                it.toUI()}\n            updateMessages()\n        }\n    }\n}\n```", "```kt\ndata class Chat(\n    val id: String? = null,\n    val name: String? = null,\n    val avatar: String? = null\n)\nfun ChatRoom.toUI() = run {\n    Chat(\n        id = id,\n        name = senderName,\n        avatar = senderAvatar\n    )\n}\n```", "```kt\n@Composable\nfun ChatScreen(\n    viewModel: ChatViewModel = hiltViewModel(),\n    chatId: String?,\n    onBack: () -> Unit\n) {\n    val messages by viewModel.messages.collectAsState()\n    val uiState by viewModel.uiState.collectAsState()\n    LaunchedEffect(Unit) {\n        viewModel.loadChatInformation(chatId.orEmpty())\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                   Text(stringResource(R.string.chat_title,\n                   uiState.name.orEmpty()))\n                }\n            )\n        },\n        bottomBar = {\n            SendMessageBox { viewModel.onSendMessage(it) }\n        }\n    ) { paddingValues->\n        ListOfMessages(paddingValues = paddingValues,\n        messages = messages)\n    }\n}\n```", "```kt\nsuspend fun connect(): Flow<Message> {\n    return flow {\n        // Wrap the connection attempt with a try-catch\n           block\n        try {\n            httpClient.webSocketSession { url(websocketUrl) }\n                .apply { webSocketSession = this }\n                .incoming\n                .receiveAsFlow()\n                .collect { frame ->\n                    try {\n                        // Handle errors while processing\n                           the message\n                        val message =\n                            webSocketSession.handleMessage(\n                                frame)?.toDomain()\n                        if (message != null) {\n                            emit(message)\n                        }\n                    } catch (e: Exception) {\n                        // Log or handle the error\n                           gracefully\n                        Log.e(TAG, \"Error handling\n                            WebSocket frame\", e)\n                    }\n                }\n        } catch (e: Exception) {\n            // Log or handle the connection error\n               gracefully\n            Log.e(TAG, \"Error connecting to WebSocket\", e)\n        }\n    }.retryWhen { cause, attempt ->\n        // Implement a retry strategy based on the cause\n           and/or the number of attempts\n        if (cause is IOException && attempt < MAX_RETRIES)\n        {\n            delay(RETRY_DELAY)\n            true\n        } else {\n            false\n        }\n    }.catch { e ->\n        // Handle exceptions from the Flow\n        Log.e(TAG, \"Error in WebSocket Flow\", e)\n    }\n}\n```", "```kt\ncompanion object {\n    const val TAG = \"MessagesSocketDataSource\"\n    const val RETRY_DELAY = 30000\n    const val MAX_RETRIES = 5\n}\n```", "```kt\n    classpath 'com.google.gms:google-services:\n    $latest_version'\n    ```", "```kt\n    implementation platform('com.google.firebase:\n        firebase-bom:$latest_version')\n    implementation 'com.google.firebase:firebase-auth'\n    implementation 'com.google.firebase:\n        firebase-firestore'\n    implementation 'com.google.firebase:\n        firebase-messaging'\n    ```", "```kt\n    implementation 'org.jetbrains.kotlinx:\n    kotlinx-coroutines-play-services:$latest_version'\n    ```", "```kt\npackage com.packt.data\nimport com.google.firebase.messaging.FirebaseMessaging\nimport kotlinx.coroutines.tasks.await\nimport javax.inject.Inject\nclass FCMTokenDataSource @Inject constructor(\n    private val firebaseMessaging: FirebaseMessaging =\n    FirebaseMessaging.getInstance()\n) {\n    suspend fun getFcmToken(): String? {\n        return try {\n            FirebaseMessaging.getInstance().token.await()\n        } catch (e: Exception) {\n            null\n        }\n    }\n}\n```", "```kt\ninterface IFCMTokenRepository {\n    suspend fun getFCMToken(): String\n}\n```", "```kt\nclass FCMTokenRepository @Inject constructor(\n    private val tokenDataSource: FCMTokenDataSource\n) {\n    suspend fun getToken(): String? {\n        return tokenDataSource.getFcmToken()\n    }\n}\n```", "```kt\ninterface IInternalTokenRepository {\n    suspend fun storeToken(userId: String, token: String)\n}\n```", "```kt\nclass InternalTokenRepository(): IInternalTokenRepository {\n    override suspend fun storeToken(userId: String, token:\n    String) {\n        // Store in the data source of your choosing\n    }\n}\n```", "```kt\npackage com.packt.framework.navigation\nobject DeepLinks {\n    const val chatRoute =\n        \"https://whatspackt.com/chat?chatId={chatId}\"\n}\n```", "```kt\nprivate fun NavGraphBuilder.addChat(navController:\nNavHostController) {\n    composable(\n        route = NavRoutes.Chat,\n        arguments = listOf(\n            navArgument(NavRoutes.ChatArgs.ChatId) {\n                type = NavType.StringType }),\n        deepLinks = listOf(\n            navDeepLink {\n                uriPattern = DeepLinks.chatRoute\n            }\n        )\n    ) { backStackEntry ->\n        val chatId = backStackEntry.arguments?.getString(\n            NavRoutes.ChatArgs.ChatId)\n        ChatScreen(chatId = chatId, onBack = {\n            navController.popBackStack() })\n    }\n}\n```", "```kt\nclass WhatsPacktMessagingService:\nFirebaseMessagingService() {\n    companion object {\n        const val CHANNEL_ID = \"Chat_message\"\n        const val CHANNEL_DESCRIPTION = \"Receive a\n            notification when a chat message is received\"\n        const val CHANNEL_TITLE = \"New chat message\n            notification\"\n    }\n    override fun onMessageReceived(remoteMessage:\n    RemoteMessage) {\n        super.onMessageReceived(remoteMessage)\n        if (remoteMessage.data.isNotEmpty()) {\n            // We can extract information such as the\n               sender, message content, or chat ID\n            val senderName =\n                remoteMessage.data[\"senderName\"]\n            val messageContent =\n                remoteMessage.data[\"message\"]\n            val chatId = remoteMessage.data[\"chatId\"]\n            val messageId = remoteMessage.data[\"messageId\"]\n            // Create and show a notification for the\n               received message\n            if (chatId != null && messageId != null) {\n                showNotification(senderName, messageId,\n                messageContent, chatId)\n            }\n        }\n    }\n    private fun showNotification(senderName: String?,\n    messageId: String, messageContent: String?,\n    chatId: String) {\n        // Implement here the notification\n    }\n}\n```", "```kt\nprivate fun showNotification(senderName: String?,\nmessageId: String, messageContent: String?, chatId: String)\n{\n    val notificationManager = getSystemService(\n       Context.NOTIFICATION_SERVICE) as NotificationManager\n    // Create a notification channel\n    // (if you want to support versions lower than Android\n       Oreo, you will have to check the version here)\n    val channel = NotificationChannel(\n        CHANNEL_ID,\n        CHANNEL_TITLE,\n        NotificationManager.IMPORTANCE_DEFAULT\n    ).apply {\n        description = CHANNEL_DESCRIPTION\n    }\n    notificationManager.createNotificationChannel(channel)\n    // Create an Intent to open the chat when the\n       notification is clicked. Here is where we are going\n       to use our newly created deeplink\n    val deepLinkUrl =\n        DeepLinks.chatRoute.replace(\"{chatId}\", chatId)\n    val intent = Intent(Intent.ACTION_VIEW,\n    Uri.parse(deepLinkUrl)).apply {\n        flags = Intent.FLAG_ACTIVITY_NEW_TASK or\n        Intent.FLAG_ACTIVITY_CLEAR_TASK\n    }\n    // Create a PendingIntent for the Intent\n    val pendingIntent = PendingIntent.getActivity(this, 0,\n        intent, PendingIntent.FLAG_IMMUTABLE)\n    // Build the notification\n    val notification = NotificationCompat.Builder(this,\n        CHANNEL_ID)\n        .setSmallIcon(R.drawable.our_notification_icon_for_\n            whatspackt)\n        .setContentTitle(senderName)\n        .setContentText(messageContent)\n        .setContentIntent(pendingIntent)\n        .setAutoCancel(true)\n        .build()\n    // Show the notification\n    notificationManager.notify(messageId.toInt(),\n        notification)\n}\n```", "```kt\n<application\n    android:allowBackup = \"true\"\n    android:dataExtractionRules =\n        \"@xml/data_extraction_rules\"\n    android:fullBackupContent = \"@xml/backup_rules\"\n    android:icon = \"@mipmap/ic_launcher\"\n    android:label = \"@string/app_name\"\n    android:supportsRtl = \"true\"\n    android:theme = \"@style/Theme.WhatsPackt\"\n    tools:targetApi = \"31\">\n    <activity\n        android:name = \".MainActivity\"\n        android:exported = \"true\"\n        android:label = \"@string/app_name\"\n        android:theme = \"@style/Theme.WhatsPackt\">\n        <intent-filter>\n            <action android:name=\n                \"android.intent.action.MAIN\" />\n            <category android:name =\n                \"android.intent.category.LAUNCHER\" />\n        </intent-filter>\n    </activity>\n    <service\n        android:name =\n            \"com.packt.data.WhatsPacktMessagingService\"\n        android:exported = \"false\">\n        <intent-filter>\n            <action android:name =\n                \"com.google.firebase.MESSAGING_EVENT\" />\n        </intent-filter>\n    </service>\n</application>\n```", "```kt\nchats (collection)\n  |\n  └── chatId1 (document)\n        |\n        ├── users (subcollection)\n        │   |\n        │   ├── userId1 (document)\n        │   │   ├── userId: \"user1\"\n        │   │   ├── avatarUrl:\n                      \"https://example.com/avatar1.jpg\"\n        │   │   └── name: \"John Doe\"\n        │   │\n        │   └── userId2 (document)\n        │       ├── userId: \"user2\"\n        │       ├── avatarUrl:\n                      \"https://example.com/avatar2.jpg\"\n        │       └── name: \"Jane Smith\"\n        │\n        └── messages (subcollection)\n              |\n              ├── messageId1 (document)\n              │   ├── senderId: \"user1\"\n              │   ├── senderName: \"John Doe\"\n              │   ├── content: \"Hello, how are you?\"\n              │   └── timestamp: 1648749123\n              |\n              └── messageId2 (document)\n                    ├── senderId: \"user2\"\n                    ├── senderName: \"Jane Smith\"\n                    ├── content: \"I'm doing great! How\n                                 about you?\"\n                    └── timestamp: 1648749156\n```", "```kt\nrules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Allow authenticated users to create chat documents,\n       but not modify or delete them\n    match /chats/{chatId} {\n      allow create: if request.auth != null;\n      allow read, update, delete: if false;\n    }\n    // Allow chat participants to read the chat's user data\n    match /chats/{chatId}/users/{userId} {\n      allow read: if request.auth != null &&\n        request.auth.uid in resource.data.userId;\n      allow write: if false;\n    }\n    // Allow authenticated users to create/modify messages\n       in a chat they are participating in\n    match /chats/{chatId}/messages/{messageId} {\n      // Get chat participants\n      function isChatParticipant() {\n        let chatUsersDoc = get(\n            /databases/$(database)/documents/chats/\n                $(chatId)/users/$(request.auth.uid));\n        return chatUsersDoc.exists();\n      }\n      // Check if the sender is the authenticated user\n      function isSender() {\n        return request.auth != null && request.auth.uid ==\n          request.resource.data.senderId;\n      }\n      allow create: if isChatParticipant() && isSender();\n      allow read: if isChatParticipant();\n      allow update, delete: if false;\n    }\n  }\n}\n```", "```kt\nimport com.google.firebase.Timestamp\nimport com.google.firebase.firestore.PropertyName\nimport com.packt.feature.chat.domain.models.Message\nimport java.text.SimpleDateFormat\nimport java.util.*\ndata class FirestoreMessageModel(\n    @Transient\n    val id: String = \"\",\n    @get:PropertyName(\"senderId\")\n    @set:PropertyName(\"senderId\")\n    var senderId: String = \"\",\n    @get:PropertyName(\"senderName\")\n    @set:PropertyName(\"senderName\")\n    var senderName: String = \"\",\n    @get:PropertyName(\"senderAvatar\")\n    @set:PropertyName(\"senderAvatar\")\n    var senderAvatar: String = \"\",\n    @get:PropertyName(\"content\")\n    @set:PropertyName(\"content\")\n    var content: String = \"\",\n    @get:PropertyName(\"timestamp\")\n    @set:PropertyName(\"timestamp\")\n    var timestamp: Timestamp = Timestamp.now()\n)\n```", "```kt\nfun toDomain(userId: String): Message {\n    return Message(\n        id = id,\n        senderName = senderName,\n        senderAvatar = senderAvatar,\n        isMine = userId == senderId,\n        contentType = Message.ContentType.TEXT,\n        content = content,\n        contentDescription = \"\",\n        timestamp = timestamp.toDateString()\n    )\n}\nprivate fun Timestamp.toDateString(): String {\n    // Create a SimpleDateFormat instance with the desired\n       format and the default Locale\n    val formatter = SimpleDateFormat(\"dd/MM/yyyy HH:mm:ss\",\n        Locale.getDefault())\n    // Convert the Timestamp to a Date object\n    val date = toDate()\n    // Format the Date object using the SimpleDateFormat\n       instance\n    return formatter.format(date)\n}\n```", "```kt\ncompanion object {\n    fun fromDomain(message: Message): FirestoreMessageModel\n    {\n        return FirestoreMessageModel(\n            id = \"\",\n            senderName = message.senderName,\n            senderAvatar = message.senderAvatar,\n            content = message.content\n        )\n    }\n}\n```", "```kt\nclass FirestoreMessagesDataSource @Inject constructor(\n    private val firestore: FirebaseFirestore =\n        FirebaseFirestore.getInstance()\n) {\n```", "```kt\n    fun getMessages(chatId: String, userId: String):\n    Flow<Message> = callbackFlow {\n```", "```kt\n        val chatRef =\n            firestore.collection(\"chats\").document(chatId)\n                .collection(\"messages\")\n```", "```kt\n        val query = chatRef.orderBy(\"timestamp\",\n            Query.Direction.ASCENDING)\n```", "```kt\n        val listenerRegistration =\n        query.addSnapshotListener { snapshot, exception ->\n            // If there's an exception, close the Flow with\n               the exception\n            if (exception != null) {\n                close(exception)\n                return@addSnapshotListener\n            }\n```", "```kt\n            val messages = snapshot?.documents?.mapNotNull\n            { doc ->\n                val message =\n                    doc.toObject(FirestoreMessageModel::\n                    class.java)\n                message?.copy(id = doc.id) // Copy the\n                                              message with\n                                              the document\n                                              ID\n            } ?: emptyList()\n            val domainMessages = messages.map {\n                it.toDomain(userId) }\n```", "```kt\n            domainMessages.forEach {\n                try {\n                    trySend(it).isSuccess\n                } catch (e: Exception) {\n                    close(e)\n                }\n            }\n        }\n```", "```kt\n        awaitClose { listenerRegistration.remove() }\n    }\n```", "```kt\n    fun sendMessage(chatId: String, message: Message) {\n        val chatRef =\n            firestore.collection(\"chats\").document(chatId)\n                .collection(\"messages\")\n        chatRef.add(FirestoreMessageModel\n            .fromDomain(message))\n    }\n}\n```", "```kt\nclass MessagesRepository @Inject constructor(\n    //private val dataSource: MessagesSocketDataSource\n    private val dataSource: FirestoreMessagesDataSource\n): IMessagesRepository {\n    override suspend fun getMessages(chatId: String,\n    userId: String): Flow<Message> {\n        return dataSource.getMessages(chatId, userId)\n    }\n    override suspend fun sendMessage(chatId: String,\n    message: Message) {\n        dataSource.sendMessage(chatId, message)\n    }\n    override suspend fun disconnect() {\n        // do nothing, Firestore data source is\n           disconnected as soon as the flow has no\n           subscribers\n    }\n}\n```"]