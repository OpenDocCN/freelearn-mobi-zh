- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing plays a crucial role in ensuring software quality in contemporary software
    development. Various types of testing are involved in the software development
    lifecycle, including unit testing, integration testing, and system testing. Unit
    testing is employed to examine software modules or components within an isolated
    environment and is typically carried out by developers. With a well-devised unit
    test strategy, programming issues can be detected at the earliest stage of the
    software development lifecycle, rendering unit testing the most efficient and
    cost-effective approach to guaranteeing software quality.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI app development, we can utilize existing unit test frameworks or
    libraries present in the .NET ecosystem. By employing a test framework or library,
    we can expedite unit test development. An effective test framework is generally
    designed for seamless integration with a **continuous integration** (**CI**) and
    **continuous deployment** (**CD**) environment. In this chapter, we will demonstrate
    how to set up unit testing and execute unit test cases as part of the .NET MAUI
    app development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock .NET MAUI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor component testing using bUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test and debug the source code from this chapter, you need to have a .NET
    8 environment set up. You can install .NET 8 by following the instructions provided
    at the Microsoft link below on Windows, macOS, or Linux: [https://dotnet.microsoft.com/en-us/download/dotnet/8.0](https://dotnet.microsoft.com/en-us/download/dotnet/8.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests can be executed from the command line using the `dotnet` command,
    or via the Test Explorer in Visual Studio if you’re using Windows.
  prefs: []
  type: TYPE_NORMAL
- en: To set up Visual Studio 2022, please refer to the *Development environment setup*
    section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter11](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/ae2e0ad9324ff4e05b1508090fe3cda77ad47ccf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the source code of this chapter, we can use the below command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To find out more about the source code in this book, please refer to the section
    *Managing the source code in this book* in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To develop unit test cases, it is common to utilize a unit test framework to
    enhance efficiency. There are several unit test frameworks available in the .NET
    environment, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Test Framework** (**MSTest**) comes bundled with Visual Studio.
    The initial version of MSTest (V1) was not an open-source product, and it first
    appeared alongside the release of Visual Studio 2005\. For more information about
    MSTest (V1), please refer to the book Microsoft Visual Studio 2005 Unleashed by
    Lars Powers and Mike Snell. Later, Microsoft made the MSTest (V2) open-source,
    hosting it on GitHub, with the first release becoming available around 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NUnit** is an open-source testing framework ported from JUnit. It was the
    inaugural unit test framework for .NET, with its earliest releases hosted on SourceForge
    in 2004\. For more information on version 2.0, please refer to the release notes
    in the *Further reading* section. The latest releases have since been moved to
    GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xUnit** is a modern and extensible framework developed by Jim Newkirk and
    Brad Wilson, the creators of NUnit. They made significant improvements to this
    new test framework compared to NUnit. To find out more about these enhancements,
    please refer to Jim’s blog, *Why Did we Build xUnit 1.0*? The first stable release
    of xUnit was available around 2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these frameworks are quite popular and can be selected according to the
    project’s requirements. In this chapter, we will utilize xUnit to develop unit
    test cases, as it is a more recent framework that offers numerous enhancements
    compared to NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the unit test framework you select, the process of developing
    unit tests is rather consistent. Even if you employ a different framework for
    your project, this chapter’s content remains applicable. Unit test cases are designed
    to run exclusively on cross-platform target frameworks instead of platform-specific
    ones. In this book, we utilize .NET 8.0; therefore, the target framework for unit
    testing is `net8.0`, as opposed to `net8.0-android` or `net8.0-ios`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will first develop unit tests for the model layer, which
    is common to both XAML and Blazor. Subsequently, we will introduce unit test development
    for Blazor apps using bUnit. bUnit is a versatile testing library compatible with
    all three test frameworks: xUnit, NUnit, and MSTest.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the unit test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To gain some practical experience, let’s create a unit test project. We can
    create a xUnit project using either Visual Studio or the .NET command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with Visual Studio, we can add a new project to our current solution,
    as shown in *Figure 11.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Creating a xUnit project](img/B21554_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Creating an xUnit project using Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: To begin, type `xunit` into the search box and select **xUnit Test Project**
    for C#.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the following screen, name the project `PassXYZ.Vault.Tests` and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subsequently, set the framework to .NET 8.0 and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re using Visual Studio Code, the first step is to install the .NET MAUI
    extension in your environment. Once the extension is installed, you can navigate
    through your project using Solution Explorer, akin to how you would in Visual
    Studio. Please be aware that the .NET MAUI extension is still in the preview stage
    as of March 2024.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an xUnit project, click the **+** button located in the solution.
    This action will reveal a list of project templates, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21554_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1a – Creating an xUnit project using Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the project using a command line, we should first create the folder
    and then utilize a .NET command to establish the project, as demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After creating the project, we can utilize the `dotnet test` command to run
    the test cases. The default test case in the template will be executed, and we
    will proceed to add more test cases to this project. Our test targets incorporate
    components from both the `PassXYZ.Vault` and `PassXYZ.BlazorUI` projects, hence
    requiring us to include these two projects as reference projects. The target framework
    of `PassXYZ.BlazorUI` is `net8.0`, allowing us to add it directly. However, as
    the target frameworks of `PassXYZ.Vault` are platform-specific, we must implement
    some modifications before incorporating them as references in `PassXYZ.Vault.Tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need to build the unit test against the target framework `net8.0`, it
    is necessary to modify the `PassXYZ.Vault.csproj` file to include `net8.0` as
    one of the target frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When building the `PassXYZ.Vault` project on supported platforms, we anticipate
    an executable, as it is an app. However, when building `PassXYZ.Vault` for the
    `net8.0` target framework, we aim to test it. `PassXYZ.Vault` should be generated
    as a library so that the test framework can utilize it to run test cases. In this
    instance, we expect to build a file with a `.dll` extension instead of `.exe`,
    which necessitates the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding build setup, a condition has been added to verify the target
    framework for the output type. If the target framework is not `net8.0`, the build
    output will be generated as an executable. Conversely, if the target framework
    is set to `net8.0`, a library will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making these changes, we can add reference projects to `PassXYZ.Vault.Tests`
    by either right-clicking on the solution node and selecting **Add** -> **Project
    Reference**, or by editing the project file for `PassXYZ.Vault.Tests` to include
    these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the MAUI project, it is also necessary to add the following
    configuration to the `PassXYZ.Vault.Tests` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully set up the xUnit project. Next, let’s proceed to add
    our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Developing test cases for the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use xUnit as a unit testing tool for our app. It provides a comprehensive
    and efficient way to run tests sequentially in isolation from each other, supporting
    both desktop and mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Two fundamental concepts in xUnit are `Fact` and `Theory`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Fact` in xUnit refers to a parameterless test method that confirms the correctness
    of certain conditions in code. It states that something should always be true.
    A “fact” test always runs every time the test suite runs as they are supposed
    to be invariant conditions, regardless of the data state at the execution time.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `Theory` allows parameterized tests to be conducted. It allows
    developers to run a single test method multiple times with different sets of data,
    reducing code redundancy while enhancing coverage. It is based on the idea that
    if the test method’s contract is true for a specific dataset, it should be true
    for all datasets.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by adding test cases to examine the model layer, as the test case
    setup for the model layer is identical in both the XAML and Blazor versions of
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the model layer, the primary implementation resides within the `PassXYZLib`
    library. For more information on the unit test cases at the model layer, please
    refer to the `PassXYZLib` source code: [https://github.com/shugaoye/PassXYZLib](https://github.com/shugaoye/PassXYZLib).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, `IDataStore` is the interface used to export `PassXYZLib`. Therefore,
    let’s incorporate test cases to test this interface, `IDataStore`. To assess the
    `IDataStore` interface, we can establish a new test class, `DataStoreTest`, within
    the `PassXYZ.Vault.Tests` project. We can add a new test case by testing “the
    addition of an item” as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'xUnit employs attributes to inform the framework about test case configurations.
    In this test case, we utilize the `[Fact]` attribute **(1)** to designate this
    method as a test case. To define a test case, we can follow a common pattern –
    `Arrange`, `Act`, and `Assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Arrange` **(2)** – We will prepare all necessary setup for the test. To add
    an item, we need to initialize the `IDataStore` interface first, and then we will
    define a variable to hold the item type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Act` **(3)** – We execute the methods that we want to test, which are `CreateNewItem`
    and `AddItemAsync`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert` **(4)** – We check the result that we expected. In our case, we try
    to retrieve the new item using `item.Id`. After that, we check to ensure that
    the item ID retrieved is the same as what we expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, we tested the `Entry` type in the previous test case.
    The `Entry` type is only one of the item types – we have many. To test all of
    them, we need to create many test cases. xUnit supports another test case type,
    `[Theory]`, which helps us to test different scenarios with one test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the “delete an item” test case to demonstrate how to test different
    scenarios in one test case with the `[Theory]` attribute. In this test case, we
    can delete an item in different item types in one test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we create a test case using the `[Theory]` attribute, **(1)**, we can pass
    different item types using the `itemSubType` parameter. The value of the `itemSubType`
    argument is defined using the `[InlineData]` attribute, **(2)**.
  prefs: []
  type: TYPE_NORMAL
- en: To arrange test data, we create a new item using the `itemSubType` argument,
    **(3)**. Then, we execute the `DeleteItemAsync` method, **(4)**, which is the
    one that we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check the return value, **(5)**. If the item is deleted successfully,
    the result is true. Otherwise, the result is false.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the process of creating a test case using the `[Fact]` attribute,
    as well as how to address different scenarios with the `[Theory]` attribute. In
    the next section, we will delve into further topics related to test case development.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing context between tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous test cases, we created a new `IDataStore` instance for each
    test. Is it possible to share one `IDataStore` instance, instead of repeatedly
    creating the same instance for every test? By sharing the test setup among a group
    of test cases in xUnit, we can minimize duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods for sharing setup and cleanup code between tests in
    xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor** and **Dispose**`:` We can use a class constructor to share
    the setup and cleanup code without sharing instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Fixture**`:` We can use a fixture to share object instances in a single
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection Fixtures**`:` We can use collection fixtures to share object instances
    in multiple test classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing using a constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove the duplicated setup code from the previous tests, we can move the
    creation of the `IDataStore` instance to the constructor of the `DataStoreTests`
    test class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we added a private member variable, `datastore`, and created
    an instance of `IDataStore` in the constructor of `DataStoreTests`. We also added
    a debug output so we can monitor the creation of the `IDataStore` interface. Let
    us debug the execution of the `DataStoreTests` class so we can see the debug output
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the debug output that a `DataStoreTests` class is created for
    each test case. There is no difference whether we create the instance of `IDataStore`
    inside the test method or in the constructor. All the test cases are still isolated
    from each other. When we use the `[Theory]` attribute to test different scenarios
    with one method, each of them looks like a separate test case at runtime. To understand
    this better, we can use the `dotnet` command to list all the defined tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that each parameter defined by the `[InlineData]` attribute is shown
    as a separate test case. They are all isolated test cases at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: After we list all the tests, we can selectively execute them using the `dotnet`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to run all the tests in the `DataStoreTests` class, we can use this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to run `Add_Item` tests only, we can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the debug output, even though we created an instance of `IDataStore`
    in the constructor, the instance is re-created for each test. The instances created
    in the test class constructor won’t be shared across tests. Even though the effect
    is still the same, the code looks more concise.
  prefs: []
  type: TYPE_NORMAL
- en: However, in certain scenarios, we may want to share instances across multiple
    tests. To achieve this, we can utilize class fixtures. In the following section,
    we will examine these specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing using class fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When utilizing a tool across all test cases, it can be more efficient to share
    the setup among them rather than creating the same one each time. Let’s use a
    logging function as an example to illustrate this approach.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a test report, we aim to create a test log that monitors the execution
    of unit tests. The `Serilog` library is the one which can be used for this purpose.
    `Serilog` enables us to log messages to different channels. In order to use `Serilog`,
    we must first set it up and then clean it up after all the tests have been executed.
    In this scenario, we prefer to share a single instance of `Serilog` between all
    the tests instead of creating one for each test. This setup allows us to produce
    a consolidated log file for all the tests rather than generating multiple log
    files for each individual test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate `Serilog`, we need to add the `Serilog` package to the project.
    This can be accomplished by executing the following `dotnet` commands in the project’s
    `PassXYZ.Vault.Tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the `Serilog` libraries to the project, we can now create a class
    fixture, `SerilogFixture`, for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use class fixtures, we can create them using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new class as the fixture class and add the setup code to the
    constructor. Here, we created a fixture class, `SerilogFixture`, **(1)**, and
    initialized the `ILogger` interface, **(2)**, in the constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we need to clean up the setup after the test case execution, we need
    to implement the `IDisposable` interface for the fixture class and put the cleanup
    code in the `Dispose` method. We implemented `IDisposable` in `SerilogFixture`
    and called the `Serilog` function, `Log.CloseAndFlush`, **(3)**, in the `Dispose`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the fixture, the test case needs to implement the `IClassFixture<T>`
    interface. We implemented this in the `DataStoreTests` test class, **(4)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access the fixture instance, we can add it as a constructor argument and
    it will be provided automatically. In the constructor of `DataStoreTests`, **(5)**,
    we assign the argument to the private member variable, `serilogFixture`, **(6)**.
    In test cases, we can access `Serilog` using this variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify this setup, we replaced all our debug output with `Serilog` `Debug`.
    After executing the tests in `DataStoreTests`, we can see the log messages here
    in the `xunit_log.txt` log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, the `SerilogFixture` class is initialized only once, allowing
    its instance to be utilized in all tests within `DataStoreTests`. This is in contrast
    to the `IDataStore` interface, which is initialized for each individual test.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing using collection fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Utilizing class fixtures, as demonstrated in the previous section, allows us
    to share the test setup context within a single test class. However, there may
    be instances where we need to share the test setup across multiple test classes.
    In such cases, we can employ collection fixtures to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `Serilog`, we can utilize it across multiple test classes, allowing
    us to view all log messages in a single log file. To achieve a unified `Serilog`
    setup for all test classes, we can implement collection fixtures in our project.
    By employing collection fixtures, we can create two new classes, `SerilogFixture`
    and `SerilogCollection`, within the `PassXYZ.Vault.Tests` project, as demonstrated
    in *Listing 11.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.1: `SerilogFixture.cs` ([https://epa.ms/SerilogFixture11-1](https://epa.ms/SerilogFixture11-1))'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement collection fixtures, we can follow the steps outlined below:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class file, `SerilogFixture.cs`, that houses both the `SerilogFixture`
    and `SerilogCollection` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorate the collection definition class, `SerilogCollection`, with the `[CollectionDefinition]`
    attribute **(1)** and assign it a unique name to help identify the test collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the collection definition class, `SerilogCollection`, implements
    the `ICollectionFixture<T>` interface **(2)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To utilize a collection fixture, we can implement the following modifications
    to our test classes:'
  prefs: []
  type: TYPE_NORMAL
- en: We can attach the `[Collection]` attribute to all test classes that will be
    incorporated into the collection. We designate `Serilog collection` as the name
    for the test collection definition within the attribute. In our case, as displayed
    in *Listing 11.2*, we append a `[Collection("Serilog collection")]` attribute
    **(1)** to the `DataStoreTests` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access the fixture instance, we can follow the same approach as in the previous
    section with class fixtures by including it as a constructor argument. It will
    then be provided automatically. In the `DataStoreTests` constructor, we assign
    a `fixture` argument to the `serilogFixture` variable **(2)**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to save space, the full code is not provided in *Listing 11.2*. The
    absent parts are indicated with the “...” symbol. The `Add_Item` test case was
    constructed using `Fact` to examine the creation of an entry. The `Create_Item`
    and `Delete_Item` test cases both employ `Theory`, enabling us to test a variety
    of items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.2: `DataStoreTests.cs` ([https://epa.ms/DataStoreTests11-2](https://epa.ms/DataStoreTests11-2))'
  prefs: []
  type: TYPE_NORMAL
- en: Through these examples, we have demonstrated how to create unit tests in the
    model layer. The knowledge we have acquired thus far can also be applied to unit
    testing in other .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: Having concluded the introduction to the model layer unit testing, we will proceed
    to explore the Razor component unit testing using the bUnit library in the next
    part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mock .NET MAUI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In developing unit tests for .NET MAUI, we will present test case development
    for both XAML-based and Blazor-based apps. In both instances, we will incorporate
    the MVVM pattern in the design. The unit test cases at the model layer are identical
    for both; however, testing the view and the view model differs significantly.
    Developing unit test cases for the view and the view model in a XAML-based app
    can be quite complex. To test the view model, it is necessary to resolve the dependencies
    of XAML components. For instance, in the XAML version of our app, we need to invoke
    `Shell` navigation methods within the view model, as demonstrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To address dependencies in `Xamarin.Forms`, an open-source project, `Xamarin.Forms.Mocks`,
    is available to help mock `Xamarin.Forms` components. In the case of .NET MAUI
    XAML apps, we require a similar solution for developing unit test cases for the
    view model, but currently, an equivalent does not seem to exist. Furthermore,
    there is a native user interface test framework, `Xamarin.UITest`, specifically
    for Android and iOS. However, it is not yet compatible with .NET MAUI. Additionally,
    since `Xamarin.UITest` is not a cross-platform solution, it will not be discussed
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: To partially address the dependency issue related to the view model test in
    this book, we can reference the .NET MAUI source code directly. Found at [https://github.com/dotnet/maui](https://github.com/dotnet/maui),
    this source code includes the original unit test code containing mock .NET MAUI
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have incorporated some elements from the .NET MAUI source code into the unit
    test project `PassXYZ.Vault.Tests`. To resolve the `Shell` navigation issue in
    the view model, the following code from `PassXYZ.Vault.Tests/maui/ShellTestBase.cs`
    is included:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `NewItemViewModel` tests, we can incorporate the `ShellTestBase` class
    with the following namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After implementing the namespace above, a mock `Shell` can be created using
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have a mock `Shell` instance, we can use this mock `Shell` instance
    in the following test case:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a Blazor Hybrid app, we don’t have the above issue. We have access to a
    reliable testing library called bUnit, which can be utilized for testing Razor
    components. This allows us to develop unit test cases for the view, view model,
    and model layers for Blazor apps.
  prefs: []
  type: TYPE_NORMAL
- en: Razor component testing using bUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET MAUI development, we cannot create unit test cases for all view and
    view model layers in XAML-based UI components; however, this is possible with
    Blazor. bUnit is an exceptional test library that can be employed for developing
    unit tests for Razor components. The bUnit library facilitates the creation of
    unit test cases for Razor components using xUnit, NUnit, or MSTest. Throughout
    the remainder of this chapter, we will utilize xUnit in conjunction with bUnit.
    The structure of unit test cases using bUnit bears similarity to the xUnit test
    cases we discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remainder of this chapter, we will focus on testing the following Razor
    components, which were created in the second part of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Razor components in the `PassXYZ.BlazorUI` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor components in the `PassXYZ.Vault` project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test Razor components using bUnit, it is necessary to modify the project
    configuration of `PassXYZ.Vault.Tests`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the project configuration for bUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To establish the test environment, we must add the bUnit and Moq packages,
    as well as updating the SDK type. The following modifications can be made to the
    xUnit `PassXYZ.Vault.Tests` testing project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add bUnit to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To incorporate the bUnit library into the project, first navigate to the project
    folder, then execute the following command from a console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, we need to include the Moq package, which is a mocking library
    that will be utilized during the test setup process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the project configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test the Razor components, we also need to change the project’s SDK to `Microsoft.NET.Sdk.Razor`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `PassXYZ.Vault.Tests.csproj` project file, we need to replace the following
    line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we have the project configuration ready, we can create a simple unit test
    case using bUnit to test our Razor components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bUnit test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our PassXYZ.Vault app, there are two types of Razor components that can be
    tested. The shared Razor components are located in the `PassXYZ.BlazorUI` project
    and serve as generic Razor components, which can be utilized across different
    projects. The second set of Razor components can be found in the `Pages` folder
    of the `PassXYZ.Vault` project. These components are specific to the `PassXYZ.Vault`
    app and make use of shared components from the `PassXYZ.BlazorUI` project.
  prefs: []
  type: TYPE_NORMAL
- en: To test the Razor components within the `PassXYZ.BlazorUI` project, we can examine
    each component individually. These test cases are unit test cases. The Razor components
    located in the `Pages` folder of the `PassXYZ.Vault` project serve as UI pages.
    Since these pages utilize UI components from other packages, they possess more
    dependencies. Consequently, these test cases can be regarded as integration test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s first create a test case for the `ModalDialog` Razor component
    in the `PassXYZ.BlazorUI` project. To test `ModalDialog`, we can generate an xUnit
    test class called `ModalDialogTests`, as illustrated in *Listing 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.3: `ModalDialogTests.cs` ([https://epa.ms/ModalDialogTests11-3](https://epa.ms/ModalDialogTests11-3))'
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the `ModalDialogTests` unit test class, it bears a strong resemblance
    to the unit test class created for the model layer. We reuse the collection fixture
    established earlier and initialize it in the constructor. In the `ModalDialogInitTest`
    test case, we continue to employ the `Arrange`, `Act`, and `Assert` pattern for
    the implementation of the test case.
  prefs: []
  type: TYPE_NORMAL
- en: All bUnit test classes inherit from `TestContext` **(1)**. During the `Arrange`
    phase, we initialize a local `title` variable, **(2)**, with a predefined string.
    In the `Act` phase, we call a generic method, `RenderComponent<T>`, **(3)**, and
    use the `ModalDialog` type as the type parameter. We pass the `title` variable,
    **(4)**, as the component parameter. The outcome of `RenderComponent<T>` is stored
    in the `cut` variable. In the `Assert` phase, we confirm that the title text after
    rendering is consistent with the argument we pass, utilizing the bUnit method
    `Find` **(5)**. The bUnit method `Find` can be used to find any HTML tag. In `ModalDialog`,
    the title is rendered as an `<h5>` HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ModalDialogInitTest` test case, we observe the structure of the bUnit
    tests. For bUnit tests, we first render the component being tested. The rendering
    outcome is stored in the `cut` variable, **(3)** which is an instance of the `IRenderedComponent`
    interface. To verify the result, we can refer to the properties or invoke the
    methods of the `IRenderedComponent` instance.
  prefs: []
  type: TYPE_NORMAL
- en: When Razor components are rendered in the `TestContext`, they exhibit the same
    lifecycle as any other Razor component. We can pass parameters to the components
    being tested, and they can generate output akin to their behavior in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when rendering the `ModalDialog` component, we can
    pass component parameters to it using the `Add` method, which belongs to the parameter
    builder of the `ComponentParameterCollectionBuilder<TComponent>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering simple components using C# code may not pose a problem. However, when
    passing multiple parameters to a component, using C# code can be inconvenient.
    By employing bUnit, we can develop test cases in Razor files, which significantly
    improves the experience of unit test development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test cases in Razor files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create tests directly in Razor markup files, we can declare components using
    Razor markup, similar to how we utilize them within a Razor page. This approach
    eliminates the need to call Razor components in the C# code or pass parameters
    using function calls. For a Razor page, we can render Razor components using **Razor
    templates**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate the process of creating tests in Razor markup files by developing
    test cases for a more complex `EditorDialog` component. We previously created
    the `EditorDialog` component in *Chapter 10*, *Implementing Razor Components*.
    In *Listing 11.4*, we will examine the unit tests for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.4: `EditorDialogTests.razor` ([https://epa.ms/EditorDialogTests11-4](https://epa.ms/EditorDialogTests11-4))'
  prefs: []
  type: TYPE_NORMAL
- en: We can develop a new Razor component, called `EditorDialogTests`, within the
    `PassXYZ.Vault.Tests` project. As it serves as a bUnit test class, it is a child
    class of `TestContext` **(1)**. Within this class, we generate test cases in a
    code block by utilizing **Razor templates**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first examine the `Edit_OnClose_Clicked` test case. In this scenario,
    we initially render the `EditorDialog` component and then proceed to test the
    close button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the `EditorDialog` component, we invoke the `Render` method **(2)**
    of `TestContext`. Compared to the previous example, in this case, we can render
    the Razor markup directly rather than calling the C# function. The Razor markup
    utilized here is referred to as **Razor templates**. For more information about
    Razor templates, refer to the following Microsoft documentation: [https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '`Razor templates` can be defined in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It consists of an `@` symbol and a pair of open and closed HTML tags. Razor
    templates can be used in the code block of the Razor file. They cannot be used
    in a C# or C# code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After `EditorDialog` is rendered, we can find the close button and simulate
    the click action, **(3)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the `OnCloseHandler` event handler, the `_isOnCloseClicked` variable, **(4)**,
    is set to `true` so that we can assert the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Edit_With_KeyEditingEnabled` test case, **(5)**, after the component
    is rendered, we can simulate user interactions to set the key and value fields
    in the component. After that, we can simulate clicking on the save button as we
    can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Upon clicking the button, the event handler is triggered. Within the `OnSaveClicked`
    event handler, we receive the modified key and value, enabling us to assert the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As evidenced by these two test cases, designing bUnit tests becomes more straightforward
    when creating tests within a Razor file. By utilizing Razor templates, we can
    render components and also simulate various user interactions, enabling us to
    test the components interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Razor templates serve as an excellent tool for combining Razor markup and C#
    code, allowing us to benefit from the strengths of both approaches. However, there
    are certain limitations when using Razor templates. In the next section, we will
    explore how to overcome these constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RenderFragment delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Razor templates can help to simplify test setups, they have their limitations,
    especially in complex test case scenarios. With intricate test cases, Razor templates
    can become quite lengthy. If we intend to reuse the same Razor templates in another
    test case, we would need to copy them, potentially resulting in a significant
    amount of duplicated code. This is one of the main drawbacks of using Razor templates.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can use a `RenderFragment` delegate. As its name indicates,
    it is the delegate type of `RenderFragment` or `RenderFragment<TValue>`. The data
    type of Razor templates is `RenderFragment` or `RenderFragment<TValue>`. A `RenderFragment`
    delegate is the delegate type for Razor templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the `RenderFragment` delegate in the following
    Microsoft document: [https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2](https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2).'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to use the `RenderFragment` delegate, let’s set up a more
    complex test for the `EditorDialog` component. `EditorDialog` can be used to edit
    either `Item` or `Field`. We can use an item-editing case to show how to use the
    `RenderFragment` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the option to create a new test class, `ItemEditTests`, within the
    `PassXYZ.Vault.Tests` project. To differentiate the Razor markup and C# code,
    we can divide the `ItemEditTests` test class into a Razor file (`ItemEditTests.razor`)
    and a C# code-behind file (`ItemEditTests.razor.cs`). The markup designated for
    testing can be declared in the Razor file, as demonstrated in *Listing 11.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.5: `ItemEditTests.razor` ([https://epa.ms/ItemEditTests11-5](https://epa.ms/ItemEditTests11-5))'
  prefs: []
  type: TYPE_NORMAL
- en: We define a `RenderFragment` delegate, `_editorDialog`, in the `@code` block
    of `ItemEditTests.razor`. The `RenderFragment` delegate must accept a parameter
    called `__builder` of the `RenderTreeBuilder` type. In the markup code, we can
    access the variables defined in the test class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the usage of `_editorDialog` in the C# code-behind file in
    *Listing 11.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.6: `ItemEditTests.razor.cs` ([https://epa.ms/ItemEditTests11-6](https://epa.ms/ItemEditTests11-6))'
  prefs: []
  type: TYPE_NORMAL
- en: Since `_editorDialog` defines the `Item` editing, we can develop multiple test
    cases for it. We can see that we render `_editorDialog`, **(1)**, for multiple
    test cases, such as `Edit_New_Item` and `Edit_Existing_Item`. By employing the
    `RenderFragment` delegate, our testing code appears more elegant and streamlined.
    Without taking this approach, we would need to replicate lengthy markup code in
    multiple locations. Directly using C# code may result in even more duplication
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: In both test cases, we employ a similar process to test the `EditorDialog` by
    setting values and then clicking the `Save` button. In the markup code, we have
    a `<select>` tag defined. We can change the option, **(2)**, of the `<select>`
    tag within the test code. This `<select>` tag is conditionally rendered based
    on the value of the `isNewItem` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Edit_Existing_Item` test, we can also examine the negative case when
    the `isNewItem` variable,**(3)**, is set to `false`. In this instance, an exception
    is raised since the `<select>` tag is not rendered. We can observe that bUnit
    can also be utilized to test negative cases by verifying the content of the exception,
    **(4)**.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples, we developed bUnit tests for the shared components
    in the `PassXYZ.BlazorUI` project. As these shared components serve as reusable
    building blocks for a high-level UI, many of them declare numerous component parameters.
    Utilizing the `RenderFragment` delegate or **Razor templates** can aid in simplifying
    the test setup process.
  prefs: []
  type: TYPE_NORMAL
- en: Upon examining the Razor pages within the `Pages` folder of the `PassXYZ.Vault`
    project, we find that `Items`, `ItemDetail`, and `Login` also function as Razor
    components. However, they are not designed for reuse. These Razor pages feature
    defined route templates and lack an extensive range of component parameters. The
    component parameters present in these Razor pages serve routing purposes. When
    designing test cases for these Razor pages, it is advisable to implement tests
    in a C# class instead of Razor files.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Razor pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the development testing of Razor pages, we will become familiar with
    some highly beneficial bUnit features. Since it is not possible to review all
    the tests of Razor pages in our app, we will use `ItemDetail` as an example. `ItemDetail`
    is a Razor page designed to display the contents of a password entry, and it has
    a defined route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to display the `ItemDetail` page, we need to pass the `Id` info
    for an `Item` instance to it, and this instance cannot be a group. The initialization
    of the `ItemDetail` page is done in the `OnParametersSet()` lifecycle method,
    as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will develop an `ItemDetailTests` test class to cover all the execution
    paths in `OnParametersSet()`. To cover all the execution paths, we can find the
    following test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Test case 1`: Initialize the `ItemDetail` instance without a selected item
    `Id`. We will get an `InvalidOperationException` exception, **(1)**, in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test case 2`: Initialize the `ItemDetail` instance with the wrong item `Id`.
    In this case, we will get an `InvalidOperationException` exception, **(2)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test case 3`: Initialize the `ItemDetail` instance with a valid item `Id`,
    but the item type as a group. In this case, we will get an `InvalidOperationException`
    exception, **(3)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test case 4`: Initialize the `ItemDetail` instance with a valid item `Id`
    and the item type is an entry, **(4)**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can implement these test cases in an `ItemDetailTests` bUnit test class,
    as shown here in *Listing 11.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11.7: `ItemDetailTests.cs` ([https://epa.ms/ItemDetailTests11-7](https://epa.ms/ItemDetailTests11-7))'
  prefs: []
  type: TYPE_NORMAL
- en: The first test case is implemented in `Init_Empty_ItemDetail` **(3)**. During
    the test setup, we attempt to render the `ItemDetail` component directly without
    providing a selected item `Id`. We anticipate encountering an `InvalidOperationException`
    exception as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Before executing the test case, we must first address the `IDataStore` dependency.
    `ItemDetail` relies on the `IDataStore<Item>` interface, and we can resolve this
    through dependency injection. In our app, this dependency is registered within
    the `MauiProgram.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: With bUnit, dependency injection is supported using `TestContext`. We can register
    the dependency using `AddSingleton`, **(2)**. To isolate the test, we use the
    `Moq` mocking framework, **(1)**, to replace the actual implementation of `IDataStore`,
    so we can reduce the complexity of the test setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `Moq`, we only need to fake the method or property that we need in our
    test setup. It can help to isolate our tests from their dependencies. To use the
    `Moq` framework, we can create a `Moq` object using the interface or class that
    we need as a type parameter. Later, we can define the behavior of the target interface
    or class when we use it. In the constructor, we create a `Mock` object and register
    the `IDataStore<Item>` interface using `dataStore.Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After we register `IDataStore` in the constructor, we can execute the first
    test case again. This time, we can get the exception and verify the message is
    what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let us look at the second test case. In the second test case, we pass
    an invalid `Id` to `ItemDetail` and try to render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we also get an expected exception, and we can verify its content
    using `Assert.Equal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third test case, we provide a valid `Id` to `ItemDetail`, but the item
    is of a group type. This is a scenario that may be challenging to reproduce during
    an integration or user acceptance test. However, in a unit test, it is relatively
    simple to verify, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To test this, we need to create a group and assign it to a `testGroup` variable.
    In this test case, we must call the `GetItem` method of `IDataStore`. Since we
    mocked `IDataStore` in our setup, we also need to mock the `GetItem` method here.
    The `Moq` method returns `testGroup` when called. Once the test setup is prepared,
    we can render `ItemDetail` with `testGroup.Id`. The expected outcome of this test
    is the exception that we anticipate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final test case, we will pass a valid Item `Id` and the item type is
    an entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This test case is similar to the third test case, except we can create an entry
    and assign it to the `testEntry` variable. After we render `ItemDetail` with `testEntry.Id`,
    we can verify that the `<article>` rendered HTML tag is the one that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have explored testing Razor components using bUnit. It is evident
    that we can attain an impressively high level of test coverage with bUnit. This
    serves as one of the advantages of Blazor UI design.
  prefs: []
  type: TYPE_NORMAL
- en: We have now addressed all the topics related to unit test development with .NET
    MAUI in this chapter that we intended to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed unit test development for .NET MAUI apps. Although
    multiple test frameworks are available, we selected xUnit as our framework for
    this chapter. In the MVVM pattern, unit testing of the model layer is consistent
    with any other .NET application. We developed test cases for the `IDataStore`
    interface to evaluate our model layer. For unit testing the view and view model,
    we concentrated on the Blazor Hybrid app utilizing the bUnit test library. By
    combining the xUnit framework and bUnit library, we can develop end-to-end unit
    tests for a Blazor Hybrid app. With bUnit, we addressed topics such as Razor templates,
    the `RenderFragment` delegate, dependency injection, and the Moq framework.
  prefs: []
  type: TYPE_NORMAL
- en: With the understanding of unit testing acquired in this chapter, you should
    now be capable of developing your own unit tests. For more information on .NET
    unit test development, please refer to the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing can be integrated into a CI/CD pipeline. This setup allows unit
    tests to be executed automatically during the development process. We will explore
    this topic in greater detail in the upcoming chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Microsoft Visual Studio 2005 Unleashed* by Lars Powers and Mike Snell: [https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194](https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MSTest: [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Strengthening Visual Studio Unit Tests* by John Robbins: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests](https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NUnit Pocket Reference* by Bill Hamilton: [https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396](https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NUnit Releases at SourceForge: [https://sourceforge.net/projects/nunit/](https://sourceforge.net/projects/nunit/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why Did we Build xUnit 1.0:* [https://xunit.net/docs/why-did-we-build-xunit-1.0](https://xunit.net/docs/why-did-we-build-xunit-1.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'xUnit documentation: [https://xunit.net/](https://xunit.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'xUnit.NET 2.0 release note: [https://xunit.net/releases/2.0](https://xunit.net/releases/2.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
